{
  "tests": [
    {
      "name": "test_simple_url_for_getting",
      "module": "test_url_building",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_building.py",
      "line_number": 55,
      "end_line_number": 62,
      "source_code": "def test_simple_url_for_getting(simple_app):\n    for letter in string.ascii_letters:\n        url = simple_app.url_for(letter)\n\n        assert url == f\"/{letter}\"\n        request, response = simple_app.test_client.get(url)\n        assert response.status == 200\n        assert response.text == letter",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "string",
        "urllib.parse.parse_qsl",
        "urllib.parse.urlsplit",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert url == f'/{letter}'",
        "assert response.status == 200",
        "assert response.text == letter"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "simple_app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "simple_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_simple_url_for_getting` aims to verify the functionality of the `url_for` method in the `simple_app` instance, ensuring that it correctly generates URLs based on given route names and that the corresponding GET requests return the expected responses.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that for each letter in the ASCII alphabet, the `url_for` method generates a URL in the format `/{letter}`. It also verifies that making a GET request to this URL returns a response with a status code of 200 and that the response body matches the letter used in the URL.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes:\n- `simple_app.url_for(letter)`: This method constructs a URL based on the provided route name (in this case, each letter). The expected output is a string representing the URL path.\n- `simple_app.test_client.get(url)`: This method simulates a GET request to the generated URL and returns a tuple containing the request and the response. The response is then checked for its status and content.\n\nThe relevant route defined in the application is:\n```python\n@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')\n```\nHowever, the actual route handling for each letter is not explicitly shown in the provided code, suggesting that the `url_for` method is expected to resolve to a route that returns the letter itself.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterized Testing**: The test iterates over all ASCII letters, effectively testing multiple cases in a single test function.\n- **Assertions**: The test uses assertions to validate both the URL generation and the response from the GET request, ensuring that both the URL and the response content are as expected.\n- **Test Client**: The use of `simple_app.test_client` allows for simulating HTTP requests, which is a common practice in testing web applications to verify endpoint behavior without needing to run a live server."
    },
    {
      "name": "test_simple_url_for_getting_with_more_params",
      "module": "test_url_building",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_building.py",
      "line_number": 74,
      "end_line_number": 82,
      "source_code": "def test_simple_url_for_getting_with_more_params(app, args, url):\n    @app.route(\"/myurl\")\n    def passes(request):\n        return text(\"this should pass\")\n\n    assert url == app.url_for(\"passes\", **args)\n    request, response = app.test_client.get(url)\n    assert response.status == 200\n    assert response.text == \"this should pass\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('args,url', [(URL_FOR_ARGS1, URL_FOR_VALUE1), (URL_FOR_ARGS2, URL_FOR_VALUE2), (URL_FOR_ARGS3, URL_FOR_VALUE3), (URL_FOR_ARGS4, URL_FOR_VALUE4)])"
      ],
      "arguments": [
        "app",
        "args",
        "url"
      ],
      "imports": [
        "string",
        "urllib.parse.parse_qsl",
        "urllib.parse.urlsplit",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert url == app.url_for('passes', **args)",
        "assert response.status == 200",
        "assert response.text == 'this should pass'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_simple_url_for_getting_with_more_params` is designed to verify that the Sanic application can correctly generate a URL for a specific route with multiple parameters and that the route responds as expected when accessed.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks two main behaviors: \n1. It ensures that the URL generated by `app.url_for` matches the expected URL when provided with specific route parameters.\n2. It confirms that a GET request to the generated URL returns a successful HTTP status (200) and the correct response body.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route `/myurl` that returns the text \"this should pass\". It then uses `app.url_for(\"passes\", **args)` to generate the URL for this route, passing in any additional parameters specified in `args`. The test asserts that this generated URL matches the expected `url`. Following this, it simulates a GET request to the generated URL using `app.test_client.get(url)` and checks that the response status is 200 and the response text is \"this should pass\".\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Route Definition within the Test**: The route is defined within the test function, allowing for isolated testing of specific behaviors without affecting other tests.\n- **Assertions**: The test employs assertions to validate both the URL generation and the response from the GET request, ensuring that both functionalities work as intended.\n- **Parameterization**: The test uses `args` to dynamically pass parameters to the URL generation, demonstrating flexibility in testing various scenarios with different parameters."
    },
    {
      "name": "test_url_for_with_server_name",
      "module": "test_url_building",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_building.py",
      "line_number": 85,
      "end_line_number": 98,
      "source_code": "def test_url_for_with_server_name(app):\n    server_name = f\"{test_host}:{test_port}\"\n    app.config.update({\"SERVER_NAME\": server_name})\n    path = \"/myurl\"\n\n    @app.route(path)\n    def passes(request):\n        return text(\"this should pass\")\n\n    url = f\"http://{server_name}{path}\"\n    assert url == app.url_for(\"passes\", _server=None, _external=True)\n    request, response = app.test_client.get(url)\n    assert response.status == 200\n    assert response.text == \"this should pass\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "string",
        "urllib.parse.parse_qsl",
        "urllib.parse.urlsplit",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert url == app.url_for('passes', _server=None, _external=True)",
        "assert response.status == 200",
        "assert response.text == 'this should pass'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_url_for_with_server_name` test is to verify that the `app.url_for` method correctly constructs a URL that includes the server name specified in the application's configuration. It ensures that the URL generation respects the server name and that the route can be accessed successfully.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a server name is set in the app's configuration, the generated URL for a specific route (`/myurl`) matches the expected format, including the server name. It also verifies that a GET request to this URL returns a successful response (HTTP status 200) with the expected content.\n\n**Code Being Tested and How It Works**:  \nThe code being tested includes the `app.url_for` method, which is responsible for generating URLs based on route names. The test sets the `SERVER_NAME` configuration, defines a route that returns a simple text response, and constructs the expected URL manually. It then asserts that the URL generated by `app.url_for` matches the manually constructed URL and checks the response from a GET request to that URL.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Setup and Teardown**: The test uses the `app` fixture to set up the application context, ensuring that the configuration and routes are properly initialized.\n- **Assertions**: It uses assertions to validate both the URL generation and the response from the HTTP request, ensuring that both aspects of the functionality are correct.\n- **Route Definition**: The route is defined within the test, demonstrating a common practice in unit tests where routes are set up specifically for the test's context, allowing for isolated testing of functionality."
    },
    {
      "name": "test_fails_if_endpoint_not_found",
      "module": "test_url_building",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_building.py",
      "line_number": 101,
      "end_line_number": 110,
      "source_code": "def test_fails_if_endpoint_not_found():\n    app = Sanic(\"app\")\n\n    @app.route(\"/fail\")\n    def fail(request):\n        return text(\"this should fail\")\n\n    with pytest.raises(URLBuildError) as e:\n        app.url_for(\"passes\")\n        e.match(\"Endpoint with name `app.passes` was not found\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "string",
        "urllib.parse.parse_qsl",
        "urllib.parse.urlsplit",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_fails_if_endpoint_not_found` is designed to verify that the Sanic application correctly raises a `URLBuildError` when attempting to generate a URL for a non-existent endpoint. This ensures that the application handles routing errors gracefully and provides appropriate feedback to the developer.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that when the `url_for` method is called with an endpoint name that has not been defined (in this case, \"passes\"), the application raises a `URLBuildError`. Additionally, it verifies that the error message accurately reflects the issue, indicating that the endpoint with the specified name was not found.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `url_for` method of the Sanic application instance. The method is expected to construct a URL based on the provided endpoint name. In this test, the application defines a route for \"/fail\" but does not define a route for \"passes\". When `app.url_for(\"passes\")` is called, it should trigger the error handling mechanism of the Sanic framework, resulting in a `URLBuildError` being raised.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that a specific exception is raised during the execution of the code block. This is a common pattern in unit testing that allows for clean and readable assertions about expected exceptions. Additionally, the use of `e.match` allows for verification of the exception message, ensuring that not only is the correct type of exception raised, but that it also contains the expected content, providing further confidence in the robustness of the error handling."
    },
    {
      "name": "test_fails_url_build_if_param_not_passed",
      "module": "test_url_building",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_building.py",
      "line_number": 113,
      "end_line_number": 130,
      "source_code": "def test_fails_url_build_if_param_not_passed(app):\n    url = \"/\"\n\n    for letter in string.ascii_lowercase:\n        url += f\"<{letter}>/\"\n\n    @app.route(url)\n    def fail(request):\n        return text(\"this should fail\")\n\n    fail_args = list(string.ascii_lowercase)\n    fail_args.pop()\n\n    fail_kwargs = {fail_arg: fail_arg for fail_arg in fail_args}\n\n    with pytest.raises(URLBuildError) as e:\n        app.url_for(\"fail\", **fail_kwargs)\n        assert e.match(\"Required parameter `z` was not passed to url_for\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "string",
        "urllib.parse.parse_qsl",
        "urllib.parse.urlsplit",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert e.match('Required parameter `z` was not passed to url_for')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_fails_url_build_if_param_not_passed` is designed to verify that the URL building functionality of the Sanic application correctly raises an error when a required parameter is not provided. Specifically, it checks that the application raises a `URLBuildError` when attempting to generate a URL for a route that expects all parameters to be passed.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the application enforces the requirement for all parameters defined in a route to be supplied when calling the `url_for` method. It verifies that the error message returned is specific and informative, indicating which parameter was missing.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves a route defined with dynamic parameters, where each letter of the alphabet is expected as a parameter in the URL. The route is defined as `/<a>/<b>/<c>/.../<z>/`, and the test attempts to call `app.url_for(\"fail\", **fail_kwargs)` without providing the last parameter (`z`). The `url_for` method is expected to raise a `URLBuildError` if any required parameters are missing, which is validated by the test.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of context management with `pytest.raises` to assert that an exception is raised during the execution of the `url_for` method. This pattern is effective for testing error conditions in a clean and readable manner. Additionally, the test uses string formatting to dynamically create the route and parameters, showcasing the flexibility of the testing approach in handling various scenarios. The use of assertions to match the error message further ensures that the test not only checks for the occurrence of an error but also validates its correctness."
    },
    {
      "name": "test_fails_url_build_if_params_not_passed",
      "module": "test_url_building",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_building.py",
      "line_number": 133,
      "end_line_number": 140,
      "source_code": "def test_fails_url_build_if_params_not_passed(app):\n    @app.route(\"/fail\")\n    def fail(request):\n        return text(\"this should fail\")\n\n    with pytest.raises(ValueError) as e:\n        app.url_for(\"fail\", _scheme=\"http\")\n        assert e.match(\"When specifying _scheme, _external must be True\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "string",
        "urllib.parse.parse_qsl",
        "urllib.parse.urlsplit",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert e.match('When specifying _scheme, _external must be True')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_fails_url_build_if_params_not_passed` is designed to verify that the `app.url_for` method raises a `ValueError` when the `_scheme` parameter is provided without the `_external` parameter being set to `True`. This ensures that the URL building logic enforces the correct usage of parameters.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that when the `_scheme` parameter is specified (in this case, set to `\"http\"`), the method correctly raises a `ValueError` with the message \"When specifying _scheme, _external must be True\" if `_external` is not provided or is set to `False`. This behavior is crucial for maintaining the integrity of URL generation in the application.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `app.url_for` method, which is responsible for generating URLs based on the provided endpoint name and parameters. In this test, a route named `\"fail\"` is defined, which is intended to simulate a scenario where URL generation fails due to incorrect parameter usage. The test then attempts to call `app.url_for(\"fail\", _scheme=\"http\")`, expecting it to raise a `ValueError` due to the missing `_external` parameter.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that a specific exception is raised during the execution of the code block. This is a common pattern in unit testing that allows for clean and readable assertions about expected exceptions. Additionally, the use of `assert e.match(...)` checks that the raised exception contains the expected error message, ensuring that not only is the correct exception raised, but it also conveys the appropriate information about the error."
    },
    {
      "name": "test_fails_with_int_message",
      "module": "test_url_building",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_building.py",
      "line_number": 157,
      "end_line_number": 172,
      "source_code": "def test_fails_with_int_message(app):\n    @app.route(COMPLEX_PARAM_URL)\n    def fail(request):\n        return text(\"this should fail\")\n\n    failing_kwargs = dict(PASSING_KWARGS)\n    failing_kwargs[\"foo\"] = \"not_int\"\n\n    with pytest.raises(URLBuildError) as e:\n        app.url_for(\"fail\", **failing_kwargs)\n\n    expected_error = (\n        r'Value \"not_int\" for parameter `foo` '\n        r\"does not match pattern for type `int`: ^-?\\d+$\"\n    )\n    assert str(e.value) == expected_error",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "string",
        "urllib.parse.parse_qsl",
        "urllib.parse.urlsplit",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(e.value) == expected_error"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_fails_with_int_message` is designed to verify that the URL building functionality of the Sanic application correctly raises an error when a parameter expected to be an integer is provided as a non-integer string. Specifically, it checks that the error message returned is informative and matches the expected format.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when the `url_for` method is called with a parameter (`foo`) that does not conform to the expected integer type (in this case, a string \"not_int\"), a `URLBuildError` is raised. It also verifies that the error message accurately describes the issue, including the invalid value and the expected type pattern.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `url_for` method of the `app` object, which is responsible for generating URLs based on route definitions. The route defined by `COMPLEX_PARAM_URL` expects `foo` to be an integer. The test modifies the `failing_kwargs` dictionary to include a non-integer value for `foo` and then calls `app.url_for(\"fail\", **failing_kwargs)`. The expected behavior is that this call raises a `URLBuildError`, which is caught in the `with pytest.raises(...)` context manager.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Manager for Exception Testing**: The use of `with pytest.raises(URLBuildError) as e:` is a common pattern in pytest for asserting that specific exceptions are raised during the execution of a block of code.\n- **Error Message Verification**: The test captures the raised exception and checks its string representation against an expected error message, ensuring that the error handling provides clear feedback to the developer.\n- **Parameterized Input**: The test modifies the `failing_kwargs` dictionary to simulate invalid input, demonstrating how the application should respond to incorrect parameter types. This approach allows for easy adjustments to test various invalid inputs in a structured manner."
    },
    {
      "name": "test_passes_with_negative_int_message",
      "module": "test_url_building",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_building.py",
      "line_number": 175,
      "end_line_number": 188,
      "source_code": "def test_passes_with_negative_int_message(app):\n    @app.route(\"path/<possibly_neg:int>/another-word\")\n    def good(request, possibly_neg):\n        assert isinstance(possibly_neg, int)\n        return text(f\"this should pass with `{possibly_neg}`\")\n\n    u_plus_3 = app.url_for(\"good\", possibly_neg=3)\n    assert u_plus_3 == \"/path/3/another-word\", u_plus_3\n    request, response = app.test_client.get(u_plus_3)\n    assert response.text == \"this should pass with `3`\"\n    u_neg_3 = app.url_for(\"good\", possibly_neg=-3)\n    assert u_neg_3 == \"/path/-3/another-word\", u_neg_3\n    request, response = app.test_client.get(u_neg_3)\n    assert response.text == \"this should pass with `-3`\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "string",
        "urllib.parse.parse_qsl",
        "urllib.parse.urlsplit",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert u_plus_3 == '/path/3/another-word', u_plus_3",
        "assert response.text == 'this should pass with `3`'",
        "assert u_neg_3 == '/path/-3/another-word', u_neg_3",
        "assert response.text == 'this should pass with `-3`'",
        "assert isinstance(possibly_neg, int)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_passes_with_negative_int_message` is designed to verify that the Sanic application correctly handles and responds to requests with both positive and negative integer parameters in the URL. It ensures that the application can accept negative integers as valid input and returns the expected response.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the application correctly constructs URLs with negative integers and that the response text matches the expected output. It verifies that the route can handle both positive and negative integers without errors, confirming that the application logic is robust against different integer inputs.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route `good` that accepts an integer parameter `possibly_neg`. It asserts that this parameter is indeed an integer and returns a text response that includes the value of `possibly_neg`. The test then constructs URLs using `app.url_for` for both positive and negative integers and makes GET requests to these URLs using `app.test_client.get`. The expected responses are compared against the actual responses to ensure correctness.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs assertions to validate both the URL construction and the response content. It uses the `app.url_for` method to dynamically generate URLs based on route parameters, which is a common pattern in web application testing. Additionally, the test checks the type of the parameter using `isinstance`, ensuring that the application enforces type constraints correctly. The use of assertions to compare expected and actual values is a standard practice in unit testing to confirm that the code behaves as intended."
    },
    {
      "name": "test_fails_with_two_letter_string_message",
      "module": "test_url_building",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_building.py",
      "line_number": 191,
      "end_line_number": 204,
      "source_code": "def test_fails_with_two_letter_string_message(app):\n    @app.route(COMPLEX_PARAM_URL)\n    def fail(request):\n        return text(\"this should fail\")\n\n    failing_kwargs = dict(PASSING_KWARGS)\n    failing_kwargs[\"two_letter_string\"] = \"foobar\"\n\n    with pytest.raises(URLBuildError) as e:\n        app.url_for(\"fail\", **failing_kwargs)\n        e.match(\n            'Value \"foobar\" for parameter `two_letter_string` '\n            \"does not satisfy pattern ^[A-z]{2}$\"\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "string",
        "urllib.parse.parse_qsl",
        "urllib.parse.urlsplit",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_fails_with_two_letter_string_message` is designed to verify that the `app.url_for` method correctly raises a `URLBuildError` when provided with an invalid two-letter string parameter. Specifically, it checks that the error message generated is accurate and informative.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the URL building mechanism enforces parameter validation by rejecting inputs that do not conform to specified patterns. In this case, it confirms that a string longer than two letters (\"foobar\") fails to match the expected pattern of exactly two letters, and that the appropriate error message is returned.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `app.url_for` method, which constructs URLs based on route definitions and parameters. The relevant part of the implementation checks if the provided parameters match defined patterns. If a parameter does not match, it raises a `URLBuildError` with a message indicating the nature of the failure. The test sets up a route (`fail`) and attempts to call `url_for` with a parameter that violates the expected pattern.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that an exception is raised during the execution of `app.url_for`. This is a common pattern in unit testing to verify that specific error conditions are handled correctly. Additionally, the use of `e.match` allows for checking that the raised exception contains the expected error message, ensuring that not only is an error raised, but that it is the correct error with the appropriate context."
    },
    {
      "name": "test_fails_with_number_message",
      "module": "test_url_building",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_building.py",
      "line_number": 207,
      "end_line_number": 221,
      "source_code": "def test_fails_with_number_message(app):\n    @app.route(COMPLEX_PARAM_URL)\n    def fail(request):\n        return text(\"this should fail\")\n\n    failing_kwargs = dict(PASSING_KWARGS)\n    failing_kwargs[\"some_number\"] = \"foo\"\n\n    with pytest.raises(URLBuildError) as e:\n        app.url_for(\"fail\", **failing_kwargs)\n        e.match(\n            'Value \"foo\" for parameter `some_number` '\n            r\"does not match pattern for type \"\n            r\"`float`: ^-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)$\"\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "string",
        "urllib.parse.parse_qsl",
        "urllib.parse.urlsplit",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_fails_with_number_message` test is designed to verify that the `url_for` method of the Sanic application correctly raises a `URLBuildError` when an invalid value is provided for a parameter that is expected to be a float. Specifically, it checks that a string that cannot be converted to a float (in this case, \"foo\") triggers the appropriate error message.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the URL building mechanism enforces type constraints on parameters. It verifies that when a parameter (`some_number`) is provided with an invalid value, the system responds with a clear and specific error message indicating the nature of the failure, including the expected pattern for a float.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `url_for` method of the Sanic application, which constructs URLs based on route definitions and parameters. The relevant part of the implementation checks if the supplied parameter matches the expected pattern for its type (in this case, a float). If the parameter does not match, it raises a `URLBuildError` with a message that includes the invalid value and the expected pattern.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that an exception is raised during the execution of `app.url_for`. It also uses the `e.match` method to verify that the raised exception contains the expected error message, which is a common pattern in unit testing to ensure that not only is an error raised, but that it is the correct error with the appropriate message. This approach enhances the robustness of the test by checking both the occurrence of the error and its content."
    },
    {
      "name": "test_passes_with_negative_number_message",
      "module": "test_url_building",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_building.py",
      "line_number": 225,
      "end_line_number": 235,
      "source_code": "def test_passes_with_negative_number_message(app, number):\n    @app.route(\"path/<possibly_neg:float>/another-word\")\n    def good(request, possibly_neg):\n        assert isinstance(possibly_neg, (int, float))\n        return text(f\"this should pass with `{possibly_neg}`\")\n\n    u = app.url_for(\"good\", possibly_neg=number)\n    assert u == f\"/path/{number}/another-word\", u\n    request, response = app.test_client.get(u)\n    # For ``number``,it has been cast to a float - so a ``3`` becomes a ``3.0``\n    assert response.text == f\"this should pass with `{float(number)}`\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('number', [3, -3, 13.123, -13.123])"
      ],
      "arguments": [
        "app",
        "number"
      ],
      "imports": [
        "string",
        "urllib.parse.parse_qsl",
        "urllib.parse.urlsplit",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert u == f'/path/{number}/another-word', u",
        "assert response.text == f'this should pass with `{float(number)}`'",
        "assert isinstance(possibly_neg, (int, float))"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_passes_with_negative_number_message` is designed to verify that the Sanic application correctly handles and responds to routes that accept negative floating-point numbers as parameters. It ensures that the application can generate the correct URL and return the expected response when provided with various numeric inputs, including negative values.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks two main behaviors: \n1. The URL generation for a route that includes a floating-point parameter, ensuring that the generated URL matches the expected format.\n2. The response content of the route when accessed, confirming that the application correctly processes the floating-point parameter and returns the appropriate message.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route `good` that accepts a floating-point parameter `possibly_neg`. Inside the route, it asserts that the parameter is either an integer or a float and returns a text response that includes the value of `possibly_neg`. The test then uses `app.url_for` to generate the URL for this route with the provided `number` argument and checks if it matches the expected URL format. Finally, it simulates a GET request to the generated URL and asserts that the response text matches the expected output, which includes the float representation of the input number.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses `pytest.mark.parametrize` to run the same test logic with multiple values for `number`, including both positive and negative floats. This approach enhances test coverage and efficiency by reducing code duplication.\n- **Assertions**: The test employs assertions to validate both the URL generation and the response content, ensuring that the application behaves as expected under different input conditions.\n- **Route Definition within the Test**: The route is defined within the test function, allowing for isolated testing of specific behaviors without affecting the global application state. This encapsulation is a common practice in unit testing to maintain test independence."
    },
    {
      "name": "test_adds_other_supplied_values_as_query_string",
      "module": "test_url_building",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_building.py",
      "line_number": 238,
      "end_line_number": 252,
      "source_code": "def test_adds_other_supplied_values_as_query_string(app):\n    @app.route(COMPLEX_PARAM_URL)\n    def passes(request):\n        return text(\"this should pass\")\n\n    new_kwargs = dict(PASSING_KWARGS)\n    new_kwargs[\"added_value_one\"] = \"one\"\n    new_kwargs[\"added_value_two\"] = \"two\"\n\n    url = app.url_for(\"passes\", **new_kwargs)\n\n    query = dict(parse_qsl(urlsplit(url).query))\n\n    assert query[\"added_value_one\"] == \"one\"\n    assert query[\"added_value_two\"] == \"two\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "string",
        "urllib.parse.parse_qsl",
        "urllib.parse.urlsplit",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert query['added_value_one'] == 'one'",
        "assert query['added_value_two'] == 'two'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_adds_other_supplied_values_as_query_string` aims to verify that the `url_for` method of the Sanic application correctly constructs a URL that includes additional query string parameters supplied as keyword arguments.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when additional values (`added_value_one` and `added_value_two`) are provided to the `url_for` method, they are correctly included in the generated URL's query string. The assertions confirm that the values in the query string match the expected values.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `url_for` method of the Sanic application, which generates a URL for a specified route. The test defines a route (`passes`) and then constructs a URL using `url_for`, passing in additional keyword arguments. The generated URL is parsed to extract the query string, which is then checked to ensure it contains the expected parameters and values.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of fixtures (the `app` fixture) to set up the testing environment, allowing for the creation of a Sanic application instance. It also utilizes dictionary unpacking to dynamically add query parameters, and it leverages assertions to validate the correctness of the generated URL. The use of `parse_qsl` from the `urllib.parse` module is a notable technique for parsing the query string into a dictionary for easy verification."
    },
    {
      "name": "test_blueprints_are_named_correctly",
      "module": "test_url_building",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_building.py",
      "line_number": 284,
      "end_line_number": 289,
      "source_code": "def test_blueprints_are_named_correctly(blueprint_app):\n    first_url = blueprint_app.url_for(\"first.foo\")\n    assert first_url == \"/first/foo\"\n\n    second_url = blueprint_app.url_for(\"second.bar\")\n    assert second_url == \"/second/foo\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "blueprint_app"
      ],
      "imports": [
        "string",
        "urllib.parse.parse_qsl",
        "urllib.parse.urlsplit",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert first_url == '/first/foo'",
        "assert second_url == '/second/foo'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "blueprint_app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "blueprint_app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_blueprints_are_named_correctly` aims to verify that the URL generation for routes defined in blueprints is functioning correctly. It checks that the URLs generated for specific route names match the expected paths.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically verifies that the `url_for` method of the `blueprint_app` correctly resolves the names of routes defined in different blueprints to their corresponding URL paths. It ensures that the expected URL paths are returned when given the route names.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `url_for` method of the `blueprint_app`, which is part of the Sanic framework. The method is expected to take a route name (e.g., `\"first.foo\"` or `\"second.bar\"`) and return the corresponding URL path (e.g., `\"/first/foo\"`). The test checks two specific routes: one from the \"first\" blueprint and another from the \"second\" blueprint, asserting that the generated URLs match the expected values.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the output of the `url_for` method against expected values. It uses a straightforward approach to check the correctness of URL generation, which is a common pattern in unit testing. Additionally, the test is structured to be clear and concise, focusing on specific route names and their expected URL paths, which enhances readability and maintainability."
    },
    {
      "name": "test_blueprints_work_with_params",
      "module": "test_url_building",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_building.py",
      "line_number": 292,
      "end_line_number": 297,
      "source_code": "def test_blueprints_work_with_params(blueprint_app):\n    first_url = blueprint_app.url_for(\"first.foo_with_param\", param=\"bar\")\n    assert first_url == \"/first/foo/bar\"\n\n    second_url = blueprint_app.url_for(\"second.bar_with_param\", param=\"bar\")\n    assert second_url == \"/second/foo/bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "blueprint_app"
      ],
      "imports": [
        "string",
        "urllib.parse.parse_qsl",
        "urllib.parse.urlsplit",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert first_url == '/first/foo/bar'",
        "assert second_url == '/second/foo/bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "blueprint_app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "blueprint_app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_blueprints_work_with_params` test verifies that the URL generation for routes defined within blueprints in a Sanic application correctly incorporates parameters. It ensures that the `url_for` method can construct the expected URLs when provided with route names and parameters.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the URLs generated for the routes `first.foo_with_param` and `second.bar_with_param` match the expected paths when the parameter `param` is set to `\"bar\"`. It confirms that the routing mechanism correctly handles dynamic segments in the URL.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `url_for` method of the `blueprint_app`, which is an instance of a Sanic application with registered blueprints. The method constructs URLs based on the route names and any parameters provided. In this case, the routes are defined in the `first` and `second` blueprints, which include dynamic segments that are replaced by the provided parameter value.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs assertions to validate the output of the `url_for` method against expected values. It uses a fixture (`blueprint_app`) to set up the application context and the necessary routes, ensuring that the test is isolated and repeatable. The use of clear and descriptive route names allows for straightforward verification of the URL generation logic."
    },
    {
      "name": "test_methodview_naming",
      "module": "test_url_building",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_building.py",
      "line_number": 341,
      "end_line_number": 346,
      "source_code": "def test_methodview_naming(methodview_app):\n    viewone_url = methodview_app.url_for(\"ViewOne\")\n    viewtwo_url = methodview_app.url_for(\"ViewTwo\")\n\n    assert viewone_url == \"/view_one\"\n    assert viewtwo_url == \"/view_two\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "methodview_app"
      ],
      "imports": [
        "string",
        "urllib.parse.parse_qsl",
        "urllib.parse.urlsplit",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert viewone_url == '/view_one'",
        "assert viewtwo_url == '/view_two'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "methodview_app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "methodview_app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_methodview_naming` test is to verify that the URL routing for the defined method views (`ViewOne` and `ViewTwo`) in the `methodview_app` is correctly configured. Specifically, it checks that the names assigned to these views can be resolved to their respective URLs.\n\n**Specific Functionality or Behavior Verified**:  \nThis test asserts that calling the `url_for` method with the names of the views returns the expected URL paths. It ensures that the application correctly maps the view names to the defined routes, confirming that the routing mechanism is functioning as intended.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `methodview_app` function, which sets up two HTTP method views (`ViewOne` and `ViewTwo`) and associates them with the routes `/view_one` and `/view_two`, respectively. The `url_for` method is called on the `methodview_app` instance to retrieve the URLs associated with these view names. The assertions check that the returned URLs match the expected paths.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern to validate the expected outcomes. It uses the `assert` statement to compare the actual output of `url_for` with the expected URL strings. This direct comparison is a common technique in unit testing to ensure that specific functionalities yield the correct results. Additionally, the test is structured to be run in a context where the `methodview_app` is already set up, indicating a reliance on fixtures or setup functions to prepare the test environment."
    },
    {
      "name": "test_versioning",
      "module": "test_url_building",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_building.py",
      "line_number": 360,
      "end_line_number": 365,
      "source_code": "def test_versioning(app, path, version, expected):\n    @app.route(path, version=version)\n    def handler(*_): ...\n\n    url = app.url_for(\"handler\")\n    assert url == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('path,version,expected', (('/foo', 1, '/v1/foo'), ('/foo', 1.1, '/v1.1/foo'), ('/foo', '1', '/v1/foo'), ('/foo', '1.1', '/v1.1/foo'), ('/foo', '1.0.1', '/v1.0.1/foo'), ('/foo', 'v1.0.1', '/v1.0.1/foo')))"
      ],
      "arguments": [
        "app",
        "path",
        "version",
        "expected"
      ],
      "imports": [
        "string",
        "urllib.parse.parse_qsl",
        "urllib.parse.urlsplit",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert url == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_versioning` function is designed to verify that the Sanic application correctly constructs URLs for routes that are versioned. It ensures that the URL generated for a specific route matches the expected URL format when a version is specified.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the URL generated by the `app.url_for` method corresponds to the expected URL for a given route path and version. It confirms that the routing mechanism respects versioning in the URL structure.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route using the `@app.route` decorator, specifying a path and a version. The `handler` function is a placeholder that does not perform any operations. The test then calls `app.url_for(\"handler\")` to generate the URL for this route. It asserts that the generated URL matches the `expected` value provided as an argument to the test.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test function takes multiple parameters (`app`, `path`, `version`, `expected`), which allows it to be run with different sets of inputs, enhancing test coverage.\n- **Assertion**: The use of `assert` statements to validate that the generated URL matches the expected output is a fundamental aspect of unit testing, ensuring that the application behaves as intended.\n- **Route Definition**: The test dynamically defines a route within the test function, showcasing how to set up routes in a test context without modifying the global application state."
    },
    {
      "name": "test_test_client_port_none",
      "module": "test_test_client_port",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_test_client_port.py",
      "line_number": 11,
      "end_line_number": 22,
      "source_code": "def test_test_client_port_none(app):\n    @app.get(\"/get\")\n    def handler(request):\n        return text(\"OK\")\n\n    test_client = SanicTestClient(app, port=None)\n\n    request, response = test_client.get(\"/get\")\n    assert response.text == \"OK\"\n\n    request, response = test_client.post(\"/get\")\n    assert response.status == 405",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert response.status == 405"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_test_client_port_none` test is to verify the behavior of the Sanic application when a request is made to a defined route with a `None` port configuration in the test client. It ensures that the application correctly handles GET requests and responds appropriately to unsupported POST requests.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that:\n1. A GET request to the `/get` endpoint returns a response with the text \"OK\".\n2. A POST request to the same endpoint returns a 405 Method Not Allowed status, indicating that the POST method is not supported for that route.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes:\n- The route handler defined by `@app.get(\"/get\")`, which returns a text response \"OK\" when accessed via a GET request.\n- The `SanicTestClient` is instantiated with `port=None`, which simulates a test environment where the server does not bind to a specific port.\n- The test client is used to send GET and POST requests to the `/get` endpoint, and the responses are asserted against expected outcomes.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Route Definition**: The test defines a route handler within the test function, demonstrating the ability to dynamically create routes for testing purposes.\n- **Assertions**: The use of assertions (`assert response.text == \"OK\"` and `assert response.status == 405`) is a common pattern in unit tests to validate that the actual outcomes match the expected results.\n- **Test Client Usage**: The test employs a test client (`SanicTestClient`) to simulate HTTP requests, which is a standard technique in testing web applications to isolate and verify the behavior of specific routes and methods."
    },
    {
      "name": "test_test_client_port_default",
      "module": "test_test_client_port",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_test_client_port.py",
      "line_number": 25,
      "end_line_number": 35,
      "source_code": "def test_test_client_port_default(app):\n    @app.get(\"/get\")\n    def handler(request):\n        return json(request.transport.get_extra_info(\"sockname\")[1])\n\n    test_client = SanicTestClient(app)\n    assert test_client.port == PORT  # Can be None before request\n\n    request, response = test_client.get(\"/get\")\n    assert test_client.port > 0\n    assert response.json == test_client.port",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert test_client.port == PORT",
        "assert test_client.port > 0",
        "assert response.json == test_client.port"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_test_client_port_default` is designed to verify the behavior of the `SanicTestClient` when it is initialized without a specified port. It checks that the client correctly identifies the port it is using after making a request to the application.\n\n**Specific Functionality or Behavior Verified**:  \nThe test ensures that:\n1. The initial port of the `SanicTestClient` is set to a default value (which can be `None` before a request).\n2. After making a GET request to the `/get` endpoint, the port is updated to a valid value greater than 0.\n3. The response from the server correctly reflects the port number used by the test client.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes:\n- The `app.get` method, which defines a route that returns the port number from the socket information of the request's transport.\n- The `test_client.get` method, which sends a GET request to the defined route.\n\nThe handler function retrieves the port number from the request's transport using `request.transport.get_extra_info(\"sockname\")[1]`, which accesses the socket's name information. The test client is instantiated and a request is made to this endpoint, allowing the test to assert the expected behaviors regarding the port.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertions**: The test uses assertions to validate the expected state of the `test_client.port` before and after the request, ensuring that it transitions from potentially `None` to a valid port number.\n- **Endpoint Testing**: The test effectively checks the integration between the client and the server by making an actual request to a defined endpoint and verifying the response.\n- **Isolation of Tests**: The test is structured to run independently, relying on the `app` fixture to provide a fresh instance of the application for each test run, which is a common practice in unit testing to avoid side effects."
    },
    {
      "name": "test_payload_too_large_from_error_handler",
      "module": "test_payload_too_large",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_payload_too_large.py",
      "line_number": 5,
      "end_line_number": 18,
      "source_code": "def test_payload_too_large_from_error_handler(app):\n    app.config.REQUEST_MAX_SIZE = 1\n\n    @app.route(\"/1\")\n    async def handler1(request):\n        return text(\"OK\")\n\n    @app.exception(PayloadTooLarge)\n    def handler_exception(request, exception):\n        return text(\"Payload Too Large from error_handler.\", 413)\n\n    _, response = app.test_client.get(\"/1\", gather_request=False)\n    assert response.status == 413\n    assert response.text == \"Payload Too Large from error_handler.\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "sanic.exceptions.PayloadTooLarge",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 413",
        "assert response.text == 'Payload Too Large from error_handler.'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.exception",
          "body": "@app.route('/')\ndef exception(request):\n    raise SanicExceptionTestException(\"You won't see me\")"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_payload_too_large_from_error_handler` test is to verify that the Sanic application correctly handles requests that exceed the maximum allowed payload size, specifically by triggering a custom error handler that returns an appropriate response.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a request is made to a route with a payload larger than the configured `REQUEST_MAX_SIZE`, the application responds with a 413 status code (Payload Too Large) and a specific error message. It ensures that the error handling mechanism is functioning as intended when the payload exceeds the limit.\n\n**Code Being Tested and How It Works**:  \nThe test sets the `REQUEST_MAX_SIZE` configuration to 1 byte, which means any request with a payload larger than this will be rejected. The test defines a route (`/1`) that returns a simple \"OK\" response and an exception handler for `PayloadTooLarge`. When the test client makes a GET request to `/1`, it expects the response to be handled by the custom error handler, which returns a 413 status code and the message \"Payload Too Large from error_handler.\" The assertions confirm that the response status and text match the expected values.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Configuration Setup**: The test modifies the application configuration (`REQUEST_MAX_SIZE`) to simulate a specific scenario.\n- **Route and Exception Handler Definition**: It dynamically defines a route and an exception handler within the test, showcasing how to set up application behavior for testing.\n- **Assertions**: The test uses assertions to validate the response status and content, ensuring that the application behaves correctly under the defined conditions.\n- **Isolation**: The test is self-contained, meaning it does not rely on external state or previous tests, which is a good practice in unit testing."
    },
    {
      "name": "test_payload_too_large_at_data_received_default",
      "module": "test_payload_too_large",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_payload_too_large.py",
      "line_number": 21,
      "end_line_number": 30,
      "source_code": "def test_payload_too_large_at_data_received_default(app):\n    app.config.REQUEST_MAX_SIZE = 1\n\n    @app.route(\"/1\")\n    async def handler2(request):\n        return text(\"OK\")\n\n    _, response = app.test_client.get(\"/1\", gather_request=False)\n    assert response.status == 413\n    assert \"Request header\" in response.text",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "sanic.exceptions.PayloadTooLarge",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 413",
        "assert 'Request header' in response.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_payload_too_large_at_data_received_default` is designed to verify that the Sanic application correctly handles requests that exceed the maximum allowed payload size. Specifically, it checks that the application responds with a 413 status code, indicating that the request entity is too large.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a request is made to the application with a payload larger than the configured `REQUEST_MAX_SIZE`, the application responds appropriately with a 413 status code. Additionally, it verifies that the response contains a specific message indicating the issue related to the request header.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the Sanic application\u2019s routing and request handling mechanisms. The test sets the `REQUEST_MAX_SIZE` configuration to 1 byte, which is extremely small. It defines a route `/1` that simply returns \"OK\". When the test client attempts to access this route, it triggers the request handling logic, which checks the size of the incoming request. Since the request exceeds the maximum size, the application responds with a 413 status code and includes a message in the response body.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of an asynchronous route handler and the Sanic test client to simulate HTTP requests. It uses assertions to validate the response status and content, which is a common pattern in unit testing to ensure that the application behaves as expected under specific conditions. The test also demonstrates the use of configuration settings to control application behavior, showcasing how tests can manipulate application state to validate edge cases."
    },
    {
      "name": "test_payload_too_large_at_on_header_default",
      "module": "test_payload_too_large",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_payload_too_large.py",
      "line_number": 33,
      "end_line_number": 43,
      "source_code": "def test_payload_too_large_at_on_header_default(app):\n    app.config.REQUEST_MAX_SIZE = 500\n\n    @app.post(\"/1\")\n    async def handler3(request):\n        return text(\"OK\")\n\n    data = \"a\" * 1000\n    _, response = app.test_client.post(\"/1\", gather_request=False, data=data)\n    assert response.status == 413\n    assert \"Request body\" in response.text",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "sanic.exceptions.PayloadTooLarge",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 413",
        "assert 'Request body' in response.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_payload_too_large_at_on_header_default` is designed to verify that the Sanic application correctly handles requests with a payload that exceeds the maximum allowed size, specifically when the request method is POST. It ensures that the application responds with the appropriate HTTP status code (413) and includes a relevant message in the response body.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a POST request is made with a body larger than the configured `REQUEST_MAX_SIZE`, the server responds with a 413 status code, indicating \"Payload Too Large.\" Additionally, it verifies that the response text contains the phrase \"Request body,\" confirming that the error message is related to the request body size.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `app.post` method, which is responsible for handling POST requests, and the `app.test_client.post` method, which simulates sending a POST request to the application. The test sets the `REQUEST_MAX_SIZE` to 500 bytes and sends a request with a body of 1000 bytes. The expected behavior is that the application will reject this request due to its size, triggering the appropriate error handling mechanism.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the response status and content, which is a common pattern in unit testing. It also utilizes the Sanic testing client to simulate HTTP requests, allowing for integration-like testing of the application's behavior in response to specific inputs. The test is structured to be clear and straightforward, focusing on a single aspect of functionality, which is a best practice in unit testing to ensure that tests are easy to understand and maintain."
    },
    {
      "name": "test_imports",
      "module": "test_init",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_init.py",
      "line_number": 24,
      "end_line_number": 25,
      "source_code": "def test_imports(item):\n    import_module(\"sanic\", item)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('item', ('__version__', 'Sanic', 'Blueprint', 'HTTPMethod', 'HTTPResponse', 'Request', 'Websocket', 'empty', 'file', 'html', 'json', 'redirect', 'text'))"
      ],
      "arguments": [
        "item"
      ],
      "imports": [
        "importlib.import_module",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_imports` function is designed to verify that specific attributes and classes can be successfully imported from the `sanic` module. This ensures that the expected components of the `sanic` framework are available and correctly defined.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks for the presence of various items (like `__version__`, `Sanic`, `Blueprint`, etc.) within the `sanic` module. If any of these items cannot be imported, an `ImportError` will be raised, indicating that the module does not contain the expected components.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the `import_module` function from the `importlib` library to attempt to import each specified item from the `sanic` module. The `pytest.mark.parametrize` decorator is used to run the test multiple times, once for each item in the provided tuple. If an item is not found in the `sanic` module, the test will fail, signaling that the module's structure may have changed or that the item is missing.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The use of `pytest.mark.parametrize` allows for concise testing of multiple cases with a single test function, improving code readability and maintainability.\n- **Dynamic Importing**: The test leverages dynamic importing to check for the existence of various components, which is a common practice in Python to ensure that modules are structured as expected without hardcoding import statements.\n- **Error Handling**: Implicitly, the test relies on Python's built-in error handling to catch `ImportError`, which is a standard way to verify the presence of module components in unit tests."
    },
    {
      "name": "test_body_can_be_retrieved",
      "module": "test_response_json",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response_json.py",
      "line_number": 27,
      "end_line_number": 29,
      "source_code": "def test_body_can_be_retrieved(json_app: Sanic):\n    _, resp = json_app.test_client.get(\"/json\")\n    assert resp.body == json_dumps(JSON_BODY).encode()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_app"
      ],
      "imports": [
        "json",
        "functools.partial",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.exceptions.SanicException",
        "sanic.response.json",
        "sanic.response.types.JSONResponse"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.body == json_dumps(JSON_BODY).encode()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_body_can_be_retrieved` is designed to verify that the Sanic application correctly returns a JSON response body when a GET request is made to the `/json` endpoint.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the response body from the endpoint matches the expected JSON representation of `JSON_BODY`, which is `{\"ok\": True}`. It ensures that the application correctly serializes the JSON data and encodes it properly.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `json_app` fixture that sets up a Sanic application with a route `/json`. The route handler returns a JSON response containing `JSON_BODY` using the `json_response` function. The test invokes this endpoint using `json_app.test_client.get(\"/json\")`, which simulates a GET request and captures the response. The assertion checks if the response body matches the expected JSON string encoded in bytes.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of fixtures (`json_app`) to set up the application context, allowing for clean and reusable test setups. It also utilizes the `assert` statement to validate the response, which is a common practice in unit testing to ensure that the actual output matches the expected output. The use of `json_dumps` with `partial` helps in customizing the JSON serialization, ensuring consistent formatting in the test assertions."
    },
    {
      "name": "test_body_can_be_set",
      "module": "test_response_json",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response_json.py",
      "line_number": 32,
      "end_line_number": 40,
      "source_code": "def test_body_can_be_set(json_app: Sanic):\n    new_body = b'{\"hello\":\"world\"}'\n\n    @json_app.on_response\n    def set_body(request: Request, response: JSONResponse):\n        response.body = new_body\n\n    _, resp = json_app.test_client.get(\"/json\")\n    assert resp.body == new_body",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_app"
      ],
      "imports": [
        "json",
        "functools.partial",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.exceptions.SanicException",
        "sanic.response.json",
        "sanic.response.types.JSONResponse"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.body == new_body"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_body_can_be_set` test verifies that the response body of a Sanic application can be modified during the response lifecycle. Specifically, it checks if the body can be set to a predefined value when a response is generated.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the `on_response` event handler correctly modifies the response body before it is sent back to the client. It confirms that the body of the response matches the expected byte string (`b'{\"hello\":\"world\"}'`).\n\n**Code Being Tested and How It Works**:  \nThe test uses the `json_app` instance of the Sanic application to define an `on_response` event handler. This handler sets the response body to `new_body` (which contains a JSON string). The test then simulates a GET request to the `/json` endpoint using `json_app.test_client.get(\"/json\")`. After the request is processed, it asserts that the response body equals `new_body`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Event Handling**: The test utilizes Sanic's event system by defining an `on_response` handler, demonstrating how middleware can manipulate responses.\n- **Byte String Comparison**: The test checks the response body against a byte string, which is a common practice when dealing with raw response data in web applications.\n- **Client Simulation**: The use of `test_client.get` simulates an actual HTTP request, allowing for integration-like testing within the unit test framework."
    },
    {
      "name": "test_raw_body_can_be_retrieved",
      "module": "test_response_json",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response_json.py",
      "line_number": 43,
      "end_line_number": 48,
      "source_code": "def test_raw_body_can_be_retrieved(json_app: Sanic):\n    @json_app.on_response\n    def check_body(request: Request, response: JSONResponse):\n        assert response.raw_body == JSON_BODY\n\n    json_app.test_client.get(\"/json\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_app"
      ],
      "imports": [
        "json",
        "functools.partial",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.exceptions.SanicException",
        "sanic.response.json",
        "sanic.response.types.JSONResponse"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.raw_body == JSON_BODY"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_raw_body_can_be_retrieved` test verifies that the `raw_body` attribute of the `JSONResponse` object correctly reflects the body of the response when a request is made to the `/json` endpoint. It ensures that the raw body can be accessed as expected after the response is generated.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `raw_body` of the response matches the predefined `JSON_BODY` dictionary. It ensures that the response handling mechanism correctly retains the original body data in its raw form, allowing for accurate retrieval.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the `json_app` fixture, which sets up a Sanic application with a `/json` endpoint that returns a JSON response containing `JSON_BODY`. The test defines an `on_response` callback that asserts the `raw_body` of the response matches `JSON_BODY`. The test then triggers a GET request to the `/json` endpoint using `json_app.test_client.get(\"/json\")`, which invokes the response handling and allows the assertion to take place.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of a fixture (`json_app`) to set up the application context, which promotes reusability and isolation of test cases. It also utilizes the `on_response` decorator to hook into the response lifecycle, allowing for assertions to be made after the response is generated. This pattern is effective for testing side effects and ensuring that the response object behaves as expected after the request has been processed."
    },
    {
      "name": "test_raw_body_can_be_set",
      "module": "test_response_json",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response_json.py",
      "line_number": 51,
      "end_line_number": 60,
      "source_code": "def test_raw_body_can_be_set(json_app: Sanic):\n    new_body = {\"hello\": \"world\"}\n\n    @json_app.on_response\n    def set_body(request: Request, response: JSONResponse):\n        response.raw_body = new_body\n        assert response.raw_body == new_body\n        assert response.body == json_dumps(new_body).encode()\n\n    json_app.test_client.get(\"/json\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_app"
      ],
      "imports": [
        "json",
        "functools.partial",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.exceptions.SanicException",
        "sanic.response.json",
        "sanic.response.types.JSONResponse"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.raw_body == new_body",
        "assert response.body == json_dumps(new_body).encode()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_raw_body_can_be_set` test verifies that the `raw_body` attribute of a `JSONResponse` object can be set correctly during the response lifecycle in a Sanic application. It ensures that the response's raw body matches the expected value after the response is processed.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a new body is assigned to `response.raw_body`, it correctly reflects that assignment. Additionally, it verifies that the `response.body` is serialized correctly to JSON format and encoded as bytes, ensuring that both the raw and processed body are consistent.\n\n**Code Being Tested and How It Works**:  \nThe test uses a Sanic application instance (`json_app`) and defines an event handler for the `on_response` event. Inside this handler, the `response.raw_body` is set to `new_body`, which is a dictionary. The test then asserts that `response.raw_body` equals `new_body` and that `response.body` equals the JSON-encoded version of `new_body`. The `json_app.test_client.get(\"/json\")` call simulates a GET request to the `/json` endpoint, triggering the response handling logic.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Event-Driven Testing**: The test leverages Sanic's event system by using the `@json_app.on_response` decorator to define behavior that occurs during the response phase.\n- **Assertions**: It employs assertions to validate the state of the response object after the request is processed, ensuring that both the raw and encoded body are as expected.\n- **Mocking**: While not explicitly shown in this test, the overall test suite demonstrates the use of mocking (e.g., `Mock` from `unittest.mock`) to control and verify behavior in other tests, indicating a pattern of isolating components for testing."
    },
    {
      "name": "test_raw_body_cant_be_retrieved_after_body_set",
      "module": "test_response_json",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response_json.py",
      "line_number": 63,
      "end_line_number": 72,
      "source_code": "def test_raw_body_cant_be_retrieved_after_body_set(json_app: Sanic):\n    new_body = b'{\"hello\":\"world\"}'\n\n    @json_app.on_response\n    def check_raw_body(request: Request, response: JSONResponse):\n        response.body = new_body\n        with pytest.raises(SanicException):\n            response.raw_body\n\n    json_app.test_client.get(\"/json\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_app"
      ],
      "imports": [
        "json",
        "functools.partial",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.exceptions.SanicException",
        "sanic.response.json",
        "sanic.response.types.JSONResponse"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_raw_body_cant_be_retrieved_after_body_set` is designed to verify that once the body of a response object in a Sanic application is set, the raw body cannot be accessed. This ensures that the response object's state is correctly managed and that the raw body is not retrievable after it has been overridden.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that attempting to access `response.raw_body` raises a `SanicException` after the response body has been set to a new value. This behavior is crucial for maintaining the integrity of the response data and preventing unintended access to the raw body after it has been modified.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the Sanic framework's response handling. It sets up a response handler using the `@json_app.on_response` decorator, which modifies the response body to a predefined byte string (`new_body`). After setting the body, the test attempts to access `response.raw_body`, which is expected to raise a `SanicException`. The test client makes a GET request to the `/json` endpoint, triggering the response handler.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of a context manager (`with pytest.raises(...)`) to assert that an exception is raised, which is a common pattern in unit testing for verifying error conditions. Additionally, it leverages the Sanic framework's event-driven architecture by using the `on_response` decorator to hook into the response lifecycle, allowing for the manipulation of response data in a controlled manner. This approach ensures that the test is both isolated and focused on the specific behavior being validated."
    },
    {
      "name": "test_raw_body_can_be_reset_after_body_set",
      "module": "test_response_json",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response_json.py",
      "line_number": 75,
      "end_line_number": 85,
      "source_code": "def test_raw_body_can_be_reset_after_body_set(json_app: Sanic):\n    new_body = b'{\"hello\":\"world\"}'\n    new_new_body = {\"lorem\": \"ipsum\"}\n\n    @json_app.on_response\n    def set_bodies(request: Request, response: JSONResponse):\n        response.body = new_body\n        response.raw_body = new_new_body\n\n    _, resp = json_app.test_client.get(\"/json\")\n    assert resp.body == json_dumps(new_new_body).encode()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_app"
      ],
      "imports": [
        "json",
        "functools.partial",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.exceptions.SanicException",
        "sanic.response.json",
        "sanic.response.types.JSONResponse"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.body == json_dumps(new_new_body).encode()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_raw_body_can_be_reset_after_body_set` is designed to verify that the `raw_body` attribute of a `JSONResponse` can be reset after it has been set. This ensures that the response object behaves correctly when both `body` and `raw_body` are manipulated, which is crucial for maintaining the integrity of the response data in a web application.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when a response's `body` is set to a specific value (`new_body`), the `raw_body` can still be set to a different value (`new_new_body`). The assertion confirms that the `body` of the response matches the JSON-encoded version of `new_new_body`, demonstrating that the `raw_body` can be effectively reset without losing the ability to retrieve the updated `body`.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves a Sanic application where a response handler is registered using the `@json_app.on_response` decorator. Inside this handler, the `response.body` is set to a byte string representing JSON data, and the `response.raw_body` is set to a dictionary. The test then simulates a GET request to the `/json` endpoint, and the response is checked to ensure that its body matches the expected JSON-encoded output of `new_new_body`. This tests the interaction between the `body` and `raw_body` attributes of the `JSONResponse`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of a fixture (`json_app`) to set up the Sanic application context, which is a common pattern in unit testing to ensure a clean and isolated environment for each test. Additionally, the use of decorators to register response handlers is a technique that allows for dynamic modification of response behavior during the request lifecycle. The test also utilizes assertions to validate the expected outcomes, which is a fundamental practice in unit testing to ensure correctness."
    },
    {
      "name": "test_set_body_method",
      "module": "test_response_json",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response_json.py",
      "line_number": 88,
      "end_line_number": 96,
      "source_code": "def test_set_body_method(json_app: Sanic):\n    new_body = {\"lorem\": \"ipsum\"}\n\n    @json_app.on_response\n    def set_body(request: Request, response: JSONResponse):\n        response.set_body(new_body)\n\n    _, resp = json_app.test_client.get(\"/json\")\n    assert resp.body == json_dumps(new_body).encode()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_app"
      ],
      "imports": [
        "json",
        "functools.partial",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.exceptions.SanicException",
        "sanic.response.json",
        "sanic.response.types.JSONResponse"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.body == json_dumps(new_body).encode()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response.set_body",
          "body": "@json_app.on_response\ndef set_body(request: Request, response: JSONResponse):\n    response.body = new_body"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_set_body_method` unit test is designed to verify that the `set_body` method correctly updates the response body of a Sanic application when a specific event (in this case, a response event) occurs. It ensures that the response body is set to the expected JSON data.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a GET request is made to the `/json` endpoint, the response body is set to a predefined JSON object (`{\"lorem\": \"ipsum\"}`) using the `set_body` method. The test asserts that the actual response body matches the expected serialized JSON output.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `json_app.test_client.get` method, which simulates a GET request to the `/json` endpoint, and the `response.set_body` method, which is defined in the `on_response` event handler. When the GET request is made, the `set_body` function is triggered, setting the response body to `new_body`. The test then checks if the response body matches the expected JSON output by comparing it to the result of `json_dumps(new_body).encode()`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of decorators to register an event handler (`@json_app.on_response`) that modifies the response before it is sent. It also utilizes assertions to validate the correctness of the response body. The use of a test client to simulate requests and responses is a common pattern in testing web applications, allowing for isolated testing of endpoint behavior without needing to run a full server."
    },
    {
      "name": "test_set_body_method_after_body_set",
      "module": "test_response_json",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response_json.py",
      "line_number": 99,
      "end_line_number": 109,
      "source_code": "def test_set_body_method_after_body_set(json_app: Sanic):\n    new_body = b'{\"hello\":\"world\"}'\n    new_new_body = {\"lorem\": \"ipsum\"}\n\n    @json_app.on_response\n    def set_body(request: Request, response: JSONResponse):\n        response.body = new_body\n        response.set_body(new_new_body)\n\n    _, resp = json_app.test_client.get(\"/json\")\n    assert resp.body == json_dumps(new_new_body).encode()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_app"
      ],
      "imports": [
        "json",
        "functools.partial",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.exceptions.SanicException",
        "sanic.response.json",
        "sanic.response.types.JSONResponse"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.body == json_dumps(new_new_body).encode()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response.set_body",
          "body": "@json_app.on_response\ndef set_body(request: Request, response: JSONResponse):\n    response.body = new_body"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_set_body_method_after_body_set` is designed to verify that the `set_body` method of the `JSONResponse` class correctly updates the response body even after it has been set previously. This ensures that the response can be modified dynamically during the request-response lifecycle.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when a response body is initially set to a specific value (`new_body`), and then subsequently modified using the `set_body` method with a new value (`new_new_body`), the final response body reflects the last set value. It asserts that the response body matches the expected JSON-encoded representation of `new_new_body`.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the `json_app` fixture, which sets up a Sanic application with a route that returns a JSON response. Inside the test, an event handler is registered to modify the response body. The `response.body` is first set to `new_body`, and then `response.set_body(new_new_body)` is called. The test client makes a GET request to the `/json` endpoint, and the response is checked to ensure that it matches the JSON-encoded version of `new_new_body`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Event Handling**: The test uses the `@json_app.on_response` decorator to register a callback that modifies the response before it is sent to the client. This pattern allows for dynamic response manipulation.\n- **Assertions**: The test employs assertions to validate that the response body is as expected, ensuring that the functionality of the `set_body` method is correctly implemented.\n- **Fixture Usage**: The `json_app` fixture is used to create a reusable test application context, promoting code reuse and clarity in the test setup."
    },
    {
      "name": "test_custom_dumps_and_kwargs",
      "module": "test_response_json",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response_json.py",
      "line_number": 112,
      "end_line_number": 121,
      "source_code": "def test_custom_dumps_and_kwargs(json_app: Sanic):\n    custom_dumps = Mock(return_value=\"custom\")\n\n    @json_app.get(\"/json-custom\")\n    async def handle_custom(request: Request):\n        return json_response(JSON_BODY, dumps=custom_dumps, prry=\"platypus\")\n\n    _, resp = json_app.test_client.get(\"/json-custom\")\n    assert resp.body == \"custom\".encode()\n    custom_dumps.assert_called_once_with(JSON_BODY, prry=\"platypus\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_app"
      ],
      "imports": [
        "json",
        "functools.partial",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.exceptions.SanicException",
        "sanic.response.json",
        "sanic.response.types.JSONResponse"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.body == 'custom'.encode()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "json_app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "json_response",
          "body": "@app.get('/json')\ndef json_response(request):\n    return json({'format': request.route.extra.error_format})"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_custom_dumps_and_kwargs` test is designed to verify that the `json_response` function in the Sanic framework correctly utilizes a custom serialization function (`dumps`) and additional keyword arguments when generating a JSON response.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the response body returned from the `/json-custom` endpoint is correctly serialized to \"custom\" using the `custom_dumps` mock function. It also ensures that the `custom_dumps` function is called exactly once with the expected arguments, confirming that the additional keyword argument (`prry`) is passed correctly.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Sanic application with a route (`/json-custom`) that returns a JSON response. The `json_response` function is called within the route handler, which uses the `custom_dumps` mock to serialize the `JSON_BODY` dictionary. The test then simulates a GET request to this endpoint and checks the response body against the expected serialized output. The assertion verifies that the response body matches the expected encoded string, and the mock's call assertion checks the parameters passed to it.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The `Mock` class from the `unittest.mock` module is used to create a mock function (`custom_dumps`) that simulates the behavior of a serialization function without executing its actual logic.\n- **Asynchronous Testing**: The test is structured to work with asynchronous route handlers, which is a common pattern in frameworks like Sanic that support async I/O.\n- **Assertions**: The test employs assertions to validate both the response body and the call to the mock function, ensuring that the expected behavior is met."
    },
    {
      "name": "test_override_dumps_and_kwargs",
      "module": "test_response_json",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response_json.py",
      "line_number": 124,
      "end_line_number": 140,
      "source_code": "def test_override_dumps_and_kwargs(json_app: Sanic):\n    custom_dumps_1 = Mock(return_value=\"custom1\")\n    custom_dumps_2 = Mock(return_value=\"custom2\")\n\n    @json_app.get(\"/json-custom\")\n    async def handle_custom(request: Request):\n        return json_response(JSON_BODY, dumps=custom_dumps_1, prry=\"platypus\")\n\n    @json_app.on_response\n    def set_body(request: Request, response: JSONResponse):\n        response.set_body(JSON_BODY, dumps=custom_dumps_2, platypus=\"prry\")\n\n    _, resp = json_app.test_client.get(\"/json-custom\")\n\n    assert resp.body == \"custom2\".encode()\n    custom_dumps_1.assert_called_once_with(JSON_BODY, prry=\"platypus\")\n    custom_dumps_2.assert_called_once_with(JSON_BODY, platypus=\"prry\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_app"
      ],
      "imports": [
        "json",
        "functools.partial",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.exceptions.SanicException",
        "sanic.response.json",
        "sanic.response.types.JSONResponse"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.body == 'custom2'.encode()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "json_app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "json_response",
          "body": "@app.get('/json')\ndef json_response(request):\n    return json({'format': request.route.extra.error_format})"
        },
        {
          "name": "response.set_body",
          "body": "@json_app.on_response\ndef set_body(request: Request, response: JSONResponse):\n    response.body = new_body"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_override_dumps_and_kwargs` is designed to verify that the Sanic application correctly overrides the JSON serialization behavior when returning a response. It checks that custom serialization functions can be applied both in the request handler and in the response lifecycle, ensuring that the expected output is produced.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically verifies that:\n1. The `dumps` parameter in the `json_response` function is correctly utilized to serialize the response body.\n2. The `set_body` method in the response lifecycle correctly applies a different serialization function.\n3. The correct arguments are passed to both custom serialization functions.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Sanic application with two routes:\n- A GET route `/json-custom` that returns a JSON response using `custom_dumps_1` for serialization.\n- An `on_response` handler that modifies the response body using `custom_dumps_2`. \n\nThe test then simulates a GET request to `/json-custom` and asserts that the response body matches the output of `custom_dumps_2`. It also checks that both custom dumps functions were called with the expected arguments.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test uses `Mock` from the `unittest.mock` module to create mock functions for serialization, allowing the test to verify that these functions are called with the correct parameters.\n- **Asynchronous Testing**: The test leverages Sanic's asynchronous capabilities, ensuring that the request handling and response lifecycle are tested in an async context.\n- **Assertions**: The test includes assertions to validate both the response body and the call parameters of the mock functions, ensuring comprehensive verification of behavior."
    },
    {
      "name": "test_append",
      "module": "test_response_json",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response_json.py",
      "line_number": 143,
      "end_line_number": 153,
      "source_code": "def test_append(json_app: Sanic):\n    @json_app.get(\"/json-append\")\n    async def handler_append(request: Request):\n        return json_response([\"a\", \"b\"], status=200)\n\n    @json_app.on_response\n    def do_append(request: Request, response: JSONResponse):\n        response.append(\"c\")\n\n    _, resp = json_app.test_client.get(\"/json-append\")\n    assert resp.body == json_dumps([\"a\", \"b\", \"c\"]).encode()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_app"
      ],
      "imports": [
        "json",
        "functools.partial",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.exceptions.SanicException",
        "sanic.response.json",
        "sanic.response.types.JSONResponse"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.body == json_dumps(['a', 'b', 'c']).encode()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "json_app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "json_response",
          "body": "@app.get('/json')\ndef json_response(request):\n    return json({'format': request.route.extra.error_format})"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_append` function is designed to verify that the Sanic application correctly appends an item to the JSON response body when a specific endpoint (`/json-append`) is accessed. This ensures that the response modification functionality works as intended.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when a GET request is made to the `/json-append` endpoint, the response body contains the original JSON array `[\"a\", \"b\"]` with an additional item `\"c\"` appended to it, resulting in `[\"a\", \"b\", \"c\"]`. The test asserts that the final response body matches the expected JSON output.\n\n**Code Being Tested and How It Works**:  \n1. The `handler_append` function is defined to handle GET requests to `/json-append`, returning a JSON response with the array `[\"a\", \"b\"]`.\n2. The `do_append` function is registered as an event handler for the `on_response` event, which modifies the response by appending `\"c\"` to it.\n3. The test client simulates a GET request to the endpoint, and the response is captured.\n4. The test then asserts that the response body matches the expected JSON output, which is generated using `json_dumps` to serialize the array `[\"a\", \"b\", \"c\"]`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test leverages asynchronous functions to handle requests and responses, which is a common pattern in web frameworks like Sanic.\n- **Event Handling**: The use of the `on_response` event to modify the response demonstrates a pattern of extending functionality through event-driven programming.\n- **Assertions**: The test employs assertions to validate the correctness of the response, ensuring that the application behaves as expected under the defined conditions."
    },
    {
      "name": "test_extend",
      "module": "test_response_json",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response_json.py",
      "line_number": 156,
      "end_line_number": 166,
      "source_code": "def test_extend(json_app: Sanic):\n    @json_app.get(\"/json-extend\")\n    async def handler_extend(request: Request):\n        return json_response([\"a\", \"b\"], status=200)\n\n    @json_app.on_response\n    def do_extend(request: Request, response: JSONResponse):\n        response.extend([\"c\", \"d\"])\n\n    _, resp = json_app.test_client.get(\"/json-extend\")\n    assert resp.body == json_dumps([\"a\", \"b\", \"c\", \"d\"]).encode()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_app"
      ],
      "imports": [
        "json",
        "functools.partial",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.exceptions.SanicException",
        "sanic.response.json",
        "sanic.response.types.JSONResponse"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.body == json_dumps(['a', 'b', 'c', 'd']).encode()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "json_app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "json_response",
          "body": "@app.get('/json')\ndef json_response(request):\n    return json({'format': request.route.extra.error_format})"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_extend` function is designed to verify the behavior of the Sanic application when extending the response body of a JSON response. It ensures that the response correctly includes additional data after the response has been modified by an event handler.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a GET request is made to the `/json-extend` endpoint, the response body contains the expected JSON array that includes both the original data and the data added by the response extension. Specifically, it verifies that the response body is `[\"a\", \"b\", \"c\", \"d\"]`.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Sanic application with a route handler for `/json-extend` that initially returns a JSON response containing `[\"a\", \"b\"]`. It also defines an `on_response` event handler that extends the response body by appending `[\"c\", \"d\"]`. After making a GET request to the endpoint using `json_app.test_client.get`, the test asserts that the response body matches the expected JSON output, which is generated using `json_dumps` and encoded to bytes.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of asynchronous route handlers and response event handlers, which are common patterns in web frameworks like Sanic. It also utilizes assertions to validate the response body, ensuring that the modifications made by the event handler are correctly reflected in the final output. The use of `json_dumps` for serialization is a notable technique that ensures the response is formatted as valid JSON."
    },
    {
      "name": "test_update",
      "module": "test_response_json",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response_json.py",
      "line_number": 169,
      "end_line_number": 179,
      "source_code": "def test_update(json_app: Sanic):\n    @json_app.get(\"/json-update\")\n    async def handler_update(request: Request):\n        return json_response({\"a\": \"b\"}, status=200)\n\n    @json_app.on_response\n    def do_update(request: Request, response: JSONResponse):\n        response.update({\"c\": \"d\"}, e=\"f\")\n\n    _, resp = json_app.test_client.get(\"/json-update\")\n    assert resp.body == json_dumps({\"a\": \"b\", \"c\": \"d\", \"e\": \"f\"}).encode()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_app"
      ],
      "imports": [
        "json",
        "functools.partial",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.exceptions.SanicException",
        "sanic.response.json",
        "sanic.response.types.JSONResponse"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.body == json_dumps({'a': 'b', 'c': 'd', 'e': 'f'}).encode()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "json_app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "json_response",
          "body": "@app.get('/json')\ndef json_response(request):\n    return json({'format': request.route.extra.error_format})"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_update` function is designed to verify the behavior of a Sanic application when handling a GET request to the `/json-update` endpoint. Specifically, it checks that the response body correctly combines the initial JSON response with additional data added during the response lifecycle.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the response from the `/json-update` endpoint includes both the original JSON data (`{\"a\": \"b\"}`) and the additional data (`{\"c\": \"d\", \"e\": \"f\"}`) that is appended by the `do_update` response handler. The expected final output is a JSON object that merges these two sets of data.\n\n**Code Being Tested and How It Works**:  \n1. The test defines a GET handler for the `/json-update` route that returns a JSON response with `{\"a\": \"b\"}`.\n2. It also defines an `on_response` handler (`do_update`) that modifies the response by adding `{\"c\": \"d\"}` and an additional key-value pair `e=\"f\"`.\n3. The test then simulates a GET request to the `/json-update` endpoint using `json_app.test_client.get()`.\n4. Finally, it asserts that the response body matches the expected JSON output, which is `{\"a\": \"b\", \"c\": \"d\", \"e\": \"f\"}`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test leverages Sanic's asynchronous capabilities, allowing for non-blocking request handling and response processing.\n- **Response Lifecycle Hooks**: It utilizes the `on_response` decorator to modify the response after the main handler has executed, demonstrating how to extend or alter responses dynamically.\n- **Assertions**: The test employs assertions to validate that the response body is as expected, ensuring that the application behaves correctly under the defined conditions."
    },
    {
      "name": "test_pop_dict",
      "module": "test_response_json",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response_json.py",
      "line_number": 182,
      "end_line_number": 196,
      "source_code": "def test_pop_dict(json_app: Sanic):\n    @json_app.get(\"/json-pop\")\n    async def handler_pop(request: Request):\n        return json_response({\"a\": \"b\", \"c\": \"d\"}, status=200)\n\n    @json_app.on_response\n    def do_pop(request: Request, response: JSONResponse):\n        val = response.pop(\"c\")\n        assert val == \"d\"\n\n        val_default = response.pop(\"e\", \"f\")\n        assert val_default == \"f\"\n\n    _, resp = json_app.test_client.get(\"/json-pop\")\n    assert resp.body == json_dumps({\"a\": \"b\"}).encode()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_app"
      ],
      "imports": [
        "json",
        "functools.partial",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.exceptions.SanicException",
        "sanic.response.json",
        "sanic.response.types.JSONResponse"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.body == json_dumps({'a': 'b'}).encode()",
        "assert val == 'd'",
        "assert val_default == 'f'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "json_app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "json_response",
          "body": "@app.get('/json')\ndef json_response(request):\n    return json({'format': request.route.extra.error_format})"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_pop_dict` function is designed to verify the behavior of the Sanic framework's response handling, specifically testing the `pop` method on a JSON response object. It ensures that the method correctly removes specified keys from the response data and handles default values appropriately.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main functionalities: \n1. It verifies that the key `\"c\"` can be successfully removed from the response, and that its value is as expected (`\"d\"`).\n2. It also checks that attempting to pop a non-existent key (`\"e\"`) returns a default value (`\"f\"`), confirming that the default behavior of the `pop` method is functioning correctly.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Sanic application with a route (`/json-pop`) that returns a JSON response containing a dictionary with keys `\"a\"`, `\"b\"`, `\"c\"`, and `\"d\"`. The `on_response` event handler is used to manipulate the response after it has been generated. The `pop` method is called on the response object to remove the key `\"c\"` and check its value, followed by attempting to pop a non-existent key with a default value. Finally, the test asserts that the response body only contains the remaining key-value pairs after the modifications.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test utilizes asynchronous handlers and the Sanic test client to simulate requests and responses, which is essential for testing web applications.\n- **Event Handling**: The use of the `@json_app.on_response` decorator allows for the manipulation of the response after it has been created, showcasing how to hook into the request-response lifecycle in Sanic.\n- **Assertions**: The test employs assertions to validate the expected outcomes, ensuring that both the value returned by `pop` and the final response body match the anticipated results. This is a common practice in unit testing to confirm that the code behaves as intended."
    },
    {
      "name": "test_pop_list",
      "module": "test_response_json",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response_json.py",
      "line_number": 199,
      "end_line_number": 215,
      "source_code": "def test_pop_list(json_app: Sanic):\n    @json_app.get(\"/json-pop\")\n    async def handler_pop(request: Request):\n        return json_response([\"a\", \"b\"], status=200)\n\n    @json_app.on_response\n    def do_pop(request: Request, response: JSONResponse):\n        val = response.pop(0)\n        assert val == \"a\"\n\n        with pytest.raises(\n            TypeError, match=\"pop doesn't accept a default argument for lists\"\n        ):\n            response.pop(21, \"nah nah\")\n\n    _, resp = json_app.test_client.get(\"/json-pop\")\n    assert resp.body == json_dumps([\"b\"]).encode()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_app"
      ],
      "imports": [
        "json",
        "functools.partial",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.exceptions.SanicException",
        "sanic.response.json",
        "sanic.response.types.JSONResponse"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.body == json_dumps(['b']).encode()",
        "assert val == 'a'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "json_app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "json_response",
          "body": "@app.get('/json')\ndef json_response(request):\n    return json({'format': request.route.extra.error_format})"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_pop_list` function is designed to verify the behavior of a Sanic application when handling a JSON response that is a list. Specifically, it tests the functionality of the `pop` method on a list response and ensures that the correct value is returned and that the method behaves as expected when given invalid arguments.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main behaviors:\n1. It verifies that the first element of the list response (`\"a\"`) is correctly removed and returned when `pop(0)` is called.\n2. It ensures that calling `pop` with a default argument raises a `TypeError`, confirming that the method does not accept a default value for lists.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Sanic route (`/json-pop`) that returns a JSON response containing a list `[\"a\", \"b\"]`. The `do_pop` function is registered as an event handler for the response, where it performs the following:\n- It calls `response.pop(0)` to remove and assert the first element.\n- It attempts to call `response.pop(21, \"nah nah\")`, which is expected to raise a `TypeError` because the `pop` method for lists does not accept a default argument. Finally, the test checks that the response body after the pop operation is `[\"b\"]`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test uses asynchronous functions to handle requests and responses, which is essential for testing web applications that operate in an asynchronous environment.\n- **Assertions**: The test employs assertions to validate expected outcomes, such as checking the value returned by `pop` and ensuring that the correct exception is raised.\n- **Response Handling**: The use of `@json_app.on_response` allows for testing the response after it has been generated, providing a way to manipulate and verify the response object directly."
    },
    {
      "name": "test_json_response_class_sets_proper_content_type",
      "module": "test_response_json",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response_json.py",
      "line_number": 218,
      "end_line_number": 224,
      "source_code": "def test_json_response_class_sets_proper_content_type(json_app: Sanic):\n    @json_app.get(\"/json-class\")\n    async def handler(request: Request):\n        return JSONResponse(JSON_BODY)\n\n    _, resp = json_app.test_client.get(\"/json-class\")\n    assert resp.headers[\"content-type\"] == \"application/json\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_app"
      ],
      "imports": [
        "json",
        "functools.partial",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.exceptions.SanicException",
        "sanic.response.json",
        "sanic.response.types.JSONResponse"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.headers['content-type'] == 'application/json'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "json_app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_json_response_class_sets_proper_content_type` test is to verify that the `JSONResponse` class correctly sets the `Content-Type` header to `application/json` when a JSON response is returned from a Sanic application endpoint.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a GET request is made to the `/json-class` endpoint, the response's `Content-Type` header is accurately set to `application/json`. This ensures that clients receiving the response can correctly interpret the data format.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `json_app.get` method, which defines an asynchronous route handler for the `/json-class` endpoint. This handler returns an instance of `JSONResponse` initialized with `JSON_BODY`. The test then uses the `json_app.test_client.get` method to simulate a GET request to this endpoint and captures the response. The assertion checks the `Content-Type` header of the response to confirm it is set to `application/json`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of a fixture (`json_app`) to set up the Sanic application context, allowing for clean and isolated testing of the endpoint. It also utilizes the `assert` statement to validate the expected outcome, which is a common practice in unit testing to ensure that the actual behavior matches the expected behavior. The use of asynchronous handlers and the Sanic test client demonstrates an effective approach to testing asynchronous web applications."
    },
    {
      "name": "test_overload_dynamic_routes",
      "module": "test_dynamic_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_dynamic_routes.py",
      "line_number": 16,
      "end_line_number": 26,
      "source_code": "def test_overload_dynamic_routes(app, method, attr, expected):\n    @app.route(\"/overload/<param>\", methods=[\"GET\"])\n    async def handler1(request, param):\n        return text(\"OK1 \" + param)\n\n    @app.route(\"/overload/<param>\", methods=[\"POST\", \"PUT\"])\n    async def handler2(request, param):\n        return text(\"OK2 \" + param)\n\n    request, response = getattr(app.test_client, method)(\"/overload/test\")\n    assert getattr(response, attr) == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('method,attr, expected', [('get', 'text', 'OK1 test'), ('post', 'text', 'OK2 test'), ('put', 'text', 'OK2 test')])"
      ],
      "arguments": [
        "app",
        "method",
        "attr",
        "expected"
      ],
      "imports": [
        "pytest",
        "sanic_routing.exceptions.RouteExists",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert getattr(response, attr) == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_overload_dynamic_routes` function is designed to verify the behavior of dynamic route handling in a Sanic web application, specifically focusing on how the application responds to different HTTP methods (GET, POST, PUT) for the same route.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the correct handler is invoked based on the HTTP method used in the request. It ensures that a GET request to the `/overload/<param>` route returns a response from the first handler (`handler1`), while POST and PUT requests return responses from the second handler (`handler2`).\n\n**Code Being Tested and How It Works**:  \nThe test defines two asynchronous route handlers for the same dynamic route `/overload/<param>`. The first handler responds to GET requests, while the second handles POST and PUT requests. The test uses the `app.test_client` to simulate requests to the defined route and checks the response against the expected output. The `getattr` function is used to dynamically call the appropriate HTTP method on the test client and to access the specified attribute of the response.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Dynamic Route Testing**: The test leverages dynamic routing capabilities of the Sanic framework to handle variable path parameters.\n- **Method Overloading**: It demonstrates method overloading by defining multiple handlers for the same route based on the HTTP method.\n- **Parameterized Testing**: The test function accepts parameters (`method`, `attr`, `expected`), allowing it to be reused for different scenarios, which is a common practice in unit testing to reduce redundancy and improve maintainability."
    },
    {
      "name": "test_overload_dynamic_routes_exist",
      "module": "test_dynamic_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_dynamic_routes.py",
      "line_number": 29,
      "end_line_number": 44,
      "source_code": "def test_overload_dynamic_routes_exist(app):\n    @app.route(\"/overload/<param>\", methods=[\"GET\"])\n    async def handler1(request, param):\n        return text(\"OK1 \" + param)\n\n    @app.route(\"/overload/<param>\", methods=[\"POST\", \"PUT\"])\n    async def handler2(request, param):\n        return text(\"OK2 \" + param)\n\n    # if this doesn't raise an error, than at least the below should happen:\n    # assert response.text == 'Duplicated'\n    with pytest.raises(RouteExists):\n\n        @app.route(\"/overload/<param>\", methods=[\"PUT\", \"DELETE\"])\n        async def handler3(request, param):\n            return text(\"Duplicated\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic_routing.exceptions.RouteExists",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_overload_dynamic_routes_exist` test is designed to verify that the Sanic application correctly raises a `RouteExists` exception when attempting to register a new route that duplicates an existing dynamic route with the same path and conflicting HTTP methods.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks for the handling of route duplication in the Sanic framework. It ensures that when a new route is defined with the same path (`/overload/<param>`) and conflicting methods (`PUT` and `DELETE`), the application raises a `RouteExists` exception, indicating that the route cannot be added due to a conflict with an already defined route.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the registration of three asynchronous route handlers for the path `/overload/<param>`. The first handler (`handler1`) responds to `GET` requests, while the second handler (`handler2`) responds to `POST` and `PUT` requests. The test then attempts to register a third handler (`handler3`) for `PUT` and `DELETE` requests. The expectation is that this registration will fail with a `RouteExists` exception because the path and method combination conflicts with the existing routes.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of the `pytest.raises` context manager to assert that an exception is raised during the execution of the code block that attempts to register the duplicate route. This is a common pattern in unit testing for verifying that specific error conditions are handled correctly. Additionally, the test leverages the Sanic framework's routing capabilities to dynamically define routes and test their behavior in a controlled environment."
    },
    {
      "name": "test_keep_alive_timeout_reuse",
      "module": "test_keep_alive_timeout",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_keep_alive_timeout.py",
      "line_number": 64,
      "end_line_number": 95,
      "source_code": "def test_keep_alive_timeout_reuse(port):\n    \"\"\"If the server keep-alive timeout and client keep-alive timeout are\n    both longer than the delay, the client _and_ server will successfully\n    reuse the existing connection.\"\"\"\n    loops = 0\n    while True:\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n        client = ReusableClient(\n            keep_alive_timeout_app_reuse, loop=loop, port=port\n        )\n        try:\n            with client:\n                headers = {\"Connection\": \"keep-alive\"}\n                request, response = client.get(\"/1\", headers=headers)\n                assert response.status == 200\n                assert response.text == \"OK\"\n                assert request.protocol.state[\"requests_count\"] == 1\n\n                loop.run_until_complete(aio_sleep(1))\n\n                request, response = client.get(\"/1\")\n                assert response.status == 200\n                assert response.text == \"OK\"\n                assert request.protocol.state[\"requests_count\"] == 2\n        except OSError:\n            loops += 1\n            if loops > MAX_LOOPS:\n                raise\n            continue\n        else:\n            break",
      "docstring": "If the server keep-alive timeout and client keep-alive timeout are\nboth longer than the delay, the client _and_ server will successfully\nreuse the existing connection.",
      "decorators": [
        "pytest.mark.skipif(bool(environ.get('SANIC_NO_UVLOOP')) or OS_IS_WINDOWS, reason='Not testable with current client')"
      ],
      "arguments": [
        "port"
      ],
      "imports": [
        "asyncio",
        "platform",
        "asyncio.sleep",
        "itertools.count",
        "os.environ",
        "pytest",
        "sanic_testing.reusable.ReusableClient",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'OK'",
        "assert request.protocol.state['requests_count'] == 1",
        "assert response.status == 200",
        "assert response.text == 'OK'",
        "assert request.protocol.state['requests_count'] == 2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "environ.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_keep_alive_timeout_reuse` test verifies that both the server and client can successfully reuse an existing connection when their keep-alive timeouts are set longer than the delay between requests. This ensures efficient resource utilization and performance in handling multiple requests over the same connection.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that after an initial request is made, a subsequent request can be sent over the same connection without needing to establish a new one, provided that the keep-alive timeouts are respected. It asserts that the response status is 200 (OK) for both requests and that the request count is incremented correctly, indicating that the connection was reused.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves a `ReusableClient` that interacts with a server application (`keep_alive_timeout_app_reuse`). The test initiates a new event loop and creates a client instance. It sends a GET request with a \"keep-alive\" header, checks the response, waits for a second, and sends another GET request. The assertions confirm that the server responds correctly and that the request count reflects the reuse of the connection.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Looping with Exception Handling**: The test employs a loop to handle potential `OSError` exceptions, allowing for retries up to a maximum number of loops (`MAX_LOOPS`). This pattern is useful for dealing with transient issues, such as network errors or server unavailability.\n- **Asynchronous Testing**: The use of `asyncio` allows the test to handle asynchronous operations effectively, ensuring that the event loop is managed correctly and that the timing of requests is controlled.\n- **Assertions for State Verification**: The test includes multiple assertions to verify the state of the response and the request count, ensuring that the expected behavior of connection reuse is validated thoroughly."
    },
    {
      "name": "test_keep_alive_client_timeout",
      "module": "test_keep_alive_timeout",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_keep_alive_timeout.py",
      "line_number": 104,
      "end_line_number": 134,
      "source_code": "def test_keep_alive_client_timeout(port):\n    \"\"\"If the server keep-alive timeout is longer than the client\n    keep-alive timeout, client will try to create a new connection here.\"\"\"\n    loops = 0\n    while True:\n        try:\n            loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(loop)\n            client = ReusableClient(\n                keep_alive_app_client_timeout, loop=loop, port=port\n            )\n            with client:\n                headers = {\"Connection\": \"keep-alive\"}\n                request, response = client.get(\n                    \"/1\", headers=headers, timeout=1\n                )\n\n                assert response.status == 200\n                assert response.text == \"OK\"\n                assert request.protocol.state[\"requests_count\"] == 1\n\n                loop.run_until_complete(aio_sleep(2))\n                request, response = client.get(\"/1\", timeout=1)\n                assert request.protocol.state[\"requests_count\"] == 1\n        except OSError:\n            loops += 1\n            if loops > MAX_LOOPS:\n                raise\n            continue\n        else:\n            break",
      "docstring": "If the server keep-alive timeout is longer than the client\nkeep-alive timeout, client will try to create a new connection here.",
      "decorators": [
        "pytest.mark.skipif(bool(environ.get('SANIC_NO_UVLOOP')) or OS_IS_WINDOWS or platform.system() != 'Linux', reason='Not testable with current client')"
      ],
      "arguments": [
        "port"
      ],
      "imports": [
        "asyncio",
        "platform",
        "asyncio.sleep",
        "itertools.count",
        "os.environ",
        "pytest",
        "sanic_testing.reusable.ReusableClient",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'OK'",
        "assert request.protocol.state['requests_count'] == 1",
        "assert request.protocol.state['requests_count'] == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "environ.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_keep_alive_client_timeout` function is designed to verify that when the server's keep-alive timeout is longer than the client's keep-alive timeout, the client will attempt to establish a new connection after the timeout period. This ensures that the client can handle server timeouts gracefully and maintain connectivity.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the client successfully makes a request to the server, receives a valid response (status 200 and text \"OK\"), and that the request count remains consistent. It also verifies that after a delay (longer than the client's timeout), the client can still make a request without incrementing the request count, indicating that it is reusing the connection correctly.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `ReusableClient` class, which manages HTTP connections. The test creates a new event loop and a client instance, then sends a GET request to the server. The server is expected to respond with a 200 status and \"OK\" text. After a sleep period (to simulate the keep-alive timeout), the test sends another request to check if the connection is still valid and that the request count has not increased, indicating that the same connection is being reused.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Loop with Exception Handling**: The test employs a loop that retries the connection setup in case of an `OSError`, allowing for resilience against transient issues (like port unavailability).\n- **Asynchronous Testing**: It utilizes `asyncio` to manage asynchronous operations, ensuring that the test can handle non-blocking I/O effectively.\n- **Assertions**: The test includes multiple assertions to validate the response status, response content, and the internal state of the request protocol, ensuring comprehensive verification of the expected behavior."
    },
    {
      "name": "test_keep_alive_server_timeout",
      "module": "test_keep_alive_timeout",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_keep_alive_timeout.py",
      "line_number": 141,
      "end_line_number": 174,
      "source_code": "def test_keep_alive_server_timeout(port):\n    \"\"\"If the client keep-alive timeout is longer than the server\n    keep-alive timeout, the client will either a 'Connection reset' error\n    _or_ a new connection. Depending on how the event-loop handles the\n    broken server connection.\"\"\"\n    loops = 0\n    while True:\n        try:\n            loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(loop)\n            client = ReusableClient(\n                keep_alive_app_server_timeout, loop=loop, port=port\n            )\n            with client:\n                headers = {\"Connection\": \"keep-alive\"}\n                request, response = client.get(\n                    \"/1\", headers=headers, timeout=60\n                )\n\n                assert response.status == 200\n                assert response.text == \"OK\"\n                assert request.protocol.state[\"requests_count\"] == 1\n\n                loop.run_until_complete(aio_sleep(3))\n                request, response = client.get(\"/1\", timeout=60)\n\n                assert request.protocol.state[\"requests_count\"] == 1\n        except OSError:\n            loops += 1\n            if loops > MAX_LOOPS:\n                raise\n            continue\n        else:\n            break",
      "docstring": "If the client keep-alive timeout is longer than the server\nkeep-alive timeout, the client will either a 'Connection reset' error\n_or_ a new connection. Depending on how the event-loop handles the\nbroken server connection.",
      "decorators": [
        "pytest.mark.skipif(bool(environ.get('SANIC_NO_UVLOOP')) or OS_IS_WINDOWS, reason='Not testable with current client')"
      ],
      "arguments": [
        "port"
      ],
      "imports": [
        "asyncio",
        "platform",
        "asyncio.sleep",
        "itertools.count",
        "os.environ",
        "pytest",
        "sanic_testing.reusable.ReusableClient",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'OK'",
        "assert request.protocol.state['requests_count'] == 1",
        "assert request.protocol.state['requests_count'] == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "environ.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_keep_alive_server_timeout` test is designed to verify the behavior of a client-server interaction when the client's keep-alive timeout exceeds that of the server. It checks whether the client can handle a potential 'Connection reset' error or establish a new connection, depending on how the event loop manages the broken connection.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically verifies that when a client sends a request with a keep-alive header, the server responds correctly (with a status of 200 and text \"OK\") and that the request count remains consistent. It also ensures that after a delay (simulating a timeout), the client can still make a request without incrementing the request count, indicating that the connection is still valid.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `ReusableClient` class, which is initialized with a server application (`keep_alive_app_server_timeout`) and an event loop. The test sends a GET request to the server and checks the response status and content. It then waits for 3 seconds (to simulate a timeout scenario) and sends another request to verify that the request count remains unchanged. The test handles potential `OSError` exceptions, which may occur if the server connection is broken, and it retries the connection a limited number of times (`MAX_LOOPS`).\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a loop to handle transient errors, allowing for retries when an `OSError` occurs. It uses assertions to validate the expected outcomes of the requests, ensuring that the server behaves as intended under the specified conditions. Additionally, the use of `asyncio` for managing the event loop and asynchronous operations is a notable pattern, reflecting modern Python testing practices for asynchronous code. The test is also conditionally skipped based on environment variables, which is a useful technique for ensuring that tests are only run in appropriate contexts."
    },
    {
      "name": "test_keep_alive_connection_context",
      "module": "test_keep_alive_timeout",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_keep_alive_timeout.py",
      "line_number": 181,
      "end_line_number": 211,
      "source_code": "def test_keep_alive_connection_context(port):\n    loops = 0\n    while True:\n        try:\n            loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(loop)\n            client = ReusableClient(\n                keep_alive_app_context, loop=loop, port=port\n            )\n            with client:\n                headers = {\"Connection\": \"keep-alive\"}\n                request1, _ = client.post(\"/ctx\", headers=headers)\n\n                loop.run_until_complete(aio_sleep(1))\n                request2, response = client.get(\"/ctx\")\n\n                assert response.text == \"hello\"\n                assert id(request1.conn_info.ctx) == id(request2.conn_info.ctx)\n                assert (\n                    request1.conn_info.ctx.foo\n                    == request2.conn_info.ctx.foo\n                    == \"hello\"\n                )\n                assert request2.protocol.state[\"requests_count\"] == 2\n        except OSError:\n            loops += 1\n            if loops > MAX_LOOPS:\n                raise\n            continue\n        else:\n            break",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(bool(environ.get('SANIC_NO_UVLOOP')) or OS_IS_WINDOWS, reason='Not testable with current client')"
      ],
      "arguments": [
        "port"
      ],
      "imports": [
        "asyncio",
        "platform",
        "asyncio.sleep",
        "itertools.count",
        "os.environ",
        "pytest",
        "sanic_testing.reusable.ReusableClient",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'hello'",
        "assert id(request1.conn_info.ctx) == id(request2.conn_info.ctx)",
        "assert request1.conn_info.ctx.foo == request2.conn_info.ctx.foo == 'hello'",
        "assert request2.protocol.state['requests_count'] == 2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "environ.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_keep_alive_connection_context` function is designed to verify that a keep-alive connection in a Sanic web application maintains the same context across multiple requests. This ensures that the application can handle persistent connections correctly, allowing for efficient resource usage and state management.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. The response from a GET request after a POST request returns the expected text (\"hello\").\n2. The context (`ctx`) associated with the connection remains the same across both requests, confirming that the connection is indeed reusable.\n3. The `requests_count` in the protocol state is incremented correctly, indicating that the server is tracking the number of requests made over the keep-alive connection.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves a Sanic application that handles HTTP requests. The `ReusableClient` is used to simulate client requests to the application. The test performs the following steps:\n1. It creates a new event loop and sets it as the current loop.\n2. It initializes a `ReusableClient` with the application context and specified port.\n3. It sends a POST request to the `/ctx` endpoint with a \"keep-alive\" header, then waits for a second.\n4. It sends a subsequent GET request to the same endpoint and checks the response and context.\n5. The assertions validate that the response text is \"hello\", the context IDs are the same, and the request count is correct.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Retry Logic**: The test includes a loop that retries the connection setup in case of an `OSError`, allowing for resilience against transient errors (e.g., port unavailability).\n- **Context Management**: The use of a context manager (`with client:`) ensures that resources are properly managed and cleaned up after the requests are made.\n- **Asynchronous Testing**: The test leverages asynchronous programming with `asyncio`, allowing for non-blocking operations and efficient handling of I/O-bound tasks.\n- **Assertions**: Multiple assertions are used to verify different aspects of the response and connection state, ensuring comprehensive coverage of the expected behavior."
    },
    {
      "name": "test_versioned_named_routes_get",
      "module": "test_named_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_named_routes.py",
      "line_number": 21,
      "end_line_number": 75,
      "source_code": "def test_versioned_named_routes_get(method):\n    app = Sanic(\"app\")\n\n    bp = Blueprint(\"test_bp\", url_prefix=\"/bp\")\n\n    method = method.lower()\n    route_name = f\"route_{method}\"\n    route_name2 = f\"route2_{method}\"\n\n    func = getattr(app, method)\n    if callable(func):\n\n        @func(f\"/{method}\", version=1, name=route_name)\n        def handler(request):\n            return text(\"OK\")\n\n    else:\n        raise\n\n    func = getattr(bp, method)\n    if callable(func):\n\n        @func(f\"/{method}\", version=1, name=route_name2)\n        def handler2(request):\n            return text(\"OK\")\n\n    else:\n        raise\n\n    app.blueprint(bp)\n\n    assert (\n        app.router.routes_all[\n            (\n                \"v1\",\n                method,\n            )\n        ].name\n        == f\"app.{route_name}\"\n    )\n\n    route = app.router.routes_all[\n        (\n            \"v1\",\n            \"bp\",\n            method,\n        )\n    ]\n    assert route.name == f\"app.test_bp.{route_name2}\"\n\n    assert app.url_for(route_name) == f\"/v1/{method}\"\n    url = app.url_for(f\"test_bp.{route_name2}\")\n    assert url == f\"/v1/bp/{method}\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler\")",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('method', HTTP_METHODS)"
      ],
      "arguments": [
        "method"
      ],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.router.routes_all['v1', method].name == f'app.{route_name}'",
        "assert route.name == f'app.test_bp.{route_name2}'",
        "assert app.url_for(route_name) == f'/v1/{method}'",
        "assert url == f'/v1/bp/{method}'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_versioned_named_routes_get` function is designed to verify the correct registration and resolution of versioned named routes in a Sanic web application. It ensures that routes can be accessed using their names and that they are correctly associated with their respective HTTP methods and versions.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. Routes are correctly registered with the expected names based on their HTTP methods and versions.\n2. The `url_for` method generates the correct URLs for the registered routes.\n3. An attempt to access a non-existent route raises a `URLBuildError`, confirming that the routing system behaves as expected when given invalid input.\n\n**Code Being Tested and How It Works**:  \nThe test creates a Sanic application and a blueprint, then dynamically registers routes for both the application and the blueprint using the specified HTTP method (GET, POST, etc.). The routes are assigned names based on the method and version. The assertions verify that:\n- The route names match the expected format.\n- The URLs generated by `url_for` correspond to the correct paths.\n- Invalid route names trigger the appropriate error.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Dynamic Route Registration**: The test uses `getattr` to dynamically register routes based on the provided method, showcasing flexibility in testing various HTTP methods.\n- **Assertions for Route Properties**: It employs assertions to validate both the route names and the generated URLs, ensuring comprehensive coverage of the routing functionality.\n- **Error Handling Verification**: The use of `pytest.raises` to check for exceptions ensures that the test not only verifies correct behavior but also confirms that the application handles errors gracefully."
    },
    {
      "name": "test_shorthand_default_routes_get",
      "module": "test_named_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_named_routes.py",
      "line_number": 78,
      "end_line_number": 86,
      "source_code": "def test_shorthand_default_routes_get():\n    app = Sanic(\"app\")\n\n    @app.get(\"/get\")\n    def handler(request):\n        return text(\"OK\")\n\n    assert app.router.routes_all[(\"get\",)].name == \"app.handler\"\n    assert app.url_for(\"handler\") == \"/get\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.router.routes_all['get',].name == 'app.handler'",
        "assert app.url_for('handler') == '/get'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_shorthand_default_routes_get` test is to verify the correct registration and functionality of a simple GET route in a Sanic web application. It ensures that the route is properly set up and can be accessed as expected.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks two main behaviors: \n1. It verifies that the route handler for the GET request to the path `/get` is correctly named and associated with the expected route.\n2. It confirms that the URL generation for the handler using the `url_for` method returns the correct path.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes:\n- The `app.get` method, which registers a GET route at the specified URI (`/get`) and associates it with a handler function that returns a response with the text \"OK\".\n- The `app.url_for` method, which generates a URL for the registered route based on the handler's name. In this case, it should return `/get` when called with the handler's name.\n\nThe assertions in the test check:\n- If the route's name in the router matches the expected name (`\"app.handler\"`).\n- If calling `app.url_for(\"handler\")` returns the correct URL (`\"/get\"`).\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Direct Assertions**: It uses assertions to directly verify the expected outcomes, which is a straightforward approach to unit testing.\n- **Route Registration Verification**: It checks the internal state of the router to ensure that the route is registered correctly, which is essential for validating the routing mechanism.\n- **URL Generation Testing**: The test validates the URL generation functionality, ensuring that the application can dynamically create URLs based on route names, which is crucial for building RESTful APIs. \n\nOverall, this test exemplifies a basic yet effective unit test for route handling in a web framework."
    },
    {
      "name": "test_shorthand_named_routes_get",
      "module": "test_named_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_named_routes.py",
      "line_number": 89,
      "end_line_number": 119,
      "source_code": "def test_shorthand_named_routes_get():\n    app = Sanic(\"app\")\n    bp = Blueprint(\"test_bp\", url_prefix=\"/bp\")\n\n    @app.get(\"/get\", name=\"route_get\")\n    def handler(request):\n        return text(\"OK\")\n\n    @bp.get(\"/get\", name=\"route_bp\")\n    def handler2(request):\n        return text(\"Blueprint\")\n\n    app.blueprint(bp)\n\n    assert app.router.routes_all[(\"get\",)].name == \"app.route_get\"\n    assert app.url_for(\"route_get\") == \"/get\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler\")\n\n    assert (\n        app.router.routes_all[\n            (\n                \"bp\",\n                \"get\",\n            )\n        ].name\n        == \"app.test_bp.route_bp\"\n    )\n    assert app.url_for(\"test_bp.route_bp\") == \"/bp/get\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"test_bp.handler2\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.router.routes_all['get',].name == 'app.route_get'",
        "assert app.url_for('route_get') == '/get'",
        "assert app.router.routes_all['bp', 'get'].name == 'app.test_bp.route_bp'",
        "assert app.url_for('test_bp.route_bp') == '/bp/get'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_shorthand_named_routes_get` test is to verify the correct registration and functionality of named routes in a Sanic application, including routes defined in a blueprint. It ensures that the application can correctly resolve URLs based on route names and that it raises appropriate errors when attempting to access non-existent routes.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. The main application route (`/get`) is correctly registered with the name `route_get`.\n2. The blueprint route (`/bp/get`) is correctly registered with the name `route_bp`.\n3. The `url_for` method can generate the correct URLs for these named routes.\n4. An error is raised when trying to access a route that does not exist (e.g., `handler`).\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Sanic application and a blueprint, defining two GET routes:\n- The main application route `/get` returns \"OK\" and is named `route_get`.\n- The blueprint route `/bp/get` returns \"Blueprint\" and is named `route_bp`.\n\nAfter registering the blueprint with the application, the test asserts that:\n- The names of the routes match the expected format (`app.route_get` and `app.test_bp.route_bp`).\n- The `url_for` method returns the correct paths for these named routes.\n- Attempting to resolve a non-existent route raises a `URLBuildError`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Assertions**: It uses assertions to validate the expected outcomes, ensuring that the application behaves as intended.\n- **Error Handling**: The test checks for exceptions using `pytest.raises`, which is a common technique to verify that the application correctly handles erroneous conditions.\n- **Blueprints**: It demonstrates the use of blueprints in Sanic, showcasing how routes can be organized and namespaced, which is a common practice in web applications for modularity and maintainability."
    },
    {
      "name": "test_shorthand_named_routes_post",
      "module": "test_named_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_named_routes.py",
      "line_number": 122,
      "end_line_number": 132,
      "source_code": "def test_shorthand_named_routes_post():\n    app = Sanic(\"app\")\n\n    @app.post(\"/post\", name=\"route_name\")\n    def handler(request):\n        return text(\"OK\")\n\n    assert app.router.routes_all[(\"post\",)].name == \"app.route_name\"\n    assert app.url_for(\"route_name\") == \"/post\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.router.routes_all['post',].name == 'app.route_name'",
        "assert app.url_for('route_name') == '/post'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_shorthand_named_routes_post` function is designed to verify the correct behavior of the Sanic framework's routing system, specifically for POST requests. It checks that named routes are properly registered and can be accessed using their names.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that:\n1. A POST route can be defined with a specific name.\n2. The route can be correctly referenced by its name to retrieve the associated URL.\n3. An attempt to access a non-existent route by name raises the appropriate error (`URLBuildError`).\n\n**Code Being Tested and How It Works**:  \nThe test creates a Sanic application instance and defines a POST route at `/post` with the name `route_name`. It then asserts:\n- The name of the route in the router matches the expected format (`app.route_name`).\n- The URL generated by `app.url_for(\"route_name\")` correctly resolves to `/post`.\n- An attempt to generate a URL for a handler that does not exist (in this case, `handler`) raises a `URLBuildError`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertions**: The test uses assertions to validate the expected outcomes, ensuring that the route name and URL generation behave as intended.\n- **Exception Testing**: The use of `pytest.raises` is a notable technique here, as it checks that the correct exception is raised when trying to access a non-existent route, which is crucial for robust error handling in web applications.\n- **Isolation**: The test is self-contained, creating its own application instance and route, which helps ensure that it does not interfere with other tests and maintains a clear focus on the specific functionality being tested."
    },
    {
      "name": "test_shorthand_named_routes_put",
      "module": "test_named_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_named_routes.py",
      "line_number": 135,
      "end_line_number": 145,
      "source_code": "def test_shorthand_named_routes_put():\n    app = Sanic(\"app\")\n\n    @app.put(\"/put\", name=\"route_put\")\n    def handler(request):\n        return text(\"OK\")\n\n    assert app.router.routes_all[(\"put\",)].name == \"app.route_put\"\n    assert app.url_for(\"route_put\") == \"/put\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.router.routes_all['put',].name == 'app.route_put'",
        "assert app.url_for('route_put') == '/put'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_shorthand_named_routes_put` function is designed to verify the correct behavior of the Sanic framework's routing system when defining and using a PUT route with a specific name. It ensures that the route can be accessed correctly and that the URL generation for the named route functions as expected.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that:\n1. The route defined with the PUT method is correctly registered with the expected name.\n2. The URL for the named route can be generated accurately using the `url_for` method.\n3. An attempt to generate a URL for a non-existent handler raises a `URLBuildError`, confirming that the routing system correctly handles invalid requests.\n\n**Code Being Tested and How It Works**:  \nThe test defines a PUT route at the path `/put` with the name `route_put`. The assertions check:\n- The name of the route in the router's collection (`app.router.routes_all`) matches the expected format (`app.route_put`).\n- The `url_for` method returns the correct URL (`/put`) for the named route.\n- The test uses `pytest.raises` to assert that calling `url_for` with a non-existent handler name (`handler`) raises a `URLBuildError`, indicating that the routing system is functioning correctly in terms of error handling.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertions**: The test uses assertions to validate the expected outcomes, which is a common practice in unit testing to ensure that the code behaves as intended.\n- **Exception Testing**: The use of `pytest.raises` to check for exceptions is a notable technique that ensures the code not only works under normal conditions but also handles erroneous conditions gracefully.\n- **Route Naming**: The test emphasizes the importance of route naming in web frameworks, ensuring that developers can reference routes by meaningful names rather than just paths, which enhances code readability and maintainability."
    },
    {
      "name": "test_shorthand_named_routes_delete",
      "module": "test_named_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_named_routes.py",
      "line_number": 148,
      "end_line_number": 158,
      "source_code": "def test_shorthand_named_routes_delete():\n    app = Sanic(\"app\")\n\n    @app.delete(\"/delete\", name=\"route_delete\")\n    def handler(request):\n        return text(\"OK\")\n\n    assert app.router.routes_all[(\"delete\",)].name == \"app.route_delete\"\n    assert app.url_for(\"route_delete\") == \"/delete\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.router.routes_all['delete',].name == 'app.route_delete'",
        "assert app.url_for('route_delete') == '/delete'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.delete",
          "body": "def delete(self, request):\n    return text('I am delete method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_shorthand_named_routes_delete` test is to verify the correct functionality of the DELETE route registration and URL generation in the Sanic web framework. It ensures that the route can be accessed correctly and that the URL can be generated using the route's name.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that:\n1. The DELETE route is correctly registered with the name \"route_delete\".\n2. The URL for the named route can be generated accurately using `app.url_for(\"route_delete\")`.\n3. An attempt to generate a URL for a non-existent handler (in this case, \"handler\") raises a `URLBuildError`.\n\n**Code Being Tested and How It Works**:  \nThe test defines a DELETE route using the `@app.delete` decorator, which associates the path \"/delete\" with a handler function that returns a simple text response \"OK\". The assertions check:\n- The name of the route in the router's route collection (`app.router.routes_all`) to ensure it matches the expected name \"app.route_delete\".\n- The output of `app.url_for(\"route_delete\")` to confirm it returns the correct URL \"/delete\".\n- The test also verifies that trying to generate a URL for a handler that is not registered raises the appropriate error.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Assertion-Based Testing**: It uses assertions to validate expected outcomes, which is a common practice in unit testing.\n- **Error Handling Verification**: The use of `pytest.raises` to check for exceptions ensures that the code behaves correctly under erroneous conditions.\n- **Route Naming and URL Generation**: The test emphasizes the importance of route naming and the ability to generate URLs dynamically, which is crucial for web applications that rely on routing mechanisms."
    },
    {
      "name": "test_shorthand_named_routes_patch",
      "module": "test_named_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_named_routes.py",
      "line_number": 161,
      "end_line_number": 171,
      "source_code": "def test_shorthand_named_routes_patch():\n    app = Sanic(\"app\")\n\n    @app.patch(\"/patch\", name=\"route_patch\")\n    def handler(request):\n        return text(\"OK\")\n\n    assert app.router.routes_all[(\"patch\",)].name == \"app.route_patch\"\n    assert app.url_for(\"route_patch\") == \"/patch\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.router.routes_all['patch',].name == 'app.route_patch'",
        "assert app.url_for('route_patch') == '/patch'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "app.patch('/patch', name='route_patch')"
      ],
      "methods_under_test": [
        {
          "name": "app.patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_shorthand_named_routes_patch` test is to verify the correct behavior of the Sanic framework's routing system when defining and accessing a PATCH route with a specific name. It ensures that the route is properly registered and can be accessed using the `url_for` method.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that:\n1. The route defined with the PATCH method is correctly named and can be retrieved from the router.\n2. The `url_for` method returns the correct URL for the named route.\n3. An attempt to access a non-existent route (in this case, a handler that is not registered) raises a `URLBuildError`.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes:\n- The `app.patch` method, which registers a PATCH route at the path `/patch` with the name `route_patch`. The handler function returns a simple text response \"OK\".\n- The `app.url_for` method, which is used to generate the URL for the named route. It should return `/patch` when called with the name `route_patch`.\n- The test also checks that calling `app.url_for` with a non-existent handler name (`handler`) raises a `URLBuildError`, indicating that the endpoint cannot be found.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertions**: The test uses assertions to validate the expected outcomes, such as checking the route name and the URL generated by `url_for`.\n- **Exception Testing**: The test employs `pytest.raises` to assert that a specific exception (`URLBuildError`) is raised when trying to access a non-existent route, demonstrating the use of exception handling in tests.\n- **Isolation**: Each test case is self-contained, creating a new instance of the Sanic app, which ensures that tests do not interfere with each other and can be run independently."
    },
    {
      "name": "test_shorthand_named_routes_head",
      "module": "test_named_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_named_routes.py",
      "line_number": 174,
      "end_line_number": 184,
      "source_code": "def test_shorthand_named_routes_head():\n    app = Sanic(\"app\")\n\n    @app.head(\"/head\", name=\"route_head\")\n    def handler(request):\n        return text(\"OK\")\n\n    assert app.router.routes_all[(\"head\",)].name == \"app.route_head\"\n    assert app.url_for(\"route_head\") == \"/head\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.router.routes_all['head',].name == 'app.route_head'",
        "assert app.url_for('route_head') == '/head'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.head",
          "body": "def head(self, request):\n    return text('', headers={'method': 'HEAD'})"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_shorthand_named_routes_head` unit test is designed to verify the correct behavior of the Sanic web framework when defining and using a shorthand named route with the HTTP HEAD method. It ensures that the route is properly registered and can be accessed using its name.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. The route defined with the HEAD method is correctly registered with the expected name.\n2. The `url_for` method can generate the correct URL for the named route.\n3. An attempt to access a non-existent route (using the handler's name) raises a `URLBuildError`.\n\n**Code Being Tested and How It Works**:  \nThe test creates a Sanic application instance and defines a route using the `@app.head` decorator, which registers a handler for the HEAD method at the path `/head` with the name `route_head`. The assertions verify:\n- The route's name in the router matches the expected format (`app.route_head`).\n- The `url_for` method returns the correct URL (`/head`) for the named route.\n- The test checks for an error when trying to generate a URL for a handler that is not registered as a route.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertions**: The test uses assertions to validate the expected outcomes, ensuring that the route registration and URL generation behave as intended.\n- **Exception Testing**: The use of `pytest.raises` is a common pattern to assert that specific exceptions are raised under certain conditions, in this case, when trying to access a non-existent route.\n- **Route Naming**: The test demonstrates the use of named routes, which is a feature that enhances the readability and maintainability of route definitions in web applications."
    },
    {
      "name": "test_shorthand_named_routes_options",
      "module": "test_named_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_named_routes.py",
      "line_number": 187,
      "end_line_number": 197,
      "source_code": "def test_shorthand_named_routes_options():\n    app = Sanic(\"app\")\n\n    @app.options(\"/options\", name=\"route_options\")\n    def handler(request):\n        return text(\"OK\")\n\n    assert app.router.routes_all[(\"options\",)].name == \"app.route_options\"\n    assert app.url_for(\"route_options\") == \"/options\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.router.routes_all['options',].name == 'app.route_options'",
        "assert app.url_for('route_options') == '/options'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.options",
          "body": "def options(self, request):\n    return text('', headers={'method': 'OPTIONS'})"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_shorthand_named_routes_options` test is to verify the correct behavior of the Sanic framework when defining and using shorthand named routes with the HTTP OPTIONS method. It ensures that the route is properly registered and can be accessed via its name.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that:\n1. The route defined with the OPTIONS method is correctly registered with the expected name.\n2. The URL can be generated using the route's name.\n3. An attempt to generate a URL for a non-existent handler raises a `URLBuildError`.\n\n**Code Being Tested and How It Works**:  \nThe test defines a Sanic application and registers an OPTIONS route at the path `/options` with the name `route_options`. The assertions verify:\n- The route's name in the router matches the expected format (`app.route_options`).\n- The `url_for` method correctly resolves the route name to the path `/options`.\n- The test checks that calling `url_for` with a non-existent handler (`handler`) raises a `URLBuildError`, indicating that the framework correctly handles errors for undefined routes.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertions**: The test uses assertions to validate the expected outcomes, ensuring that the route registration and URL generation behave as intended.\n- **Exception Testing**: The use of `pytest.raises` to check for `URLBuildError` demonstrates a common pattern in unit testing where the expected failure conditions are explicitly tested.\n- **Route Naming Convention**: The test reinforces the importance of consistent naming conventions for routes, which aids in maintainability and clarity within the codebase."
    },
    {
      "name": "test_named_static_routes",
      "module": "test_named_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_named_routes.py",
      "line_number": 200,
      "end_line_number": 221,
      "source_code": "def test_named_static_routes():\n    app = Sanic(\"app\")\n\n    @app.route(\"/test\", name=\"route_test\")\n    async def handler1(request):\n        return text(\"OK1\")\n\n    @app.route(\"/pizazz\", name=\"route_pizazz\")\n    async def handler2(request):\n        return text(\"OK2\")\n\n    assert app.router.routes_all[(\"test\",)].name == \"app.route_test\"\n    assert app.router.routes_static[(\"test\",)][0].name == \"app.route_test\"\n    assert app.url_for(\"route_test\") == \"/test\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler1\")\n\n    assert app.router.routes_all[(\"pizazz\",)].name == \"app.route_pizazz\"\n    assert app.router.routes_static[(\"pizazz\",)][0].name == \"app.route_pizazz\"\n    assert app.url_for(\"route_pizazz\") == \"/pizazz\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler2\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.router.routes_all['test',].name == 'app.route_test'",
        "assert app.router.routes_static['test',][0].name == 'app.route_test'",
        "assert app.url_for('route_test') == '/test'",
        "assert app.router.routes_all['pizazz',].name == 'app.route_pizazz'",
        "assert app.router.routes_static['pizazz',][0].name == 'app.route_pizazz'",
        "assert app.url_for('route_pizazz') == '/pizazz'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_named_static_routes` function is designed to verify the correct registration and retrieval of named static routes in a Sanic web application. It ensures that routes can be accessed by their names and that the expected behavior occurs when attempting to access non-existent routes.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. Routes are correctly registered with their respective names.\n2. The `url_for` method returns the correct URL for the named routes.\n3. An attempt to access a route by a handler name (which is not a registered route) raises a `URLBuildError`.\n\n**Code Being Tested and How It Works**:  \nThe test creates a Sanic application instance and defines two static routes (`/test` and `/pizazz`) with names `route_test` and `route_pizazz`, respectively. It then asserts:\n- The names of the routes in the router's `routes_all` and `routes_static` collections.\n- The output of the `url_for` method for both named routes.\n- The expected exceptions when trying to access non-existent routes by handler names.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertions**: The test uses assertions to validate the expected outcomes, ensuring that the routes are registered correctly and that the URL generation behaves as intended.\n- **Exception Testing**: The use of `pytest.raises` to check for `URLBuildError` demonstrates a common pattern in unit testing where the behavior of the code under exceptional conditions is verified.\n- **Isolation**: The test is self-contained, creating its own application instance and routes, which allows for focused testing without side effects from other tests."
    },
    {
      "name": "test_named_dynamic_route",
      "module": "test_named_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_named_routes.py",
      "line_number": 224,
      "end_line_number": 244,
      "source_code": "def test_named_dynamic_route():\n    app = Sanic(\"app\")\n    results = []\n\n    @app.route(\"/folder/<name>\", name=\"route_dynamic\")\n    async def handler(request, name):\n        results.append(name)\n        return text(\"OK\")\n\n    assert (\n        app.router.routes_all[\n            (\n                \"folder\",\n                \"<name:str>\",\n            )\n        ].name\n        == \"app.route_dynamic\"\n    )\n    assert app.url_for(\"route_dynamic\", name=\"test\") == \"/folder/test\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.router.routes_all['folder', '<name:str>'].name == 'app.route_dynamic'",
        "assert app.url_for('route_dynamic', name='test') == '/folder/test'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_named_dynamic_route` function is designed to verify the correct behavior of dynamic routing in a Sanic web application. It specifically checks that named routes are properly registered and can be resolved to their expected URLs.\n\n**Specific Functionality or Behavior Verified**:  \nThe test ensures that:\n1. The route defined with a dynamic segment (`<name>`) is correctly named and can be accessed via the `url_for` method.\n2. The URL generated by `url_for` for the named route matches the expected path format.\n3. An attempt to generate a URL for a non-existent route raises a `URLBuildError`.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes:\n- The route definition `@app.route(\"/folder/<name>\", name=\"route_dynamic\")`, which creates a dynamic route that captures a segment of the URL as a variable (`name`).\n- The assertion `app.router.routes_all[(\"folder\", \"<name:str>\")].name == \"app.route_dynamic\"` checks that the route is registered with the correct name.\n- The assertion `app.url_for(\"route_dynamic\", name=\"test\") == \"/folder/test\"` verifies that calling `url_for` with the route name and a parameter generates the expected URL.\n- The `with pytest.raises(URLBuildError)` block tests that an error is raised when trying to generate a URL for a handler that is not registered as a route.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertions**: The test uses assertions to validate expected outcomes, ensuring that the route name and URL generation behave as intended.\n- **Error Handling**: The test employs `pytest.raises` to confirm that the application correctly raises an error when attempting to access an undefined route, demonstrating robust error handling.\n- **Dynamic Routing**: The test showcases the use of dynamic segments in route definitions, which is a common pattern in web frameworks for creating flexible and reusable routes."
    },
    {
      "name": "test_dynamic_named_route_regex",
      "module": "test_named_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_named_routes.py",
      "line_number": 247,
      "end_line_number": 263,
      "source_code": "def test_dynamic_named_route_regex():\n    app = Sanic(\"app\")\n\n    @app.route(\"/folder/<folder_id:[A-Za-z0-9]{0,4}>\", name=\"route_re\")\n    async def handler(request, folder_id):\n        return text(\"OK\")\n\n    route = app.router.routes_all[\n        (\n            \"folder\",\n            \"<folder_id:[A-Za-z0-9]{0,4}>\",\n        )\n    ]\n    assert route.name == \"app.route_re\"\n    assert app.url_for(\"route_re\", folder_id=\"test\") == \"/folder/test\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert route.name == 'app.route_re'",
        "assert app.url_for('route_re', folder_id='test') == '/folder/test'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_dynamic_named_route_regex` function is designed to verify the behavior of dynamic named routes in the Sanic web framework, specifically focusing on routes that utilize regular expressions for parameter validation.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that:\n1. The route is correctly registered with the expected name.\n2. The URL generation for the route works as intended when valid parameters are provided.\n3. An error is raised when attempting to generate a URL for a handler that does not have a corresponding route.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route in a Sanic application that matches a specific pattern: `/folder/<folder_id:[A-Za-z0-9]{0,4}>`. The route handler returns a simple text response. The test then accesses the route's metadata to confirm that its name is correctly set to `app.route_re`. It also uses the `url_for` method to generate a URL for the route with a valid `folder_id`, ensuring it returns the expected path. Finally, it checks that invoking `url_for` with an invalid route name raises a `URLBuildError`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertions**: The test employs assertions to validate the expected outcomes, such as checking the route name and the generated URL.\n- **Exception Testing**: It uses `pytest.raises` to assert that specific exceptions are raised under certain conditions, ensuring robust error handling in the application.\n- **Dynamic Routing**: The test demonstrates the use of dynamic routing with regex patterns, showcasing how Sanic can handle complex URL structures and parameter validation."
    },
    {
      "name": "test_dynamic_named_route_path",
      "module": "test_named_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_named_routes.py",
      "line_number": 266,
      "end_line_number": 282,
      "source_code": "def test_dynamic_named_route_path():\n    app = Sanic(\"app\")\n\n    @app.route(\"/<path:path>/info\", name=\"route_dynamic_path\")\n    async def handler(request, path):\n        return text(\"OK\")\n\n    route = app.router.routes_all[\n        (\n            \"<path:path>\",\n            \"info\",\n        )\n    ]\n    assert route.name == \"app.route_dynamic_path\"\n    assert app.url_for(\"route_dynamic_path\", path=\"path/1\") == \"/path/1/info\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert route.name == 'app.route_dynamic_path'",
        "assert app.url_for('route_dynamic_path', path='path/1') == '/path/1/info'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_dynamic_named_route_path` unit test is designed to verify the correct behavior of dynamic named routes in a Sanic web application. It ensures that the routing mechanism correctly identifies and constructs URLs based on dynamic path parameters.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. The name of the dynamically created route is correctly set.\n2. The `url_for` method generates the expected URL when provided with a specific path parameter.\n3. An exception (`URLBuildError`) is raised when attempting to generate a URL for a non-existent route.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves a Sanic application where a route is defined with a dynamic path parameter (`<path:path>`). The route is named `route_dynamic_path`, and the handler returns a simple text response. The test accesses the route through the application's router and verifies its name. It also tests the `url_for` method to ensure it constructs the URL `/path/1/info` when the path parameter is set to `path/1`. Finally, it checks that an error is raised when trying to generate a URL for a handler that does not have a corresponding route.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertions**: The test uses assertions to validate expected outcomes, such as checking the route name and the generated URL.\n- **Exception Testing**: It employs `pytest.raises` to assert that a specific exception is raised under certain conditions, ensuring robust error handling in the routing logic.\n- **Dynamic Routing**: The test demonstrates the use of dynamic routing in web applications, showcasing how parameters can be captured and utilized in URL generation."
    },
    {
      "name": "test_dynamic_named_route_unhashable",
      "module": "test_named_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_named_routes.py",
      "line_number": 285,
      "end_line_number": 305,
      "source_code": "def test_dynamic_named_route_unhashable():\n    app = Sanic(\"app\")\n\n    @app.route(\n        \"/folder/<unhashable:[A-Za-z0-9/]+>/end/\", name=\"route_unhashable\"\n    )\n    async def handler(request, unhashable):\n        return text(\"OK\")\n\n    route = app.router.routes_all[\n        (\n            \"folder\",\n            \"<unhashable:[A-Za-z0-9/]+>\",\n            \"end\",\n        )\n    ]\n    assert route.name == \"app.route_unhashable\"\n    url = app.url_for(\"route_unhashable\", unhashable=\"test/asdf\")\n    assert url == \"/folder/test/asdf/end\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert route.name == 'app.route_unhashable'",
        "assert url == '/folder/test/asdf/end'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_dynamic_named_route_unhashable` test is to verify the correct behavior of dynamic named routes in the Sanic web framework, specifically when using unhashable types as route parameters. It ensures that the routing mechanism can handle parameters that include special characters (like slashes) and that the URL generation works as expected.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that:\n1. The route is correctly registered with the expected name.\n2. The URL generated for the route with a specific unhashable parameter is accurate.\n3. An error is raised when attempting to generate a URL for a handler that is not a named route.\n\n**Code Being Tested and How It Works**:  \nThe test defines a Sanic application and a route that accepts a dynamic parameter `unhashable`, which is constrained by a regex pattern to allow alphanumeric characters and slashes. The route is named `route_unhashable`. The test then retrieves the route from the router and asserts that its name matches the expected format. It also uses the `url_for` method to generate a URL for the route with a specific value for `unhashable` and checks that the generated URL is correct. Finally, it verifies that calling `url_for` with a non-existent route raises a `URLBuildError`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test uses asynchronous route handlers, which is a common pattern in web frameworks to handle requests without blocking.\n- **Assertions**: It employs assertions to validate the expected outcomes, such as checking route names and generated URLs.\n- **Error Handling**: The test anticipates and checks for exceptions (specifically `URLBuildError`), ensuring that the application behaves correctly when faced with invalid input or requests."
    },
    {
      "name": "test_websocket_named_route",
      "module": "test_named_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_named_routes.py",
      "line_number": 308,
      "end_line_number": 320,
      "source_code": "def test_websocket_named_route():\n    app = Sanic(\"app\")\n    ev = asyncio.Event()\n\n    @app.websocket(\"/ws\", name=\"route_ws\")\n    async def handler(request, ws):\n        assert ws.subprotocol is None\n        ev.set()\n\n    assert app.router.routes_all[(\"ws\",)].name == \"app.route_ws\"\n    assert app.url_for(\"route_ws\") == \"/ws\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.router.routes_all['ws',].name == 'app.route_ws'",
        "assert app.url_for('route_ws') == '/ws'",
        "assert ws.subprotocol is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_websocket_named_route` function is designed to verify the correct registration and behavior of a named WebSocket route in a Sanic application. It ensures that the route can be accessed by its name and that the WebSocket handler behaves as expected.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. The WebSocket route is correctly named and can be referenced using the `url_for` method.\n2. The WebSocket handler correctly initializes and verifies that the `subprotocol` is `None` when no subprotocol is specified.\n3. An attempt to access a non-existent route (in this case, \"handler\") raises a `URLBuildError`.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes:\n- The registration of a WebSocket route using the `@app.websocket` decorator, which maps the route `/ws` to the `handler` function with the name `route_ws`.\n- The `app.router.routes_all` structure, which holds all registered routes, allowing the test to assert that the route's name is correctly set.\n- The `app.url_for` method, which generates URLs based on route names, allowing the test to confirm that the URL for `route_ws` is `/ws`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertions**: The test uses assertions to validate the expected outcomes, such as checking the route name and the URL generated by `url_for`.\n- **Exception Testing**: The test employs `pytest.raises` to ensure that accessing a non-existent route raises the appropriate exception, demonstrating robust error handling.\n- **Event Handling**: The use of `asyncio.Event()` allows the test to synchronize the WebSocket handler's execution, ensuring that the assertions regarding the `subprotocol` are made after the WebSocket connection is established."
    },
    {
      "name": "test_websocket_named_route_with_subprotocols",
      "module": "test_named_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_named_routes.py",
      "line_number": 323,
      "end_line_number": 334,
      "source_code": "def test_websocket_named_route_with_subprotocols():\n    app = Sanic(\"app\")\n    results = []\n\n    @app.websocket(\"/ws\", subprotocols=[\"foo\", \"bar\"], name=\"route_ws\")\n    async def handler(request, ws):\n        results.append(ws.subprotocol)\n\n    assert app.router.routes_all[(\"ws\",)].name == \"app.route_ws\"\n    assert app.url_for(\"route_ws\") == \"/ws\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.router.routes_all['ws',].name == 'app.route_ws'",
        "assert app.url_for('route_ws') == '/ws'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_websocket_named_route_with_subprotocols` is designed to verify the correct registration and functionality of a WebSocket route in a Sanic application that supports multiple subprotocols. It ensures that the route can be accessed correctly and that the expected subprotocols are handled appropriately.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. The WebSocket route is correctly named and registered in the application's router.\n2. The URL for the named route can be generated correctly using `app.url_for`.\n3. An attempt to generate a URL for a non-existent handler raises a `URLBuildError`.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the Sanic framework's ability to define WebSocket routes with subprotocols. The route is defined with the path `/ws`, allowing for subprotocols `[\"foo\", \"bar\"]`. The handler function appends the selected subprotocol to a results list. The assertions confirm that:\n- The route is registered with the expected name (`\"app.route_ws\"`).\n- The URL for the route can be generated as `\"/ws\"`.\n- An error is raised when trying to generate a URL for a handler that does not exist.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test uses asynchronous functions to handle WebSocket connections, which is essential for testing real-time communication features.\n- **Assertions**: It employs assertions to validate the expected outcomes, ensuring that the route behaves as intended.\n- **Error Handling**: The test checks for proper error handling by asserting that a `URLBuildError` is raised when attempting to access a non-existent route, demonstrating robustness in route management."
    },
    {
      "name": "test_static_add_named_route",
      "module": "test_named_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_named_routes.py",
      "line_number": 337,
      "end_line_number": 359,
      "source_code": "def test_static_add_named_route():\n    app = Sanic(\"app\")\n\n    async def handler1(request):\n        return text(\"OK1\")\n\n    async def handler2(request):\n        return text(\"OK2\")\n\n    app.add_route(handler1, \"/test\", name=\"route_test\")\n    app.add_route(handler2, \"/test2\", name=\"route_test2\")\n\n    assert app.router.routes_all[(\"test\",)].name == \"app.route_test\"\n    assert app.router.routes_static[(\"test\",)][0].name == \"app.route_test\"\n    assert app.url_for(\"route_test\") == \"/test\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler1\")\n\n    assert app.router.routes_all[(\"test2\",)].name == \"app.route_test2\"\n    assert app.router.routes_static[(\"test2\",)][0].name == \"app.route_test2\"\n    assert app.url_for(\"route_test2\") == \"/test2\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler2\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.router.routes_all['test',].name == 'app.route_test'",
        "assert app.router.routes_static['test',][0].name == 'app.route_test'",
        "assert app.url_for('route_test') == '/test'",
        "assert app.router.routes_all['test2',].name == 'app.route_test2'",
        "assert app.router.routes_static['test2',][0].name == 'app.route_test2'",
        "assert app.url_for('route_test2') == '/test2'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_static_add_named_route` function is designed to verify the correct behavior of adding static routes with names in a Sanic application. It ensures that routes can be added, named, and accessed correctly, and that the URL building functionality works as expected.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. Routes are correctly registered with the expected names.\n2. The `url_for` method generates the correct URLs for the named routes.\n3. An attempt to access a non-existent route name raises a `URLBuildError`.\n\n**Code Being Tested and How It Works**:  \nThe test creates a Sanic application instance and defines two asynchronous request handlers (`handler1` and `handler2`). It adds these handlers as routes with specific names using `app.add_route()`. The assertions then verify:\n- The names of the routes in the router's `routes_all` and `routes_static` collections.\n- The output of `app.url_for()` for the named routes.\n- The expected exceptions when trying to access non-existent route names.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertions**: The test uses assertions to validate the expected outcomes, ensuring that the application behaves as intended.\n- **Exception Testing**: The use of `pytest.raises` to check for `URLBuildError` demonstrates a common pattern in unit testing where the behavior of the code under exceptional conditions is verified.\n- **Asynchronous Testing**: The test leverages asynchronous handlers, which is a key feature of the Sanic framework, ensuring that the test is compatible with the asynchronous nature of the application."
    },
    {
      "name": "test_dynamic_add_named_route",
      "module": "test_named_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_named_routes.py",
      "line_number": 362,
      "end_line_number": 377,
      "source_code": "def test_dynamic_add_named_route():\n    app = Sanic(\"app\")\n    results = []\n\n    async def handler(request, name):\n        results.append(name)\n        return text(\"OK\")\n\n    app.add_route(handler, \"/folder/<name>\", name=\"route_dynamic\")\n    assert (\n        app.router.routes_all[(\"folder\", \"<name:str>\")].name\n        == \"app.route_dynamic\"\n    )\n    assert app.url_for(\"route_dynamic\", name=\"test\") == \"/folder/test\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.router.routes_all['folder', '<name:str>'].name == 'app.route_dynamic'",
        "assert app.url_for('route_dynamic', name='test') == '/folder/test'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_dynamic_add_named_route` function is designed to verify the functionality of dynamically adding named routes in a Sanic web application. It ensures that the routing system correctly associates a route with a name and that the URL generation for that route works as expected.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main behaviors: \n1. It verifies that the route added with the name \"route_dynamic\" is correctly registered in the application's router with the expected full name \"app.route_dynamic\".\n2. It confirms that the `url_for` method generates the correct URL for the named route when provided with a parameter. Additionally, it tests that an error is raised when attempting to generate a URL for a non-existent handler.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the Sanic application instance (`app`) and its routing capabilities. The `add_route` method is used to register an asynchronous handler function that responds to requests at the path `/folder/<name>`. The test then checks:\n- The name of the route in the router's collection (`app.router.routes_all`).\n- The output of `app.url_for(\"route_dynamic\", name=\"test\")`, which should return the URL `/folder/test`.\n- It also tests that calling `app.url_for(\"handler\")` raises a `URLBuildError`, indicating that the handler is not registered as a named route.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several key testing techniques:\n- **Assertions**: It uses assertions to validate expected outcomes, ensuring that the route name and generated URL match the anticipated values.\n- **Error Handling**: The test checks for exceptions using `pytest.raises`, which is a common pattern in unit tests to ensure that specific error conditions are handled correctly.\n- **Asynchronous Testing**: The test is structured to work with asynchronous code, which is essential for testing web frameworks like Sanic that utilize async/await syntax for handling requests."
    },
    {
      "name": "test_dynamic_add_named_route_unhashable",
      "module": "test_named_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_named_routes.py",
      "line_number": 380,
      "end_line_number": 402,
      "source_code": "def test_dynamic_add_named_route_unhashable():\n    app = Sanic(\"app\")\n\n    async def handler(request, unhashable):\n        return text(\"OK\")\n\n    app.add_route(\n        handler,\n        \"/folder/<unhashable:[A-Za-z0-9/]+>/end/\",\n        name=\"route_unhashable\",\n    )\n    route = app.router.routes_all[\n        (\n            \"folder\",\n            \"<unhashable:[A-Za-z0-9/]+>\",\n            \"end\",\n        )\n    ]\n    assert route.name == \"app.route_unhashable\"\n    url = app.url_for(\"route_unhashable\", unhashable=\"folder1\")\n    assert url == \"/folder/folder1/end\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert route.name == 'app.route_unhashable'",
        "assert url == '/folder/folder1/end'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_dynamic_add_named_route_unhashable` is designed to verify the functionality of adding a dynamic route with a named parameter that is unhashable (in this case, a string containing slashes) in a Sanic web application. It ensures that the route can be correctly registered and that the URL can be generated based on the route name and parameters.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. The route is correctly named and can be accessed via its name.\n2. The URL generated for the route using the `url_for` method matches the expected format when provided with a valid parameter.\n3. An attempt to generate a URL for a handler that is not a named route raises a `URLBuildError`.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the Sanic framework's routing capabilities. The test creates a Sanic application instance and defines a route with a dynamic segment (`<unhashable:[A-Za-z0-9/]+>`). The route is named \"route_unhashable\". The test then retrieves the route from the router and asserts its name. It also uses the `url_for` method to generate a URL for the route with a specific value for the `unhashable` parameter and checks that it matches the expected URL format. Finally, it verifies that an error is raised when trying to generate a URL for a non-named route.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test uses asynchronous route handlers, which is a common pattern in web frameworks like Sanic to handle I/O-bound operations efficiently.\n- **Assertions**: The test employs assertions to validate the expected outcomes, such as checking the route name and the generated URL.\n- **Error Handling**: The test includes a check for expected exceptions (`URLBuildError`), ensuring that the application behaves correctly when invalid operations are attempted. This is a crucial aspect of robust testing, as it verifies that the application can handle errors gracefully."
    },
    {
      "name": "test_overload_routes",
      "module": "test_named_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_named_routes.py",
      "line_number": 405,
      "end_line_number": 439,
      "source_code": "def test_overload_routes():\n    app = Sanic(\"app\")\n\n    @app.route(\"/overload\", methods=[\"GET\"], name=\"route_first\")\n    async def handler1(request):\n        return text(\"OK1\")\n\n    @app.route(\"/overload\", methods=[\"POST\", \"PUT\"], name=\"route_second\")\n    async def handler2(request):\n        return text(\"OK2\")\n\n    request, response = app.test_client.get(app.url_for(\"route_first\"))\n    assert response.text == \"OK1\"\n\n    request, response = app.test_client.post(app.url_for(\"route_first\"))\n    assert response.text == \"OK2\"\n\n    request, response = app.test_client.put(app.url_for(\"route_first\"))\n    assert response.text == \"OK2\"\n\n    request, response = app.test_client.get(app.url_for(\"route_second\"))\n    assert response.text == \"OK1\"\n\n    request, response = app.test_client.post(app.url_for(\"route_second\"))\n    assert response.text == \"OK2\"\n\n    request, response = app.test_client.put(app.url_for(\"route_second\"))\n    assert response.text == \"OK2\"\n\n    assert app.router.routes_all[(\"overload\",)].name == \"app.route_first\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler1\")\n\n    assert app.url_for(\"route_first\") == \"/overload\"\n    assert app.url_for(\"route_second\") == app.url_for(\"route_first\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK1'",
        "assert response.text == 'OK2'",
        "assert response.text == 'OK2'",
        "assert response.text == 'OK1'",
        "assert response.text == 'OK2'",
        "assert response.text == 'OK2'",
        "assert app.router.routes_all['overload',].name == 'app.route_first'",
        "assert app.url_for('route_first') == '/overload'",
        "assert app.url_for('route_second') == app.url_for('route_first')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_overload_routes` function is designed to verify the behavior of route overloads in a Sanic web application. It ensures that multiple HTTP methods can be associated with the same route and that the correct handler is invoked based on the method used in the request.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. A GET request to the `/overload` route returns \"OK1\".\n2. POST and PUT requests to the same route return \"OK2\".\n3. The correct handler is invoked when accessing the route with different methods.\n4. The route's name is correctly assigned and can be resolved using `url_for`.\n5. An attempt to access a non-existent route raises a `URLBuildError`.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes two route handlers:\n- `handler1` for the GET method, which returns \"OK1\".\n- `handler2` for the POST and PUT methods, which returns \"OK2\".\n\nThe test uses the Sanic test client to simulate requests to these routes and checks the responses. It also verifies the route's name and checks for proper error handling when trying to build a URL for a non-existent handler.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertion Checks**: The test uses assertions to validate the response content and status codes, ensuring that the application behaves as expected under different conditions.\n- **Error Handling Verification**: It checks for exceptions (like `URLBuildError`) to ensure that the application correctly handles invalid operations.\n- **Route Name Verification**: The test confirms that the route names are correctly assigned and can be resolved, which is crucial for maintaining clear and manageable routing in the application."
    },
    {
      "name": "test_http1_response_has_alt_svc",
      "module": "test_http_alt_svc",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_http_alt_svc.py",
      "line_number": 17,
      "end_line_number": 64,
      "source_code": "def test_http1_response_has_alt_svc(port):\n    Sanic._app_registry.clear()\n    app = Sanic(\"TestAltSvc\")\n    app.config.TOUCHUP = True\n    response = b\"\"\n\n    @app.get(\"/\")\n    async def handler(*_):\n        return empty()\n\n    @app.after_server_start\n    async def do_request(*_):\n        nonlocal response\n\n        app.router.reset()\n        app.router.finalize()\n\n        client = RawClient(app.state.host, app.state.port)\n        await client.connect()\n        await client.send(\n            \"\"\"\n            GET / HTTP/1.1\n            host: localhost:7777\n\n            \"\"\"\n        )\n        response = await client.recv(1024)\n        await client.close()\n\n    @app.after_server_start\n    def shutdown(*_):\n        app.stop()\n\n    app.prepare(\n        version=3,\n        ssl={\n            \"cert\": localhost_dir / \"fullchain.pem\",\n            \"key\": localhost_dir / \"privkey.pem\",\n        },\n        port=port,\n    )\n    app.prepare(\n        version=1,\n        port=port,\n    )\n    Sanic.serve_single(app)\n\n    assert f'alt-svc: h3=\":{port}\"\\r\\n'.encode() in response",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(sys.version_info < (3, 9), reason='Not supported in 3.7')"
      ],
      "arguments": [
        "port"
      ],
      "imports": [
        "sys",
        "pathlib.Path",
        "pytest",
        "sanic.app.Sanic",
        "sanic.response.empty",
        "tests.client.RawClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert f'alt-svc: h3=\":{port}\"\\r\\n'.encode() in response"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.router.reset",
          "body": "@pytest.fixture(autouse=True)\ndef reset():\n    try:\n        del os.environ['SANIC_MOTD_OUTPUT']\n    except KeyError:\n        ..."
        },
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        },
        {
          "name": "client.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "client.recv",
          "body": "def recv(**kwargs):\n    nonlocal runner\n    nonlocal raw\n    method = raw.recv_until if 'until' in kwargs else raw.recv\n    return runner._run(method(**kwargs))"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_http1_response_has_alt_svc` test is to verify that the HTTP/1.1 response from a Sanic application correctly includes the `Alt-Svc` header, which indicates support for HTTP/3 on a specified port. This is crucial for ensuring that clients can discover alternative service protocols supported by the server.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that the response received from the server contains the `Alt-Svc` header formatted as `alt-svc: h3=\":{port}\"`, where `port` is the port number on which the server is running. This confirms that the server is correctly advertising its capability to handle HTTP/3 connections.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Sanic application with two versions: HTTP/3 (version 3) and HTTP/1.1 (version 1). It defines a simple route that returns an empty response. After the server starts, it uses a `RawClient` to send a GET request to the server and captures the response. The `Alt-Svc` header is expected to be present in this response, indicating that the server is configured to support HTTP/3.\n\nThe relevant code includes:\n- `app.get(\"/\")`: Defines a route that returns an empty response.\n- `app.after_server_start`: A callback that sends a request to the server after it has started, allowing the test to capture the response.\n- `Sanic.serve_single(app)`: Starts the server to handle incoming requests.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Asynchronous Testing**: The use of `async` functions allows for non-blocking I/O operations, which is essential for testing web servers.\n- **Nonlocal Variables**: The `nonlocal` keyword is used to modify the `response` variable within the nested asynchronous function, allowing the test to capture the response from the server.\n- **Server Lifecycle Management**: The test includes setup and teardown logic to ensure that the server is properly started and stopped, preventing resource leaks and ensuring a clean test environment.\n- **Dynamic Assertions**: The assertion checks for the presence of the `Alt-Svc` header in the response, which is dynamically constructed based on the port passed to the test, demonstrating adaptability in testing different configurations."
    },
    {
      "name": "test_multiprocessing",
      "module": "test_multiprocessing",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_multiprocessing.py",
      "line_number": 28,
      "end_line_number": 48,
      "source_code": "def test_multiprocessing(app, port):\n    \"\"\"Tests that the number of children we produce is correct\"\"\"\n    # Selects a number at random so we can spot check\n    num_workers = random.choice(range(2, multiprocessing.cpu_count() * 2 + 1))\n    process_list = set()\n\n    @app.after_server_start\n    async def shutdown(app):\n        await sleep(2.1)\n        app.stop()\n\n    def stop_on_alarm(*args):\n        for process in multiprocessing.active_children():\n            process_list.add(process.pid)\n\n    signal.signal(signal.SIGALRM, stop_on_alarm)\n    signal.alarm(2)\n    with use_context(\"fork\"):\n        app.run(HOST, port, workers=num_workers, debug=True)\n\n    assert len(process_list) == num_workers + 1",
      "docstring": "Tests that the number of children we produce is correct",
      "decorators": [
        "pytest.mark.skipif(not hasattr(signal, 'SIGALRM'), reason='SIGALRM is not implemented for this platform, we have to come up with another timeout strategy to test these')",
        "pytest.mark.skipif(sys.platform not in ('linux', 'darwin'), reason='This test requires fork context')"
      ],
      "arguments": [
        "app",
        "port"
      ],
      "imports": [
        "logging",
        "multiprocessing",
        "pickle",
        "random",
        "signal",
        "sys",
        "asyncio.sleep",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic.Blueprint",
        "sanic.text",
        "sanic.compat.use_context",
        "sanic.log.logger"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(process_list) == num_workers + 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        },
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_multiprocessing` function aims to verify that the Sanic application correctly spawns the expected number of worker processes when it is run with a specified number of workers. This is crucial for ensuring that the application can handle concurrent requests effectively.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the number of active child processes created by the application matches the number of workers specified (`num_workers`) plus one for the main process. This ensures that the application is correctly utilizing multiprocessing capabilities.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the `app.run` method to start the Sanic application with a specified number of worker processes. It sets up a signal alarm to stop the application after a short delay, allowing the test to capture the number of active child processes at that time. The `process_list` set collects the PIDs of the active child processes, and the assertion at the end checks that the length of this set equals `num_workers + 1`.\n\n**Notable Testing Patterns or Techniques Used**:  \n1. **Asynchronous Testing**: The test uses asynchronous functions and the `@app.after_server_start` decorator to manage the application lifecycle, ensuring that the application stops after a delay.\n2. **Signal Handling**: It employs signal handling to manage process termination, which is a common technique in tests involving multiprocessing.\n3. **Dynamic Worker Count**: The test randomly selects the number of workers to be spawned, allowing for variability in testing and ensuring that the application can handle different configurations.\n4. **Context Management**: The use of `with use_context(\"fork\")` indicates that the test is explicitly managing the context for multiprocessing, which is important for compatibility across different operating systems, especially when using the `fork` method on Unix-like systems."
    },
    {
      "name": "test_multiprocessing_with_blueprint",
      "module": "test_multiprocessing",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_multiprocessing.py",
      "line_number": 59,
      "end_line_number": 81,
      "source_code": "def test_multiprocessing_with_blueprint(app: object, port) -> object:\n    # Selects a number at random so we can spot check\n    num_workers = random.choice(range(2, multiprocessing.cpu_count() * 2 + 1))\n    process_list = set()\n\n    @app.after_server_start\n    async def shutdown(app):\n        await sleep(2.1)\n        app.stop()\n\n    def stop_on_alarm(*args):\n        for process in multiprocessing.active_children():\n            process_list.add(process.pid)\n\n    signal.signal(signal.SIGALRM, stop_on_alarm)\n    signal.alarm(2)\n\n    bp = Blueprint(\"test_text\")\n    app.blueprint(bp)\n    with use_context(\"fork\"):\n        app.run(HOST, port, workers=num_workers, debug=True)\n\n    assert len(process_list) == num_workers + 1",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(not hasattr(signal, 'SIGALRM'), reason='SIGALRM is not implemented for this platform')",
        "pytest.mark.skipif(sys.platform not in ('linux', 'darwin'), reason='This test requires fork context')"
      ],
      "arguments": [
        "app",
        "port"
      ],
      "imports": [
        "logging",
        "multiprocessing",
        "pickle",
        "random",
        "signal",
        "sys",
        "asyncio.sleep",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic.Blueprint",
        "sanic.text",
        "sanic.compat.use_context",
        "sanic.log.logger"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(process_list) == num_workers + 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        },
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_multiprocessing_with_blueprint` function is designed to verify the correct behavior of a Sanic application when it is run with multiple worker processes and a blueprint. It ensures that the application can handle multiprocessing correctly and that the expected number of worker processes is spawned.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the number of active child processes matches the expected count, which is the randomly chosen number of workers plus one for the main process. This confirms that the application is capable of starting the specified number of worker processes and that they are properly managed.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `app.run` method, which starts the Sanic application with a specified number of workers. It uses a signal alarm to trigger a shutdown after a short delay, allowing the application to run and spawn the worker processes. The `stop_on_alarm` function collects the PIDs of the active child processes, which are then counted to assert that the expected number of processes is running.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The use of `async` functions and `await` allows for non-blocking operations, which is crucial in a web server context.\n- **Signal Handling**: The test employs Unix signal handling to manage process termination, demonstrating an understanding of inter-process communication.\n- **Randomized Testing**: By randomly selecting the number of workers, the test ensures robustness against different configurations and helps identify potential edge cases in process management.\n- **Blueprint Usage**: The test incorporates a Sanic blueprint, which is a way to organize routes and handlers, verifying that the application can handle modular components in a multiprocessing context."
    },
    {
      "name": "test_pickle_app",
      "module": "test_multiprocessing",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_multiprocessing.py",
      "line_number": 96,
      "end_line_number": 105,
      "source_code": "def test_pickle_app(app, protocol, port):\n    app.route(\"/\")(handler)\n    app.after_server_start(stop)\n    app.router.reset()\n    app.signal_router.reset()\n    p_app = pickle.dumps(app, protocol=protocol)\n    del app\n    up_p_app = pickle.loads(p_app)\n    assert up_p_app\n    up_p_app.run(single_process=True, port=port)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('protocol', [3, 4])"
      ],
      "arguments": [
        "app",
        "protocol",
        "port"
      ],
      "imports": [
        "logging",
        "multiprocessing",
        "pickle",
        "random",
        "signal",
        "sys",
        "asyncio.sleep",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic.Blueprint",
        "sanic.text",
        "sanic.compat.use_context",
        "sanic.log.logger"
      ],
      "fixtures": [],
      "assertions": [
        "assert up_p_app"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.router.reset",
          "body": "@pytest.fixture(autouse=True)\ndef reset():\n    try:\n        del os.environ['SANIC_MOTD_OUTPUT']\n    except KeyError:\n        ..."
        },
        {
          "name": "app.signal_router.reset",
          "body": "@pytest.fixture(autouse=True)\ndef reset():\n    try:\n        del os.environ['SANIC_MOTD_OUTPUT']\n    except KeyError:\n        ..."
        },
        {
          "name": "up_p_app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_pickle_app` function is designed to verify the serialization and deserialization of a Sanic application instance using Python's `pickle` module. It ensures that the application can be pickled (serialized) and then unpickled (deserialized) without losing its state or functionality.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that after pickling and unpickling the `app` instance, the resulting `up_p_app` (unpickled application) is valid and can be run successfully. It also ensures that the application's routing and signal handling mechanisms are intact after the serialization process.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes:\n- `app.router.reset()`: Resets the application's routing table, ensuring a clean state before serialization.\n- `app.signal_router.reset()`: Resets the signal routing, similar to the router reset.\n- `pickle.dumps(app, protocol=protocol)`: Serializes the `app` instance using the specified protocol.\n- `pickle.loads(p_app)`: Deserializes the pickled application back into an object.\n- `up_p_app.run(single_process=True, port=port)`: Runs the unpickled application in a single process on the specified port.\n\nThe test first sets up the application with a route and a server start handler, then resets the routers, pickles the app, deletes the original app reference, and finally unpickles it to verify its integrity and functionality.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The test relies on fixtures (like `app`, `protocol`, and `port`) to provide necessary context and dependencies, promoting reusability and separation of concerns.\n- **Serialization Testing**: It specifically tests the serialization and deserialization process, which is crucial for applications that may need to save and restore state.\n- **Assertions**: The test uses assertions to validate that the unpickled application is not `None`, ensuring that the deserialization was successful and that the application can be run afterward.\n- **Environment Cleanup**: The test includes cleanup steps (like resetting routers) to ensure that the test environment is consistent and does not affect other tests."
    },
    {
      "name": "test_pickle_app_with_bp",
      "module": "test_multiprocessing",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_multiprocessing.py",
      "line_number": 109,
      "end_line_number": 120,
      "source_code": "def test_pickle_app_with_bp(app, protocol, port):\n    bp = Blueprint(\"test_text\")\n    bp.route(\"/\")(handler)\n    bp.after_server_start(stop)\n    app.blueprint(bp)\n    app.router.reset()\n    app.signal_router.reset()\n    p_app = pickle.dumps(app, protocol=protocol)\n    del app\n    up_p_app = pickle.loads(p_app)\n    assert up_p_app\n    up_p_app.run(single_process=True, port=port)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('protocol', [3, 4])"
      ],
      "arguments": [
        "app",
        "protocol",
        "port"
      ],
      "imports": [
        "logging",
        "multiprocessing",
        "pickle",
        "random",
        "signal",
        "sys",
        "asyncio.sleep",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic.Blueprint",
        "sanic.text",
        "sanic.compat.use_context",
        "sanic.log.logger"
      ],
      "fixtures": [],
      "assertions": [
        "assert up_p_app"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.router.reset",
          "body": "@pytest.fixture(autouse=True)\ndef reset():\n    try:\n        del os.environ['SANIC_MOTD_OUTPUT']\n    except KeyError:\n        ..."
        },
        {
          "name": "app.signal_router.reset",
          "body": "@pytest.fixture(autouse=True)\ndef reset():\n    try:\n        del os.environ['SANIC_MOTD_OUTPUT']\n    except KeyError:\n        ..."
        },
        {
          "name": "up_p_app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_pickle_app_with_bp` test is designed to verify that a Sanic application, when pickled and unpickled, retains its functionality and can successfully run with a registered blueprint.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the application can be serialized (pickled) and deserialized (unpickled) without losing its state or functionality. It ensures that the application can still run after being restored from a serialized state.\n\n**Code Being Tested and How It Works**:  \nThe test creates a Sanic application and registers a blueprint with a route and an after-server-start handler. It then resets the application's router and signal router, pickles the application using the specified protocol, deletes the original application reference, and subsequently unpickles it. Finally, it asserts that the unpickled application is valid and attempts to run it on a specified port. The `app.router.reset()` and `app.signal_router.reset()` methods are called to ensure a clean state before pickling.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The test relies on fixtures (`app`, `protocol`, `port`) to provide necessary context and parameters for the test execution.\n- **Pickling**: The use of Python's `pickle` module demonstrates a common serialization technique to test the persistence of application state.\n- **Assertions**: The test employs assertions to validate that the unpickled application is not `None`, ensuring that the deserialization process was successful.\n- **Blueprints**: The test showcases the use of blueprints in Sanic, which allows for modular application design and organization of routes and handlers."
    },
    {
      "name": "test_pickle_app_with_static",
      "module": "test_multiprocessing",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_multiprocessing.py",
      "line_number": 124,
      "end_line_number": 134,
      "source_code": "def test_pickle_app_with_static(app, protocol):\n    app.route(\"/\")(handler)\n    app.after_server_start(stop)\n    app.static(\"/static\", \"/tmp/static\")\n    app.router.reset()\n    app.signal_router.reset()\n    p_app = pickle.dumps(app, protocol=protocol)\n    del app\n    up_p_app = pickle.loads(p_app)\n    assert up_p_app\n    up_p_app.run(single_process=True)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('protocol', [3, 4])"
      ],
      "arguments": [
        "app",
        "protocol"
      ],
      "imports": [
        "logging",
        "multiprocessing",
        "pickle",
        "random",
        "signal",
        "sys",
        "asyncio.sleep",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic.Blueprint",
        "sanic.text",
        "sanic.compat.use_context",
        "sanic.log.logger"
      ],
      "fixtures": [],
      "assertions": [
        "assert up_p_app"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.router.reset",
          "body": "@pytest.fixture(autouse=True)\ndef reset():\n    try:\n        del os.environ['SANIC_MOTD_OUTPUT']\n    except KeyError:\n        ..."
        },
        {
          "name": "app.signal_router.reset",
          "body": "@pytest.fixture(autouse=True)\ndef reset():\n    try:\n        del os.environ['SANIC_MOTD_OUTPUT']\n    except KeyError:\n        ..."
        },
        {
          "name": "up_p_app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_pickle_app_with_static` test is designed to verify that a Sanic application can be serialized and deserialized using Python's `pickle` module while maintaining its functionality. This ensures that the application state can be preserved and restored correctly, which is crucial for scenarios like process forking or distributed systems.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that after pickling and unpickling the Sanic application (`app`), the application remains functional. Specifically, it verifies that the application can still run and respond to requests after being restored from its serialized state. The assertion `assert up_p_app` ensures that the unpickled application object is valid and not `None`.\n\n**Code Being Tested and How It Works**:  \nThe test first sets up the Sanic application by defining a route, registering a static file directory, and setting up a server start event. It then uses `pickle.dumps` to serialize the application object (`app`) with the specified protocol. After deleting the original `app` reference, it uses `pickle.loads` to create a new instance (`up_p_app`) from the serialized data. Finally, it calls `up_p_app.run(single_process=True)` to start the application, which should work as expected if the serialization and deserialization were successful.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Pickling**: The test utilizes Python's `pickle` module to serialize and deserialize the application, which is a common technique for preserving object state.\n- **Assertions**: The test employs assertions to validate that the unpickled application is not `None`, ensuring that the deserialization process was successful.\n- **Setup and Teardown**: The test implicitly relies on the setup of the application state (routes, static files, etc.) before serialization, demonstrating a common pattern in unit tests where the environment is prepared before the main test logic is executed."
    },
    {
      "name": "test_main_process_event",
      "module": "test_multiprocessing",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_multiprocessing.py",
      "line_number": 141,
      "end_line_number": 174,
      "source_code": "def test_main_process_event(app, caplog, port):\n    # Selects a number at random so we can spot check\n    num_workers = random.choice(range(2, multiprocessing.cpu_count() * 2 + 1))\n\n    app.after_server_start(stop)\n\n    @app.listener(\"main_process_start\")\n    def main_process_start(app, loop):\n        logger.info(\"main_process_start\")\n\n    @app.listener(\"main_process_stop\")\n    def main_process_stop(app, loop):\n        logger.info(\"main_process_stop\")\n\n    @app.main_process_start\n    def main_process_start2(app, loop):\n        logger.info(\"main_process_start\")\n\n    @app.main_process_stop\n    def main_process_stop2(app, loop):\n        logger.info(\"main_process_stop\")\n\n    with use_context(\"fork\"):\n        with caplog.at_level(logging.INFO):\n            app.run(HOST, port, workers=num_workers)\n\n    assert (\n        caplog.record_tuples.count((\"sanic.root\", 20, \"main_process_start\"))\n        == 2\n    )\n    assert (\n        caplog.record_tuples.count((\"sanic.root\", 20, \"main_process_stop\"))\n        == 2\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(sys.platform not in ('linux', 'darwin'), reason='This test requires fork context')"
      ],
      "arguments": [
        "app",
        "caplog",
        "port"
      ],
      "imports": [
        "logging",
        "multiprocessing",
        "pickle",
        "random",
        "signal",
        "sys",
        "asyncio.sleep",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic.Blueprint",
        "sanic.text",
        "sanic.compat.use_context",
        "sanic.log.logger"
      ],
      "fixtures": [],
      "assertions": [
        "assert caplog.record_tuples.count(('sanic.root', 20, 'main_process_start')) == 2",
        "assert caplog.record_tuples.count(('sanic.root', 20, 'main_process_stop')) == 2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_main_process_event` function is designed to verify that the Sanic application correctly triggers the `main_process_start` and `main_process_stop` events when the server starts and stops, respectively. It ensures that the logging for these events occurs the expected number of times, confirming that the application lifecycle events are functioning as intended.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the logging messages for `main_process_start` and `main_process_stop` are recorded exactly twice each during the server's lifecycle. This indicates that both the main process start and stop listeners are being executed correctly.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `app.run()` method, which starts the Sanic server. The test sets up listeners for the `main_process_start` and `main_process_stop` events, which log messages when these events are triggered. The server is run in a context that allows for forking, and the test captures log messages using the `caplog` fixture. After the server has run, the test asserts that the expected log messages were recorded the correct number of times.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The test uses `use_context(\"fork\")` to ensure that the server runs in a forked process context, which is necessary for testing multiprocessing behavior.\n- **Logging Capture**: The `caplog` fixture is employed to capture log messages during the test, allowing for assertions on the log output.\n- **Randomized Input**: The number of worker processes is chosen randomly within a specified range, which helps to ensure that the test can handle different configurations and is not dependent on a fixed number of workers."
    },
    {
      "name": "test_change_encoder",
      "module": "test_json_encoding",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_json_encoding.py",
      "line_number": 56,
      "end_line_number": 58,
      "source_code": "def test_change_encoder():\n    Sanic(\"Test\", dumps=sdumps)\n    assert BaseHTTPResponse._dumps == sdumps",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "sys",
        "dataclasses.asdict",
        "dataclasses.dataclass",
        "functools.partial",
        "json.dumps",
        "string.ascii_lowercase",
        "typing.Dict",
        "pytest",
        "sanic.Sanic",
        "sanic.response.BaseHTTPResponse",
        "sanic.response.json",
        "ujson",
        "ujson.dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert BaseHTTPResponse._dumps == sdumps"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_change_encoder` function is designed to verify that the `Sanic` application correctly sets a custom JSON serialization function (`dumps`) for the `BaseHTTPResponse` class. This ensures that the response serialization behavior can be modified as intended.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that after initializing a `Sanic` application with a custom serialization function (`sdumps`), the `_dumps` attribute of `BaseHTTPResponse` is updated to reference this new function. This confirms that the application is capable of using a different encoder for JSON responses.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `Sanic` class and its ability to set a custom JSON encoder. When `Sanic(\"Test\", dumps=sdumps)` is called, it initializes a new `Sanic` application instance with `sdumps` as the serialization function. The assertion `assert BaseHTTPResponse._dumps == sdumps` checks if the `_dumps` attribute of `BaseHTTPResponse` has been updated to the new encoder, thereby validating the expected behavior.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern to verify state changes in the application. It uses a direct comparison to check if the expected function (`sdumps`) is set as the encoder. This is a common technique in unit testing where the focus is on verifying the internal state of an object or class after a specific operation has been performed. Additionally, the test is part of a larger suite that utilizes fixtures and parameterization, showcasing a structured approach to testing various aspects of the `Sanic` framework."
    },
    {
      "name": "test_change_encoder_to_some_custom",
      "module": "test_json_encoding",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_json_encoding.py",
      "line_number": 61,
      "end_line_number": 66,
      "source_code": "def test_change_encoder_to_some_custom():\n    def my_custom_encoder():\n        return \"foo\"\n\n    Sanic(\"Test\", dumps=my_custom_encoder)\n    assert BaseHTTPResponse._dumps == my_custom_encoder",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "sys",
        "dataclasses.asdict",
        "dataclasses.dataclass",
        "functools.partial",
        "json.dumps",
        "string.ascii_lowercase",
        "typing.Dict",
        "pytest",
        "sanic.Sanic",
        "sanic.response.BaseHTTPResponse",
        "sanic.response.json",
        "ujson",
        "ujson.dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert BaseHTTPResponse._dumps == my_custom_encoder"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_change_encoder_to_some_custom` is designed to verify that the Sanic framework can accept and correctly set a custom JSON encoder function for serializing responses. This ensures that developers can customize how data is converted to JSON format when using the Sanic web framework.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when a custom encoder function (`my_custom_encoder`) is provided to the Sanic application, it is correctly assigned to the `BaseHTTPResponse._dumps` attribute. This attribute is responsible for serializing response data into JSON format. The assertion confirms that the custom encoder is in effect.\n\n**Code Being Tested and How It Works**:  \nThe relevant code being tested involves the instantiation of a Sanic application with a custom `dumps` parameter. The `Sanic(\"Test\", dumps=my_custom_encoder)` line initializes a new Sanic application instance, passing the custom encoder function. The assertion `assert BaseHTTPResponse._dumps == my_custom_encoder` checks if the internal serialization method has been updated to use the custom encoder, thereby validating that the application is configured to use it for JSON serialization.\n\n**Notable Testing Patterns or Techniques Used**:  \nThis test employs a straightforward unit testing pattern where a specific configuration (custom encoder) is set up and then verified through assertions. It uses a simple function as a mock encoder, which is a common technique in unit tests to isolate functionality. The test also follows the Arrange-Act-Assert (AAA) pattern, where the setup (arranging the custom encoder), action (creating the Sanic app), and assertion (checking the encoder assignment) are clearly delineated."
    },
    {
      "name": "test_json_response_ujson",
      "module": "test_json_encoding",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_json_encoding.py",
      "line_number": 70,
      "end_line_number": 84,
      "source_code": "def test_json_response_ujson(payload: Dict[str, Foo]):\n    \"\"\"ujson will look at __json__\"\"\"\n    response = json(payload)\n    assert response.body == b'{\"foo\":{\"bar\":\"bar\"}}'\n\n    with pytest.raises(\n        TypeError, match=\"Object of type Foo is not JSON serializable\"\n    ):\n        json(payload, dumps=sdumps)\n\n    Sanic(\"Test\", dumps=sdumps)\n    with pytest.raises(\n        TypeError, match=\"Object of type Foo is not JSON serializable\"\n    ):\n        json(payload)",
      "docstring": "ujson will look at __json__",
      "decorators": [
        "pytest.mark.skipif(NO_UJSON is True, reason='ujson not installed')"
      ],
      "arguments": [
        "payload"
      ],
      "imports": [
        "sys",
        "dataclasses.asdict",
        "dataclasses.dataclass",
        "functools.partial",
        "json.dumps",
        "string.ascii_lowercase",
        "typing.Dict",
        "pytest",
        "sanic.Sanic",
        "sanic.response.BaseHTTPResponse",
        "sanic.response.json",
        "ujson",
        "ujson.dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.body == b'{\"foo\":{\"bar\":\"bar\"}}'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_json_response_ujson` test is designed to verify the behavior of the `json` function in the Sanic framework when handling serialization of objects, specifically those that implement a custom `__json__` method. It checks both successful serialization and the appropriate handling of serialization errors.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies that:\n1. A payload containing an instance of the `Foo` class can be successfully serialized to JSON using `ujson`, resulting in the expected byte string output.\n2. When attempting to serialize the same payload with a different serialization method (using `sdumps`), a `TypeError` is raised, indicating that the `Foo` object is not JSON serializable.\n3. It also checks that the default serialization method in the context of a Sanic application raises the same `TypeError`.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `json` function from the Sanic framework, which is responsible for converting Python objects into JSON format. The `Foo` class has a `__json__` method that defines how its instances should be serialized. The test first creates a payload that includes an instance of `Foo` and checks if it can be serialized correctly. It then tests the serialization with a different encoder (`sdumps`) to ensure that it raises the expected error when the object is not serializable.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The test utilizes pytest fixtures (`foo` and `payload`) to set up the necessary test data, promoting code reuse and clarity.\n- **Exception Testing**: The test employs `pytest.raises` to assert that specific exceptions are raised under certain conditions, which is a common pattern for testing error handling in unit tests.\n- **Conditional Skipping**: The test is marked with `@pytest.mark.skipif` to conditionally skip execution if `ujson` is not installed or if the version is incompatible, ensuring that the test suite remains robust and does not fail due to environmental issues."
    },
    {
      "name": "test_json_response_json",
      "module": "test_json_encoding",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_json_encoding.py",
      "line_number": 94,
      "end_line_number": 107,
      "source_code": "def test_json_response_json():\n    \"\"\"One of the easiest ways to tell the difference is that ujson cannot\n    serialize over 64 bits\"\"\"\n    too_big_for_ujson = 111111111111111111111\n\n    with pytest.raises(OverflowError, match=\"int too big to convert\"):\n        json(too_big_for_ujson)\n\n    response = json(too_big_for_ujson, dumps=sdumps)\n    assert sys.getsizeof(response.body) == 54\n\n    Sanic(\"Test\", dumps=sdumps)\n    response = json(too_big_for_ujson)\n    assert sys.getsizeof(response.body) == 54",
      "docstring": "One of the easiest ways to tell the difference is that ujson cannot\nserialize over 64 bits",
      "decorators": [
        "pytest.mark.skipif(NO_UJSON is True or ujson_version >= (5, 4, 0), reason='ujson not installed or version is 5.4.0 or newer, which can handle arbitrary size integers')"
      ],
      "arguments": [],
      "imports": [
        "sys",
        "dataclasses.asdict",
        "dataclasses.dataclass",
        "functools.partial",
        "json.dumps",
        "string.ascii_lowercase",
        "typing.Dict",
        "pytest",
        "sanic.Sanic",
        "sanic.response.BaseHTTPResponse",
        "sanic.response.json",
        "ujson",
        "ujson.dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert sys.getsizeof(response.body) == 54",
        "assert sys.getsizeof(response.body) == 54"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_json_response_json` test is to verify the behavior of the `json` function in handling large integers, specifically testing how it interacts with the `ujson` library for JSON serialization. It ensures that the function raises an appropriate error when attempting to serialize an integer that exceeds the limits of `ujson`, and it checks the size of the response body generated by the `json` function.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main behaviors: \n1. It verifies that an `OverflowError` is raised when trying to serialize an integer larger than what `ujson` can handle (greater than 64 bits).\n2. It confirms that the size of the response body generated by the `json` function is as expected (54 bytes) when using both `ujson` and the default `json` serialization.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `json` function, which is responsible for creating a JSON response object. It takes a body (data to be serialized), an optional status code, headers, content type, and a custom serialization function (`dumps`). The function returns a `JSONResponse` object that contains the serialized body. The test specifically checks how this function behaves when given a large integer, ensuring that it correctly raises an error with `ujson` and produces a response of the expected size.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the following notable patterns:\n- **Exception Testing**: It uses `pytest.raises` to assert that an `OverflowError` is raised when attempting to serialize a large integer with `ujson`, which is a common pattern for testing error handling in unit tests.\n- **Assertions on Response Size**: The test checks the size of the response body using `sys.getsizeof`, which is a practical approach to verify that the response is correctly formatted and meets size expectations.\n- **Context Management**: The use of a context manager (`with` statement) for exception testing ensures that the test is clean and that the expected exception is properly handled within the scope."
    },
    {
      "name": "test_custom_context",
      "module": "test_request_data",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request_data.py",
      "line_number": 12,
      "end_line_number": 64,
      "source_code": "def test_custom_context(app):\n    @app.middleware(\"request\")\n    def store(request):\n        request.ctx.user = \"sanic\"\n        request.ctx.session = None\n\n    @app.route(\"/\")\n    def handler(request):\n        # Accessing non-existent key should fail with AttributeError\n        try:\n            invalid = request.ctx.missing\n        except AttributeError as e:\n            invalid = str(e)\n        return json(\n            {\n                \"user\": request.ctx.user,\n                \"session\": request.ctx.session,\n                \"has_user\": hasattr(request.ctx, \"user\"),\n                \"has_session\": hasattr(request.ctx, \"session\"),\n                \"has_missing\": hasattr(request.ctx, \"missing\"),\n                \"invalid\": invalid,\n            }\n        )\n\n    @app.middleware(\"response\")\n    def modify(request, response):\n        # Using response-middleware to access request ctx\n        try:\n            user = request.ctx.user\n        except AttributeError as e:\n            user = str(e)\n        try:\n            invalid = request.ctx.missing\n        except AttributeError as e:\n            invalid = str(e)\n\n        j = loads(response.body)\n        j[\"response_mw_valid\"] = user\n        j[\"response_mw_invalid\"] = invalid\n        return json(j)\n\n    request, response = app.test_client.get(\"/\")\n    assert response.json == {\n        \"user\": \"sanic\",\n        \"session\": None,\n        \"has_user\": True,\n        \"has_session\": True,\n        \"has_missing\": False,\n        \"invalid\": \"'types.SimpleNamespace' object has no attribute 'missing'\",\n        \"response_mw_valid\": \"sanic\",\n        \"response_mw_invalid\": \"'types.SimpleNamespace' object has no\"\n        \" attribute 'missing'\",\n    }",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "random",
        "sanic.response.json",
        "ujson.loads",
        "json.loads"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json == {'user': 'sanic', 'session': None, 'has_user': True, 'has_session': True, 'has_missing': False, 'invalid': \"'types.SimpleNamespace' object has no attribute 'missing'\", 'response_mw_valid': 'sanic', 'response_mw_invalid': \"'types.SimpleNamespace' object has no attribute 'missing'\"}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_custom_context` function is designed to verify the behavior of middleware in a Sanic web application, specifically how it manages and accesses custom context data within request and response cycles. It ensures that the context is correctly set, accessed, and that appropriate error handling occurs when trying to access non-existent attributes.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. The middleware correctly stores user information in the request context.\n2. The handler can access this context and return the expected JSON response.\n3. The response middleware can access the request context and modify the response based on it.\n4. Accessing a non-existent key in the context raises an `AttributeError`, which is caught and handled gracefully.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Sanic application with:\n- A request middleware (`store`) that initializes `request.ctx.user` and `request.ctx.session`.\n- A route handler (`handler`) that attempts to access `request.ctx.missing`, which does not exist, and captures the resulting `AttributeError`.\n- A response middleware (`modify`) that accesses the context and modifies the response based on the values stored in the request context.\n\nThe test then simulates a GET request to the root endpoint (\"/\") and asserts that the JSON response matches the expected structure, including the values set in the context and the error message for the missing key.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Middleware Testing**: The test effectively demonstrates how to test middleware in a web framework, ensuring that both request and response middleware can interact with the request context.\n- **Error Handling Verification**: It checks that the application correctly handles exceptions (like `AttributeError`) and returns meaningful information in the response.\n- **Assertions on JSON Response**: The use of assertions to compare the actual response against an expected dictionary structure is a common pattern in unit testing, ensuring that the API behaves as intended."
    },
    {
      "name": "test_app_injection",
      "module": "test_request_data",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request_data.py",
      "line_number": 67,
      "end_line_number": 81,
      "source_code": "def test_app_injection(app):\n    expected = random.choice(range(0, 100))\n\n    @app.listener(\"after_server_start\")\n    async def inject_data(app, loop):\n        app.ctx.injected = expected\n\n    @app.get(\"/\")\n    async def handler(request):\n        return json({\"injected\": request.app.ctx.injected})\n\n    request, response = app.test_client.get(\"/\")\n\n    response_json = loads(response.text)\n    assert response_json[\"injected\"] == expected",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "random",
        "sanic.response.json",
        "ujson.loads",
        "json.loads"
      ],
      "fixtures": [],
      "assertions": [
        "assert response_json['injected'] == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_app_injection` function is designed to verify that data can be injected into the application context during the server's startup phase and that this injected data can be accessed through a defined route.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the value injected into the application context (`app.ctx.injected`) is correctly returned in the JSON response when a GET request is made to the root endpoint (\"/\"). It ensures that the application correctly handles the lifecycle event of the server starting and that the injected data persists across requests.\n\n**Code Being Tested and How It Works**:  \nThe test defines an asynchronous listener for the `after_server_start` event, which sets `app.ctx.injected` to a randomly chosen integer between 0 and 99. It then defines a route handler for the root endpoint (\"/\") that returns a JSON response containing the injected value. The test client makes a GET request to this endpoint, and the response is parsed to verify that the injected value matches the expected value.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The use of `async` functions allows for testing asynchronous behavior in the Sanic framework.\n- **Lifecycle Event Handling**: The test leverages Sanic's event listeners to inject data at a specific point in the application lifecycle.\n- **Randomized Input**: The use of `random.choice` introduces variability in the expected output, ensuring that the test checks for correct behavior under different conditions.\n- **Assertions**: The test employs assertions to validate that the actual output matches the expected output, which is a fundamental practice in unit testing."
    },
    {
      "name": "test_middleware_request",
      "module": "test_middleware",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware.py",
      "line_number": 16,
      "end_line_number": 30,
      "source_code": "def test_middleware_request(app):\n    results = []\n\n    @app.middleware\n    async def handler1(request):\n        results.append(request)\n\n    @app.route(\"/\")\n    async def handler2(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/\")\n\n    assert response.text == \"OK\"\n    assert type(results[0]) is Request",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "asyncio.CancelledError",
        "asyncio.sleep",
        "itertools.count",
        "sanic.exceptions.NotFound",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert type(results[0]) is Request"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_middleware_request` function is designed to verify the behavior of middleware in a Sanic web application. Specifically, it checks that the middleware correctly processes incoming requests and that the expected response is returned from the route handler.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the middleware (`handler1`) is invoked when a request is made to the root route (`\"/\"`). It verifies that the request object is appended to the `results` list and that the response from the route handler (`handler2`) is as expected (\"OK\"). Additionally, it checks that the type of the first element in `results` is a `Request` object, confirming that the middleware is functioning correctly.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the middleware registration and the route handler within a Sanic application. The middleware (`handler1`) is defined to append the incoming request to a list (`results`). The route handler (`handler2`) simply returns a text response of \"OK\". The test simulates a GET request to the root URL using `app.test_client.get(\"/\")`, which triggers the middleware and the route handler, allowing the assertions to validate the expected behavior.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Middleware Testing**: It specifically tests the middleware's ability to intercept and process requests.\n- **Assertions**: It uses assertions to validate both the response content and the type of the request object stored in the results list.\n- **Test Client**: The use of `app.test_client.get()` allows for simulating HTTP requests in a controlled environment, making it easier to test the application\u2019s behavior without needing to run a live server."
    },
    {
      "name": "test_middleware_request_as_convenience",
      "module": "test_middleware",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware.py",
      "line_number": 33,
      "end_line_number": 52,
      "source_code": "def test_middleware_request_as_convenience(app):\n    results = []\n\n    @app.on_request\n    async def handler1(request):\n        results.append(request)\n\n    @app.on_request()\n    async def handler2(request):\n        results.append(request)\n\n    @app.route(\"/\")\n    async def handler3(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/\")\n\n    assert response.text == \"OK\"\n    assert type(results[0]) is Request\n    assert type(results[1]) is Request",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "asyncio.CancelledError",
        "asyncio.sleep",
        "itertools.count",
        "sanic.exceptions.NotFound",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert type(results[0]) is Request",
        "assert type(results[1]) is Request"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_middleware_request_as_convenience` test is designed to verify that middleware functions correctly handle incoming requests in a Sanic web application. It ensures that the middleware can access and manipulate the request object before it reaches the route handler.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that two middleware handlers (`handler1` and `handler2`) are invoked when a request is made to the root route (\"/\"). It verifies that both handlers receive the request object and that the response from the route handler is as expected (\"OK\"). Additionally, it confirms that the request objects received by the middleware are of the correct type (`Request`).\n\n**Code Being Tested and How It Works**:  \nThe test sets up two middleware functions that are triggered on every incoming request (`@app.on_request`). It also defines a route handler that returns a simple text response. When the test client makes a GET request to the root route, the middleware functions append the request object to a results list. The assertions at the end check that the response text is \"OK\" and that the types of the objects in the results list are as expected.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Middleware Testing**: The test effectively demonstrates how to test middleware in a web framework, ensuring that middleware can interact with requests as intended.\n- **Asynchronous Testing**: The use of `async` functions indicates that the test is designed to work with asynchronous code, which is common in modern web frameworks like Sanic.\n- **Assertions on Types**: The test employs type assertions to ensure that the objects being handled are of the expected types, which is crucial for maintaining type safety and correctness in the application."
    },
    {
      "name": "test_middleware_response",
      "module": "test_middleware",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware.py",
      "line_number": 55,
      "end_line_number": 76,
      "source_code": "def test_middleware_response(app):\n    results = []\n\n    @app.middleware(\"request\")\n    async def process_request(request):\n        results.append(request)\n\n    @app.middleware(\"response\")\n    async def process_response(request, response):\n        results.append(request)\n        results.append(response)\n\n    @app.route(\"/\")\n    async def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/\")\n\n    assert response.text == \"OK\"\n    assert type(results[0]) is Request\n    assert type(results[1]) is Request\n    assert isinstance(results[2], HTTPResponse)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "asyncio.CancelledError",
        "asyncio.sleep",
        "itertools.count",
        "sanic.exceptions.NotFound",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert type(results[0]) is Request",
        "assert type(results[1]) is Request",
        "assert isinstance(results[2], HTTPResponse)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_middleware_response` function is designed to verify the correct behavior of middleware in a Sanic web application, specifically ensuring that both request and response middleware are executed properly and that they interact as expected with the request and response objects.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the middleware functions are invoked during the handling of a request to the root route (\"/\"). It asserts that the response returned is \"OK\" and verifies the types of the objects appended to the `results` list, ensuring that the correct request and response objects are captured.\n\n**Code Being Tested and How It Works**:  \nThe test sets up two middleware functions: one for processing requests and another for processing responses. The request middleware appends the request object to the `results` list, while the response middleware appends both the request and response objects. The test then simulates a GET request to the root route using `app.test_client.get(\"/\")`, which triggers the middleware and the route handler. The assertions check that the response text is \"OK\" and that the types of the objects in `results` are as expected.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Middleware Testing**: The test effectively demonstrates how to test middleware by capturing the request and response objects and verifying their types.\n- **Asynchronous Testing**: The use of `async` functions indicates that the test is designed to work with asynchronous code, which is common in web frameworks like Sanic.\n- **Assertions**: The test employs multiple assertions to validate the expected outcomes, ensuring that both the response content and the types of the objects in the results list are correct. This thoroughness helps ensure that the middleware behaves as intended."
    },
    {
      "name": "test_middleware_response_as_convenience",
      "module": "test_middleware",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware.py",
      "line_number": 79,
      "end_line_number": 107,
      "source_code": "def test_middleware_response_as_convenience(app):\n    results = []\n\n    @app.on_request\n    async def process_request(request):\n        results.append(request)\n\n    @app.on_response\n    async def process_response_1(request, response):\n        results.append(request)\n        results.append(response)\n\n    @app.on_response()\n    async def process_response_2(request, response):\n        results.append(request)\n        results.append(response)\n\n    @app.route(\"/\")\n    async def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/\")\n\n    assert response.text == \"OK\"\n    assert type(results[0]) is Request\n    assert type(results[1]) is Request\n    assert isinstance(results[2], HTTPResponse)\n    assert type(results[3]) is Request\n    assert isinstance(results[4], HTTPResponse)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "asyncio.CancelledError",
        "asyncio.sleep",
        "itertools.count",
        "sanic.exceptions.NotFound",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert type(results[0]) is Request",
        "assert type(results[1]) is Request",
        "assert isinstance(results[2], HTTPResponse)",
        "assert type(results[3]) is Request",
        "assert isinstance(results[4], HTTPResponse)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_middleware_response_as_convenience` test is to verify that the middleware functions in the Sanic application correctly process requests and responses, ensuring that they are invoked in the expected order and that the correct types of objects are being handled.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that:\n1. The request middleware is called before the response middleware.\n2. The response returned from the route handler is as expected (\"OK\").\n3. The types of objects appended to the `results` list are correct, confirming that the middleware is processing the appropriate request and response objects.\n\n**Code Being Tested and How It Works**:  \nThe code being tested includes:\n- Middleware functions registered with the Sanic app using `@app.on_request` and `@app.on_response`.\n- A route handler defined with `@app.route(\"/\")` that returns a simple text response.\n- The `app.test_client.get(\"/\")` method simulates a GET request to the root endpoint, triggering the middleware and route handler.\n\nThe middleware functions append the request and response objects to the `results` list, which is then asserted against expected types and values to ensure proper functionality.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test uses asynchronous functions to handle requests and responses, which is crucial for testing web frameworks like Sanic that are built on asynchronous I/O.\n- **Middleware Verification**: The test effectively demonstrates how to verify middleware behavior by checking the order and types of objects processed.\n- **Assertions on Types**: The use of `assert type(...)` and `assert isinstance(...)` ensures that the test not only checks for the presence of objects but also validates their types, which is important for ensuring that the middleware is functioning correctly."
    },
    {
      "name": "test_middleware_response_as_convenience_called",
      "module": "test_middleware",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware.py",
      "line_number": 110,
      "end_line_number": 131,
      "source_code": "def test_middleware_response_as_convenience_called(app):\n    results = []\n\n    @app.on_request()\n    async def process_request(request):\n        results.append(request)\n\n    @app.on_response()\n    async def process_response(request, response):\n        results.append(request)\n        results.append(response)\n\n    @app.route(\"/\")\n    async def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/\")\n\n    assert response.text == \"OK\"\n    assert type(results[0]) is Request\n    assert type(results[1]) is Request\n    assert isinstance(results[2], HTTPResponse)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "asyncio.CancelledError",
        "asyncio.sleep",
        "itertools.count",
        "sanic.exceptions.NotFound",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert type(results[0]) is Request",
        "assert type(results[1]) is Request",
        "assert isinstance(results[2], HTTPResponse)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_middleware_response_as_convenience_called` test is to verify that the middleware functions for handling requests and responses in a Sanic application are invoked correctly and that they capture the expected request and response objects.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that:\n1. The response from the route handler is as expected (\"OK\").\n2. The middleware correctly captures the request object when a request is made.\n3. The middleware captures the response object after the request is processed.\n4. The types of the captured objects are as expected (i.e., the first two are `Request` objects and the third is an `HTTPResponse`).\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Sanic application with:\n- A request middleware (`process_request`) that appends the incoming request to a results list.\n- A response middleware (`process_response`) that appends both the request and the response to the same results list.\n- A route handler (`handler`) that simply returns a text response \"OK\".\n\nWhen the test client makes a GET request to the root route (\"/\"), the middleware functions are triggered, and the results are collected. The assertions at the end validate that the response is correct and that the middleware captured the expected objects.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Middleware Testing**: The test effectively demonstrates how to test middleware in a web framework by asserting the behavior of request and response handling.\n- **Asynchronous Testing**: The use of async functions indicates that the test is designed to work with asynchronous code, which is common in modern web frameworks like Sanic.\n- **Assertions on Types**: The test employs type assertions to ensure that the objects captured by the middleware are of the expected types, which is a good practice for ensuring type safety and correctness in the application."
    },
    {
      "name": "test_middleware_response_exception",
      "module": "test_middleware",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware.py",
      "line_number": 134,
      "end_line_number": 152,
      "source_code": "def test_middleware_response_exception(app):\n    result = {\"status_code\": \"middleware not run\"}\n\n    @app.middleware(\"response\")\n    async def process_response(request, response):\n        result[\"status_code\"] = response.status\n        return response\n\n    @app.exception(NotFound)\n    async def error_handler(request, exception):\n        return text(\"OK\", exception.status_code)\n\n    @app.route(\"/\")\n    async def handler(request):\n        return text(\"FAIL\")\n\n    request, response = app.test_client.get(\"/page_not_found\")\n    assert response.text == \"OK\"\n    assert result[\"status_code\"] == 404",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "asyncio.CancelledError",
        "asyncio.sleep",
        "itertools.count",
        "sanic.exceptions.NotFound",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert result['status_code'] == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.exception",
          "body": "@app.route('/')\ndef exception(request):\n    raise SanicExceptionTestException(\"You won't see me\")"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_middleware_response_exception` test is designed to verify the behavior of middleware in a Sanic application when an exception occurs, specifically ensuring that the response status is correctly handled and that the middleware processes the response as expected.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a `NotFound` exception is raised (simulated by accessing a non-existent route), the middleware correctly captures the response status and that the error handler returns the expected response text (\"OK\") with the appropriate status code (404).\n\n**Code Being Tested and How It Works**:  \n1. **Middleware Definition**: The test defines a response middleware that updates a `result` dictionary with the response status code.\n2. **Exception Handling**: An exception handler for `NotFound` is defined, which returns a text response \"OK\" with the status code of the exception.\n3. **Route Definition**: A route is defined that always returns \"FAIL\", but this route is not hit because the test accesses a non-existent route (`/page_not_found`).\n4. **Test Execution**: The test simulates a GET request to the non-existent route, expecting the middleware to run and the error handler to respond with \"OK\" and a status code of 404.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Middleware Testing**: The test effectively demonstrates how to set up and test middleware in a web framework, ensuring that middleware can modify the request/response cycle.\n- **Exception Handling**: It showcases how to handle exceptions in a web application context, ensuring that the application can gracefully respond to errors.\n- **Assertions**: The use of assertions to verify both the response content and the status code ensures that the test is comprehensive and checks multiple aspects of the response behavior."
    },
    {
      "name": "test_middleware_response_raise_cancelled_error",
      "module": "test_middleware",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware.py",
      "line_number": 155,
      "end_line_number": 174,
      "source_code": "def test_middleware_response_raise_cancelled_error(app, caplog):\n    app.config.RESPONSE_TIMEOUT = 1\n\n    @app.middleware(\"response\")\n    async def process_response(request, response):\n        raise CancelledError(\"CancelledError at response middleware\")\n\n    @app.get(\"/\")\n    def handler(request):\n        return text(\"OK\")\n\n    with caplog.at_level(logging.ERROR):\n        reqrequest, response = app.test_client.get(\"/\")\n\n        assert response.status == 500\n        assert (\n            \"sanic.error\",\n            logging.ERROR,\n            \"Exception occurred while handling uri: 'http://127.0.0.1:42101/'\",\n        ) not in caplog.record_tuples",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "caplog"
      ],
      "imports": [
        "logging",
        "asyncio.CancelledError",
        "asyncio.sleep",
        "itertools.count",
        "sanic.exceptions.NotFound",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert ('sanic.error', logging.ERROR, \"Exception occurred while handling uri: 'http://127.0.0.1:42101/'\") not in caplog.record_tuples"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_middleware_response_raise_cancelled_error` test is to verify that when a `CancelledError` is raised in the response middleware of a Sanic application, the application correctly handles the error by returning a 500 Internal Server Error status without logging the error message.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the application does not log an error message when a `CancelledError` occurs in the middleware. It ensures that the response status is set to 500, indicating an internal server error, and that the expected error log entry is absent from the captured logs.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a Sanic application with a middleware function that raises a `CancelledError`. The middleware is registered to run on response events. The test simulates a GET request to the root endpoint (\"/\") and checks the response status and log records. The middleware is expected to raise an error, which should lead to a 500 response status, while the log should not contain a specific error message related to the request handling.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `caplog` fixture from pytest to capture log messages at the ERROR level during the execution of the test. It also uses assertions to verify both the response status and the absence of specific log entries. This pattern of capturing logs and asserting their content is a common technique in testing to ensure that error handling behaves as expected without cluttering the logs with unnecessary error messages."
    },
    {
      "name": "test_middleware_response_raise_exception",
      "module": "test_middleware",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware.py",
      "line_number": 177,
      "end_line_number": 198,
      "source_code": "def test_middleware_response_raise_exception(app, caplog):\n    @app.middleware(\"response\")\n    async def process_response(request, response):\n        raise Exception(\"Exception at response middleware\")\n\n    app.route(\"/\")(lambda x: x)\n    with caplog.at_level(logging.ERROR):\n        reqrequest, response = app.test_client.get(\"/fail\")\n\n    assert response.status == 404\n    # 404 errors are not logged\n    assert (\n        \"sanic.error\",\n        logging.ERROR,\n        \"Exception occurred while handling uri: 'http://127.0.0.1:42101/'\",\n    ) not in caplog.record_tuples\n    # Middleware exception ignored but logged\n    assert (\n        \"sanic.error\",\n        logging.ERROR,\n        \"Exception occurred in one of response middleware handlers\",\n    ) in caplog.record_tuples",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "caplog"
      ],
      "imports": [
        "logging",
        "asyncio.CancelledError",
        "asyncio.sleep",
        "itertools.count",
        "sanic.exceptions.NotFound",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 404",
        "assert ('sanic.error', logging.ERROR, \"Exception occurred while handling uri: 'http://127.0.0.1:42101/'\") not in caplog.record_tuples",
        "assert ('sanic.error', logging.ERROR, 'Exception occurred in one of response middleware handlers') in caplog.record_tuples"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_middleware_response_raise_exception` test is to verify the behavior of the Sanic application when an exception is raised in a response middleware. Specifically, it checks that the application correctly handles the exception without logging a 404 error and ensures that the appropriate error message is logged.\n\n**Specific Functionality or Behavior Verified**:  \nThis test verifies that when an exception occurs in the response middleware, the application does not log a 404 error for the request that triggered the middleware. Instead, it confirms that a specific error message related to the middleware exception is logged. This behavior is crucial for ensuring that middleware exceptions are handled gracefully without affecting the logging of other errors.\n\n**Code Being Tested and How It Works**:  \nThe code being tested includes a middleware function `process_response` that raises an exception when processing a response. The test sets up a route that returns a simple response and then simulates a GET request to a non-existent endpoint (\"/fail\"). The middleware is expected to raise an exception, which should not result in a 404 error being logged, but rather log a specific error message indicating that an exception occurred in the response middleware.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of context management with `caplog.at_level(logging.ERROR)` to capture log messages at the ERROR level during the execution of the test. This allows for assertions on the log output to verify that the correct messages are logged or not logged. Additionally, the test uses assertions to validate the response status and the contents of the log records, demonstrating a clear separation of concerns between response handling and logging behavior."
    },
    {
      "name": "test_middleware_override_request",
      "module": "test_middleware",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware.py",
      "line_number": 201,
      "end_line_number": 213,
      "source_code": "def test_middleware_override_request(app):\n    @app.middleware\n    async def halt_request(request):\n        return text(\"OK\")\n\n    @app.route(\"/\")\n    async def handler(request):\n        return text(\"FAIL\")\n\n    _, response = app.test_client.get(\"/\", gather_request=False)\n\n    assert response.status == 200\n    assert response.text == \"OK\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "asyncio.CancelledError",
        "asyncio.sleep",
        "itertools.count",
        "sanic.exceptions.NotFound",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_middleware_override_request` test is to verify that a middleware function can successfully override the default request handling behavior in a Sanic web application. Specifically, it checks that the middleware can intercept a request and return a response before reaching the route handler.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a request is made to the root endpoint (\"/\"), the middleware `halt_request` is executed, which returns a response with the text \"OK\" and a status code of 200. The test confirms that the route handler is effectively bypassed, demonstrating that the middleware can control the response flow.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a middleware function defined with `@app.middleware`, which intercepts incoming requests. The middleware is designed to return a response directly, thus preventing the route handler from executing. The route handler, which is defined to return \"FAIL\", is not invoked because the middleware takes precedence. The test uses `app.test_client.get(\"/\")` to simulate a GET request to the root URL and captures the response.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of middleware in a web framework context, showcasing how middleware can alter request handling. It also utilizes assertions to validate the response status and content, ensuring that the expected behavior is met. The use of `app.test_client.get` allows for easy simulation of HTTP requests, making it a common pattern in testing web applications. Additionally, the test is structured to be concise and focused, which is a good practice in unit testing."
    },
    {
      "name": "test_middleware_override_response",
      "module": "test_middleware",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware.py",
      "line_number": 216,
      "end_line_number": 228,
      "source_code": "def test_middleware_override_response(app):\n    @app.middleware(\"response\")\n    async def process_response(request, response):\n        return text(\"OK\")\n\n    @app.route(\"/\")\n    async def handler(request):\n        return text(\"FAIL\")\n\n    request, response = app.test_client.get(\"/\")\n\n    assert response.status == 200\n    assert response.text == \"OK\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "asyncio.CancelledError",
        "asyncio.sleep",
        "itertools.count",
        "sanic.exceptions.NotFound",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_middleware_override_response` test is designed to verify that a middleware function can successfully override the response generated by a route handler in a Sanic web application. Specifically, it checks that the response returned by the middleware takes precedence over the response from the route handler.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a middleware is defined to handle the \"response\" phase, it can modify the response before it is sent back to the client. In this case, the middleware is set to return a response with the text \"OK\", regardless of what the route handler returns.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Sanic application with a middleware function that intercepts the response phase. The middleware is defined to return a response with the text \"OK\". The route handler, which is also defined, is intended to return \"FAIL\". When a GET request is made to the root route (\"/\"), the middleware processes the response and returns \"OK\" instead of \"FAIL\". The assertions then check that the response status is 200 and the response text is \"OK\".\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Middleware Testing**: The test effectively demonstrates how to test middleware functionality in a web framework, ensuring that middleware can alter responses.\n- **Asynchronous Testing**: The use of `async` functions indicates that the test is designed to work with asynchronous code, which is common in modern web frameworks like Sanic.\n- **Assertions**: The test employs assertions to validate the expected outcomes, ensuring that the middleware behaves as intended."
    },
    {
      "name": "test_middleware_order",
      "module": "test_middleware",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware.py",
      "line_number": 231,
      "end_line_number": 265,
      "source_code": "def test_middleware_order(app):\n    order = []\n\n    @app.middleware(\"request\")\n    async def request1(request):\n        order.append(1)\n\n    @app.middleware(\"request\")\n    async def request2(request):\n        order.append(2)\n\n    @app.middleware(\"request\")\n    async def request3(request):\n        order.append(3)\n\n    @app.middleware(\"response\")\n    async def response1(request, response):\n        order.append(6)\n\n    @app.middleware(\"response\")\n    async def response2(request, response):\n        order.append(5)\n\n    @app.middleware(\"response\")\n    async def response3(request, response):\n        order.append(4)\n\n    @app.route(\"/\")\n    async def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/\")\n\n    assert response.status == 200\n    assert order == [1, 2, 3, 4, 5, 6]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "asyncio.CancelledError",
        "asyncio.sleep",
        "itertools.count",
        "sanic.exceptions.NotFound",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert order == [1, 2, 3, 4, 5, 6]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_middleware_order` function is designed to verify the execution order of middleware in a Sanic application. It ensures that the request and response middleware are executed in the expected sequence when handling a request.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the middleware functions are called in the correct order during the request and response phases. Specifically, it asserts that the order of execution for the request middleware is `[1, 2, 3]` and for the response middleware is `[4, 5, 6]`, confirming that the middleware is processed in the expected sequence.\n\n**Code Being Tested and How It Works**:  \nThe test sets up three request middleware functions (`request1`, `request2`, `request3`) and three response middleware functions (`response1`, `response2`, `response3`). Each middleware appends a number to the `order` list when executed. The test then simulates a GET request to the root route (`\"/\"`) and checks the response status and the order of middleware execution. The `app.test_client.get(\"/\")` method is used to send the request, and the assertions verify that the response status is `200` and that the `order` list matches the expected sequence.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Middleware Testing**: The test effectively demonstrates how to test middleware execution order, which is crucial for understanding the flow of requests and responses in a web application.\n- **Asynchronous Testing**: The use of `async` functions indicates that the test is designed to work with asynchronous code, which is common in modern web frameworks like Sanic.\n- **Assertions**: The test employs assertions to validate both the response status and the order of middleware execution, ensuring that the application behaves as expected under test conditions."
    },
    {
      "name": "test_request_middleware_executes_once",
      "module": "test_middleware",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware.py",
      "line_number": 268,
      "end_line_number": 285,
      "source_code": "def test_request_middleware_executes_once(app):\n    i = count()\n\n    @app.middleware(\"request\")\n    async def inc(request):\n        nonlocal i\n        next(i)\n\n    @app.route(\"/\")\n    async def handler(request):\n        await request.app._run_request_middleware(request)\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/\")\n    assert next(i) == 1\n\n    request, response = app.test_client.get(\"/\")\n    assert next(i) == 3",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "asyncio.CancelledError",
        "asyncio.sleep",
        "itertools.count",
        "sanic.exceptions.NotFound",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert next(i) == 1",
        "assert next(i) == 3"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_request_middleware_executes_once` test is to verify that the request middleware in the Sanic application executes exactly once per request. This ensures that middleware functions are not inadvertently called multiple times for a single request, which could lead to unexpected behavior.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that the middleware increments a counter (`i`) each time a request is processed. It asserts that the counter reflects the expected number of executions after two consecutive requests to the same endpoint. The expected values are `1` for the first request and `3` for the second request, indicating that the middleware is executed once for the first request and twice for the second (once for the initial request and once for the middleware execution).\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a middleware function `inc` that increments a counter `i` each time a request is received. The middleware is registered with the Sanic app using the `@app.middleware(\"request\")` decorator. The test simulates two GET requests to the root endpoint (`\"/\"`), and after each request, it checks the value of `i` using `next(i)`. The first request should increment `i` to `1`, and the second request should increment it to `3`, as the middleware is executed for both requests.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of a closure with `nonlocal` to maintain state across function calls, specifically for the counter `i`. It also utilizes assertions to validate the expected outcomes after executing the requests. The test leverages the Sanic testing client to simulate HTTP requests, which is a common pattern in testing web applications to ensure that the application behaves as expected under various conditions. Additionally, the use of `count()` from the `itertools` module provides a clean and efficient way to manage the incrementing counter."
    },
    {
      "name": "test_middleware_added_response",
      "module": "test_middleware",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware.py",
      "line_number": 288,
      "end_line_number": 299,
      "source_code": "def test_middleware_added_response(app):\n    @app.on_response\n    def display(_, response):\n        response[\"foo\"] = \"bar\"\n        return json(response)\n\n    @app.get(\"/\")\n    async def handler(request):\n        return {}\n\n    _, response = app.test_client.get(\"/\")\n    assert response.json[\"foo\"] == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "asyncio.CancelledError",
        "asyncio.sleep",
        "itertools.count",
        "sanic.exceptions.NotFound",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json['foo'] == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_middleware_added_response` test verifies that a middleware function can modify the response object before it is sent back to the client. Specifically, it checks that the middleware correctly adds a key-value pair to the response JSON.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the middleware registered with the Sanic application can successfully alter the response data. It specifically checks that the response contains a JSON object with the key `\"foo\"` set to the value `\"bar\"` after the middleware has processed the response.\n\n**Code Being Tested and How It Works**:  \nThe test defines a middleware function `display` that is triggered on the response event (`@app.on_response`). This middleware modifies the response by adding a new key-value pair (`\"foo\": \"bar\"`). The test then defines a simple route handler that returns an empty dictionary. When a GET request is made to the root endpoint (`\"/\"`), the middleware is invoked, and the modified response is checked to ensure it contains the expected data.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Middleware Testing**: The test demonstrates how to test middleware functionality within a web framework, ensuring that middleware can manipulate the response.\n- **Asynchronous Testing**: The use of async functions indicates that the test is designed to work with asynchronous request handling, which is common in modern web frameworks like Sanic.\n- **Assertions**: The test uses assertions to validate the expected outcome, ensuring that the middleware's effect on the response is as intended."
    },
    {
      "name": "test_middleware_return_response",
      "module": "test_middleware",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware.py",
      "line_number": 302,
      "end_line_number": 323,
      "source_code": "def test_middleware_return_response(app):\n    response_middleware_run_count = 0\n    request_middleware_run_count = 0\n\n    @app.on_response\n    def response(_, response):\n        nonlocal response_middleware_run_count\n        response_middleware_run_count += 1\n\n    @app.on_request\n    def request(_):\n        nonlocal request_middleware_run_count\n        request_middleware_run_count += 1\n\n    @app.get(\"/\")\n    async def handler(request):\n        resp1 = await request.respond()\n        return resp1\n\n    app.test_client.get(\"/\")\n    assert response_middleware_run_count == 1\n    assert request_middleware_run_count == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "asyncio.CancelledError",
        "asyncio.sleep",
        "itertools.count",
        "sanic.exceptions.NotFound",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response_middleware_run_count == 1",
        "assert request_middleware_run_count == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_middleware_return_response` test is to verify that the middleware functions for both request and response are executed exactly once when a GET request is made to the root endpoint (\"/\"). This ensures that the middleware is correctly integrated into the request-response lifecycle of the Sanic application.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that the middleware for handling requests and responses is triggered once each during the processing of a request. It asserts that the counters for both the request and response middleware increment correctly, confirming that the middleware is functioning as intended.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the middleware registration via `@app.on_request` and `@app.on_response`, which increment their respective counters when invoked. The test defines a simple GET handler that responds to requests. When `app.test_client.get(\"/\")` is called, it simulates a GET request to the root endpoint, which should invoke both middleware functions. The assertions at the end check that both middleware functions were called exactly once.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of nonlocal variables to maintain state across nested functions, which is a common pattern in Python for tracking counts or states in closures. Additionally, it uses assertions to validate the expected behavior, which is a standard practice in unit testing to ensure that the code behaves as intended. The test also leverages the Sanic framework's built-in testing client to simulate HTTP requests, demonstrating integration testing within the unit test context."
    },
    {
      "name": "test_middleware_run_on_timeout",
      "module": "test_middleware",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware.py",
      "line_number": 326,
      "end_line_number": 349,
      "source_code": "def test_middleware_run_on_timeout(app):\n    app.config.RESPONSE_TIMEOUT = 0.1\n    response_middleware_run_count = 0\n    request_middleware_run_count = 0\n\n    @app.on_response\n    def response(_, response):\n        nonlocal response_middleware_run_count\n        response_middleware_run_count += 1\n\n    @app.on_request\n    def request(_):\n        nonlocal request_middleware_run_count\n        request_middleware_run_count += 1\n\n    @app.get(\"/\")\n    async def handler(request):\n        resp1 = await request.respond()\n        await sleep(1)\n        return resp1\n\n    app.test_client.get(\"/\")\n    assert request_middleware_run_count == 1\n    assert response_middleware_run_count == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "asyncio.CancelledError",
        "asyncio.sleep",
        "itertools.count",
        "sanic.exceptions.NotFound",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request_middleware_run_count == 1",
        "assert response_middleware_run_count == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_middleware_run_on_timeout` test is to verify that both request and response middleware are executed even when a timeout occurs during the handling of a request in a Sanic application. This ensures that middleware functions are robust and can handle scenarios where the request processing takes longer than the configured timeout.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that the middleware for both request and response is invoked exactly once when a request is made to the application, despite the handler's execution being delayed due to a sleep call that exceeds the response timeout. The assertions confirm that the middleware's run counts are as expected.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the Sanic application's middleware registration and the request handler. The `@app.on_request` and `@app.on_response` decorators are used to define middleware functions that increment counters when they are executed. The handler simulates a long-running operation by sleeping for 1 second after responding to the request. The test client then makes a GET request to the root endpoint, and the middleware counters are asserted to ensure they were incremented correctly.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Nonlocal Variables**: The use of `nonlocal` allows the middleware functions to modify the counters defined in the outer scope, which is a common technique for tracking state across nested functions.\n- **Asynchronous Testing**: The test leverages asynchronous programming with `async def` and `await`, which is essential for testing asynchronous frameworks like Sanic.\n- **Timeout Configuration**: The test sets a response timeout to simulate a real-world scenario where requests may exceed expected processing times, ensuring that the middleware behaves correctly under such conditions."
    },
    {
      "name": "test_add_signal",
      "module": "test_signals",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_signals.py",
      "line_number": 15,
      "end_line_number": 20,
      "source_code": "def test_add_signal(app):\n    def sync_signal(*_): ...\n\n    app.add_signal(sync_signal, \"foo.bar.baz\")\n\n    assert len(app.signal_router.routes) == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "enum.Enum",
        "itertools.count",
        "pytest",
        "sanic_routing.exceptions.NotFound",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.empty",
        "sanic.exceptions.InvalidSignal",
        "sanic.exceptions.SanicException",
        "sanic.signals.Event"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(app.signal_router.routes) == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_add_signal` function is designed to verify that a signal can be successfully added to the Sanic application and that the internal routing mechanism correctly reflects this addition by checking the number of routes in the signal router.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that after adding a signal with the name \"foo.bar.baz\", the length of the `app.signal_router.routes` list is equal to 1, indicating that the signal has been registered correctly.\n\n**Code Being Tested and How It Works**:  \nThe relevant code being tested is the `add_signal` method of the Sanic application, which registers a signal handler (`sync_signal`) for a specific event name (\"foo.bar.baz\"). The `app.signal_router.routes` is expected to contain the newly added signal, and the test asserts that its length is 1, confirming that the signal was added successfully.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion to validate the expected state of the application after a specific action (adding a signal). It uses a simple function as a signal handler and checks the internal state of the application, which is a common pattern in unit testing to ensure that the system behaves as expected after performing an operation. The use of a fixture (`app`) suggests that this test is part of a larger test suite, likely utilizing pytest for setup and teardown of the application context."
    },
    {
      "name": "test_add_signal_method_handler",
      "module": "test_signals",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_signals.py",
      "line_number": 23,
      "end_line_number": 45,
      "source_code": "def test_add_signal_method_handler(app):\n    counter = 0\n\n    class TestSanic(Sanic):\n        def __init__(self, *args, **kwargs):\n            super().__init__(*args, **kwargs)\n            self.add_signal(\n                self.after_routing_signal_handler, \"http.routing.after\"\n            )\n\n        def after_routing_signal_handler(self, *args, **kwargs):\n            nonlocal counter\n            counter += 1\n\n    app = TestSanic(\"Test\")\n    assert len(app.signal_router.routes) == 1\n\n    @app.route(\"/\")\n    async def handler(_):\n        return empty()\n\n    app.test_client.get(\"/\")\n    assert counter == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "enum.Enum",
        "itertools.count",
        "pytest",
        "sanic_routing.exceptions.NotFound",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.empty",
        "sanic.exceptions.InvalidSignal",
        "sanic.exceptions.SanicException",
        "sanic.signals.Event"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(app.signal_router.routes) == 1",
        "assert counter == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_add_signal_method_handler` test is to verify that a signal handler can be successfully added to a Sanic application and that it is triggered correctly after a routing event occurs.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `after_routing_signal_handler` method is invoked after a request is made to a defined route (\"/\"). It ensures that the signal mechanism in the Sanic framework works as intended, incrementing a counter when the signal is triggered.\n\n**Code Being Tested and How It Works**:  \nThe test defines a subclass of `Sanic`, `TestSanic`, which overrides the constructor to add a signal handler for the `http.routing.after` event. The `after_routing_signal_handler` method increments a `counter` variable whenever it is called. The test then creates an instance of `TestSanic`, asserts that one signal route has been added, defines a simple route that returns an empty response, and makes a GET request to that route. Finally, it asserts that the `counter` has been incremented to 1, indicating that the signal handler was executed.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Subclassing for Test Isolation**: The test creates a subclass of `Sanic` to encapsulate the signal handling logic, ensuring that the test environment is isolated and controlled.\n- **Nonlocal Variable**: The use of the `nonlocal` keyword allows the signal handler to modify the `counter` variable defined in the enclosing scope, demonstrating a technique for maintaining state across function calls.\n- **Assertions**: The test employs assertions to validate the expected outcomes, ensuring that the signal system behaves correctly after a routing event."
    },
    {
      "name": "test_add_signal_decorator",
      "module": "test_signals",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_signals.py",
      "line_number": 48,
      "end_line_number": 56,
      "source_code": "def test_add_signal_decorator(app):\n    @app.signal(\"foo.bar.baz\")\n    def sync_signal(*_): ...\n\n    @app.signal(\"foo.bar.baz\")\n    async def async_signal(*_): ...\n\n    assert len(app.signal_router.routes) == 2\n    assert len(app.signal_router.dynamic_routes) == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "enum.Enum",
        "itertools.count",
        "pytest",
        "sanic_routing.exceptions.NotFound",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.empty",
        "sanic.exceptions.InvalidSignal",
        "sanic.exceptions.SanicException",
        "sanic.signals.Event"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(app.signal_router.routes) == 2",
        "assert len(app.signal_router.dynamic_routes) == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_add_signal_decorator` unit test is designed to verify that the Sanic application correctly registers both synchronous and asynchronous signal handlers for the same event. It ensures that the application can handle multiple signal handlers for a single event without conflicts.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when two signal handlers (one synchronous and one asynchronous) are added for the same event (`\"foo.bar.baz\"`), the total number of routes in the signal router is correctly updated to reflect both handlers. It also verifies that the number of dynamic routes is as expected, indicating that the application can manage different types of signal handlers.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the Sanic application's signal router, which is responsible for managing event handlers. The test uses the `@app.signal` decorator to register two handlers for the event `\"foo.bar.baz\"`: a synchronous function (`sync_signal`) and an asynchronous function (`async_signal`). After these registrations, the test asserts that the length of `app.signal_router.routes` is 2 (indicating both handlers are registered) and that `app.signal_router.dynamic_routes` has a length of 1 (indicating that one of the handlers is asynchronous).\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of decorators to register signal handlers, which is a common pattern in event-driven programming. It also utilizes assertions to validate the state of the application after the handlers are registered, ensuring that the expected behavior aligns with the actual behavior of the signal router. The test is structured to be concise and focused, directly verifying the outcomes of the signal registration process without extraneous complexity."
    },
    {
      "name": "test_invalid_signal",
      "module": "test_signals",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_signals.py",
      "line_number": 68,
      "end_line_number": 72,
      "source_code": "def test_invalid_signal(app, signal):\n    with pytest.raises(InvalidSignal, match=f\"Invalid signal event: {signal}\"):\n\n        @app.signal(signal)\n        def handler(): ...",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('signal', ('<foo>.bar.bax', 'foo.<bar>.baz', 'foo.bar', 'foo.bar.baz.qux'))"
      ],
      "arguments": [
        "app",
        "signal"
      ],
      "imports": [
        "asyncio",
        "enum.Enum",
        "itertools.count",
        "pytest",
        "sanic_routing.exceptions.NotFound",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.empty",
        "sanic.exceptions.InvalidSignal",
        "sanic.exceptions.SanicException",
        "sanic.signals.Event"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_invalid_signal` function is designed to verify that the application correctly raises an `InvalidSignal` exception when an invalid signal is registered. This ensures that the signal handling mechanism enforces valid signal names and prevents erroneous configurations.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that when an invalid signal (passed as the `signal` argument) is registered using the `@app.signal(signal)` decorator, the application raises an `InvalidSignal` exception with a message that includes the invalid signal name. This behavior is crucial for maintaining the integrity of the signal system within the application.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the registration of a signal handler using the `@app.signal(signal)` decorator. The `signal` parameter represents the name of the signal being registered. If the signal name is invalid, the context manager `pytest.raises` is used to assert that an `InvalidSignal` exception is raised, and it checks that the exception message matches the expected format, which includes the invalid signal name.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that an exception is raised during the execution of the code block. This is a common pattern in unit testing to verify that specific error conditions are handled correctly. Additionally, the use of formatted strings in the `match` argument allows for dynamic verification of the exception message, enhancing the robustness of the test. The test is also parameterized with `app` and `signal`, indicating that it can be run with multiple configurations, which is a useful technique for testing various scenarios efficiently."
    },
    {
      "name": "test_bad_finalize",
      "module": "test_signals",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_signals.py",
      "line_number": 562,
      "end_line_number": 575,
      "source_code": "def test_bad_finalize(app):\n    counter = 0\n\n    @app.signal(\"foo.bar.baz\")\n    def sync_signal(amount):\n        nonlocal counter\n        counter += amount\n\n    with pytest.raises(\n        RuntimeError, match=\"Cannot finalize signals outside of event loop\"\n    ):\n        app.signal_router.finalize()\n\n    assert counter == 0",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "enum.Enum",
        "itertools.count",
        "pytest",
        "sanic_routing.exceptions.NotFound",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.empty",
        "sanic.exceptions.InvalidSignal",
        "sanic.exceptions.SanicException",
        "sanic.signals.Event"
      ],
      "fixtures": [],
      "assertions": [
        "assert counter == 0"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_bad_finalize` unit test is designed to verify that the `finalize` method of the `signal_router` raises a `RuntimeError` when it is called outside of an event loop context. This ensures that the application correctly enforces its operational constraints regarding signal finalization.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that the application does not allow the finalization of signals when the event loop is not running. It expects a `RuntimeError` with a specific message to be raised, indicating that the operation is invalid in the current context.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `finalize` method of the `signal_router` within the Sanic application. The method is expected to complete the signal handling setup, but it should only be callable when the application is in an appropriate state (i.e., within an active event loop). The test sets up a signal handler (`sync_signal`) that increments a counter but does not invoke it, ensuring that the counter remains zero. The test then attempts to call `app.signal_router.finalize()` and checks for the expected exception.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that an exception is raised during the execution of the `finalize` method. This is a common pattern in unit testing for verifying that specific error conditions are handled correctly. Additionally, the use of `nonlocal` allows the test to modify the `counter` variable from within the nested signal handler, demonstrating a clear understanding of variable scope in Python. The final assertion checks that the counter remains unchanged, reinforcing the expectation that the signal finalization did not occur."
    },
    {
      "name": "test_event_on_bp_not_registered",
      "module": "test_signals",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_signals.py",
      "line_number": 632,
      "end_line_number": 642,
      "source_code": "def test_event_on_bp_not_registered():\n    bp = Blueprint(\"bp\")\n\n    @bp.signal(\"foo.bar.baz\")\n    def bp_signal(): ...\n\n    with pytest.raises(\n        SanicException,\n        match=\"<Blueprint bp> has not yet been registered to an app\",\n    ):\n        bp.event(\"foo.bar.baz\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "enum.Enum",
        "itertools.count",
        "pytest",
        "sanic_routing.exceptions.NotFound",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.empty",
        "sanic.exceptions.InvalidSignal",
        "sanic.exceptions.SanicException",
        "sanic.signals.Event"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_event_on_bp_not_registered` test is to verify that an attempt to register an event on a Sanic `Blueprint` that has not been registered to an application raises the appropriate exception, specifically a `SanicException`.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the Sanic framework correctly enforces the requirement that a `Blueprint` must be registered to an application before any events can be associated with it. It ensures that the error message returned is specific and informative, indicating that the `Blueprint` is not registered.\n\n**Code Being Tested and How It Works**:  \nThe test creates a `Blueprint` instance named \"bp\" and defines a signal associated with the event \"foo.bar.baz\". It then attempts to register an event handler for the same signal using `bp.event(\"foo.bar.baz\")`. Since the `Blueprint` has not been registered to any application, the code is expected to raise a `SanicException` with a specific message indicating the issue.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that an exception is raised during the execution of the code block. This is a common pattern in unit testing to verify that specific error conditions are handled correctly. Additionally, the use of the `match` parameter allows for checking that the exception message matches the expected output, ensuring that not only is an exception raised, but it is the correct one with the appropriate message."
    },
    {
      "name": "test_signal_reservation",
      "module": "test_signals",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_signals.py",
      "line_number": 655,
      "end_line_number": 663,
      "source_code": "def test_signal_reservation(app, event, expected):\n    if not expected:\n        with pytest.raises(\n            InvalidSignal,\n            match=f\"Cannot declare reserved signal event: {event}\",\n        ):\n            app.signal(event)(lambda: ...)\n    else:\n        app.signal(event)(lambda: ...)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('event,expected', (('foo.bar.baz', True), ('server.init.before', True), ('server.init.somethingelse', False), ('http.request.start', False), ('sanic.notice.anything', True)))"
      ],
      "arguments": [
        "app",
        "event",
        "expected"
      ],
      "imports": [
        "asyncio",
        "enum.Enum",
        "itertools.count",
        "pytest",
        "sanic_routing.exceptions.NotFound",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.empty",
        "sanic.exceptions.InvalidSignal",
        "sanic.exceptions.SanicException",
        "sanic.signals.Event"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_signal_reservation` function is designed to verify that certain signal events in the Sanic application framework are either allowed or disallowed based on predefined expectations. Specifically, it checks whether attempting to declare a reserved signal event raises an `InvalidSignal` exception when it should not be allowed.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks the behavior of the `app.signal(event)` method when provided with various event names. It ensures that for certain events (defined in the `expected` parameter), the application can successfully register the signal without any exceptions. Conversely, for other events that are reserved, it verifies that an `InvalidSignal` exception is raised, indicating that the event cannot be declared.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `app.signal(event)` method, which is part of the Sanic framework's signal handling mechanism. The method is expected to register a signal handler for the specified event. The test uses the `pytest.raises` context manager to assert that an exception is raised when an attempt is made to register a reserved event. The `match` parameter in `pytest.raises` ensures that the exception message matches the expected output, providing additional validation of the error handling.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs parameterized testing using `pytest.mark.parametrize`, which allows for multiple sets of inputs (`event` and `expected`) to be tested in a single test function. This approach enhances test coverage and reduces code duplication. Additionally, the use of exception assertions with `pytest.raises` is a common pattern in unit testing to verify that specific error conditions are handled correctly. The test structure is clear and concise, making it easy to understand the expected outcomes for each input scenario."
    },
    {
      "name": "test_report_exception_runs",
      "module": "test_signals",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_signals.py",
      "line_number": 687,
      "end_line_number": 700,
      "source_code": "def test_report_exception_runs(app: Sanic):\n    event = asyncio.Event()\n\n    @app.report_exception\n    async def catch_any_exception(app: Sanic, exception: Exception):\n        event.set()\n\n    @app.route(\"/\")\n    async def handler(request):\n        1 / 0\n\n    app.test_client.get(\"/\")\n\n    assert event.is_set()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "enum.Enum",
        "itertools.count",
        "pytest",
        "sanic_routing.exceptions.NotFound",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.empty",
        "sanic.exceptions.InvalidSignal",
        "sanic.exceptions.SanicException",
        "sanic.signals.Event"
      ],
      "fixtures": [],
      "assertions": [
        "assert event.is_set()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_report_exception_runs` test is designed to verify that the Sanic application correctly reports exceptions that occur during request handling. Specifically, it checks that the exception handling mechanism is triggered when an unhandled exception (division by zero) occurs in the route handler.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the `report_exception` decorator is functioning as intended by confirming that the `catch_any_exception` function is invoked when an exception is raised in the route handler. The test checks that the `event` is set, indicating that the exception was caught and handled.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Sanic application with a route that intentionally raises a `ZeroDivisionError`. The `catch_any_exception` function is registered with the `report_exception` decorator, which is called whenever an exception occurs in the application. The `event.set()` call within this function signals that the exception was caught. The test then makes a GET request to the route, which triggers the exception, and finally asserts that the `event` is set, confirming that the exception handling mechanism was activated.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test uses asynchronous functions and the `asyncio.Event` to manage the flow of execution and synchronization, ensuring that the test waits for the exception handling to complete.\n- **Decorator Usage**: The use of the `@app.report_exception` decorator demonstrates how to extend the functionality of the Sanic application by adding custom exception handling logic.\n- **Event Signaling**: The test employs an event signaling mechanism to verify that the exception handling code was executed, which is a common pattern in asynchronous programming to coordinate between different parts of the code."
    },
    {
      "name": "test_report_exception_runs_once_inline",
      "module": "test_signals",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_signals.py",
      "line_number": 703,
      "end_line_number": 722,
      "source_code": "def test_report_exception_runs_once_inline(app: Sanic):\n    event = asyncio.Event()\n    c = count()\n\n    @app.report_exception\n    async def catch_any_exception(app: Sanic, exception: Exception):\n        event.set()\n        next(c)\n\n    @app.route(\"/\")\n    async def handler(request): ...\n\n    @app.signal(Event.HTTP_ROUTING_AFTER.value)\n    async def after_routing(**_):\n        1 / 0\n\n    app.test_client.get(\"/\")\n\n    assert event.is_set()\n    assert next(c) == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "enum.Enum",
        "itertools.count",
        "pytest",
        "sanic_routing.exceptions.NotFound",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.empty",
        "sanic.exceptions.InvalidSignal",
        "sanic.exceptions.SanicException",
        "sanic.signals.Event"
      ],
      "fixtures": [],
      "assertions": [
        "assert event.is_set()",
        "assert next(c) == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_report_exception_runs_once_inline` is designed to verify that the exception reporting mechanism in the Sanic web framework correctly captures and handles exceptions raised during the request lifecycle. Specifically, it checks that the exception handler is invoked exactly once when an exception occurs.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when an exception is raised in the routing phase (in this case, a division by zero), the registered exception handler (`catch_any_exception`) is triggered, setting an event and incrementing a counter. The test asserts that the event is set and that the counter has been incremented exactly once, confirming that the exception handling logic is functioning as intended.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the Sanic application setup, where an exception handler is registered using the `@app.report_exception` decorator. The handler sets an `asyncio.Event` when invoked and increments a counter. The test simulates a request to the root route (`\"/\"`) which triggers the `after_routing` signal, where a deliberate exception (division by zero) is raised. The assertions at the end check if the event was set and if the counter was incremented correctly.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test uses `async` functions and `asyncio.Event` to handle asynchronous behavior, which is common in web frameworks like Sanic.\n- **Signal Handling**: The test leverages Sanic's signal mechanism to trigger the exception, demonstrating how to integrate custom behavior into the request lifecycle.\n- **Counter for Invocation Tracking**: The use of a counter (via `count()`) to track the number of times the exception handler is invoked is a practical technique for verifying that the handler runs the expected number of times."
    },
    {
      "name": "test_report_exception_runs_once_custom",
      "module": "test_signals",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_signals.py",
      "line_number": 725,
      "end_line_number": 746,
      "source_code": "def test_report_exception_runs_once_custom(app: Sanic):\n    event = asyncio.Event()\n    c = count()\n\n    @app.report_exception\n    async def catch_any_exception(app: Sanic, exception: Exception):\n        event.set()\n        next(c)\n\n    @app.route(\"/\")\n    async def handler(request):\n        await app.dispatch(\"one.two.three\")\n        return empty()\n\n    @app.signal(\"one.two.three\")\n    async def one_two_three(**_):\n        1 / 0\n\n    app.test_client.get(\"/\")\n\n    assert event.is_set()\n    assert next(c) == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "enum.Enum",
        "itertools.count",
        "pytest",
        "sanic_routing.exceptions.NotFound",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.empty",
        "sanic.exceptions.InvalidSignal",
        "sanic.exceptions.SanicException",
        "sanic.signals.Event"
      ],
      "fixtures": [],
      "assertions": [
        "assert event.is_set()",
        "assert next(c) == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_report_exception_runs_once_custom` test is designed to verify that the custom exception reporting mechanism in the Sanic web framework correctly captures and handles exceptions raised during the processing of a request. Specifically, it checks that the exception handler is invoked exactly once when an exception occurs.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when an exception is raised in a signal handler (in this case, during the dispatch of a custom signal), the registered exception handler (`catch_any_exception`) is triggered, and it sets an event to indicate that the exception was caught. The test also verifies that the handler was called only once by using a counter.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Sanic application with a route that dispatches a signal (`\"one.two.three\"`). The signal handler intentionally raises a division by zero exception. The `catch_any_exception` function is decorated with `@app.report_exception`, which registers it to handle exceptions. When the test client makes a GET request to the root route (`\"/\"`), the exception is raised, triggering the exception handler. The test then checks if the event was set (indicating the handler was called) and that the counter incremented correctly, confirming the handler ran once.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test uses `async` functions and `asyncio.Event` to handle asynchronous behavior, which is common in web frameworks like Sanic.\n- **Signal Handling**: The test leverages Sanic's signal mechanism to simulate the occurrence of an event that leads to an exception, allowing for a clean separation of concerns.\n- **Counter for Verification**: The use of a counter (`count()`) to track the number of times the exception handler is invoked is a straightforward technique to ensure that the handler runs exactly once, providing a clear assertion for the test's intent."
    },
    {
      "name": "test_report_exception_runs_task",
      "module": "test_signals",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_signals.py",
      "line_number": 749,
      "end_line_number": 772,
      "source_code": "def test_report_exception_runs_task(app: Sanic):\n    c = count()\n\n    async def task_1():\n        next(c)\n\n    async def task_2(app):\n        next(c)\n\n    @app.report_exception\n    async def catch_any_exception(app: Sanic, exception: Exception):\n        next(c)\n\n    @app.route(\"/\")\n    async def handler(request):\n        app.add_task(task_1)\n        app.add_task(task_1())\n        app.add_task(task_2)\n        app.add_task(task_2(app))\n        return empty()\n\n    app.test_client.get(\"/\")\n\n    assert next(c) == 4",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "enum.Enum",
        "itertools.count",
        "pytest",
        "sanic_routing.exceptions.NotFound",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.empty",
        "sanic.exceptions.InvalidSignal",
        "sanic.exceptions.SanicException",
        "sanic.signals.Event"
      ],
      "fixtures": [],
      "assertions": [
        "assert next(c) == 4"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.add_task",
          "body": "def add_task(self, func):\n    loop = asyncio.get_event_loop()\n    self.stay_active_task = loop.create_task(func(self))"
        },
        {
          "name": "app.add_task",
          "body": "def add_task(self, func):\n    loop = asyncio.get_event_loop()\n    self.stay_active_task = loop.create_task(func(self))"
        },
        {
          "name": "app.add_task",
          "body": "def add_task(self, func):\n    loop = asyncio.get_event_loop()\n    self.stay_active_task = loop.create_task(func(self))"
        },
        {
          "name": "app.add_task",
          "body": "def add_task(self, func):\n    loop = asyncio.get_event_loop()\n    self.stay_active_task = loop.create_task(func(self))"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_report_exception_runs_task` test is to verify that when an exception occurs during the handling of a request in a Sanic application, the registered exception handler is invoked, and any tasks added to the application are executed correctly.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the exception handling mechanism in the Sanic framework works as intended by ensuring that the `catch_any_exception` function is called when an exception is raised. It also verifies that the tasks added to the application are executed, and the count of these executions matches the expected value.\n\n**Code Being Tested and How It Works**:  \nThe test sets up an asynchronous environment where multiple tasks (`task_1` and `task_2`) are added to the application. The `handler` function is defined to add these tasks to the event loop. When the test client makes a GET request to the root endpoint (\"/\"), it triggers the execution of these tasks. The `catch_any_exception` function is decorated with `@app.report_exception`, which means it will be called if an exception occurs during the request handling. The `count` generator is used to track how many times the `next(c)` function is called, which should equal 4 by the end of the test, indicating that all tasks and the exception handler were executed.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test utilizes asynchronous functions and the Sanic framework's event loop to manage concurrent tasks, which is essential for testing web applications that handle multiple requests simultaneously.\n- **Decorator for Exception Handling**: The use of the `@app.report_exception` decorator allows for centralized exception handling, making it easier to manage and test how exceptions are reported and handled.\n- **Count Tracking**: The `count` generator is a simple yet effective way to track the number of times certain code paths are executed, providing a clear assertion at the end of the test to validate the expected behavior."
    },
    {
      "name": "test_no_exceptions_when_cancel_pending_request",
      "module": "test_graceful_shutdown",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_graceful_shutdown.py",
      "line_number": 12,
      "end_line_number": 31,
      "source_code": "def test_no_exceptions_when_cancel_pending_request(\n    app, caplog: LogCaptureFixture, port\n):\n    app.config.GRACEFUL_SHUTDOWN_TIMEOUT = 1\n\n    @app.get(\"/\")\n    async def handler(request):\n        await asyncio.sleep(5)\n\n    @app.listener(\"after_server_start\")\n    async def _request(sanic, loop):\n        connect = asyncio.open_connection(\"127.0.0.1\", port)\n        _, writer = await connect\n        writer.write(b\"GET / HTTP/1.1\\r\\n\\r\\n\")\n        app.stop()\n\n    with caplog.at_level(logging.INFO):\n        app.run(single_process=True, access_log=True, port=port)\n\n    assert \"Request: GET http:/// stopped. Transport is closed.\" in caplog.text",
      "docstring": null,
      "decorators": [
        "pytest.mark.xfail(reason='This test runs fine locally, but fails on CI')"
      ],
      "arguments": [
        "app",
        "caplog",
        "port"
      ],
      "imports": [
        "asyncio",
        "logging",
        "pytest",
        "pytest.LogCaptureFixture",
        "sanic.response.empty"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'Request: GET http:/// stopped. Transport is closed.' in caplog.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        },
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_no_exceptions_when_cancel_pending_request` test is to verify that the Sanic application can gracefully handle the cancellation of a pending request without raising any exceptions. This is particularly important for ensuring that the application can shut down cleanly while requests are still being processed.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that when a request is initiated and then the application is instructed to stop, the application logs a message indicating that the request was stopped and the transport is closed. This ensures that the application behaves as expected during a shutdown scenario, without leaving any hanging requests or causing unhandled exceptions.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Sanic application with a route that simulates a long-running request (5 seconds) using `asyncio.sleep`. It also defines a listener that sends a GET request to the application and then immediately calls `app.stop()` to initiate the shutdown process. The test runs the application in a single process and captures log output at the INFO level. After the application runs, it asserts that the expected log message indicating the cancellation of the request is present in the captured logs.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test leverages asynchronous programming with `async def` and `await`, which is essential for testing asynchronous frameworks like Sanic.\n- **Log Capture**: The use of `caplog` allows the test to capture and assert log messages, which is crucial for verifying that the application behaves correctly during shutdown.\n- **Graceful Shutdown Configuration**: The test modifies the application's configuration to set a `GRACEFUL_SHUTDOWN_TIMEOUT`, which is a key aspect of testing how the application handles shutdown scenarios.\n- **Mocking and Dependency Injection**: The test indirectly uses dependency injection by passing the `app`, `caplog`, and `port` parameters, allowing for flexible testing of the application in different contexts."
    },
    {
      "name": "test_completes_request",
      "module": "test_graceful_shutdown",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_graceful_shutdown.py",
      "line_number": 34,
      "end_line_number": 61,
      "source_code": "def test_completes_request(app, caplog: LogCaptureFixture, port):\n    app.config.GRACEFUL_SHUTDOWN_TIMEOUT = 1\n\n    @app.get(\"/\")\n    async def handler(request):\n        await asyncio.sleep(0.5)\n        return empty()\n\n    @app.listener(\"after_server_start\")\n    async def _request(sanic, loop):\n        connect = asyncio.open_connection(\"127.0.0.1\", port)\n        _, writer = await connect\n        writer.write(b\"GET / HTTP/1.1\\r\\n\\r\\n\")\n        app.stop()\n\n    with caplog.at_level(logging.INFO):\n        app.run(single_process=True, access_log=True, port=port)\n\n    assert (\"sanic.access\", 20, \"\") in caplog.record_tuples\n\n    # Make sure that the server starts shutdown process before access log\n    index_stopping = 0\n    for idx, record in enumerate(caplog.records):\n        if record.message.startswith(\"Stopping worker\"):\n            index_stopping = idx\n            break\n    index_request = caplog.record_tuples.index((\"sanic.access\", 20, \"\"))\n    assert index_request > index_stopping > 0",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "caplog",
        "port"
      ],
      "imports": [
        "asyncio",
        "logging",
        "pytest",
        "pytest.LogCaptureFixture",
        "sanic.response.empty"
      ],
      "fixtures": [],
      "assertions": [
        "assert ('sanic.access', 20, '') in caplog.record_tuples",
        "assert index_request > index_stopping > 0"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "caplog.record_tuples.index",
          "body": "@app.route('/', name='hostindex', host='example.com')\n@app.route('/path', name='hostpath', host='path.example.com')\ndef index(request):\n    pass"
        },
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        },
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_completes_request` function is designed to verify that the Sanic application can successfully handle a request and log the appropriate access information before initiating a graceful shutdown. It ensures that the server processes incoming requests correctly and that the shutdown sequence is logged in the expected order.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a GET request is made to the root endpoint (\"/\"), the server responds correctly and that the access log captures this request. Additionally, it verifies that the server begins its shutdown process before logging the access information, ensuring the correct sequence of operations during shutdown.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a simple Sanic application with a GET handler that simulates a delay of 0.5 seconds before returning an empty response. The `after_server_start` listener is used to send a GET request to the server after it starts. The server is then stopped immediately after sending the request. The test checks the log records captured by `caplog` to confirm that the access log entry for the request is present and that the shutdown log entry appears before the access log entry.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test utilizes asynchronous functions to handle requests and responses, which is essential for testing an asynchronous web framework like Sanic.\n- **Logging Capture**: The `caplog` fixture from pytest is used to capture log messages during the test, allowing for assertions on the log output.\n- **Graceful Shutdown Verification**: The test explicitly checks the order of log entries to ensure that the server's shutdown process is initiated correctly, demonstrating an understanding of the application's lifecycle events."
    },
    {
      "name": "test_response_body_not_a_string",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 41,
      "end_line_number": 51,
      "source_code": "def test_response_body_not_a_string(app):\n    \"\"\"Test when a response body sent from the application is not a string\"\"\"\n    random_num = choice(range(1000))\n\n    @app.route(\"/hello\")\n    async def hello_route(request: Request):\n        return text(random_num)\n\n    request, response = app.test_client.get(\"/hello\")\n    assert response.status == 500\n    assert b\"Internal Server Error\" in response.body",
      "docstring": "Test when a response body sent from the application is not a string",
      "decorators": [
        "pytest.mark.filterwarnings('ignore:Types other than str will be')"
      ],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert b'Internal Server Error' in response.body"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_response_body_not_a_string` is designed to verify the behavior of the Sanic application when a response body that is not a string is returned from a route handler. Specifically, it checks that the application correctly raises an internal server error (HTTP status 500) in such cases.\n\n**Specific Functionality or Behavior Verified**:  \nThe test ensures that when a non-string response body (in this case, an integer) is returned, the application does not process it successfully. Instead, it should trigger an error handling mechanism that results in a 500 Internal Server Error response, confirming that the application enforces type constraints on response bodies.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the route handler defined in the test, which is set up to return a random integer as the response body. The `app.test_client.get(\"/hello\")` method simulates a GET request to this route. The expected behavior is that the `text` function, which is responsible for creating text responses, raises a `TypeError` because the body is not a string. This error is caught by the Sanic framework, which then returns a 500 status code along with an appropriate error message in the response body.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of an asynchronous route handler and the Sanic testing client to simulate HTTP requests. It also utilizes assertions to verify the response status and the presence of an error message in the response body. This pattern of testing routes by simulating requests and checking responses is common in web application testing, allowing for the verification of both expected outcomes and error handling behavior."
    },
    {
      "name": "test_method_not_allowed",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 63,
      "end_line_number": 100,
      "source_code": "def test_method_not_allowed():\n    app = Sanic(\"app\")\n\n    @app.get(\"/\")\n    async def test_get(request: Request):\n        return response.json({\"hello\": \"world\"})\n\n    request, response = app.test_client.head(\"/\")\n    assert set(response.headers[\"Allow\"].split(\", \")) == {\n        \"GET\",\n    }\n\n    request, response = app.test_client.post(\"/\")\n    assert set(response.headers[\"Allow\"].split(\", \")) == {\n        \"GET\",\n    }\n\n    app.router.reset()\n\n    @app.post(\"/\")\n    async def test_post(request: Request):\n        return response.json({\"hello\": \"world\"})\n\n    request, response = app.test_client.head(\"/\")\n    assert response.status == 405\n    assert set(response.headers[\"Allow\"].split(\", \")) == {\n        \"GET\",\n        \"POST\",\n    }\n    assert response.headers[\"Content-Length\"] == \"0\"\n\n    request, response = app.test_client.patch(\"/\")\n    assert response.status == 405\n    assert set(response.headers[\"Allow\"].split(\", \")) == {\n        \"GET\",\n        \"POST\",\n    }\n    assert response.headers[\"Content-Length\"] == \"0\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert set(response.headers['Allow'].split(', ')) == {'GET'}",
        "assert set(response.headers['Allow'].split(', ')) == {'GET'}",
        "assert response.status == 405",
        "assert set(response.headers['Allow'].split(', ')) == {'GET', 'POST'}",
        "assert response.headers['Content-Length'] == '0'",
        "assert response.status == 405",
        "assert set(response.headers['Allow'].split(', ')) == {'GET', 'POST'}",
        "assert response.headers['Content-Length'] == '0'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "app.test_client.patch('/')"
      ],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.head",
          "body": "def head(self, request):\n    return text('', headers={'method': 'HEAD'})"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.router.reset",
          "body": "@pytest.fixture(autouse=True)\ndef reset():\n    try:\n        del os.environ['SANIC_MOTD_OUTPUT']\n    except KeyError:\n        ..."
        },
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.head",
          "body": "def head(self, request):\n    return text('', headers={'method': 'HEAD'})"
        },
        {
          "name": "app.test_client.patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_method_not_allowed` function is designed to verify the behavior of the Sanic web framework when HTTP methods that are not allowed for a specific route are invoked. It specifically checks that the server responds with a 405 Method Not Allowed status and provides the correct `Allow` header indicating which methods are permitted.\n\n**Specific Functionality or Behavior Verified**:  \nThe test ensures that:\n1. A GET request to the root path (\"/\") is allowed, while HEAD and POST requests initially return the allowed methods as \"GET\".\n2. After defining a POST handler for the same path, HEAD and PATCH requests return a 405 status, indicating that these methods are not allowed, while the `Allow` header correctly lists both \"GET\" and \"POST\" as valid methods.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the Sanic application instance:\n- It first defines a GET route that returns a JSON response.\n- It then uses the test client to send HEAD and POST requests to the root path and checks the `Allow` header.\n- After resetting the router and defining a POST route, it again sends HEAD and PATCH requests to verify that they return a 405 status and the correct `Allow` header.\n- The `MethodNotAllowed` exception class is implicitly tested as it is responsible for generating the 405 response and the `Allow` header.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Setup and Teardown**: The test uses `app.router.reset()` to clear previous route definitions, ensuring that tests do not interfere with each other.\n- **Assertions**: The test employs assertions to validate the response status and headers, ensuring that the application behaves as expected under different HTTP methods.\n- **Asynchronous Testing**: The test is structured to handle asynchronous routes, which is a common pattern in modern web frameworks like Sanic."
    },
    {
      "name": "test_response_header",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 103,
      "end_line_number": 114,
      "source_code": "def test_response_header(app):\n    @app.get(\"/\")\n    async def test(request: Request):\n        return json({\"ok\": True}, headers={\"CONTENT-TYPE\": \"application/json\"})\n\n    request, response = app.test_client.get(\"/\")\n    for key, value in {\n        \"connection\": \"keep-alive\",\n        \"content-length\": \"11\",\n        \"content-type\": \"application/json\",\n    }.items():\n        assert response.headers[key] == value",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.headers[key] == value"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_response_header` function is designed to verify that the HTTP response headers returned by the Sanic application contain the expected values. This ensures that the application correctly sets and returns headers in its responses, which is crucial for proper client-server communication.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks for the presence and correctness of three HTTP response headers: `connection`, `content-length`, and `content-type`. It asserts that these headers match the expected values, confirming that the application is returning the correct metadata about the response.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route (`@app.get(\"/\")`) that returns a JSON response with a header specifying the content type as `application/json`. The `app.test_client.get(\"/\")` method is then called to simulate a GET request to this route. The response is captured, and the headers are checked against a predefined dictionary of expected values. The headers are accessed from the `response` object, which is returned by the test client.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The test uses a fixture (`app`) to provide a test instance of the Sanic application, allowing for isolated testing of routes and responses.\n- **Direct Header Assertion**: The test directly asserts the values of response headers, which is a common practice in testing HTTP responses to ensure that the server behaves as expected.\n- **Looping Through Expected Values**: The test employs a loop to iterate through expected header values, which enhances readability and maintainability by reducing redundancy in assertions."
    },
    {
      "name": "test_response_content_length",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 117,
      "end_line_number": 147,
      "source_code": "def test_response_content_length(app):\n    @app.get(\"/response_with_space\")\n    async def response_with_space(request: Request):\n        return json(\n            {\"message\": \"Data\", \"details\": \"Some Details\"},\n            headers={\"CONTENT-TYPE\": \"application/json\"},\n        )\n\n    @app.get(\"/response_without_space\")\n    async def response_without_space(request: Request):\n        return json(\n            {\"message\": \"Data\", \"details\": \"Some Details\"},\n            headers={\"CONTENT-TYPE\": \"application/json\"},\n        )\n\n    _, response = app.test_client.get(\"/response_with_space\")\n    content_length_for_response_with_space = response.headers.get(\n        \"Content-Length\"\n    )\n\n    _, response = app.test_client.get(\"/response_without_space\")\n    content_length_for_response_without_space = response.headers.get(\n        \"Content-Length\"\n    )\n\n    assert (\n        content_length_for_response_with_space\n        == content_length_for_response_without_space\n    )\n\n    assert content_length_for_response_with_space == \"43\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert content_length_for_response_with_space == content_length_for_response_without_space",
        "assert content_length_for_response_with_space == '43'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response.headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response.headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_response_content_length` function is designed to verify that the `Content-Length` header of HTTP responses is correctly calculated and consistent for two different endpoints that return the same JSON data. It ensures that the server correctly computes the length of the response body, which is crucial for clients to understand how much data to expect.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the `Content-Length` header for the responses from both `/response_with_space` and `/response_without_space` endpoints is equal. Additionally, it asserts that this length is exactly \"43\", which corresponds to the byte size of the JSON response being returned.\n\n**Code Being Tested and How It Works**:  \nThe code under test consists of two asynchronous route handlers defined within the `app` instance. Both handlers return a JSON response containing the same data structure: `{\"message\": \"Data\", \"details\": \"Some Details\"}`. The test uses the `app.test_client.get` method to simulate GET requests to these endpoints and retrieves the `Content-Length` from the response headers. The test then compares the lengths and checks for the expected value.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test leverages asynchronous route handlers and the Sanic framework's test client to handle requests and responses in a non-blocking manner.\n- **Header Verification**: It specifically checks HTTP headers, which is a common practice in web application testing to ensure that responses conform to HTTP standards.\n- **Assertions**: The use of assertions to validate both the equality of the `Content-Length` values and the specific expected length demonstrates a clear and effective way to verify the correctness of the implementation."
    },
    {
      "name": "test_response_content_length_with_different_data_types",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 150,
      "end_line_number": 160,
      "source_code": "def test_response_content_length_with_different_data_types(app):\n    @app.get(\"/\")\n    async def get_data_with_different_types(request: Request):\n        # Indentation issues in the Response is intentional. Please do not fix\n        return json(\n            {\"bool\": True, \"none\": None, \"string\": \"string\", \"number\": -1},\n            headers={\"CONTENT-TYPE\": \"application/json\"},\n        )\n\n    _, response = app.test_client.get(\"/\")\n    assert response.headers.get(\"Content-Length\") == \"55\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.headers.get('Content-Length') == '55'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response.headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the test `test_response_content_length_with_different_data_types` is to verify that the HTTP response generated by the Sanic application correctly calculates and returns the `Content-Length` header for a JSON response containing various data types.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `Content-Length` header in the response is equal to \"55\". This value represents the byte size of the JSON string returned by the endpoint, which includes a boolean, a null value, a string, and a number.\n\n**Code Being Tested and How It Works**:  \nThe code being tested includes an asynchronous route handler defined by `@app.get(\"/\")`, which returns a JSON response containing a dictionary with different data types. The `json` function is used to create the response, and the `test_client.get(\"/\")` method simulates a GET request to this endpoint. The test then asserts that the `Content-Length` header in the response matches the expected value of \"55\".\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of an asynchronous route handler, which is a common pattern in modern web frameworks like Sanic. It also utilizes the `test_client` to simulate HTTP requests, allowing for integration-style testing of the application\u2019s endpoints. The assertion checks the response headers directly, which is a typical technique for validating HTTP responses in unit tests."
    },
    {
      "name": "test_json_response",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 192,
      "end_line_number": 202,
      "source_code": "def test_json_response(json_app):\n    from sanic.response import json_dumps\n\n    request, response = json_app.test_client.get(\"/\")\n    assert response.status == 200\n    assert response.text == json_dumps(JSON_DATA)\n    assert response.json == JSON_DATA\n\n    request, response = json_app.test_client.get(\"/precondition\")\n    assert response.status == 412\n    assert response.json == JSON_DATA",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == json_dumps(JSON_DATA)",
        "assert response.json == JSON_DATA",
        "assert response.status == 412",
        "assert response.json == JSON_DATA"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_json_response` function is designed to verify the behavior of the Sanic application when handling JSON responses. It specifically checks that the application correctly returns JSON data for a successful request and handles a precondition failure appropriately.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies two main scenarios: \n1. When a GET request is made to the root endpoint (\"/\"), it checks that the response status is 200 (OK), the response text matches the expected JSON data, and the parsed JSON response is correct.\n2. When a GET request is made to the \"/precondition\" endpoint, it checks that the response status is 412 (Precondition Failed) and that the JSON response still contains the expected data.\n\n**Code Being Tested and How It Works**:  \nThe code being tested includes the `json_app` function, which sets up routes for the Sanic application. The root route (\"/\") returns a JSON response with a status of 200, while the \"/precondition\" route returns a JSON response with a status of 412. The test uses the `test_client` to simulate GET requests to these endpoints and checks the responses against expected values.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the response status, text, and JSON content. It utilizes the `json_dumps` function to ensure that the response text is correctly formatted as JSON. The test also leverages the `json_app` fixture to set up the application context, allowing for clean and isolated testing of the routes. This pattern of using fixtures is common in testing frameworks like pytest, promoting reusability and clarity in test setup."
    },
    {
      "name": "test_no_content",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 205,
      "end_line_number": 226,
      "source_code": "def test_no_content(json_app):\n    request, response = json_app.test_client.get(\"/no-content\")\n    assert response.status == 204\n    assert response.text == \"\"\n    assert \"Content-Length\" not in response.headers\n\n    request, response = json_app.test_client.get(\"/no-content/unmodified\")\n    assert response.status == 304\n    assert response.text == \"\"\n    assert \"Content-Length\" not in response.headers\n    assert \"Content-Type\" not in response.headers\n\n    request, response = json_app.test_client.get(\"/unmodified\")\n    assert response.status == 304\n    assert response.text == \"\"\n    assert \"Content-Length\" not in response.headers\n    assert \"Content-Type\" not in response.headers\n\n    request, response = json_app.test_client.delete(\"/\")\n    assert response.status == 204\n    assert response.text == \"\"\n    assert \"Content-Length\" not in response.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 204",
        "assert response.text == ''",
        "assert 'Content-Length' not in response.headers",
        "assert response.status == 304",
        "assert response.text == ''",
        "assert 'Content-Length' not in response.headers",
        "assert 'Content-Type' not in response.headers",
        "assert response.status == 304",
        "assert response.text == ''",
        "assert 'Content-Length' not in response.headers",
        "assert 'Content-Type' not in response.headers",
        "assert response.status == 204",
        "assert response.text == ''",
        "assert 'Content-Length' not in response.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "json_app.test_client.delete",
          "body": "def delete(self, request):\n    return text('I am delete method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_no_content` function is designed to verify the behavior of various HTTP endpoints in the Sanic application when they return no content or indicate that the content has not been modified. Specifically, it checks the correct HTTP status codes and the absence of certain headers in the responses.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks for the following behaviors:\n1. The `/no-content` endpoint should return a 204 No Content status with an empty response body and no `Content-Length` header.\n2. The `/no-content/unmodified` and `/unmodified` endpoints should return a 304 Not Modified status with an empty response body and no `Content-Length` or `Content-Type` headers.\n3. The DELETE request to the root endpoint should also return a 204 No Content status with similar response characteristics.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes several route handlers defined in the `json_app` function. Each handler is responsible for returning specific HTTP responses:\n- The `/no-content` handler returns a 204 status with no content.\n- The `/no-content/unmodified` and `/unmodified` handlers return a 304 status, indicating that the requested resource has not been modified.\n- The DELETE handler at the root returns a 204 status as well. The `text` function is used to create responses, ensuring that the body and headers are set correctly based on the specified status.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Direct Assertion**: It uses direct assertions to verify the status codes, response body, and headers, ensuring that the application behaves as expected under different scenarios.\n- **Separation of Concerns**: Each assertion is clearly separated by the request being tested, making it easy to identify which endpoint is being validated.\n- **Use of Fixtures**: The `json_app` fixture is used to set up the application context for testing, allowing for clean and isolated tests without side effects from other tests."
    },
    {
      "name": "test_chunked_streaming_adds_correct_headers",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 251,
      "end_line_number": 257,
      "source_code": "def test_chunked_streaming_adds_correct_headers(streaming_app):\n    request, response = streaming_app.test_client.get(\"/\")\n    assert response.headers[\"Transfer-Encoding\"] == \"chunked\"\n    assert response.headers[\"Content-Type\"] == \"text/csv\"\n    # Content-Length is not allowed by HTTP/1.1 specification\n    # when \"Transfer-Encoding: chunked\" is used\n    assert \"Content-Length\" not in response.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "streaming_app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.headers['Transfer-Encoding'] == 'chunked'",
        "assert response.headers['Content-Type'] == 'text/csv'",
        "assert 'Content-Length' not in response.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "streaming_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_chunked_streaming_adds_correct_headers` verifies that the HTTP response generated by the `streaming_app` correctly implements chunked transfer encoding and sets the appropriate headers when a GET request is made to the root endpoint (\"/\"). \n\n**Specific Functionality or Behavior Verified**:  \nThe test checks three specific behaviors of the HTTP response: \n1. It asserts that the `Transfer-Encoding` header is set to \"chunked\", indicating that the response body is sent in a series of chunks.\n2. It verifies that the `Content-Type` header is set to \"text/csv\", ensuring the response is correctly identified as CSV data.\n3. It confirms that the `Content-Length` header is absent, which is a requirement when using chunked transfer encoding as per HTTP/1.1 specifications.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `streaming_app` which is a Sanic application. The `test_client.get(\"/\")` method simulates an HTTP GET request to the root endpoint. The response is expected to be a stream of data, and the headers are set based on the response configuration in the application. The relevant code that handles the response is likely part of the Sanic framework, which manages HTTP requests and responses, including the handling of streaming responses.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs direct assertions to validate the response headers, which is a common pattern in unit testing. It uses the `assert` statement to check for expected values, ensuring that the application behaves as intended. The test also implicitly relies on the setup of the `streaming_app` to provide a controlled environment for testing, which is a typical practice in unit tests to isolate the functionality being tested. Additionally, the test is structured to be clear and concise, focusing on specific aspects of the response rather than broader application behavior."
    },
    {
      "name": "test_chunked_streaming_returns_correct_content",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 260,
      "end_line_number": 262,
      "source_code": "def test_chunked_streaming_returns_correct_content(streaming_app):\n    request, response = streaming_app.test_client.get(\"/\")\n    assert response.text == \"foo,bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "streaming_app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'foo,bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "streaming_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_chunked_streaming_returns_correct_content` aims to verify that the streaming response from the Sanic application correctly returns the expected content when accessed via a GET request.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the response text from the root endpoint (\"/\") matches the string \"foo,bar\". It ensures that the application correctly handles streaming responses and that the content is accurately delivered to the client.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves a Sanic application that defines a route (\"/\") which returns a `ResponseStream`. The `ResponseStream` is constructed using an asynchronous function (`sample_streaming_fn`) that writes \"foo\" to the response. However, the test seems to expect a different output (\"foo,bar\"), indicating a potential mismatch between the expected and actual behavior of the application. The `streaming_app.test_client.get(\"/\")` method simulates a GET request to the application, and the response is then checked for the expected content.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the response content, which is a common practice in unit testing. It also utilizes the Sanic test client to simulate HTTP requests, allowing for the testing of asynchronous behavior in a controlled environment. The test is structured to be straightforward, focusing on a single aspect of the application's behavior, which is a hallmark of effective unit tests."
    },
    {
      "name": "test_non_chunked_streaming_adds_correct_headers",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 271,
      "end_line_number": 276,
      "source_code": "def test_non_chunked_streaming_adds_correct_headers(non_chunked_streaming_app):\n    request, response = non_chunked_streaming_app.test_client.get(\"/\")\n\n    assert \"Transfer-Encoding\" not in response.headers\n    assert response.headers[\"Content-Type\"] == \"text/csv\"\n    assert response.headers[\"Content-Length\"] == \"7\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "non_chunked_streaming_app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'Transfer-Encoding' not in response.headers",
        "assert response.headers['Content-Type'] == 'text/csv'",
        "assert response.headers['Content-Length'] == '7'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "non_chunked_streaming_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_non_chunked_streaming_adds_correct_headers` aims to verify that when a non-chunked streaming response is returned from the `non_chunked_streaming_app`, the appropriate HTTP headers are set correctly. Specifically, it checks that the `Transfer-Encoding` header is absent, and that the `Content-Type` and `Content-Length` headers are set to expected values.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the application correctly handles non-chunked responses by confirming that the `Transfer-Encoding` header is not included in the response. It also verifies that the `Content-Type` is set to \"text/csv\" and that the `Content-Length` accurately reflects the size of the response body, which is expected to be 7 bytes.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `non_chunked_streaming_app.test_client.get(\"/\")` method, which simulates an HTTP GET request to the root endpoint of the application. The response is expected to be a simple text response (\"I am get method\") wrapped in a CSV format. The test checks the headers of the response object returned by this GET request to ensure they conform to the expected values.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs direct assertions to validate the response headers, which is a common pattern in unit testing. It uses the `assert` statement to check for the absence of the `Transfer-Encoding` header and to confirm the values of `Content-Type` and `Content-Length`. This straightforward approach allows for clear and immediate feedback on the correctness of the application's behavior regarding HTTP response headers. Additionally, the test is structured to be run in an isolated environment using a test client, which is a typical technique in testing web applications."
    },
    {
      "name": "test_non_chunked_streaming_returns_correct_content",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 289,
      "end_line_number": 293,
      "source_code": "def test_non_chunked_streaming_returns_correct_content(\n    non_chunked_streaming_app,\n):\n    request, response = non_chunked_streaming_app.test_client.get(\"/\")\n    assert response.text == \"foo,bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "non_chunked_streaming_app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'foo,bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "non_chunked_streaming_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_non_chunked_streaming_returns_correct_content` aims to verify that a non-chunked streaming response from the `non_chunked_streaming_app` returns the expected content when a GET request is made to the root endpoint (\"/\"). \n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the response text matches the string \"foo,bar\". It ensures that the application correctly handles non-chunked responses and that the content delivered to the client is accurate.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `non_chunked_streaming_app` which is expected to return a response when the `test_client.get(\"/\")` method is called. The relevant part of the application code is the route handler that is supposed to return a streaming response. However, the provided code snippet for the `get` method does not align with the expected output of \"foo,bar\", indicating that the actual implementation of the route handler may not be included in the provided snippets.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern, using `assert` to compare the actual response text with the expected value. It utilizes the `test_client` to simulate a GET request, which is a common technique in unit testing web applications to verify endpoint behavior without needing to run a full server. The test is also structured to be simple and direct, focusing solely on the output of the response, which is a best practice in unit testing to ensure clarity and maintainability."
    },
    {
      "name": "test_stream_response_with_cookies",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 296,
      "end_line_number": 312,
      "source_code": "def test_stream_response_with_cookies(app):\n    @app.route(\"/\")\n    async def test(request: Request):\n        headers = Header()\n        cookies = CookieJar(headers)\n        cookies[\"test\"] = \"modified\"\n        cookies[\"test\"] = \"pass\"\n        response = await request.respond(\n            content_type=\"text/csv\", headers=headers\n        )\n\n        await response.send(\"foo,\")\n        await asyncio.sleep(0.001)\n        await response.send(\"bar\")\n\n    request, response = app.test_client.get(\"/\")\n    assert response.cookies[\"test\"] == \"pass\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.cookies['test'] == 'pass'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "response.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_stream_response_with_cookies` test is to verify that cookies set during a streaming response are correctly modified and accessible in the response object. Specifically, it checks that the last value assigned to a cookie named \"test\" is the one that is returned in the response.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a cookie is modified multiple times within the same request context, the final value is the one that persists and is sent back to the client. In this case, it verifies that the cookie \"test\" has the value \"pass\" after the response is sent.\n\n**Code Being Tested and How It Works**:  \nThe test defines an asynchronous route handler that modifies the \"test\" cookie twice: first setting it to \"modified\" and then to \"pass\". The `request.respond` method is called to initiate the response, and the `response.send` method is used to send data in chunks. After the response is constructed, the test client makes a GET request to the route, and the test asserts that the cookie \"test\" in the response has the value \"pass\". This behavior is facilitated by the `CookieJar` class, which manages the cookies associated with the response.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Asynchronous Testing**: The use of `async` and `await` allows for testing asynchronous code, which is crucial in web frameworks like Sanic that handle requests concurrently.\n- **Fixture Usage**: The test relies on a fixture (`app`) that sets up the application context for testing, ensuring that the test runs in a controlled environment.\n- **Direct Assertion**: The test directly asserts the expected state of the response's cookies, which is a straightforward and effective way to validate the outcome of the code under test."
    },
    {
      "name": "test_stream_response_without_cookies",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 315,
      "end_line_number": 321,
      "source_code": "def test_stream_response_without_cookies(app):\n    @app.route(\"/\")\n    async def test(request: Request):\n        await sample_streaming_fn(request)\n\n    request, response = app.test_client.get(\"/\")\n    assert response.cookies == {}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.cookies == {}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_stream_response_without_cookies` test is designed to verify that a streaming response from the Sanic application does not include any cookies in the response when no cookies are set in the request.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `response.cookies` attribute is an empty dictionary (`{}`), confirming that no cookies are present in the response. This is important for ensuring that the application behaves correctly when handling requests that do not involve cookies.\n\n**Code Being Tested and How It Works**:  \nThe test defines an asynchronous route handler (`test`) that calls a streaming function (`sample_streaming_fn`) when a GET request is made to the root URL (\"/\"). The `app.test_client.get(\"/\")` method simulates a GET request to this route. The expected behavior is that the response generated by this route should not include any cookies, which is asserted by checking `response.cookies`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test utilizes asynchronous programming patterns, which is common in web frameworks like Sanic that support async/await syntax.\n- **Route Definition**: The test dynamically defines a route within the test function, allowing for isolated testing of specific behaviors without affecting the global application state.\n- **Assertion**: The test employs a straightforward assertion to validate the absence of cookies, which is a common practice in unit testing to ensure expected outcomes."
    },
    {
      "name": "test_file_response",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 358,
      "end_line_number": 372,
      "source_code": "def test_file_response(app: Sanic, file_name, static_file_directory, status):\n    @app.route(\"/files/<filename>\", methods=[\"GET\"])\n    def file_route(request, filename):\n        file_path = os.path.join(static_file_directory, filename)\n        file_path = os.path.abspath(unquote(file_path))\n        return file(\n            file_path,\n            status=status,\n            mime_type=guess_type(file_path)[0] or \"text/plain\",\n        )\n\n    request, response = app.test_client.get(f\"/files/{file_name}\")\n    assert response.status == status\n    assert response.body == get_file_content(static_file_directory, file_name)\n    assert \"Content-Disposition\" not in response.headers",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt', 'python.png'])",
        "pytest.mark.parametrize('status', [200, 401])"
      ],
      "arguments": [
        "app",
        "file_name",
        "static_file_directory",
        "status"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == status",
        "assert response.body == get_file_content(static_file_directory, file_name)",
        "assert 'Content-Disposition' not in response.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_file_response` function is designed to verify that the Sanic web application correctly serves static files from a specified directory. It checks that the response status matches the expected status and that the content of the response body matches the actual file content.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically verifies that when a GET request is made to the `/files/<filename>` endpoint, the application returns the correct HTTP status code, the correct file content, and ensures that the `Content-Disposition` header is not present in the response. This is crucial for ensuring that files are served correctly without unintended download prompts.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a route handler defined within the test that constructs the file path using the provided `static_file_directory` and the requested filename. It uses the `file` function to return the file content with the specified status and MIME type. The `get_file_content` function reads the actual file content from the filesystem, which is then compared against the response body to ensure they match.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of parameterization via `pytest.mark.parametrize`, allowing it to run multiple scenarios with different filenames and expected statuses. This enhances test coverage and ensures that various file types and conditions are validated without duplicating code. Additionally, assertions are used to validate the response's status, body, and headers, which is a common practice in unit testing to ensure that the application behaves as expected."
    },
    {
      "name": "test_file_response_custom_filename",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 383,
      "end_line_number": 398,
      "source_code": "def test_file_response_custom_filename(\n    app: Sanic, source, dest, static_file_directory\n):\n    @app.route(\"/files/<filename>\", methods=[\"GET\"])\n    def file_route(request, filename):\n        file_path = os.path.join(static_file_directory, filename)\n        file_path = os.path.abspath(unquote(file_path))\n        return file(file_path, filename=dest)\n\n    request, response = app.test_client.get(f\"/files/{source}\")\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, source)\n    assert (\n        response.headers[\"Content-Disposition\"]\n        == f'attachment; filename=\"{dest}\"'\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('source,dest', [('test.file', 'my_file.txt'), ('decode me.txt', 'readme.md'), ('python.png', 'logo.png')])"
      ],
      "arguments": [
        "app",
        "source",
        "dest",
        "static_file_directory"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, source)",
        "assert response.headers['Content-Disposition'] == f'attachment; filename=\"{dest}\"'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_file_response_custom_filename` test verifies that the Sanic application correctly serves files with a custom filename in the `Content-Disposition` header when a file is requested via a specific route.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a file is requested, the response status is 200 (OK), the response body matches the content of the requested file, and the `Content-Disposition` header is set to indicate that the file should be downloaded with a specified filename.\n\n**Code Being Tested and How It Works**:  \nThe code under test defines a route `/files/<filename>` that constructs the file path from a static directory and serves the file using the `file` function. The `file` function is expected to return the file content along with the specified filename in the `Content-Disposition` header. The test simulates a GET request to this route and asserts the correctness of the response.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses `pytest.mark.parametrize` to run the same test logic with different pairs of `source` and `dest` values, allowing for multiple scenarios to be tested efficiently.\n- **Assertions**: The test employs assertions to validate the response status, body content, and headers, ensuring that the application behaves as expected under various conditions.\n- **Route Definition within the Test**: The route is defined within the test function, which allows for isolated testing of the specific behavior without affecting other tests or routes."
    },
    {
      "name": "test_file_head_response",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 402,
      "end_line_number": 429,
      "source_code": "def test_file_head_response(app: Sanic, file_name, static_file_directory):\n    @app.route(\"/files/<filename>\", methods=[\"GET\", \"HEAD\"])\n    async def file_route(request, filename):\n        file_path = os.path.join(static_file_directory, filename)\n        file_path = os.path.abspath(unquote(file_path))\n        stats = await async_os.stat(file_path)\n        headers = {}\n        headers[\"Accept-Ranges\"] = \"bytes\"\n        headers[\"Content-Length\"] = str(stats.st_size)\n        if request.method == \"HEAD\":\n            return HTTPResponse(\n                headers=headers,\n                content_type=guess_type(file_path)[0] or \"text/plain\",\n            )\n        else:\n            return file(\n                file_path,\n                headers=headers,\n                mime_type=guess_type(file_path)[0] or \"text/plain\",\n            )\n\n    request, response = app.test_client.head(f\"/files/{file_name}\")\n    assert response.status == 200\n    assert \"Accept-Ranges\" in response.headers\n    assert \"Content-Length\" in response.headers\n    assert int(response.headers[\"Content-Length\"]) == len(\n        get_file_content(static_file_directory, file_name)\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt'])"
      ],
      "arguments": [
        "app",
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert 'Accept-Ranges' in response.headers",
        "assert 'Content-Length' in response.headers",
        "assert int(response.headers['Content-Length']) == len(get_file_content(static_file_directory, file_name))"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.head",
          "body": "def head(self, request):\n    return text('', headers={'method': 'HEAD'})"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_file_head_response` unit test is designed to verify the correct behavior of the Sanic web framework's file serving functionality, specifically for HTTP HEAD requests. It ensures that the server responds appropriately with the correct headers and status code when a HEAD request is made for a static file.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that:\n1. The response status for a HEAD request is 200 (OK).\n2. The response headers include \"Accept-Ranges\" and \"Content-Length\".\n3. The \"Content-Length\" header accurately reflects the size of the requested file.\n\n**Code Being Tested and How It Works**:  \nThe code under test defines a route (`/files/<filename>`) that handles both GET and HEAD requests. When a HEAD request is received, the server:\n- Constructs the file path from the static file directory and the filename.\n- Uses `async_os.stat` to retrieve file statistics, including its size.\n- Sets the \"Accept-Ranges\" header to indicate that the server supports byte-range requests.\n- Returns an `HTTPResponse` with the appropriate headers and content type, but without the file content itself, as is standard for HEAD requests.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses `pytest.mark.parametrize` to run the test with multiple filenames, ensuring that the functionality is validated across different file types.\n- **Assertions**: The test employs assertions to validate the response status and headers, ensuring that the server behaves as expected.\n- **Asynchronous Testing**: The test leverages asynchronous programming patterns, which is essential for testing web applications that handle I/O-bound operations, such as file access."
    },
    {
      "name": "test_file_stream_response",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 435,
      "end_line_number": 449,
      "source_code": "def test_file_stream_response(app: Sanic, file_name, static_file_directory):\n    @app.route(\"/files/<filename>\", methods=[\"GET\"])\n    def file_route(request, filename):\n        file_path = os.path.join(static_file_directory, filename)\n        file_path = os.path.abspath(unquote(file_path))\n        return file_stream(\n            file_path,\n            chunk_size=32,\n            mime_type=guess_type(file_path)[0] or \"text/plain\",\n        )\n\n    request, response = app.test_client.get(f\"/files/{file_name}\")\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, file_name)\n    assert \"Content-Disposition\" not in response.headers",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt', 'python.png'])"
      ],
      "arguments": [
        "app",
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, file_name)",
        "assert 'Content-Disposition' not in response.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_file_stream_response` function is designed to verify that the Sanic application correctly serves files from a specified directory when a GET request is made to the `/files/<filename>` endpoint. It ensures that the response status is 200 (OK) and that the content of the response matches the expected file content.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that:\n1. The server responds with a 200 status code when a valid file is requested.\n2. The body of the response contains the exact content of the requested file.\n3. The `Content-Disposition` header is not present in the response, indicating that the file is served inline rather than as an attachment.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes:\n- The route handler defined within the test, which constructs the file path using the provided `static_file_directory` and the requested filename. It then calls `file_stream` to serve the file.\n- The `file_stream` function is expected to handle the streaming of the file content, with a specified chunk size and MIME type determined by `guess_type`.\n- The `get_file_content` function reads the content of the file from the filesystem to provide a reference for comparison in the assertions.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test is likely part of a parameterized test suite, allowing it to run multiple times with different `file_name` inputs, ensuring coverage for various file scenarios.\n- **Assertions**: The test employs assertions to validate the response status, body content, and absence of specific headers, which are critical for confirming the expected behavior of the file-serving functionality.\n- **Route Definition within the Test**: The route is defined within the test function, allowing for isolated testing of the specific endpoint without affecting the global application state. This encapsulation is useful for unit testing in web frameworks."
    },
    {
      "name": "test_file_stream_response_custom_filename",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 460,
      "end_line_number": 475,
      "source_code": "def test_file_stream_response_custom_filename(\n    app: Sanic, source, dest, static_file_directory\n):\n    @app.route(\"/files/<filename>\", methods=[\"GET\"])\n    def file_route(request, filename):\n        file_path = os.path.join(static_file_directory, filename)\n        file_path = os.path.abspath(unquote(file_path))\n        return file_stream(file_path, chunk_size=32, filename=dest)\n\n    request, response = app.test_client.get(f\"/files/{source}\")\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, source)\n    assert (\n        response.headers[\"Content-Disposition\"]\n        == f'attachment; filename=\"{dest}\"'\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('source,dest', [('test.file', 'my_file.txt'), ('decode me.txt', 'readme.md'), ('python.png', 'logo.png')])"
      ],
      "arguments": [
        "app",
        "source",
        "dest",
        "static_file_directory"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, source)",
        "assert response.headers['Content-Disposition'] == f'attachment; filename=\"{dest}\"'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_file_stream_response_custom_filename` test verifies that the Sanic application correctly serves files with a custom filename in the `Content-Disposition` header when accessed via a specific route. This ensures that clients downloading files receive them with the intended name rather than the original filename.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks three main aspects: \n1. The HTTP response status is 200, indicating a successful request.\n2. The response body matches the content of the requested file, ensuring the correct file is served.\n3. The `Content-Disposition` header is set to `attachment; filename=\"{dest}\"`, confirming that the file will be downloaded with the specified custom filename.\n\n**Code Being Tested and How It Works**:  \nThe code under test defines a route `/files/<filename>` that constructs the file path from a static directory and serves the file using the `file_stream` function. The `file_stream` function is called with the absolute path of the file, a chunk size, and a custom filename (`dest`). The test simulates a GET request to this route and checks the response against expected values.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses `pytest.mark.parametrize` to run the same test logic with multiple sets of input values (`source` and `dest`), allowing for efficient testing of different scenarios without duplicating code.\n- **Assertions**: The test employs assertions to validate the response status, body content, and headers, ensuring that the application behaves as expected under the defined conditions.\n- **Route Definition within the Test**: The route is defined within the test function, allowing for isolated testing of the specific behavior without affecting other tests or routes in the application."
    },
    {
      "name": "test_file_stream_head_response",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 479,
      "end_line_number": 515,
      "source_code": "def test_file_stream_head_response(\n    app: Sanic, file_name, static_file_directory\n):\n    @app.route(\"/files/<filename>\", methods=[\"GET\", \"HEAD\"])\n    async def file_route(request, filename):\n        file_path = os.path.join(static_file_directory, filename)\n        file_path = os.path.abspath(unquote(file_path))\n        headers = {}\n        headers[\"Accept-Ranges\"] = \"bytes\"\n        if request.method == \"HEAD\":\n            # Return a normal HTTPResponse, not a\n            # StreamingHTTPResponse for a HEAD request\n            stats = await async_os.stat(file_path)\n            headers[\"Content-Length\"] = str(stats.st_size)\n            return HTTPResponse(\n                headers=headers,\n                content_type=guess_type(file_path)[0] or \"text/plain\",\n            )\n        else:\n            return file_stream(\n                file_path,\n                chunk_size=32,\n                headers=headers,\n                mime_type=guess_type(file_path)[0] or \"text/plain\",\n            )\n\n    request, response = app.test_client.head(f\"/files/{file_name}\")\n    assert response.status == 200\n    # A HEAD request should never be streamed/chunked.\n    if \"Transfer-Encoding\" in response.headers:\n        assert response.headers[\"Transfer-Encoding\"] != \"chunked\"\n    assert \"Accept-Ranges\" in response.headers\n    # A HEAD request should get the Content-Length too\n    assert \"Content-Length\" in response.headers\n    assert int(response.headers[\"Content-Length\"]) == len(\n        get_file_content(static_file_directory, file_name)\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt'])"
      ],
      "arguments": [
        "app",
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert 'Accept-Ranges' in response.headers",
        "assert 'Content-Length' in response.headers",
        "assert int(response.headers['Content-Length']) == len(get_file_content(static_file_directory, file_name))",
        "assert response.headers['Transfer-Encoding'] != 'chunked'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.head",
          "body": "def head(self, request):\n    return text('', headers={'method': 'HEAD'})"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_file_stream_head_response` test is to verify that the Sanic application correctly handles HTTP HEAD requests for file resources. It ensures that the server responds with the appropriate headers, including `Content-Length` and `Accept-Ranges`, without sending the actual file content.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that:\n1. A HEAD request to the `/files/<filename>` endpoint returns a 200 OK status.\n2. The response includes the `Accept-Ranges` header, indicating that the server supports range requests.\n3. The `Content-Length` header accurately reflects the size of the requested file.\n4. The response does not use chunked transfer encoding, which is not appropriate for HEAD requests.\n\n**Code Being Tested and How It Works**:  \nThe code under test defines a route in a Sanic application that handles both GET and HEAD requests for files. When a HEAD request is received, it:\n- Constructs the file path and retrieves its statistics using `async_os.stat`.\n- Sets the `Content-Length` header based on the file size.\n- Returns an `HTTPResponse` with the headers and a content type derived from the file's extension, but without the file content itself.\n\nThe test simulates a HEAD request using `app.test_client.head` and checks the response against the expected conditions.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test is designed to be run with multiple file names, allowing for comprehensive coverage of different scenarios without duplicating code.\n- **Assertions**: The test employs multiple assertions to validate the response's status and headers, ensuring that all expected behaviors are confirmed.\n- **Asynchronous Testing**: The test leverages Sanic's asynchronous capabilities, which is essential for testing web applications that handle requests asynchronously."
    },
    {
      "name": "test_file_stream_response_range",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 524,
      "end_line_number": 548,
      "source_code": "def test_file_stream_response_range(\n    app: Sanic, file_name, static_file_directory, size, start, end\n):\n    Range = namedtuple(\"Range\", [\"size\", \"start\", \"end\", \"total\"])\n    total = len(get_file_content(static_file_directory, file_name))\n    range = Range(size=size, start=start, end=end, total=total)\n\n    @app.route(\"/files/<filename>\", methods=[\"GET\"])\n    def file_route(request, filename):\n        file_path = os.path.join(static_file_directory, filename)\n        file_path = os.path.abspath(unquote(file_path))\n        return file_stream(\n            file_path,\n            chunk_size=32,\n            mime_type=guess_type(file_path)[0] or \"text/plain\",\n            _range=range,\n        )\n\n    request, response = app.test_client.get(f\"/files/{file_name}\")\n    assert response.status == 206\n    assert \"Content-Range\" in response.headers\n    assert (\n        response.headers[\"Content-Range\"]\n        == f\"bytes {range.start}-{range.end}/{range.total}\"\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt', 'python.png'])",
        "pytest.mark.parametrize('size,start,end', [(1024, 0, 1024), (4096, 1024, 8192)])"
      ],
      "arguments": [
        "app",
        "file_name",
        "static_file_directory",
        "size",
        "start",
        "end"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 206",
        "assert 'Content-Range' in response.headers",
        "assert response.headers['Content-Range'] == f'bytes {range.start}-{range.end}/{range.total}'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_file_stream_response_range` test is to verify that the Sanic application correctly handles HTTP range requests for file streaming. Specifically, it checks that the server responds with the appropriate status code and headers when a partial content request is made.\n\n**Specific Functionality or Behavior Verified**:  \nThis test verifies that when a valid range is requested for a file, the server responds with a `206 Partial Content` status. It also checks that the `Content-Range` header is present in the response and that it correctly reflects the requested byte range and the total size of the file.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `file_route` function, which is defined within the test. This function constructs the file path and calls the `file_stream` function, passing the file path, chunk size, MIME type, and a `Range` object that encapsulates the requested byte range. The `get_file_content` function is used to determine the total size of the file, which is essential for constructing the `Content-Range` header. The test then simulates a GET request to the `/files/<filename>` endpoint and asserts the response status and headers.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Namedtuples**: The `Range` namedtuple is used to encapsulate the range information, providing a clear structure for the data being passed around.\n- **Parameterized Testing**: Although not explicitly shown in this test, the surrounding tests utilize `pytest.mark.parametrize`, indicating a pattern of testing multiple scenarios with different inputs.\n- **Mocking HTTP Requests**: The use of `app.test_client.get` simulates HTTP requests to the application, allowing for testing of the route handlers without needing to run a live server.\n- **Assertions**: The test uses assertions to validate the response status and headers, ensuring that the application behaves as expected under the specified conditions."
    },
    {
      "name": "test_raw_response",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 551,
      "end_line_number": 558,
      "source_code": "def test_raw_response(app):\n    @app.get(\"/test\")\n    def handler(request: Request):\n        return raw(b\"raw_response\")\n\n    request, response = app.test_client.get(\"/test\")\n    assert response.content_type == DEFAULT_HTTP_CONTENT_TYPE\n    assert response.body == b\"raw_response\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.content_type == DEFAULT_HTTP_CONTENT_TYPE",
        "assert response.body == b'raw_response'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_raw_response` function is designed to verify that the `raw` function correctly returns a raw HTTP response with the expected content type and body when a GET request is made to the `/test` endpoint.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks two key aspects of the HTTP response: \n1. The `content_type` of the response should match the default content type defined by `DEFAULT_HTTP_CONTENT_TYPE`.\n2. The body of the response should exactly match the raw byte string `b\"raw_response\"`.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a route handler for the Sanic application that responds to GET requests at the `/test` endpoint. The handler uses the `raw` function to return a response with the byte string `b\"raw_response\"`. The `raw` function constructs an `HTTPResponse` object without encoding the body, allowing for the direct transmission of binary data. The test then simulates a GET request to this endpoint using `app.test_client.get(\"/test\")`, capturing the request and response for assertions.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The test utilizes a fixture (`app`) to set up the Sanic application context, allowing for easy testing of routes and handlers.\n- **Direct Assertions**: The test employs direct assertions to validate the response's properties, ensuring that the expected values are returned.\n- **Endpoint Testing**: It tests the behavior of a specific endpoint in isolation, which is a common practice in unit testing to ensure that individual components function correctly."
    },
    {
      "name": "test_empty_response",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 561,
      "end_line_number": 568,
      "source_code": "def test_empty_response(app):\n    @app.get(\"/test\")\n    def handler(request: Request):\n        return empty()\n\n    request, response = app.test_client.get(\"/test\")\n    assert response.content_type is None\n    assert response.body == b\"\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.content_type is None",
        "assert response.body == b''"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_empty_response` function is designed to verify the behavior of a Sanic application when an endpoint returns an empty response. It specifically checks that the response has no content type and an empty body.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when the `/test` endpoint is accessed, the response does not contain any content type (i.e., `None`) and that the body of the response is an empty byte string (`b\"\"`). This is crucial for confirming that the application correctly handles cases where no data is returned.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route handler for the Sanic application that calls the `empty()` function, which is expected to return an empty response. The test then uses the `app.test_client.get()` method to simulate a GET request to the `/test` endpoint. The assertions check the properties of the response object, specifically `response.content_type` and `response.body`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The test uses a fixture (`app`) to set up the Sanic application context, allowing for easy testing of routes.\n- **Assertions**: It employs assertions to validate the expected outcomes of the response, ensuring that both the content type and body are as intended.\n- **Route Definition**: The test dynamically defines a route within the test function, showcasing a common pattern in testing web applications where routes are defined for the scope of the test."
    },
    {
      "name": "test_direct_response_stream",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 571,
      "end_line_number": 583,
      "source_code": "def test_direct_response_stream(app: Sanic):\n    @app.route(\"/\")\n    async def test(request: Request):\n        response = await request.respond(content_type=\"text/csv\")\n        await response.send(\"foo,\")\n        await response.send(\"bar\")\n        await response.eof()\n\n    _, response = app.test_client.get(\"/\")\n    assert response.text == \"foo,bar\"\n    assert response.headers[\"Transfer-Encoding\"] == \"chunked\"\n    assert response.headers[\"Content-Type\"] == \"text/csv\"\n    assert \"Content-Length\" not in response.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'foo,bar'",
        "assert response.headers['Transfer-Encoding'] == 'chunked'",
        "assert response.headers['Content-Type'] == 'text/csv'",
        "assert 'Content-Length' not in response.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "response.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_direct_response_stream` unit test is designed to verify the behavior of the Sanic web framework when handling direct streaming responses. It ensures that the server correctly streams data in chunks and sets the appropriate HTTP headers.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the response from the server contains the expected streamed content (\"foo,bar\") and that the HTTP headers indicate the response is chunked and of the correct content type (CSV). It also verifies that the `Content-Length` header is absent, which is typical for chunked responses.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route (`\"/\"`) that responds to HTTP requests by creating a streaming response with the content type set to \"text/csv\". The `respond` method is called to initiate the response, followed by multiple calls to `send` to stream the data in chunks. The `eof` method signals the end of the response. The test then makes a GET request to this route using `app.test_client.get(\"/\")` and checks the response's text and headers.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test uses asynchronous functions to handle the non-blocking nature of the Sanic framework, allowing for efficient streaming of responses.\n- **Assertions**: It employs assertions to validate the response's content and headers, ensuring that the server behaves as expected under the defined conditions.\n- **Route Definition within Test**: The route is defined within the test function, which is a common pattern in unit tests to isolate the test environment and ensure that the route is only available during the test execution."
    },
    {
      "name": "test_multiple_responses",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 601,
      "end_line_number": 698,
      "source_code": "def test_multiple_responses(\n    app: Sanic,\n    caplog: LogCaptureFixture,\n    message_in_records: Callable[[List[LogRecord], str], bool],\n):\n    @app.route(\"/1\")\n    async def handler1(request: Request):\n        response = await request.respond()\n        await response.send(\"foo\")\n        response = await request.respond()\n\n    @app.route(\"/2\")\n    async def handler2(request: Request):\n        response = await request.respond()\n        response = await request.respond()\n        await response.send(\"foo\")\n\n    @app.get(\"/3\")\n    async def handler3(request: Request):\n        response = await request.respond()\n        await response.send(\"foo,\")\n        response = await request.respond()\n        await response.send(\"bar\")\n\n    @app.get(\"/4\")\n    async def handler4(request: Request):\n        await request.respond(headers={\"one\": \"one\"})\n        return json({\"foo\": \"bar\"}, headers={\"one\": \"two\"})\n\n    @app.get(\"/5\")\n    async def handler5(request: Request):\n        response = await request.respond(headers={\"one\": \"one\"})\n        await response.send(\"foo\")\n        return json({\"foo\": \"bar\"}, headers={\"one\": \"two\"})\n\n    @app.get(\"/6\")\n    async def handler6(request: Request):\n        response = await request.respond(headers={\"one\": \"one\"})\n        await response.send(\"foo, \")\n        json_response = json({\"foo\": \"bar\"}, headers={\"one\": \"two\"})\n        await response.send(\"bar\")\n        return json_response\n\n    error_msg0 = \"Second respond call is not allowed.\"\n\n    error_msg1 = (\n        \"The error response will not be sent to the client for the following \"\n        'exception:\"Second respond call is not allowed.\". A previous '\n        \"response has at least partially been sent.\"\n    )\n\n    error_msg2 = (\n        \"The response object returned by the route handler \"\n        \"will not be sent to client. The request has already \"\n        \"been responded to.\"\n    )\n\n    with caplog.at_level(ERROR):\n        _, response = app.test_client.get(\"/1\")\n        assert response.status == 200\n        assert message_in_records(caplog.records, error_msg0)\n        assert message_in_records(caplog.records, error_msg1)\n\n    with caplog.at_level(ERROR):\n        _, response = app.test_client.get(\"/2\")\n        assert response.status == 500\n        assert \"500 \u2014 Internal Server Error\" in response.text\n\n    with caplog.at_level(ERROR):\n        _, response = app.test_client.get(\"/3\")\n        assert response.status == 200\n        assert \"foo,\" in response.text\n        assert message_in_records(caplog.records, error_msg0)\n        assert message_in_records(caplog.records, error_msg1)\n\n    with caplog.at_level(ERROR):\n        _, response = app.test_client.get(\"/4\")\n        assert response.status == 200\n        assert \"foo\" not in response.text\n        assert \"one\" in response.headers\n        assert response.headers[\"one\"] == \"one\"\n\n        assert message_in_records(caplog.records, error_msg2)\n\n    with caplog.at_level(ERROR):\n        _, response = app.test_client.get(\"/5\")\n        assert response.status == 200\n        assert \"foo\" in response.text\n        assert \"one\" in response.headers\n        assert response.headers[\"one\"] == \"one\"\n        assert message_in_records(caplog.records, error_msg2)\n\n    with caplog.at_level(ERROR):\n        _, response = app.test_client.get(\"/6\")\n        assert \"foo, bar\" in response.text\n        assert \"one\" in response.headers\n        assert response.headers[\"one\"] == \"one\"\n        assert message_in_records(caplog.records, error_msg2)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "caplog",
        "message_in_records"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert message_in_records(caplog.records, error_msg0)",
        "assert message_in_records(caplog.records, error_msg1)",
        "assert response.status == 500",
        "assert '500 \u2014 Internal Server Error' in response.text",
        "assert response.status == 200",
        "assert 'foo,' in response.text",
        "assert message_in_records(caplog.records, error_msg0)",
        "assert message_in_records(caplog.records, error_msg1)",
        "assert response.status == 200",
        "assert 'foo' not in response.text",
        "assert 'one' in response.headers",
        "assert response.headers['one'] == 'one'",
        "assert message_in_records(caplog.records, error_msg2)",
        "assert response.status == 200",
        "assert 'foo' in response.text",
        "assert 'one' in response.headers",
        "assert response.headers['one'] == 'one'",
        "assert message_in_records(caplog.records, error_msg2)",
        "assert 'foo, bar' in response.text",
        "assert 'one' in response.headers",
        "assert response.headers['one'] == 'one'",
        "assert message_in_records(caplog.records, error_msg2)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "message_in_records",
          "body": "@pytest.fixture(scope='function')\ndef message_in_records():\n\n    def msg_in_log(records: List[LogRecord], msg: str):\n        error_captured = False\n        for record in records:\n            if msg in record.message:\n                error_captured = True\n                break\n        return error_captured\n    return msg_in_log"
        },
        {
          "name": "message_in_records",
          "body": "@pytest.fixture(scope='function')\ndef message_in_records():\n\n    def msg_in_log(records: List[LogRecord], msg: str):\n        error_captured = False\n        for record in records:\n            if msg in record.message:\n                error_captured = True\n                break\n        return error_captured\n    return msg_in_log"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "message_in_records",
          "body": "@pytest.fixture(scope='function')\ndef message_in_records():\n\n    def msg_in_log(records: List[LogRecord], msg: str):\n        error_captured = False\n        for record in records:\n            if msg in record.message:\n                error_captured = True\n                break\n        return error_captured\n    return msg_in_log"
        },
        {
          "name": "message_in_records",
          "body": "@pytest.fixture(scope='function')\ndef message_in_records():\n\n    def msg_in_log(records: List[LogRecord], msg: str):\n        error_captured = False\n        for record in records:\n            if msg in record.message:\n                error_captured = True\n                break\n        return error_captured\n    return msg_in_log"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "message_in_records",
          "body": "@pytest.fixture(scope='function')\ndef message_in_records():\n\n    def msg_in_log(records: List[LogRecord], msg: str):\n        error_captured = False\n        for record in records:\n            if msg in record.message:\n                error_captured = True\n                break\n        return error_captured\n    return msg_in_log"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "message_in_records",
          "body": "@pytest.fixture(scope='function')\ndef message_in_records():\n\n    def msg_in_log(records: List[LogRecord], msg: str):\n        error_captured = False\n        for record in records:\n            if msg in record.message:\n                error_captured = True\n                break\n        return error_captured\n    return msg_in_log"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "message_in_records",
          "body": "@pytest.fixture(scope='function')\ndef message_in_records():\n\n    def msg_in_log(records: List[LogRecord], msg: str):\n        error_captured = False\n        for record in records:\n            if msg in record.message:\n                error_captured = True\n                break\n        return error_captured\n    return msg_in_log"
        },
        {
          "name": "response.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "response.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "response.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "response.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "response.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "response.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "response.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:\nThe `test_multiple_responses` function is designed to verify the behavior of Sanic route handlers when multiple response attempts are made for a single request. It ensures that the application correctly handles scenarios where a response is attempted more than once, which should result in errors being logged and appropriate HTTP status codes being returned.\n\n**Specific Functionality or Behavior Verified**:\nThe test checks that:\n1. An error is logged when a second response attempt is made (e.g., in handlers `/1`, `/2`, and `/3`).\n2. The correct HTTP status codes are returned for each route, particularly ensuring that a 500 Internal Server Error is returned when a second response is attempted.\n3. The response content and headers are correctly set and returned for routes that do not trigger errors (e.g., `/4`, `/5`, and `/6`).\n\n**Code Being Tested and How It Works**:\nThe test defines several asynchronous route handlers within a Sanic application. Each handler attempts to respond to a request multiple times, which is not allowed. The `request.respond()` method is called to initiate a response, and `response.send()` is used to send the actual content. The test then makes GET requests to these routes using `app.test_client.get()` and checks the responses and logs for expected behavior, including error messages and HTTP status codes.\n\n**Notable Testing Patterns or Techniques Used**:\n1. **Log Capture**: The test uses `caplog` to capture log messages at the ERROR level, allowing verification of specific error messages related to multiple response attempts.\n2. **Assertions**: Multiple assertions are employed to validate both the HTTP response status and the presence of specific log messages, ensuring comprehensive coverage of the expected outcomes.\n3. **Asynchronous Testing**: The use of async route handlers and the `await` keyword demonstrates the handling of asynchronous operations within the test, which is crucial for testing web frameworks like Sanic that are built on asynchronous principles."
    },
    {
      "name": "test_send_response_after_eof_should_fail",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 701,
      "end_line_number": 729,
      "source_code": "def test_send_response_after_eof_should_fail(\n    app: Sanic,\n    caplog: LogCaptureFixture,\n    message_in_records: Callable[[List[LogRecord], str], bool],\n):\n    @app.get(\"/\")\n    async def handler(request: Request):\n        response = await request.respond()\n        await response.send(\"foo, \")\n        await response.eof()\n        await response.send(\"bar\")\n\n    error_msg1 = (\n        \"The error response will not be sent to the client for the following \"\n        'exception:\"Response stream was ended, no more response '\n        'data is allowed to be sent.\". A previous '\n        \"response has at least partially been sent.\"\n    )\n\n    error_msg2 = (\n        \"Response stream was ended, no more response \"\n        \"data is allowed to be sent.\"\n    )\n\n    with caplog.at_level(ERROR):\n        _, response = app.test_client.get(\"/\")\n        assert \"foo, \" in response.text\n        assert message_in_records(caplog.records, error_msg1)\n        assert message_in_records(caplog.records, error_msg2)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "caplog",
        "message_in_records"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'foo, ' in response.text",
        "assert message_in_records(caplog.records, error_msg1)",
        "assert message_in_records(caplog.records, error_msg2)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "message_in_records",
          "body": "@pytest.fixture(scope='function')\ndef message_in_records():\n\n    def msg_in_log(records: List[LogRecord], msg: str):\n        error_captured = False\n        for record in records:\n            if msg in record.message:\n                error_captured = True\n                break\n        return error_captured\n    return msg_in_log"
        },
        {
          "name": "message_in_records",
          "body": "@pytest.fixture(scope='function')\ndef message_in_records():\n\n    def msg_in_log(records: List[LogRecord], msg: str):\n        error_captured = False\n        for record in records:\n            if msg in record.message:\n                error_captured = True\n                break\n        return error_captured\n    return msg_in_log"
        },
        {
          "name": "response.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "response.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_send_response_after_eof_should_fail` is designed to verify that attempting to send additional data after the end of a response stream (EOF) results in the appropriate error handling and logging behavior in a Sanic web application.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when a response is sent and then marked as complete (EOF), any subsequent attempts to send more data are correctly rejected. It also verifies that the expected error messages are logged, indicating that the response stream has already been closed.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route handler that sends a response with the text \"foo, \", then calls `eof()` to indicate that the response is complete, and finally attempts to send \"bar\". The Sanic framework should prevent this last send operation and log specific error messages. The test uses the `caplog` fixture to capture log messages at the ERROR level and checks that the expected error messages are present in the logs.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test is designed to work with asynchronous code, utilizing `async def` for the route handler and the test function itself.\n- **Log Capture**: The `caplog` fixture from pytest is used to capture log messages, allowing the test to assert that specific error messages were logged during the execution.\n- **Assertions**: The test includes assertions to verify both the content of the response and the presence of error messages in the logs, ensuring comprehensive validation of the behavior under test."
    },
    {
      "name": "test_file_response_headers",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 768,
      "end_line_number": 856,
      "source_code": "def test_file_response_headers(\n    app: Sanic, file_name: str, static_file_directory: str\n):\n    test_last_modified = datetime.now()\n    test_max_age = 10\n    test_expires = test_last_modified.timestamp() + test_max_age\n\n    @app.route(\"/files/cached/<filename>\", methods=[\"GET\"])\n    def file_route_cache(request: Request, filename: str):\n        file_path = (\n            Path(static_file_directory) / unquote(filename)\n        ).absolute()\n        return file(\n            file_path, max_age=test_max_age, last_modified=test_last_modified\n        )\n\n    @app.route(\n        \"/files/cached_default_last_modified/<filename>\", methods=[\"GET\"]\n    )\n    def file_route_cache_default_last_modified(\n        request: Request, filename: str\n    ):\n        file_path = (\n            Path(static_file_directory) / unquote(filename)\n        ).absolute()\n        return file(file_path, max_age=test_max_age)\n\n    @app.route(\"/files/no_cache/<filename>\", methods=[\"GET\"])\n    def file_route_no_cache(request: Request, filename: str):\n        file_path = (\n            Path(static_file_directory) / unquote(filename)\n        ).absolute()\n        return file(file_path)\n\n    @app.route(\"/files/no_store/<filename>\", methods=[\"GET\"])\n    def file_route_no_store(request: Request, filename: str):\n        file_path = (\n            Path(static_file_directory) / unquote(filename)\n        ).absolute()\n        return file(file_path, no_store=True)\n\n    _, response = app.test_client.get(f\"/files/cached/{file_name}\")\n    assert response.body == get_file_content(static_file_directory, file_name)\n    headers = response.headers\n    assert (\n        \"cache-control\" in headers\n        and f\"max-age={test_max_age}\" in headers.get(\"cache-control\")\n        and \"public\" in headers.get(\"cache-control\")\n    )\n    assert (\n        \"expires\" in headers\n        and headers.get(\"expires\")[:-6]\n        == formatdate(test_expires, usegmt=True)[:-6]\n        # [:-6] to allow at most 1 min difference\n        # It's minimal for cases like:\n        # Thu, 26 May 2022 05:36:59 GMT\n        # AND\n        # Thu, 26 May 2022 05:37:00 GMT\n    )\n    assert response.status == 200\n    assert \"last-modified\" in headers and headers.get(\n        \"last-modified\"\n    ) == formatdate(test_last_modified.timestamp(), usegmt=True)\n\n    _, response = app.test_client.get(\n        f\"/files/cached_default_last_modified/{file_name}\"\n    )\n    file_last_modified = get_file_last_modified_timestamp(\n        static_file_directory, file_name\n    )\n    headers = response.headers\n    assert \"last-modified\" in headers and headers.get(\n        \"last-modified\"\n    ) == formatdate(file_last_modified, usegmt=True)\n    assert response.status == 200\n\n    _, response = app.test_client.get(f\"/files/no_cache/{file_name}\")\n    headers = response.headers\n    assert \"cache-control\" in headers and \"no-cache\" == headers.get(\n        \"cache-control\"\n    )\n    assert response.status == 200\n\n    _, response = app.test_client.get(f\"/files/no_store/{file_name}\")\n    headers = response.headers\n    assert \"cache-control\" in headers and \"no-store\" == headers.get(\n        \"cache-control\"\n    )\n    assert response.status == 200",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt', 'python.png'])"
      ],
      "arguments": [
        "app",
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.body == get_file_content(static_file_directory, file_name)",
        "assert 'cache-control' in headers and f'max-age={test_max_age}' in headers.get('cache-control') and ('public' in headers.get('cache-control'))",
        "assert 'expires' in headers and headers.get('expires')[:-6] == formatdate(test_expires, usegmt=True)[:-6]",
        "assert response.status == 200",
        "assert 'last-modified' in headers and headers.get('last-modified') == formatdate(test_last_modified.timestamp(), usegmt=True)",
        "assert 'last-modified' in headers and headers.get('last-modified') == formatdate(file_last_modified, usegmt=True)",
        "assert response.status == 200",
        "assert 'cache-control' in headers and 'no-cache' == headers.get('cache-control')",
        "assert response.status == 200",
        "assert 'cache-control' in headers and 'no-store' == headers.get('cache-control')",
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_last_modified_timestamp",
          "body": "def get_file_last_modified_timestamp(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    return (static_file_directory / file_name).stat().st_mtime"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        },
        {
          "name": "headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_file_response_headers` test is to verify that the HTTP response headers for file requests are correctly set according to caching and file modification rules. It ensures that the server responds with appropriate cache control, expiration, and last-modified headers when serving static files.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks multiple routes for serving files with different caching behaviors:\n1. **Cached Files**: Validates that the response includes the correct `Cache-Control`, `Expires`, and `Last-Modified` headers.\n2. **Default Last Modified**: Ensures that the last modified timestamp is correctly set when not explicitly provided.\n3. **No Cache**: Confirms that the `Cache-Control` header is set to `no-cache`.\n4. **No Store**: Verifies that the `Cache-Control` header is set to `no-store`.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with a Sanic application that defines several routes for serving files:\n- The `file_route_cache` serves files with caching headers.\n- The `file_route_cache_default_last_modified` serves files with a default last modified timestamp.\n- The `file_route_no_cache` and `file_route_no_store` serve files with specific cache control settings.\n\nThe test uses the `app.test_client.get` method to simulate GET requests to these routes, checking the response body and headers against expected values. It also calculates expected values for headers based on the current time and the specified max age.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test is designed to run with different file names, allowing for a broader coverage of scenarios without duplicating code.\n- **Assertions**: Multiple assertions are used to validate the correctness of the response body and headers, ensuring that all relevant aspects of the response are checked.\n- **Dynamic Header Calculation**: The test dynamically calculates expected header values (like `Expires` and `Last-Modified`) based on the current time, which helps in accommodating slight timing discrepancies during tests."
    },
    {
      "name": "test_file_validate",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 859,
      "end_line_number": 900,
      "source_code": "def test_file_validate(app: Sanic, static_file_directory: str):\n    file_name = \"test_validate.txt\"\n    static_file_directory = Path(static_file_directory)\n    file_path = static_file_directory / file_name\n    file_path = file_path.absolute()\n    test_max_age = 10\n\n    with open(file_path, \"w+\") as f:\n        f.write(\"foo\\n\")\n\n    @app.route(\"/validate\", methods=[\"GET\"])\n    def file_route_cache(request: Request):\n        return file(\n            file_path,\n            request_headers=request.headers,\n            max_age=test_max_age,\n            validate_when_requested=True,\n        )\n\n    _, response = app.test_client.get(\"/validate\")\n    assert response.status == 200\n    assert response.body == b\"foo\\n\"\n    last_modified = response.headers[\"Last-Modified\"]\n\n    time.sleep(1)\n    with open(file_path, \"a\") as f:\n        f.write(\"bar\\n\")\n    _, response = app.test_client.get(\n        \"/validate\", headers={\"If-Modified-Since\": last_modified}\n    )\n\n    assert response.status == 200\n    assert response.body == b\"foo\\nbar\\n\"\n\n    last_modified = response.headers[\"Last-Modified\"]\n    _, response = app.test_client.get(\n        \"/validate\", headers={\"if-modified-since\": last_modified}\n    )\n    assert response.status == 304\n    assert response.body == b\"\"\n\n    file_path.unlink()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "static_file_directory"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == b'foo\\n'",
        "assert response.status == 200",
        "assert response.body == b'foo\\nbar\\n'",
        "assert response.status == 304",
        "assert response.body == b''"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_file_validate` function is designed to verify the behavior of a file-serving endpoint in a Sanic web application. Specifically, it tests the caching mechanism and the handling of the `If-Modified-Since` HTTP header to ensure that the server correctly serves the file content based on its modification status.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks three main scenarios:\n1. When the file is first requested, it should return a 200 status with the correct content.\n2. After appending new content to the file, a request with the `If-Modified-Since` header should still return the updated content (200 status).\n3. A subsequent request with the same `If-Modified-Since` header should return a 304 status, indicating that the content has not changed since the last request.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a route defined in the Sanic app that serves a file located at `file_path`. The `file` function is called with parameters that include the file path, request headers, and caching options. The test creates a temporary file, writes initial content, and then modifies it to simulate changes. The responses from the app's test client are asserted against expected outcomes to validate the correct behavior of the file-serving logic.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Setup and Teardown**: The test creates a temporary file for testing and ensures it is deleted at the end of the test to avoid side effects.\n- **Assertions**: Multiple assertions are used to verify the status codes and response bodies, ensuring that the application behaves as expected under different conditions.\n- **Simulating Time**: The test uses `time.sleep(1)` to create a delay, allowing the modification time of the file to change, which is crucial for testing the caching behavior.\n- **Parameterization**: The test is structured to allow for easy extension with different file names, demonstrating a flexible approach to testing various scenarios."
    },
    {
      "name": "test_file_validating_invalid_header",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 906,
      "end_line_number": 935,
      "source_code": "def test_file_validating_invalid_header(\n    app: Sanic, file_name: str, static_file_directory: str\n):\n    @app.route(\"/files/<filename>\", methods=[\"GET\"])\n    def file_route(request: Request, filename: str):\n        handler_file_path = (\n            Path(static_file_directory) / unquote(filename)\n        ).absolute()\n\n        return file(\n            handler_file_path,\n            request_headers=request.headers,\n            validate_when_requested=True,\n        )\n\n    _, response = app.test_client.get(f\"/files/{file_name}\")\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, file_name)\n\n    _, response = app.test_client.get(\n        f\"/files/{file_name}\", headers={\"if-modified-since\": \"invalid-value\"}\n    )\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, file_name)\n\n    _, response = app.test_client.get(\n        f\"/files/{file_name}\", headers={\"if-modified-since\": \"\"}\n    )\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, file_name)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt', 'python.png'])"
      ],
      "arguments": [
        "app",
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, file_name)",
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, file_name)",
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, file_name)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_file_validating_invalid_header` function is designed to verify the behavior of a file-serving endpoint in a Sanic web application when it receives invalid or empty `If-Modified-Since` headers. The test ensures that the server correctly handles these scenarios by returning the appropriate file content and HTTP status codes.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. A valid GET request to the file route returns a 200 status and the correct file content.\n2. A GET request with an invalid `If-Modified-Since` header still returns a 200 status and the correct file content.\n3. A GET request with an empty `If-Modified-Since` header also returns a 200 status and the correct file content.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a route defined in the Sanic application that serves files from a specified directory. The route uses the `file` function to return the file content, taking into account the request headers and a validation flag. The `get_file_content` function is used to read the actual content of the file from the filesystem, ensuring that the response matches the expected content.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test is set up to run with multiple file names, allowing for a broader coverage of scenarios without duplicating code.\n- **Assertions**: The test employs assertions to validate the response status and body, ensuring that the application behaves as expected under different conditions.\n- **Mocking**: While not explicitly shown in the test, the use of `app.test_client.get` simulates HTTP requests to the application, allowing for isolated testing of the route's behavior without needing a live server."
    },
    {
      "name": "test_file_validating_304_response_file_route",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 941,
      "end_line_number": 965,
      "source_code": "def test_file_validating_304_response_file_route(\n    app: Sanic, file_name: str, static_file_directory: str\n):\n    @app.route(\"/files/<filename>\", methods=[\"GET\"])\n    def file_route(request: Request, filename: str):\n        handler_file_path = (\n            Path(static_file_directory) / unquote(filename)\n        ).absolute()\n\n        return file(\n            handler_file_path,\n            request_headers=request.headers,\n            validate_when_requested=True,\n        )\n\n    _, response = app.test_client.get(f\"/files/{file_name}\")\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, file_name)\n\n    _, response = app.test_client.get(\n        f\"/files/{file_name}\",\n        headers={\"if-modified-since\": response.headers[\"Last-Modified\"]},\n    )\n    assert response.status == 304\n    assert response.body == b\"\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt', 'python.png'])"
      ],
      "arguments": [
        "app",
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, file_name)",
        "assert response.status == 304",
        "assert response.body == b''"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_file_validating_304_response_file_route` test is to verify that the file-serving route in a Sanic web application correctly handles HTTP GET requests and responds with the appropriate status codes, particularly focusing on the behavior of the server when a file has not been modified since the last request (HTTP 304 Not Modified).\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks two main behaviors: \n1. It ensures that a GET request for a file returns a 200 OK status and the correct file content when the file is requested for the first time.\n2. It verifies that a subsequent GET request with an `If-Modified-Since` header (set to the last modified time of the file) returns a 304 Not Modified status, indicating that the file has not changed since the last request.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a route handler defined within the test that serves files from a specified directory. The `file_route` function constructs the absolute path of the requested file and uses the `file` function to serve it, passing along any request headers and enabling validation of the file's modification status. The test then simulates two GET requests: the first retrieves the file and checks the response status and body, while the second checks for the 304 status when the file has not been modified.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs parameterized testing using `pytest.mark.parametrize`, allowing it to run multiple scenarios with different file names. It also utilizes assertions to validate the response status and body, ensuring that the application behaves as expected under different conditions. The use of `request.headers` to pass the `If-Modified-Since` header demonstrates a common pattern in testing HTTP interactions, simulating real-world client behavior."
    },
    {
      "name": "test_file_validating_304_response",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 971,
      "end_line_number": 990,
      "source_code": "def test_file_validating_304_response(\n    app: Sanic, file_name: str, static_file_directory: str\n):\n    app.static(\"static\", Path(static_file_directory) / file_name)\n\n    _, response = app.test_client.get(\"/static\")\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, file_name)\n    last_modified = parsedate_to_datetime(response.headers[\"Last-Modified\"])\n    last_modified += timedelta(seconds=1)\n    _, response = app.test_client.get(\n        \"/static\",\n        headers={\n            \"if-modified-since\": formatdate(\n                last_modified.timestamp(), usegmt=True\n            )\n        },\n    )\n    assert response.status == 304\n    assert response.body == b\"\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt', 'python.png'])"
      ],
      "arguments": [
        "app",
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, file_name)",
        "assert response.status == 304",
        "assert response.body == b''"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_file_validating_304_response` test is to verify the correct behavior of the Sanic application when handling static file requests, specifically ensuring that the server responds with a 304 Not Modified status when the file has not changed since the last request.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks two main behaviors: \n1. It confirms that a GET request for a static file returns a 200 OK status and the correct file content when the file is first requested.\n2. It verifies that a subsequent GET request with an `If-Modified-Since` header (indicating the last modified time of the file) returns a 304 Not Modified status if the file has not been modified since that time.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the Sanic application by setting up a static file route and making GET requests to it. The `app.static` method is used to serve the specified file from the static directory. The first request checks that the file is served correctly, while the second request uses the `If-Modified-Since` header to check if the file has been modified. The `get_file_content` function reads the file's content to ensure the response body matches the expected content.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterized Testing**: The test uses `pytest.mark.parametrize` to run the same test logic for multiple file names, ensuring that the functionality is validated across different file scenarios.\n- **Assertions**: The test employs assertions to validate the response status and body, ensuring that the application behaves as expected under different conditions.\n- **Date Handling**: The test manipulates the `Last-Modified` header to simulate the condition for the 304 response, demonstrating an understanding of HTTP caching mechanisms."
    },
    {
      "name": "test_stream_response_with_default_headers",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 993,
      "end_line_number": 1004,
      "source_code": "def test_stream_response_with_default_headers(app: Sanic):\n    async def sample_streaming_fn(response_):\n        await response_.write(\"foo\")\n\n    @app.route(\"/\")\n    async def test(request: Request):\n        return ResponseStream(sample_streaming_fn, content_type=\"text/csv\")\n\n    _, response = app.test_client.get(\"/\")\n    assert response.text == \"foo\"\n    assert response.headers[\"Transfer-Encoding\"] == \"chunked\"\n    assert response.headers[\"Content-Type\"] == \"text/csv\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'foo'",
        "assert response.headers['Transfer-Encoding'] == 'chunked'",
        "assert response.headers['Content-Type'] == 'text/csv'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_stream_response_with_default_headers` test is to verify that the Sanic application correctly streams a response with the expected default headers and content when a GET request is made to the root endpoint (\"/\"). \n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the response body contains the string \"foo\", that the `Transfer-Encoding` header is set to \"chunked\", and that the `Content-Type` header is set to \"text/csv\". These assertions ensure that the streaming functionality and header management of the Sanic application are working as intended.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes an asynchronous route handler defined within the Sanic application. The `sample_streaming_fn` function writes \"foo\" to the response stream. The route handler, `test`, returns a `ResponseStream` object that utilizes this streaming function. When the test client makes a GET request to the root endpoint, the application processes the request, invokes the streaming function, and constructs the response with the specified headers.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the following techniques:\n- **Asynchronous Testing**: The use of `async` functions allows for testing asynchronous behavior, which is crucial for web applications that handle I/O operations like streaming.\n- **Direct Assertions**: The test directly asserts the expected values of the response body and headers, ensuring that the application behaves as expected.\n- **Route Definition within Test**: The route is defined within the test function, allowing for isolated testing of specific functionality without affecting the global application state. This encapsulation is a common pattern in unit tests for web frameworks."
    },
    {
      "name": "test_sync",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 34,
      "end_line_number": 41,
      "source_code": "def test_sync(app):\n    @app.route(\"/\")\n    def handler(request):\n        return text(\"Hello\")\n\n    request, response = app.test_client.get(\"/\")\n\n    assert response.body == b\"Hello\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.body == b'Hello'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_sync` function is designed to verify that the Sanic application correctly handles a simple GET request to the root endpoint (\"/\") and returns the expected response body.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a GET request is made to the root URL, the response body matches the expected byte string `b\"Hello\"`. It ensures that the route handler is functioning as intended and that the response is correctly formatted.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the route handler defined within the `test_sync` function, which returns a text response \"Hello\" when the root endpoint is accessed. The line `request, response = app.test_client.get(\"/\")` simulates a GET request to this endpoint, and the assertion `assert response.body == b\"Hello\"` checks if the response body matches the expected output.\n\n**Notable Testing Patterns or Techniques Used**:  \nThis test employs a straightforward approach to unit testing by using the Sanic framework's built-in test client to simulate HTTP requests. It uses assertions to validate the response, which is a common pattern in unit tests. The test is structured to be self-contained, defining the route and making the request within the same function, which simplifies the testing of isolated functionality."
    },
    {
      "name": "test_ip",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 55,
      "end_line_number": 62,
      "source_code": "def test_ip(app):\n    @app.route(\"/\")\n    def handler(request):\n        return text(f\"{request.ip}\")\n\n    request, response = app.test_client.get(\"/\")\n\n    assert response.body == b\"127.0.0.1\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.body == b'127.0.0.1'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_ip` function is designed to verify that the Sanic application correctly returns the IP address of the incoming request. Specifically, it checks that the response body contains the expected IP address, which is hardcoded as `127.0.0.1`.\n\n**Specific Functionality or Behavior Verified**:  \nThis test confirms that the application\u2019s request handling mechanism accurately captures and returns the client's IP address. It ensures that the `request.ip` attribute is functioning as intended when a request is made to the root endpoint (`\"/\"`).\n\n**Code Being Tested and How It Works**:  \nThe test defines a route handler for the root path (`\"/\"`) that returns the IP address of the request using `text(f\"{request.ip}\")`. The test then simulates a GET request to this endpoint using `app.test_client.get(\"/\")`. The response is checked to ensure that the body matches the expected byte string `b\"127.0.0.1\"`, which represents the local loopback address.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Route Definition**: The test dynamically defines a route within the test function, which is a common pattern in testing web applications to isolate tests and avoid side effects.\n- **Client Simulation**: It uses the `app.test_client.get` method to simulate a client request, allowing for easy testing of the application's response without needing to run a server.\n- **Assertion**: The test employs a straightforward assertion to compare the actual response body with the expected value, ensuring that the functionality is working as intended."
    },
    {
      "name": "test_text",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 81,
      "end_line_number": 88,
      "source_code": "def test_text(app):\n    @app.route(\"/\")\n    async def handler(request):\n        return text(\"Hello\")\n\n    request, response = app.test_client.get(\"/\")\n\n    assert response.body == b\"Hello\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.body == b'Hello'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_text` function is designed to verify that the Sanic application correctly handles a GET request to the root endpoint (\"/\") and returns the expected text response.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a GET request is made to the root URL, the response body contains the string \"Hello\" in bytes format (`b\"Hello\"`). It ensures that the routing and response generation mechanisms of the Sanic application are functioning as intended.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the route handler defined within the `test_text` function. The handler is an asynchronous function that responds to incoming requests by returning a text response with the content \"Hello\". The line `request, response = app.test_client.get(\"/\")` simulates a GET request to the root endpoint, and the assertion `assert response.body == b\"Hello\"` checks if the response body matches the expected output.\n\n**Notable Testing Patterns or Techniques Used**:  \nThis test employs the use of a test client provided by the Sanic framework, which allows for simulating HTTP requests to the application. The use of assertions to compare the actual response with the expected output is a common pattern in unit testing, ensuring that the application behaves correctly under specified conditions. Additionally, the test is structured to be asynchronous, which is a key feature of the Sanic framework, allowing for non-blocking I/O operations."
    },
    {
      "name": "test_html",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 91,
      "end_line_number": 123,
      "source_code": "def test_html(app):\n    class Foo:\n        def __html__(self):\n            return \"<h1>Foo</h1>\"\n\n        def _repr_html_(self):\n            return \"<h1>Foo object repr</h1>\"\n\n    class Bar:\n        def _repr_html_(self):\n            return \"<h1>Bar object repr</h1>\"\n\n    @app.route(\"/\")\n    async def handler(request):\n        return html(\"<h1>Hello</h1>\")\n\n    @app.route(\"/foo\")\n    async def handler_foo(request):\n        return html(Foo())\n\n    @app.route(\"/bar\")\n    async def handler_bar(request):\n        return html(Bar())\n\n    request, response = app.test_client.get(\"/\")\n    assert response.content_type == \"text/html; charset=utf-8\"\n    assert response.body == b\"<h1>Hello</h1>\"\n\n    request, response = app.test_client.get(\"/foo\")\n    assert response.body == b\"<h1>Foo</h1>\"\n\n    request, response = app.test_client.get(\"/bar\")\n    assert response.body == b\"<h1>Bar object repr</h1>\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.content_type == 'text/html; charset=utf-8'",
        "assert response.body == b'<h1>Hello</h1>'",
        "assert response.body == b'<h1>Foo</h1>'",
        "assert response.body == b'<h1>Bar object repr</h1>'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_html` function is designed to verify the correct rendering of HTML responses in a Sanic web application. It ensures that the application can return HTML content for different routes, including both static HTML and HTML generated from custom objects.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. The root route (`/`) returns a simple HTML response with the content `<h1>Hello</h1>`.\n2. The `/foo` route returns HTML generated from an instance of the `Foo` class, which implements the `__html__` method, returning `<h1>Foo</h1>`.\n3. The `/bar` route returns HTML generated from an instance of the `Bar` class, which implements the `_repr_html_` method, returning `<h1>Bar object repr</h1>`.\n4. The content type of the response for the root route is correctly set to `text/html; charset=utf-8`.\n\n**Code Being Tested and How It Works**:  \nThe test defines two classes, `Foo` and `Bar`, each with methods that return HTML strings. It sets up three routes in the Sanic application:\n- The root route (`/`) returns a static HTML string.\n- The `/foo` route returns an instance of `Foo`, which Sanic uses to generate HTML via the `__html__` method.\n- The `/bar` route returns an instance of `Bar`, which generates HTML via the `_repr_html_` method.\n\nThe test uses the `app.test_client.get` method to simulate HTTP GET requests to these routes and asserts the expected HTML responses and content types.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Route Testing**: The test verifies multiple routes in a single function, ensuring that each route behaves as expected.\n- **Custom Object Rendering**: It demonstrates how custom objects can be rendered as HTML by implementing specific methods (`__html__` and `_repr_html_`).\n- **Assertions**: The test employs assertions to validate both the content type and the body of the responses, ensuring comprehensive coverage of the expected behavior.\n- **Asynchronous Testing**: The test is structured to work within an asynchronous framework, leveraging Sanic's capabilities to handle async routes and responses."
    },
    {
      "name": "test_headers",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 137,
      "end_line_number": 145,
      "source_code": "def test_headers(app):\n    @app.route(\"/\")\n    async def handler(request):\n        headers = {\"spam\": \"great\"}\n        return text(\"Hello\", headers=headers)\n\n    request, response = app.test_client.get(\"/\")\n\n    assert response.headers.get(\"spam\") == \"great\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.headers.get('spam') == 'great'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response.headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_headers` function is designed to verify that the HTTP response from a Sanic application correctly includes custom headers set in the response. Specifically, it checks that the header \"spam\" is present and has the expected value \"great\".\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a request is made to the root endpoint (\"/\"), the response contains the custom header \"spam\" with the value \"great\". It confirms that the application correctly handles and returns headers as part of the HTTP response.\n\n**Code Being Tested and How It Works**:  \nThe test defines an asynchronous route handler for the root endpoint (\"/\") that returns a text response with a custom header. The `app.test_client.get(\"/\")` method simulates an HTTP GET request to this endpoint. The response is then checked to see if the \"spam\" header is present and matches the expected value. The relevant code being tested includes the route handler and the response handling mechanism of the Sanic framework.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the response headers, which is a common practice in unit testing to ensure expected outcomes. It also utilizes the Sanic testing client to simulate requests and capture responses, allowing for isolated testing of the application's behavior without needing to run a full server. The use of asynchronous functions indicates that the test is designed to work with asynchronous code, which is a key feature of the Sanic framework."
    },
    {
      "name": "test_non_str_headers",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 160,
      "end_line_number": 168,
      "source_code": "def test_non_str_headers(app):\n    @app.route(\"/\")\n    async def handler(request):\n        headers = {\"answer\": 42}\n        return text(\"Hello\", headers=headers)\n\n    request, response = app.test_client.get(\"/\")\n\n    assert response.headers.get(\"answer\") == \"42\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.headers.get('answer') == '42'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response.headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_non_str_headers` test is designed to verify that the Sanic application can handle non-string header values correctly, specifically ensuring that integer values in headers are converted to strings when accessed.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when an integer value (in this case, `42`) is set as a header in the response, it is correctly returned as a string when accessed via the response object's headers. The assertion confirms that the header value is accessible and matches the expected string representation.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route handler for the root path (`\"/\"`) of the Sanic application. Inside this handler, a response is returned with a header named `\"answer\"` set to the integer `42`. The test then makes a GET request to this route using the application's test client. After receiving the response, it checks the value of the `\"answer\"` header to ensure it equals the string `\"42\"`. The relevant code being tested includes the route handler and the response handling mechanism of the Sanic framework.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test leverages asynchronous programming by defining the route handler as an `async` function, which is a common pattern in modern web frameworks to handle I/O-bound operations efficiently.\n- **Header Manipulation**: The test specifically manipulates HTTP headers, showcasing how to set and retrieve headers in a web application context.\n- **Assertions**: The use of assertions to validate the expected outcome is a fundamental aspect of unit testing, ensuring that the application behaves as intended under the specified conditions."
    },
    {
      "name": "test_invalid_response",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 183,
      "end_line_number": 194,
      "source_code": "def test_invalid_response(app):\n    @app.exception(ServerError)\n    def handler_exception(request, exception):\n        return text(\"Internal Server Error.\", 500)\n\n    @app.route(\"/\")\n    async def handler(request):\n        return \"This should fail\"\n\n    request, response = app.test_client.get(\"/\")\n    assert response.status == 500\n    assert response.body == b\"Internal Server Error.\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert response.body == b'Internal Server Error.'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.exception",
          "body": "@app.route('/')\ndef exception(request):\n    raise SanicExceptionTestException(\"You won't see me\")"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_invalid_response` function is designed to verify that the Sanic application correctly handles a scenario where an internal server error occurs. Specifically, it checks that the application returns a 500 status code and the appropriate error message when an exception is raised.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a route handler raises an exception (in this case, a `SanicExceptionTestException`), the application responds with a 500 Internal Server Error status and a specific error message (\"Internal Server Error.\") as the response body. This behavior is crucial for maintaining proper error handling and user feedback in web applications.\n\n**Code Being Tested and How It Works**:  \nThe test sets up an exception handler for `ServerError` using the `@app.exception` decorator, which specifies how to respond when such an error occurs. The route defined by `@app.route(\"/\")` is intentionally designed to fail by returning a string that does not conform to the expected response type. When the test client makes a GET request to this route, the raised exception triggers the error handler, which returns the specified 500 status and error message.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Exception Handling**: The test utilizes custom exception handling to simulate error conditions and verify that the application responds appropriately.\n- **Assertions**: It employs assertions to validate the response status and body, ensuring that the application behaves as expected under error conditions.\n- **Test Client**: The use of `app.test_client.get(\"/\")` allows for simulating HTTP requests to the application, making it easier to test the behavior of routes and error handling in a controlled environment."
    },
    {
      "name": "test_json",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 212,
      "end_line_number": 221,
      "source_code": "def test_json(app):\n    @app.route(\"/\")\n    async def handler(request):\n        return json({\"test\": True})\n\n    request, response = app.test_client.get(\"/\")\n\n    results = json_loads(response.text)\n\n    assert results.get(\"test\") is True",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert results.get('test') is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "results.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_json` function is designed to verify that the Sanic application correctly returns a JSON response when a GET request is made to the root endpoint (\"/\"). Specifically, it checks that the response contains a specific key-value pair in the JSON object.\n\n**Specific Functionality or Behavior Verified**:  \nThe test ensures that the application responds with a JSON object containing the key `\"test\"` set to `True`. This confirms that the route handler is functioning as expected and that the JSON serialization is working correctly.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route handler for the root endpoint (\"/\") that returns a JSON response with the content `{\"test\": True}`. The test client then makes a GET request to this endpoint, and the response is parsed to check if the value associated with the key `\"test\"` is `True`. The relevant code being tested includes the route handler and the `app.test_client.get` method, which simulates the GET request.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test is structured to work with asynchronous code, which is common in web frameworks like Sanic. This is indicated by the use of `async def` for the route handler.\n- **Client Simulation**: The use of `app.test_client.get` allows for simulating HTTP requests to the application, enabling the test to verify the behavior of the application as if it were receiving real requests.\n- **Assertions**: The test employs assertions to validate the expected outcome, specifically checking the content of the JSON response. This is a fundamental practice in unit testing to ensure that the code behaves as intended."
    },
    {
      "name": "test_empty_json",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 237,
      "end_line_number": 245,
      "source_code": "def test_empty_json(app):\n    @app.route(\"/\")\n    async def handler(request):\n        assert request.json is None\n        return json(request.json)\n\n    request, response = app.test_client.get(\"/\")\n    assert response.status == 200\n    assert response.body == b\"null\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == b'null'",
        "assert request.json is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_empty_json` function is designed to verify the behavior of a Sanic application when an empty JSON request is made to the root endpoint (\"/\"). It checks that the application correctly identifies the absence of JSON data in the request and returns a response that reflects this.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically verifies that when a GET request is made to the root endpoint, the `request.json` attribute is `None`, indicating that no JSON data was sent. It also checks that the response status is 200 (OK) and that the response body is `b\"null\"`, which is the expected output when no JSON data is provided.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes an asynchronous route handler defined within the `test_empty_json` function. This handler asserts that `request.json` is `None` and returns a JSON response based on this value. The test then simulates a GET request to the root endpoint using `app.test_client.get(\"/\")`, capturing the request and response. The assertions confirm that the response status is 200 and the body is `b\"null\"`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test leverages asynchronous programming, which is common in web frameworks like Sanic. The handler is defined as an `async` function, allowing it to handle requests without blocking.\n- **Inline Route Definition**: The route handler is defined within the test function, which is a common pattern for unit tests that need to isolate behavior without affecting the global application state.\n- **Assertions**: The test uses assertions to validate the expected outcomes, ensuring that both the status code and response body match the anticipated results. This is a fundamental practice in unit testing to confirm that the code behaves as expected."
    },
    {
      "name": "test_echo_json",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 260,
      "end_line_number": 269,
      "source_code": "def test_echo_json(app):\n    @app.post(\"/\")\n    async def handler(request):\n        return json(request.json)\n\n    data = {\"foo\": \"bar\"}\n    request, response = app.test_client.post(\"/\", json=data)\n\n    assert response.status == 200\n    assert response.json == data",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.json == data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_echo_json` function is designed to verify that the Sanic application correctly handles JSON data sent in a POST request and returns the same data in the response. It ensures that the application can parse incoming JSON and respond appropriately.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks two key behaviors: \n1. The HTTP response status code is 200, indicating a successful request.\n2. The JSON response body matches the input data, confirming that the application correctly echoes back the JSON it received.\n\n**Code Being Tested and How It Works**:  \nThe test defines a POST route at the root URL (\"/\") of the Sanic application, where the handler function takes a request and returns the JSON data from that request. The test client simulates a POST request to this endpoint with a JSON payload (`{\"foo\": \"bar\"}`), and the assertions check that the response status is 200 and that the response JSON matches the input data.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test leverages Sanic's asynchronous capabilities, allowing for non-blocking I/O operations, which is essential for web applications.\n- **Test Client**: It uses the `app.test_client` to simulate HTTP requests, which is a common pattern in testing web applications to isolate and test specific routes and handlers.\n- **Assertions**: The test employs assertions to validate the expected outcomes, ensuring that both the status code and the response body are as intended. This is a fundamental practice in unit testing to confirm that the code behaves as expected."
    },
    {
      "name": "test_invalid_json",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 285,
      "end_line_number": 293,
      "source_code": "def test_invalid_json(app):\n    @app.post(\"/\")\n    async def handler(request):\n        return json(request.json)\n\n    data = \"I am not json\"\n    request, response = app.test_client.post(\"/\", data=data)\n\n    assert response.status == 400",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 400"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_invalid_json` function is designed to verify that the application correctly handles invalid JSON input by returning a 400 Bad Request status. This ensures that the application can gracefully manage erroneous data submissions.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks the application's response to a POST request containing data that is not valid JSON. It asserts that the response status is 400, indicating that the server recognizes the input as malformed and cannot process it.\n\n**Code Being Tested and How It Works**:  \nThe test defines a POST route handler that attempts to parse the incoming request's JSON data. When the test sends a string (\"I am not json\") that is not valid JSON, the handler should fail to parse it, leading to a 400 response. The relevant code being tested is the `app.post` method, which is expected to invoke the handler and return the appropriate HTTP status code based on the validity of the input.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern, using `assert` to validate the expected outcome (response status). It also utilizes the Sanic testing client to simulate HTTP requests, allowing for the testing of asynchronous route handlers in a controlled environment. The test is structured to be simple and focused, ensuring clarity in what is being validated without unnecessary complexity."
    },
    {
      "name": "test_query_string",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 308,
      "end_line_number": 321,
      "source_code": "def test_query_string(app):\n    @app.route(\"/\")\n    async def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\n        \"/\", params=[(\"test1\", \"1\"), (\"test2\", \"false\"), (\"test2\", \"true\")]\n    )\n\n    assert request.args.get(\"test1\") == \"1\"\n    assert request.args.get(\"test2\") == \"false\"\n    assert request.args.getlist(\"test2\") == [\"false\", \"true\"]\n    assert request.args.getlist(\"test1\") == [\"1\"]\n    assert request.args.get(\"test3\", default=\"My value\") == \"My value\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.args.get('test1') == '1'",
        "assert request.args.get('test2') == 'false'",
        "assert request.args.getlist('test2') == ['false', 'true']",
        "assert request.args.getlist('test1') == ['1']",
        "assert request.args.get('test3', default='My value') == 'My value'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "request.args.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "request.args.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "request.args.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_query_string` function is designed to verify the correct handling of query string parameters in a Sanic web application. It ensures that the application can correctly parse and retrieve values from the query string, including handling multiple values for the same key.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. Single query parameters return the expected values.\n2. Multiple values for the same query parameter are correctly retrieved as a list.\n3. Default values are returned when a non-existent query parameter is requested.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a simple route (`\"/\"`) that responds with \"OK\". It then simulates a GET request to this route with a set of query parameters: `test1`, `test2`, and a duplicate `test2`. The assertions verify:\n- `request.args.get(\"test1\")` retrieves the value `\"1\"`.\n- `request.args.get(\"test2\")` retrieves the first occurrence of `\"false\"`.\n- `request.args.getlist(\"test2\")` retrieves both occurrences of `test2`, resulting in the list `[\"false\", \"true\"]`.\n- `request.args.get(\"test3\", default=\"My value\")` checks that the default value is returned for a non-existent parameter.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses a list of tuples to pass multiple query parameters, demonstrating how to handle complex query strings.\n- **Assertions**: Multiple assertions are employed to validate different aspects of the query string handling, ensuring comprehensive coverage of the functionality.\n- **Asynchronous Testing**: The test is structured to work within an asynchronous context, which is essential for testing web applications built with frameworks like Sanic that utilize async/await patterns."
    },
    {
      "name": "test_popped_stays_popped",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 324,
      "end_line_number": 332,
      "source_code": "def test_popped_stays_popped(app):\n    @app.route(\"/\")\n    async def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/\", params=[(\"test1\", \"1\")])\n\n    assert request.args.pop(\"test1\") == [\"1\"]\n    assert \"test1\" not in request.args",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.args.pop('test1') == ['1']",
        "assert 'test1' not in request.args"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_popped_stays_popped` test verifies that when a query parameter is popped from the request arguments, it is removed from the arguments list and cannot be accessed afterward.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `pop` method on the request's `args` dictionary correctly retrieves the value associated with the key \"test1\" and removes it from the dictionary, ensuring that subsequent attempts to access \"test1\" return a result indicating it no longer exists.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a simple Sanic application with a single route that responds with \"OK\". It then simulates a GET request to this route with a query parameter `test1=1`. The `app.test_client.get` method is called, which returns a `request` object containing the query parameters. The test then asserts that calling `request.args.pop(\"test1\")` returns the expected value `[\"1\"]` and that the key \"test1\" is no longer present in `request.args`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the state of the request arguments before and after the `pop` operation. It also utilizes the Sanic testing client to simulate HTTP requests, which is a common pattern in testing web applications. The use of async functions and the Sanic framework's routing capabilities demonstrates how to effectively test asynchronous web handlers."
    },
    {
      "name": "test_uri_template",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 352,
      "end_line_number": 358,
      "source_code": "def test_uri_template(app):\n    @app.route(\"/foo/<id:int>/bar/<name:[A-z]+>\")\n    async def handler(request, id, name):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/foo/123/bar/baz\")\n    assert request.uri_template == \"/foo/<id:int>/bar/<name:[A-z]+>\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.uri_template == '/foo/<id:int>/bar/<name:[A-z]+>'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_uri_template` function is designed to verify that the URI template used in a Sanic application correctly matches the expected format when a specific route is accessed. It ensures that the routing mechanism of the Sanic framework is functioning as intended.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a GET request is made to the route `/foo/123/bar/baz`, the `request.uri_template` attribute accurately reflects the defined route template `\"/foo/<id:int>/bar/<name:[A-z]+>\"`. This confirms that the routing system captures and retains the template used for the request.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the route definition and the request handling mechanism of the Sanic application. The route is defined with parameters that specify the expected types (integer for `id` and a regex for `name`). When the test client makes a GET request to the specified path, the handler function is invoked, and the request object is returned, which includes the `uri_template` attribute. The assertion checks if this attribute matches the expected template.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test is structured to work with asynchronous code, which is common in web frameworks like Sanic. This is indicated by the use of `async def` for the handler and the test function.\n- **Route Parameterization**: The test leverages route parameters to validate that the framework correctly interprets and matches dynamic segments in the URL.\n- **Assertion**: The use of an assertion to compare the actual `uri_template` with the expected string is a straightforward yet effective way to validate the behavior of the routing system."
    },
    {
      "name": "test_token",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 384,
      "end_line_number": 400,
      "source_code": "def test_token(app, auth_type, token):\n    @app.route(\"/\")\n    async def handler(request):\n        return text(\"OK\")\n\n    if token:\n        headers = {\n            \"content-type\": \"application/json\",\n            \"Authorization\": f\"{auth_type} {token}\"\n            if auth_type\n            else f\"{token}\",\n        }\n    else:\n        headers = {\"content-type\": \"application/json\"}\n\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert request.token == token",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize(('auth_type', 'token'), [(None, 'a1d895e0-553a-421a-8e22-5ff8ecb48cbf'), ('Token', 'a1d895e0-553a-421a-8e22-5ff8ecb48cbf'), ('Bearer', 'a1d895e0-553a-421a-8e22-5ff8ecb48cbf'), (None, None)])"
      ],
      "arguments": [
        "app",
        "auth_type",
        "token"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.token == token"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_token` function is designed to verify the correct handling of authorization tokens in HTTP requests made to a Sanic web application. It ensures that the application correctly processes requests with various types of authorization headers and that the expected token is associated with the request.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when a request is made to the root endpoint (\"/\") with a specific authorization token, the token is correctly set in the request object. It validates that the token passed in the headers matches the token expected by the application.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route handler for the root endpoint that simply returns \"OK\". It constructs headers based on the presence of a token and the specified authorization type (`auth_type`). The test then makes a GET request to the root endpoint using the constructed headers. After the request is processed, it asserts that the `token` attribute of the request object matches the provided token. This ensures that the application correctly recognizes and associates the token with the incoming request.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test utilizes `pytest.mark.parametrize` to run multiple scenarios with different combinations of `auth_type` and `token`, allowing for comprehensive testing of various authorization methods without duplicating code.\n- **Asynchronous Testing**: The test is designed to work with an asynchronous framework (Sanic), which is evident in the use of async route handlers and the test client.\n- **Header Manipulation**: The test demonstrates how to manipulate HTTP headers to simulate different authorization scenarios, which is a common practice in testing web applications."
    },
    {
      "name": "test_credentials",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 423,
      "end_line_number": 459,
      "source_code": "def test_credentials(app, capfd, auth_type, token, username, password):\n    @app.route(\"/\")\n    async def handler(request):\n        return text(\"OK\")\n\n    if token:\n        headers = {\n            \"content-type\": \"application/json\",\n            \"Authorization\": f\"{auth_type} {token}\"\n            if auth_type\n            else f\"{token}\",\n        }\n    else:\n        headers = {\"content-type\": \"application/json\"}\n\n    request, response = app.test_client.get(\"/\", headers=headers)\n\n    if auth_type == \"Basic\":\n        assert request.credentials.username == username\n        assert request.credentials.password == password\n    else:\n        _, err = capfd.readouterr()\n        with pytest.raises(AttributeError):\n            request.credentials.password\n            assert \"Password is available for Basic Auth only\" in err\n            request.credentials.username\n            assert \"Username is available for Basic Auth only\" in err\n\n    if token:\n        assert request.credentials.token == token\n        assert request.credentials.auth_type == auth_type\n    else:\n        assert request.credentials is None\n        assert not hasattr(request.credentials, \"token\")\n        assert not hasattr(request.credentials, \"auth_type\")\n        assert not hasattr(request.credentials, \"_username\")\n        assert not hasattr(request.credentials, \"_password\")",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize(('auth_type', 'token', 'username', 'password'), [(None, 'a1d895e0-553a-421a-8e22-5ff8ecb48cbf', None, None), ('Token', 'a1d895e0-553a-421a-8e22-5ff8ecb48cbf', None, None), ('Bearer', 'a1d895e0-553a-421a-8e22-5ff8ecb48cbf', None, None), ('Basic', encode_basic_auth_credentials('some_username', 'some_pass'), 'some_username', 'some_pass'), (None, None, None, None)])"
      ],
      "arguments": [
        "app",
        "capfd",
        "auth_type",
        "token",
        "username",
        "password"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.credentials.username == username",
        "assert request.credentials.password == password",
        "assert request.credentials.token == token",
        "assert request.credentials.auth_type == auth_type",
        "assert request.credentials is None",
        "assert not hasattr(request.credentials, 'token')",
        "assert not hasattr(request.credentials, 'auth_type')",
        "assert not hasattr(request.credentials, '_username')",
        "assert not hasattr(request.credentials, '_password')",
        "assert 'Password is available for Basic Auth only' in err",
        "assert 'Username is available for Basic Auth only' in err"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "encode_basic_auth_credentials",
          "body": "def encode_basic_auth_credentials(username, password):\n    return base64.b64encode(f'{username}:{password}'.encode()).decode('ascii')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_credentials` function is designed to verify the behavior of the Sanic application regarding authentication credentials. It checks how the application handles different types of authentication (Basic Auth and token-based) and ensures that the correct credentials are parsed and returned in the request context.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies that:\n1. For Basic Auth, the correct username and password are extracted and matched against expected values.\n2. For non-Basic Auth scenarios, it ensures that accessing username and password raises an `AttributeError` and that appropriate error messages are generated.\n3. It checks that when a token is provided, the token and its type are correctly assigned to the request credentials.\n4. If no token is provided, it confirms that the credentials are `None` and that no attributes related to credentials exist.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `app.test_client.get` method, which simulates a GET request to the application. The request includes headers that may contain authentication information. The `credentials` property of the request object attempts to parse the `Authorization` header to extract the authentication type and credentials. The test checks the behavior of this property under different conditions (with and without tokens, and with Basic Auth).\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterized Testing**: The test function accepts multiple parameters (`auth_type`, `token`, `username`, `password`), allowing it to run multiple scenarios with different inputs.\n- **Assertions**: The test uses assertions to validate expected outcomes, including checking for the presence of attributes and error messages.\n- **Error Handling**: The test anticipates and verifies the raising of exceptions (e.g., `AttributeError`) when accessing invalid attributes, demonstrating robust error handling in the application.\n- **Use of Fixtures**: The test leverages fixtures (`app`, `capfd`) to set up the application context and capture output, which is a common practice in testing frameworks like pytest."
    },
    {
      "name": "test_content_type",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 462,
      "end_line_number": 474,
      "source_code": "def test_content_type(app):\n    @app.route(\"/\")\n    async def handler(request):\n        return text(request.content_type)\n\n    request, response = app.test_client.get(\"/\")\n    assert request.content_type == DEFAULT_HTTP_CONTENT_TYPE\n    assert response.body.decode() == DEFAULT_HTTP_CONTENT_TYPE\n\n    headers = {\"content-type\": \"application/json\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert request.content_type == \"application/json\"\n    assert response.body == b\"application/json\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.content_type == DEFAULT_HTTP_CONTENT_TYPE",
        "assert response.body.decode() == DEFAULT_HTTP_CONTENT_TYPE",
        "assert request.content_type == 'application/json'",
        "assert response.body == b'application/json'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_content_type` function is designed to verify that the Sanic application correctly handles and returns the `Content-Type` header in HTTP requests and responses. It ensures that the application defaults to a specified content type and can also handle custom content types provided in the request headers.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main scenarios: \n1. When a GET request is made to the root endpoint (\"/\") without any custom headers, it verifies that the `Content-Type` of the request and the response body match the default content type (`DEFAULT_HTTP_CONTENT_TYPE`).\n2. When a GET request is made with a custom `Content-Type` header set to \"application/json\", it verifies that both the request's `Content-Type` and the response body reflect this custom type.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes an asynchronous route handler defined for the root endpoint (\"/\") that returns the `Content-Type` of the incoming request. The test uses the `app.test_client.get` method to simulate GET requests to this endpoint. The first request checks the default behavior, while the second request includes a custom header to test the application's ability to recognize and return the specified content type.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test leverages asynchronous route handling, which is a common pattern in modern web frameworks like Sanic. This allows for non-blocking I/O operations.\n- **Assertions**: The test uses assertions to validate the expected outcomes, ensuring that both the request and response behave as intended.\n- **Header Manipulation**: The test demonstrates how to manipulate HTTP headers in requests to test different scenarios, which is crucial for verifying the robustness of web applications."
    },
    {
      "name": "test_standard_forwarded",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 493,
      "end_line_number": 605,
      "source_code": "def test_standard_forwarded(app):\n    @app.route(\"/\")\n    async def handler(request):\n        return json(request.forwarded)\n\n    # Without configured FORWARDED_SECRET, x-headers should be respected\n    app.config.PROXIES_COUNT = 1\n    app.config.REAL_IP_HEADER = \"x-real-ip\"\n    headers = {\n        \"Forwarded\": (\n            'for=1.1.1.1, for=injected;host=\"'\n            ', for=\"[::2]\";proto=https;host=me.tld;'\n            'path=\"/app/\";secret=mySecret'\n            \",for=broken;;secret=b0rked\"\n            \", for=127.0.0.3;scheme=http;port=1234\"\n        ),\n        \"X-Real-IP\": \"127.0.0.2\",\n        \"X-Forwarded-For\": \"127.0.1.1\",\n        \"X-Scheme\": \"ws\",\n        \"Host\": \"local.site\",\n    }\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert response.json == {\"for\": \"127.0.0.2\", \"proto\": \"ws\"}\n    assert request.remote_addr == \"127.0.0.2\"\n    assert request.client_ip == \"127.0.0.2\"\n    assert request.scheme == \"ws\"\n    assert request.server_name == \"local.site\"\n    assert request.server_port == 80\n\n    app.config.FORWARDED_SECRET = \"mySecret\"\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert response.json == {\n        \"for\": \"[::2]\",\n        \"proto\": \"https\",\n        \"host\": \"me.tld\",\n        \"path\": \"/app/\",\n        \"secret\": \"mySecret\",\n    }\n    assert request.remote_addr == \"[::2]\"\n    assert request.server_name == \"me.tld\"\n    assert request.scheme == \"https\"\n    assert request.server_port == 443\n\n    # Empty Forwarded header -> use X-headers\n    headers[\"Forwarded\"] = \"\"\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert response.json == {\"for\": \"127.0.0.2\", \"proto\": \"ws\"}\n\n    # Header present but not matching anything\n    request, response = app.test_client.get(\"/\", headers={\"Forwarded\": \".\"})\n    assert response.json == {}\n\n    # Forwarded header present but no matching secret -> use X-headers\n    headers = {\n        \"Forwarded\": \"for=1.1.1.1;secret=x, for=127.0.0.1\",\n        \"X-Real-IP\": \"127.0.0.2\",\n    }\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert response.json == {\"for\": \"127.0.0.2\"}\n    assert request.remote_addr == \"127.0.0.2\"\n\n    # Different formatting and hitting both ends of the header\n    headers = {\"Forwarded\": 'Secret=\"mySecret\";For=127.0.0.4;Port=1234'}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert response.json == {\n        \"for\": \"127.0.0.4\",\n        \"port\": 1234,\n        \"secret\": \"mySecret\",\n    }\n\n    # Test escapes (modify this if you see anyone implementing quoted-pairs)\n    headers = {\"Forwarded\": 'for=test;quoted=\"\\\\,x=x;y=\\\\\";secret=mySecret'}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert response.json == {\n        \"for\": \"test\",\n        \"quoted\": \"\\\\,x=x;y=\\\\\",\n        \"secret\": \"mySecret\",\n    }\n\n    # Secret insulated by malformed field #1\n    headers = {\"Forwarded\": \"for=test;secret=mySecret;b0rked;proto=wss;\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert response.json == {\"for\": \"test\", \"secret\": \"mySecret\"}\n\n    # Secret insulated by malformed field #2\n    headers = {\"Forwarded\": \"for=test;b0rked;secret=mySecret;proto=wss\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert response.json == {\"proto\": \"wss\", \"secret\": \"mySecret\"}\n\n    # Unexpected termination should not lose existing acceptable values\n    headers = {\"Forwarded\": \"b0rked;secret=mySecret;proto=wss\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert response.json == {\"proto\": \"wss\", \"secret\": \"mySecret\"}\n\n    # Field normalization\n    headers = {\n        \"Forwarded\": 'PROTO=WSS;BY=\"CAFE::8000\";FOR=unknown;PORT=X;HOST=\"A:2\";'\n        'PATH=\"/With%20Spaces%22Quoted%22/sanicApp?key=val\";SECRET=mySecret'\n    }\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert response.json == {\n        \"proto\": \"wss\",\n        \"by\": \"[cafe::8000]\",\n        \"host\": \"a:2\",\n        \"path\": '/With Spaces\"Quoted\"/sanicApp?key=val',\n        \"secret\": \"mySecret\",\n    }\n\n    # Using \"by\" field as secret\n    app.config.FORWARDED_SECRET = \"_proxySecret\"\n    headers = {\"Forwarded\": \"for=1.2.3.4; by=_proxySecret\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert response.json == {\"for\": \"1.2.3.4\", \"by\": \"_proxySecret\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json == {'for': '127.0.0.2', 'proto': 'ws'}",
        "assert request.remote_addr == '127.0.0.2'",
        "assert request.client_ip == '127.0.0.2'",
        "assert request.scheme == 'ws'",
        "assert request.server_name == 'local.site'",
        "assert request.server_port == 80",
        "assert response.json == {'for': '[::2]', 'proto': 'https', 'host': 'me.tld', 'path': '/app/', 'secret': 'mySecret'}",
        "assert request.remote_addr == '[::2]'",
        "assert request.server_name == 'me.tld'",
        "assert request.scheme == 'https'",
        "assert request.server_port == 443",
        "assert response.json == {'for': '127.0.0.2', 'proto': 'ws'}",
        "assert response.json == {}",
        "assert response.json == {'for': '127.0.0.2'}",
        "assert request.remote_addr == '127.0.0.2'",
        "assert response.json == {'for': '127.0.0.4', 'port': 1234, 'secret': 'mySecret'}",
        "assert response.json == {'for': 'test', 'quoted': '\\\\,x=x;y=\\\\', 'secret': 'mySecret'}",
        "assert response.json == {'for': 'test', 'secret': 'mySecret'}",
        "assert response.json == {'proto': 'wss', 'secret': 'mySecret'}",
        "assert response.json == {'proto': 'wss', 'secret': 'mySecret'}",
        "assert response.json == {'proto': 'wss', 'by': '[cafe::8000]', 'host': 'a:2', 'path': '/With Spaces\"Quoted\"/sanicApp?key=val', 'secret': 'mySecret'}",
        "assert response.json == {'for': '1.2.3.4', 'by': '_proxySecret'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_standard_forwarded` function is designed to verify the behavior of the Sanic web framework when handling the `Forwarded` HTTP header and related headers such as `X-Real-IP` and `X-Forwarded-For`. It ensures that the application correctly interprets these headers to determine the client's IP address, protocol, and other request attributes, especially in scenarios involving proxies.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks multiple scenarios:\n1. When the `FORWARDED_SECRET` is not set, it verifies that the application respects the `X-Real-IP` and `X-Forwarded-For` headers.\n2. When the `FORWARDED_SECRET` is set, it ensures that the application correctly parses the `Forwarded` header and extracts the appropriate values, including the secret.\n3. It tests edge cases such as empty `Forwarded` headers, malformed headers, and various formatting styles to ensure robustness in header parsing.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes an asynchronous route handler that returns the parsed `request.forwarded` data as JSON. The test client simulates HTTP GET requests to this route with various headers. The assertions check that the response JSON and request attributes (like `remote_addr`, `client_ip`, `scheme`, etc.) match the expected values based on the provided headers. The test also manipulates the application configuration to toggle the behavior of header processing.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterized Testing**: The test uses multiple assertions to cover a wide range of header configurations and expected outcomes, ensuring comprehensive coverage of the header parsing logic.\n- **Mocking and Dependency Injection**: The test leverages the `app.test_client` to simulate requests, allowing for isolated testing of the route handler without needing a live server.\n- **Assertions**: The use of assertions to validate the response and request attributes ensures that the test fails if the application does not behave as expected, providing immediate feedback on any issues."
    },
    {
      "name": "test_remote_addr_with_two_proxies",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 727,
      "end_line_number": 765,
      "source_code": "def test_remote_addr_with_two_proxies(app):\n    app.config.PROXIES_COUNT = 2\n    app.config.REAL_IP_HEADER = \"x-real-ip\"\n\n    @app.route(\"/\")\n    async def handler(request):\n        return text(request.remote_addr)\n\n    headers = {\"X-Real-IP\": \"127.0.0.2\", \"X-Forwarded-For\": \"127.0.1.1\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert request.remote_addr == \"127.0.0.2\"\n    assert response.body == b\"127.0.0.2\"\n\n    headers = {\"X-Forwarded-For\": \"127.0.1.1\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert request.remote_addr == \"\"\n    assert request.client_ip == \"127.0.0.1\"\n    assert response.body == b\"\"\n\n    headers = {\"X-Forwarded-For\": \"127.0.0.1, 127.0.1.2\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert request.remote_addr == \"127.0.0.1\"\n    assert response.body == b\"127.0.0.1\"\n\n    request, response = app.test_client.get(\"/\")\n    assert request.remote_addr == \"\"\n    assert response.body == b\"\"\n\n    headers = {\"X-Forwarded-For\": \"127.0.0.1, ,   ,,127.0.1.2\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert request.remote_addr == \"127.0.0.1\"\n    assert response.body == b\"127.0.0.1\"\n\n    headers = {\n        \"X-Forwarded-For\": \", 127.0.2.2, ,  ,127.0.0.1, ,   ,,127.0.1.2\"\n    }\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert request.remote_addr == \"127.0.0.1\"\n    assert response.body == b\"127.0.0.1\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.remote_addr == '127.0.0.2'",
        "assert response.body == b'127.0.0.2'",
        "assert request.remote_addr == ''",
        "assert request.client_ip == '127.0.0.1'",
        "assert response.body == b''",
        "assert request.remote_addr == '127.0.0.1'",
        "assert response.body == b'127.0.0.1'",
        "assert request.remote_addr == ''",
        "assert response.body == b''",
        "assert request.remote_addr == '127.0.0.1'",
        "assert response.body == b'127.0.0.1'",
        "assert request.remote_addr == '127.0.0.1'",
        "assert response.body == b'127.0.0.1'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_remote_addr_with_two_proxies` test is to verify the correct handling of client IP addresses when requests are forwarded through multiple proxies. It ensures that the application correctly identifies the original client IP based on the provided headers, particularly when the `X-Real-IP` and `X-Forwarded-For` headers are used.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the `remote_addr` attribute of the request object reflects the expected client IP address based on the configuration of the application and the headers sent with the request. It verifies various scenarios, including:\n- Correctly extracting the IP from `X-Real-IP` when both `X-Real-IP` and `X-Forwarded-For` are present.\n- Handling cases where only `X-Forwarded-For` is present, including malformed headers and multiple IPs.\n- Ensuring that when no valid IP is provided, the `remote_addr` is empty.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the Sanic application\u2019s request handling mechanism, specifically how it processes incoming requests to determine the client's IP address. The `handler` function returns the `remote_addr` from the request object. The test simulates various requests with different headers and checks the resulting `remote_addr` and response body to ensure they match expected values. The application configuration (`PROXIES_COUNT` and `REAL_IP_HEADER`) influences how the headers are interpreted.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Parameterized Testing**: It tests multiple scenarios by changing the headers and asserting different expected outcomes, which helps ensure comprehensive coverage of edge cases.\n- **Asynchronous Testing**: The use of `async` functions and the `app.test_client.get` method indicates that the test is designed to work with asynchronous request handling, which is a common pattern in modern web frameworks.\n- **Assertions**: The test uses assertions to validate that the actual output matches the expected output, which is a fundamental aspect of unit testing to ensure correctness."
    },
    {
      "name": "test_remote_addr_without_proxy",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 809,
      "end_line_number": 829,
      "source_code": "def test_remote_addr_without_proxy(app):\n    app.config.PROXIES_COUNT = 0\n\n    @app.route(\"/\")\n    async def handler(request):\n        return text(request.remote_addr)\n\n    headers = {\"X-Real-IP\": \"127.0.0.2\", \"X-Forwarded-For\": \"127.0.1.1\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert request.remote_addr == \"\"\n    assert response.body == b\"\"\n\n    headers = {\"X-Forwarded-For\": \"127.0.1.1\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert request.remote_addr == \"\"\n    assert response.body == b\"\"\n\n    headers = {\"X-Forwarded-For\": \"127.0.0.1, 127.0.1.2\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert request.remote_addr == \"\"\n    assert response.body == b\"\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.remote_addr == ''",
        "assert response.body == b''",
        "assert request.remote_addr == ''",
        "assert response.body == b''",
        "assert request.remote_addr == ''",
        "assert response.body == b''"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_remote_addr_without_proxy` function is designed to verify the behavior of the Sanic application when no proxies are configured. Specifically, it checks that the `remote_addr` attribute of the request object remains empty when the application is not behind any proxies, regardless of the presence of headers that typically convey the client's IP address.\n\n**Specific Functionality or Behavior Verified**:  \nThe test ensures that when `PROXIES_COUNT` is set to 0, the application does not use any forwarded headers (like `X-Real-IP` or `X-Forwarded-For`) to determine the client's IP address. It asserts that `request.remote_addr` is an empty string and that the response body is also empty for various header configurations.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a route handler that returns the `remote_addr` from the request. The test simulates HTTP GET requests to this route with different headers. The assertions check that the `remote_addr` remains empty and that the response body is empty, confirming that the application correctly ignores the headers when no proxies are configured.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a parameterized approach by testing multiple scenarios with different header configurations. It uses assertions to validate the expected outcomes, ensuring that the application behaves consistently under various conditions. The use of `async` functions and the Sanic test client demonstrates an effective way to test asynchronous web applications."
    },
    {
      "name": "test_remote_addr_custom_headers",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 856,
      "end_line_number": 878,
      "source_code": "def test_remote_addr_custom_headers(app):\n    app.config.PROXIES_COUNT = 1\n    app.config.REAL_IP_HEADER = \"Client-IP\"\n    app.config.FORWARDED_FOR_HEADER = \"Forwarded\"\n\n    @app.route(\"/\")\n    async def handler(request):\n        return text(request.remote_addr)\n\n    headers = {\"X-Real-IP\": \"127.0.0.2\", \"Forwarded\": \"127.0.1.1\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert request.remote_addr == \"127.0.1.1\"\n    assert response.body == b\"127.0.1.1\"\n\n    headers = {\"X-Forwarded-For\": \"127.0.1.1\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert request.remote_addr == \"\"\n    assert response.body == b\"\"\n\n    headers = {\"Client-IP\": \"127.0.0.2\", \"Forwarded\": \"127.0.1.1\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert request.remote_addr == \"127.0.0.2\"\n    assert response.body == b\"127.0.0.2\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.remote_addr == '127.0.1.1'",
        "assert response.body == b'127.0.1.1'",
        "assert request.remote_addr == ''",
        "assert response.body == b''",
        "assert request.remote_addr == '127.0.0.2'",
        "assert response.body == b'127.0.0.2'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_remote_addr_custom_headers` test is to verify that the Sanic application correctly identifies the client's remote address based on various custom HTTP headers. This is particularly important in scenarios where the application is behind proxies, and the actual client IP needs to be extracted from headers like `X-Real-IP` and `Forwarded`.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks the behavior of the application when different combinations of headers are sent in the request. It verifies that the `request.remote_addr` attribute is set correctly based on the provided headers, and that the response body matches the expected remote address. It also tests the handling of cases where headers are missing or incorrectly formatted.\n\n**Code Being Tested and How It Works**:  \nThe code being tested includes a route handler that returns the `request.remote_addr`. The test sets up the application configuration to recognize specific headers (`REAL_IP_HEADER` and `FORWARDED_FOR_HEADER`) and then simulates GET requests with various headers. The assertions check that the `remote_addr` is set to the expected IP address based on the headers provided, and that the response body reflects this address.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs parameterized testing by sending multiple requests with different headers to cover various scenarios. It uses assertions to validate the expected outcomes, ensuring that the application behaves correctly under different conditions. The use of `async` functions indicates that the test is designed to work with asynchronous request handling, which is a common pattern in modern web frameworks like Sanic. Additionally, the test is structured to be clear and concise, focusing on specific behaviors rather than broad functionality."
    },
    {
      "name": "test_forwarded_scheme",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 907,
      "end_line_number": 925,
      "source_code": "def test_forwarded_scheme(app):\n    @app.route(\"/\")\n    async def handler(request):\n        return text(request.remote_addr)\n\n    app.config.PROXIES_COUNT = 1\n    request, response = app.test_client.get(\"/\")\n    assert request.scheme == \"http\"\n\n    request, response = app.test_client.get(\n        \"/\",\n        headers={\"X-Forwarded-For\": \"127.1.2.3\", \"X-Forwarded-Proto\": \"https\"},\n    )\n    assert request.scheme == \"https\"\n\n    request, response = app.test_client.get(\n        \"/\", headers={\"X-Forwarded-For\": \"127.1.2.3\", \"X-Scheme\": \"https\"}\n    )\n    assert request.scheme == \"https\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.scheme == 'http'",
        "assert request.scheme == 'https'",
        "assert request.scheme == 'https'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_forwarded_scheme` test verifies that the Sanic application correctly interprets the scheme (HTTP or HTTPS) of incoming requests based on forwarded headers. This is crucial for applications that operate behind proxies, ensuring that the application can accurately determine the original request scheme.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. When no forwarded headers are present, the request scheme defaults to \"http\".\n2. When the `X-Forwarded-Proto` header is set to \"https\", the request scheme is correctly interpreted as \"https\".\n3. When the `X-Scheme` header is set to \"https\", the request scheme is also interpreted as \"https\".\n\n**Code Being Tested and How It Works**:  \nThe test defines a simple route handler that returns the remote address of the request. It then makes three GET requests to this handler:\n1. The first request checks the default scheme when no headers are set.\n2. The second request includes the `X-Forwarded-For` and `X-Forwarded-Proto` headers, which should set the scheme to \"https\".\n3. The third request uses the `X-Scheme` header to also assert that the scheme is \"https\". The assertions confirm that the application correctly processes these headers to determine the request scheme.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Header Manipulation**: The test effectively demonstrates how to manipulate HTTP headers to simulate different request scenarios, which is a common practice in testing web applications.\n- **Assertions**: The use of assertions to validate the expected outcomes of the request scheme based on the headers is a standard approach in unit testing, ensuring that the application behaves as intended under various conditions.\n- **Asynchronous Testing**: Although this specific test is synchronous, it is part of a broader codebase that utilizes asynchronous handlers, showcasing the flexibility of testing frameworks like pytest with async capabilities."
    },
    {
      "name": "test_match_info",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 928,
      "end_line_number": 936,
      "source_code": "def test_match_info(app):\n    @app.route(\"/api/v1/user/<user_id>/\")\n    async def handler(request, user_id):\n        return json(request.match_info)\n\n    request, response = app.test_client.get(\"/api/v1/user/sanic_user/\")\n\n    assert request.match_info == {\"user_id\": \"sanic_user\"}\n    assert json_loads(response.text) == {\"user_id\": \"sanic_user\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.match_info == {'user_id': 'sanic_user'}",
        "assert json_loads(response.text) == {'user_id': 'sanic_user'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_match_info` function is designed to verify that the Sanic web framework correctly captures and returns route parameters from a URL. Specifically, it checks that the `match_info` attribute of the request object accurately reflects the dynamic segments of the route.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a request is made to a specific endpoint (in this case, `/api/v1/user/<user_id>/`), the `user_id` parameter is correctly extracted from the URL and made available in the `request.match_info` dictionary. Additionally, it verifies that the response body contains the same information in JSON format.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a route handler defined within the `test_match_info` function. The handler is set up to respond to GET requests at the specified endpoint. When a request is made to `/api/v1/user/sanic_user/`, the handler returns the `request.match_info`, which should contain the key-value pair `{\"user_id\": \"sanic_user\"}`. The test then asserts that both the `request.match_info` and the JSON response body match this expected output.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Route Testing**: The test leverages Sanic's routing capabilities to define a dynamic route and validate its behavior.\n- **Assertions**: It uses assertions to compare the actual output against expected values, ensuring that both the request's match information and the response content are correct.\n- **Asynchronous Testing**: The test is structured to work within an asynchronous context, which is common in web frameworks like Sanic, allowing for non-blocking I/O operations."
    },
    {
      "name": "test_post_json",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 956,
      "end_line_number": 970,
      "source_code": "def test_post_json(app):\n    @app.route(\"/\", methods=[\"POST\"])\n    async def handler(request):\n        return text(\"OK\")\n\n    payload = {\"test\": \"OK\"}\n    headers = {\"content-type\": \"application/json\"}\n\n    request, response = app.test_client.post(\n        \"/\", data=json_dumps(payload), headers=headers\n    )\n\n    assert request.json.get(\"test\") == \"OK\"\n    assert request.json.get(\"test\") == \"OK\"  # for request.parsed_json\n    assert response.body == b\"OK\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.json.get('test') == 'OK'",
        "assert request.json.get('test') == 'OK'",
        "assert response.body == b'OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "request.json.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "request.json.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_post_json` function is designed to verify the behavior of a POST request handler in a Sanic web application. Specifically, it checks that the application correctly processes JSON data sent in the request body and returns the expected response.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies that when a JSON payload is sent to the root endpoint (\"/\"), the server correctly parses the JSON data and returns a response with the body \"OK\". It also checks that the parsed JSON data can be accessed correctly from the request object.\n\n**Code Being Tested and How It Works**:  \nThe test defines a POST route handler that returns a simple text response \"OK\". It then constructs a JSON payload (`{\"test\": \"OK\"}`) and sends it to the handler using the `app.test_client.post` method. The assertions check that:\n1. The JSON data in the request is correctly parsed and contains the expected value.\n2. The response body matches the expected output.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test is structured to work with asynchronous code, which is common in web frameworks like Sanic. This allows for non-blocking I/O operations.\n- **Client Simulation**: The use of `app.test_client.post` simulates a client making a request to the server, allowing for integration-style testing of the route handlers.\n- **Assertions**: The test employs assertions to validate the expected outcomes, ensuring that both the request parsing and response generation work as intended."
    },
    {
      "name": "test_post_form_urlencoded",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 991,
      "end_line_number": 1004,
      "source_code": "def test_post_form_urlencoded(app):\n    @app.route(\"/\", methods=[\"POST\"])\n    async def handler(request):\n        return text(\"OK\")\n\n    payload = \"test=OK\"\n    headers = {\"content-type\": \"application/x-www-form-urlencoded\"}\n\n    request, response = app.test_client.post(\n        \"/\", data=payload, headers=headers\n    )\n\n    assert request.form.get(\"test\") == \"OK\"\n    assert request.form.get(\"test\") == \"OK\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.form.get('test') == 'OK'",
        "assert request.form.get('test') == 'OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "request.form.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "request.form.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_post_form_urlencoded` function is designed to verify that the Sanic application correctly processes a POST request with form-urlencoded data. Specifically, it checks that the data sent in the request body can be accurately retrieved from the request's form data.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a POST request is made with the content type `application/x-www-form-urlencoded`, the application can parse the request body and make the form data accessible through the `request.form` attribute. It verifies that the key-value pairs in the payload are correctly interpreted.\n\n**Code Being Tested and How It Works**:  \nThe test defines a simple route handler that responds to POST requests at the root URL (\"/\"). The handler does not perform any operations on the incoming request data but simply returns a text response \"OK\". The test then constructs a payload (`\"test=OK\"`) and sends it in a POST request using the `app.test_client.post` method. After the request is made, the test checks if the value associated with the key \"test\" in `request.form` is \"OK\", confirming that the form data was parsed correctly.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Setup and Teardown**: The test uses a fixture (`app`) to set up the Sanic application context, ensuring that the test runs in an isolated environment.\n- **Assertions**: The test employs assertions to validate the expected outcomes, specifically checking the contents of `request.form` to ensure the data was parsed as intended.\n- **Asynchronous Testing**: Although this specific test is synchronous, it is part of a suite that includes asynchronous tests, indicating a broader strategy to handle both synchronous and asynchronous request handling in the application."
    },
    {
      "name": "test_post_form_urlencoded_keep_blanks",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1024,
      "end_line_number": 1038,
      "source_code": "def test_post_form_urlencoded_keep_blanks(app):\n    @app.route(\"/\", methods=[\"POST\"])\n    async def handler(request):\n        request.get_form(keep_blank_values=True)\n        return text(\"OK\")\n\n    payload = \"test=\"\n    headers = {\"content-type\": \"application/x-www-form-urlencoded\"}\n\n    request, response = app.test_client.post(\n        \"/\", data=payload, headers=headers\n    )\n\n    assert request.form.get(\"test\") == \"\"\n    assert request.form.get(\"test\") == \"\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.form.get('test') == ''",
        "assert request.form.get('test') == ''"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "request.form.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "request.form.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_post_form_urlencoded_keep_blanks` test is to verify that when a POST request is made with form data containing a key with an empty value, the application correctly retains the blank value in the parsed form data.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the form data is parsed correctly, ensuring that the key \"test\" is present in the parsed form data and that its value is an empty string when the `keep_blank_values` option is set to `True`. This behavior is crucial for applications that need to handle form submissions where users may intentionally leave fields blank.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route handler for the root path (\"/\") that processes POST requests. Inside the handler, the `request.get_form(keep_blank_values=True)` method is called to parse the incoming form data. The test then simulates a POST request using `app.test_client.post`, sending a payload of `\"test=\"`, which indicates that the key \"test\" has an empty value. After the request is processed, the test asserts that `request.form.get(\"test\")` returns an empty string, confirming that the application correctly retains the blank value.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of an asynchronous route handler and the Sanic testing client to simulate HTTP requests. It also utilizes assertions to validate the expected outcomes, which is a common pattern in unit testing. The test is structured to be clear and concise, focusing on a specific aspect of form data handling, which is a good practice in unit testing to ensure that each test case is isolated and tests a single behavior. Additionally, the use of `keep_blank_values=True` demonstrates a configuration option that can affect the behavior of form data parsing, highlighting the importance of testing different configurations."
    },
    {
      "name": "test_post_form_urlencoded_drop_blanks",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1059,
      "end_line_number": 1071,
      "source_code": "def test_post_form_urlencoded_drop_blanks(app):\n    @app.route(\"/\", methods=[\"POST\"])\n    async def handler(request):\n        return text(\"OK\")\n\n    payload = \"test=\"\n    headers = {\"content-type\": \"application/x-www-form-urlencoded\"}\n\n    request, response = app.test_client.post(\n        \"/\", data=payload, headers=headers\n    )\n\n    assert \"test\" not in request.form.keys()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'test' not in request.form.keys()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_post_form_urlencoded_drop_blanks` test is designed to verify that when a POST request is made with a form payload containing a key with an empty value, the key is not included in the parsed form data. This ensures that the application correctly handles form submissions by omitting blank fields.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the key \"test\" is not present in the `request.form` dictionary when the payload is `test=`. This behavior is crucial for applications that need to ignore empty form fields to avoid processing unnecessary data.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a simple Sanic application with a POST route that returns a text response. It sends a POST request to this route with a payload of `test=` and a content type of `application/x-www-form-urlencoded`. After the request is processed, the test asserts that the key \"test\" is not found in `request.form.keys()`, confirming that the application drops blank fields.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test leverages Sanic's asynchronous capabilities, allowing for non-blocking request handling.\n- **Client Simulation**: It uses `app.test_client.post` to simulate a client making a POST request, which is a common pattern in testing web applications.\n- **Assertions**: The test employs assertions to validate the expected outcome, ensuring that the application behaves as intended when handling form data."
    },
    {
      "name": "test_post_form_multipart_form_data",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1105,
      "end_line_number": 1114,
      "source_code": "def test_post_form_multipart_form_data(app, payload):\n    @app.route(\"/\", methods=[\"POST\"])\n    async def handler(request):\n        return text(\"OK\")\n\n    headers = {\"content-type\": \"multipart/form-data; boundary=----sanic\"}\n\n    request, response = app.test_client.post(data=payload, headers=headers)\n\n    assert request.form.get(\"test\") == \"OK\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('payload', ['------sanic\\r\\nContent-Disposition: form-data; name=\"test\"\\r\\n\\r\\nOK\\r\\n------sanic--\\r\\n', '------sanic\\r\\ncontent-disposition: form-data; name=\"test\"\\r\\n\\r\\nOK\\r\\n------sanic--\\r\\n'])"
      ],
      "arguments": [
        "app",
        "payload"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.form.get('test') == 'OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "request.form.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_post_form_multipart_form_data` function is designed to verify that the Sanic application correctly handles multipart form data submissions. Specifically, it checks whether the application can parse the incoming data and retrieve the expected value associated with the \"test\" field.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a POST request is made with multipart form data, the application can successfully extract the value of the \"test\" field from the request. It asserts that the value retrieved from the request's form data matches the expected output (\"OK\").\n\n**Code Being Tested and How It Works**:  \nThe test sets up a simple route (`\"/\"`) that responds to POST requests by returning the text \"OK\". It then simulates a POST request to this route using the `app.test_client.post` method, passing in a payload that represents multipart form data. The test checks the `request.form.get(\"test\")` method to see if it retrieves the correct value. The expected behavior is that the form data is parsed correctly, and the value associated with the \"test\" key is \"OK\".\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Route Definition**: The test defines a route within the test function, allowing for isolated testing of the handler's behavior.\n- **Client Simulation**: It uses `app.test_client.post` to simulate a client making a POST request, which is a common pattern in testing web applications.\n- **Assertion**: The test employs an assertion to validate the expected outcome, ensuring that the application behaves as intended when handling multipart form data.\n- **Parameterization**: The test is designed to be run with different payloads, allowing for comprehensive testing of various multipart form data formats, which enhances test coverage and robustness."
    },
    {
      "name": "test_url_attributes_no_ssl",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1155,
      "end_line_number": 1169,
      "source_code": "def test_url_attributes_no_ssl(app, path, query, expected_url):\n    async def handler(request):\n        return text(\"OK\")\n\n    app.add_route(handler, path)\n\n    request, response = app.test_client.get(path + f\"?{query}\")\n    assert request.url == expected_url.format(HOST, request.server_port)\n\n    parsed = urlparse(request.url)\n\n    assert parsed.scheme == request.scheme\n    assert parsed.path == request.path\n    assert parsed.query == request.query_string\n    assert parsed.netloc == request.host",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('path,query,expected_url', [('/foo', '', 'http://{}:{}/foo'), ('/bar/baz', '', 'http://{}:{}/bar/baz'), ('/moo/boo', 'arg1=val1', 'http://{}:{}/moo/boo?arg1=val1')])"
      ],
      "arguments": [
        "app",
        "path",
        "query",
        "expected_url"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.url == expected_url.format(HOST, request.server_port)",
        "assert parsed.scheme == request.scheme",
        "assert parsed.path == request.path",
        "assert parsed.query == request.query_string",
        "assert parsed.netloc == request.host"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_url_attributes_no_ssl` function is designed to verify that the URL attributes generated by the Sanic application are correct when handling HTTP requests without SSL. It ensures that the request's URL, scheme, path, query string, and host are accurately constructed based on the provided parameters.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the URL returned by the request matches the expected URL format, and it validates that the individual components of the URL (scheme, path, query, and netloc) correspond to the request's attributes. This ensures that the application correctly handles routing and URL generation for non-SSL requests.\n\n**Code Being Tested and How It Works**:  \nThe test adds a route to the Sanic application that responds with \"OK\" when accessed. It then simulates a GET request to this route with a specified path and query string. The test asserts that the constructed URL matches the expected format, which includes the host and server port. It also parses the URL to verify that its components (scheme, path, query, and netloc) align with the request's attributes, ensuring that the application correctly processes and constructs URLs.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test utilizes `pytest.mark.parametrize` to run multiple scenarios with different path, query, and expected URL combinations, enhancing test coverage and reducing code duplication.\n- **Asynchronous Testing**: The test is marked with `@pytest.mark.asyncio`, indicating that it is designed to work with asynchronous code, which is common in web frameworks like Sanic.\n- **Assertions**: Multiple assertions are employed to validate different aspects of the request, ensuring comprehensive verification of the URL attributes and their correctness."
    },
    {
      "name": "test_form_with_multiple_values",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1198,
      "end_line_number": 1211,
      "source_code": "def test_form_with_multiple_values(app):\n    @app.route(\"/\", methods=[\"POST\"])\n    async def handler(request):\n        return text(\"OK\")\n\n    payload = \"selectedItems=v1&selectedItems=v2&selectedItems=v3\"\n\n    headers = {\"content-type\": \"application/x-www-form-urlencoded\"}\n\n    request, response = app.test_client.post(\n        \"/\", data=payload, headers=headers\n    )\n\n    assert request.form.getlist(\"selectedItems\") == [\"v1\", \"v2\", \"v3\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.form.getlist('selectedItems') == ['v1', 'v2', 'v3']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_form_with_multiple_values` test is to verify that the Sanic application correctly handles and processes form data submitted via a POST request, specifically when multiple values are associated with the same form field.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the application can correctly parse and retrieve multiple values for a single form field (`selectedItems`) from the request data. It ensures that the `getlist` method of the form data returns all submitted values as a list.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route handler for the root URL (\"/\") that responds to POST requests. It constructs a payload containing multiple values for the `selectedItems` field and sends this data in a POST request using the `app.test_client.post` method. After the request is processed, the test asserts that the list of values retrieved from `request.form.getlist(\"selectedItems\")` matches the expected list `[\"v1\", \"v2\", \"v3\"]`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of a test client to simulate HTTP requests, which is a common pattern in unit testing web applications. It also utilizes assertions to validate the expected outcomes, ensuring that the application behaves as intended when handling form submissions. The test is structured to be asynchronous, which is appropriate for testing an asynchronous web framework like Sanic."
    },
    {
      "name": "test_request_string_representation",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1231,
      "end_line_number": 1237,
      "source_code": "def test_request_string_representation(app):\n    @app.route(\"/\", methods=[\"GET\"])\n    async def get(request):\n        return text(\"OK\")\n\n    request, _ = app.test_client.get(\"/\")\n    assert repr(request) == \"<Request: GET />\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(request) == '<Request: GET />'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_request_string_representation` test is to verify that the string representation of a request object in the Sanic web framework correctly reflects the HTTP method and the route being accessed.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a GET request is made to the root endpoint (\"/\"), the string representation of the request object matches the expected format `<Request: GET />`. This ensures that the request object is being instantiated and represented correctly within the framework.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `app.test_client.get(\"/\")` method, which simulates a GET request to the root route defined in the Sanic application. The route handler returns a simple text response \"OK\". The test then asserts that the string representation of the request object (`repr(request)`) matches the expected output. The `repr` function is expected to provide a clear and concise representation of the request, indicating the HTTP method used.\n\n**Notable Testing Patterns or Techniques Used**:  \nThis test employs the use of assertions to validate the expected outcome, which is a common pattern in unit testing. It also utilizes the Sanic testing client to simulate HTTP requests, allowing for the testing of route handlers in isolation. The use of async functions and the Sanic framework's routing capabilities demonstrates an effective approach to testing asynchronous web applications. Additionally, the test is structured to be straightforward, focusing on a single aspect of the request object, which is a best practice in unit testing to ensure clarity and maintainability."
    },
    {
      "name": "test_request_multipart_files",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1327,
      "end_line_number": 1335,
      "source_code": "def test_request_multipart_files(app, payload, filename):\n    @app.route(\"/\", methods=[\"POST\"])\n    async def post(request):\n        return text(\"OK\")\n\n    headers = {\"content-type\": \"multipart/form-data; boundary=----sanic\"}\n\n    request, _ = app.test_client.post(data=payload, headers=headers)\n    assert request.files.get(\"test\").name == filename",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('payload,filename', [('------sanic\\r\\nContent-Disposition: form-data; filename=\"filename\"; name=\"test\"\\r\\n\\r\\nOK\\r\\n------sanic--\\r\\n', 'filename'), ('------sanic\\r\\ncontent-disposition: form-data; filename=\"filename\"; name=\"test\"\\r\\n\\r\\ncontent-type: application/json; {\"field\": \"value\"}\\r\\n------sanic--\\r\\n', 'filename'), ('------sanic\\r\\nContent-Disposition: form-data; filename=\"\"; name=\"test\"\\r\\n\\r\\nOK\\r\\n------sanic--\\r\\n', ''), ('------sanic\\r\\ncontent-disposition: form-data; filename=\"\"; name=\"test\"\\r\\n\\r\\ncontent-type: application/json; {\"field\": \"value\"}\\r\\n------sanic--\\r\\n', ''), ('------sanic\\r\\nContent-Disposition: form-data; filename*=\"utf-8\\'\\'filename_%C2%A0_test\"; name=\"test\"\\r\\n\\r\\nOK\\r\\n------sanic--\\r\\n', 'filename_\\xa0_test'), ('------sanic\\r\\ncontent-disposition: form-data; filename*=\"utf-8\\'\\'filename_%C2%A0_test\"; name=\"test\"\\r\\n\\r\\ncontent-type: application/json; {\"field\": \"value\"}\\r\\n------sanic--\\r\\n', 'filename_\\xa0_test'), ('------sanic\\r\\ncontent-disposition: form-data; filename*=\"utf-8\\'\\'filename_%C3%A4_test\"; name=\"test\"\\r\\n\\r\\nOK\\r\\n------sanic--\\r\\n', 'filename_\u00e4_test'), ('------sanic\\r\\ncontent-disposition: form-data; filename*=\"utf-8\\'\\'filename_a%CC%88_test\"; name=\"test\"\\r\\n\\r\\nOK\\r\\n------sanic--\\r\\n', 'filename_\u00e4_test')])"
      ],
      "arguments": [
        "app",
        "payload",
        "filename"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.files.get('test').name == filename"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "request.files.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_request_multipart_files` test is to verify that the application correctly handles multipart form data submissions, specifically ensuring that the uploaded file's name is accurately retrieved from the request.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a multipart form data request is made with a file included, the application can correctly access the file's metadata, particularly the filename associated with the uploaded file.\n\n**Code Being Tested and How It Works**:  \nThe test defines a POST route in the Sanic application that simply returns a text response \"OK\". It then simulates a POST request to this route using the `app.test_client.post` method, sending a multipart payload and appropriate headers. After the request is made, the test asserts that the name of the file retrieved from `request.files.get(\"test\")` matches the expected `filename` parameter.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterized Testing**: The test utilizes `pytest.mark.parametrize` to run multiple scenarios with different payloads and expected filenames, ensuring comprehensive coverage of various multipart form data formats.\n- **Asynchronous Testing**: The test is designed to work with an asynchronous framework (Sanic), which is evident from the use of `async def` for the route handler and the test function.\n- **Assertions**: The test employs assertions to validate the expected outcomes, ensuring that the application behaves as intended when processing multipart file uploads."
    },
    {
      "name": "test_request_multipart_file_with_json_content_type",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1407,
      "end_line_number": 1426,
      "source_code": "def test_request_multipart_file_with_json_content_type(app):\n    @app.route(\"/\", methods=[\"POST\"])\n    async def post(request):\n        return text(\"OK\")\n\n    payload = (\n        \"------sanic\\r\\n\"\n        'Content-Disposition: form-data; name=\"file\";'\n        ' filename=\"test.json\"\\r\\n'\n        \"Content-Type: application/json\\r\\n\"\n        \"Content-Length: 0\"\n        \"\\r\\n\"\n        \"\\r\\n\"\n        \"------sanic--\"\n    )\n\n    headers = {\"content-type\": \"multipart/form-data; boundary=------sanic\"}\n\n    request, _ = app.test_client.post(data=payload, headers=headers)\n    assert request.files.get(\"file\").type == \"application/json\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.files.get('file').type == 'application/json'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "request.files.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_request_multipart_file_with_json_content_type` is designed to verify that the Sanic application correctly handles multipart form-data requests that include a file with a JSON content type. It ensures that the application can accurately identify and process the content type of the uploaded file.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a file is uploaded with the content type set to `application/json`, the application correctly recognizes this content type when accessing the uploaded file through the request object. The assertion confirms that the type of the file retrieved from the request matches the expected content type.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `app.test_client.post` method, which simulates a POST request to the application. The payload constructed in the test represents a multipart form-data request containing a file named `test.json` with a content type of `application/json`. The test then asserts that the type of the file retrieved from `request.files` is indeed `application/json`, validating that the application processes the request correctly.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of a mock application context (`app`) to simulate the behavior of a real Sanic application. It utilizes the `test_client` to perform a POST request, which is a common pattern in unit testing web applications. The test also leverages assertions to validate the expected outcomes, ensuring that the application behaves as intended when handling multipart file uploads. Additionally, the test is structured to be asynchronous, which is a notable technique in testing frameworks that support asynchronous operations, such as Sanic."
    },
    {
      "name": "test_request_multipart_file_without_field_name",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1452,
      "end_line_number": 1475,
      "source_code": "def test_request_multipart_file_without_field_name(app, caplog):\n    @app.route(\"/\", methods=[\"POST\"])\n    async def post(request):\n        return text(\"OK\")\n\n    payload = (\n        '------sanic\\r\\nContent-Disposition: form-data; filename=\"test.json\"'\n        \"\\r\\nContent-Type: application/json\\r\\n\\r\\n\\r\\n------sanic--\"\n    )\n\n    headers = {\"content-type\": \"multipart/form-data; boundary=------sanic\"}\n\n    request, _ = app.test_client.post(\n        data=payload, headers=headers, debug=True\n    )\n    with caplog.at_level(logging.DEBUG):\n        request.form\n\n    assert caplog.record_tuples[-1] == (\n        \"sanic.root\",\n        logging.DEBUG,\n        \"Form-data field does not have a 'name' parameter \"\n        \"in the Content-Disposition header\",\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "caplog"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert caplog.record_tuples[-1] == ('sanic.root', logging.DEBUG, \"Form-data field does not have a 'name' parameter in the Content-Disposition header\")"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_request_multipart_file_without_field_name` is designed to verify the behavior of the Sanic framework when handling multipart form-data requests that lack a 'name' parameter in the Content-Disposition header. It ensures that the application correctly logs a warning message when such a malformed request is received.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a multipart file is submitted without a field name, the application logs a debug message indicating that the form-data field is missing the 'name' parameter. The assertion at the end of the test confirms that the expected log message is recorded.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the Sanic route defined for handling POST requests. The test simulates a POST request with a multipart payload that includes a file but omits the 'name' parameter in the Content-Disposition header. The `request.form` line triggers the processing of the form data, which leads to the logging of the warning message if the 'name' parameter is absent. The test checks the last recorded log entry to ensure it matches the expected warning.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `caplog` fixture from pytest to capture log messages during the test execution. This allows for verification of logging behavior without altering the actual logging configuration. Additionally, the use of an asynchronous route handler and the Sanic test client demonstrates how to test asynchronous web applications effectively. The test also utilizes a structured payload to simulate a real-world scenario, ensuring that the test is both realistic and relevant."
    },
    {
      "name": "test_request_multipart_file_duplicate_filed_name",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1478,
      "end_line_number": 1510,
      "source_code": "def test_request_multipart_file_duplicate_filed_name(app):\n    @app.route(\"/\", methods=[\"POST\"])\n    async def post(request):\n        return text(\"OK\")\n\n    payload = (\n        \"--e73ffaa8b1b2472b8ec848de833cb05b\\r\\n\"\n        'Content-Disposition: form-data; name=\"file\"\\r\\n'\n        \"Content-Type: application/octet-stream\\r\\n\"\n        \"Content-Length: 15\\r\\n\"\n        \"\\r\\n\"\n        '{\"test\":\"json\"}\\r\\n'\n        \"--e73ffaa8b1b2472b8ec848de833cb05b\\r\\n\"\n        'Content-Disposition: form-data; name=\"file\"\\r\\n'\n        \"Content-Type: application/octet-stream\\r\\n\"\n        \"Content-Length: 15\\r\\n\"\n        \"\\r\\n\"\n        '{\"test\":\"json2\"}\\r\\n'\n        \"--e73ffaa8b1b2472b8ec848de833cb05b--\\r\\n\"\n    )\n\n    headers = {\n        \"Content-Type\": \"multipart/form-data;\"\n        \" boundary=e73ffaa8b1b2472b8ec848de833cb05b\"\n    }\n\n    request, _ = app.test_client.post(\n        data=payload, headers=headers, debug=True\n    )\n    assert request.form.getlist(\"file\") == [\n        '{\"test\":\"json\"}',\n        '{\"test\":\"json2\"}',\n    ]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.form.getlist('file') == ['{\"test\":\"json\"}', '{\"test\":\"json2\"}']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the test `test_request_multipart_file_duplicate_filed_name` is to verify that the application correctly handles multipart form data when multiple files are uploaded with the same field name. Specifically, it checks that both files are accessible and correctly parsed from the request.\n\n**Specific Functionality or Behavior Verified**:  \nThis test verifies that when two files are uploaded under the same field name (\"file\"), the application can retrieve both files from the request's form data. The expected behavior is that the `request.form.getlist(\"file\")` method returns a list containing the contents of both files.\n\n**Code Being Tested and How It Works**:  \nThe code being tested includes the `app.test_client.post` method, which simulates a POST request to the application. The test sets up a route that responds to POST requests and prepares a multipart payload containing two files with the same name. The payload is structured according to the multipart/form-data specification, including boundaries and content disposition headers. After sending the request, the test asserts that the retrieved form data matches the expected list of file contents.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the following notable patterns and techniques:\n- **Asynchronous Testing**: The test is designed to work with an asynchronous framework (Sanic), which is indicated by the use of `async def` for the route handler.\n- **Multipart Form Data Simulation**: It constructs a realistic multipart form data payload to simulate file uploads, ensuring that the test closely resembles real-world usage.\n- **Assertions**: The test uses assertions to validate the output, specifically checking that the list of files retrieved from the request matches the expected values, which is a common practice in unit testing to ensure correctness."
    },
    {
      "name": "test_request_multipart_with_multiple_files_and_type",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1547,
      "end_line_number": 1565,
      "source_code": "def test_request_multipart_with_multiple_files_and_type(app):\n    @app.route(\"/\", methods=[\"POST\"])\n    async def post(request):\n        return text(\"OK\")\n\n    payload = (\n        '------sanic\\r\\nContent-Disposition: form-data; name=\"file\";'\n        ' filename=\"test.json\"'\n        \"\\r\\nContent-Type: application/json\\r\\n\\r\\n\\r\\n\"\n        '------sanic\\r\\nContent-Disposition: form-data; name=\"file\";'\n        ' filename=\"some_file.pdf\"\\r\\n'\n        \"Content-Type: application/pdf\\r\\n\\r\\n\\r\\n------sanic--\"\n    )\n    headers = {\"content-type\": \"multipart/form-data; boundary=------sanic\"}\n\n    request, _ = app.test_client.post(data=payload, headers=headers)\n    assert len(request.files.getlist(\"file\")) == 2\n    assert request.files.getlist(\"file\")[0].type == \"application/json\"\n    assert request.files.getlist(\"file\")[1].type == \"application/pdf\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(request.files.getlist('file')) == 2",
        "assert request.files.getlist('file')[0].type == 'application/json'",
        "assert request.files.getlist('file')[1].type == 'application/pdf'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the test `test_request_multipart_with_multiple_files_and_type` is to verify that the Sanic application can correctly handle multipart form-data requests containing multiple files. Specifically, it checks that the application can parse the files correctly and identify their respective content types.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies that when a POST request is made with a multipart payload containing two files, the application correctly identifies the number of files uploaded and their content types. It asserts that the number of files received is two and that the content types of the files match the expected types: `application/json` for the first file and `application/pdf` for the second.\n\n**Code Being Tested and How It Works**:  \nThe code being tested includes a route defined in the Sanic application that handles POST requests. The test sets up a multipart payload with two files and sends it to the application using the test client. The application processes the request, and the test checks the `request.files` attribute to ensure it contains the expected number of files and their correct content types. The `app.test_client.post` method simulates the request, and the assertions validate the response.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable testing patterns:\n1. **Fixture Usage**: The `app` parameter is likely a fixture that provides a test instance of the Sanic application, allowing for isolated testing of routes.\n2. **Asynchronous Testing**: The test is designed to work with asynchronous code, which is common in web frameworks like Sanic. This is evident in the use of `async def` for the route handler and the test function.\n3. **Multipart Form Data Simulation**: The test constructs a multipart form-data payload manually, which is a common technique for testing file uploads in web applications.\n4. **Assertions**: The use of assertions to validate the expected outcomes is a standard practice in unit testing, ensuring that the application behaves as intended."
    },
    {
      "name": "test_request_repr",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1590,
      "end_line_number": 1599,
      "source_code": "def test_request_repr(app):\n    @app.get(\"/\")\n    def handler(request):\n        return text(\"pass\")\n\n    request, response = app.test_client.get(\"/\")\n    assert repr(request) == \"<Request: GET />\"\n\n    request.method = None\n    assert repr(request) == \"<Request: None />\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(request) == '<Request: GET />'",
        "assert repr(request) == '<Request: None />'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_request_repr` function aims to verify the string representation of the `Request` object in the Sanic framework. It ensures that the representation accurately reflects the HTTP method of the request, both when it is set to a valid method (GET) and when it is explicitly set to `None`.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks two specific scenarios: \n1. When a GET request is made, the representation should be `<Request: GET />`.\n2. When the request method is set to `None`, the representation should change to `<Request: None />`. This verifies that the `repr` method of the `Request` class correctly formats the output based on the current state of the request.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the `app.test_client.get(\"/\")` method to simulate a GET request to the root endpoint. The `request` object returned from this call is then subjected to assertions that check its string representation. The `repr` function is expected to return a string that indicates the HTTP method of the request. The test also modifies the `request.method` attribute to `None` to validate that the representation updates accordingly.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertion Testing**: The test employs assertions to validate the expected output of the `repr` function against the actual output, ensuring correctness.\n- **Mocking with Test Client**: The use of `app.test_client.get()` simulates real HTTP requests without needing a live server, allowing for isolated unit testing of the request handling.\n- **Direct State Manipulation**: The test directly manipulates the `request.method` attribute to test the behavior of the `repr` method under different conditions, demonstrating a clear approach to testing edge cases."
    },
    {
      "name": "test_request_bool",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1615,
      "end_line_number": 1621,
      "source_code": "def test_request_bool(app):\n    @app.get(\"/\")\n    def handler(request):\n        return text(\"pass\")\n\n    request, response = app.test_client.get(\"/\")\n    assert bool(request)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert bool(request)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_request_bool` function is designed to verify that a request object is successfully created and is truthy when a GET request is made to the root endpoint (\"/\") of the Sanic application.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks the truthiness of the `request` object returned by the `app.test_client.get(\"/\")` call. It ensures that the request object is not `None` or an empty value, which indicates that the request was processed correctly.\n\n**Code Being Tested and How It Works**:  \nThe test defines a simple GET handler for the root endpoint that returns a text response \"pass\". The line `request, response = app.test_client.get(\"/\")` sends a GET request to this endpoint. The assertion `assert bool(request)` checks that the `request` object is truthy, confirming that the request was successfully created and processed.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertion of Truthiness**: The test uses a simple assertion to check the truthiness of the `request` object, which is a common pattern in unit tests to validate object creation.\n- **Minimal Setup**: The test sets up a minimal application context with a single route, demonstrating a straightforward approach to testing in a web framework.\n- **Direct Interaction with the Framework**: The test leverages the Sanic framework's test client to simulate HTTP requests, which is a standard technique for testing web applications."
    },
    {
      "name": "test_request_parsing_form_failed",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1624,
      "end_line_number": 1643,
      "source_code": "def test_request_parsing_form_failed(app, caplog):\n    @app.route(\"/\", methods=[\"POST\"])\n    async def handler(request):\n        return text(\"OK\")\n\n    payload = \"test=OK\"\n    headers = {\"content-type\": \"multipart/form-data\"}\n\n    request, response = app.test_client.post(\n        \"/\", data=payload, headers=headers\n    )\n\n    with caplog.at_level(logging.ERROR):\n        request.form\n\n    assert caplog.record_tuples[-1] == (\n        \"sanic.error\",\n        logging.ERROR,\n        \"Failed when parsing form\",\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "caplog"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert caplog.record_tuples[-1] == ('sanic.error', logging.ERROR, 'Failed when parsing form')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_request_parsing_form_failed` is designed to verify that the Sanic application correctly handles a failure when attempting to parse form data from a request with an incorrect content type. Specifically, it checks that an appropriate error message is logged when the parsing fails.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a request is made with `multipart/form-data` content type but the payload is not formatted correctly for form parsing, the application logs an error message indicating the failure. It verifies that the logging mechanism captures this error at the `ERROR` level.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `app.test_client.post` method, which simulates a POST request to the application. The test sets up a route that returns a simple \"OK\" response. It then sends a payload (`\"test=OK\"`) with the `multipart/form-data` content type. When the test accesses `request.form`, it triggers the form parsing logic. If parsing fails, it is expected to log an error message: \"Failed when parsing form\". The test checks that this message is indeed logged.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Logging Capture**: The test uses `caplog` to capture log messages generated during the execution of the test. This allows for verification of the logging output without needing to inspect the logs manually.\n- **Context Management**: The use of `with caplog.at_level(logging.ERROR)` sets the logging level to `ERROR` for the duration of the block, ensuring that only relevant log messages are captured.\n- **Assertion on Log Output**: The test asserts that the last recorded log message matches the expected error message, confirming that the application behaves as intended in error scenarios."
    },
    {
      "name": "test_request_args_no_query_string",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1669,
      "end_line_number": 1676,
      "source_code": "def test_request_args_no_query_string(app):\n    @app.get(\"/\")\n    def handler(request):\n        return text(\"pass\")\n\n    request, response = app.test_client.get(\"/\")\n\n    assert request.args == {}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.args == {}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_request_args_no_query_string` is designed to verify that when a GET request is made to the root endpoint (\"/\") without any query string parameters, the request's arguments (`request.args`) are empty.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the `request.args` attribute correctly reflects the absence of query parameters in the request. It asserts that `request.args` is an empty dictionary (`{}`) when no query string is provided.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `app.get` method, which registers a route handler for GET requests, and the `app.test_client.get` method, which simulates a GET request to the specified endpoint. In this case, the handler simply returns a text response \"pass\". The test then checks the `request.args` property of the request object returned by the test client to ensure it is empty, indicating that no query parameters were included in the request.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern to validate the expected state of the request object. It uses the `assert` statement to compare the actual output (`request.args`) with the expected output (an empty dictionary). This is a common practice in unit testing to ensure that the code behaves as intended under specific conditions. Additionally, the use of a test client to simulate requests is a typical technique in web framework testing, allowing for the isolation of request handling logic without needing to run a full server."
    },
    {
      "name": "test_request_query_args",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1690,
      "end_line_number": 1723,
      "source_code": "def test_request_query_args(app):\n    # test multiple params with the same key\n    params = [(\"test\", \"value1\"), (\"test\", \"value2\")]\n\n    @app.get(\"/\")\n    def handler(request):\n        return text(\"pass\")\n\n    request, response = app.test_client.get(\"/\", params=params)\n\n    assert request.query_args == params\n\n    # test cached value\n    assert (\n        request.parsed_not_grouped_args[(False, False, \"utf-8\", \"replace\")]\n        == request.query_args\n    )\n\n    # test params directly in the url\n    request, response = app.test_client.get(\"/?test=value1&test=value2\")\n\n    assert request.query_args == params\n\n    # test unique params\n    params = [(\"test1\", \"value1\"), (\"test2\", \"value2\")]\n\n    request, response = app.test_client.get(\"/\", params=params)\n\n    assert request.query_args == params\n\n    # test no params\n    request, response = app.test_client.get(\"/\")\n\n    assert not request.query_args",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.query_args == params",
        "assert request.parsed_not_grouped_args[False, False, 'utf-8', 'replace'] == request.query_args",
        "assert request.query_args == params",
        "assert request.query_args == params",
        "assert not request.query_args"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_request_query_args` function is designed to verify the handling of query parameters in HTTP GET requests within a Sanic web application. It ensures that the application correctly processes multiple query parameters, including those with the same key, and checks the behavior when no parameters are provided.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks several scenarios:\n1. It verifies that multiple query parameters with the same key are correctly parsed and returned.\n2. It confirms that the cached value of parsed query parameters matches the expected output.\n3. It tests the direct inclusion of query parameters in the URL.\n4. It checks the handling of unique query parameters.\n5. It ensures that when no parameters are provided, the query arguments are empty.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the Sanic application by defining a simple route handler that returns a text response. It uses the `app.test_client.get` method to simulate GET requests with various query parameters. The assertions check that the `request.query_args` attribute contains the expected parameters after each request. The test also examines the `request.parsed_not_grouped_args` to ensure it reflects the same values as `request.query_args`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses tuples to represent query parameters, allowing for easy modification and testing of different scenarios.\n- **Assertions**: Multiple assertions are employed to validate the expected outcomes after each request, ensuring comprehensive coverage of the functionality.\n- **Direct URL Testing**: The test includes a scenario where parameters are directly embedded in the URL, demonstrating the flexibility of the query parameter handling.\n- **Separation of Concerns**: The test clearly separates different cases (e.g., multiple parameters, unique parameters, no parameters) to maintain clarity and focus on specific behaviors."
    },
    {
      "name": "test_request_query_args_custom_parsing",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1763,
      "end_line_number": 1793,
      "source_code": "def test_request_query_args_custom_parsing(app):\n    @app.get(\"/\")\n    def handler(request):\n        return text(\"pass\")\n\n    request, response = app.test_client.get(\n        \"/?test1=value1&test2=&test3=value3\"\n    )\n\n    assert request.get_query_args(keep_blank_values=True) == [\n        (\"test1\", \"value1\"),\n        (\"test2\", \"\"),\n        (\"test3\", \"value3\"),\n    ]\n    assert request.query_args == [(\"test1\", \"value1\"), (\"test3\", \"value3\")]\n    assert request.get_query_args(keep_blank_values=False) == [\n        (\"test1\", \"value1\"),\n        (\"test3\", \"value3\"),\n    ]\n\n    assert request.get_args(keep_blank_values=True) == RequestParameters(\n        {\"test1\": [\"value1\"], \"test2\": [\"\"], \"test3\": [\"value3\"]}\n    )\n\n    assert request.args == RequestParameters(\n        {\"test1\": [\"value1\"], \"test3\": [\"value3\"]}\n    )\n\n    assert request.get_args(keep_blank_values=False) == RequestParameters(\n        {\"test1\": [\"value1\"], \"test3\": [\"value3\"]}\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.get_query_args(keep_blank_values=True) == [('test1', 'value1'), ('test2', ''), ('test3', 'value3')]",
        "assert request.query_args == [('test1', 'value1'), ('test3', 'value3')]",
        "assert request.get_query_args(keep_blank_values=False) == [('test1', 'value1'), ('test3', 'value3')]",
        "assert request.get_args(keep_blank_values=True) == RequestParameters({'test1': ['value1'], 'test2': [''], 'test3': ['value3']})",
        "assert request.args == RequestParameters({'test1': ['value1'], 'test3': ['value3']})",
        "assert request.get_args(keep_blank_values=False) == RequestParameters({'test1': ['value1'], 'test3': ['value3']})"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_request_query_args_custom_parsing` test is to verify the correct parsing and retrieval of query parameters from a request in a Sanic web application. It ensures that both blank and non-blank query parameters are handled appropriately.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks the behavior of the request object in terms of:\n- Retrieving query parameters while keeping blank values.\n- Retrieving query parameters without keeping blank values.\n- Ensuring that the parameters are returned in the expected format, both as tuples and as `RequestParameters` objects.\n\n**Code Being Tested and How It Works**:  \nThe code being tested includes the `get_query_args` and `get_args` methods of the request object. The test simulates a GET request to the root endpoint (`\"/\"`) with a query string containing three parameters: `test1`, `test2`, and `test3`. The expected behavior is that:\n- `get_query_args(keep_blank_values=True)` returns all parameters, including those with blank values.\n- `query_args` and `get_query_args(keep_blank_values=False)` return only non-blank parameters.\n- `get_args` provides a structured representation of the parameters, encapsulated in a `RequestParameters` object.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable testing patterns:\n- **Parameterization**: It tests various scenarios of query parameter retrieval by changing the `keep_blank_values` flag.\n- **Assertions**: Multiple assertions are used to validate the output against expected results, ensuring comprehensive coverage of the functionality.\n- **Simulated Requests**: The use of `app.test_client.get` allows for simulating HTTP requests, which is a common practice in testing web applications to verify endpoint behavior without needing a live server."
    },
    {
      "name": "test_request_cookies",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1830,
      "end_line_number": 1840,
      "source_code": "def test_request_cookies(app):\n    cookies = {\"test\": \"OK\"}\n\n    @app.get(\"/\")\n    def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/\", cookies=cookies)\n\n    assert len(request.cookies) == len(cookies)\n    assert request.cookies[\"test\"] == cookies[\"test\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(request.cookies) == len(cookies)",
        "assert request.cookies['test'] == cookies['test']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_request_cookies` function is designed to verify that the Sanic application correctly handles and retrieves cookies sent with an HTTP request. It ensures that the cookies are accessible in the request object and that their values match the expected values.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the cookies included in the request are correctly parsed and stored in the request object. It asserts that the number of cookies received matches the number sent and that the value of a specific cookie (\"test\") is as expected (\"OK\").\n\n**Code Being Tested and How It Works**:  \nThe test sets up a simple Sanic application with a single route (\"/\") that returns a text response. It uses the `app.test_client.get` method to simulate an HTTP GET request to this route, including a dictionary of cookies. The request object is then checked to ensure that it contains the correct number of cookies and that the value of the \"test\" cookie is \"OK\". The relevant methods being tested are `app.get` for defining the route and `app.test_client.get` for making the request.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern to validate the expected outcomes. It uses the `assert` statement to check conditions, which is a common practice in unit testing to ensure that the actual results match the expected results. Additionally, the test leverages the Sanic testing client to simulate requests, allowing for isolated testing of the application's behavior without needing to run a full server. This approach is efficient for unit tests, as it focuses on specific functionalities in a controlled environment."
    },
    {
      "name": "test_request_cookies_without_cookies",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1857,
      "end_line_number": 1864,
      "source_code": "def test_request_cookies_without_cookies(app):\n    @app.get(\"/\")\n    def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/\")\n\n    assert request.cookies == {}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.cookies == {}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_request_cookies_without_cookies` is designed to verify that when a request is made without any cookies, the `cookies` attribute of the request object is an empty dictionary. This ensures that the application correctly handles requests that do not include any cookie data.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that the `cookies` property of the request object returns an empty dictionary (`{}`) when no cookies are sent in the request. This behavior is crucial for ensuring that the application does not erroneously assume the presence of cookies when they are not provided.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `app.get` method, which defines a simple route handler that returns a text response \"OK\". The test client then makes a GET request to this route. The `request` object is expected to have its `cookies` property accessed, which internally calls the `get_cookies` method to parse cookies from the request headers. Since no cookies are sent, the `cookies` property should return an empty dictionary.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern, using `assert` to compare the actual output (`request.cookies`) with the expected output (an empty dictionary). This is a common practice in unit testing to validate that the code behaves as intended. Additionally, the use of a test client to simulate HTTP requests is a notable technique, allowing for the testing of request handling in a controlled environment. The test is also structured to be simple and focused, which is a best practice in unit testing to ensure clarity and maintainability."
    },
    {
      "name": "test_request_port",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1878,
      "end_line_number": 1886,
      "source_code": "def test_request_port(app):\n    @app.get(\"/\")\n    def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/\")\n\n    port = request.port\n    assert isinstance(port, int)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(port, int)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_request_port` function aims to verify that the `port` attribute of the `request` object returned by the Sanic application is of the correct type (an integer). This is essential for ensuring that the application correctly identifies the port from which the request was made.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that the `port` attribute of the `request` object is an integer. This is a fundamental aspect of request handling, as it confirms that the application can accurately capture and represent the port information associated with incoming requests.\n\n**Code Being Tested and How It Works**:  \nThe test defines a simple route handler for the root path (\"/\") that returns a text response \"OK\". It then uses the `app.test_client.get(\"/\")` method to simulate a GET request to this route. The `request` object returned from this call is expected to have a `port` attribute, which the test checks to ensure it is an integer. The relevant code being tested includes the `app.get` method for defining routes and the `app.test_client.get` method for simulating requests.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern using `assert isinstance(port, int)` to validate the type of the `port` attribute. This is a common technique in unit testing to ensure that the output of a function or method meets expected type constraints. Additionally, the use of a test client to simulate requests is a standard practice in web application testing, allowing for the verification of request handling without needing to run a full server instance."
    },
    {
      "name": "test_request_socket",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1901,
      "end_line_number": 1915,
      "source_code": "def test_request_socket(app):\n    @app.get(\"/\")\n    def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/\")\n\n    socket = request.socket\n    assert isinstance(socket, tuple)\n\n    ip = socket[0]\n    port = socket[1]\n\n    assert ip == request.ip\n    assert port == request.port",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(socket, tuple)",
        "assert ip == request.ip",
        "assert port == request.port"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_request_socket` function is designed to verify that the socket information associated with a request in a Sanic web application is correctly represented as a tuple containing the IP address and port number. This ensures that the request handling mechanism accurately captures and exposes the underlying network details.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the `request.socket` attribute is a tuple and that its elements (IP and port) match the corresponding `request.ip` and `request.port` attributes. This confirms that the request object correctly reflects the connection details from which the request originated.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a simple Sanic application with a single route that returns a text response. It then uses the `app.test_client.get(\"/\")` method to simulate a GET request to the root endpoint. The `request` object returned from this call contains the `socket` attribute, which is expected to be a tuple. The test extracts the IP and port from this tuple and asserts that they match the values in `request.ip` and `request.port`, respectively.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Setup and Teardown**: The test uses a fixture (`app`) to set up the Sanic application context, ensuring that the test runs in a controlled environment.\n- **Assertions**: The test employs assertions to validate the expected outcomes, specifically checking the type of the socket and the equality of IP and port values.\n- **Isolation**: The test is isolated from other tests, focusing solely on the socket information, which helps in pinpointing issues related to request handling without interference from other functionalities."
    },
    {
      "name": "test_request_server_name",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1918,
      "end_line_number": 1924,
      "source_code": "def test_request_server_name(app):\n    @app.get(\"/\")\n    def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/\")\n    assert request.server_name == \"127.0.0.1\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.server_name == '127.0.0.1'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_request_server_name` unit test is designed to verify that the `server_name` attribute of the request object correctly reflects the server's address when a request is made to the application. Specifically, it checks that the default server name is set to \"127.0.0.1\" when the request is made without any custom headers.\n\n**Specific Functionality or Behavior Verified**:  \nThis test confirms that the `server_name` property of the request object is accurately populated based on the incoming request's context. It ensures that the application correctly identifies the server's address as \"127.0.0.1\" for requests made to the root endpoint (\"/\") without any modifications to the request headers.\n\n**Code Being Tested and How It Works**:  \nThe test defines a simple route handler for the root path (\"/\") that returns a text response \"OK\". It then uses the `app.test_client.get(\"/\")` method to simulate a GET request to this endpoint. The request object returned from this call is checked to ensure that its `server_name` attribute equals \"127.0.0.1\". This behavior is expected because the test client simulates requests as if they are coming from the local machine.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Test Client Usage**: The test utilizes the `app.test_client` to simulate HTTP requests, which is a common pattern in testing web applications to isolate and verify specific behaviors without needing a live server.\n- **Assertion**: The test employs a straightforward assertion to validate the expected outcome, which is a fundamental practice in unit testing to ensure that the actual behavior matches the expected behavior.\n- **Route Definition**: The test dynamically defines a route within the test function, showcasing a technique where tests can set up their own context and behavior, allowing for isolated and specific testing scenarios."
    },
    {
      "name": "test_request_server_name_in_host_header",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1927,
      "end_line_number": 1945,
      "source_code": "def test_request_server_name_in_host_header(app):\n    @app.get(\"/\")\n    def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\n        \"/\", headers={\"Host\": \"my-server:5555\"}\n    )\n    assert request.server_name == \"my-server\"\n\n    request, response = app.test_client.get(\n        \"/\", headers={\"Host\": \"[2a00:1450:400f:80c::200e]:5555\"}\n    )\n    assert request.server_name == \"[2a00:1450:400f:80c::200e]\"\n\n    request, response = app.test_client.get(\n        \"/\", headers={\"Host\": \"mal_formed\"}\n    )\n    assert request.server_name == \"\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.server_name == 'my-server'",
        "assert request.server_name == '[2a00:1450:400f:80c::200e]'",
        "assert request.server_name == ''"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_request_server_name_in_host_header` is designed to verify that the `server_name` attribute of the request object correctly reflects the value specified in the `Host` header of incoming HTTP requests. This ensures that the application can accurately identify the server name from the request headers.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks three scenarios:\n1. When the `Host` header is set to a valid hostname (`my-server:5555`), the `server_name` should be extracted as `my-server`.\n2. When the `Host` header contains an IPv6 address (`[2a00:1450:400f:80c::200e]:5555`), the `server_name` should be the IPv6 address without the port.\n3. When the `Host` header is malformed (`mal_formed`), the `server_name` should be an empty string, indicating that the application correctly handles invalid input.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the Sanic framework's routing and request handling capabilities. The `app.get(\"/\")` decorator defines a simple route that returns a text response. The `app.test_client.get` method simulates HTTP GET requests to this route, allowing the test to inspect the `request` object returned. The `server_name` attribute is expected to be populated based on the `Host` header provided in the request.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses multiple assertions to cover different scenarios, ensuring comprehensive coverage of the `Host` header's behavior.\n- **Isolation**: Each request is made independently, allowing for clear verification of the `server_name` attribute without interference from other tests.\n- **Assertions**: The use of assertions to validate the expected outcomes against the actual results is a standard practice in unit testing, ensuring that the code behaves as intended under various conditions."
    },
    {
      "name": "test_request_server_name_forwarded",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1948,
      "end_line_number": 1962,
      "source_code": "def test_request_server_name_forwarded(app):\n    @app.get(\"/\")\n    def handler(request):\n        return text(\"OK\")\n\n    app.config.PROXIES_COUNT = 1\n    request, response = app.test_client.get(\n        \"/\",\n        headers={\n            \"Host\": \"my-server:5555\",\n            \"X-Forwarded-For\": \"127.1.2.3\",\n            \"X-Forwarded-Host\": \"your-server\",\n        },\n    )\n    assert request.server_name == \"your-server\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.server_name == 'your-server'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_request_server_name_forwarded` test is to verify that the Sanic application correctly interprets the `X-Forwarded-Host` header when the application is behind a proxy. This ensures that the server name used in the request context reflects the intended host as specified by the forwarded headers.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a request is made with the `X-Forwarded-Host` header set to \"your-server\", the `request.server_name` attribute is correctly set to \"your-server\", overriding the default behavior that would use the `Host` header.\n\n**Code Being Tested and How It Works**:  \nThe code being tested involves the Sanic framework's request handling mechanism. The test sets up a simple route that returns \"OK\" and configures the application to recognize one proxy (`app.config.PROXIES_COUNT = 1`). When the test client makes a GET request to the root endpoint (\"/\") with specific headers, the application processes these headers to determine the server name. The assertion checks that `request.server_name` equals \"your-server\", which is derived from the `X-Forwarded-Host` header.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of a test client to simulate HTTP requests, allowing for the verification of request attributes in a controlled environment. It also utilizes header manipulation to simulate real-world scenarios where applications are deployed behind proxies. The use of assertions to validate the expected outcome is a standard practice in unit testing, ensuring that the application behaves as intended under specific conditions."
    },
    {
      "name": "test_request_server_port",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1965,
      "end_line_number": 1972,
      "source_code": "def test_request_server_port(app):\n    @app.get(\"/\")\n    def handler(request):\n        return text(\"OK\")\n\n    test_client = SanicTestClient(app)\n    request, response = test_client.get(\"/\", headers={\"Host\": \"my-server\"})\n    assert request.server_port == 80",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.server_port == 80"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_request_server_port` unit test is designed to verify that the `server_port` attribute of the request object correctly reflects the expected port number when a request is made to the server. Specifically, it checks that the server port is set to 80 when the request is made with a specific host header.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the `server_port` property of the request object is accurately populated based on the incoming request's context. It confirms that the server correctly interprets the request's host header and assigns the appropriate default port (80) when no specific port is provided in the request.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a simple Sanic application with a single route (`\"/\"`) that returns a text response of \"OK\". It then creates an instance of `SanicTestClient`, which is used to simulate a GET request to the root endpoint. The request is made with a custom host header (`\"Host\": \"my-server\"`). After the request is processed, the test asserts that the `server_port` attribute of the request object equals 80, indicating that the server correctly identified the default port for HTTP requests.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking and Simulation**: The test uses `SanicTestClient` to simulate HTTP requests, allowing for controlled testing of the application without needing to run a live server.\n- **Assertion**: The test employs an assertion to validate the expected outcome, ensuring that the `server_port` is set correctly based on the request context.\n- **Minimal Setup**: The test is concise, focusing only on the necessary components (route handler and request simulation) to verify the specific behavior being tested, which enhances readability and maintainability."
    },
    {
      "name": "test_request_server_port_in_host_header",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1975,
      "end_line_number": 1996,
      "source_code": "def test_request_server_port_in_host_header(app):\n    @app.get(\"/\")\n    def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\n        \"/\", headers={\"Host\": \"my-server:5555\"}\n    )\n    assert request.server_port == 5555\n\n    request, response = app.test_client.get(\n        \"/\", headers={\"Host\": \"[2a00:1450:400f:80c::200e]:5555\"}\n    )\n    assert request.server_port == 5555\n\n    request, response = app.test_client.get(\n        \"/\", headers={\"Host\": \"mal_formed:5555\"}\n    )\n    if PORT is None:\n        assert request.server_port != 5555\n    else:\n        assert request.server_port == app.test_client.port",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.server_port == 5555",
        "assert request.server_port == 5555",
        "assert request.server_port != 5555",
        "assert request.server_port == app.test_client.port"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_request_server_port_in_host_header` is designed to verify that the server correctly extracts and assigns the port number from the `Host` header in incoming HTTP requests. This ensures that the application can accurately identify the port being used by the client, which is crucial for handling requests properly in a multi-port environment.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks three scenarios:\n1. When the `Host` header specifies a valid hostname with a port (e.g., `my-server:5555`), the server should correctly identify the port as `5555`.\n2. It verifies that the server can handle IPv6 addresses in the `Host` header (e.g., `[2a00:1450:400f:80c::200e]:5555`) and still extract the port correctly.\n3. It tests a malformed `Host` header (e.g., `mal_formed:5555`) to ensure that the server behaves correctly based on the configuration of the `PORT` variable, either confirming that the port is not `5555` or matching it with the test client\u2019s port.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `app` object, which is an instance of a Sanic application. It defines a simple route handler that returns a text response. The test client (`app.test_client`) is used to simulate HTTP GET requests with custom headers. The `request` object returned from the test client contains the `server_port` attribute, which is asserted against expected values based on the `Host` header provided in the requests.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterized Testing**: The test uses different headers to cover various scenarios, ensuring robustness against different input formats.\n- **Assertions**: The test employs assertions to validate the expected behavior of the `server_port` attribute, which is a common practice in unit testing to confirm that the code behaves as intended.\n- **Conditional Logic**: The test includes conditional assertions based on the value of the `PORT` variable, demonstrating adaptability in testing based on configuration settings. This allows the test to handle different environments or setups gracefully."
    },
    {
      "name": "test_request_server_port_forwarded",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1999,
      "end_line_number": 2013,
      "source_code": "def test_request_server_port_forwarded(app):\n    @app.get(\"/\")\n    def handler(request):\n        return text(\"OK\")\n\n    app.config.PROXIES_COUNT = 1\n    request, response = app.test_client.get(\n        \"/\",\n        headers={\n            \"Host\": \"my-server:5555\",\n            \"X-Forwarded-For\": \"127.1.2.3\",\n            \"X-Forwarded-Port\": \"4444\",\n        },\n    )\n    assert request.server_port == 4444",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.server_port == 4444"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_request_server_port_forwarded` is designed to verify that the Sanic application correctly interprets the `X-Forwarded-Port` header when the application is behind a proxy. Specifically, it checks that the server port reported in the request matches the port specified in the `X-Forwarded-Port` header.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a request is made with the `X-Forwarded-Port` header set to `4444`, the application correctly sets the `request.server_port` attribute to `4444`. This is crucial for applications that rely on forwarded headers to determine the original request's context, especially in a proxied environment.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `app.test_client.get` method, which simulates an HTTP GET request to the application. The request is made to the root endpoint (\"/\") with specific headers, including `X-Forwarded-Port`. The application is configured to recognize one proxy (`app.config.PROXIES_COUNT = 1`), which allows it to process the forwarded headers. The assertion checks that the `request.server_port` is set to the value provided in the `X-Forwarded-Port` header.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of a test client to simulate HTTP requests, which is a common pattern in unit testing web applications. It also utilizes assertions to validate the expected behavior of the application. The configuration of the application (setting `PROXIES_COUNT`) before making the request is a notable technique that ensures the application behaves as it would in a real-world scenario where it is behind a proxy. This setup allows for isolated testing of the application's handling of forwarded headers."
    },
    {
      "name": "test_request_form_invalid_content_type",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 2016,
      "end_line_number": 2023,
      "source_code": "def test_request_form_invalid_content_type(app):\n    @app.route(\"/\", methods=[\"POST\"])\n    async def post(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.post(\"/\", json={\"test\": \"OK\"})\n\n    assert request.form == {}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.form == {}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_request_form_invalid_content_type` test is designed to verify that when a request is made with an invalid content type (in this case, JSON), the form data is not parsed and remains empty. This ensures that the application correctly handles requests that do not conform to expected content types.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the `request.form` attribute is an empty dictionary (`{}`) when a JSON payload is sent in a POST request. This behavior confirms that the application does not attempt to parse the JSON data as form data, which is the expected behavior when the content type is not `application/x-www-form-urlencoded`.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `app.test_client.post` method, which simulates a POST request to the application. The route defined in the test (`@app.route(\"/\", methods=[\"POST\"])`) simply returns a text response of \"OK\". The test sends a JSON payload (`json={\"test\": \"OK\"}`) and checks the `request.form` attribute. Since the content type is not suitable for form data, `request.form` should remain empty.\n\n**Notable Testing Patterns or Techniques Used**:  \nThis test employs the use of a test client to simulate HTTP requests, which is a common pattern in unit testing web applications. It also utilizes assertions to validate the state of the `request.form` attribute, ensuring that the application behaves as expected under specific conditions. The test is structured to be straightforward, focusing on a single aspect of functionality, which is a best practice in unit testing to maintain clarity and ease of debugging."
    },
    {
      "name": "test_server_name_and_url_for",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 2026,
      "end_line_number": 2040,
      "source_code": "def test_server_name_and_url_for(app):\n    @app.get(\"/foo\")\n    def handler(request):\n        return text(\"ok\")\n\n    app.config.SERVER_NAME = \"my-server\"  # This means default port\n    assert app.url_for(\"handler\", _external=True) == \"http://my-server/foo\"\n    request, response = app.test_client.get(\"/foo\")\n    assert request.url_for(\"handler\") == \"http://my-server/foo\"\n\n    app.config.SERVER_NAME = \"https://my-server/path\"\n    request, response = app.test_client.get(\"/foo\")\n    url = \"https://my-server/path/foo\"\n    assert app.url_for(\"handler\", _external=True) == url\n    assert request.url_for(\"handler\") == url",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.url_for('handler', _external=True) == 'http://my-server/foo'",
        "assert request.url_for('handler') == 'http://my-server/foo'",
        "assert app.url_for('handler', _external=True) == url",
        "assert request.url_for('handler') == url"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "request.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "request.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_server_name_and_url_for` function is designed to verify that the Sanic application correctly constructs URLs based on the server name configuration. It ensures that the application can generate both external and internal URLs that reflect the expected server name and path.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main behaviors: \n1. When the `SERVER_NAME` is set to a simple hostname, the generated URL for the route `/foo` should match the expected format with the default port.\n2. When the `SERVER_NAME` includes a full URL (including a path), the generated URL should reflect this configuration accurately, ensuring that both external and internal URL generation methods (`app.url_for` and `request.url_for`) yield the same results.\n\n**Code Being Tested and How It Works**:  \nThe test defines a simple route `/foo` that returns a text response \"ok\". It then manipulates the `SERVER_NAME` configuration of the app to test different scenarios:\n- First, it sets `SERVER_NAME` to \"my-server\" and checks that the URL generated for the handler matches \"http://my-server/foo\".\n- Next, it changes `SERVER_NAME` to \"https://my-server/path\" and verifies that the URL generated reflects this new configuration. The assertions confirm that both `app.url_for` and `request.url_for` produce the expected URLs.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses different configurations of `SERVER_NAME` to validate the URL generation under varying conditions.\n- **Assertions**: It employs assertions to validate that the generated URLs match expected values, ensuring that both external and internal URL generation methods are functioning correctly.\n- **Isolation**: The test is isolated to a single route and configuration, allowing for focused testing of URL generation without interference from other parts of the application."
    },
    {
      "name": "test_url_for_with_forwarded_request",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 2043,
      "end_line_number": 2079,
      "source_code": "def test_url_for_with_forwarded_request(app):\n    @app.get(\"/\")\n    def handler(request):\n        return text(\"OK\")\n\n    @app.get(\"/another_view/\")\n    def view_name(request):\n        return text(\"OK\")\n\n    app.config.SERVER_NAME = \"my-server\"\n    app.config.PROXIES_COUNT = 1\n    request, response = app.test_client.get(\n        \"/\",\n        headers={\n            \"X-Forwarded-For\": \"127.1.2.3\",\n            \"X-Forwarded-Proto\": \"https\",\n            \"X-Forwarded-Port\": \"6789\",\n        },\n    )\n    assert app.url_for(\"view_name\") == \"/another_view\"\n    assert (\n        app.url_for(\"view_name\", _external=True)\n        == \"http://my-server/another_view\"\n    )\n    assert (\n        request.url_for(\"view_name\") == \"https://my-server:6789/another_view\"\n    )\n\n    request, response = app.test_client.get(\n        \"/\",\n        headers={\n            \"X-Forwarded-For\": \"127.1.2.3\",\n            \"X-Forwarded-Proto\": \"https\",\n            \"X-Forwarded-Port\": \"443\",\n        },\n    )\n    assert request.url_for(\"view_name\") == \"https://my-server/another_view\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.url_for('view_name') == '/another_view'",
        "assert app.url_for('view_name', _external=True) == 'http://my-server/another_view'",
        "assert request.url_for('view_name') == 'https://my-server:6789/another_view'",
        "assert request.url_for('view_name') == 'https://my-server/another_view'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "request.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "request.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_url_for_with_forwarded_request` is designed to verify that the Sanic application correctly constructs URLs based on forwarded request headers. It ensures that the application can accurately generate URLs that reflect the original request's context, including the server name, protocol, and port, when requests are proxied.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks the behavior of the `url_for` method in different scenarios, specifically:\n1. Generating a relative URL for a view function (`view_name`).\n2. Generating an external URL that includes the server name and protocol.\n3. Ensuring that the request context correctly reflects the forwarded headers, particularly the `X-Forwarded-Proto` and `X-Forwarded-Port`.\n\n**Code Being Tested and How It Works**:  \nThe test sets up two route handlers (`handler` and `view_name`) and configures the application with a server name and proxy count. It then simulates a GET request to the root endpoint with specific headers that indicate the original request's IP, protocol, and port. The assertions check:\n- The relative URL generated by `app.url_for(\"view_name\")`.\n- The external URL generated by `app.url_for(\"view_name\", _external=True)`.\n- The URL generated by `request.url_for(\"view_name\")` based on the forwarded headers.\n\nThe test is repeated with different `X-Forwarded-Port` values to ensure consistent behavior.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking and Stubbing**: The test uses the Sanic test client to simulate HTTP requests, allowing for controlled testing of the application\u2019s routing and URL generation without needing a live server.\n- **Assertions**: Multiple assertions are employed to validate the correctness of URL generation under different conditions, ensuring that the application behaves as expected in various scenarios.\n- **Header Manipulation**: The test leverages HTTP headers to simulate real-world scenarios where requests are forwarded through proxies, which is common in production environments. This helps ensure that the application can handle such cases correctly."
    },
    {
      "name": "test_endpoint_basic",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 2093,
      "end_line_number": 2102,
      "source_code": "def test_endpoint_basic():\n    app = Sanic(name=\"Test\")\n\n    @app.route(\"/\")\n    def my_unique_handler(request):\n        return text(\"Hello\")\n\n    request, response = app.test_client.get(\"/\")\n\n    assert request.endpoint == \"Test.my_unique_handler\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.endpoint == 'Test.my_unique_handler'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_endpoint_basic` function is designed to verify that a basic HTTP GET request to the root endpoint (\"/\") of a Sanic application correctly invokes the associated request handler and that the endpoint is correctly identified.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a GET request is made to the root URL, the request's endpoint is correctly set to the handler's name, which in this case is \"Test.my_unique_handler\". This ensures that the routing mechanism of the Sanic application is functioning as expected.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the Sanic application instance and its routing mechanism. The `app.route(\"/\")` decorator registers the `my_unique_handler` function to handle GET requests to the root URL. The `app.test_client.get(\"/\")` method simulates a GET request to this endpoint, returning a request and response object. The assertion checks that the `request.endpoint` matches the expected endpoint name.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Direct Assertion**: The test uses a direct assertion to verify the expected outcome, which is a common practice in unit testing to ensure that the actual behavior matches the expected behavior.\n- **Test Client**: The use of `app.test_client.get()` allows for simulating requests to the application without needing to run a server, making it efficient for testing routing and request handling.\n- **Anonymous Function**: The handler is defined inline, showcasing the flexibility of defining routes in Sanic applications."
    },
    {
      "name": "test_endpoint_named_app",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 2118,
      "end_line_number": 2127,
      "source_code": "def test_endpoint_named_app():\n    app = Sanic(\"named\")\n\n    @app.route(\"/\")\n    def my_unique_handler(request):\n        return text(\"Hello\")\n\n    request, response = app.test_client.get(\"/\")\n\n    assert request.endpoint == \"named.my_unique_handler\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.endpoint == 'named.my_unique_handler'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_endpoint_named_app` unit test is designed to verify that the Sanic application correctly associates a route with a specific endpoint name. This ensures that the routing mechanism of the Sanic framework is functioning as expected.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when a GET request is made to the root endpoint (\"/\"), the request object contains the correct endpoint name, which should be formatted as \"named.my_unique_handler\". This confirms that the application correctly identifies and names the handler associated with the route.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves creating a Sanic application instance named \"named\" and defining a route (\"/\") that is handled by the `my_unique_handler` function. The `app.test_client.get(\"/\")` method simulates a GET request to this route, returning a request and response object. The assertion `assert request.endpoint == \"named.my_unique_handler\"` checks if the endpoint name is correctly set.\n\n**Notable Testing Patterns or Techniques Used**:  \nThis test employs a straightforward approach to unit testing by using assertions to validate expected outcomes. It utilizes the Sanic testing client to simulate HTTP requests, which is a common pattern in testing web applications. The test is synchronous, making it simple and easy to understand, while also ensuring that the routing and endpoint naming conventions are correctly implemented in the application."
    },
    {
      "name": "test_endpoint_blueprint",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 2143,
      "end_line_number": 2155,
      "source_code": "def test_endpoint_blueprint():\n    bp = Blueprint(\"my_blueprint\", url_prefix=\"/bp\")\n\n    @bp.route(\"/\")\n    async def bp_root(request):\n        return text(\"Hello\")\n\n    app = Sanic(\"named\")\n    app.blueprint(bp)\n\n    request, response = app.test_client.get(\"/bp\")\n\n    assert request.endpoint == \"named.my_blueprint.bp_root\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.endpoint == 'named.my_blueprint.bp_root'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_endpoint_blueprint` function is designed to verify that a Sanic application correctly registers and routes requests to an endpoint defined within a blueprint. It ensures that the endpoint can be accessed via the specified URL and that the request is correctly associated with the expected endpoint name.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a GET request is made to the `/bp` URL, the request's endpoint is correctly identified as `named.my_blueprint.bp_root`. This confirms that the blueprint's routing mechanism is functioning as intended and that the endpoint is properly registered under the expected name.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves creating a Sanic application and a blueprint. The blueprint is defined with a URL prefix of `/bp`, and a route is added to it that responds to GET requests at the root of the blueprint (`/`). The test then simulates a GET request to `/bp` using the application's test client. The response is not directly checked, but the test asserts that the `request.endpoint` matches the expected endpoint name, which is derived from the application and blueprint context.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Blueprint Usage**: The test demonstrates the use of blueprints in Sanic, which allows for modular organization of routes and handlers.\n- **Test Client**: It utilizes the `app.test_client` to simulate HTTP requests, which is a common pattern in testing web applications to verify routing and response behavior.\n- **Asynchronous Handling**: Although the test itself is synchronous, it is set up in a context where asynchronous routes could be tested, indicating readiness for async behavior in the application.\n- **Endpoint Assertion**: The test asserts the `request.endpoint`, which is a common practice to ensure that the routing logic correctly associates requests with their defined handlers."
    },
    {
      "name": "test_url_for_without_server_name",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 2174,
      "end_line_number": 2187,
      "source_code": "def test_url_for_without_server_name(app):\n    @app.route(\"/sample\")\n    def sample(request):\n        return json({\"url\": request.url_for(\"url_for\")})\n\n    @app.route(\"/url-for\")\n    def url_for(request):\n        return text(\"url-for\")\n\n    request, response = app.test_client.get(\"/sample\")\n    assert (\n        response.json[\"url\"]\n        == f\"http://127.0.0.1:{request.server_port}/url-for\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json['url'] == f'http://127.0.0.1:{request.server_port}/url-for'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "request.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_url_for_without_server_name` verifies that the Sanic application correctly constructs a URL for a given endpoint when the server name is not explicitly set in the application configuration. It ensures that the generated URL reflects the expected format based on the request's context.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks the behavior of the `request.url_for` method when generating a URL for the \"url_for\" endpoint. It asserts that the URL returned matches the expected format, which includes the server's IP address and port, confirming that the application can dynamically generate URLs based on the current request context.\n\n**Code Being Tested and How It Works**:  \nThe test defines two routes: `/sample` and `/url-for`. The `/sample` route calls `request.url_for(\"url_for\")`, which generates the URL for the `/url-for` endpoint. The test then makes a GET request to `/sample` and checks that the JSON response contains the correct URL, formatted as `http://127.0.0.1:{request.server_port}/url-for`. The `request.server_port` dynamically retrieves the port used in the request, ensuring the URL is accurate.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the output against expected values, a common practice in unit testing. It also utilizes the Sanic testing client to simulate HTTP requests, allowing for the verification of route behavior in a controlled environment. The test is structured to be clear and concise, focusing on a single aspect of functionality, which is a best practice in unit testing to ensure that tests are easy to understand and maintain."
    },
    {
      "name": "test_safe_method_with_body_ignored",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 2190,
      "end_line_number": 2204,
      "source_code": "def test_safe_method_with_body_ignored(app):\n    @app.get(\"/\")\n    async def handler(request):\n        return text(\"OK\")\n\n    payload = {\"test\": \"OK\"}\n    headers = {\"content-type\": \"application/json\"}\n\n    request, response = app.test_client.request(\n        \"/\", http_method=\"get\", data=json_dumps(payload), headers=headers\n    )\n\n    assert request.body == b\"\"\n    assert request.json is None\n    assert response.body == b\"OK\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.body == b''",
        "assert request.json is None",
        "assert response.body == b'OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.request",
          "body": "@app.on_request\ndef request(_):\n    nonlocal request_middleware_run_count\n    request_middleware_run_count += 1"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_safe_method_with_body_ignored` test is to verify that when a safe HTTP method (GET) is used, the request body is ignored, and the response is correctly returned without any body content.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that:\n1. The request body is empty (`request.body == b\"\"`).\n2. The JSON representation of the request is `None` (`request.json is None`).\n3. The response body contains the expected text \"OK\" (`response.body == b\"OK\"`).\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `app.get` method, which defines a route handler that returns a simple text response. The test simulates a GET request to this route using the `app.test_client.request` method, passing a JSON payload and headers. However, since GET requests are not supposed to have a body, the test checks that the body is ignored and the response is as expected.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Isolation of Test Cases**: The test defines its own route handler within the test function, ensuring that it does not interfere with other tests.\n- **Assertions**: The use of assertions to validate the state of the request and response is a common pattern in unit testing, ensuring that the behavior of the application matches expectations.\n- **Mocking HTTP Requests**: The test utilizes a test client to simulate HTTP requests, allowing for controlled testing of the application's routing and response behavior without needing a live server."
    },
    {
      "name": "test_safe_method_with_body",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 2207,
      "end_line_number": 2221,
      "source_code": "def test_safe_method_with_body(app):\n    @app.get(\"/\", ignore_body=False)\n    async def handler(request):\n        return text(\"OK\")\n\n    payload = {\"test\": \"OK\"}\n    headers = {\"content-type\": \"application/json\"}\n    data = json_dumps(payload)\n    request, response = app.test_client.request(\n        \"/\", http_method=\"get\", data=data, headers=headers\n    )\n\n    assert request.body == data.encode(\"utf-8\")\n    assert request.json.get(\"test\") == \"OK\"\n    assert response.body == b\"OK\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.body == data.encode('utf-8')",
        "assert request.json.get('test') == 'OK'",
        "assert response.body == b'OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.request",
          "body": "@app.on_request\ndef request(_):\n    nonlocal request_middleware_run_count\n    request_middleware_run_count += 1"
        },
        {
          "name": "request.json.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_safe_method_with_body` unit test is designed to verify the behavior of the Sanic web framework when handling HTTP GET requests that include a body. Specifically, it checks that the request body is correctly processed and that the response is as expected.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a GET request is made with a body (which is typically not standard for GET requests), the application correctly captures the body in the request object and that the response from the handler is accurate. It also verifies that the JSON payload sent in the request is correctly parsed.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route handler for the GET method that returns a simple text response \"OK\". It then constructs a JSON payload and sends a GET request to the handler with this payload. The assertions check:\n1. If the request body matches the encoded JSON data.\n2. If the JSON data can be accessed correctly via `request.json`.\n3. If the response body is \"OK\".\n\nThe relevant code being tested includes the `app.get` method for defining routes, the `app.test_client.request` method for simulating requests, and the request handling logic that processes the incoming request.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the expected outcomes, which is a common practice in unit testing. It also utilizes the Sanic test client to simulate HTTP requests, allowing for isolated testing of route handlers without needing to run a full server. The test is structured to be asynchronous, reflecting the asynchronous nature of the Sanic framework, which is essential for testing web applications that handle concurrent requests."
    },
    {
      "name": "test_conflicting_body_methods_overload",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 2241,
      "end_line_number": 2286,
      "source_code": "def test_conflicting_body_methods_overload(app: Sanic):\n    @app.put(\"/\", name=\"one\")\n    @app.put(\"/p/\", name=\"two\")\n    @app.put(\"/p/<foo>\", name=\"three\")\n    async def put(request, foo=None):\n        return json(\n            {\"name\": request.route.name, \"body\": str(request.body), \"foo\": foo}\n        )\n\n    @app.delete(\"/p/<foo>\")\n    async def delete(request, foo):\n        return json(\n            {\"name\": request.route.name, \"body\": str(request.body), \"foo\": foo}\n        )\n\n    payload = {\"test\": \"OK\"}\n    data = str(json_dumps(payload).encode())\n\n    _, response = app.test_client.put(\"/\", json=payload)\n    assert response.status == 200\n    assert response.json == {\n        \"name\": \"test_conflicting_body_methods_overload.one\",\n        \"foo\": None,\n        \"body\": data,\n    }\n    _, response = app.test_client.put(\"/p\", json=payload)\n    assert response.status == 200\n    assert response.json == {\n        \"name\": \"test_conflicting_body_methods_overload.two\",\n        \"foo\": None,\n        \"body\": data,\n    }\n    _, response = app.test_client.put(\"/p/test\", json=payload)\n    assert response.status == 200\n    assert response.json == {\n        \"name\": \"test_conflicting_body_methods_overload.three\",\n        \"foo\": \"test\",\n        \"body\": data,\n    }\n    _, response = app.test_client.delete(\"/p/test\")\n    assert response.status == 200\n    assert response.json == {\n        \"name\": \"test_conflicting_body_methods_overload.delete\",\n        \"foo\": \"test\",\n        \"body\": str(\"\".encode()),\n    }",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.json == {'name': 'test_conflicting_body_methods_overload.one', 'foo': None, 'body': data}",
        "assert response.status == 200",
        "assert response.json == {'name': 'test_conflicting_body_methods_overload.two', 'foo': None, 'body': data}",
        "assert response.status == 200",
        "assert response.json == {'name': 'test_conflicting_body_methods_overload.three', 'foo': 'test', 'body': data}",
        "assert response.status == 200",
        "assert response.json == {'name': 'test_conflicting_body_methods_overload.delete', 'foo': 'test', 'body': str(''.encode())}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.delete",
          "body": "def delete(self, request):\n    return text('I am delete method')"
        },
        {
          "name": "app.test_client.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.test_client.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.test_client.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.test_client.delete",
          "body": "def delete(self, request):\n    return text('I am delete method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_conflicting_body_methods_overload` test is to verify that the Sanic application correctly handles multiple HTTP PUT and DELETE routes with overlapping paths and that it returns the expected JSON responses based on the route matched.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the application can distinguish between different PUT and DELETE requests based on their paths and that it correctly processes the request body. It ensures that the correct route name, request body, and any path parameters are returned in the JSON response for each request.\n\n**Code Being Tested and How It Works**:  \nThe test defines several routes using the Sanic framework:\n- Three PUT routes (`\"/\"`, `\"/p/\"`, and `\"/p/<foo>\"`) that return the route name, request body, and an optional path parameter `foo`.\n- One DELETE route (`\"/p/<foo>\"`) that returns similar information. \n\nThe test then sends requests to these routes using the `app.test_client` and asserts that the responses have a status code of 200 and contain the expected JSON structure, including the correct route name and body content.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterized Testing**: The test checks multiple scenarios by sending requests to different routes and asserting the responses, effectively covering various cases of route handling.\n- **Assertions**: The use of assertions to validate the response status and JSON content ensures that the application behaves as expected under different conditions.\n- **Mocking and Test Client**: The test utilizes the Sanic test client to simulate HTTP requests, allowing for isolated testing of the application\u2019s routing and response handling without needing a live server."
    },
    {
      "name": "test_handler_overload",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 2305,
      "end_line_number": 2324,
      "source_code": "def test_handler_overload(app: Sanic):\n    @app.get(\n        \"/long/sub/route/param_a/<param_a:str>/param_b/<param_b:str>\",\n        name=\"one\",\n    )\n    @app.post(\"/long/sub/route/\", name=\"two\")\n    def handler(request, **kwargs):\n        return json(kwargs)\n\n    _, response = app.test_client.get(\n        \"/long/sub/route/param_a/foo/param_b/bar\"\n    )\n    assert response.status == 200\n    assert response.json == {\n        \"param_a\": \"foo\",\n        \"param_b\": \"bar\",\n    }\n    _, response = app.test_client.post(\"/long/sub/route\")\n    assert response.status == 200\n    assert response.json == {}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.json == {'param_a': 'foo', 'param_b': 'bar'}",
        "assert response.status == 200",
        "assert response.json == {}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_handler_overload` function is designed to verify that the Sanic application can correctly handle multiple HTTP methods (GET and POST) for the same route, ensuring that the appropriate parameters are processed and returned in the response.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a GET request is made to a specific route with parameters, the application returns a JSON response containing those parameters. It also verifies that a POST request to the same route returns an empty JSON response, confirming that the handler can differentiate between the two methods and respond accordingly.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route with two handlers: one for GET requests that captures two string parameters (`param_a` and `param_b`) and another for POST requests that does not require any parameters. The GET handler returns a JSON object with the captured parameters, while the POST handler returns an empty JSON object. The test uses the `app.test_client` to simulate requests to these routes and checks the status and content of the responses.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Route Definition**: The test uses decorators to define routes directly within the test function, showcasing a common pattern in web frameworks for setting up handlers.\n- **Assertions**: It employs assertions to validate the response status and JSON content, ensuring that the application behaves as expected under different request methods.\n- **Parameterization**: The test effectively demonstrates how to handle dynamic URL parameters, which is a typical requirement in web applications.\n- **Separation of Concerns**: By defining the handler within the test, it keeps the test self-contained, allowing for easy understanding and modification without affecting other parts of the codebase."
    },
    {
      "name": "test_static_directory_view",
      "module": "test_static_directory",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static_directory.py",
      "line_number": 21,
      "end_line_number": 27,
      "source_code": "def test_static_directory_view(app: Sanic, static_file_directory: str):\n    app.static(\"/static\", static_file_directory, directory_view=True)\n\n    _, response = app.test_client.get(\"/static/\")\n    assert response.status == 200\n    assert response.content_type == \"text/html; charset=utf-8\"\n    assert \"<title>Directory Viewer</title>\" in response.text",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "static_file_directory"
      ],
      "imports": [
        "os",
        "pathlib.Path",
        "pytest",
        "sanic.Sanic",
        "sanic.handlers.directory.DirectoryHandler"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.content_type == 'text/html; charset=utf-8'",
        "assert '<title>Directory Viewer</title>' in response.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_static_directory_view` function is designed to verify that the Sanic application correctly serves a static directory view when a request is made to the specified static route. It ensures that the directory listing is accessible and returns the expected HTML content.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a GET request is made to the `/static/` endpoint, the response status is 200 (indicating success), the content type is `text/html; charset=utf-8`, and the response body contains the title \"Directory Viewer\". This confirms that the application is properly configured to display a directory listing.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `app.static` method, which sets up a static file serving route. The `directory_view=True` argument enables the directory listing feature. The `app.test_client.get(\"/static/\")` simulates a client request to this route, and the assertions check the properties of the response returned by the application.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the response's status, content type, and body. It utilizes the Sanic test client to simulate HTTP requests, which is a common pattern in unit testing web applications. The test is structured to be clear and concise, focusing on specific expected outcomes, which is a best practice in unit testing to ensure maintainability and readability."
    },
    {
      "name": "test_static_index_single",
      "module": "test_static_directory",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static_directory.py",
      "line_number": 30,
      "end_line_number": 38,
      "source_code": "def test_static_index_single(app: Sanic, static_file_directory: str):\n    app.static(\"/static\", static_file_directory, index=\"test.html\")\n\n    _, response = app.test_client.get(\"/static/\")\n    assert response.status == 200\n    assert response.body == get_file_content(\n        static_file_directory, \"test.html\"\n    )\n    assert response.headers[\"Content-Type\"] == \"text/html\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "static_file_directory"
      ],
      "imports": [
        "os",
        "pathlib.Path",
        "pytest",
        "sanic.Sanic",
        "sanic.handlers.directory.DirectoryHandler"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, 'test.html')",
        "assert response.headers['Content-Type'] == 'text/html'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_static_index_single` test verifies that the Sanic application correctly serves a static HTML file when a request is made to a specific static route. It ensures that the application can find and return the specified index file (`test.html`) from the given static file directory.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks three key aspects: \n1. The HTTP response status is `200`, indicating a successful request.\n2. The content of the response body matches the content of the `test.html` file located in the specified static directory.\n3. The `Content-Type` header of the response is set to `text/html`, confirming that the server is serving an HTML document.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `app.static` method, which configures the Sanic application to serve static files from a specified directory. The `index` parameter is set to `test.html`, meaning that when a request is made to the `/static/` route, the server should respond with the content of `test.html`. The `app.test_client.get` method simulates an HTTP GET request to the `/static/` endpoint, and the assertions validate the response.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertions**: The test uses assertions to validate the response status, body content, and headers, which is a common practice in unit testing to ensure expected outcomes.\n- **Separation of Concerns**: The test relies on a helper function, `get_file_content`, to read the expected file content, promoting code reuse and clarity.\n- **Parameterization**: While not directly used in this specific test, the surrounding tests utilize `pytest.mark.parametrize`, indicating a pattern of testing multiple scenarios with different inputs, which enhances test coverage and robustness."
    },
    {
      "name": "test_static_index_single_not_found",
      "module": "test_static_directory",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static_directory.py",
      "line_number": 41,
      "end_line_number": 45,
      "source_code": "def test_static_index_single_not_found(app: Sanic, static_file_directory: str):\n    app.static(\"/static\", static_file_directory, index=\"index.html\")\n\n    _, response = app.test_client.get(\"/static/\")\n    assert response.status == 404",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "static_file_directory"
      ],
      "imports": [
        "os",
        "pathlib.Path",
        "pytest",
        "sanic.Sanic",
        "sanic.handlers.directory.DirectoryHandler"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_static_index_single_not_found` test verifies that when a static file is requested from a specified directory and the index file does not exist, the server correctly responds with a 404 Not Found status.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks the behavior of the Sanic application when attempting to access a static directory that is configured to serve an index file (`index.html`) that is not present in the specified static file directory. The expected outcome is a 404 status code, indicating that the requested resource could not be found.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Sanic application instance and configures it to serve static files from a given directory (`static_file_directory`) with the expectation that an index file named `index.html` should be served when accessing the root of the static path (`/static/`). The line `_, response = app.test_client.get(\"/static/\")` simulates an HTTP GET request to this path. The assertion `assert response.status == 404` checks that the response status is indeed 404, confirming that the index file is not found.\n\n**Notable Testing Patterns or Techniques Used**:  \nThis test employs the Arrange-Act-Assert (AAA) pattern, where:\n- **Arrange**: The application is configured with a static route expecting an index file.\n- **Act**: A GET request is made to the static route.\n- **Assert**: The response status is checked to ensure it is 404.  \nAdditionally, the test uses dependency injection for the `app` and `static_file_directory` parameters, allowing for flexible and reusable test setups."
    },
    {
      "name": "test_static_index_multiple",
      "module": "test_static_directory",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static_directory.py",
      "line_number": 48,
      "end_line_number": 60,
      "source_code": "def test_static_index_multiple(app: Sanic, static_file_directory: str):\n    app.static(\n        \"/static\",\n        static_file_directory,\n        index=[\"index.html\", \"test.html\"],\n    )\n\n    _, response = app.test_client.get(\"/static/\")\n    assert response.status == 200\n    assert response.body == get_file_content(\n        static_file_directory, \"test.html\"\n    )\n    assert response.headers[\"Content-Type\"] == \"text/html\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "static_file_directory"
      ],
      "imports": [
        "os",
        "pathlib.Path",
        "pytest",
        "sanic.Sanic",
        "sanic.handlers.directory.DirectoryHandler"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, 'test.html')",
        "assert response.headers['Content-Type'] == 'text/html'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_static_index_multiple` function is designed to verify the behavior of the Sanic web framework when serving static files from a specified directory, particularly when multiple index files are provided. It ensures that the correct file is served when a request is made to the static directory.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a GET request is made to the `/static/` endpoint, the server responds with a status code of 200, serves the content of `test.html`, and sets the correct `Content-Type` header to `text/html`. It also verifies that the server correctly prioritizes `test.html` over `index.html` when both are specified as index files.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `app.static` method, which configures the Sanic application to serve static files from a given directory. The `index` parameter allows specifying multiple index files. The `app.test_client.get` method simulates a GET request to the `/static/` endpoint. The `get_file_content` function reads the content of `test.html` from the specified `static_file_directory`, which is then compared against the response body to ensure the correct file is served.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs assertions to validate the response status, body content, and headers, which is a common practice in unit testing to ensure that the application behaves as expected. It also uses parameterization of the index files, allowing for flexible testing of multiple scenarios with minimal code duplication. The use of a test client to simulate HTTP requests is a standard technique in testing web applications, enabling the verification of endpoint behavior in a controlled environment."
    },
    {
      "name": "test_static_directory_view_and_index",
      "module": "test_static_directory",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static_directory.py",
      "line_number": 63,
      "end_line_number": 83,
      "source_code": "def test_static_directory_view_and_index(\n    app: Sanic, static_file_directory: str\n):\n    app.static(\n        \"/static\",\n        static_file_directory,\n        directory_view=True,\n        index=\"foo.txt\",\n    )\n\n    _, response = app.test_client.get(\"/static/nested/\")\n    assert response.status == 200\n    assert response.content_type == \"text/html; charset=utf-8\"\n    assert \"<title>Directory Viewer</title>\" in response.text\n\n    _, response = app.test_client.get(\"/static/nested/dir/\")\n    assert response.status == 200\n    assert response.body == get_file_content(\n        f\"{static_file_directory}/nested/dir\", \"foo.txt\"\n    )\n    assert response.content_type == \"text/plain\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "static_file_directory"
      ],
      "imports": [
        "os",
        "pathlib.Path",
        "pytest",
        "sanic.Sanic",
        "sanic.handlers.directory.DirectoryHandler"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.content_type == 'text/html; charset=utf-8'",
        "assert '<title>Directory Viewer</title>' in response.text",
        "assert response.status == 200",
        "assert response.body == get_file_content(f'{static_file_directory}/nested/dir', 'foo.txt')",
        "assert response.content_type == 'text/plain'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_static_directory_view_and_index` function is designed to verify the behavior of the Sanic web framework's static file serving capabilities, specifically when serving a directory view and an index file. It ensures that the application correctly serves a directory listing and the specified index file when accessed via HTTP.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main functionalities:\n1. When accessing a directory (in this case, `/static/nested/`), it verifies that the server responds with a 200 status code, the correct content type (`text/html`), and that the response contains the title \"Directory Viewer\".\n2. When accessing a specific directory path (`/static/nested/dir/`), it verifies that the server responds with a 200 status code, the content of the index file (`foo.txt`), and that the content type is `text/plain`.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the Sanic application setup where the `app.static` method is called to configure static file serving. The parameters include:\n- The URL path (`/static`).\n- The directory from which to serve files (`static_file_directory`).\n- Enabling directory view (`directory_view=True`).\n- Specifying the index file (`index=\"foo.txt\"`).\n\nThe test then uses the `app.test_client.get` method to simulate HTTP GET requests to the specified paths and checks the responses against expected values.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertions**: The test employs assertions to validate the response status, content type, and body content, ensuring that the application behaves as expected.\n- **HTTP Client Simulation**: It uses the `test_client` to simulate requests to the application, allowing for integration-style testing of the static file serving functionality.\n- **Directory and Index File Handling**: The test specifically checks the handling of directory views and index files, which is a common requirement in web applications serving static content."
    },
    {
      "name": "test_static_directory_handler",
      "module": "test_static_directory",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static_directory.py",
      "line_number": 86,
      "end_line_number": 105,
      "source_code": "def test_static_directory_handler(app: Sanic, static_file_directory: str):\n    dh = DirectoryHandler(\n        \"/static\",\n        Path(static_file_directory),\n        directory_view=True,\n        index=\"foo.txt\",\n    )\n    app.static(\"/static\", static_file_directory, directory_handler=dh)\n\n    _, response = app.test_client.get(\"/static/nested/\")\n    assert response.status == 200\n    assert response.content_type == \"text/html; charset=utf-8\"\n    assert \"<title>Directory Viewer</title>\" in response.text\n\n    _, response = app.test_client.get(\"/static/nested/dir/\")\n    assert response.status == 200\n    assert response.body == get_file_content(\n        f\"{static_file_directory}/nested/dir\", \"foo.txt\"\n    )\n    assert response.content_type == \"text/plain\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "static_file_directory"
      ],
      "imports": [
        "os",
        "pathlib.Path",
        "pytest",
        "sanic.Sanic",
        "sanic.handlers.directory.DirectoryHandler"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.content_type == 'text/html; charset=utf-8'",
        "assert '<title>Directory Viewer</title>' in response.text",
        "assert response.status == 200",
        "assert response.body == get_file_content(f'{static_file_directory}/nested/dir', 'foo.txt')",
        "assert response.content_type == 'text/plain'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_static_directory_handler` unit test is designed to verify the functionality of serving static files and directory listings in a Sanic web application. It specifically checks that the application correctly handles requests to a static directory and serves the appropriate content when directory viewing is enabled.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies two main behaviors: \n1. When accessing a directory (e.g., `/static/nested/`), the application should return a 200 status code, an HTML content type, and a specific title indicating that it is a directory viewer.\n2. When accessing a specific file within a nested directory (e.g., `/static/nested/dir/`), the application should return a 200 status code, the correct file content, and a plain text content type.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a `DirectoryHandler` for the static directory, which is configured to allow directory viewing and specify an index file (`foo.txt`). The `app.static` method is called to register the static route with the directory handler. The test then simulates HTTP GET requests to the specified paths using `app.test_client.get`, checking the responses for the expected status codes, content types, and content.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Setup and Teardown**: The test initializes the `DirectoryHandler` and registers it with the app before executing the requests, ensuring a clean state for each test run.\n- **Assertions**: Multiple assertions are used to validate different aspects of the response, including status codes, content types, and specific content within the response body.\n- **Parameterized Testing**: While not directly shown in this specific test, the surrounding code indicates the use of `pytest.mark.parametrize`, which allows for testing multiple scenarios with different inputs efficiently."
    },
    {
      "name": "test_static_directory_handler_fails",
      "module": "test_static_directory",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static_directory.py",
      "line_number": 108,
      "end_line_number": 123,
      "source_code": "def test_static_directory_handler_fails(app: Sanic):\n    dh = DirectoryHandler(\n        \"/static\",\n        Path(\"\"),\n        directory_view=True,\n        index=\"foo.txt\",\n    )\n    message = (\n        \"When explicitly setting directory_handler, you cannot \"\n        \"set either directory_view or index. Instead, pass \"\n        \"these arguments to your DirectoryHandler instance.\"\n    )\n    with pytest.raises(ValueError, match=message):\n        app.static(\"/static\", \"\", directory_handler=dh, directory_view=True)\n    with pytest.raises(ValueError, match=message):\n        app.static(\"/static\", \"\", directory_handler=dh, index=\"index.html\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "os",
        "pathlib.Path",
        "pytest",
        "sanic.Sanic",
        "sanic.handlers.directory.DirectoryHandler"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_static_directory_handler_fails` test is designed to verify that the Sanic application correctly raises a `ValueError` when a user attempts to set both `directory_view` and `index` parameters while also providing a custom `directory_handler`. This ensures that the application enforces its constraints on how static file handling is configured.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when the `app.static` method is called with conflicting parameters (i.e., `directory_view=True` and `index` set), it raises a `ValueError` with a specific error message. This behavior is crucial for maintaining the integrity of the static file serving configuration.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `app.static` method of the Sanic framework, which is responsible for serving static files. The test creates an instance of `DirectoryHandler` with specific parameters and then attempts to register static routes with conflicting options. The expected behavior is that the application raises a `ValueError` when these conflicting parameters are used, indicating that the user must configure the `DirectoryHandler` instance directly instead.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that a specific exception is raised during the execution of the code block. This pattern is effective for testing error conditions and ensures that the application behaves as expected when invalid configurations are provided. Additionally, the use of a specific error message in the `match` argument allows for precise verification that the correct error is raised, enhancing the robustness of the test."
    },
    {
      "name": "test_ws_handler",
      "module": "test_ws_handlers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_ws_handlers.py",
      "line_number": 63,
      "end_line_number": 77,
      "source_code": "def test_ws_handler(\n    app: Sanic,\n    simple_ws_mimic_client: MimicClientType,\n):\n    @app.websocket(\"/ws\")\n    async def ws_echo_handler(request: Request, ws: Websocket):\n        while True:\n            msg = await ws.recv()\n            await ws.send(msg)\n\n    _, ws_proxy = app.test_client.websocket(\n        \"/ws\", mimic=simple_ws_mimic_client\n    )\n    assert ws_proxy.client_sent == [\"test 1\", \"test 2\", \"\"]\n    assert ws_proxy.client_received == [\"test 1\", \"test 2\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "simple_ws_mimic_client"
      ],
      "imports": [
        "base64",
        "secrets",
        "typing.Any",
        "typing.Callable",
        "typing.Coroutine",
        "pytest",
        "websockets.client.WebSocketClientProtocol",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.Websocket"
      ],
      "fixtures": [],
      "assertions": [
        "assert ws_proxy.client_sent == ['test 1', 'test 2', '']",
        "assert ws_proxy.client_received == ['test 1', 'test 2']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "ws.recv",
          "body": "def recv(**kwargs):\n    nonlocal runner\n    nonlocal raw\n    method = raw.recv_until if 'until' in kwargs else raw.recv\n    return runner._run(method(**kwargs))"
        },
        {
          "name": "ws.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_ws_handler` function is to verify the correct behavior of a WebSocket echo handler in a Sanic application. It ensures that messages sent by a client are correctly received and echoed back by the server.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the WebSocket server correctly receives messages sent by the client and sends back the same messages. It asserts that the messages sent by the client (`client_sent`) match the expected values, and that the messages received by the client (`client_received`) also match the expected values.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the WebSocket echo handler defined within the `test_ws_handler` function. The handler listens for incoming messages in an infinite loop, receiving messages via `ws.recv()` and sending them back using `ws.send()`. The test uses a mock client (`simple_ws_mimic_client`) to simulate sending messages (\"test 1\" and \"test 2\") to the WebSocket endpoint (`/ws`). The assertions at the end of the test confirm that the messages sent and received are as expected.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of fixtures (e.g., `simple_ws_mimic_client`) to set up the WebSocket client behavior, allowing for clean and reusable test code. It also utilizes assertions to validate the state of the WebSocket communication, ensuring that both sent and received messages are correctly handled. The use of an asynchronous context (`async def`) is significant, as it allows for non-blocking operations typical in WebSocket communication."
    },
    {
      "name": "test_ws_handler_invalid_upgrade",
      "module": "test_ws_handlers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_ws_handlers.py",
      "line_number": 80,
      "end_line_number": 94,
      "source_code": "def test_ws_handler_invalid_upgrade(app: Sanic):\n    @app.websocket(\"/ws\")\n    async def ws_echo_handler(request: Request, ws: Websocket):\n        async for msg in ws:\n            await ws.send(msg)\n\n    ws_key = base64.b64encode(secrets.token_bytes(16)).decode(\"utf-8\")\n    invalid_upgrade_headers = {\n        \"Upgrade\": \"websocket\",\n        # \"Connection\": \"Upgrade\",\n        \"Sec-WebSocket-Key\": ws_key,\n        \"Sec-WebSocket-Version\": \"13\",\n    }\n    _, response = app.test_client.get(\"/ws\", headers=invalid_upgrade_headers)\n    assert response.status == 426",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "secrets",
        "typing.Any",
        "typing.Callable",
        "typing.Coroutine",
        "pytest",
        "websockets.client.WebSocketClientProtocol",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.Websocket"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 426"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "ws.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_ws_handler_invalid_upgrade` test is designed to verify that the Sanic application correctly handles an invalid WebSocket upgrade request. Specifically, it checks that when the required \"Connection\" header is missing, the server responds with the appropriate HTTP status code 426 (Upgrade Required).\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the WebSocket handler enforces the necessary headers for a valid WebSocket connection. By omitting the \"Connection\" header, the test confirms that the server does not accept the connection and responds with a 426 status, indicating that the client must provide the correct headers to establish a WebSocket connection.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a WebSocket route (`/ws`) in the Sanic application and prepares an invalid upgrade request by including the \"Upgrade\" and \"Sec-WebSocket-Key\" headers but omitting the \"Connection\" header. It then sends a GET request to the WebSocket endpoint using the test client. The response is checked to ensure that the status code is 426, which indicates that the upgrade request was not accepted due to the missing header.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test leverages asynchronous programming by using `async` functions and the Sanic test client, which is designed to handle asynchronous requests.\n- **Header Manipulation**: The test demonstrates how to manipulate HTTP headers to simulate different request scenarios, allowing for the verification of server behavior under specific conditions.\n- **Assertion of HTTP Status Codes**: The test uses assertions to validate the response status code, which is a common practice in unit testing to ensure that the application behaves as expected in various situations."
    },
    {
      "name": "test_ws_handler_async_for",
      "module": "test_ws_handlers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_ws_handlers.py",
      "line_number": 97,
      "end_line_number": 110,
      "source_code": "def test_ws_handler_async_for(\n    app: Sanic,\n    simple_ws_mimic_client: MimicClientType,\n):\n    @app.websocket(\"/ws\")\n    async def ws_echo_handler(request: Request, ws: Websocket):\n        async for msg in ws:\n            await ws.send(msg)\n\n    _, ws_proxy = app.test_client.websocket(\n        \"/ws\", mimic=simple_ws_mimic_client\n    )\n    assert ws_proxy.client_sent == [\"test 1\", \"test 2\", \"\"]\n    assert ws_proxy.client_received == [\"test 1\", \"test 2\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "simple_ws_mimic_client"
      ],
      "imports": [
        "base64",
        "secrets",
        "typing.Any",
        "typing.Callable",
        "typing.Coroutine",
        "pytest",
        "websockets.client.WebSocketClientProtocol",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.Websocket"
      ],
      "fixtures": [],
      "assertions": [
        "assert ws_proxy.client_sent == ['test 1', 'test 2', '']",
        "assert ws_proxy.client_received == ['test 1', 'test 2']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "ws.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_ws_handler_async_for` test is to verify the functionality of a WebSocket echo handler in a Sanic application. It ensures that messages sent by a client are correctly received and echoed back by the server.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the WebSocket handler correctly processes incoming messages. It verifies that the messages sent by the client (`\"test 1\"` and `\"test 2\"`) are received and echoed back, while also confirming that an empty message is sent at the end of the communication.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `ws_echo_handler` function, which is defined as a WebSocket route in the Sanic application. It uses an asynchronous loop (`async for msg in ws`) to continuously receive messages from the WebSocket connection. For each received message, it sends the same message back to the client using `await ws.send(msg)`. The test utilizes a mock WebSocket client (`simple_ws_mimic_client`) to simulate sending and receiving messages during the test.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of fixtures (`simple_ws_mimic_client`) to set up the WebSocket client behavior, allowing for controlled testing of the WebSocket interactions. It also uses assertions to validate the expected outcomes, specifically checking the contents of `ws_proxy.client_sent` and `ws_proxy.client_received` to ensure that the messages were sent and received as intended. The use of asynchronous testing with `async def` and `await` is a key aspect, reflecting the asynchronous nature of WebSocket communication in the Sanic framework."
    },
    {
      "name": "test_request_url",
      "module": "test_ws_handlers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_ws_handlers.py",
      "line_number": 114,
      "end_line_number": 146,
      "source_code": "def test_request_url(\n    app: Sanic,\n    simple_ws_mimic_client: MimicClientType,\n    proxy: str,\n):\n    @app.websocket(\"/ws\")\n    async def ws_url_handler(request: Request, ws: Websocket):\n        request.headers[\"forwarded\"] = (\n            \"for=[2001:db8::1];proto=https;host=example.com;by=proxy\"\n        )\n\n        await ws.recv()\n        await ws.send(request.url)\n        await ws.recv()\n        await ws.send(request.url_for(\"ws_url_handler\"))\n        await ws.recv()\n\n    app.config.FORWARDED_SECRET = proxy\n    app.config.SERVER_NAME = (\n        \"https://example.com\" if proxy == \"servername\" else \"\"\n    )\n    _, ws_proxy = app.test_client.websocket(\n        \"/ws\",\n        mimic=simple_ws_mimic_client,\n    )\n    assert ws_proxy.client_sent == [\"test 1\", \"test 2\", \"\"]\n    assert ws_proxy.client_received[0] == ws_proxy.client_received[1]\n    if proxy == \"servername\":\n        assert ws_proxy.client_received[0] == \"wss://example.com/ws\"\n        assert ws_proxy.client_received[1] == \"wss://example.com/ws\"\n    else:\n        assert ws_proxy.client_received[0].startswith(\"ws://127.0.0.1\")\n        assert ws_proxy.client_received[1].startswith(\"ws://127.0.0.1\")",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('proxy', ['', 'proxy', 'servername'])"
      ],
      "arguments": [
        "app",
        "simple_ws_mimic_client",
        "proxy"
      ],
      "imports": [
        "base64",
        "secrets",
        "typing.Any",
        "typing.Callable",
        "typing.Coroutine",
        "pytest",
        "websockets.client.WebSocketClientProtocol",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.Websocket"
      ],
      "fixtures": [],
      "assertions": [
        "assert ws_proxy.client_sent == ['test 1', 'test 2', '']",
        "assert ws_proxy.client_received[0] == ws_proxy.client_received[1]",
        "assert ws_proxy.client_received[0] == 'wss://example.com/ws'",
        "assert ws_proxy.client_received[1] == 'wss://example.com/ws'",
        "assert ws_proxy.client_received[0].startswith('ws://127.0.0.1')",
        "assert ws_proxy.client_received[1].startswith('ws://127.0.0.1')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "ws.recv",
          "body": "def recv(**kwargs):\n    nonlocal runner\n    nonlocal raw\n    method = raw.recv_until if 'until' in kwargs else raw.recv\n    return runner._run(method(**kwargs))"
        },
        {
          "name": "ws.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "ws.recv",
          "body": "def recv(**kwargs):\n    nonlocal runner\n    nonlocal raw\n    method = raw.recv_until if 'until' in kwargs else raw.recv\n    return runner._run(method(**kwargs))"
        },
        {
          "name": "ws.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "ws.recv",
          "body": "def recv(**kwargs):\n    nonlocal runner\n    nonlocal raw\n    method = raw.recv_until if 'until' in kwargs else raw.recv\n    return runner._run(method(**kwargs))"
        },
        {
          "name": "request.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_request_url` function is designed to verify the behavior of a WebSocket endpoint in a Sanic application, specifically how it handles requests and constructs URLs based on the `X-Forwarded-For` and `SERVER_NAME` configurations. It ensures that the correct URLs are sent back to the client based on the proxy settings.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the WebSocket handler correctly processes incoming messages and responds with the expected URLs. It verifies that the URLs returned by the handler are consistent with the proxy configuration, distinguishing between a \"servername\" proxy and a local address.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the WebSocket handler defined within the `test_request_url` function. It modifies the request headers to include a \"forwarded\" header, receives messages from the client, and sends back the request URL and the URL for the handler itself. The assertions at the end of the test confirm that the URLs sent back to the client match the expected values based on the proxy configuration.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of asynchronous testing with the Sanic framework, utilizing a WebSocket client to simulate interactions. It also uses assertions to validate the state of the WebSocket communication, checking both the messages sent by the client and the responses received. The test is parameterized to handle different proxy configurations, allowing for comprehensive coverage of the URL handling logic."
    },
    {
      "name": "test_ws_signals",
      "module": "test_ws_handlers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_ws_handlers.py",
      "line_number": 149,
      "end_line_number": 160,
      "source_code": "def test_ws_signals(\n    app: Sanic,\n    simple_ws_mimic_client: MimicClientType,\n):\n    signalapp(app)\n\n    app.ctx.seq = []\n    _, ws_proxy = app.test_client.websocket(\n        \"/ws\", mimic=simple_ws_mimic_client\n    )\n    assert ws_proxy.client_received == [\"before: test 1\", \"after: test 2\"]\n    assert app.ctx.seq == [\"before\", \"ws\", \"after\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "simple_ws_mimic_client"
      ],
      "imports": [
        "base64",
        "secrets",
        "typing.Any",
        "typing.Callable",
        "typing.Coroutine",
        "pytest",
        "websockets.client.WebSocketClientProtocol",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.Websocket"
      ],
      "fixtures": [],
      "assertions": [
        "assert ws_proxy.client_received == ['before: test 1', 'after: test 2']",
        "assert app.ctx.seq == ['before', 'ws', 'after']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "signalapp",
          "body": "def signalapp(app):\n\n    @app.signal('websocket.handler.before')\n    async def ws_before(request: Request, websocket: Websocket):\n        app.ctx.seq.append('before')\n        print('before')\n        await websocket.send('before: ' + await websocket.recv())\n        print('before2')\n\n    @app.signal('websocket.handler.after')\n    async def ws_after(request: Request, websocket: Websocket):\n        app.ctx.seq.append('after')\n        await websocket.send('after: ' + await websocket.recv())\n        await websocket.recv()\n\n    @app.signal('websocket.handler.exception')\n    async def ws_exception(request: Request, websocket: Websocket, exception: Exception):\n        app.ctx.seq.append('exception')\n        await websocket.send(f'exception: {exception}')\n        await websocket.recv()\n\n    @app.websocket('/ws')\n    async def ws_handler(request: Request, ws: Websocket):\n        app.ctx.seq.append('ws')\n\n    @app.websocket('/wserror')\n    async def ws_error(request: Request, ws: Websocket):\n        print('wserr')\n        app.ctx.seq.append('wserror')\n        raise Exception(await ws.recv())\n        print('wserr2')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_ws_signals` function is designed to verify the correct behavior of WebSocket signal handlers in a Sanic application. Specifically, it checks that the signals for \"before\" and \"after\" events are triggered correctly during a WebSocket connection, and that the expected messages are sent and received.\n\n**Specific Functionality or Behavior Verified**:  \nThe test ensures that when a WebSocket client connects to the `/ws` endpoint, the \"before\" signal handler is executed first, followed by the WebSocket handler itself, and finally the \"after\" signal handler. It verifies that the messages sent to the client are as expected and that the sequence of events recorded in the application context (`app.ctx.seq`) matches the anticipated order.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `signalapp` function, which registers signal handlers for WebSocket events. The `ws_before` function appends \"before\" to the context sequence, sends a message prefixed with \"before:\", and waits for a response. The `ws_handler` function appends \"ws\" to the sequence, and the `ws_after` function appends \"after\" to the sequence and sends a message prefixed with \"after:\". The test simulates a WebSocket connection using a mock client (`simple_ws_mimic_client`), which sends predefined messages and receives responses.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of fixtures to set up the application context and mock WebSocket client behavior. It utilizes assertions to validate the expected outcomes, specifically checking the messages received by the client and the sequence of events recorded in the application context. The use of asynchronous functions and the Sanic testing client demonstrates effective testing of asynchronous code, ensuring that the WebSocket interactions are handled correctly."
    },
    {
      "name": "test_ws_signals_exception",
      "module": "test_ws_handlers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_ws_handlers.py",
      "line_number": 163,
      "end_line_number": 174,
      "source_code": "def test_ws_signals_exception(\n    app: Sanic,\n    simple_ws_mimic_client: MimicClientType,\n):\n    signalapp(app)\n\n    app.ctx.seq = []\n    _, ws_proxy = app.test_client.websocket(\n        \"/wserror\", mimic=simple_ws_mimic_client\n    )\n    assert ws_proxy.client_received == [\"before: test 1\", \"exception: test 2\"]\n    assert app.ctx.seq == [\"before\", \"wserror\", \"exception\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "simple_ws_mimic_client"
      ],
      "imports": [
        "base64",
        "secrets",
        "typing.Any",
        "typing.Callable",
        "typing.Coroutine",
        "pytest",
        "websockets.client.WebSocketClientProtocol",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.Websocket"
      ],
      "fixtures": [],
      "assertions": [
        "assert ws_proxy.client_received == ['before: test 1', 'exception: test 2']",
        "assert app.ctx.seq == ['before', 'wserror', 'exception']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "signalapp",
          "body": "def signalapp(app):\n\n    @app.signal('websocket.handler.before')\n    async def ws_before(request: Request, websocket: Websocket):\n        app.ctx.seq.append('before')\n        print('before')\n        await websocket.send('before: ' + await websocket.recv())\n        print('before2')\n\n    @app.signal('websocket.handler.after')\n    async def ws_after(request: Request, websocket: Websocket):\n        app.ctx.seq.append('after')\n        await websocket.send('after: ' + await websocket.recv())\n        await websocket.recv()\n\n    @app.signal('websocket.handler.exception')\n    async def ws_exception(request: Request, websocket: Websocket, exception: Exception):\n        app.ctx.seq.append('exception')\n        await websocket.send(f'exception: {exception}')\n        await websocket.recv()\n\n    @app.websocket('/ws')\n    async def ws_handler(request: Request, ws: Websocket):\n        app.ctx.seq.append('ws')\n\n    @app.websocket('/wserror')\n    async def ws_error(request: Request, ws: Websocket):\n        print('wserr')\n        app.ctx.seq.append('wserror')\n        raise Exception(await ws.recv())\n        print('wserr2')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_ws_signals_exception` unit test is designed to verify the behavior of the Sanic application when a WebSocket connection encounters an exception. Specifically, it checks that the appropriate signals are triggered and that the correct messages are sent back to the client when an error occurs during the WebSocket communication.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when an exception is raised in the WebSocket handler (`ws_error`), the application correctly processes the exception signal. It verifies that the client receives the expected messages indicating the sequence of events leading up to the exception, and it checks that the application's context (`app.ctx.seq`) accurately reflects the order of operations.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `signalapp` function, which registers signal handlers for various WebSocket events, including `websocket.handler.before`, `websocket.handler.exception`, and `websocket.handler.after`. The `ws_error` handler is specifically designed to raise an exception when it receives a message. The test simulates a WebSocket connection to the `/wserror` endpoint, sends a message, and expects the following:\n1. The client receives messages indicating the \"before\" signal and the \"exception\" signal.\n2. The application's context sequence (`app.ctx.seq`) reflects the order of events: `[\"before\", \"wserror\", \"exception\"]`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of a mock WebSocket client (`simple_ws_mimic_client`) to simulate WebSocket interactions without needing a real client. It also utilizes assertions to validate the expected outcomes, ensuring that both the messages received by the client and the internal state of the application are as expected. This approach allows for isolated testing of the WebSocket error handling logic, making it easier to identify issues related to signal processing and exception handling in the application."
    },
    {
      "name": "test_has_message_body",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_helpers.py",
      "line_number": 9,
      "end_line_number": 19,
      "source_code": "def test_has_message_body():\n    tests = (\n        (100, False),\n        (102, False),\n        (204, False),\n        (200, True),\n        (304, False),\n        (400, True),\n    )\n    for status_code, expected in tests:\n        assert helpers.has_message_body(status_code) is expected",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "inspect",
        "pytest",
        "sanic.helpers",
        "sanic.config.Config"
      ],
      "fixtures": [],
      "assertions": [
        "assert helpers.has_message_body(status_code) is expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_has_message_body` function is designed to verify the behavior of the `helpers.has_message_body` function, ensuring it correctly determines whether a response with a given HTTP status code should include a message body according to the HTTP specification.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that for specific HTTP status codes, the `has_message_body` function returns the expected boolean value indicating whether a message body is allowed. It validates that status codes 100, 102, 204, and 304 should not have a message body (returning `False`), while status codes 200 and 400 should have a message body (returning `True`).\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `has_message_body` function, which implements logic based on the HTTP/1.1 specification (RFC 2616). It returns `True` if the status code is 200 or 400, and `False` for status codes 100, 102, 204, and 304, as these codes indicate that a message body should not be included in the response.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a parameterized approach by using a tuple of test cases, iterating through each status code and its expected result. This pattern allows for concise and clear testing of multiple scenarios within a single test function, enhancing maintainability and readability. The use of assertions directly compares the output of the function under test with the expected values, ensuring that any discrepancies are easily identified."
    },
    {
      "name": "test_is_entity_header",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_helpers.py",
      "line_number": 22,
      "end_line_number": 30,
      "source_code": "def test_is_entity_header():\n    tests = (\n        (\"allow\", True),\n        (\"extension-header\", True),\n        (\"\", False),\n        (\"test\", False),\n    )\n    for header, expected in tests:\n        assert helpers.is_entity_header(header) is expected",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "inspect",
        "pytest",
        "sanic.helpers",
        "sanic.config.Config"
      ],
      "fixtures": [],
      "assertions": [
        "assert helpers.is_entity_header(header) is expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_is_entity_header` function is designed to verify the behavior of the `is_entity_header` function, which checks if a given HTTP header is classified as an entity header. This is crucial for ensuring that the application correctly identifies headers that are relevant to the message body of HTTP requests and responses.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks various input headers against expected boolean outcomes. It confirms that certain headers (like \"allow\" and \"extension-header\") are recognized as entity headers (returning `True`), while others (like an empty string and \"test\") are not recognized (returning `False`). This ensures that the `is_entity_header` function behaves as intended across a range of valid and invalid inputs.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `is_entity_header` function, which converts the input header to lowercase and checks if it exists in a predefined set of entity headers stored in `_ENTITY_HEADERS`. The function returns `True` if the header is found and `False` otherwise. This implementation relies on case-insensitivity to ensure consistent behavior regardless of how headers are formatted.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a parameterized approach by iterating over a tuple of test cases, each containing a header and its expected result. This pattern allows for concise and clear testing of multiple scenarios within a single test function, enhancing readability and maintainability. The use of assertions directly compares the output of the function under test with the expected results, providing immediate feedback on the correctness of the implementation."
    },
    {
      "name": "test_is_hop_by_hop_header",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_helpers.py",
      "line_number": 33,
      "end_line_number": 41,
      "source_code": "def test_is_hop_by_hop_header():\n    tests = (\n        (\"connection\", True),\n        (\"upgrade\", True),\n        (\"\", False),\n        (\"test\", False),\n    )\n    for header, expected in tests:\n        assert helpers.is_hop_by_hop_header(header) is expected",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "inspect",
        "pytest",
        "sanic.helpers",
        "sanic.config.Config"
      ],
      "fixtures": [],
      "assertions": [
        "assert helpers.is_hop_by_hop_header(header) is expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_is_hop_by_hop_header` function is designed to verify the behavior of the `is_hop_by_hop_header` function from the `helpers` module. Specifically, it checks whether certain HTTP headers are classified as \"hop-by-hop\" headers, which are headers that are only relevant for a single transport-level connection.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks a set of predefined headers against expected boolean values. It confirms that the headers \"connection\" and \"upgrade\" return `True`, indicating they are hop-by-hop headers, while an empty string and a generic \"test\" header return `False`, indicating they are not.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `helpers.is_hop_by_hop_header` function. This function likely contains logic to determine if a given header name is part of a predefined set of hop-by-hop headers as specified by the HTTP/1.1 specification (RFC 7230). The test iterates through a tuple of header names and their expected results, asserting that the function's output matches the expected boolean value.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a parameterized approach by using a tuple of test cases, which allows for concise and clear verification of multiple scenarios within a single test function. This pattern enhances readability and maintainability, as it groups related tests together and reduces code duplication. The use of assertions directly compares the function's output to expected values, which is a common practice in unit testing to ensure correctness."
    },
    {
      "name": "test_import_string_class",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_helpers.py",
      "line_number": 44,
      "end_line_number": 46,
      "source_code": "def test_import_string_class():\n    obj = helpers.import_string(\"sanic.config.Config\")\n    assert isinstance(obj, Config)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "inspect",
        "pytest",
        "sanic.helpers",
        "sanic.config.Config"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(obj, Config)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_import_string_class` unit test is designed to verify that the `import_string` function from the `sanic.helpers` module correctly imports a specified class from a given module path. In this case, it checks that the class `Config` from the `sanic.config` module is successfully imported.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the object returned by `helpers.import_string(\"sanic.config.Config\")` is indeed an instance of the `Config` class. This ensures that the `import_string` function can dynamically import classes and that it behaves as expected when provided with a valid class path.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `import_string` function, which takes a string representing a module path and returns the corresponding class or module. In this test, the string `\"sanic.config.Config\"` is passed to `import_string`, and the returned object is checked using `isinstance(obj, Config)`. If the object is an instance of `Config`, the assertion passes, confirming that the import was successful.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern using `assert` to validate the type of the imported object. It leverages Python's built-in `isinstance()` function, which is a common technique in unit tests to ensure that an object is of the expected type. Additionally, the test is structured to be simple and direct, focusing solely on the functionality of the `import_string` method without any complex setup or teardown, which is a hallmark of effective unit tests."
    },
    {
      "name": "test_import_string_module",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_helpers.py",
      "line_number": 49,
      "end_line_number": 51,
      "source_code": "def test_import_string_module():\n    module = helpers.import_string(\"sanic.config\")\n    assert inspect.ismodule(module)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "inspect",
        "pytest",
        "sanic.helpers",
        "sanic.config.Config"
      ],
      "fixtures": [],
      "assertions": [
        "assert inspect.ismodule(module)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_import_string_module` unit test is designed to verify that the `import_string` function from the `sanic.helpers` module correctly imports a module when given its string representation. Specifically, it checks that the module `sanic.config` can be successfully imported and is recognized as a module.\n\n**Specific Functionality or Behavior Verified**:  \nThis test confirms that the `import_string` function returns a valid module object when provided with the string \"sanic.config\". The assertion `assert inspect.ismodule(module)` ensures that the returned object is indeed a module, which is a fundamental requirement for the function's expected behavior.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `import_string` function, which is expected to take a string input representing a module name and return the corresponding module object. In this case, the input is \"sanic.config\". The function likely utilizes Python's import mechanisms (such as `importlib`) to dynamically load the specified module. The test checks that the result of this import operation is a module by using the `inspect.ismodule()` function.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern, where the outcome of a function call is directly compared against an expected condition (in this case, being a module). It uses the `inspect` module to validate the type of the returned object, which is a common practice in unit testing to ensure that the function behaves as intended. The test is also isolated, focusing solely on the functionality of the `import_string` function without dependencies on other parts of the codebase, which is a hallmark of effective unit tests."
    },
    {
      "name": "test_import_string_exception",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_helpers.py",
      "line_number": 54,
      "end_line_number": 56,
      "source_code": "def test_import_string_exception():\n    with pytest.raises(ImportError):\n        helpers.import_string(\"test.test.test\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "inspect",
        "pytest",
        "sanic.helpers",
        "sanic.config.Config"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_import_string_exception` test is designed to verify that an `ImportError` is raised when attempting to import a non-existent module or attribute using the `helpers.import_string` function. This ensures that the function correctly handles invalid import strings.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks the error handling behavior of the `import_string` function. It confirms that when an invalid import path (in this case, `\"test.test.test\"`) is provided, the function raises an `ImportError`, which is a critical aspect of robust error handling in dynamic imports.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `helpers.import_string` function, which is expected to take a string representing a module or attribute path and attempt to import it. If the specified path does not correspond to a valid module or attribute, the function should raise an `ImportError`. The test uses the `pytest.raises` context manager to assert that the expected exception is raised during the execution of the import statement.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager, a common pattern in unit testing for asserting that specific exceptions are raised during the execution of code. This technique allows for clean and readable tests that clearly express the expected behavior in the face of erroneous input. Additionally, the test is simple and focused, adhering to the principle of testing one specific behavior at a time, which enhances maintainability and clarity."
    },
    {
      "name": "test_vanilla_sanic",
      "module": "test_naming",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_naming.py",
      "line_number": 23,
      "end_line_number": 29,
      "source_code": "def test_vanilla_sanic():\n    app = factory(Sanic, Blueprint)\n    _, foo_response = app.test_client.get(\"/\")\n    _, bar_response = app.test_client.get(\"/bar/\")\n\n    assert foo_response.text == \"Foo.handler\"\n    assert bar_response.text == \"Foo.Bar.handler\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "typing.Type",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert foo_response.text == 'Foo.handler'",
        "assert bar_response.text == 'Foo.Bar.handler'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "factory",
          "body": "def factory(sanic_cls: Type[Sanic], blueprint_cls: Type[Blueprint]):\n    app = sanic_cls('Foo')\n    bp = blueprint_cls('Bar', url_prefix='/bar')\n\n    @app.get('/')\n    async def handler(request):\n        return text(request.name)\n\n    @bp.get('/')\n    async def handler(request):\n        return text(request.name)\n    app.blueprint(bp)\n    return app"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_vanilla_sanic` function is designed to verify the correct behavior of a Sanic application created using a factory function. It specifically checks that the application routes return the expected responses when accessed.\n\n**Specific Functionality or Behavior Verified**:  \nThis test verifies that the root endpoint (`\"/\"`) returns the string `\"Foo.handler\"` and the blueprint endpoint (`\"/bar/\"`) returns the string `\"Foo.Bar.handler\"`. It ensures that the routing and response handling in the application are functioning as intended.\n\n**Code Being Tested and How It Works**:  \nThe test invokes the `factory` function, which creates a Sanic application instance with a blueprint. The `factory` function defines two routes: one for the root path (`\"/\"`) and another for the blueprint path (`\"/bar/\"`). Each route has an associated asynchronous handler that returns the name of the request. The test then uses the application's test client to send GET requests to both endpoints and checks the responses.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Factory Pattern**: The use of a factory function (`factory`) to create the application allows for flexible instantiation of the app with different configurations or classes, promoting reusability and separation of concerns.\n- **Assertions**: The test employs assertions to validate the responses from the application, ensuring that the expected output matches the actual output.\n- **Test Client**: The use of `app.test_client.get` simulates HTTP requests to the application, allowing for integration-style testing of the routes without needing to run a live server."
    },
    {
      "name": "test_custom_app",
      "module": "test_naming",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_naming.py",
      "line_number": 32,
      "end_line_number": 43,
      "source_code": "def test_custom_app():\n    class Custom(Sanic):\n        def generate_name(self, *objects):\n            existing = self._generate_name(*objects)\n            return existing.replace(\"Foo\", \"CHANGED_APP\")\n\n    app = factory(Custom, Blueprint)\n    _, foo_response = app.test_client.get(\"/\")\n    _, bar_response = app.test_client.get(\"/bar/\")\n\n    assert foo_response.text == \"CHANGED_APP.handler\"\n    assert bar_response.text == \"CHANGED_APP.Bar.handler\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "typing.Type",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert foo_response.text == 'CHANGED_APP.handler'",
        "assert bar_response.text == 'CHANGED_APP.Bar.handler'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "factory",
          "body": "def factory(sanic_cls: Type[Sanic], blueprint_cls: Type[Blueprint]):\n    app = sanic_cls('Foo')\n    bp = blueprint_cls('Bar', url_prefix='/bar')\n\n    @app.get('/')\n    async def handler(request):\n        return text(request.name)\n\n    @bp.get('/')\n    async def handler(request):\n        return text(request.name)\n    app.blueprint(bp)\n    return app"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_custom_app` function is designed to verify that a custom Sanic application correctly modifies the generated names of its routes when a specific subclass of the Sanic application is used. It ensures that the application behaves as expected when the `generate_name` method is overridden.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the responses from two routes (`\"/\"` and `\"/bar/\"`) return the expected modified names. Specifically, it verifies that the default name \"Foo\" is replaced with \"CHANGED_APP\" in the response text, confirming that the custom naming logic is functioning correctly.\n\n**Code Being Tested and How It Works**:  \nThe test creates a subclass of `Sanic` called `Custom`, which overrides the `generate_name` method to replace \"Foo\" with \"CHANGED_APP\". The `factory` function is used to create an instance of this custom application, which sets up two routes: one for the root path (`\"/\"`) and another for the blueprint path (`\"/bar/\"`). The test then makes GET requests to these routes and asserts that the responses contain the expected modified names.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Subclassing**: The test demonstrates the use of subclassing to extend the functionality of the Sanic application, allowing for custom behavior in route naming.\n- **Factory Pattern**: The `factory` function encapsulates the creation of the application and its routes, promoting code reuse and separation of concerns.\n- **Assertions**: The test employs assertions to validate the output of the application against expected values, ensuring that the application behaves as intended.\n- **Integration Testing**: By making actual HTTP requests to the application, the test acts as an integration test, verifying that the components of the application work together correctly."
    },
    {
      "name": "test_custom_blueprint",
      "module": "test_naming",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_naming.py",
      "line_number": 46,
      "end_line_number": 57,
      "source_code": "def test_custom_blueprint():\n    class Custom(Blueprint):\n        def generate_name(self, *objects):\n            existing = self._generate_name(*objects)\n            return existing.replace(\"Bar\", \"CHANGED_BP\")\n\n    app = factory(Sanic, Custom)\n    _, foo_response = app.test_client.get(\"/\")\n    _, bar_response = app.test_client.get(\"/bar/\")\n\n    assert foo_response.text == \"Foo.handler\"\n    assert bar_response.text == \"Foo.CHANGED_BP.handler\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "typing.Type",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert foo_response.text == 'Foo.handler'",
        "assert bar_response.text == 'Foo.CHANGED_BP.handler'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "factory",
          "body": "def factory(sanic_cls: Type[Sanic], blueprint_cls: Type[Blueprint]):\n    app = sanic_cls('Foo')\n    bp = blueprint_cls('Bar', url_prefix='/bar')\n\n    @app.get('/')\n    async def handler(request):\n        return text(request.name)\n\n    @bp.get('/')\n    async def handler(request):\n        return text(request.name)\n    app.blueprint(bp)\n    return app"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_custom_blueprint` function is designed to verify the behavior of a custom `Blueprint` class in a Sanic application. Specifically, it checks that the `generate_name` method of the `Custom` blueprint correctly modifies the name of the blueprint when handling requests.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a request is made to the root endpoint (\"/\") and the \"/bar/\" endpoint, the responses are as expected. It verifies that the response from the root endpoint remains unchanged, while the response from the \"/bar/\" endpoint reflects the modification made by the `generate_name` method, replacing \"Bar\" with \"CHANGED_BP\".\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the `factory` function to create a Sanic application instance with a custom blueprint. The `Custom` class extends `Blueprint` and overrides the `generate_name` method to alter the generated name. The application defines two routes: one for the root (\"/\") and another for the \"/bar/\" endpoint. The test then makes GET requests to both endpoints and asserts that the responses match the expected values: \"Foo.handler\" for the root and \"Foo.CHANGED_BP.handler\" for the \"/bar/\" endpoint.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a few notable patterns:\n1. **Custom Class Extension**: It demonstrates how to extend existing classes (in this case, `Blueprint`) to modify behavior, which is a common practice in object-oriented programming.\n2. **Factory Pattern**: The use of the `factory` function to create instances of the application and blueprints promotes code reusability and separation of concerns.\n3. **Assertions**: The test uses assertions to validate the output of the application against expected results, which is a fundamental aspect of unit testing to ensure correctness.\n4. **Isolation of Tests**: By defining a specific test case for the custom blueprint, it isolates the functionality being tested, making it easier to identify issues related to that specific behavior."
    },
    {
      "name": "test_app_str",
      "module": "test_base",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_base.py",
      "line_number": 17,
      "end_line_number": 18,
      "source_code": "def test_app_str(app):\n    assert str(app) == \"<Sanic my_app>\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.exceptions.SanicException"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(app) == '<Sanic my_app>'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_app_str` unit test is designed to verify the string representation of a Sanic application instance. It ensures that when the `str()` function is called on the `app` object, it returns the expected formatted string that includes the application's name.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the string representation of the `app` object matches the expected output, which is `\"<Sanic my_app>\"`. This confirms that the `__str__` method of the Sanic application class is functioning correctly and provides a meaningful representation of the app instance.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `__str__` method of the Sanic application class. When `str(app)` is called, it invokes this method, which is expected to return a string formatted as `\"<Sanic {app_name}>\"`, where `{app_name}` is the name of the application instance. In this case, the app is initialized with the name \"my_app\".\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern using `assert`, which is a common technique in unit testing to validate expected outcomes. It does not utilize any mocking or complex setup, making it a simple and direct test case that focuses solely on the output of the `str()` method. This simplicity is effective for ensuring that the core functionality of the app's string representation is intact."
    },
    {
      "name": "test_app_repr",
      "module": "test_base",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_base.py",
      "line_number": 21,
      "end_line_number": 22,
      "source_code": "def test_app_repr(app):\n    assert repr(app) == 'Sanic(name=\"my_app\")'",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.exceptions.SanicException"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(app) == 'Sanic(name=\"my_app\")'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_app_repr` unit test is designed to verify the string representation of a `Sanic` application instance. It ensures that the `repr()` function returns the expected format, which is crucial for debugging and logging purposes.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `repr()` method of the `Sanic` app instance correctly formats the output to include the app's name. In this case, it asserts that the representation of the app named \"my_app\" matches the string `'Sanic(name=\"my_app\")'`.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `repr()` method of the `Sanic` class. When `repr(app)` is called, it should return a string that includes the class name and the name of the app in a specific format. The test uses an assertion to compare the actual output of `repr(app)` with the expected string.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern, which is a common technique in unit testing. It uses the `assert` statement to validate that the output of the `repr()` method matches the expected value. This approach is simple yet effective for verifying the correctness of the string representation of objects. Additionally, the test is likely part of a larger suite of tests that ensure the integrity of the `Sanic` framework's functionality."
    },
    {
      "name": "test_bp_str",
      "module": "test_base",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_base.py",
      "line_number": 25,
      "end_line_number": 26,
      "source_code": "def test_bp_str(bp):\n    assert str(bp) == \"<Blueprint my_bp>\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "bp"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.exceptions.SanicException"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(bp) == '<Blueprint my_bp>'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_bp_str` unit test is designed to verify the string representation of a `Blueprint` object in the Sanic framework. It ensures that when the `str()` function is called on a `Blueprint` instance, it returns the expected formatted string.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the output of `str(bp)` matches the expected string `\"<Blueprint my_bp>\"`. This confirms that the `Blueprint` class correctly implements the `__str__` method to provide a meaningful representation of the object.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `Blueprint` class from the Sanic framework. The `Blueprint` class is initialized with a name (in this case, \"my_bp\"). The `str()` function calls the `__str__` method of the `Blueprint` class, which is expected to return a string that includes the class name and the name of the blueprint. The test asserts that this output matches the expected format.\n\n**Notable Testing Patterns or Techniques Used**:  \nThis test employs a straightforward assertion pattern, using the `assert` statement to compare the actual output of `str(bp)` with the expected string. It utilizes a fixture (`bp`) to create a `Blueprint` instance, promoting code reusability and clarity. The test is simple and direct, focusing solely on the string representation without involving any complex setup or dependencies."
    },
    {
      "name": "test_bp_repr",
      "module": "test_base",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_base.py",
      "line_number": 29,
      "end_line_number": 33,
      "source_code": "def test_bp_repr(bp):\n    assert repr(bp) == (\n        'Blueprint(name=\"my_bp\", url_prefix=None, host=None, '\n        \"version=None, strict_slashes=None)\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "bp"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.exceptions.SanicException"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(bp) == 'Blueprint(name=\"my_bp\", url_prefix=None, host=None, version=None, strict_slashes=None)'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_bp_repr` unit test is designed to verify the string representation of a `Blueprint` object in the Sanic framework. It ensures that the `repr` function returns a specific formatted string that accurately reflects the attributes of the `Blueprint`.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the `repr` method of the `Blueprint` class produces a string that includes the name of the blueprint and its attributes (such as `url_prefix`, `host`, `version`, and `strict_slashes`). The expected output is a clear and structured representation of the `Blueprint` instance.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `repr` method of the `Blueprint` class. When `repr(bp)` is called, it should return a string formatted as follows:  \n`'Blueprint(name=\"my_bp\", url_prefix=None, host=None, version=None, strict_slashes=None)'`. This string includes the name of the blueprint and indicates that all other attributes are set to `None`, which is the default state for a newly created `Blueprint` instance.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern, using `assert` to compare the actual output of `repr(bp)` with the expected string. This direct comparison is a common technique in unit testing to validate that a function or method behaves as intended. The test is also structured to be simple and focused, which is a best practice in unit testing to ensure clarity and maintainability."
    },
    {
      "name": "test_bp_repr_with_values",
      "module": "test_base",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_base.py",
      "line_number": 36,
      "end_line_number": 44,
      "source_code": "def test_bp_repr_with_values(bp):\n    bp.host = \"example.com\"\n    bp.url_prefix = \"/foo\"\n    bp.version = 3\n    bp.strict_slashes = True\n    assert repr(bp) == (\n        'Blueprint(name=\"my_bp\", url_prefix=\"/foo\", host=\"example.com\", '\n        \"version=3, strict_slashes=True)\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "bp"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.exceptions.SanicException"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(bp) == 'Blueprint(name=\"my_bp\", url_prefix=\"/foo\", host=\"example.com\", version=3, strict_slashes=True)'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_bp_repr_with_values` test is to verify the string representation of a `Blueprint` instance in the Sanic framework when specific attributes are set. This ensures that the `__repr__` method of the `Blueprint` class correctly formats the output to reflect the current state of the instance.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `repr` function returns a string that accurately represents the `Blueprint` instance, including its name, URL prefix, host, version, and strict slashes settings. It confirms that the output matches the expected format when the attributes are assigned specific values.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `__repr__` method of the `Blueprint` class. In the test, the `bp` object (an instance of `Blueprint`) is assigned values for `host`, `url_prefix`, `version`, and `strict_slashes`. The test then asserts that calling `repr(bp)` produces a string that matches the expected format, which includes all the set attributes. This ensures that the method constructs the string representation correctly based on the instance's current state.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern, where the output of a method (`repr(bp)`) is compared against an expected string. This is a common technique in unit testing to validate the correctness of methods. Additionally, the test uses a fixture (`bp`) to create a reusable instance of `Blueprint`, promoting code reuse and clarity in the test setup. The use of clear and descriptive assertions enhances the readability and maintainability of the test."
    },
    {
      "name": "test_names_okay",
      "module": "test_base",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_base.py",
      "line_number": 65,
      "end_line_number": 70,
      "source_code": "def test_names_okay(name):\n    app = Sanic(name)\n    bp = Blueprint(name)\n\n    assert app.name == name\n    assert bp.name == name",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('name', ('something', 'some-thing', 'some_thing', 'Something', 'SomeThing', 'Some-Thing', 'Some_Thing', 'SomeThing123', 'something123', 'some-thing123', 'some_thing123', 'some-Thing123', 'some_Thing123'))"
      ],
      "arguments": [
        "name"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.exceptions.SanicException"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.name == name",
        "assert bp.name == name"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_names_okay` function is designed to verify that the `Sanic` application and `Blueprint` instances can be successfully created with valid names. It ensures that the names assigned to these instances match the expected input.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the `name` attribute of both the `Sanic` application and the `Blueprint` instance is correctly set to the provided `name` argument. It confirms that the instantiation of these objects behaves as expected when valid names are used.\n\n**Code Being Tested and How It Works**:  \nThe test creates an instance of `Sanic` and `Blueprint` using the provided `name` parameter. It then asserts that the `name` attributes of both instances are equal to the input `name`. This is a straightforward check to ensure that the constructors of these classes properly assign the name attribute.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs simple assertions to validate the state of the objects after instantiation. It does not utilize any mocking or complex setup, making it a direct and clear unit test. The use of parameterization in related tests (like `test_names_not_okay`) suggests a broader testing strategy to cover both valid and invalid cases for naming conventions, although this specific test focuses solely on the positive case."
    },
    {
      "name": "test_names_not_okay",
      "module": "test_base",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_base.py",
      "line_number": 81,
      "end_line_number": 97,
      "source_code": "def test_names_not_okay(name):\n    app_message = (\n        f\"Sanic instance named '{name}' uses an invalid format. Names must \"\n        \"begin with a character and may only contain alphanumeric \"\n        \"characters, _, or -.\"\n    )\n    bp_message = (\n        f\"Blueprint instance named '{name}' uses an invalid format. Names \"\n        \"must begin with a character and may only contain alphanumeric \"\n        \"characters, _, or -.\"\n    )\n\n    with pytest.raises(SanicException, match=app_message):\n        Sanic(name)\n\n    with pytest.raises(SanicException, match=bp_message):\n        Blueprint(name)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('name', ('123something', 'some thing', 'something!'))"
      ],
      "arguments": [
        "name"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.exceptions.SanicException"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_names_not_okay` function is designed to verify that the `Sanic` and `Blueprint` classes correctly raise a `SanicException` when instantiated with invalid names. This ensures that the naming conventions enforced by the framework are adhered to, preventing potential issues in application behavior.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that both the `Sanic` instance and the `Blueprint` instance reject names that do not conform to the specified format. The expected format requires names to start with a character and only contain alphanumeric characters, underscores, or hyphens. The test asserts that appropriate error messages are generated when invalid names are used.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the constructors for the `Sanic` and `Blueprint` classes. When an invalid name is passed to either constructor, a `SanicException` should be raised. The test constructs specific error messages that are expected to be matched against the exception raised, ensuring that the error handling in the constructors is functioning as intended.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that exceptions are raised during the execution of the code block. This is a common pattern in unit testing for verifying that specific error conditions are met. Additionally, the use of formatted strings for the expected error messages allows for clear and dynamic assertions based on the input name, enhancing the test's readability and maintainability."
    },
    {
      "name": "test_change_decoder",
      "module": "test_json_decoding",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_json_decoding.py",
      "line_number": 24,
      "end_line_number": 26,
      "source_code": "def test_change_decoder():\n    Sanic(\"Test\", loads=sloads)\n    assert Request._loads == sloads",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "json.loads",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.json",
        "ujson.loads"
      ],
      "fixtures": [],
      "assertions": [
        "assert Request._loads == sloads"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_change_decoder` function is designed to verify that the `Sanic` application correctly sets the JSON decoding function for incoming requests. Specifically, it checks that the `Request._loads` attribute is updated to use the specified `sloads` function from the `json` module.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a `Sanic` application is instantiated with a custom JSON loader (in this case, `sloads`), the internal request handling mechanism reflects this change by updating the `_loads` attribute of the `Request` class. It confirms that the application is capable of using different JSON decoding strategies.\n\n**Code Being Tested and How It Works**:  \nThe relevant code being tested is the instantiation of the `Sanic` application with a custom `loads` parameter. The line `Sanic(\"Test\", loads=sloads)` initializes the application with the `sloads` function for JSON decoding. The assertion `assert Request._loads == sloads` checks if the `_loads` attribute of the `Request` class has been set to `sloads`, thereby validating that the application correctly applies the specified decoder.\n\n**Notable Testing Patterns or Techniques Used**:  \nThis test employs a straightforward assertion pattern to verify state changes in the application. It uses the `assert` statement to compare the expected value (`sloads`) with the actual value (`Request._loads`). The test is simple and direct, focusing on the side effect of the `Sanic` constructor on the `Request` class, which is a common practice in unit testing to ensure that configuration changes are applied correctly. Additionally, the use of a fixture (`default_back_to_ujson`) in the broader test suite indicates a pattern of ensuring a clean state before and after tests, which is a good practice in unit testing."
    },
    {
      "name": "test_change_decoder_to_some_custom",
      "module": "test_json_decoding",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_json_decoding.py",
      "line_number": 29,
      "end_line_number": 46,
      "source_code": "def test_change_decoder_to_some_custom():\n    def my_custom_decoder(some_str: str):\n        dict = sloads(some_str)\n        dict[\"some_key\"] = \"new_value\"\n        return dict\n\n    app = Sanic(\"Test\", loads=my_custom_decoder)\n    assert Request._loads == my_custom_decoder\n\n    req_body = {\"some_key\": \"some_value\"}\n\n    @app.post(\"/test\")\n    def handler(request):\n        new_json = request.json\n        return json(new_json)\n\n    req, res = app.test_client.post(\"/test\", json=req_body)\n    assert sloads(res.body) == {\"some_key\": \"new_value\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "json.loads",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.json",
        "ujson.loads"
      ],
      "fixtures": [],
      "assertions": [
        "assert Request._loads == my_custom_decoder",
        "assert sloads(res.body) == {'some_key': 'new_value'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_change_decoder_to_some_custom` test is to verify that a custom JSON decoder can be successfully set and utilized within a Sanic application. It ensures that the application correctly processes incoming JSON requests using the specified custom decoder.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically verifies that when a JSON request is made to the Sanic application, the custom decoder modifies the incoming JSON data as expected. In this case, it checks that the key `\"some_key\"` in the request body is transformed to have the value `\"new_value\"` in the response.\n\n**Code Being Tested and How It Works**:  \nThe test defines a custom decoder function, `my_custom_decoder`, which uses the standard `sloads` function to load a JSON string into a dictionary and then modifies the dictionary by changing the value of `\"some_key\"`. The Sanic application is instantiated with this custom decoder. The test then defines a POST route that returns the JSON data received in the request. After sending a POST request with a specific JSON body, the test asserts that the response body matches the expected modified dictionary.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Custom Decoder**: The test demonstrates the use of a custom decoder function to manipulate JSON data before it is processed by the application.\n- **Assertions**: It employs assertions to validate both the setting of the custom decoder and the correctness of the response data.\n- **Sanic Test Client**: The test utilizes the Sanic test client to simulate HTTP requests and responses, allowing for integration-style testing of the application\u2019s behavior.\n- **Isolation**: The test is designed to run independently, ensuring that the custom decoder does not affect other tests by using a fixture to reset the decoder after the test completes."
    },
    {
      "name": "test_default_decoder",
      "module": "test_json_decoding",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_json_decoding.py",
      "line_number": 50,
      "end_line_number": 52,
      "source_code": "def test_default_decoder():\n    Sanic(\"Test\")\n    assert Request._loads == uloads",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(NO_UJSON is True, reason='ujson not installed')"
      ],
      "arguments": [],
      "imports": [
        "json.loads",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.json",
        "ujson.loads"
      ],
      "fixtures": [],
      "assertions": [
        "assert Request._loads == uloads"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_default_decoder` unit test is designed to verify that the default JSON decoding function used by the Sanic framework is set to `uloads` (from the `ujson` library) when it is available. This ensures that the application is using the most efficient JSON decoder for performance.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the `Request._loads` attribute, which is responsible for loading JSON data in Sanic, is correctly assigned to `uloads`. If `ujson` is not installed, the test will be skipped, indicating that the functionality is contingent on the presence of the `ujson` library.\n\n**Code Being Tested and How It Works**:  \nThe relevant code being tested is the initialization of the Sanic application and the assignment of the JSON loading function. The line `assert Request._loads == uloads` confirms that the `Request` class's `_loads` attribute is equal to `uloads`, which is expected to be the default decoder if `ujson` is available. The test indirectly relies on the behavior of the Sanic framework to set this attribute during application initialization.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Conditional Testing**: The use of `@pytest.mark.skipif` allows the test to be conditionally skipped if `ujson` is not installed, which is a good practice to avoid false negatives in test results.\n- **Fixture Usage**: The test leverages the `default_back_to_ujson` fixture (though not directly in this test) to ensure that the state is reset after each test, maintaining isolation and preventing side effects between tests.\n- **Assertions**: The test employs a straightforward assertion to validate the expected state of the application, which is a common pattern in unit testing to confirm that the code behaves as intended."
    },
    {
      "name": "test_add_register_priority",
      "module": "test_middleware_priority",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware_priority.py",
      "line_number": 43,
      "end_line_number": 53,
      "source_code": "def test_add_register_priority(app: Sanic):\n    def foo(*_): ...\n\n    app.register_middleware(foo, priority=999)\n    assert len(app.request_middleware) == 1\n    assert len(app.response_middleware) == 0\n    assert app.request_middleware[0].priority == 999  # type: ignore\n    app.register_middleware(foo, attach_to=\"response\", priority=999)\n    assert len(app.request_middleware) == 1\n    assert len(app.response_middleware) == 1\n    assert app.response_middleware[0].priority == 999",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "functools.partial",
        "pytest",
        "sanic.Sanic",
        "sanic.middleware.Middleware",
        "sanic.middleware.MiddlewareLocation",
        "sanic.response.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(app.request_middleware) == 1",
        "assert len(app.response_middleware) == 0",
        "assert app.request_middleware[0].priority == 999",
        "assert len(app.request_middleware) == 1",
        "assert len(app.response_middleware) == 1",
        "assert app.response_middleware[0].priority == 999"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_add_register_priority` function is designed to verify the correct registration and prioritization of middleware in a Sanic application. It ensures that middleware can be added with specified priorities and that these priorities are respected when the middleware is invoked.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. A middleware function can be registered for request handling with a specified priority.\n2. The middleware is correctly added to the request middleware list.\n3. The middleware can also be registered for response handling, and it verifies that the response middleware list is updated accordingly.\n4. The priority of the registered middleware is accurately reflected in the middleware's properties.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `Sanic` application instance, specifically using the `register_middleware` method. It first registers a middleware function `foo` with a priority of 999 for request handling. The assertions confirm that the request middleware list contains one middleware with the correct priority. Then, it registers the same middleware for response handling, again with a priority of 999, and checks that the response middleware list is updated correctly. The middleware's priority is accessed directly to ensure it matches the expected value.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertions**: The test uses assertions to validate the state of the middleware lists and their priorities after each registration, ensuring that the expected outcomes are met.\n- **Isolation**: The test focuses on a single aspect of middleware registration, allowing for clear identification of any issues related to priority handling.\n- **Direct Property Access**: The test accesses the properties of the middleware directly to verify that the priority is set correctly, which is a common practice in unit testing to ensure that the internal state of objects is as expected."
    },
    {
      "name": "test_add_register_named_priority",
      "module": "test_middleware_priority",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware_priority.py",
      "line_number": 56,
      "end_line_number": 68,
      "source_code": "def test_add_register_named_priority(app: Sanic):\n    def foo(*_): ...\n\n    app.register_named_middleware(foo, route_names=[\"foo\"], priority=999)\n    assert len(app.named_request_middleware) == 1\n    assert len(app.named_response_middleware) == 0\n    assert app.named_request_middleware[\"foo\"][0].priority == 999  # type: ignore\n    app.register_named_middleware(\n        foo, attach_to=\"response\", route_names=[\"foo\"], priority=999\n    )\n    assert len(app.named_request_middleware) == 1\n    assert len(app.named_response_middleware) == 1\n    assert app.named_response_middleware[\"foo\"][0].priority == 999",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "functools.partial",
        "pytest",
        "sanic.Sanic",
        "sanic.middleware.Middleware",
        "sanic.middleware.MiddlewareLocation",
        "sanic.response.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(app.named_request_middleware) == 1",
        "assert len(app.named_response_middleware) == 0",
        "assert app.named_request_middleware['foo'][0].priority == 999",
        "assert len(app.named_request_middleware) == 1",
        "assert len(app.named_response_middleware) == 1",
        "assert app.named_response_middleware['foo'][0].priority == 999"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_add_register_named_priority` test verifies the functionality of registering named middleware in a Sanic application, specifically focusing on the correct handling of middleware priorities for both request and response types.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when a named middleware is registered with a specified priority, it is correctly added to the application's middleware lists. It ensures that the middleware is accessible via its name and that the priority is set as expected. The test also confirms that the middleware behaves correctly when registered for both request and response phases.\n\n**Code Being Tested and How It Works**:  \nThe test uses the `app.register_named_middleware` method to register a middleware function (`foo`) with a priority of 999 for specific route names. It first registers the middleware for the request phase and checks the lengths and priorities of the `named_request_middleware` and `named_response_middleware` attributes of the `app` instance. After that, it registers the same middleware for the response phase and performs similar assertions to ensure that the middleware is correctly added to the response middleware list.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertions**: The test employs assertions to validate the state of the middleware lists and their priorities after each registration, ensuring that the expected conditions are met.\n- **Separation of Concerns**: By testing the registration of middleware separately for request and response phases, the test maintains clarity and focuses on specific behaviors.\n- **Use of Named Middleware**: The test demonstrates the use of named middleware, which allows for more organized and manageable middleware registration, especially in larger applications."
    },
    {
      "name": "test_add_decorator_priority",
      "module": "test_middleware_priority",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware_priority.py",
      "line_number": 71,
      "end_line_number": 81,
      "source_code": "def test_add_decorator_priority(app: Sanic):\n    def foo(*_): ...\n\n    app.middleware(foo, priority=999)\n    assert len(app.request_middleware) == 1\n    assert len(app.response_middleware) == 0\n    assert app.request_middleware[0].priority == 999  # type: ignore\n    app.middleware(foo, attach_to=\"response\", priority=999)\n    assert len(app.request_middleware) == 1\n    assert len(app.response_middleware) == 1\n    assert app.response_middleware[0].priority == 999",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "functools.partial",
        "pytest",
        "sanic.Sanic",
        "sanic.middleware.Middleware",
        "sanic.middleware.MiddlewareLocation",
        "sanic.response.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(app.request_middleware) == 1",
        "assert len(app.response_middleware) == 0",
        "assert app.request_middleware[0].priority == 999",
        "assert len(app.request_middleware) == 1",
        "assert len(app.response_middleware) == 1",
        "assert app.response_middleware[0].priority == 999"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_add_decorator_priority` function is designed to verify the correct registration and prioritization of middleware in a Sanic application. It ensures that middleware can be added with specified priorities and that the middleware is categorized correctly as either request or response middleware.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. A middleware function (`foo`) can be registered with a high priority (999) for request handling.\n2. The middleware is correctly added to the request middleware list and not to the response middleware list initially.\n3. When the same middleware is registered for response handling with the same priority, it verifies that it is added to the response middleware list as expected.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `Sanic` application instance (`app`) to register middleware using the `app.middleware` method. The middleware function `foo` is defined as a no-op (does nothing). The test first registers `foo` for request handling and checks the lengths and priorities of the middleware lists. It then registers `foo` for response handling and performs similar checks to ensure that the middleware is categorized and prioritized correctly.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertions**: The test uses assertions to validate the state of the middleware lists after each registration, ensuring that the expected conditions are met.\n- **Priority Handling**: The test specifically checks the priority attribute of the middleware, demonstrating the importance of middleware order in request/response processing.\n- **Separation of Concerns**: By testing the addition of middleware separately for requests and responses, the test adheres to the principle of testing one aspect of functionality at a time, which enhances clarity and maintainability."
    },
    {
      "name": "test_add_convenience_priority",
      "module": "test_middleware_priority",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware_priority.py",
      "line_number": 84,
      "end_line_number": 94,
      "source_code": "def test_add_convenience_priority(app: Sanic):\n    def foo(*_): ...\n\n    app.on_request(foo, priority=999)\n    assert len(app.request_middleware) == 1\n    assert len(app.response_middleware) == 0\n    assert app.request_middleware[0].priority == 999  # type: ignore\n    app.on_response(foo, priority=999)\n    assert len(app.request_middleware) == 1\n    assert len(app.response_middleware) == 1\n    assert app.response_middleware[0].priority == 999",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "functools.partial",
        "pytest",
        "sanic.Sanic",
        "sanic.middleware.Middleware",
        "sanic.middleware.MiddlewareLocation",
        "sanic.response.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(app.request_middleware) == 1",
        "assert len(app.response_middleware) == 0",
        "assert app.request_middleware[0].priority == 999",
        "assert len(app.request_middleware) == 1",
        "assert len(app.response_middleware) == 1",
        "assert app.response_middleware[0].priority == 999"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_add_convenience_priority` test verifies the functionality of adding middleware to a Sanic application with specific priority levels for request and response handling. It ensures that middleware can be registered correctly and that the priority is respected.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when middleware is added to handle requests and responses, the middleware is stored in the appropriate lists (`request_middleware` and `response_middleware`) and that the priority of the middleware is set as expected. It confirms that the middleware for requests and responses can coexist without interference.\n\n**Code Being Tested and How It Works**:  \nThe test uses the `app.on_request` and `app.on_response` methods to register a middleware function (`foo`) with a priority of 999. After each registration, assertions are made to check the lengths of the `request_middleware` and `response_middleware` lists and to verify that the priority of the added middleware matches the expected value. The middleware function itself is a placeholder that does not perform any operations.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertions**: The test employs assertions to validate the state of the application after middleware registration, ensuring that the expected conditions are met.\n- **Priority Handling**: The test specifically focuses on the priority mechanism, which is crucial for middleware execution order in web frameworks.\n- **Isolation**: Each middleware addition is tested in isolation, allowing for clear verification of the behavior of the `on_request` and `on_response` methods without side effects from other tests."
    },
    {
      "name": "test_add_conflicting_priority",
      "module": "test_middleware_priority",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware_priority.py",
      "line_number": 97,
      "end_line_number": 103,
      "source_code": "def test_add_conflicting_priority(app: Sanic):\n    def foo(*_): ...\n\n    middleware = Middleware(foo, MiddlewareLocation.REQUEST, priority=998)\n    app.register_middleware(middleware=middleware, priority=999)\n    assert app.request_middleware[0].priority == 999  # type: ignore\n    middleware.priority == 998",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "functools.partial",
        "pytest",
        "sanic.Sanic",
        "sanic.middleware.Middleware",
        "sanic.middleware.MiddlewareLocation",
        "sanic.response.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.request_middleware[0].priority == 999"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_add_conflicting_priority` test is designed to verify the behavior of middleware registration in the Sanic framework when two middleware functions are registered with conflicting priorities. Specifically, it checks that the middleware with the higher priority (999) is correctly placed in the middleware stack, overriding the one with the lower priority (998).\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when middleware is registered with a higher priority than an existing middleware, the new middleware takes precedence in the execution order. It asserts that the middleware with priority 999 is indeed the first in the request middleware list, while the original middleware retains its priority of 998.\n\n**Code Being Tested and How It Works**:  \nThe test creates a middleware function `foo` and registers it with a priority of 998. It then registers another middleware with the same function but with a higher priority of 999. The assertion checks that the first middleware in the `app.request_middleware` list has a priority of 999, confirming that the registration order respects the priority levels. The line `middleware.priority == 998` is a standalone expression that does not assert anything, which may be an oversight.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern to validate the expected state of the middleware list after registration. It uses the Sanic framework's middleware registration mechanism to simulate real-world usage scenarios. The test also demonstrates the use of priority management in middleware, which is a common pattern in web frameworks to control the order of middleware execution."
    },
    {
      "name": "test_add_conflicting_priority_named",
      "module": "test_middleware_priority",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware_priority.py",
      "line_number": 106,
      "end_line_number": 114,
      "source_code": "def test_add_conflicting_priority_named(app: Sanic):\n    def foo(*_): ...\n\n    middleware = Middleware(foo, MiddlewareLocation.REQUEST, priority=998)\n    app.register_named_middleware(\n        middleware=middleware, route_names=[\"foo\"], priority=999\n    )\n    assert app.named_request_middleware[\"foo\"][0].priority == 999  # type: ignore\n    middleware.priority == 998",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "functools.partial",
        "pytest",
        "sanic.Sanic",
        "sanic.middleware.Middleware",
        "sanic.middleware.MiddlewareLocation",
        "sanic.response.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.named_request_middleware['foo'][0].priority == 999"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_add_conflicting_priority_named` aims to verify the behavior of the Sanic application when registering named middleware with conflicting priorities. Specifically, it checks that the middleware with the higher priority (999) is correctly registered and takes precedence over the middleware with a lower priority (998).\n\n**Specific Functionality or Behavior Verified**:  \nThe test ensures that when two middleware functions are registered with the same route name but different priorities, the middleware with the higher priority is the one that is actually used. It asserts that the priority of the middleware registered last (999) is correctly reflected in the application's middleware registry.\n\n**Code Being Tested and How It Works**:  \nThe test creates a middleware function `foo` and registers it twice with the Sanic application: first with a priority of 998 and then with a priority of 999. The assertion checks that the first middleware in the list for the route name \"foo\" has a priority of 999, confirming that the latter registration has taken effect. The line `middleware.priority == 998` is a standalone expression that does not contribute to the test's assertions but indicates the original priority of the first middleware.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern to validate the expected state of the application's middleware registry. It uses the `assert` statement to check the priority of the middleware, which is a common practice in unit testing to ensure that the code behaves as expected. The use of named middleware and priority management reflects a design pattern that allows for flexible middleware registration and execution order, which is crucial in web frameworks like Sanic."
    },
    {
      "name": "test_request_middleware_order_priority",
      "module": "test_middleware_priority",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware_priority.py",
      "line_number": 121,
      "end_line_number": 139,
      "source_code": "def test_request_middleware_order_priority(app: Sanic, expected, priorities):\n    order = []\n\n    def add_ident(request, ident):\n        order.append(ident)\n\n    @app.get(\"/\")\n    def handler(request):\n        return json(None)\n\n    for ident, priority in enumerate(priorities):\n        kwargs = {}\n        if priority is not None:\n            kwargs[\"priority\"] = priority\n        app.on_request(partial(add_ident, ident=ident), **kwargs)\n\n    app.test_client.get(\"/\")\n\n    assert order == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('expected,priorities', PRIORITY_TEST_CASES)"
      ],
      "arguments": [
        "app",
        "expected",
        "priorities"
      ],
      "imports": [
        "functools.partial",
        "pytest",
        "sanic.Sanic",
        "sanic.middleware.Middleware",
        "sanic.middleware.MiddlewareLocation",
        "sanic.response.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert order == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_request_middleware_order_priority` test verifies that the order of middleware execution in a Sanic application respects the specified priority levels. It ensures that middleware functions are executed in the correct order based on their assigned priorities when handling a request.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that middleware functions are executed in the order defined by their priority values. The expected order of execution is compared against the actual order recorded during the request handling, ensuring that middleware with higher priority values runs before those with lower values.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Sanic application and registers multiple middleware functions with varying priority levels. The `add_ident` function appends an identifier to the `order` list whenever it is called. After registering the middleware, a GET request is made to the root endpoint (\"/\"). The test then asserts that the order of identifiers in the `order` list matches the expected order defined in the `expected` argument, which is provided through parameterization.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses `pytest.mark.parametrize` to run the same test logic with different sets of expected outcomes and priorities, allowing for comprehensive coverage of various scenarios without duplicating code.\n- **Partial Functions**: The `functools.partial` is used to create a version of the `add_ident` function that includes the identifier, demonstrating a technique for customizing function behavior in middleware registration.\n- **Assertion**: The test concludes with an assertion that checks if the actual order of middleware execution matches the expected order, which is a fundamental aspect of unit testing to validate functionality."
    },
    {
      "name": "test_response_middleware_order_priority",
      "module": "test_middleware_priority",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware_priority.py",
      "line_number": 146,
      "end_line_number": 164,
      "source_code": "def test_response_middleware_order_priority(app: Sanic, expected, priorities):\n    order = []\n\n    def add_ident(request, response, ident):\n        order.append(ident)\n\n    @app.get(\"/\")\n    def handler(request):\n        return json(None)\n\n    for ident, priority in enumerate(priorities):\n        kwargs = {}\n        if priority is not None:\n            kwargs[\"priority\"] = priority\n        app.on_response(partial(add_ident, ident=ident), **kwargs)\n\n    app.test_client.get(\"/\")\n\n    assert order[::-1] == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('expected,priorities', PRIORITY_TEST_CASES)"
      ],
      "arguments": [
        "app",
        "expected",
        "priorities"
      ],
      "imports": [
        "functools.partial",
        "pytest",
        "sanic.Sanic",
        "sanic.middleware.Middleware",
        "sanic.middleware.MiddlewareLocation",
        "sanic.response.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert order[::-1] == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_response_middleware_order_priority` test is designed to verify that the order of response middleware execution in a Sanic application adheres to the specified priorities. It ensures that middleware functions are executed in the correct order based on their assigned priority values when handling a response.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the middleware functions are invoked in the expected order when a response is generated. The expected order is determined by the `priorities` parameter, and the test asserts that the actual order of execution matches the expected order after reversing it. This reversal is necessary because the middleware is executed in a last-in-first-out (LIFO) manner.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Sanic application and registers multiple response middleware functions using the `app.on_response` method. Each middleware function appends its identifier to the `order` list. The `handler` function is defined to respond to GET requests at the root endpoint. After registering the middleware, the test simulates a GET request to the root endpoint using `app.test_client.get(\"/\")`. Finally, it asserts that the recorded order of middleware execution (reversed) matches the expected order provided in the test parameters.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses `pytest.mark.parametrize` to run the same test logic with different sets of expected values and priorities, allowing for comprehensive testing of various scenarios without duplicating code.\n- **Partial Functions**: The `partial` function from the `functools` module is used to create middleware functions with fixed identifiers, simplifying the registration process.\n- **Assertion of Order**: The test employs an assertion that checks the order of execution by reversing the collected order, which is a common technique in testing scenarios where the order of operations is critical."
    },
    {
      "name": "test_bad_request_response",
      "module": "test_bad_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_bad_request.py",
      "line_number": 6,
      "end_line_number": 26,
      "source_code": "def test_bad_request_response(app: Sanic):\n    lines = []\n\n    app.get(\"/\")(lambda x: ...)\n\n    @app.listener(\"after_server_start\")\n    async def _request(sanic, loop):\n        nonlocal lines\n        connect = asyncio.open_connection(\"127.0.0.1\", 42101)\n        reader, writer = await connect\n        writer.write(b\"not http\\r\\n\\r\\n\")\n        while True:\n            line = await reader.readline()\n            if not line:\n                break\n            lines.append(line)\n        app.stop()\n\n    app.run(host=\"127.0.0.1\", port=42101, debug=False, single_process=True)\n    assert lines[0] == b\"HTTP/1.1 400 Bad Request\\r\\n\"\n    assert b\"Bad Request\" in lines[-2]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "sanic.Sanic"
      ],
      "fixtures": [],
      "assertions": [
        "assert lines[0] == b'HTTP/1.1 400 Bad Request\\r\\n'",
        "assert b'Bad Request' in lines[-2]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_bad_request_response` function is designed to verify that the Sanic application correctly handles malformed HTTP requests by returning a 400 Bad Request response. This ensures that the application can gracefully manage invalid input from clients.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that when a non-HTTP request (in this case, `b\"not http\\r\\n\\r\\n\"`) is sent to the server, the server responds with a 400 Bad Request status. It also verifies that the response contains the phrase \"Bad Request\" in the response body, confirming that the server's error handling is functioning as expected.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Sanic application and defines a route that does not perform any meaningful action (using a lambda function). It then establishes an asynchronous listener that triggers after the server starts. This listener opens a connection to the server, sends a malformed request, and reads the response lines. The assertions at the end check the first line of the response for the correct status code and ensure that the error message is present in the response.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test utilizes asynchronous functions to handle the server's lifecycle and the request-response cycle, which is essential for testing web applications that operate in an asynchronous environment.\n- **Nonlocal Variables**: The use of `nonlocal` allows the inner listener function to modify the `lines` list defined in the outer function scope, facilitating the collection of response data.\n- **Direct Socket Communication**: The test directly interacts with the server via socket connections, simulating real client behavior and allowing for precise control over the requests sent to the server.\n- **Assertions**: The test employs assertions to validate the expected outcomes, ensuring that the server's response matches the anticipated error handling behavior."
    },
    {
      "name": "test_unix_socket_creation",
      "module": "test_unix_socket",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_unix_socket.py",
      "line_number": 60,
      "end_line_number": 84,
      "source_code": "def test_unix_socket_creation(caplog: LogCaptureFixture):\n    from socket import AF_UNIX, socket\n\n    with socket(AF_UNIX) as sock:\n        sock.bind(SOCKPATH)\n    assert os.path.exists(SOCKPATH)\n    ino = os.stat(SOCKPATH).st_ino\n\n    app = Sanic(name=\"test\")\n\n    @app.after_server_start\n    def running(app: Sanic):\n        assert os.path.exists(SOCKPATH)\n        assert ino != os.stat(SOCKPATH).st_ino\n        app.stop()\n\n    with caplog.at_level(logging.INFO):\n        app.run(unix=SOCKPATH, single_process=True)\n\n    assert (\n        \"sanic.root\",\n        logging.INFO,\n        f\"Goin' Fast @ {SOCKPATH} http://...\",\n    ) in caplog.record_tuples\n    assert not os.path.exists(SOCKPATH)",
      "docstring": null,
      "decorators": [
        "pytest.mark.xfail(reason='Flaky Test on Non Linux Infra')"
      ],
      "arguments": [
        "caplog"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "asyncio.AbstractEventLoop",
        "asyncio.sleep",
        "pathlib.Path",
        "string.ascii_lowercase",
        "httpcore",
        "httpx",
        "pytest",
        "pytest.LogCaptureFixture",
        "sanic.Sanic",
        "sanic.compat.use_context",
        "sanic.request.Request",
        "sanic.response.text",
        "socket.AF_UNIX",
        "socket.socket",
        "socket.AF_UNIX",
        "socket.socket"
      ],
      "fixtures": [],
      "assertions": [
        "assert os.path.exists(SOCKPATH)",
        "assert ('sanic.root', logging.INFO, f\"Goin' Fast @ {SOCKPATH} http://...\") in caplog.record_tuples",
        "assert not os.path.exists(SOCKPATH)",
        "assert os.path.exists(SOCKPATH)",
        "assert ino != os.stat(SOCKPATH).st_ino"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        },
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_unix_socket_creation` unit test is designed to verify the correct creation and management of a Unix socket by the Sanic application. It ensures that the socket is created, that the application can run using this socket, and that the socket is properly cleaned up after the application stops.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks several key behaviors:\n1. It verifies that the socket file is created at the specified path (`SOCKPATH`).\n2. It ensures that the inode number of the socket changes after the server starts, indicating that a new socket is created.\n3. It confirms that the application logs the expected message when it starts running.\n4. It checks that the socket file is deleted after the application stops.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `Sanic` application, specifically testing the `app.run()` method with a Unix socket. The `app.run()` method is responsible for starting the server, and it binds to the specified Unix socket path. The `app.stop()` method is called to stop the server, which is expected to clean up the socket file. The test also uses `os.path.exists()` and `os.stat()` to check the existence and properties of the socket file.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Managers**: The test uses context managers (`with` statements) to manage resources like the socket and logging levels, ensuring proper setup and teardown.\n- **Logging Capture**: The `caplog` fixture is used to capture log messages generated during the test, allowing assertions on the log output.\n- **Assertions**: Multiple assertions are employed to validate the expected state of the socket file and the log messages, ensuring comprehensive verification of the functionality being tested."
    },
    {
      "name": "test_invalid_paths",
      "module": "test_unix_socket",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_unix_socket.py",
      "line_number": 88,
      "end_line_number": 92,
      "source_code": "def test_invalid_paths(path: str):\n    app = Sanic(name=\"test\")\n    #\n    with pytest.raises((FileExistsError, FileNotFoundError)):\n        app.run(unix=path, single_process=True)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('path', ('.', 'no-such-directory/sanictest.sock'))"
      ],
      "arguments": [
        "path"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "asyncio.AbstractEventLoop",
        "asyncio.sleep",
        "pathlib.Path",
        "string.ascii_lowercase",
        "httpcore",
        "httpx",
        "pytest",
        "pytest.LogCaptureFixture",
        "sanic.Sanic",
        "sanic.compat.use_context",
        "sanic.request.Request",
        "sanic.response.text",
        "socket.AF_UNIX",
        "socket.socket",
        "socket.AF_UNIX",
        "socket.socket"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_invalid_paths` function is designed to verify that the Sanic application correctly raises exceptions when attempting to run with invalid Unix socket paths. Specifically, it checks for `FileExistsError` and `FileNotFoundError`, which are expected when the provided path does not point to a valid socket.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the application does not start if the specified Unix socket path is invalid. It confirms that the application handles such scenarios gracefully by raising the appropriate exceptions, thereby preventing the server from running in an invalid state.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `app.run()` method of the Sanic application, which is invoked with the `unix` parameter set to the provided `path`. The `run` method attempts to bind the server to the specified Unix socket. If the path is invalid (e.g., it does not exist or is not a socket), it raises either a `FileExistsError` or a `FileNotFoundError`, which the test is designed to catch.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that specific exceptions are raised during the execution of the `app.run()` method. This is a common pattern in unit testing that allows for clean and readable verification of error conditions. Additionally, the use of parameterization (though not shown in this specific test) in other tests indicates a broader strategy of testing multiple scenarios efficiently."
    },
    {
      "name": "test_dont_replace_file",
      "module": "test_unix_socket",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_unix_socket.py",
      "line_number": 95,
      "end_line_number": 105,
      "source_code": "def test_dont_replace_file():\n    SOCKPATH.write_text(\"File, not socket\")\n\n    app = Sanic(name=\"test\")\n\n    @app.after_server_start\n    def stop(app: Sanic):\n        app.stop()\n\n    with pytest.raises(FileExistsError):\n        app.run(unix=SOCKPATH, single_process=True)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "os",
        "sys",
        "asyncio.AbstractEventLoop",
        "asyncio.sleep",
        "pathlib.Path",
        "string.ascii_lowercase",
        "httpcore",
        "httpx",
        "pytest",
        "pytest.LogCaptureFixture",
        "sanic.Sanic",
        "sanic.compat.use_context",
        "sanic.request.Request",
        "sanic.response.text",
        "socket.AF_UNIX",
        "socket.socket",
        "socket.AF_UNIX",
        "socket.socket"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        },
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_dont_replace_file` unit test is designed to verify that the Sanic application correctly raises a `FileExistsError` when an attempt is made to run the application using a Unix socket path that is already occupied by a regular file.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks the behavior of the `app.run()` method when the specified Unix socket path (`SOCKPATH`) is not a socket but a regular file. The expected outcome is that the application should not start and should raise a `FileExistsError`, indicating that the socket cannot be created because a file with the same name already exists.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `app.run()` method, which is responsible for starting the Sanic application. The method attempts to bind to the specified Unix socket path. In this test, `SOCKPATH.write_text(\"File, not socket\")` creates a regular file at the socket path. When `app.run(unix=SOCKPATH, single_process=True)` is called, it checks if the path is a valid socket. Since it is not (it's a regular file), the method raises a `FileExistsError`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that a specific exception (`FileExistsError`) is raised during the execution of the `app.run()` method. This is a common pattern in unit testing to verify that error conditions are handled correctly. Additionally, the use of the `@app.after_server_start` decorator to define a cleanup function (`stop`) ensures that the application stops after the test runs, maintaining a clean state for subsequent tests."
    },
    {
      "name": "test_dont_follow_symlink",
      "module": "test_unix_socket",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_unix_socket.py",
      "line_number": 108,
      "end_line_number": 122,
      "source_code": "def test_dont_follow_symlink():\n    from socket import AF_UNIX, socket\n\n    with socket(AF_UNIX) as sock:\n        sock.bind(SOCKPATH2)\n    os.symlink(SOCKPATH2, SOCKPATH)\n\n    app = Sanic(name=\"test\")\n\n    @app.after_server_start\n    def stop(app: Sanic):\n        app.stop()\n\n    with pytest.raises(FileExistsError):\n        app.run(unix=SOCKPATH, single_process=True)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "os",
        "sys",
        "asyncio.AbstractEventLoop",
        "asyncio.sleep",
        "pathlib.Path",
        "string.ascii_lowercase",
        "httpcore",
        "httpx",
        "pytest",
        "pytest.LogCaptureFixture",
        "sanic.Sanic",
        "sanic.compat.use_context",
        "sanic.request.Request",
        "sanic.response.text",
        "socket.AF_UNIX",
        "socket.socket",
        "socket.AF_UNIX",
        "socket.socket"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        },
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_dont_follow_symlink` test is designed to verify that the Sanic application correctly raises a `FileExistsError` when attempting to bind to a Unix socket that is already represented by a symbolic link. This ensures that the application does not inadvertently follow symlinks, which could lead to unexpected behavior or security issues.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks the behavior of the `app.run()` method when it encounters a Unix socket path that is a symlink to an existing socket. The expected outcome is that the application should not start and should raise a `FileExistsError`, indicating that the socket path is already in use.\n\n**Code Being Tested and How It Works**:  \nThe test creates a Unix socket at `SOCKPATH2` and then creates a symbolic link at `SOCKPATH` pointing to `SOCKPATH2`. When `app.run(unix=SOCKPATH, single_process=True)` is called, the Sanic application attempts to bind to the socket at `SOCKPATH`. Since `SOCKPATH` is a symlink to an existing socket, the application raises a `FileExistsError`, which is captured by the `pytest.raises` context manager.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Managers**: The use of `with` statements for socket creation and exception handling allows for clean resource management and ensures that the test is both readable and maintainable.\n- **Exception Assertion**: The test employs `pytest.raises` to assert that a specific exception (`FileExistsError`) is raised, which is a common pattern in unit testing to verify error handling.\n- **Isolation of Side Effects**: The test isolates the creation of the socket and symlink, ensuring that the test environment is controlled and that the test does not interfere with other tests or system state."
    },
    {
      "name": "test_socket_deleted_while_running",
      "module": "test_unix_socket",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_unix_socket.py",
      "line_number": 125,
      "end_line_number": 133,
      "source_code": "def test_socket_deleted_while_running():\n    app = Sanic(name=\"test\")\n\n    @app.after_server_start\n    async def hack(app: Sanic):\n        os.unlink(SOCKPATH)\n        app.stop()\n\n    app.run(host=\"myhost.invalid\", unix=SOCKPATH, single_process=True)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "os",
        "sys",
        "asyncio.AbstractEventLoop",
        "asyncio.sleep",
        "pathlib.Path",
        "string.ascii_lowercase",
        "httpcore",
        "httpx",
        "pytest",
        "pytest.LogCaptureFixture",
        "sanic.Sanic",
        "sanic.compat.use_context",
        "sanic.request.Request",
        "sanic.response.text",
        "socket.AF_UNIX",
        "socket.socket",
        "socket.AF_UNIX",
        "socket.socket"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_socket_deleted_while_running` test is designed to verify the behavior of the Sanic application when the Unix socket it is bound to is deleted while the server is running. This scenario is crucial for ensuring that the application can handle unexpected changes to its socket file gracefully.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the Sanic application can detect the deletion of its socket file and subsequently stop the server. It ensures that the application does not crash or hang when the socket is removed, which is important for maintaining stability in production environments.\n\n**Code Being Tested and How It Works**:  \nThe test creates a Sanic application instance and defines an asynchronous function `hack` that is registered to run after the server starts (`@app.after_server_start`). This function deletes the socket file specified by `SOCKPATH` using `os.unlink(SOCKPATH)` and then calls `app.stop()` to stop the server. The server is then started with `app.run()`, which binds to the specified Unix socket. The test indirectly verifies that the server can handle the socket deletion without errors.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test utilizes asynchronous functions to handle the server's lifecycle events, which is a common pattern in modern web frameworks that support async operations.\n- **Lifecycle Hooks**: The use of `@app.after_server_start` demonstrates the use of lifecycle hooks to execute code at specific points in the server's lifecycle, allowing for clean and organized management of server behavior.\n- **Resource Management**: The test implicitly checks resource management by ensuring that the server can handle the deletion of its socket file, which is a critical aspect of robust server design."
    },
    {
      "name": "test_socket_replaced_with_file",
      "module": "test_unix_socket",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_unix_socket.py",
      "line_number": 136,
      "end_line_number": 146,
      "source_code": "def test_socket_replaced_with_file():\n    app = Sanic(name=\"test\")\n\n    @app.after_server_start\n    async def hack(app: Sanic):\n        os.unlink(SOCKPATH)\n        with open(SOCKPATH, \"w\") as f:\n            f.write(\"Not a socket\")\n        app.stop()\n\n    app.run(host=\"myhost.invalid\", unix=SOCKPATH, single_process=True)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "os",
        "sys",
        "asyncio.AbstractEventLoop",
        "asyncio.sleep",
        "pathlib.Path",
        "string.ascii_lowercase",
        "httpcore",
        "httpx",
        "pytest",
        "pytest.LogCaptureFixture",
        "sanic.Sanic",
        "sanic.compat.use_context",
        "sanic.request.Request",
        "sanic.response.text",
        "socket.AF_UNIX",
        "socket.socket",
        "socket.AF_UNIX",
        "socket.socket"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_socket_replaced_with_file` unit test aims to verify the behavior of the Sanic application when a Unix socket file is replaced with a regular file during the server's startup process. This is crucial for ensuring that the application handles such scenarios gracefully and does not crash or behave unexpectedly.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the Sanic application can start without raising an error when the socket file (specified by `SOCKPATH`) is replaced with a non-socket file. The expectation is that the application should not attempt to bind to a non-socket file, which would typically result in an error.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `app.run()` method, which is responsible for starting the Sanic server and binding it to the specified Unix socket. The test modifies the socket file by unlinking it and then writing a string (\"Not a socket\") to the same path. The `app.stop()` method is called to stop the server after the modification. The test does not assert any specific outcome, which may imply that it is primarily checking for the absence of exceptions during the server's startup.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of an asynchronous callback (`@app.after_server_start`) to perform actions after the server has started. This pattern allows for modifications to the socket file while the server is running. Additionally, the test uses the `os.unlink()` function to remove the existing socket file, demonstrating a direct manipulation of the filesystem to simulate the test scenario. However, it lacks assertions to validate the expected behavior, which is a notable omission in unit testing best practices."
    },
    {
      "name": "test_unix_connection",
      "module": "test_unix_socket",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_unix_socket.py",
      "line_number": 149,
      "end_line_number": 170,
      "source_code": "def test_unix_connection():\n    app = Sanic(name=\"test\")\n\n    @app.get(\"/\")\n    def handler(request: Request):\n        return text(f\"{request.conn_info.server}\")\n\n    @app.after_server_start\n    async def client(app: Sanic):\n        if httpx_version >= (0, 20):\n            transport = httpx.AsyncHTTPTransport(uds=SOCKPATH)\n        else:\n            transport = httpcore.AsyncConnectionPool(uds=SOCKPATH)\n        try:\n            async with httpx.AsyncClient(transport=transport) as client:\n                r = await client.get(\"http://myhost.invalid/\")\n                assert r.status_code == 200\n                assert r.text == os.path.abspath(SOCKPATH)\n        finally:\n            app.stop()\n\n    app.run(host=\"myhost.invalid\", unix=SOCKPATH, single_process=True)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "os",
        "sys",
        "asyncio.AbstractEventLoop",
        "asyncio.sleep",
        "pathlib.Path",
        "string.ascii_lowercase",
        "httpcore",
        "httpx",
        "pytest",
        "pytest.LogCaptureFixture",
        "sanic.Sanic",
        "sanic.compat.use_context",
        "sanic.request.Request",
        "sanic.response.text",
        "socket.AF_UNIX",
        "socket.socket",
        "socket.AF_UNIX",
        "socket.socket"
      ],
      "fixtures": [],
      "assertions": [
        "assert r.status_code == 200",
        "assert r.text == os.path.abspath(SOCKPATH)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        },
        {
          "name": "client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_unix_connection` function is designed to verify that a Sanic application can successfully handle HTTP requests over a Unix socket connection. It ensures that the application responds correctly to requests and that the connection information is accurately reflected in the response.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when a GET request is made to the root endpoint (\"/\"), the server responds with a status code of 200 and that the response body contains the absolute path of the Unix socket specified by `SOCKPATH`. This confirms that the server is correctly configured to use the Unix socket and that it can process requests as expected.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Sanic application with a route handler that returns the server's connection information. It uses the `httpx` library to create an asynchronous HTTP client that connects to the server via the Unix socket. The `app.run` method starts the server, and the `client` function is executed after the server starts, making a request to the server and asserting the expected response. The `app.stop()` method is called to ensure the server is properly shut down after the test.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test leverages asynchronous programming with `async/await`, allowing it to handle non-blocking I/O operations effectively.\n- **Conditional Logic**: The test includes a version check for `httpx` to determine the appropriate transport mechanism for the Unix socket, demonstrating adaptability based on the environment.\n- **Resource Management**: The use of a `try/finally` block ensures that the server is stopped regardless of whether the request succeeds or fails, promoting good resource management practices."
    },
    {
      "name": "test_unix_connection_multiple_workers",
      "module": "test_unix_socket",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_unix_socket.py",
      "line_number": 193,
      "end_line_number": 198,
      "source_code": "def test_unix_connection_multiple_workers():\n    with use_context(\"fork\"):\n        app_multi = Sanic(name=\"test\")\n        app_multi.get(\"/\")(handler)\n        app_multi.listener(\"after_server_start\")(client)\n        app_multi.run(host=\"myhost.invalid\", unix=SOCKPATH, workers=2)",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(sys.platform not in ('linux', 'darwin'), reason='This test requires fork context')"
      ],
      "arguments": [],
      "imports": [
        "logging",
        "os",
        "sys",
        "asyncio.AbstractEventLoop",
        "asyncio.sleep",
        "pathlib.Path",
        "string.ascii_lowercase",
        "httpcore",
        "httpx",
        "pytest",
        "pytest.LogCaptureFixture",
        "sanic.Sanic",
        "sanic.compat.use_context",
        "sanic.request.Request",
        "sanic.response.text",
        "socket.AF_UNIX",
        "socket.socket",
        "socket.AF_UNIX",
        "socket.socket"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_multi.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "app_multi.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_unix_connection_multiple_workers` function is designed to verify the behavior of the Sanic application when it is run with multiple worker processes using a Unix socket. This test ensures that the application can handle concurrent requests across multiple workers, which is crucial for performance and scalability in a production environment.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that the Sanic application can be successfully started with two worker processes and that it can handle incoming requests via a Unix socket. It ensures that the application is correctly configured to use the specified socket path (`SOCKPATH`) and that it can operate under a forking context, which is essential for managing multiple workers.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `app_multi.run` method, which is responsible for starting the Sanic server with the specified parameters, including the host, Unix socket path, and number of workers. The `app_multi.get` method is also indirectly tested, as it sets up a route that the server will respond to. The `run` method constructs a command to start the server and captures its output, while the `get` method defines a simple handler that returns a text response when accessed.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `use_context` context manager to set the environment for forking, which is a common pattern when testing multi-process applications. This ensures that the test runs in a controlled environment that mimics the production setup. Additionally, the test does not include assertions, which may indicate that it is primarily focused on verifying that the server starts without errors rather than validating specific output or behavior. This approach is typical in integration tests where the focus is on the overall system behavior rather than individual components."
    },
    {
      "name": "test_listeners_triggered",
      "module": "test_asgi",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_asgi.py",
      "line_number": 65,
      "end_line_number": 163,
      "source_code": "def test_listeners_triggered(caplog):\n    app = Sanic(\"app\")\n    before_server_start = False\n    after_server_start = False\n    before_server_stop = False\n    after_server_stop = False\n\n    @app.listener(\"before_server_start\")\n    def do_before_server_start(*args, **kwargs):\n        nonlocal before_server_start\n        before_server_start = True\n\n    @app.listener(\"after_server_start\")\n    def do_after_server_start(*args, **kwargs):\n        nonlocal after_server_start\n        after_server_start = True\n\n    @app.listener(\"before_server_stop\")\n    def do_before_server_stop(*args, **kwargs):\n        nonlocal before_server_stop\n        before_server_stop = True\n\n    @app.listener(\"after_server_stop\")\n    def do_after_server_stop(*args, **kwargs):\n        nonlocal after_server_stop\n        after_server_stop = True\n\n    @app.route(\"/\")\n    def handler(request):\n        return text(\"...\")\n\n    class CustomServer(uvicorn.Server):\n        def install_signal_handlers(self):\n            pass\n\n    config = uvicorn.Config(\n        app=app, loop=\"asyncio\", limit_max_requests=0, port=get_port()\n    )\n    server = CustomServer(config=config)\n\n    start_message = (\n        'You have set a listener for \"before_server_start\" in ASGI mode. '\n        \"It will be executed as early as possible, but not before the ASGI \"\n        \"server is started.\"\n    )\n    stop_message = (\n        'You have set a listener for \"after_server_stop\" in ASGI mode. '\n        \"It will be executed as late as possible, but not after the ASGI \"\n        \"server is stopped.\"\n    )\n\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    assert before_server_start\n    assert after_server_start\n    assert before_server_stop\n    assert after_server_stop\n\n    app.state.mode = Mode.DEBUG\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    app.state.verbosity = 2\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) in caplog.record_tuples",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "caplog"
      ],
      "imports": [
        "asyncio",
        "logging",
        "collections.deque",
        "collections.namedtuple",
        "unittest.mock.call",
        "pytest",
        "uvicorn",
        "httpx.Headers",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.application.state.Mode",
        "sanic.asgi.Lifespan",
        "sanic.asgi.MockTransport",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.ServiceUnavailable",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.server.websockets.connection.WebSocketConnection",
        "sanic.signals.RESERVED_NAMESPACES",
        "conftest.get_port",
        "unittest.mock.AsyncMock",
        "tests.asyncmock.AsyncMock"
      ],
      "fixtures": [],
      "assertions": [
        "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
        "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
        "assert before_server_start",
        "assert after_server_start",
        "assert before_server_stop",
        "assert after_server_stop",
        "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
        "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
        "assert ('sanic.root', logging.DEBUG, start_message) in caplog.record_tuples",
        "assert ('sanic.root', logging.DEBUG, stop_message) in caplog.record_tuples"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "server.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "server.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "server.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "get_port",
          "body": "def get_port():\n    sock = socket.socket()\n    sock.bind(('', 0))\n    return sock.getsockname()[1]"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_listeners_triggered` test is to verify that the Sanic application correctly triggers its lifecycle listeners during server startup and shutdown events. It ensures that the appropriate listeners are executed and that the expected log messages are generated based on the application's configuration.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the listeners for the events `before_server_start`, `after_server_start`, `before_server_stop`, and `after_server_stop` are invoked as expected. It also verifies that specific debug log messages are not emitted when the application is in certain modes (like `DEBUG` and with verbosity set to 2) and that they are emitted in other configurations.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves a Sanic application instance that registers listeners for various server lifecycle events. The listeners are defined as functions that set boolean flags when triggered. The `server.run()` method is called to start the server, which in turn should invoke the registered listeners. The test uses the `caplog` fixture to capture log messages emitted during the server's execution, allowing assertions to be made about the presence or absence of specific log entries.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Use of Fixtures**: The `caplog` fixture is employed to capture logging output, which allows for assertions on log messages without modifying the logging configuration globally.\n- **Nonlocal Variables**: The test uses `nonlocal` to modify flags within nested functions, which is a common pattern in Python to maintain state across closures.\n- **Assertions on State and Logs**: The test combines assertions on both the state of the application (the boolean flags) and the captured log messages, providing a comprehensive verification of the application's behavior during the test.\n- **Multiple Configurations**: The test runs the server multiple times with different configurations (default, `DEBUG`, and increased verbosity) to ensure that the behavior of the listeners and logging is consistent across different application states."
    },
    {
      "name": "test_listeners_triggered_async",
      "module": "test_asgi",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_asgi.py",
      "line_number": 166,
      "end_line_number": 264,
      "source_code": "def test_listeners_triggered_async(app, caplog):\n    before_server_start = False\n    after_server_start = False\n    before_server_stop = False\n    after_server_stop = False\n\n    @app.listener(\"before_server_start\")\n    async def do_before_server_start(*args, **kwargs):\n        nonlocal before_server_start\n        before_server_start = True\n\n    @app.listener(\"after_server_start\")\n    async def do_after_server_start(*args, **kwargs):\n        nonlocal after_server_start\n        after_server_start = True\n\n    @app.listener(\"before_server_stop\")\n    async def do_before_server_stop(*args, **kwargs):\n        nonlocal before_server_stop\n        before_server_stop = True\n\n    @app.listener(\"after_server_stop\")\n    async def do_after_server_stop(*args, **kwargs):\n        nonlocal after_server_stop\n        after_server_stop = True\n\n    @app.route(\"/\")\n    def handler(request):\n        return text(\"...\")\n\n    class CustomServer(uvicorn.Server):\n        def install_signal_handlers(self):\n            pass\n\n    config = uvicorn.Config(\n        app=app, loop=\"asyncio\", limit_max_requests=0, port=get_port()\n    )\n    server = CustomServer(config=config)\n\n    start_message = (\n        'You have set a listener for \"before_server_start\" in ASGI mode. '\n        \"It will be executed as early as possible, but not before the ASGI \"\n        \"server is started.\"\n    )\n    stop_message = (\n        'You have set a listener for \"after_server_stop\" in ASGI mode. '\n        \"It will be executed as late as possible, but not after the ASGI \"\n        \"server is stopped.\"\n    )\n\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    assert before_server_start\n    assert after_server_start\n    assert before_server_stop\n    assert after_server_stop\n\n    app.state.mode = Mode.DEBUG\n    app.state.verbosity = 0\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    app.state.verbosity = 2\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) in caplog.record_tuples",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "caplog"
      ],
      "imports": [
        "asyncio",
        "logging",
        "collections.deque",
        "collections.namedtuple",
        "unittest.mock.call",
        "pytest",
        "uvicorn",
        "httpx.Headers",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.application.state.Mode",
        "sanic.asgi.Lifespan",
        "sanic.asgi.MockTransport",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.ServiceUnavailable",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.server.websockets.connection.WebSocketConnection",
        "sanic.signals.RESERVED_NAMESPACES",
        "conftest.get_port",
        "unittest.mock.AsyncMock",
        "tests.asyncmock.AsyncMock"
      ],
      "fixtures": [],
      "assertions": [
        "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
        "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
        "assert before_server_start",
        "assert after_server_start",
        "assert before_server_stop",
        "assert after_server_stop",
        "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
        "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
        "assert ('sanic.root', logging.DEBUG, start_message) in caplog.record_tuples",
        "assert ('sanic.root', logging.DEBUG, stop_message) in caplog.record_tuples"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "server.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "server.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "server.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "get_port",
          "body": "def get_port():\n    sock = socket.socket()\n    sock.bind(('', 0))\n    return sock.getsockname()[1]"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_listeners_triggered_async` test is to verify that the Sanic application correctly triggers the defined lifecycle listeners during the server's startup and shutdown processes. It ensures that the listeners for events such as `before_server_start`, `after_server_start`, `before_server_stop`, and `after_server_stop` are executed as expected.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. The listeners are invoked correctly, setting the corresponding flags (`before_server_start`, `after_server_start`, `before_server_stop`, `after_server_stop`) to `True`.\n2. The expected log messages related to the listeners are not present in the log output when the application is in a specific state (DEBUG mode with verbosity set to 0) and are present when verbosity is increased.\n\n**Code Being Tested and How It Works**:  \nThe test defines several asynchronous listener functions that modify the state of boolean flags when triggered. It sets up a custom server using Uvicorn and runs it, capturing log output with `caplog`. The assertions check:\n- That the flags are set to `True` after the server starts and stops.\n- That specific log messages are present or absent in the captured logs based on the application's verbosity settings.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Nonlocal Variables**: The use of `nonlocal` allows the listener functions to modify the flags defined in the outer scope, which is a common pattern in Python for maintaining state across nested functions.\n- **Context Managers**: The `with caplog.at_level(logging.DEBUG)` context manager is used to capture log output during the server's execution, allowing for assertions on log messages.\n- **Asynchronous Testing**: The test leverages asynchronous functions and the Sanic framework's event-driven architecture, which is essential for testing applications that rely on asynchronous operations.\n- **Assertions**: The test employs multiple assertions to validate both the state changes (flags) and the log output, ensuring comprehensive coverage of the listener behavior."
    },
    {
      "name": "test_non_default_uvloop_config_raises_warning",
      "module": "test_asgi",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_asgi.py",
      "line_number": 267,
      "end_line_number": 293,
      "source_code": "def test_non_default_uvloop_config_raises_warning(app):\n    app.config.USE_UVLOOP = True\n\n    class CustomServer(uvicorn.Server):\n        def install_signal_handlers(self):\n            pass\n\n    config = uvicorn.Config(\n        app=app, loop=\"asyncio\", limit_max_requests=0, port=get_port()\n    )\n    server = CustomServer(config=config)\n\n    with pytest.warns(UserWarning) as records:\n        server.run()\n\n    msg = \"\"\n    for record in records:\n        _msg = str(record.message)\n        if _msg.startswith(\"You have set the USE_UVLOOP configuration\"):\n            msg = _msg\n            break\n\n    assert msg == (\n        \"You have set the USE_UVLOOP configuration option, but Sanic \"\n        \"cannot control the event loop when running in ASGI mode.\"\n        \"This option will be ignored.\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "collections.deque",
        "collections.namedtuple",
        "unittest.mock.call",
        "pytest",
        "uvicorn",
        "httpx.Headers",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.application.state.Mode",
        "sanic.asgi.Lifespan",
        "sanic.asgi.MockTransport",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.ServiceUnavailable",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.server.websockets.connection.WebSocketConnection",
        "sanic.signals.RESERVED_NAMESPACES",
        "conftest.get_port",
        "unittest.mock.AsyncMock",
        "tests.asyncmock.AsyncMock"
      ],
      "fixtures": [],
      "assertions": [
        "assert msg == 'You have set the USE_UVLOOP configuration option, but Sanic cannot control the event loop when running in ASGI mode.This option will be ignored.'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "server.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "get_port",
          "body": "def get_port():\n    sock = socket.socket()\n    sock.bind(('', 0))\n    return sock.getsockname()[1]"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_non_default_uvloop_config_raises_warning` test is to verify that when the `USE_UVLOOP` configuration option is set to `True` in a Sanic application running in ASGI mode, a specific warning is raised. This warning indicates that Sanic cannot control the event loop in this context, and thus the configuration option will be ignored.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that a `UserWarning` is emitted when the server is run with the `USE_UVLOOP` configuration enabled. It specifically looks for a warning message that informs the user about the incompatibility of using `USE_UVLOOP` in ASGI mode, ensuring that the application behaves correctly in this scenario.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `run` method of a custom `uvicorn.Server` instance. The test sets up a `CustomServer` class that overrides the `install_signal_handlers` method to prevent signal handling during the test. The `uvicorn.Config` is configured with the application and the event loop set to \"asyncio\". When `server.run()` is called, it triggers the warning if the `USE_UVLOOP` configuration is active. The test captures the emitted warnings and checks if the expected warning message is present.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.warns` context manager to capture warnings raised during the execution of `server.run()`. This is a common pattern in Python testing for verifying that specific warnings are raised under certain conditions. Additionally, the test uses a loop to filter through the captured warnings to find the specific message of interest, demonstrating a methodical approach to validating the warning content. The use of assertions to compare the captured message against the expected string is a standard practice in unit testing to ensure correctness."
    },
    {
      "name": "test_improper_websocket_connection",
      "module": "test_asgi",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_asgi.py",
      "line_number": 416,
      "end_line_number": 422,
      "source_code": "def test_improper_websocket_connection(transport, send, receive):\n    with pytest.raises(BadRequest):\n        transport.get_websocket_connection()\n\n    transport.create_websocket_connection(send, receive)\n    connection = transport.get_websocket_connection()\n    assert isinstance(connection, WebSocketConnection)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "transport",
        "send",
        "receive"
      ],
      "imports": [
        "asyncio",
        "logging",
        "collections.deque",
        "collections.namedtuple",
        "unittest.mock.call",
        "pytest",
        "uvicorn",
        "httpx.Headers",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.application.state.Mode",
        "sanic.asgi.Lifespan",
        "sanic.asgi.MockTransport",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.ServiceUnavailable",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.server.websockets.connection.WebSocketConnection",
        "sanic.signals.RESERVED_NAMESPACES",
        "conftest.get_port",
        "unittest.mock.AsyncMock",
        "tests.asyncmock.AsyncMock"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(connection, WebSocketConnection)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_improper_websocket_connection` test is to verify the behavior of the `transport` object when attempting to establish a WebSocket connection under improper conditions. Specifically, it checks that a `BadRequest` exception is raised when trying to retrieve a WebSocket connection before one has been created.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the system correctly handles an improper state by raising a `BadRequest` exception when `get_websocket_connection()` is called without a prior successful connection setup. It also verifies that after creating a WebSocket connection using `create_websocket_connection(send, receive)`, the subsequent call to `get_websocket_connection()` returns a valid `WebSocketConnection` instance.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `transport` object, which is expected to manage WebSocket connections. Initially, it calls `transport.get_websocket_connection()`, which should raise a `BadRequest` exception if no connection has been established. After that, it simulates the creation of a WebSocket connection with `transport.create_websocket_connection(send, receive)`, and then it retrieves the connection using `transport.get_websocket_connection()`, asserting that the returned object is an instance of `WebSocketConnection`. This confirms that the connection was successfully established.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that an exception is raised, which is a common pattern for testing error conditions in Python. Additionally, it uses assertions to validate the type of the object returned by `get_websocket_connection()`, ensuring that the expected type is returned after a successful connection setup. This combination of exception handling and type checking is effective for verifying both error handling and successful outcomes in unit tests."
    },
    {
      "name": "test_static_file",
      "module": "test_url_for_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_for_static.py",
      "line_number": 37,
      "end_line_number": 118,
      "source_code": "def test_static_file(static_file_directory, file_name):\n    app = Sanic(\"qq\")\n    app.static(\n        \"/testing.file\", get_file_path(static_file_directory, file_name)\n    )\n    app.static(\n        \"/testing2.file\",\n        get_file_path(static_file_directory, file_name),\n        name=\"testing_file\",\n    )\n\n    app.router.finalize()\n\n    uri = app.url_for(\"static\")\n    uri2 = app.url_for(\"static\", filename=\"any\")\n    uri3 = app.url_for(\"static\", name=\"static\", filename=\"any\")\n\n    assert uri == \"/testing.file\"\n    assert uri == uri2\n    assert uri2 == uri3\n\n    app.router.reset()\n\n    request, response = app.test_client.get(uri)\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, file_name)\n\n    app.router.reset()\n\n    bp = Blueprint(\"test_bp_static\", url_prefix=\"/bp\")\n\n    bp.static(\"/testing.file\", get_file_path(static_file_directory, file_name))\n    bp.static(\n        \"/testing2.file\",\n        get_file_path(static_file_directory, file_name),\n        name=\"testing_file\",\n    )\n\n    app.blueprint(bp)\n\n    uris = [\n        app.url_for(\"static\", name=\"test_bp_static.static\"),\n        app.url_for(\"static\", name=\"test_bp_static.static\", filename=\"any\"),\n        app.url_for(\"test_bp_static.static\"),\n        app.url_for(\"test_bp_static.static\", filename=\"any\"),\n    ]\n\n    assert all(uri == \"/bp/testing.file\" for uri in uris)\n\n    request, response = app.test_client.get(uri)\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, file_name)\n\n    # test for other parameters\n    uri = app.url_for(\"static\", _external=True, _server=\"http://localhost\")\n    assert uri == \"http://localhost/testing.file\"\n\n    uri = app.url_for(\n        \"static\",\n        name=\"test_bp_static.static\",\n        _external=True,\n        _server=\"http://localhost\",\n    )\n    assert uri == \"http://localhost/bp/testing.file\"\n\n    # test for defined name\n    uri = app.url_for(\"static\", name=\"testing_file\")\n    assert uri == \"/testing2.file\"\n\n    request, response = app.test_client.get(uri)\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, file_name)\n\n    uri = app.url_for(\"static\", name=\"test_bp_static.testing_file\")\n    assert uri == \"/bp/testing2.file\"\n    assert uri == app.url_for(\n        \"static\", name=\"test_bp_static.testing_file\", filename=\"any\"\n    )\n\n    request, response = app.test_client.get(uri)\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, file_name)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt', 'python.png'])"
      ],
      "arguments": [
        "static_file_directory",
        "file_name"
      ],
      "imports": [
        "inspect",
        "os",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint"
      ],
      "fixtures": [],
      "assertions": [
        "assert uri == '/testing.file'",
        "assert uri == uri2",
        "assert uri2 == uri3",
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, file_name)",
        "assert all((uri == '/bp/testing.file' for uri in uris))",
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, file_name)",
        "assert uri == 'http://localhost/testing.file'",
        "assert uri == 'http://localhost/bp/testing.file'",
        "assert uri == '/testing2.file'",
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, file_name)",
        "assert uri == '/bp/testing2.file'",
        "assert uri == app.url_for('static', name='test_bp_static.testing_file', filename='any')",
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, file_name)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.router.reset",
          "body": "@pytest.fixture(autouse=True)\ndef reset():\n    try:\n        del os.environ['SANIC_MOTD_OUTPUT']\n    except KeyError:\n        ..."
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.router.reset",
          "body": "@pytest.fixture(autouse=True)\ndef reset():\n    try:\n        del os.environ['SANIC_MOTD_OUTPUT']\n    except KeyError:\n        ..."
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_static_file` function is designed to verify the functionality of serving static files in a Sanic web application. It ensures that static files can be correctly registered, accessed via URLs, and that the content served matches the expected file content.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks multiple aspects of static file handling, including:\n- Correct URL generation for static files using `app.url_for`.\n- Successful HTTP GET requests to the static file endpoints, returning a 200 status code.\n- The response body matches the actual content of the static file.\n- The behavior of static files when registered under different blueprints and with different names.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the Sanic application instance (`app`) to register static file routes using the `app.static` method. It uses helper functions like `get_file_path` to construct file paths and `get_file_content` to read the actual content of the files. The test then uses `app.test_client.get` to simulate HTTP GET requests to the registered static file endpoints and asserts that the responses are as expected.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterized Testing**: The test uses parameterization to run the same test logic with different file names, ensuring that various types of files can be served correctly.\n- **Blueprints**: The test demonstrates the use of blueprints in Sanic, allowing for modular organization of routes and static file handling.\n- **Assertions**: Multiple assertions are employed to validate the correctness of URL generation, response status, and response body content, ensuring comprehensive coverage of the static file functionality."
    },
    {
      "name": "test_static_directory",
      "module": "test_url_for_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_for_static.py",
      "line_number": 123,
      "end_line_number": 180,
      "source_code": "def test_static_directory(file_name, base_uri, static_file_directory):\n    app = Sanic(\"base\")\n\n    app.static(base_uri, static_file_directory)\n    base_uri2 = base_uri + \"/2\"\n    app.static(base_uri2, static_file_directory, name=\"uploads\")\n\n    uri = app.url_for(\"static\", name=\"static\", filename=file_name)\n    assert uri == f\"{base_uri}/{file_name}\"\n\n    request, response = app.test_client.get(uri)\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, file_name)\n\n    uri2 = app.url_for(\"static\", name=\"static\", filename=\"/\" + file_name)\n    uri3 = app.url_for(\"static\", filename=file_name)\n    uri4 = app.url_for(\"static\", filename=\"/\" + file_name)\n    uri5 = app.url_for(\"static\", name=\"uploads\", filename=file_name)\n    uri6 = app.url_for(\"static\", name=\"uploads\", filename=\"/\" + file_name)\n\n    assert uri == uri2\n    assert uri2 == uri3\n    assert uri3 == uri4\n\n    assert uri5 == f\"{base_uri2}/{file_name}\"\n    assert uri5 == uri6\n\n    bp = Blueprint(\"test_bp_static\", url_prefix=\"/bp\")\n\n    bp.static(base_uri, static_file_directory)\n    bp.static(base_uri2, static_file_directory, name=\"uploads\")\n\n    app.router.reset()\n    app.blueprint(bp)\n\n    uri = app.url_for(\n        \"static\", name=\"test_bp_static.static\", filename=file_name\n    )\n    uri2 = app.url_for(\n        \"static\", name=\"test_bp_static.static\", filename=\"/\" + file_name\n    )\n\n    uri4 = app.url_for(\n        \"static\", name=\"test_bp_static.uploads\", filename=file_name\n    )\n    uri5 = app.url_for(\n        \"static\", name=\"test_bp_static.uploads\", filename=\"/\" + file_name\n    )\n\n    assert uri == f\"/bp{base_uri}/{file_name}\"\n    assert uri == uri2\n\n    assert uri4 == f\"/bp{base_uri2}/{file_name}\"\n    assert uri4 == uri5\n\n    request, response = app.test_client.get(uri)\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, file_name)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt'])",
        "pytest.mark.parametrize('base_uri', ['/static', '', '/dir'])"
      ],
      "arguments": [
        "file_name",
        "base_uri",
        "static_file_directory"
      ],
      "imports": [
        "inspect",
        "os",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint"
      ],
      "fixtures": [],
      "assertions": [
        "assert uri == f'{base_uri}/{file_name}'",
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, file_name)",
        "assert uri == uri2",
        "assert uri2 == uri3",
        "assert uri3 == uri4",
        "assert uri5 == f'{base_uri2}/{file_name}'",
        "assert uri5 == uri6",
        "assert uri == f'/bp{base_uri}/{file_name}'",
        "assert uri == uri2",
        "assert uri4 == f'/bp{base_uri2}/{file_name}'",
        "assert uri4 == uri5",
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, file_name)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.router.reset",
          "body": "@pytest.fixture(autouse=True)\ndef reset():\n    try:\n        del os.environ['SANIC_MOTD_OUTPUT']\n    except KeyError:\n        ..."
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_static_directory` function is designed to verify the correct behavior of the Sanic web framework's static file serving capabilities. It ensures that static files can be served correctly from specified directories and that the URL generation for these files works as expected.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks multiple aspects of static file serving, including:\n- Correct URL generation for static files using `app.url_for`.\n- Successful retrieval of static files via HTTP GET requests, confirming that the response status is 200 and the response body matches the expected file content.\n- The handling of static files under different URI formats and within a blueprint context, ensuring that the static file routes are correctly prefixed and accessible.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `Sanic` application instance, specifically:\n- It sets up static file routes using `app.static`, linking a base URI to a directory containing static files.\n- It uses `app.url_for` to generate URLs for static files, checking that the generated URLs match expected patterns.\n- The `app.test_client.get` method is employed to simulate HTTP GET requests to these URLs, allowing the test to assert the correctness of the responses, including status codes and content.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test is designed to run with multiple file names, allowing for a broader coverage of scenarios without duplicating code.\n- **Assertions**: The test employs multiple assertions to validate the correctness of URL generation and HTTP responses, ensuring that both the routing and file serving functionalities are thoroughly checked.\n- **Blueprints**: The test demonstrates the use of blueprints in Sanic, verifying that static routes defined within a blueprint are correctly integrated into the main application context."
    },
    {
      "name": "test_static_head_request",
      "module": "test_url_for_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_for_static.py",
      "line_number": 184,
      "end_line_number": 226,
      "source_code": "def test_static_head_request(file_name, static_file_directory):\n    app = Sanic(\"base\")\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n\n    bp = Blueprint(\"test_bp_static\", url_prefix=\"/bp\")\n    bp.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n    app.blueprint(bp)\n\n    uri = app.url_for(\"static\")\n    assert uri == \"/testing.file\"\n    assert uri == app.url_for(\"static\", name=\"static\")\n    assert uri == app.url_for(\"static\", name=\"static\", filename=\"any\")\n\n    request, response = app.test_client.head(uri)\n    assert response.status == 200\n    assert \"Accept-Ranges\" in response.headers\n    assert \"Content-Length\" in response.headers\n    assert int(response.headers[\"Content-Length\"]) == len(\n        get_file_content(static_file_directory, file_name)\n    )\n\n    # blueprint\n    uri = app.url_for(\"static\", name=\"test_bp_static.static\")\n    assert uri == \"/bp/testing.file\"\n    assert uri == app.url_for(\n        \"static\", name=\"test_bp_static.static\", filename=\"any\"\n    )\n\n    request, response = app.test_client.head(uri)\n    assert response.status == 200\n    assert \"Accept-Ranges\" in response.headers\n    assert \"Content-Length\" in response.headers\n    assert int(response.headers[\"Content-Length\"]) == len(\n        get_file_content(static_file_directory, file_name)\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt'])"
      ],
      "arguments": [
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "inspect",
        "os",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint"
      ],
      "fixtures": [],
      "assertions": [
        "assert uri == '/testing.file'",
        "assert uri == app.url_for('static', name='static')",
        "assert uri == app.url_for('static', name='static', filename='any')",
        "assert response.status == 200",
        "assert 'Accept-Ranges' in response.headers",
        "assert 'Content-Length' in response.headers",
        "assert int(response.headers['Content-Length']) == len(get_file_content(static_file_directory, file_name))",
        "assert uri == '/bp/testing.file'",
        "assert uri == app.url_for('static', name='test_bp_static.static', filename='any')",
        "assert response.status == 200",
        "assert 'Accept-Ranges' in response.headers",
        "assert 'Content-Length' in response.headers",
        "assert int(response.headers['Content-Length']) == len(get_file_content(static_file_directory, file_name))"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.head",
          "body": "def head(self, request):\n    return text('', headers={'method': 'HEAD'})"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.head",
          "body": "def head(self, request):\n    return text('', headers={'method': 'HEAD'})"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_static_head_request` function is designed to verify the behavior of static file serving in a Sanic web application when handling HTTP HEAD requests. It ensures that the application correctly responds to HEAD requests for static files, returning appropriate headers and status codes.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. The correct URI is generated for static files.\n2. The server responds with a 200 status code for HEAD requests.\n3. The response headers include \"Accept-Ranges\" and \"Content-Length\".\n4. The \"Content-Length\" matches the actual size of the static file being served.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Sanic application with static file routes defined both directly on the app and within a blueprint. It uses the `app.url_for` method to generate URIs for the static files and then sends HEAD requests using `app.test_client.head`. The `get_file_path` and `get_file_content` functions are used to determine the file's path and content length, respectively. The test verifies that the application correctly serves the static file and provides the expected headers.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test is designed to run with different file names, allowing for multiple scenarios to be tested without duplicating code.\n- **Blueprints**: The use of blueprints in Sanic allows for modular organization of routes, which is tested here by serving static files from both the main app and a blueprint.\n- **Assertions**: The test employs multiple assertions to validate the correctness of the URI generation and the response from the server, ensuring comprehensive coverage of the expected behavior."
    },
    {
      "name": "test_static_content_range_correct",
      "module": "test_url_for_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_for_static.py",
      "line_number": 230,
      "end_line_number": 278,
      "source_code": "def test_static_content_range_correct(file_name, static_file_directory):\n    app = Sanic(\"base\")\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n\n    bp = Blueprint(\"test_bp_static\", url_prefix=\"/bp\")\n    bp.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n    app.blueprint(bp)\n\n    headers = {\"Range\": \"bytes=12-19\"}\n    uri = app.url_for(\"static\")\n    assert uri == \"/testing.file\"\n    assert uri == app.url_for(\"static\", name=\"static\")\n    assert uri == app.url_for(\"static\", name=\"static\", filename=\"any\")\n\n    request, response = app.test_client.get(uri, headers=headers)\n    assert response.status == 206\n    assert \"Content-Length\" in response.headers\n    assert \"Content-Range\" in response.headers\n    static_content = bytes(get_file_content(static_file_directory, file_name))[\n        12:20\n    ]\n    assert int(response.headers[\"Content-Length\"]) == len(static_content)\n    assert response.body == static_content\n\n    # blueprint\n    uri = app.url_for(\"static\", name=\"test_bp_static.static\")\n    assert uri == \"/bp/testing.file\"\n    assert uri == app.url_for(\n        \"static\", name=\"test_bp_static.static\", filename=\"any\"\n    )\n    assert uri == app.url_for(\"test_bp_static.static\")\n\n    request, response = app.test_client.get(uri, headers=headers)\n    assert response.status == 206\n    assert \"Content-Length\" in response.headers\n    assert \"Content-Range\" in response.headers\n    static_content = bytes(get_file_content(static_file_directory, file_name))[\n        12:20\n    ]\n    assert int(response.headers[\"Content-Length\"]) == len(static_content)\n    assert response.body == static_content",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt'])"
      ],
      "arguments": [
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "inspect",
        "os",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint"
      ],
      "fixtures": [],
      "assertions": [
        "assert uri == '/testing.file'",
        "assert uri == app.url_for('static', name='static')",
        "assert uri == app.url_for('static', name='static', filename='any')",
        "assert response.status == 206",
        "assert 'Content-Length' in response.headers",
        "assert 'Content-Range' in response.headers",
        "assert int(response.headers['Content-Length']) == len(static_content)",
        "assert response.body == static_content",
        "assert uri == '/bp/testing.file'",
        "assert uri == app.url_for('static', name='test_bp_static.static', filename='any')",
        "assert uri == app.url_for('test_bp_static.static')",
        "assert response.status == 206",
        "assert 'Content-Length' in response.headers",
        "assert 'Content-Range' in response.headers",
        "assert int(response.headers['Content-Length']) == len(static_content)",
        "assert response.body == static_content"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_static_content_range_correct` test is to verify that the Sanic application correctly handles HTTP range requests for static files. Specifically, it checks that the server responds with the appropriate status code, headers, and body content when a range of bytes is requested.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a client requests a specific byte range (in this case, bytes 12 to 19) from a static file, the server responds with a `206 Partial Content` status. It also verifies that the `Content-Length` and `Content-Range` headers are correctly set and that the body of the response contains the expected byte range of the file.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Sanic application with static file serving capabilities, both at the application level and within a blueprint. It uses the `app.static` and `bp.static` methods to define the static file routes. The `get_file_path` function constructs the file path, and `get_file_content` reads the file's content. The test then simulates a GET request with a `Range` header and checks the response's status, headers, and body content against the expected values.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs parameterization (using `@pytest.mark.parametrize`) to run the same test logic with different file names, enhancing coverage and ensuring that the functionality works with various inputs. It also utilizes assertions to validate the response's status and headers, which is a common practice in unit testing to ensure that the application behaves as expected under different conditions. The use of blueprints to organize routes is another notable aspect, demonstrating modular design in the application structure."
    },
    {
      "name": "test_static_content_range_front",
      "module": "test_url_for_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_for_static.py",
      "line_number": 282,
      "end_line_number": 331,
      "source_code": "def test_static_content_range_front(file_name, static_file_directory):\n    app = Sanic(\"base\")\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n\n    bp = Blueprint(\"test_bp_static\", url_prefix=\"/bp\")\n    bp.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n    app.blueprint(bp)\n\n    headers = {\"Range\": \"bytes=12-\"}\n    uri = app.url_for(\"static\")\n    assert uri == \"/testing.file\"\n    assert uri == app.url_for(\"static\", name=\"static\")\n    assert uri == app.url_for(\"static\", name=\"static\", filename=\"any\")\n\n    request, response = app.test_client.get(uri, headers=headers)\n    assert response.status == 206\n    assert \"Content-Length\" in response.headers\n    assert \"Content-Range\" in response.headers\n    static_content = bytes(get_file_content(static_file_directory, file_name))[\n        12:\n    ]\n    assert int(response.headers[\"Content-Length\"]) == len(static_content)\n    assert response.body == static_content\n\n    # blueprint\n    uri = app.url_for(\"static\", name=\"test_bp_static.static\")\n    assert uri == \"/bp/testing.file\"\n    assert uri == app.url_for(\n        \"static\", name=\"test_bp_static.static\", filename=\"any\"\n    )\n    assert uri == app.url_for(\"test_bp_static.static\")\n    assert uri == app.url_for(\"test_bp_static.static\", filename=\"any\")\n\n    request, response = app.test_client.get(uri, headers=headers)\n    assert response.status == 206\n    assert \"Content-Length\" in response.headers\n    assert \"Content-Range\" in response.headers\n    static_content = bytes(get_file_content(static_file_directory, file_name))[\n        12:\n    ]\n    assert int(response.headers[\"Content-Length\"]) == len(static_content)\n    assert response.body == static_content",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt'])"
      ],
      "arguments": [
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "inspect",
        "os",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint"
      ],
      "fixtures": [],
      "assertions": [
        "assert uri == '/testing.file'",
        "assert uri == app.url_for('static', name='static')",
        "assert uri == app.url_for('static', name='static', filename='any')",
        "assert response.status == 206",
        "assert 'Content-Length' in response.headers",
        "assert 'Content-Range' in response.headers",
        "assert int(response.headers['Content-Length']) == len(static_content)",
        "assert response.body == static_content",
        "assert uri == '/bp/testing.file'",
        "assert uri == app.url_for('static', name='test_bp_static.static', filename='any')",
        "assert uri == app.url_for('test_bp_static.static')",
        "assert uri == app.url_for('test_bp_static.static', filename='any')",
        "assert response.status == 206",
        "assert 'Content-Length' in response.headers",
        "assert 'Content-Range' in response.headers",
        "assert int(response.headers['Content-Length']) == len(static_content)",
        "assert response.body == static_content"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_static_content_range_front` test is to verify that the Sanic application correctly handles HTTP range requests for static files. It ensures that when a client requests a specific byte range of a file, the server responds with the appropriate status code (206 Partial Content) and includes the correct `Content-Length` and `Content-Range` headers, along with the expected body content.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks the behavior of the static file serving mechanism in Sanic when the `use_content_range` option is enabled. It verifies that:\n- The application correctly constructs the URL for static files.\n- The server responds with a 206 status code when a valid range request is made.\n- The response headers include `Content-Length` and `Content-Range`.\n- The body of the response contains the correct portion of the file as specified by the range request.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Sanic application and a blueprint that serve a static file located at a specified path. The `app.static` and `bp.static` methods are used to define the static file routes, enabling content range support. The test then simulates a GET request to the static file endpoint with a `Range` header indicating the desired byte range. The relevant methods being tested include:\n- `app.url_for`: Generates the URL for the static file.\n- `app.test_client.get`: Simulates an HTTP GET request to the server.\n- `get_file_content`: Reads the content of the specified static file to compare against the response.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Parameterized Testing**: The use of `@pytest.mark.parametrize` allows the test to run multiple times with different file names, enhancing coverage and robustness.\n- **Assertions**: Multiple assertions are used to validate the response status, headers, and body content, ensuring comprehensive verification of the server's behavior.\n- **Blueprints**: The test demonstrates the use of blueprints in Sanic, allowing for modular organization of routes and static file serving, which is essential for larger applications."
    },
    {
      "name": "test_static_content_range_back",
      "module": "test_url_for_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_for_static.py",
      "line_number": 335,
      "end_line_number": 384,
      "source_code": "def test_static_content_range_back(file_name, static_file_directory):\n    app = Sanic(\"base\")\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n\n    bp = Blueprint(\"test_bp_static\", url_prefix=\"/bp\")\n    bp.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n    app.blueprint(bp)\n\n    headers = {\"Range\": \"bytes=-12\"}\n    uri = app.url_for(\"static\")\n    assert uri == \"/testing.file\"\n    assert uri == app.url_for(\"static\", name=\"static\")\n    assert uri == app.url_for(\"static\", name=\"static\", filename=\"any\")\n\n    request, response = app.test_client.get(uri, headers=headers)\n    assert response.status == 206\n    assert \"Content-Length\" in response.headers\n    assert \"Content-Range\" in response.headers\n    static_content = bytes(get_file_content(static_file_directory, file_name))[\n        -12:\n    ]\n    assert int(response.headers[\"Content-Length\"]) == len(static_content)\n    assert response.body == static_content\n\n    # blueprint\n    uri = app.url_for(\"static\", name=\"test_bp_static.static\")\n    assert uri == \"/bp/testing.file\"\n    assert uri == app.url_for(\n        \"static\", name=\"test_bp_static.static\", filename=\"any\"\n    )\n    assert uri == app.url_for(\"test_bp_static.static\")\n    assert uri == app.url_for(\"test_bp_static.static\", filename=\"any\")\n\n    request, response = app.test_client.get(uri, headers=headers)\n    assert response.status == 206\n    assert \"Content-Length\" in response.headers\n    assert \"Content-Range\" in response.headers\n    static_content = bytes(get_file_content(static_file_directory, file_name))[\n        -12:\n    ]\n    assert int(response.headers[\"Content-Length\"]) == len(static_content)\n    assert response.body == static_content",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt'])"
      ],
      "arguments": [
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "inspect",
        "os",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint"
      ],
      "fixtures": [],
      "assertions": [
        "assert uri == '/testing.file'",
        "assert uri == app.url_for('static', name='static')",
        "assert uri == app.url_for('static', name='static', filename='any')",
        "assert response.status == 206",
        "assert 'Content-Length' in response.headers",
        "assert 'Content-Range' in response.headers",
        "assert int(response.headers['Content-Length']) == len(static_content)",
        "assert response.body == static_content",
        "assert uri == '/bp/testing.file'",
        "assert uri == app.url_for('static', name='test_bp_static.static', filename='any')",
        "assert uri == app.url_for('test_bp_static.static')",
        "assert uri == app.url_for('test_bp_static.static', filename='any')",
        "assert response.status == 206",
        "assert 'Content-Length' in response.headers",
        "assert 'Content-Range' in response.headers",
        "assert int(response.headers['Content-Length']) == len(static_content)",
        "assert response.body == static_content"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_static_content_range_back` test is to verify that the Sanic application correctly handles HTTP range requests for static files. Specifically, it checks that the server responds appropriately when a client requests a specific byte range from a static file, ensuring that the response includes the correct status code, headers, and body content.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies that when a range request is made (e.g., `Range: bytes=-12`), the server responds with a `206 Partial Content` status, indicating that the request was successful and that the response body contains the last 12 bytes of the requested file. It also checks that the `Content-Length` and `Content-Range` headers are present and correctly reflect the size of the returned content.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the Sanic application setup, where static file serving is configured with the `use_content_range=True` option. The `app.static` method is used to serve a static file, and a blueprint is created to serve the same file under a different URL prefix. The test then constructs the request using `app.test_client.get` to simulate a client request for the static file with the specified range header. The assertions check the response status, headers, and body content against expected values.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs parameterization (using `@pytest.mark.parametrize`) to run the same test logic with different file names, enhancing coverage and ensuring that the functionality works with various inputs. It also uses assertions to validate multiple aspects of the response, including status codes, headers, and body content, which is a common practice in unit testing to ensure comprehensive verification of functionality. Additionally, the use of blueprints allows for organized routing and testing of static content in a modular way."
    },
    {
      "name": "test_static_content_range_empty",
      "module": "test_url_for_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_for_static.py",
      "line_number": 388,
      "end_line_number": 438,
      "source_code": "def test_static_content_range_empty(file_name, static_file_directory):\n    app = Sanic(\"base\")\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n\n    bp = Blueprint(\"test_bp_static\", url_prefix=\"/bp\")\n    bp.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n    app.blueprint(bp)\n\n    uri = app.url_for(\"static\")\n    assert uri == \"/testing.file\"\n    assert uri == app.url_for(\"static\", name=\"static\")\n    assert uri == app.url_for(\"static\", name=\"static\", filename=\"any\")\n\n    request, response = app.test_client.get(uri)\n    assert response.status == 200\n    assert \"Content-Length\" in response.headers\n    assert \"Content-Range\" not in response.headers\n    assert int(response.headers[\"Content-Length\"]) == len(\n        get_file_content(static_file_directory, file_name)\n    )\n    assert response.body == bytes(\n        get_file_content(static_file_directory, file_name)\n    )\n\n    # blueprint\n    uri = app.url_for(\"static\", name=\"test_bp_static.static\")\n    assert uri == \"/bp/testing.file\"\n    assert uri == app.url_for(\n        \"static\", name=\"test_bp_static.static\", filename=\"any\"\n    )\n    assert uri == app.url_for(\"test_bp_static.static\")\n    assert uri == app.url_for(\"test_bp_static.static\", filename=\"any\")\n\n    request, response = app.test_client.get(uri)\n    assert response.status == 200\n    assert \"Content-Length\" in response.headers\n    assert \"Content-Range\" not in response.headers\n    assert int(response.headers[\"Content-Length\"]) == len(\n        get_file_content(static_file_directory, file_name)\n    )\n    assert response.body == bytes(\n        get_file_content(static_file_directory, file_name)\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt'])"
      ],
      "arguments": [
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "inspect",
        "os",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint"
      ],
      "fixtures": [],
      "assertions": [
        "assert uri == '/testing.file'",
        "assert uri == app.url_for('static', name='static')",
        "assert uri == app.url_for('static', name='static', filename='any')",
        "assert response.status == 200",
        "assert 'Content-Length' in response.headers",
        "assert 'Content-Range' not in response.headers",
        "assert int(response.headers['Content-Length']) == len(get_file_content(static_file_directory, file_name))",
        "assert response.body == bytes(get_file_content(static_file_directory, file_name))",
        "assert uri == '/bp/testing.file'",
        "assert uri == app.url_for('static', name='test_bp_static.static', filename='any')",
        "assert uri == app.url_for('test_bp_static.static')",
        "assert uri == app.url_for('test_bp_static.static', filename='any')",
        "assert response.status == 200",
        "assert 'Content-Length' in response.headers",
        "assert 'Content-Range' not in response.headers",
        "assert int(response.headers['Content-Length']) == len(get_file_content(static_file_directory, file_name))",
        "assert response.body == bytes(get_file_content(static_file_directory, file_name))"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_static_content_range_empty` function is designed to verify the behavior of the Sanic web framework when serving static files with content range support enabled. Specifically, it checks that when a static file is requested without any range specified, the server responds correctly without including a `Content-Range` header, and that the response body matches the expected file content.\n\n**Specific Functionality or Behavior Verified**:  \nThe test ensures that:\n1. The correct URI is generated for static file access.\n2. The server responds with a 200 status code when the static file is requested.\n3. The `Content-Length` header is present and accurately reflects the size of the file.\n4. The `Content-Range` header is absent when the entire file is served.\n5. The response body contains the complete content of the requested file.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the Sanic application by:\n- Setting up a static file route using `app.static()` and a blueprint with `bp.static()`, both pointing to the same file.\n- Using `app.url_for()` to generate the correct URIs for accessing the static file.\n- Making GET requests to these URIs using `app.test_client.get()`, which simulates client requests to the server.\n- Validating the response status, headers, and body against expected values, ensuring that the static file is served correctly.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test is designed to run with multiple file names, allowing for broader coverage of different file types and names.\n- **Blueprints**: The use of blueprints in Sanic allows for modular organization of routes, and the test verifies that static file serving works correctly both at the application level and within a blueprint context.\n- **Assertions**: The test employs multiple assertions to validate various aspects of the response, ensuring comprehensive verification of the server's behavior when serving static content."
    },
    {
      "name": "test_static_content_range_error",
      "module": "test_url_for_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_for_static.py",
      "line_number": 442,
      "end_line_number": 487,
      "source_code": "def test_static_content_range_error(app, file_name, static_file_directory):\n    app = Sanic(\"base\")\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n\n    bp = Blueprint(\"test_bp_static\", url_prefix=\"/bp\")\n    bp.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n    app.blueprint(bp)\n\n    headers = {\"Range\": \"bytes=1-0\"}\n    uri = app.url_for(\"static\")\n    assert uri == \"/testing.file\"\n    assert uri == app.url_for(\"static\", name=\"static\")\n    assert uri == app.url_for(\"static\", name=\"static\", filename=\"any\")\n\n    request, response = app.test_client.get(uri, headers=headers)\n    assert response.status == 416\n    assert \"Content-Length\" in response.headers\n    assert \"Content-Range\" in response.headers\n    assert response.headers[\"Content-Range\"] == \"bytes */%s\" % (\n        len(get_file_content(static_file_directory, file_name)),\n    )\n\n    # blueprint\n    uri = app.url_for(\"static\", name=\"test_bp_static.static\")\n    assert uri == \"/bp/testing.file\"\n    assert uri == app.url_for(\n        \"static\", name=\"test_bp_static.static\", filename=\"any\"\n    )\n    assert uri == app.url_for(\"test_bp_static.static\")\n    assert uri == app.url_for(\"test_bp_static.static\", filename=\"any\")\n\n    request, response = app.test_client.get(uri, headers=headers)\n    assert response.status == 416\n    assert \"Content-Length\" in response.headers\n    assert \"Content-Range\" in response.headers\n    assert response.headers[\"Content-Range\"] == \"bytes */%s\" % (\n        len(get_file_content(static_file_directory, file_name)),\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt'])"
      ],
      "arguments": [
        "app",
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "inspect",
        "os",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint"
      ],
      "fixtures": [],
      "assertions": [
        "assert uri == '/testing.file'",
        "assert uri == app.url_for('static', name='static')",
        "assert uri == app.url_for('static', name='static', filename='any')",
        "assert response.status == 416",
        "assert 'Content-Length' in response.headers",
        "assert 'Content-Range' in response.headers",
        "assert response.headers['Content-Range'] == 'bytes */%s' % (len(get_file_content(static_file_directory, file_name)),)",
        "assert uri == '/bp/testing.file'",
        "assert uri == app.url_for('static', name='test_bp_static.static', filename='any')",
        "assert uri == app.url_for('test_bp_static.static')",
        "assert uri == app.url_for('test_bp_static.static', filename='any')",
        "assert response.status == 416",
        "assert 'Content-Length' in response.headers",
        "assert 'Content-Range' in response.headers",
        "assert response.headers['Content-Range'] == 'bytes */%s' % (len(get_file_content(static_file_directory, file_name)),)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_static_content_range_error` function is designed to verify the behavior of the Sanic web framework when handling HTTP range requests for static files. Specifically, it checks that the server correctly responds with a 416 status code (Range Not Satisfiable) when a malformed range request is made.\n\n**Specific Functionality or Behavior Verified**:  \nThe test ensures that when a range request is sent with an invalid range (e.g., \"bytes=1-0\"), the server responds with a 416 status code. It also verifies that the response headers include \"Content-Length\" and \"Content-Range\", and that the \"Content-Range\" header correctly indicates the total size of the requested file.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Sanic application and a blueprint that serve a static file with content range support enabled. It uses the `app.static` method to define the static file route and the `bp.static` method for the blueprint. The `app.test_client.get` method is then used to simulate an HTTP GET request with the specified range headers. The assertions check the response status and headers to confirm the expected behavior.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Setup and Teardown**: The test initializes a new Sanic application and a blueprint, ensuring a clean environment for each test run.\n- **Parameterized Testing**: The test uses parameters for different file names, allowing it to run multiple scenarios with varying inputs.\n- **Assertions**: The test employs multiple assertions to validate the response status and headers, ensuring comprehensive coverage of the expected outcomes.\n- **Blueprint Usage**: The test demonstrates the use of blueprints in Sanic, allowing for modular and organized routing of static files."
    },
    {
      "name": "test_request_cookies",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 16,
      "end_line_number": 27,
      "source_code": "def test_request_cookies():\n    cdict = parse_cookie(\"foo=one; foo=two; abc = xyz;;bare;=bare2\")\n    assert cdict == {\n        \"foo\": [\"one\", \"two\"],\n        \"abc\": [\"xyz\"],\n        \"\": [\"bare\", \"bare2\"],\n    }\n    c = CookieRequestParameters(cdict)\n    assert c.getlist(\"foo\") == [\"one\", \"two\"]\n    assert c.getlist(\"abc\") == [\"xyz\"]\n    assert c.getlist(\"\") == [\"bare\", \"bare2\"]\n    assert c.getlist(\"bare\") == []",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert cdict == {'foo': ['one', 'two'], 'abc': ['xyz'], '': ['bare', 'bare2']}",
        "assert c.getlist('foo') == ['one', 'two']",
        "assert c.getlist('abc') == ['xyz']",
        "assert c.getlist('') == ['bare', 'bare2']",
        "assert c.getlist('bare') == []"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_request_cookies` function is to verify the correct parsing and retrieval of cookie values from a string representation of cookies. It ensures that the `parse_cookie` function and the `CookieRequestParameters` class work as intended, particularly in handling multiple cookies with the same name and empty cookie names.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. The `parse_cookie` function correctly converts a cookie string into a dictionary format, where each cookie name maps to a list of its values.\n2. The `getlist` method of the `CookieRequestParameters` class accurately retrieves all values associated with a given cookie name, including handling cases where the cookie name is empty.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes:\n- The `parse_cookie` function, which takes a cookie string and returns a dictionary where keys are cookie names and values are lists of cookie values. For example, the input `\"foo=one; foo=two; abc = xyz;;bare;=bare2\"` results in `{'foo': ['one', 'two'], 'abc': ['xyz'], '': ['bare', 'bare2']}`.\n- The `CookieRequestParameters` class, which is initialized with the parsed cookie dictionary. It provides the `getlist` method to retrieve all values for a specified cookie name. The test checks that calling `getlist` with various keys returns the expected lists of values.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertion-Based Testing**: The test uses assertions to validate expected outcomes against actual results, which is a common practice in unit testing.\n- **Input-Output Verification**: The test verifies the output of the `parse_cookie` function against a predefined expected dictionary, ensuring that the parsing logic is functioning correctly.\n- **Method Behavior Testing**: It checks the behavior of the `getlist` method for different scenarios, including retrieving values for existing cookies, handling empty cookie names, and ensuring that non-existent cookies return an empty list. This thorough approach helps ensure robustness in the cookie handling logic."
    },
    {
      "name": "test_cookies",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 35,
      "end_line_number": 48,
      "source_code": "def test_cookies(app):\n    @app.route(\"/\")\n    def handler(request):\n        cookie_value = request.cookies[\"test\"]\n        response = text(f\"Cookies are: {cookie_value}\")\n        response.cookies[\"right_back\"] = \"at you\"\n        return response\n\n    request, response = app.test_client.get(\"/\", cookies={\"test\": \"working!\"})\n    response_cookies = SimpleCookie()\n    response_cookies.load(response.headers.get(\"Set-Cookie\", {}))\n\n    assert response.text == \"Cookies are: working!\"\n    assert response_cookies[\"right_back\"].value == \"at you\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'Cookies are: working!'",
        "assert response_cookies['right_back'].value == 'at you'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response_cookies.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        },
        {
          "name": "response.headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_cookies` function is designed to verify the correct handling of cookies in a Sanic web application. It checks that cookies sent in a request are properly read and that new cookies set in the response are correctly configured.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically verifies two behaviors: \n1. The application correctly retrieves the value of a cookie named \"test\" from the incoming request and includes it in the response text.\n2. A new cookie named \"right_back\" is set in the response, and its value is verified to ensure it is correctly assigned.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a route handler defined within the `test_cookies` function. This handler:\n- Reads the \"test\" cookie from the incoming request.\n- Constructs a response that includes the value of the \"test\" cookie in the response body.\n- Sets a new cookie \"right_back\" with the value \"at you\" in the response.\n\nThe test then simulates a GET request to the root endpoint (\"/\") with a cookie set to \"working!\". It checks the response text and the value of the newly set cookie.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the following patterns:\n- **Mocking**: The `app.test_client.get` method is used to simulate a request to the application, allowing for controlled testing of the route handler without needing to run a live server.\n- **Assertions**: The test uses assertions to validate the expected outcomes, ensuring that the response text and cookie values match the anticipated results.\n- **Isolation**: The test is self-contained, with the route handler defined within the test function, ensuring that it does not interfere with other tests and maintains a clear focus on cookie handling."
    },
    {
      "name": "test_false_cookies_encoded",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 71,
      "end_line_number": 81,
      "source_code": "def test_false_cookies_encoded(app, httponly, expected):\n    @app.route(\"/\")\n    def handler(request):\n        response = text(\"hello cookies\")\n        response.cookies[\"hello\"] = \"world\"\n        response.cookies[\"hello\"][\"httponly\"] = httponly\n        return text(response.cookies[\"hello\"].encode(\"utf8\").decode())\n\n    request, response = app.test_client.get(\"/\")\n\n    assert (\"HttpOnly\" in response.text) == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('httponly,expected', [(False, False), (True, True)])"
      ],
      "arguments": [
        "app",
        "httponly",
        "expected"
      ],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert ('HttpOnly' in response.text) == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_false_cookies_encoded` test is designed to verify the behavior of cookie handling in a Sanic web application, specifically checking whether the \"HttpOnly\" attribute is correctly set and reflected in the response when cookies are encoded.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks if the presence of the \"HttpOnly\" attribute in the response cookies matches the expected boolean value provided as an argument. It asserts that the string \"HttpOnly\" appears in the response text only when the `expected` parameter is `True`.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route handler that sets a cookie named \"hello\" with a value of \"world\" and assigns the `httponly` attribute based on the test input. The handler then returns the encoded value of the cookie. The test client makes a GET request to this route, and the response is checked to see if \"HttpOnly\" is present in the response text, which indicates whether the cookie was set with the HttpOnly attribute.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test likely uses a parameterized testing approach (though not shown in the snippet) to run multiple scenarios with different values for `httponly` and `expected`.\n- **Assertion**: The test employs a straightforward assertion to validate the expected outcome against the actual response, ensuring that the cookie's properties are correctly reflected in the response.\n- **Mocking**: The use of `app.test_client.get` simulates a real HTTP request to the application, allowing for testing of the route's behavior without needing a live server."
    },
    {
      "name": "test_false_cookies",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 85,
      "end_line_number": 97,
      "source_code": "def test_false_cookies(app, httponly, expected):\n    @app.route(\"/\")\n    def handler(request):\n        response = text(\"hello cookies\")\n        response.cookies[\"right_back\"] = \"at you\"\n        response.cookies[\"right_back\"][\"httponly\"] = httponly\n        return response\n\n    request, response = app.test_client.get(\"/\")\n    response_cookies = SimpleCookie()\n    response_cookies.load(response.headers.get(\"Set-Cookie\", {}))\n\n    assert (\"HttpOnly\" in response_cookies[\"right_back\"].output()) == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('httponly,expected', [(False, False), (True, True)])"
      ],
      "arguments": [
        "app",
        "httponly",
        "expected"
      ],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert ('HttpOnly' in response_cookies['right_back'].output()) == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response_cookies.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        },
        {
          "name": "response.headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_false_cookies` function is designed to verify the behavior of cookie attributes, specifically the `HttpOnly` flag, in the response generated by a Sanic web application. It checks whether the `HttpOnly` attribute is correctly set based on the input parameter `httponly`.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks if the `HttpOnly` attribute is present in the `Set-Cookie` header of the HTTP response when a cookie is created. The test asserts that the presence of the `HttpOnly` attribute in the cookie output matches the expected value provided as an argument to the test.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route handler that sets a cookie named `right_back` with a value of `\"at you\"` and assigns the `httponly` attribute based on the test input. The test then simulates a GET request to the root endpoint (`\"/\"`) using the `app.test_client.get` method. It retrieves the `Set-Cookie` header from the response, loads it into a `SimpleCookie` object, and checks if the `HttpOnly` attribute is present in the cookie's output.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test function takes parameters (`app`, `httponly`, `expected`), allowing it to be run with different values for `httponly` and `expected`, which is useful for testing multiple scenarios without duplicating code.\n- **Assertion**: The test uses an assertion to validate the expected outcome, ensuring that the behavior of the cookie handling aligns with the specified requirements.\n- **Mocking**: The use of `app.test_client.get` simulates HTTP requests, allowing the test to focus on the application's response behavior without needing a live server."
    },
    {
      "name": "test_http2_cookies",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 100,
      "end_line_number": 110,
      "source_code": "def test_http2_cookies(app):\n    @app.route(\"/\")\n    async def handler(request):\n        cookie_value = request.cookies[\"test\"]\n        response = text(f\"Cookies are: {cookie_value}\")\n        return response\n\n    headers = {\"cookie\": \"test=working!\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n\n    assert response.text == \"Cookies are: working!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'Cookies are: working!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_http2_cookies` function is designed to verify that the Sanic application correctly processes HTTP requests containing cookies. Specifically, it checks whether the application can read a cookie from the request and return the expected response that includes the cookie's value.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a request is made to the root endpoint (\"/\") with a specific cookie set in the headers, the application correctly retrieves the cookie value and includes it in the response text. It validates that the response matches the expected output, confirming the proper handling of cookies in HTTP/2 requests.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes an asynchronous route handler defined within the `test_http2_cookies` function. The handler retrieves the value of the \"test\" cookie from the incoming request and constructs a response that includes this value. The test simulates a GET request to the root endpoint with a cookie header set to \"test=working!\". The expected behavior is that the response text should be \"Cookies are: working!\", which is asserted at the end of the test.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test uses an asynchronous route handler, which is a common pattern in modern web frameworks to handle I/O-bound operations efficiently.\n- **Mocking HTTP Requests**: The test utilizes the `app.test_client.get` method to simulate an HTTP GET request, allowing for controlled testing of the application's behavior without needing a live server.\n- **Assertions**: The test employs a straightforward assertion to compare the actual response text with the expected output, ensuring that the application behaves as intended when handling cookies."
    },
    {
      "name": "test_cookie_options",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 113,
      "end_line_number": 129,
      "source_code": "def test_cookie_options(app):\n    @app.route(\"/\")\n    def handler(request):\n        response = text(\"OK\")\n        response.cookies[\"test\"] = \"at you\"\n        response.cookies[\"test\"][\"httponly\"] = True\n        response.cookies[\"test\"][\"expires\"] = datetime.now() + timedelta(\n            seconds=10\n        )\n        return response\n\n    request, response = app.test_client.get(\"/\")\n    response_cookies = SimpleCookie()\n    response_cookies.load(response.headers.get(\"Set-Cookie\", {}))\n\n    assert response_cookies[\"test\"].value == \"at you\"\n    assert response_cookies[\"test\"][\"httponly\"] is True",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert response_cookies['test'].value == 'at you'",
        "assert response_cookies['test']['httponly'] is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response_cookies.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        },
        {
          "name": "response.headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_cookie_options` unit test is to verify that the Sanic application correctly sets cookie attributes, specifically the value, `HttpOnly` flag, and expiration time for a cookie in the HTTP response.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a request is made to the root endpoint (\"/\"), the response contains a cookie named \"test\" with the expected value of \"at you\" and that the `HttpOnly` attribute is set to `True`. This ensures that the cookie is not accessible via JavaScript, enhancing security.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route handler that creates a response with a cookie. The cookie is assigned a value and has its `HttpOnly` attribute set to `True`, along with an expiration time of 10 seconds from the current time. The test then simulates a GET request to the root endpoint using `app.test_client.get(\"/\")`, retrieves the `Set-Cookie` header from the response, and loads it into a `SimpleCookie` object for verification. The assertions confirm that the cookie's value and attributes are set as intended.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the following techniques:\n- **Route Definition**: It defines a route within the test to isolate the behavior being tested.\n- **Client Simulation**: It uses `app.test_client.get()` to simulate an HTTP request and capture the response.\n- **Cookie Parsing**: The `SimpleCookie` class is utilized to parse the `Set-Cookie` header, allowing for easy verification of cookie attributes.\n- **Assertions**: The test uses assertions to validate that the cookie's value and attributes match the expected outcomes, ensuring the correctness of the implementation."
    },
    {
      "name": "test_cookie_deletion",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 132,
      "end_line_number": 149,
      "source_code": "def test_cookie_deletion(app):\n    cookie_jar = None\n\n    @app.route(\"/\")\n    def handler(request):\n        nonlocal cookie_jar\n        response = text(\"OK\")\n        del response.cookies[\"one\"]\n        response.cookies[\"two\"] = \"testing\"\n        del response.cookies[\"two\"]\n        cookie_jar = response.cookies\n        return response\n\n    _, response = app.test_client.get(\"/\")\n\n    assert cookie_jar.get_cookie(\"one\").max_age == 0\n    assert cookie_jar.get_cookie(\"two\").max_age == 0\n    assert len(response.cookies) == 0",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert cookie_jar.get_cookie('one').max_age == 0",
        "assert cookie_jar.get_cookie('two').max_age == 0",
        "assert len(response.cookies) == 0"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "cookie_jar.get_cookie",
          "body": "@app.get('/cookie')\ndef get_cookie(request):\n    response = text(\"There's a cookie up in this response\")\n    response.cookies['test'] = 'Cookie1'\n    response.cookies['test']['httponly'] = True\n    response.cookies['c2'] = 'Cookie2'\n    response.cookies['c2']['httponly'] = False\n    return response"
        },
        {
          "name": "cookie_jar.get_cookie",
          "body": "@app.get('/cookie')\ndef get_cookie(request):\n    response = text(\"There's a cookie up in this response\")\n    response.cookies['test'] = 'Cookie1'\n    response.cookies['test']['httponly'] = True\n    response.cookies['c2'] = 'Cookie2'\n    response.cookies['c2']['httponly'] = False\n    return response"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_cookie_deletion` function is designed to verify the behavior of cookie deletion in a Sanic web application. Specifically, it checks that cookies can be deleted correctly and that their properties reflect this deletion.\n\n**Specific Functionality or Behavior Verified**:  \nThe test ensures that when a cookie is deleted, its `max_age` property is set to `0`, indicating that it is no longer valid. Additionally, it verifies that the response does not contain any cookies after the deletion operations.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route handler for the root path (\"/\") of the application. Within this handler:\n- A response is created with the text \"OK\".\n- The cookie named \"one\" is deleted from the response.\n- A new cookie named \"two\" is added and then immediately deleted.\n- The resulting cookies are stored in the `cookie_jar` variable.\n\nAfter invoking the route with a GET request, the test checks:\n1. The `max_age` of the cookie \"one\" is `0`, confirming it has been deleted.\n2. The `max_age` of the cookie \"two\" is also `0`, confirming it was added and then deleted.\n3. The length of the `response.cookies` is `0`, indicating no cookies are present in the response.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Nonlocal Variable**: The use of `nonlocal` allows the inner function to modify the `cookie_jar` variable defined in the outer scope, which is essential for capturing the state of cookies after the request.\n- **Assertions**: The test employs assertions to validate the expected outcomes, ensuring that the behavior of the cookie handling aligns with the intended functionality.\n- **Route Handling**: The test demonstrates how to define a route and handle requests within the Sanic framework, showcasing the integration of request handling and cookie management in a web application context."
    },
    {
      "name": "test_cookie_reserved_cookie",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 152,
      "end_line_number": 155,
      "source_code": "def test_cookie_reserved_cookie():\n    with pytest.raises(expected_exception=KeyError) as e:\n        Cookie(\"domain\", \"testdomain.com\")\n        assert e.message == \"Cookie name is a reserved word\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert e.message == 'Cookie name is a reserved word'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_cookie_reserved_cookie` function is designed to verify that the `Cookie` class correctly raises a `KeyError` when an attempt is made to create a cookie with a name that is a reserved word. This ensures that the implementation adheres to the expected behavior regarding cookie naming conventions.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that when a cookie is instantiated with a reserved name, the appropriate exception is raised, and that the exception message accurately reflects the reason for the failure. In this case, it confirms that the message is \"Cookie name is a reserved word\".\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `Cookie` class constructor, which presumably includes logic to check if the provided cookie name is a reserved word. If it is, the constructor raises a `KeyError`. The test uses the `pytest.raises` context manager to assert that this exception is raised during the instantiation of the `Cookie` object.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager, which is a common pattern in unit testing for asserting that specific exceptions are raised during the execution of code. This pattern enhances readability and clarity, allowing the test to focus on the expected outcome (the exception) rather than the mechanics of exception handling. Additionally, the use of an assertion on the exception message provides a more granular check, ensuring that not only is the exception raised, but it also conveys the correct information."
    },
    {
      "name": "test_cookie_illegal_key_format",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 158,
      "end_line_number": 161,
      "source_code": "def test_cookie_illegal_key_format():\n    with pytest.raises(expected_exception=KeyError) as e:\n        Cookie(\"test\u00e5\", \"test\")\n        assert e.message == \"Cookie key contains illegal characters\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert e.message == 'Cookie key contains illegal characters'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_cookie_illegal_key_format` test is designed to verify that the `Cookie` class correctly raises a `KeyError` when an attempt is made to create a cookie with a key that contains illegal characters, specifically non-ASCII characters.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks the error handling mechanism of the `Cookie` class when it encounters a cookie key that does not conform to the expected format. It ensures that the appropriate exception is raised and that the error message accurately describes the issue.\n\n**Code Being Tested and How It Works**:  \nThe test invokes the `Cookie` constructor with a key `\"test\u00e5\"` which includes a non-ASCII character (`\u00e5`). The expected behavior is that the constructor will raise a `KeyError` with the message \"Cookie key contains illegal characters\". This behavior is likely implemented in the `Cookie` class's `__init__` method, which validates the key format before allowing the creation of a cookie.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that a specific exception (`KeyError`) is raised during the execution of the code block. This pattern is effective for testing error conditions, as it allows for clean and readable assertions about expected exceptions. Additionally, the test checks the exception message to ensure it provides the correct feedback, which is a good practice for validating the specificity of error handling."
    },
    {
      "name": "test_cookie_set_unknown_property",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 164,
      "end_line_number": 168,
      "source_code": "def test_cookie_set_unknown_property():\n    c = Cookie(\"test_cookie\", \"value\")\n    with pytest.raises(expected_exception=KeyError) as e:\n        c[\"invalid\"] = \"value\"\n        assert e.message == \"Unknown cookie property\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert e.message == 'Unknown cookie property'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_cookie_set_unknown_property` unit test is designed to verify that attempting to set an invalid property on a `Cookie` object raises the appropriate exception, specifically a `KeyError`. This ensures that the `Cookie` class enforces its property constraints correctly.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when an unknown property (in this case, \"invalid\") is assigned to a `Cookie` instance, a `KeyError` is raised with the message \"Unknown cookie property\". This behavior is crucial for maintaining the integrity of the `Cookie` class by preventing the assignment of undefined properties.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `Cookie` class, which likely has a mechanism to manage its properties. When the line `c[\"invalid\"] = \"value\"` is executed, the `__setitem__` method of the `Cookie` class is invoked. This method should contain logic to check if the key being set is valid. If the key is not recognized, it raises a `KeyError`, which is what the test is asserting.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that a specific exception is raised during the execution of the code block. This is a common pattern in unit testing that allows for clean and readable exception handling tests. Additionally, the test checks the exception message to ensure that it is not only raising the correct type of exception but also providing the correct error message, which is important for debugging and user feedback."
    },
    {
      "name": "test_cookie_set_same_key",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 171,
      "end_line_number": 183,
      "source_code": "def test_cookie_set_same_key(app):\n    cookies = {\"test\": \"wait\"}\n\n    @app.get(\"/\")\n    def handler(request):\n        response = text(\"pass\")\n        response.cookies[\"test\"] = \"modified\"\n        response.cookies[\"test\"] = \"pass\"\n        return response\n\n    request, response = app.test_client.get(\"/\", cookies=cookies)\n    assert response.status == 200\n    assert response.cookies[\"test\"] == \"pass\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.cookies['test'] == 'pass'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_cookie_set_same_key` unit test is designed to verify the behavior of setting cookies with the same key in a Sanic web application. It ensures that the last value assigned to a cookie with a duplicate key is the one that is ultimately stored in the response.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a cookie is set multiple times with the same key, the final value assigned to that key is the one that is returned in the response. In this case, it verifies that the cookie named \"test\" is set to \"pass\" after being modified.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route handler for the root path (\"/\") of the application. Inside this handler, it creates a response object and sets the cookie \"test\" twice: first to \"modified\" and then to \"pass\". The test then simulates a GET request to this route with an initial cookie value of \"wait\". After the request is processed, it asserts that the response status is 200 (indicating success) and that the value of the \"test\" cookie in the response is \"pass\", confirming that the last assignment took effect.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of a mock application context (`app`) to define the route and handle requests, which is a common pattern in unit testing web applications. It also utilizes assertions to validate the expected outcomes, ensuring that the test is both clear and effective in confirming the desired behavior. The use of a simple dictionary to represent cookies and the direct manipulation of the response object are straightforward techniques that enhance the readability and maintainability of the test."
    },
    {
      "name": "test_cookie_max_age",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 187,
      "end_line_number": 225,
      "source_code": "def test_cookie_max_age(app, max_age):\n    cookies = {\"test\": \"wait\"}\n\n    @app.get(\"/\")\n    def handler(request):\n        response = text(\"pass\")\n        response.cookies[\"test\"] = \"pass\"\n        response.cookies[\"test\"][\"max-age\"] = max_age\n        return response\n\n    request, response = app.test_client.get(\n        \"/\", cookies=cookies, raw_cookies=True\n    )\n    assert response.status == 200\n\n    cookie = response.cookies.get(\"test\")\n    if (\n        str(max_age).isdigit()\n        and int(max_age) == float(max_age)\n        and int(max_age) != 0\n    ):\n        cookie_expires = datetime.utcfromtimestamp(\n            response.raw_cookies[\"test\"].expires\n        ).replace(microsecond=0)\n\n        # Grabbing utcnow after the response may lead to it being off slightly.\n        # Therefore, we 0 out the microseconds, and accept the test if there\n        # is a 1 second difference.\n        expires = datetime.utcnow().replace(microsecond=0) + timedelta(\n            seconds=int(max_age)\n        )\n\n        assert cookie == \"pass\"\n        assert (\n            cookie_expires == expires\n            or cookie_expires == expires + timedelta(seconds=-1)\n        )\n    else:\n        assert cookie is None",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('max_age', ['0', 30, '30'])"
      ],
      "arguments": [
        "app",
        "max_age"
      ],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert cookie == 'pass'",
        "assert cookie_expires == expires or cookie_expires == expires + timedelta(seconds=-1)",
        "assert cookie is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response.cookies.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_cookie_max_age` function is designed to verify the behavior of cookie expiration based on the `max-age` attribute. It ensures that when a cookie is set with a specific `max-age`, it behaves as expected in terms of its value and expiration time.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two scenarios: \n1. When a valid `max_age` is provided (a positive integer), it verifies that the cookie is set correctly and that its expiration time matches the expected value based on the current time plus the `max_age`.\n2. When an invalid `max_age` is provided (non-integer or zero), it confirms that the cookie is not set, ensuring that the application correctly handles invalid input.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves a Sanic application that defines a route (`/`) which sets a cookie named `test` with a value of `\"pass\"` and a `max-age` attribute. The test simulates a GET request to this route, checking the response status and the properties of the cookie returned. The cookie's expiration is calculated using the current UTC time and the provided `max_age`, and assertions are made to ensure the cookie's value and expiration are as expected.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterized Testing**: The test utilizes parameterization to run multiple scenarios with different `max_age` values, including valid and invalid cases. This approach enhances test coverage and ensures that various input types are handled correctly.\n- **Assertions**: The test employs assertions to validate the response status and the properties of the cookie, ensuring that the application behaves as intended under different conditions.\n- **Time Handling**: The test accounts for potential discrepancies in time measurement by allowing a one-second difference when comparing expiration times, demonstrating careful consideration of timing issues in tests."
    },
    {
      "name": "test_cookie_bad_max_age",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 229,
      "end_line_number": 242,
      "source_code": "def test_cookie_bad_max_age(app, max_age):\n    cookies = {\"test\": \"wait\"}\n\n    @app.get(\"/\")\n    def handler(request):\n        response = text(\"pass\")\n        response.cookies[\"test\"] = \"pass\"\n        response.cookies[\"test\"][\"max-age\"] = max_age\n        return response\n\n    request, response = app.test_client.get(\n        \"/\", cookies=cookies, raw_cookies=True\n    )\n    assert response.status == 500",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('max_age', [30.0, 30.1, 'test'])"
      ],
      "arguments": [
        "app",
        "max_age"
      ],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_cookie_bad_max_age` function is designed to verify that the application correctly handles invalid values for the `max-age` attribute of cookies. Specifically, it checks that when an invalid `max_age` is provided, the server responds with a 500 Internal Server Error status.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the application does not crash or behave unexpectedly when it encounters a non-integer or inappropriate value for the `max-age` attribute in a cookie. The expected behavior is that the server should return a 500 status code, indicating an internal error due to the invalid cookie configuration.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a simple Sanic application with a route that sets a cookie named \"test\" with a value of \"pass\" and assigns the `max-age` attribute to the value of `max_age` passed to the test. The test then simulates a GET request to the root endpoint (\"/\") with a pre-existing cookie. The response is checked to ensure that the status code is 500, which indicates that the application encountered an error while processing the request due to the invalid `max-age`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses `@pytest.mark.parametrize` to run the same test logic with multiple values for `max_age`, including valid (30.0, 30.1) and invalid (\"test\") inputs. This allows for efficient testing of various scenarios without duplicating code.\n- **Assertion of Response Status**: The test asserts the response status directly, which is a common practice in unit tests to verify that the application behaves as expected under different conditions.\n- **Isolation of Test Logic**: The test defines a handler function within the test scope, ensuring that the test is self-contained and does not interfere with other tests or application logic."
    },
    {
      "name": "test_cookie_expires",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 246,
      "end_line_number": 267,
      "source_code": "def test_cookie_expires(app: Sanic, expires: timedelta):\n    expires_time = datetime.utcnow().replace(microsecond=0) + expires\n    cookies = {\"test\": \"wait\"}\n\n    @app.get(\"/\")\n    def handler(request):\n        response = text(\"pass\")\n        response.cookies[\"test\"] = \"pass\"\n        response.cookies[\"test\"][\"expires\"] = expires_time\n        return response\n\n    request, response = app.test_client.get(\n        \"/\", cookies=cookies, raw_cookies=True\n    )\n\n    cookie_expires = datetime.utcfromtimestamp(\n        response.raw_cookies[\"test\"].expires\n    ).replace(microsecond=0)\n\n    assert response.status == 200\n    assert response.cookies[\"test\"] == \"pass\"\n    assert cookie_expires == expires_time",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('expires', [timedelta(seconds=60)])"
      ],
      "arguments": [
        "app",
        "expires"
      ],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.cookies['test'] == 'pass'",
        "assert cookie_expires == expires_time"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_cookie_expires` function is designed to verify that cookies set by the Sanic application correctly reflect the specified expiration time. It ensures that when a cookie is created with a defined expiration, the cookie's properties are accurately set and can be retrieved as expected.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks three main assertions: \n1. The HTTP response status is 200, indicating a successful request.\n2. The value of the cookie named \"test\" is set to \"pass\".\n3. The expiration time of the cookie matches the expected expiration time calculated based on the provided `expires` parameter.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route handler for the root path (\"/\") that sets a cookie named \"test\" with the value \"pass\" and an expiration time derived from the current UTC time plus the `expires` timedelta. The test client then makes a GET request to this route, simulating a browser request that includes an initial cookie. After receiving the response, the test extracts the expiration time from the raw cookies and compares it to the expected expiration time. The relevant methods being tested include the route handler and the cookie management functionality of the Sanic framework.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test is likely part of a parameterized test suite, allowing it to run with different expiration values, although the specific parameterization is not shown in the provided code.\n- **Assertions**: The test employs assertions to validate the response status, cookie value, and expiration time, which are standard practices in unit testing to ensure that the code behaves as expected.\n- **Mocking**: The use of `app.test_client.get` simulates HTTP requests without needing a live server, allowing for isolated testing of the cookie functionality."
    },
    {
      "name": "test_cookie_expires_illegal_instance_type",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 271,
      "end_line_number": 275,
      "source_code": "def test_cookie_expires_illegal_instance_type(expires):\n    c = Cookie(\"test_cookie\", \"value\")\n    with pytest.raises(expected_exception=TypeError) as e:\n        c[\"expires\"] = expires\n        assert e.message == \"Cookie 'expires' property must be a datetime\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('expires', ['Fri, 21-Dec-2018 15:30:00 GMT'])"
      ],
      "arguments": [
        "expires"
      ],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert e.message == \"Cookie 'expires' property must be a datetime\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_cookie_expires_illegal_instance_type` is designed to verify that the `expires` property of a `Cookie` object correctly enforces type constraints, specifically that it must be a `datetime` instance. This ensures that any attempt to assign an invalid type raises a `TypeError`.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when an invalid type (in this case, a string representing a date) is assigned to the `expires` property of a `Cookie`, a `TypeError` is raised with the message \"Cookie 'expires' property must be a datetime\". This behavior is crucial for maintaining the integrity of cookie expiration handling.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `expires` property setter of the `Cookie` class. When the test attempts to set `c[\"expires\"] = expires`, it triggers the setter method, which is expected to validate the type of the value being assigned. If the value is not a `datetime`, the setter raises a `TypeError`, which is what the test is asserting.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that a specific exception is raised during the execution of the code block. This is a common pattern in unit testing for verifying that error conditions are handled correctly. Additionally, the test uses parameterization (`@pytest.mark.parametrize`) to run the test with different invalid `expires` values, enhancing coverage and ensuring robustness against various incorrect input types."
    },
    {
      "name": "test_request_with_duplicate_cookie_key",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 279,
      "end_line_number": 286,
      "source_code": "def test_request_with_duplicate_cookie_key(value):\n    headers = Header({\"Cookie\": value})\n    request = Request(b\"/\", headers, \"1.1\", \"GET\", Mock(), Mock())\n\n    assert request.cookies[\"foo\"] == \"one\"\n    assert request.cookies.get(\"foo\") == \"one\"\n    assert request.cookies.getlist(\"foo\") == [\"one\", \"two\"]\n    assert request.cookies.get(\"bar\") is None",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('value', ('foo=one; foo=two', 'foo=one;foo=two'))"
      ],
      "arguments": [
        "value"
      ],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.cookies['foo'] == 'one'",
        "assert request.cookies.get('foo') == 'one'",
        "assert request.cookies.getlist('foo') == ['one', 'two']",
        "assert request.cookies.get('bar') is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "request.cookies.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "request.cookies.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:\nThe test `test_request_with_duplicate_cookie_key` is designed to verify the behavior of the `Request` class in handling cookies, specifically when there are duplicate cookie keys in the request headers. It ensures that the implementation correctly retrieves both single and multiple values for cookies with the same name.\n\n**Specific Functionality or Behavior Verified**:\nThe test checks that:\n1. A single value can be retrieved for a cookie key (`foo`).\n2. The same value can be accessed using the `get` method.\n3. Multiple values for the same cookie key can be retrieved using the `getlist` method.\n4. A cookie key that does not exist (`bar`) returns `None`.\n\n**Code Being Tested and How It Works**:\nThe code under test involves the `Request` class, which processes HTTP requests. The `cookies` attribute of the `Request` object is expected to handle cookies as a dictionary-like structure, allowing for both single and multiple values. The `Header` class is used to simulate the HTTP headers, including the `Cookie` header, which contains the cookie data. The test initializes a `Request` object with a specific cookie string and then asserts the expected behavior of the `cookies` attribute.\n\n**Notable Testing Patterns or Techniques Used**:\n- **Parameterized Testing**: The test uses a parameterized approach by passing different cookie values to check various scenarios of cookie retrieval.\n- **Assertions**: Multiple assertions are employed to validate different aspects of cookie handling, ensuring comprehensive coverage of the functionality.\n- **Mocking**: The use of `Mock()` allows for the creation of mock objects that simulate the behavior of complex dependencies, focusing the test on the `Request` class's cookie handling logic without external interference."
    },
    {
      "name": "test_cookie_jar_cookies",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 289,
      "end_line_number": 296,
      "source_code": "def test_cookie_jar_cookies():\n    headers = Header()\n    jar = CookieJar(headers)\n    jar.add_cookie(\"foo\", \"one\")\n    jar.add_cookie(\"foo\", \"two\", domain=\"example.com\")\n\n    assert len(jar.cookies) == 2\n    assert len(headers) == 2",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(jar.cookies) == 2",
        "assert len(headers) == 2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_cookie_jar_cookies` function is designed to verify that the `CookieJar` class correctly manages the addition of cookies and updates the associated headers. It ensures that the internal state of the `CookieJar` reflects the expected number of cookies after adding them.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when two cookies are added to the `CookieJar`, the total count of cookies in both the `CookieJar` and the `Header` object is as expected. It asserts that the `CookieJar` contains two cookies and that the `Header` also reflects this count, confirming that the cookies are being tracked correctly.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `CookieJar` class, which is initialized with a `Header` object. The `add_cookie` method is called twice to add two cookies with the same name but different attributes (one without a domain and the other with a domain). The `len(jar.cookies)` and `len(headers)` assertions check that both the `CookieJar` and the `Header` have two entries, indicating that the cookies were added successfully.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs direct assertions to validate the state of the `CookieJar` and `Header` after performing operations, which is a common pattern in unit testing. It uses the `assert` statement to check conditions, which is straightforward and effective for verifying expected outcomes. The test is also structured to be simple and focused, making it easy to understand the specific behavior being validated."
    },
    {
      "name": "test_cookie_jar_has_cookie",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 299,
      "end_line_number": 308,
      "source_code": "def test_cookie_jar_has_cookie():\n    headers = Header()\n    jar = CookieJar(headers)\n    jar.add_cookie(\"foo\", \"one\")\n    jar.add_cookie(\"foo\", \"two\", domain=\"example.com\")\n\n    assert jar.has_cookie(\"foo\")\n    assert jar.has_cookie(\"foo\", domain=\"example.com\")\n    assert not jar.has_cookie(\"foo\", path=\"/unknown\")\n    assert not jar.has_cookie(\"bar\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert jar.has_cookie('foo')",
        "assert jar.has_cookie('foo', domain='example.com')",
        "assert not jar.has_cookie('foo', path='/unknown')",
        "assert not jar.has_cookie('bar')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_cookie_jar_has_cookie` function is designed to verify the functionality of the `has_cookie` method in the `CookieJar` class. It ensures that the cookie jar correctly identifies the presence or absence of cookies based on their names, domains, and paths.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks four specific scenarios:\n1. It confirms that a cookie with the name \"foo\" exists in the jar.\n2. It verifies that a cookie with the name \"foo\" exists when specifically queried with the domain \"example.com\".\n3. It asserts that there is no cookie with the name \"foo\" when queried with an unknown path (\"/unknown\").\n4. It checks that a cookie with the name \"bar\" does not exist in the jar.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `has_cookie` method of the `CookieJar` class. The test first creates a `Header` object and initializes a `CookieJar` instance with it. It then adds two cookies with the name \"foo\" (one without a domain and one with the domain \"example.com\"). The `has_cookie` method is called with various parameters to check for the existence of these cookies, demonstrating how the method handles different conditions (name, domain, path).\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs direct assertions to validate the expected outcomes, which is a common pattern in unit testing. It uses the `assert` statement to check boolean conditions, making it straightforward to understand what is being tested. The test is also self-contained, meaning it sets up its own context (creating headers and a cookie jar) without relying on external state, which is a best practice in unit testing to ensure isolation and repeatability."
    },
    {
      "name": "test_cookie_jar_get_cookie",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 311,
      "end_line_number": 320,
      "source_code": "def test_cookie_jar_get_cookie():\n    headers = Header()\n    jar = CookieJar(headers)\n    cookie1 = jar.add_cookie(\"foo\", \"one\")\n    cookie2 = jar.add_cookie(\"foo\", \"two\", domain=\"example.com\")\n\n    assert jar.get_cookie(\"foo\") is cookie1\n    assert jar.get_cookie(\"foo\", domain=\"example.com\") is cookie2\n    assert jar.get_cookie(\"foo\", path=\"/unknown\") is None\n    assert jar.get_cookie(\"bar\") is None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert jar.get_cookie('foo') is cookie1",
        "assert jar.get_cookie('foo', domain='example.com') is cookie2",
        "assert jar.get_cookie('foo', path='/unknown') is None",
        "assert jar.get_cookie('bar') is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "jar.get_cookie",
          "body": "@app.get('/cookie')\ndef get_cookie(request):\n    response = text(\"There's a cookie up in this response\")\n    response.cookies['test'] = 'Cookie1'\n    response.cookies['test']['httponly'] = True\n    response.cookies['c2'] = 'Cookie2'\n    response.cookies['c2']['httponly'] = False\n    return response"
        },
        {
          "name": "jar.get_cookie",
          "body": "@app.get('/cookie')\ndef get_cookie(request):\n    response = text(\"There's a cookie up in this response\")\n    response.cookies['test'] = 'Cookie1'\n    response.cookies['test']['httponly'] = True\n    response.cookies['c2'] = 'Cookie2'\n    response.cookies['c2']['httponly'] = False\n    return response"
        },
        {
          "name": "jar.get_cookie",
          "body": "@app.get('/cookie')\ndef get_cookie(request):\n    response = text(\"There's a cookie up in this response\")\n    response.cookies['test'] = 'Cookie1'\n    response.cookies['test']['httponly'] = True\n    response.cookies['c2'] = 'Cookie2'\n    response.cookies['c2']['httponly'] = False\n    return response"
        },
        {
          "name": "jar.get_cookie",
          "body": "@app.get('/cookie')\ndef get_cookie(request):\n    response = text(\"There's a cookie up in this response\")\n    response.cookies['test'] = 'Cookie1'\n    response.cookies['test']['httponly'] = True\n    response.cookies['c2'] = 'Cookie2'\n    response.cookies['c2']['httponly'] = False\n    return response"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_cookie_jar_get_cookie` function is designed to verify the behavior of the `get_cookie` method in the `CookieJar` class. It ensures that the method correctly retrieves cookies based on their keys, domains, and paths, and that it returns `None` for non-existent cookies.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks four specific scenarios:\n1. It verifies that the cookie with the key \"foo\" is correctly retrieved when no domain is specified.\n2. It checks that the cookie with the key \"foo\" and the domain \"example.com\" is retrieved correctly.\n3. It confirms that a request for a cookie with the key \"foo\" and an unknown path returns `None`.\n4. It ensures that a request for a cookie with a key that does not exist (in this case, \"bar\") also returns `None`.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `get_cookie` method of the `CookieJar` class. This method takes parameters for the cookie key, path, and domain, and it iterates through the stored cookies to find a match based on these criteria. If a matching cookie is found, it is returned; otherwise, `None` is returned. The test sets up a `CookieJar` instance, adds two cookies, and then calls `get_cookie` with various parameters to validate its functionality.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs direct assertions to validate expected outcomes, which is a common pattern in unit testing. It uses the `is` operator to check for object identity, ensuring that the returned cookie is the exact instance that was added to the jar. This approach helps confirm that the `get_cookie` method not only retrieves the correct cookie but also maintains the integrity of the cookie objects. Additionally, the test is structured to cover both positive and negative cases, enhancing its robustness."
    },
    {
      "name": "test_cookie_jar_add_cookie_encode",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 323,
      "end_line_number": 348,
      "source_code": "def test_cookie_jar_add_cookie_encode():\n    headers = Header()\n    jar = CookieJar(headers)\n    jar.add_cookie(\"foo\", \"one\")\n    jar.add_cookie(\n        \"foo\",\n        \"two\",\n        domain=\"example.com\",\n        path=\"/something\",\n        secure=True,\n        max_age=999,\n        httponly=True,\n        samesite=\"strict\",\n    )\n    jar.add_cookie(\"foo\", \"three\", secure_prefix=True)\n    jar.add_cookie(\"foo\", \"four\", host_prefix=True)\n    jar.add_cookie(\"foo\", \"five\", host_prefix=True, partitioned=True)\n\n    encoded = [cookie.encode(\"ascii\") for cookie in jar.cookies]\n    assert encoded == [\n        b\"foo=one; Path=/; SameSite=Lax; Secure\",\n        b\"foo=two; Path=/something; Domain=example.com; Max-Age=999; SameSite=Strict; Secure; HttpOnly\",  # noqa\n        b\"__Secure-foo=three; Path=/; SameSite=Lax; Secure\",\n        b\"__Host-foo=four; Path=/; SameSite=Lax; Secure\",\n        b\"__Host-foo=five; Path=/; SameSite=Lax; Secure; Partitioned\",\n    ]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert encoded == [b'foo=one; Path=/; SameSite=Lax; Secure', b'foo=two; Path=/something; Domain=example.com; Max-Age=999; SameSite=Strict; Secure; HttpOnly', b'__Secure-foo=three; Path=/; SameSite=Lax; Secure', b'__Host-foo=four; Path=/; SameSite=Lax; Secure', b'__Host-foo=five; Path=/; SameSite=Lax; Secure; Partitioned']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_cookie_jar_add_cookie_encode` test is to verify that the `CookieJar` class correctly encodes cookies with various attributes and prefixes. It ensures that cookies are added to the jar with the expected properties and that they are encoded in the correct format when retrieved.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks the behavior of the `add_cookie` method in the `CookieJar` class. It verifies that cookies can be added with different configurations, including secure flags, domain, path, and prefix options. The test asserts that the encoded output matches the expected byte strings, which represent the cookies in their proper HTTP format.\n\n**Code Being Tested and How It Works**:  \nThe code being tested involves the `CookieJar` class, which manages a collection of cookies. The `add_cookie` method is called multiple times with different parameters to add cookies with various attributes. After adding the cookies, the test retrieves the cookies from the jar and encodes them into ASCII format. The expected output is a list of byte strings that represent the cookies, formatted according to HTTP cookie standards. The test then asserts that the actual encoded output matches the expected output.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the following notable patterns and techniques:\n- **Assertions**: It uses assertions to compare the actual output against expected values, ensuring that the functionality behaves as intended.\n- **Parameterized Testing**: While not explicitly shown in this single test, the variety of parameters used in `add_cookie` demonstrates a form of parameterized testing, where different configurations are tested to ensure robustness.\n- **Isolation**: The test is isolated from external dependencies, focusing solely on the behavior of the `CookieJar` class, which is a good practice in unit testing to ensure that tests are reliable and repeatable."
    },
    {
      "name": "test_cookie_jar_old_school_cookie_encode",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 351,
      "end_line_number": 367,
      "source_code": "def test_cookie_jar_old_school_cookie_encode():\n    headers = Header()\n    jar = CookieJar(headers)\n    jar[\"foo\"] = \"one\"\n    jar[\"bar\"] = \"two\"\n    jar[\"bar\"][\"domain\"] = \"example.com\"\n    jar[\"bar\"][\"path\"] = \"/something\"\n    jar[\"bar\"][\"secure\"] = True\n    jar[\"bar\"][\"max-age\"] = 999\n    jar[\"bar\"][\"httponly\"] = True\n    jar[\"bar\"][\"samesite\"] = \"strict\"\n\n    encoded = [cookie.encode(\"ascii\") for cookie in jar.cookies]\n    assert encoded == [\n        b\"foo=one; Path=/\",\n        b\"bar=two; Path=/something; Domain=example.com; Max-Age=999; SameSite=Strict; Secure; HttpOnly\",  # noqa\n    ]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert encoded == [b'foo=one; Path=/', b'bar=two; Path=/something; Domain=example.com; Max-Age=999; SameSite=Strict; Secure; HttpOnly']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_cookie_jar_old_school_cookie_encode` test is to verify that the `CookieJar` class correctly encodes cookies into the expected format when various attributes are set. This ensures that the cookie handling functionality adheres to the specified standards for cookie encoding.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that cookies added to the `CookieJar` are encoded properly into a byte string format that includes all relevant attributes such as `Path`, `Domain`, `Max-Age`, `SameSite`, `Secure`, and `HttpOnly`. It ensures that the cookies are formatted correctly according to the HTTP cookie specification.\n\n**Code Being Tested and How It Works**:  \nThe code being tested involves the `CookieJar` class, which is responsible for managing cookies. In the test, two cookies (`foo` and `bar`) are added to the jar with various attributes. The `encode` method of each cookie is called to convert the cookie objects into a byte string representation. The expected output is then compared against the actual encoded output to ensure correctness. The `encode` method leverages Python's string encoding capabilities to produce the final byte string.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the output against expected values, which is a common practice in unit testing. It also utilizes list comprehensions to succinctly encode all cookies in the jar. The test is structured to be clear and straightforward, focusing on a single aspect of functionality, which is a hallmark of effective unit tests. Additionally, the use of constants for expected values helps maintain clarity and reduces the risk of errors in the expected output."
    },
    {
      "name": "test_cookie_jar_delete_cookie_encode",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 370,
      "end_line_number": 380,
      "source_code": "def test_cookie_jar_delete_cookie_encode():\n    headers = Header()\n    jar = CookieJar(headers)\n    jar.delete_cookie(\"foo\")\n    jar.delete_cookie(\"foo\", domain=\"example.com\")\n\n    encoded = [cookie.encode(\"ascii\") for cookie in jar.cookies]\n    assert encoded == [\n        b'foo=\"\"; Path=/; Max-Age=0; Secure',\n        b'foo=\"\"; Path=/; Domain=example.com; Max-Age=0; Secure',\n    ]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert encoded == [b'foo=\"\"; Path=/; Max-Age=0; Secure', b'foo=\"\"; Path=/; Domain=example.com; Max-Age=0; Secure']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_cookie_jar_delete_cookie_encode` is designed to verify the behavior of the `delete_cookie` method in the `CookieJar` class. Specifically, it checks that when a cookie is deleted, it is correctly encoded to reflect its deletion in the cookie jar.\n\n**Specific Functionality or Behavior Verified**:  \nThe test ensures that when a cookie is deleted, it is represented in the cookie jar with an empty value and a `Max-Age` of 0, which indicates to the browser that the cookie should be removed. It verifies that the encoded output of the cookies in the jar matches the expected format for deleted cookies.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `delete_cookie` method of the `CookieJar` class. This method sets the specified cookie's `Max-Age` to 0, effectively marking it for deletion. The test creates a `CookieJar` instance, deletes a cookie named \"foo\" and another with the same name but a specified domain, and then encodes the remaining cookies to check their representation. The expected output is a list of encoded cookies that reflect the deletion.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs direct assertions to compare the actual output of the cookie encoding against the expected output. It uses list comprehension to encode the cookies, which is a concise way to transform the cookie objects into their byte representation. The test also follows a clear structure: setup (creating the `CookieJar` and deleting cookies), execution (encoding the cookies), and verification (asserting the encoded output). This pattern enhances readability and maintainability."
    },
    {
      "name": "test_cookie_jar_delete_nonsecure_cookie",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 383,
      "end_line_number": 391,
      "source_code": "def test_cookie_jar_delete_nonsecure_cookie():\n    headers = Header()\n    jar = CookieJar(headers)\n    jar.delete_cookie(\"foo\", domain=\"example.com\", secure=False)\n\n    encoded = [cookie.encode(\"ascii\") for cookie in jar.cookies]\n    assert encoded == [\n        b'foo=\"\"; Path=/; Domain=example.com; Max-Age=0',\n    ]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert encoded == [b'foo=\"\"; Path=/; Domain=example.com; Max-Age=0']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_cookie_jar_delete_nonsecure_cookie` test is to verify that the `delete_cookie` method of the `CookieJar` class correctly removes a non-secure cookie (i.e., a cookie that is not marked as secure) and encodes the resulting cookie state accurately.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a non-secure cookie named \"foo\" is deleted from the `CookieJar` with the domain set to \"example.com\", the resulting encoded cookies reflect that the cookie has been effectively deleted. The expected output should indicate that the cookie is no longer present, but rather set to an empty value with a `Max-Age` of 0, which instructs the browser to delete it.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `delete_cookie` method of the `CookieJar` class. This method is designed to remove a cookie by setting its `Max-Age` to 0, which is a standard way to signal to the browser that the cookie should be deleted. The test creates a `CookieJar` instance, calls `delete_cookie` with the appropriate parameters, and then checks the state of the cookies in the jar. The expected output is a list containing a single encoded cookie string that indicates the cookie \"foo\" has been deleted for the specified domain.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern, where the actual output (the encoded cookies) is compared against an expected output using an equality assertion. This is a common technique in unit testing to ensure that the code behaves as intended. Additionally, the test uses a clear and descriptive naming convention, which aids in understanding the purpose of the test at a glance. The use of `assert` statements is a fundamental aspect of unit testing in Python, providing a simple way to validate conditions."
    },
    {
      "name": "test_cookie_jar_delete_existing_cookie",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 394,
      "end_line_number": 407,
      "source_code": "def test_cookie_jar_delete_existing_cookie():\n    headers = Header()\n    jar = CookieJar(headers)\n    jar.add_cookie(\n        \"foo\", \"test\", secure=True, domain=\"example.com\", samesite=\"Strict\"\n    )\n    jar.delete_cookie(\"foo\", domain=\"example.com\", secure=True)\n\n    encoded = [cookie.encode(\"ascii\") for cookie in jar.cookies]\n    # deletion cookie contains samesite=Strict as was in original cookie\n    assert encoded == [\n        b'foo=\"\"; Path=/; Domain=example.com; Max-Age=0; '\n        b\"SameSite=Strict; Secure\",\n    ]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert encoded == [b'foo=\"\"; Path=/; Domain=example.com; Max-Age=0; SameSite=Strict; Secure']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_cookie_jar_delete_existing_cookie` is designed to verify the functionality of the `delete_cookie` method in the `CookieJar` class. Specifically, it checks that an existing secure cookie is correctly marked for deletion and that the resulting cookie representation reflects this deletion.\n\n**Specific Functionality or Behavior Verified**:  \nThe test ensures that when a secure cookie is deleted, it is encoded with the appropriate attributes, including `Max-Age=0`, `SameSite=Strict`, and `Secure`. This behavior is crucial for browsers to interpret the cookie as deleted.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `CookieJar` class, which manages cookies. The test first adds a secure cookie named \"foo\" with specific attributes (value \"test\", domain \"example.com\", and `SameSite` set to \"Strict\"). It then calls the `delete_cookie` method to remove this cookie. After deletion, the test encodes the remaining cookies in the jar and asserts that the encoded representation matches the expected output, which indicates that the cookie has been properly marked for deletion.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern, comparing the actual output of the cookie jar after deletion to an expected byte string. This approach ensures that the test is both clear and effective in validating the specific behavior of the `delete_cookie` method. Additionally, the use of comments within the test provides context for the expected behavior, enhancing readability and maintainability."
    },
    {
      "name": "test_cookie_jar_delete_existing_nonsecure_cookie",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 410,
      "end_line_number": 422,
      "source_code": "def test_cookie_jar_delete_existing_nonsecure_cookie():\n    headers = Header()\n    jar = CookieJar(headers)\n    jar.add_cookie(\n        \"foo\", \"test\", secure=False, domain=\"example.com\", samesite=\"Strict\"\n    )\n    jar.delete_cookie(\"foo\", domain=\"example.com\", secure=False)\n\n    encoded = [cookie.encode(\"ascii\") for cookie in jar.cookies]\n    # deletion cookie contains samesite=Strict as was in original cookie\n    assert encoded == [\n        b'foo=\"\"; Path=/; Domain=example.com; Max-Age=0; SameSite=Strict',\n    ]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert encoded == [b'foo=\"\"; Path=/; Domain=example.com; Max-Age=0; SameSite=Strict']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_cookie_jar_delete_existing_nonsecure_cookie` is designed to verify the functionality of deleting a non-secure cookie from a `CookieJar` instance. It ensures that when a non-secure cookie is deleted, it is correctly represented in the cookie jar with the appropriate attributes indicating its deletion.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that after deleting a non-secure cookie named \"foo\", the cookie jar reflects this deletion by encoding the cookie to show it as an expired cookie. The expected output indicates that the cookie has been set with a `Max-Age` of 0, which is the standard way to signal to browsers that the cookie should be deleted.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `delete_cookie` method of the `CookieJar` class. The test first adds a non-secure cookie with specific attributes (including `samesite=\"Strict\"`), then calls the `delete_cookie` method to remove it. After deletion, the test encodes the remaining cookies in the jar to verify that the deleted cookie is represented correctly as an expired cookie with the same attributes it had when it was added.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the expected state of the cookie jar after the deletion operation. It uses a list comprehension to encode the cookies into ASCII format for comparison, which is a common technique in unit tests to ensure that the output matches the expected format. Additionally, the test is structured to be clear and straightforward, focusing solely on the deletion functionality without extraneous complexity."
    },
    {
      "name": "test_cookie_jar_delete_existing_nonsecure_cookie_bad_prefix",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 425,
      "end_line_number": 442,
      "source_code": "def test_cookie_jar_delete_existing_nonsecure_cookie_bad_prefix():\n    headers = Header()\n    jar = CookieJar(headers)\n    jar.add_cookie(\n        \"foo\", \"test\", secure=False, domain=\"example.com\", samesite=\"Strict\"\n    )\n    message = (\n        \"Cannot set host_prefix on a cookie without \"\n        \"path='/', domain=None, and secure=True\"\n    )\n    with pytest.raises(ServerError, match=message):\n        jar.delete_cookie(\n            \"foo\",\n            domain=\"example.com\",\n            secure=False,\n            secure_prefix=True,\n            host_prefix=True,\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_cookie_jar_delete_existing_nonsecure_cookie_bad_prefix` is designed to verify that the `delete_cookie` method of the `CookieJar` class correctly raises a `ServerError` when attempting to delete a non-secure cookie with invalid prefix parameters. Specifically, it checks that the method enforces the rules regarding the use of `host_prefix` and `secure_prefix`.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the `delete_cookie` method does not allow the deletion of a cookie with both `host_prefix` and `secure_prefix` set to `True` when the cookie is not secure. It verifies that the appropriate error message is raised, indicating that certain conditions must be met for using these prefixes.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `delete_cookie` method of the `CookieJar` class. The method checks the parameters provided (like `host_prefix` and `secure_prefix`) against the cookie's properties (such as `secure`, `path`, and `domain`). If the conditions for using these prefixes are not met, it raises a `ServerError` with a specific message. In this case, the test adds a non-secure cookie and then attempts to delete it with invalid prefix parameters, expecting the error to be raised.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that an exception is raised during the execution of the `delete_cookie` method. This pattern is effective for testing error conditions and ensures that the test fails if the expected exception is not raised. Additionally, the use of a specific error message in the `match` argument allows for precise verification that the correct error is raised, enhancing the robustness of the test."
    },
    {
      "name": "test_cookie_jar_old_school_delete_encode",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 445,
      "end_line_number": 453,
      "source_code": "def test_cookie_jar_old_school_delete_encode():\n    headers = Header()\n    jar = CookieJar(headers)\n    del jar[\"foo\"]\n\n    encoded = [cookie.encode(\"ascii\") for cookie in jar.cookies]\n    assert encoded == [\n        b'foo=\"\"; Path=/; Max-Age=0; Secure',\n    ]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert encoded == [b'foo=\"\"; Path=/; Max-Age=0; Secure']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_cookie_jar_old_school_delete_encode` is designed to verify the behavior of the `CookieJar` class when a cookie is deleted using the old-school method of `del jar[\"foo\"]`. It ensures that the deletion of the cookie is correctly reflected in the encoded output of the cookie jar.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a cookie with the key \"foo\" is deleted, the resulting encoded cookies reflect that the cookie has been removed. The expected output should indicate that the cookie is effectively deleted by setting its `Max-Age` to 0, which is a standard way to signal to browsers that the cookie should be removed.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `CookieJar` class, which manages cookies. The deletion is performed by the `__delitem__` method (implicitly called by `del jar[\"foo\"]`), which should remove the specified cookie and prepare it for deletion by setting its attributes accordingly. The `encode` method is then called to convert the remaining cookies into a byte representation, which is checked against the expected output.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern, where the actual output (the encoded cookies) is compared to an expected output using an equality assertion. This is a common unit testing technique that helps ensure that the code behaves as intended. The use of a specific expected byte string for the encoded cookie also highlights the importance of precise output formatting in cookie management."
    },
    {
      "name": "test_bad_cookie_prarms",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 456,
      "end_line_number": 504,
      "source_code": "def test_bad_cookie_prarms():\n    headers = Header()\n    jar = CookieJar(headers)\n\n    with pytest.raises(\n        ServerError,\n        match=(\n            \"Both host_prefix and secure_prefix were requested. \"\n            \"A cookie should have only one prefix.\"\n        ),\n    ):\n        jar.add_cookie(\"foo\", \"bar\", host_prefix=True, secure_prefix=True)\n\n    with pytest.raises(\n        ServerError,\n        match=\"Cannot set host_prefix on a cookie without secure=True\",\n    ):\n        jar.add_cookie(\"foo\", \"bar\", host_prefix=True, secure=False)\n\n    with pytest.raises(\n        ServerError,\n        match=\"Cannot set host_prefix on a cookie unless path='/'\",\n    ):\n        jar.add_cookie(\n            \"foo\", \"bar\", host_prefix=True, secure=True, path=\"/foo\"\n        )\n\n    with pytest.raises(\n        ServerError,\n        match=\"Cannot set host_prefix on a cookie with a defined domain\",\n    ):\n        jar.add_cookie(\n            \"foo\", \"bar\", host_prefix=True, secure=True, domain=\"foo.bar\"\n        )\n\n    with pytest.raises(\n        ServerError,\n        match=\"Cannot set secure_prefix on a cookie without secure=True\",\n    ):\n        jar.add_cookie(\"foo\", \"bar\", secure_prefix=True, secure=False)\n\n    with pytest.raises(\n        ServerError,\n        match=(\n            \"Cannot create a partitioned cookie without \"\n            \"also setting host_prefix=True\"\n        ),\n    ):\n        jar.add_cookie(\"foo\", \"bar\", partitioned=True)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_bad_cookie_prarms` test is to validate the error handling of the `add_cookie` method in the `CookieJar` class when invalid cookie parameters are provided. It ensures that the method raises appropriate `ServerError` exceptions with specific messages when the cookie parameters do not meet the required conditions.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies that the `add_cookie` method correctly enforces rules regarding cookie attributes such as `host_prefix`, `secure_prefix`, `secure`, `path`, and `domain`. It checks that:\n- Both `host_prefix` and `secure_prefix` cannot be set simultaneously.\n- `host_prefix` requires `secure=True`, `path='/'`, and no `domain`.\n- `secure_prefix` also requires `secure=True`.\n- A partitioned cookie must have `host_prefix=True`.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `add_cookie` method of the `CookieJar` class, which is responsible for adding cookies with specific attributes. The method checks the provided parameters against a set of rules and raises a `ServerError` if any of the rules are violated. The test uses the `pytest.raises` context manager to assert that the expected exceptions are raised with the correct messages when invalid parameters are passed.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the following notable patterns:\n- **Exception Testing**: It uses `pytest.raises` to assert that specific exceptions are raised under certain conditions, which is a common practice for testing error handling in unit tests.\n- **Parameterized Testing**: Although not explicitly shown in this test, the structure allows for easy extension to parameterized tests where multiple invalid configurations could be tested in a single test function.\n- **Descriptive Assertions**: Each assertion includes a `match` parameter that specifies the expected error message, ensuring that not only the exception type is correct but also the content of the error message, which aids in debugging."
    },
    {
      "name": "test_cookie_accessors",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 507,
      "end_line_number": 573,
      "source_code": "def test_cookie_accessors(app: Sanic):\n    @app.get(\"/\")\n    async def handler(request: Request):\n        return json(\n            {\n                \"getitem\": {\n                    \"one\": request.cookies[\"one\"],\n                    \"two\": request.cookies[\"two\"],\n                    \"three\": request.cookies[\"three\"],\n                },\n                \"get\": {\n                    \"one\": request.cookies.get(\"one\", \"fallback\"),\n                    \"two\": request.cookies.get(\"two\", \"fallback\"),\n                    \"three\": request.cookies.get(\"three\", \"fallback\"),\n                    \"four\": request.cookies.get(\"four\", \"fallback\"),\n                },\n                \"getlist\": {\n                    \"one\": request.cookies.getlist(\"one\"),\n                    \"two\": request.cookies.getlist(\"two\"),\n                    \"three\": request.cookies.getlist(\"three\"),\n                    \"four\": request.cookies.getlist(\"four\"),\n                    \"five\": request.cookies.getlist(\"five\", [\"fallback\"]),\n                },\n                \"getattr\": {\n                    \"one\": request.cookies.one,\n                    \"two\": request.cookies.two,\n                    \"three\": request.cookies.three,\n                    \"four\": request.cookies.four,\n                },\n            }\n        )\n\n    _, response = app.test_client.get(\n        \"/\",\n        cookies={\n            \"__Host-one\": \"1\",\n            \"__Secure-two\": \"2\",\n            \"three\": \"3\",\n        },\n    )\n\n    assert response.json == {\n        \"getitem\": {\n            \"one\": \"1\",\n            \"two\": \"2\",\n            \"three\": \"3\",\n        },\n        \"get\": {\n            \"one\": \"1\",\n            \"two\": \"2\",\n            \"three\": \"3\",\n            \"four\": \"fallback\",\n        },\n        \"getlist\": {\n            \"one\": [\"1\"],\n            \"two\": [\"2\"],\n            \"three\": [\"3\"],\n            \"four\": [],\n            \"five\": [\"fallback\"],\n        },\n        \"getattr\": {\n            \"one\": \"1\",\n            \"two\": \"2\",\n            \"three\": \"3\",\n            \"four\": \"\",\n        },\n    }",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json == {'getitem': {'one': '1', 'two': '2', 'three': '3'}, 'get': {'one': '1', 'two': '2', 'three': '3', 'four': 'fallback'}, 'getlist': {'one': ['1'], 'two': ['2'], 'three': ['3'], 'four': [], 'five': ['fallback']}, 'getattr': {'one': '1', 'two': '2', 'three': '3', 'four': ''}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "request.cookies.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "request.cookies.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "request.cookies.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "request.cookies.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_cookie_accessors` test is to verify the correct functionality of various cookie access methods in a Sanic web application. It ensures that cookies can be accessed and retrieved correctly using different approaches, such as direct indexing, the `get` method, `getlist`, and attribute access.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the application correctly retrieves cookie values from the request object. It verifies that:\n- Cookies can be accessed directly by their names.\n- The `get` method returns a default value when a cookie is not present.\n- The `getlist` method returns a list of values for cookies that may have multiple entries.\n- Attribute-style access to cookies behaves as expected, returning the correct values or an empty string when cookies are absent.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route handler for the root path (\"/\") of the Sanic application. This handler constructs a JSON response containing:\n- A dictionary of cookie values accessed directly.\n- A dictionary using the `get` method with a fallback for missing cookies.\n- A dictionary using `getlist` to handle cookies that may have multiple values.\n- A dictionary using attribute access to retrieve cookie values.\n\nThe test then simulates a GET request to this route with a set of cookies and asserts that the returned JSON response matches the expected structure and values, confirming that the cookie access methods work as intended.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking and Simulation**: The test uses the Sanic test client to simulate a request to the application, allowing for controlled testing of the handler's response without needing a live server.\n- **Assertions**: The test employs assertions to compare the actual response against the expected output, ensuring that all cookie access methods return the correct values.\n- **Structured Response Verification**: The test checks multiple aspects of the response in a structured manner, validating the behavior of different cookie access methods in one comprehensive test case."
    },
    {
      "name": "test_cookie_accessor_hyphens",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 576,
      "end_line_number": 579,
      "source_code": "def test_cookie_accessor_hyphens():\n    cookies = CookieRequestParameters({\"session-token\": [\"abc123\"]})\n\n    assert cookies.get(\"session-token\") == cookies.session_token",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert cookies.get('session-token') == cookies.session_token"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "cookies.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_cookie_accessor_hyphens` test is to verify that the `CookieRequestParameters` class correctly retrieves cookie values using a key that contains hyphens. This ensures that the implementation can handle cookie names with special characters appropriately.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that the value retrieved using the `get` method of the `cookies` object matches the value accessed through the `session_token` attribute. This confirms that both methods of accessing the cookie yield the same result, thereby validating the internal mapping of cookie names to their values.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `get` method of the `CookieRequestParameters` class, which is designed to return the value of a specified cookie. In this case, the `cookies` object is initialized with a dictionary containing a single cookie named `\"session-token\"` with the value `[\"abc123\"]`. The `get` method attempts to retrieve the value associated with this key, while `cookies.session_token` accesses the same value through an attribute. The test asserts that both retrieval methods return the same value.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern, using the `assert` statement to compare the results of two different access methods. This is a common technique in unit testing to ensure that different interfaces or methods yield consistent results. Additionally, the test is structured to be simple and focused, which is a best practice in unit testing to isolate specific behaviors for verification."
    },
    {
      "name": "test_cookie_passthru",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 582,
      "end_line_number": 598,
      "source_code": "def test_cookie_passthru(app):\n    cookie_jar = None\n\n    @app.route(\"/\")\n    def handler(request):\n        nonlocal cookie_jar\n        response = text(\"OK\")\n        response.add_cookie(\"one\", \"1\", host_prefix=True)\n        response.delete_cookie(\"two\", secure_prefix=True)\n        cookie_jar = response.cookies\n        return response\n\n    _, response = app.test_client.get(\"/\")\n\n    assert cookie_jar.get_cookie(\"two\", secure_prefix=True).max_age == 0\n    assert len(response.cookies) == 1\n    assert response.cookies[\"__Host-one\"] == \"1\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert cookie_jar.get_cookie('two', secure_prefix=True).max_age == 0",
        "assert len(response.cookies) == 1",
        "assert response.cookies['__Host-one'] == '1'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "cookie_jar.get_cookie",
          "body": "@app.get('/cookie')\ndef get_cookie(request):\n    response = text(\"There's a cookie up in this response\")\n    response.cookies['test'] = 'Cookie1'\n    response.cookies['test']['httponly'] = True\n    response.cookies['c2'] = 'Cookie2'\n    response.cookies['c2']['httponly'] = False\n    return response"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_cookie_passthru` function is designed to verify the behavior of cookie handling in a Sanic web application. Specifically, it tests the ability to add and delete cookies in the response and checks the correct behavior of cookie attributes such as `max_age`.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that:\n1. A cookie named \"one\" is successfully added to the response with the expected value.\n2. A cookie named \"two\" is deleted, and its `max_age` is confirmed to be `0`, indicating it is no longer valid.\n3. The response contains the correct number of cookies, ensuring that the cookie management logic is functioning as intended.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route handler for the root path (\"/\") of the application. Within this handler:\n- A cookie \"one\" is added with the value \"1\" and a host prefix.\n- A cookie \"two\" is deleted with a secure prefix.\nThe `cookie_jar` variable captures the cookies from the response. The test then makes a GET request to the root path and asserts the expected conditions on the cookies.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Nonlocal Variable**: The use of `nonlocal` allows the inner function to modify the `cookie_jar` variable defined in the outer scope, which is essential for capturing the response cookies.\n- **Assertions**: The test employs assertions to validate the state of the cookies after the request, ensuring that the expected behavior aligns with the actual behavior of the application.\n- **Route Handling**: The test demonstrates how to define a route and handle requests within the context of a Sanic application, showcasing the framework's capabilities for managing HTTP responses and cookies."
    },
    {
      "name": "test_string_compat",
      "module": "test_constants",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_constants.py",
      "line_number": 9,
      "end_line_number": 12,
      "source_code": "def test_string_compat(enum):\n    for key in enum.__members__.keys():\n        assert key.upper() == getattr(enum, key).upper()\n        assert key.lower() == getattr(enum, key).lower()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('enum', (HTTPMethod, Server, Mode))"
      ],
      "arguments": [
        "enum"
      ],
      "imports": [
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.application.constants.Mode",
        "sanic.application.constants.Server",
        "sanic.application.constants.ServerStage",
        "sanic.constants.HTTP_METHODS",
        "sanic.constants.HTTPMethod"
      ],
      "fixtures": [],
      "assertions": [
        "assert key.upper() == getattr(enum, key).upper()",
        "assert key.lower() == getattr(enum, key).lower()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_string_compat` function is designed to verify the compatibility of string representations of enum members in a custom enumeration class (`StrEnum`). It ensures that the string keys of the enum can be accurately represented in both uppercase and lowercase formats.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that for each member of the provided enum, the uppercase and lowercase transformations of the member's name (key) match the uppercase and lowercase transformations of the member's value. This ensures that the enum's string representation behaves consistently with its defined keys.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `StrEnum` class, which extends both `str` and `Enum`. The `StrEnum` class overrides the equality operator and the string representation method to ensure that enum members can be compared and represented as strings in a case-insensitive manner. The test iterates over the enum's members, using `getattr` to retrieve the value associated with each key, and asserts that the transformations (upper and lower) yield consistent results.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a parameterized approach by accepting an `enum` argument, allowing it to be reused for different enum classes. It uses assertions to validate conditions, which is a common practice in unit testing to ensure that expected outcomes are met. The test does not rely on any external dependencies or side effects, making it a pure unit test focused solely on the behavior of the enum class."
    },
    {
      "name": "test_http_methods",
      "module": "test_constants",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_constants.py",
      "line_number": 15,
      "end_line_number": 17,
      "source_code": "def test_http_methods():\n    for value in HTTPMethod.__members__.values():\n        assert value in HTTP_METHODS",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.application.constants.Mode",
        "sanic.application.constants.Server",
        "sanic.application.constants.ServerStage",
        "sanic.constants.HTTP_METHODS",
        "sanic.constants.HTTPMethod"
      ],
      "fixtures": [],
      "assertions": [
        "assert value in HTTP_METHODS"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_http_methods` function is designed to verify that all HTTP methods defined in the `HTTPMethod` enumeration are present in the `HTTP_METHODS` collection. This ensures that the set of HTTP methods recognized by the application is consistent and complete.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks for the presence of each HTTP method (like GET, POST, etc.) defined in the `HTTPMethod` enum within the `HTTP_METHODS` constant. This is crucial for maintaining the integrity of the HTTP methods supported by the application, ensuring that no methods are missing or incorrectly defined.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `HTTPMethod` enum, which contains various HTTP methods as its members. The `HTTP_METHODS` constant is expected to be a collection (like a list or set) that includes all valid HTTP methods. The test iterates over the values of `HTTPMethod.__members__`, asserting that each method is included in `HTTP_METHODS`. If any method is missing, the assertion will fail, indicating a potential issue in the application's handling of HTTP methods.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a simple iteration and assertion pattern, which is a common technique in unit testing. It uses the `assert` statement to validate conditions, which is straightforward and effective for checking membership in collections. The absence of a docstring in the test function is a minor oversight, as documenting the purpose and expected behavior of the test would enhance clarity and maintainability."
    },
    {
      "name": "test_server_stage",
      "module": "test_constants",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_constants.py",
      "line_number": 20,
      "end_line_number": 21,
      "source_code": "def test_server_stage():\n    assert ServerStage.SERVING > ServerStage.PARTIAL > ServerStage.STOPPED",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.application.constants.Mode",
        "sanic.application.constants.Server",
        "sanic.application.constants.ServerStage",
        "sanic.constants.HTTP_METHODS",
        "sanic.constants.HTTPMethod"
      ],
      "fixtures": [],
      "assertions": [
        "assert ServerStage.SERVING > ServerStage.PARTIAL > ServerStage.STOPPED"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_server_stage` unit test is designed to verify the ordering of the `ServerStage` enumeration values, ensuring that the stages are correctly prioritized in the expected sequence: `SERVING` > `PARTIAL` > `STOPPED`.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks the comparative values of the `ServerStage` enumeration. It asserts that the `SERVING` stage is greater than the `PARTIAL` stage, which in turn is greater than the `STOPPED` stage. This is crucial for the correct functioning of the server's state management, as it relies on these values to determine the server's operational status.\n\n**Code Being Tested and How It Works**:  \nThe test references the `ServerStage` enumeration, which is likely defined elsewhere in the codebase. The comparison `ServerStage.SERVING > ServerStage.PARTIAL > ServerStage.STOPPED` implies that these enumeration values are assigned integer values (or similar comparable types) that reflect their priority. The test does not directly invoke any methods or properties but relies on the correct implementation of the `ServerStage` enumeration.\n\n**Notable Testing Patterns or Techniques Used**:  \nThis test employs a simple assertion pattern to validate the expected behavior of an enumeration. It uses chained comparisons, which is a Python feature that allows for concise and readable assertions. The absence of a docstring and the simplicity of the test indicate that it is a straightforward check, focusing solely on the integrity of the `ServerStage` values without additional setup or teardown logic."
    },
    {
      "name": "test_use_in_routes",
      "module": "test_constants",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_constants.py",
      "line_number": 24,
      "end_line_number": 35,
      "source_code": "def test_use_in_routes(app: Sanic):\n    @app.route(\"/\", methods=[HTTPMethod.GET, HTTPMethod.POST])\n    def handler(_):\n        return text(\"It works\")\n\n    _, response = app.test_client.get(\"/\")\n    assert response.status == 200\n    assert response.text == \"It works\"\n\n    _, response = app.test_client.post(\"/\")\n    assert response.status == 200\n    assert response.text == \"It works\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.application.constants.Mode",
        "sanic.application.constants.Server",
        "sanic.application.constants.ServerStage",
        "sanic.constants.HTTP_METHODS",
        "sanic.constants.HTTPMethod"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'It works'",
        "assert response.status == 200",
        "assert response.text == 'It works'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_use_in_routes` function is designed to verify that the Sanic application correctly handles HTTP GET and POST requests to the root route (\"/\"). It ensures that both methods return the expected response and status code.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when a GET or POST request is made to the root route, the application responds with a status code of 200 and the text \"It works\". This confirms that the route is properly set up to handle these methods and return the correct output.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the route handler defined within the `test_use_in_routes` function. The handler is registered to respond to both GET and POST requests. The `app.test_client.get(\"/\")` and `app.test_client.post(\"/\")` methods simulate these requests, and the assertions check the response status and content. The handler returns a simple text response, which is what the test expects.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Route Testing**: The test directly interacts with the application's routing mechanism by defining a route within the test function, allowing for isolated testing of route behavior.\n- **Assertions**: The use of assertions to validate the response status and content is a common practice in unit testing, ensuring that the application behaves as expected.\n- **HTTP Method Verification**: By testing both GET and POST methods, the test ensures that the application can handle multiple HTTP methods for the same route, which is a critical aspect of RESTful API design."
    },
    {
      "name": "test_bp",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 20,
      "end_line_number": 30,
      "source_code": "def test_bp(app: Sanic):\n    bp = Blueprint(\"test_text\")\n\n    @bp.route(\"/\")\n    def handler(request):\n        return text(\"Hello\")\n\n    app.blueprint(bp)\n    request, response = app.test_client.get(\"/\")\n\n    assert response.text == \"Hello\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'Hello'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_bp` function is designed to verify that a Sanic application can correctly handle a simple GET request routed through a blueprint. It ensures that the application responds with the expected text when accessing the root endpoint defined in the blueprint.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a GET request is made to the root URL (\"/\") of the blueprint, the response text is \"Hello\". This confirms that the routing and response handling for the defined endpoint are functioning as intended.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the creation of a `Blueprint` instance named \"test_text\" and the definition of a route (\"/\") that returns the text \"Hello\". The `app.blueprint(bp)` line registers the blueprint with the Sanic application. The test then simulates a GET request to the root URL using `app.test_client.get(\"/\")`, capturing the request and response. The assertion `assert response.text == \"Hello\"` checks that the response matches the expected output.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of a blueprint to encapsulate route definitions, which is a common pattern in web frameworks to organize code. It also utilizes the Sanic test client to simulate HTTP requests, allowing for straightforward verification of response behavior. The use of assertions to validate the response is a standard practice in unit testing, ensuring that the application behaves as expected under defined conditions."
    },
    {
      "name": "test_bp_app_access",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 33,
      "end_line_number": 44,
      "source_code": "def test_bp_app_access(app: Sanic):\n    bp = Blueprint(\"test\")\n\n    with pytest.raises(\n        SanicException,\n        match=\"<Blueprint test> has not yet been registered to an app\",\n    ):\n        bp.apps\n\n    app.blueprint(bp)\n\n    assert app in bp.apps",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert app in bp.apps"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_bp_app_access` test is to verify the behavior of a `Blueprint` instance in the Sanic framework when it has not yet been registered to an application. It ensures that attempting to access the `apps` attribute of a `Blueprint` that is not associated with any `Sanic` app raises the appropriate exception.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that a `SanicException` is raised with the correct message when trying to access the `apps` attribute of a `Blueprint` that has not been registered to any `Sanic` application. It also verifies that once the `Blueprint` is registered to the `Sanic` app, the app is correctly added to the `Blueprint`'s `apps` list.\n\n**Code Being Tested and How It Works**:  \nThe code being tested involves the `Blueprint` class from the Sanic framework. Initially, a `Blueprint` instance is created without being registered to any app. The test attempts to access the `apps` attribute, which should raise a `SanicException` with a specific message indicating that the `Blueprint` is not registered. After registering the `Blueprint` to the `Sanic` app using `app.blueprint(bp)`, the test asserts that the app is now included in the `bp.apps` list, confirming successful registration.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that an exception is raised, which is a common pattern in unit testing for verifying error conditions. Additionally, it uses assertions to confirm the expected state of the `Blueprint` after registration, ensuring that the test not only checks for exceptions but also validates the correct behavior of the code under test. This combination of exception testing and state verification is effective for ensuring robust functionality in the framework."
    },
    {
      "name": "test_versioned_routes_get",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 67,
      "end_line_number": 87,
      "source_code": "def test_versioned_routes_get(app, method):\n    bp = Blueprint(\"test_text\")\n\n    method = method.lower()\n\n    func = getattr(bp, method)\n    if callable(func):\n\n        @func(f\"/{method}\", version=1)\n        def handler(request):\n            return text(\"OK\")\n\n    else:\n        raise Exception(f\"{func} is not callable\")\n\n    app.blueprint(bp)\n\n    client_method = getattr(app.test_client, method)\n\n    request, response = client_method(f\"/v1/{method}\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('method', HTTP_METHODS)"
      ],
      "arguments": [
        "app",
        "method"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_versioned_routes_get` function is designed to verify that a Sanic application correctly handles GET requests to versioned routes. Specifically, it checks that a route defined for a specific HTTP method (GET, POST, etc.) responds with a 200 OK status when accessed.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a route is registered with a specific version (in this case, version 1), a GET request to that route returns a successful response (HTTP status 200). It also validates that the method used to register the route is callable and correctly handles the request.\n\n**Code Being Tested and How It Works**:  \nThe test creates a new `Blueprint` instance and dynamically assigns a route handler based on the provided `method` argument (which is expected to be a string representing an HTTP method). The handler simply returns a text response \"OK\". The blueprint is then registered with the application, and a test client is used to send a GET request to the versioned route (e.g., `/v1/get`). The response is asserted to ensure that the status code is 200, indicating that the route is functioning as expected.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Dynamic Route Registration**: The test uses `getattr` to dynamically assign the HTTP method to the handler, allowing for flexible testing of different methods.\n- **Blueprints**: It leverages Sanic's blueprint feature to modularize route definitions, which is a common practice in web applications for better organization.\n- **Client Testing**: The use of `app.test_client` allows for simulating HTTP requests to the application, making it possible to test the behavior of the application as it would be used in a real-world scenario.\n- **Assertions**: The test employs assertions to validate the expected outcome, ensuring that the application behaves correctly under the specified conditions."
    },
    {
      "name": "test_bp_strict_slash",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 90,
      "end_line_number": 114,
      "source_code": "def test_bp_strict_slash(app: Sanic):\n    bp = Blueprint(\"test_text\")\n\n    @bp.get(\"/get\", strict_slashes=True)\n    def get_handler(request):\n        return text(\"OK\")\n\n    @bp.post(\"/post/\", strict_slashes=True)\n    def post_handler(request):\n        return text(\"OK\")\n\n    app.blueprint(bp)\n\n    request, response = app.test_client.get(\"/get\")\n    assert response.text == \"OK\"\n    assert response.json is None\n\n    request, response = app.test_client.get(\"/get/\")\n    assert response.status == 404\n\n    request, response = app.test_client.post(\"/post/\")\n    assert response.text == \"OK\"\n\n    request, response = app.test_client.post(\"/post\")\n    assert response.status == 404",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert response.json is None",
        "assert response.status == 404",
        "assert response.text == 'OK'",
        "assert response.status == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "bp.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_bp_strict_slash` function is designed to verify the behavior of route handling in a Sanic application when using strict slashes in URL paths. It ensures that the application correctly distinguishes between routes with and without trailing slashes, which is crucial for maintaining consistent API behavior.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. A GET request to `/get` returns a successful response with the text \"OK\".\n2. A GET request to `/get/` results in a 404 Not Found error, demonstrating that the route is strictly defined without a trailing slash.\n3. A POST request to `/post/` returns a successful response with the text \"OK\".\n4. A POST request to `/post` results in a 404 Not Found error, again confirming strict adherence to the defined route.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Sanic application with a blueprint containing two routes:\n- A GET route at `/get` with `strict_slashes=True`.\n- A POST route at `/post/` with `strict_slashes=True`.\n\nThe `app.test_client` is used to simulate HTTP requests to these routes. The assertions check the responses against expected outcomes, validating that the application behaves as intended when strict slashes are enforced.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Blueprints**: The use of blueprints allows for modular route definitions, making it easier to manage and test routes in isolation.\n- **Assertions**: The test employs assertions to validate the response content and status codes, ensuring that the application behaves correctly under different request scenarios.\n- **HTTP Method Testing**: The test distinguishes between GET and POST requests, verifying that each method is handled appropriately according to the defined routes."
    },
    {
      "name": "test_bp_strict_slash_default_value",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 117,
      "end_line_number": 134,
      "source_code": "def test_bp_strict_slash_default_value(app: Sanic):\n    bp = Blueprint(\"test_text\", strict_slashes=True)\n\n    @bp.get(\"/get\")\n    def get_handler(request):\n        return text(\"OK\")\n\n    @bp.post(\"/post/\")\n    def post_handler(request):\n        return text(\"OK\")\n\n    app.blueprint(bp)\n\n    request, response = app.test_client.get(\"/get/\")\n    assert response.status == 404\n\n    request, response = app.test_client.post(\"/post\")\n    assert response.status == 404",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 404",
        "assert response.status == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "bp.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_bp_strict_slash_default_value` is designed to verify the behavior of a Sanic blueprint when the `strict_slashes` option is set to `True`. Specifically, it checks that routes defined with a trailing slash are not accessible without the trailing slash, resulting in a 404 Not Found response.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a blueprint is created with `strict_slashes=True`, the routes defined within that blueprint enforce strict matching of the URL paths. It verifies that a GET request to `/get/` and a POST request to `/post` return a 404 status code, indicating that the routes are not found when accessed without the expected trailing slashes.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `bp.get` and `bp.post` methods, which define the routes for handling GET and POST requests, respectively. The blueprint `bp` is registered with the Sanic app, and the test client is used to simulate requests to the defined routes. The expected behavior is that the routes will only respond correctly when the URL matches the defined patterns exactly, including the trailing slashes.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the response status codes, which is a common practice in unit testing to ensure that the application behaves as expected. Additionally, it utilizes the Sanic test client to simulate HTTP requests, allowing for isolated testing of route behavior without needing to run a full server. The test also demonstrates the use of blueprints in Sanic, showcasing how they can encapsulate route definitions and their configurations."
    },
    {
      "name": "test_bp_strict_slash_without_passing_default_value",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 137,
      "end_line_number": 154,
      "source_code": "def test_bp_strict_slash_without_passing_default_value(app: Sanic):\n    bp = Blueprint(\"test_text\")\n\n    @bp.get(\"/get\")\n    def get_handler(request):\n        return text(\"OK\")\n\n    @bp.post(\"/post/\")\n    def post_handler(request):\n        return text(\"OK\")\n\n    app.blueprint(bp)\n\n    request, response = app.test_client.get(\"/get/\")\n    assert response.text == \"OK\"\n\n    request, response = app.test_client.post(\"/post\")\n    assert response.text == \"OK\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert response.text == 'OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "bp.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_bp_strict_slash_without_passing_default_value` is designed to verify the behavior of a Sanic blueprint when handling HTTP GET and POST requests without enforcing strict slashes. It ensures that the routes defined in the blueprint respond correctly regardless of the trailing slashes in the URL.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the GET request to `/get/` and the POST request to `/post` return the expected response of \"OK\". It confirms that the absence of a strict slash enforcement allows both routes to be accessible with and without trailing slashes.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `bp.get` and `bp.post` methods, which define the routes for handling GET and POST requests, respectively. The `app.test_client.get` and `app.test_client.post` methods simulate client requests to these routes. The blueprint is registered with the Sanic app, and the test client is used to send requests to the defined endpoints, checking the responses against the expected output.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the Arrange-Act-Assert pattern:\n- **Arrange**: A blueprint is created and routes are defined.\n- **Act**: The test client sends requests to the defined routes.\n- **Assert**: The responses are checked to ensure they match the expected results.  \nAdditionally, the test uses assertions to validate the response content, which is a common practice in unit testing to ensure that the application behaves as intended."
    },
    {
      "name": "test_bp_strict_slash_default_value_can_be_overwritten",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 157,
      "end_line_number": 174,
      "source_code": "def test_bp_strict_slash_default_value_can_be_overwritten(app: Sanic):\n    bp = Blueprint(\"test_text\", strict_slashes=True)\n\n    @bp.get(\"/get\", strict_slashes=False)\n    def get_handler(request):\n        return text(\"OK\")\n\n    @bp.post(\"/post/\", strict_slashes=False)\n    def post_handler(request):\n        return text(\"OK\")\n\n    app.blueprint(bp)\n\n    request, response = app.test_client.get(\"/get/\")\n    assert response.text == \"OK\"\n\n    request, response = app.test_client.post(\"/post\")\n    assert response.text == \"OK\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert response.text == 'OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "bp.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_bp_strict_slash_default_value_can_be_overwritten` verifies that the Sanic framework allows the default behavior of strict slashes in route definitions to be overridden at the individual route level. This ensures that developers can customize the behavior of their routes as needed.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that when a blueprint is created with `strict_slashes=True`, individual routes can still be defined with `strict_slashes=False`. It confirms that requests to the defined routes respond correctly regardless of the strict slash setting.\n\n**Code Being Tested and How It Works**:  \nThe test creates a `Blueprint` instance with `strict_slashes=True` and defines two routes (`/get` and `/post`) with `strict_slashes=False`. The test then registers this blueprint with the Sanic application and makes GET and POST requests to the respective endpoints. The expected response for both requests is \"OK\", which is asserted to ensure the routes are functioning as intended.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the Arrange-Act-Assert pattern:\n- **Arrange**: Set up the blueprint and define the routes.\n- **Act**: Make requests to the defined routes using the test client.\n- **Assert**: Verify that the responses match the expected output.  \nAdditionally, the test uses assertions to validate the response content, ensuring that the application behaves correctly under the specified conditions."
    },
    {
      "name": "test_bp_with_url_prefix",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 177,
      "end_line_number": 187,
      "source_code": "def test_bp_with_url_prefix(app: Sanic):\n    bp = Blueprint(\"test_text\", url_prefix=\"/test1\")\n\n    @bp.route(\"/\")\n    def handler(request):\n        return text(\"Hello\")\n\n    app.blueprint(bp)\n    request, response = app.test_client.get(\"/test1/\")\n\n    assert response.text == \"Hello\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'Hello'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_bp_with_url_prefix` test verifies that a Sanic application correctly handles requests to a route defined within a blueprint that has a URL prefix. It ensures that the route is accessible and returns the expected response when accessed via the prefixed URL.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a GET request is made to the URL `/test1/`, the application responds with the text \"Hello\". This confirms that the blueprint's URL prefix is functioning as intended and that the route handler is correctly set up to return the expected response.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves creating a `Blueprint` instance with a URL prefix of `/test1`. A route is defined within this blueprint that responds to GET requests at the root path (`/`) of the blueprint. The `app.blueprint(bp)` line registers the blueprint with the Sanic application. The test then simulates a GET request to `/test1/` using `app.test_client.get`, and it checks that the response text matches \"Hello\". The relevant code being tested is the route handler defined in the blueprint.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of a blueprint to encapsulate route definitions, which is a common pattern in web frameworks to organize code. It also utilizes the Sanic test client to simulate HTTP requests, allowing for straightforward verification of the application's behavior without needing to run a live server. The use of assertions to compare the actual response with the expected output is a standard practice in unit testing to validate functionality."
    },
    {
      "name": "test_several_bp_with_url_prefix",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 190,
      "end_line_number": 208,
      "source_code": "def test_several_bp_with_url_prefix(app: Sanic):\n    bp = Blueprint(\"test_text\", url_prefix=\"/test1\")\n    bp2 = Blueprint(\"test_text2\", url_prefix=\"/test2\")\n\n    @bp.route(\"/\")\n    def handler(request):\n        return text(\"Hello\")\n\n    @bp2.route(\"/\")\n    def handler2(request):\n        return text(\"Hello2\")\n\n    app.blueprint(bp)\n    app.blueprint(bp2)\n    request, response = app.test_client.get(\"/test1/\")\n    assert response.text == \"Hello\"\n\n    request, response = app.test_client.get(\"/test2/\")\n    assert response.text == \"Hello2\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'Hello'",
        "assert response.text == 'Hello2'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_several_bp_with_url_prefix` test verifies that multiple blueprints can be registered with distinct URL prefixes in a Sanic application, and that requests to these prefixes return the expected responses.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when two blueprints (`bp` and `bp2`) are registered with the application, each handling requests at their respective URL prefixes (`/test1/` and `/test2/`), the correct response is returned for each route. Specifically, it ensures that a GET request to `/test1/` returns \"Hello\" and a GET request to `/test2/` returns \"Hello2\".\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the Sanic application and its ability to handle requests routed through blueprints. The blueprints are defined with specific URL prefixes and associated route handlers. The `app.test_client.get` method simulates GET requests to the defined routes, and the responses are asserted against expected values. The `Blueprint` class is used to encapsulate route definitions and their associated handlers, allowing for modular route management.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Blueprints**: The use of blueprints allows for organized route management and modularity in the application structure.\n- **Assertions**: The test employs assertions to validate that the responses from the application match the expected output, ensuring that the routing logic is functioning correctly.\n- **Test Client**: The `app.test_client` is utilized to simulate HTTP requests, which is a common practice in testing web applications to verify endpoint behavior without needing to run a live server."
    },
    {
      "name": "test_bp_with_host",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 211,
      "end_line_number": 230,
      "source_code": "def test_bp_with_host(app: Sanic):\n    bp = Blueprint(\"test_bp_host\", url_prefix=\"/test1\", host=\"example.com\")\n\n    @bp.route(\"/\")\n    def handler1(request):\n        return text(\"Hello\")\n\n    @bp.route(\"/\", host=\"sub.example.com\")\n    def handler2(request):\n        return text(\"Hello subdomain!\")\n\n    app.blueprint(bp)\n    headers = {\"Host\": \"example.com\"}\n\n    request, response = app.test_client.get(\"/test1/\", headers=headers)\n    assert response.text == \"Hello\"\n\n    headers = {\"Host\": \"sub.example.com\"}\n    request, response = app.test_client.get(\"/test1/\", headers=headers)\n    assert response.body == b\"Hello subdomain!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'Hello'",
        "assert response.body == b'Hello subdomain!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_bp_with_host` function is designed to verify the behavior of Sanic blueprints when handling requests with different host headers. It ensures that the correct route handler is invoked based on the specified host in the request headers.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that:\n1. A request to the main host (`example.com`) returns the expected response from `handler1`.\n2. A request to a subdomain (`sub.example.com`) correctly routes to `handler2`, returning a different response.\n\n**Code Being Tested and How It Works**:  \nThe test creates a Sanic `Blueprint` with two route handlers:\n- `handler1` responds to requests at the root path (`/`) when the host is `example.com`.\n- `handler2` responds to requests at the same path (`/`) but only when the host is `sub.example.com`.\n\nThe test then simulates HTTP GET requests to the `/test1/` endpoint with different `Host` headers using the `app.test_client.get` method. It asserts that the responses match the expected outputs for both handlers.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Blueprint Testing**: The test leverages Sanic's blueprint feature to organize routes and their handlers, allowing for modular code structure.\n- **Header Manipulation**: It demonstrates how to manipulate HTTP headers in tests to simulate different request scenarios.\n- **Assertions**: The use of assertions (`assert response.text == \"Hello\"` and `assert response.body == b\"Hello subdomain!\"`) to validate the correctness of the responses is a standard practice in unit testing, ensuring that the application behaves as expected under different conditions."
    },
    {
      "name": "test_several_bp_with_host",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 233,
      "end_line_number": 274,
      "source_code": "def test_several_bp_with_host(app: Sanic):\n    bp = Blueprint(\n        \"test_text\",\n        url_prefix=\"/test\",\n        host=\"example.com\",\n        strict_slashes=True,\n    )\n    bp2 = Blueprint(\n        \"test_text2\",\n        url_prefix=\"/test\",\n        host=\"sub.example.com\",\n        strict_slashes=True,\n    )\n\n    @bp.route(\"/\")\n    def handler(request):\n        return text(\"Hello\")\n\n    @bp2.route(\"/\")\n    def handler1(request):\n        return text(\"Hello2\")\n\n    @bp2.route(\"/other/\")\n    def handler2(request):\n        return text(\"Hello3\")\n\n    app.blueprint(bp)\n    app.blueprint(bp2)\n\n    assert bp.host == \"example.com\"\n    headers = {\"Host\": \"example.com\"}\n    request, response = app.test_client.get(\"/test/\", headers=headers)\n\n    assert response.text == \"Hello\"\n\n    assert bp2.host == \"sub.example.com\"\n    headers = {\"Host\": \"sub.example.com\"}\n    request, response = app.test_client.get(\"/test/\", headers=headers)\n\n    assert response.text == \"Hello2\"\n    request, response = app.test_client.get(\"/test/other/\", headers=headers)\n    assert response.text == \"Hello3\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert bp.host == 'example.com'",
        "assert response.text == 'Hello'",
        "assert bp2.host == 'sub.example.com'",
        "assert response.text == 'Hello2'",
        "assert response.text == 'Hello3'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_several_bp_with_host` function is designed to verify the behavior of multiple blueprints in a Sanic application when they are registered with specific host headers. It ensures that the correct handler is invoked based on the host specified in the request headers.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. The correct response is returned when accessing routes defined in different blueprints based on the `Host` header.\n2. Each blueprint correctly associates with its designated host, ensuring that requests to the same URL path but different hosts yield the expected responses.\n\n**Code Being Tested and How It Works**:  \nThe test creates two blueprints (`bp` and `bp2`), each with a unique host and URL prefix. The blueprints define routes that return different responses:\n- `bp` responds with \"Hello\" when accessed at `/test/` with the host `example.com`.\n- `bp2` responds with \"Hello2\" at `/test/` with the host `sub.example.com` and \"Hello3\" at `/test/other/`.\n\nThe test then registers both blueprints with the Sanic application and makes GET requests to the defined routes, asserting that the responses match the expected output based on the host header.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Blueprints**: The use of blueprints allows for modular route definitions, which can be tested independently.\n- **Host Header Testing**: The test leverages HTTP headers to simulate requests to different hosts, validating the application's routing logic based on host-specific configurations.\n- **Assertions**: The test employs assertions to verify that the expected responses are returned, ensuring that the application behaves correctly under the specified conditions."
    },
    {
      "name": "test_bp_with_host_list",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 277,
      "end_line_number": 308,
      "source_code": "def test_bp_with_host_list(app: Sanic):\n    bp = Blueprint(\n        \"test_bp_host\",\n        url_prefix=\"/test1\",\n        host=[\"example.com\", \"sub.example.com\"],\n    )\n\n    @bp.route(\"/\")\n    def handler1(request):\n        return text(\"Hello\")\n\n    @bp.route(\"/\", host=[\"sub1.example.com\"])\n    def handler2(request):\n        return text(\"Hello subdomain!\")\n\n    app.blueprint(bp)\n    headers = {\"Host\": \"example.com\"}\n    request, response = app.test_client.get(\"/test1/\", headers=headers)\n    assert response.text == \"Hello\"\n\n    headers = {\"Host\": \"sub.example.com\"}\n    request, response = app.test_client.get(\"/test1/\", headers=headers)\n    assert response.text == \"Hello\"\n\n    headers = {\"Host\": \"sub1.example.com\"}\n    request, response = app.test_client.get(\"/test1/\", headers=headers)\n\n    assert response.text == \"Hello subdomain!\"\n\n    route_names = [r.name for r in app.router.routes]\n    assert \"test_bp_with_host_list.test_bp_host.handler1\" in route_names\n    assert \"test_bp_with_host_list.test_bp_host.handler2\" in route_names",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'Hello'",
        "assert response.text == 'Hello'",
        "assert response.text == 'Hello subdomain!'",
        "assert 'test_bp_with_host_list.test_bp_host.handler1' in route_names",
        "assert 'test_bp_with_host_list.test_bp_host.handler2' in route_names"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_bp_with_host_list` test verifies that a Sanic application correctly routes requests to different handlers based on the `Host` header. It ensures that the application can handle requests for specific hosts and subdomains as defined in the blueprint.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. Requests to the main handler (`handler1`) return the expected response when the `Host` header matches `example.com` or `sub.example.com`.\n2. Requests to a subdomain handler (`handler2`) return the expected response when the `Host` header matches `sub1.example.com`.\n3. The correct route names are registered in the application\u2019s router.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves a Sanic application with a blueprint that defines two routes:\n- `handler1` responds to requests at the root path (`/`) for `example.com` and `sub.example.com`.\n- `handler2` responds to requests at the same path but only for `sub1.example.com`. \n\nThe test simulates HTTP GET requests to these routes with different `Host` headers and asserts that the responses match the expected text. Additionally, it checks that the route names for both handlers are correctly registered in the application's router.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Blueprints**: The test utilizes Sanic's blueprint feature to encapsulate route definitions, allowing for modular application design.\n- **Parameterized Requests**: The test simulates requests with different headers to validate the routing logic based on the `Host` header.\n- **Assertions**: The test employs assertions to verify both the response content and the presence of route names, ensuring comprehensive coverage of the routing behavior."
    },
    {
      "name": "test_several_bp_with_host_list",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 311,
      "end_line_number": 360,
      "source_code": "def test_several_bp_with_host_list(app: Sanic):\n    bp = Blueprint(\n        \"test_text\",\n        url_prefix=\"/test\",\n        host=[\"example.com\", \"sub.example.com\"],\n    )\n    bp2 = Blueprint(\n        \"test_text2\",\n        url_prefix=\"/test\",\n        host=[\"sub1.example.com\", \"sub2.example.com\"],\n    )\n\n    @bp.route(\"/\")\n    def handler(request):\n        return text(\"Hello\")\n\n    @bp2.route(\"/\")\n    def handler1(request):\n        return text(\"Hello2\")\n\n    @bp2.route(\"/other/\")\n    def handler2(request):\n        return text(\"Hello3\")\n\n    app.blueprint(bp)\n    app.blueprint(bp2)\n\n    assert bp.host == [\"example.com\", \"sub.example.com\"]\n    headers = {\"Host\": \"example.com\"}\n    request, response = app.test_client.get(\"/test/\", headers=headers)\n    assert response.text == \"Hello\"\n\n    assert bp.host == [\"example.com\", \"sub.example.com\"]\n    headers = {\"Host\": \"sub.example.com\"}\n    request, response = app.test_client.get(\"/test/\", headers=headers)\n    assert response.text == \"Hello\"\n\n    assert bp2.host == [\"sub1.example.com\", \"sub2.example.com\"]\n    headers = {\"Host\": \"sub1.example.com\"}\n    request, response = app.test_client.get(\"/test/\", headers=headers)\n    assert response.text == \"Hello2\"\n    request, response = app.test_client.get(\"/test/other/\", headers=headers)\n    assert response.text == \"Hello3\"\n\n    assert bp2.host == [\"sub1.example.com\", \"sub2.example.com\"]\n    headers = {\"Host\": \"sub2.example.com\"}\n    request, response = app.test_client.get(\"/test/\", headers=headers)\n    assert response.text == \"Hello2\"\n    request, response = app.test_client.get(\"/test/other/\", headers=headers)\n    assert response.text == \"Hello3\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert bp.host == ['example.com', 'sub.example.com']",
        "assert response.text == 'Hello'",
        "assert bp.host == ['example.com', 'sub.example.com']",
        "assert response.text == 'Hello'",
        "assert bp2.host == ['sub1.example.com', 'sub2.example.com']",
        "assert response.text == 'Hello2'",
        "assert response.text == 'Hello3'",
        "assert bp2.host == ['sub1.example.com', 'sub2.example.com']",
        "assert response.text == 'Hello2'",
        "assert response.text == 'Hello3'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_several_bp_with_host_list` test is to verify that multiple blueprints in a Sanic application can correctly handle requests based on the specified host headers. It ensures that the appropriate route handlers are invoked depending on the host value in the request.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that:\n1. The correct response is returned when requests are made to the blueprints with different host headers.\n2. Each blueprint is associated with the correct host list, and the routes respond as expected when accessed with valid host headers.\n\n**Code Being Tested and How It Works**:  \nThe code being tested involves two blueprints (`bp` and `bp2`) that are registered with the Sanic application. Each blueprint has a defined host list:\n- `bp` is associated with `[\"example.com\", \"sub.example.com\"]`.\n- `bp2` is associated with `[\"sub1.example.com\", \"sub2.example.com\"]`.\n\nThe test sends GET requests to the application with different host headers and checks the responses:\n- For `example.com` and `sub.example.com`, it expects \"Hello\" from `bp`.\n- For `sub1.example.com` and `sub2.example.com`, it expects \"Hello2\" and \"Hello3\" from `bp2`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertions**: The test uses assertions to validate that the expected responses match the actual responses from the application.\n- **Parameterized Requests**: It tests multiple scenarios by changing the host header in the requests, demonstrating how the application behaves under different conditions.\n- **Blueprints**: The test effectively utilizes Sanic's blueprint feature to organize routes and handlers, showcasing how to manage multiple route handlers with specific host requirements."
    },
    {
      "name": "test_bp_middleware",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 363,
      "end_line_number": 379,
      "source_code": "def test_bp_middleware(app: Sanic):\n    blueprint = Blueprint(\"test_bp_middleware\")\n\n    @blueprint.middleware(\"response\")\n    async def process_response(request, response):\n        return text(\"OK\")\n\n    @app.route(\"/\")\n    async def handler(request):\n        return text(\"FAIL\")\n\n    app.blueprint(blueprint)\n\n    request, response = app.test_client.get(\"/\")\n\n    assert response.status == 200\n    assert response.text == \"FAIL\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'FAIL'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_bp_middleware` test is to verify the behavior of middleware in a Sanic application when handling HTTP responses. Specifically, it checks that the middleware can modify the response before it is sent to the client.\n\n**Specific Functionality or Behavior Verified**:  \nThis test verifies that the middleware defined in the blueprint does not alter the response returned by the route handler. It ensures that the response from the route handler is \"FAIL\" and that the response status is 200, despite the middleware being present.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a Sanic application with a blueprint that contains a middleware function for processing responses. The middleware is defined to return a response with the text \"OK\", but the route handler for the root path (\"/\") returns \"FAIL\". The test sends a GET request to the root path and asserts that the response status is 200 and the response text is \"FAIL\", demonstrating that the middleware does not override the handler's response.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of a blueprint to encapsulate middleware and route definitions, allowing for modular testing of middleware behavior. It also utilizes the Sanic test client to simulate HTTP requests and validate responses, which is a common pattern in testing web applications. The assertions at the end of the test confirm the expected outcomes, ensuring that the middleware does not interfere with the route handler's response."
    },
    {
      "name": "test_bp_middleware_with_route",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 382,
      "end_line_number": 402,
      "source_code": "def test_bp_middleware_with_route(app: Sanic):\n    blueprint = Blueprint(\"test_bp_middleware\")\n\n    @blueprint.middleware(\"response\")\n    async def process_response(request, response):\n        return text(\"OK\")\n\n    @app.route(\"/\")\n    async def handler(request):\n        return text(\"FAIL\")\n\n    @blueprint.route(\"/bp\")\n    async def bp_handler(request):\n        return text(\"FAIL\")\n\n    app.blueprint(blueprint)\n\n    request, response = app.test_client.get(\"/bp\")\n\n    assert response.status == 200\n    assert response.text == \"OK\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_bp_middleware_with_route` test is to verify that the middleware defined in a Sanic blueprint correctly processes the response for a specific route, ensuring that the middleware can override the default response behavior.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a request is made to the `/bp` route, the response is modified by the middleware to return a status of 200 and a body of \"OK\", despite the route handler's default response being \"FAIL\". This confirms that the middleware is functioning as intended.\n\n**Code Being Tested and How It Works**:  \nThe code being tested includes a Sanic application with a blueprint that has a middleware function registered for the \"response\" phase. The middleware `process_response` is designed to return a response with the text \"OK\". The test sets up a route `/bp` within the blueprint that would normally return \"FAIL\". When a GET request is made to `/bp`, the middleware intercepts the response and modifies it before it is sent back to the client. The assertions check that the response status is 200 and the response text is \"OK\".\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of a blueprint to encapsulate middleware and route definitions, which is a common pattern in web frameworks to organize code. It also utilizes assertions to validate the expected outcomes of the middleware's behavior. The test client is used to simulate HTTP requests, allowing for integration-style testing of the middleware and route interactions. This approach ensures that the middleware's effect on the response is thoroughly validated in a realistic scenario."
    },
    {
      "name": "test_bp_middleware_order",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 405,
      "end_line_number": 442,
      "source_code": "def test_bp_middleware_order(app: Sanic):\n    blueprint = Blueprint(\"test_bp_middleware_order\")\n    order = []\n\n    @blueprint.middleware(\"request\")\n    def mw_1(request):\n        order.append(1)\n\n    @blueprint.middleware(\"request\")\n    def mw_2(request):\n        order.append(2)\n\n    @blueprint.middleware(\"request\")\n    def mw_3(request):\n        order.append(3)\n\n    @blueprint.middleware(\"response\")\n    def mw_4(request, response):\n        order.append(6)\n\n    @blueprint.middleware(\"response\")\n    def mw_5(request, response):\n        order.append(5)\n\n    @blueprint.middleware(\"response\")\n    def mw_6(request, response):\n        order.append(4)\n\n    @blueprint.route(\"/\")\n    def process_response(request):\n        return text(\"OK\")\n\n    app.blueprint(blueprint)\n    order.clear()\n    request, response = app.test_client.get(\"/\")\n\n    assert response.status == 200\n    assert order == [1, 2, 3, 4, 5, 6]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert order == [1, 2, 3, 4, 5, 6]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_bp_middleware_order` test is to verify the execution order of middleware functions in a Sanic application when handling a request and a response. It ensures that the middleware functions are executed in the expected sequence, both for request and response phases.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the middleware functions registered for the \"request\" phase are executed in the order they were added (1, 2, 3) and that the middleware functions for the \"response\" phase are executed in reverse order (6, 5, 4). The test asserts that the final order of execution matches the expected sequence after a GET request to the root endpoint.\n\n**Code Being Tested and How It Works**:  \nThe code being tested involves a Sanic application with a blueprint that contains multiple middleware functions for both request and response phases. The middleware functions append their respective identifiers to an `order` list. The test then makes a GET request to the root endpoint (\"/\") and checks the response status and the order of middleware execution. The expected response status is 200, and the expected order of execution is `[1, 2, 3, 4, 5, 6]`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the following notable patterns and techniques:\n- **Middleware Registration**: It demonstrates how to register multiple middleware functions for both request and response phases within a blueprint.\n- **Order Verification**: It uses a list to track the order of execution, allowing for straightforward verification of the sequence.\n- **Assertions**: The test uses assertions to validate both the HTTP response status and the order of middleware execution, ensuring that the application behaves as expected.\n- **Isolation of State**: The `order.clear()` method is called before the request to ensure that the order list is empty at the start of the test, preventing interference from previous tests."
    },
    {
      "name": "test_bp_exception_handler",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 445,
      "end_line_number": 474,
      "source_code": "def test_bp_exception_handler(app: Sanic):\n    blueprint = Blueprint(\"test_middleware\")\n\n    @blueprint.route(\"/1\")\n    def handler_1(request):\n        raise BadRequest(\"OK\")\n\n    @blueprint.route(\"/2\")\n    def handler_2(request):\n        raise ServerError(\"OK\")\n\n    @blueprint.route(\"/3\")\n    def handler_3(request):\n        raise NotFound(\"OK\")\n\n    @blueprint.exception(NotFound, ServerError)\n    def handler_exception(request, exception):\n        return text(\"OK\")\n\n    app.blueprint(blueprint)\n\n    request, response = app.test_client.get(\"/1\")\n    assert response.status == 400\n\n    request, response = app.test_client.get(\"/2\")\n    assert response.status == 200\n    assert response.text == \"OK\"\n\n    request, response = app.test_client.get(\"/3\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 400",
        "assert response.status == 200",
        "assert response.text == 'OK'",
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "blueprint.exception",
          "body": "@app.route('/')\ndef exception(request):\n    raise SanicExceptionTestException(\"You won't see me\")"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_bp_exception_handler` unit test is designed to verify the behavior of a Sanic application when handling exceptions raised by route handlers within a blueprint. It specifically checks that the application correctly responds to different types of exceptions with the expected HTTP status codes and responses.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies that:\n1. A `BadRequest` exception results in a 400 status code.\n2. A `ServerError` exception is handled by a custom exception handler, returning a 200 status code with a specific response text.\n3. A `NotFound` exception is also handled by the custom exception handler, returning a 200 status code.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Sanic application with a blueprint that defines three routes, each raising a different exception:\n- `/1` raises a `BadRequest`.\n- `/2` raises a `ServerError`.\n- `/3` raises a `NotFound`.\n\nA custom exception handler is registered for `NotFound` and `ServerError`, which returns a text response of \"OK\". The test then makes GET requests to each route using the `app.test_client.get` method and asserts the expected status codes and response content.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Blueprints**: The test utilizes Sanic's blueprint feature to encapsulate route definitions and exception handling, promoting modularity.\n- **Exception Handling**: It tests the application's ability to handle exceptions gracefully and return appropriate responses.\n- **Assertions**: The test employs assertions to validate the response status and content, ensuring that the application behaves as expected under different error conditions.\n- **Isolation**: Each route is tested independently, allowing for clear identification of which exception handling logic is being verified."
    },
    {
      "name": "test_bp_exception_handler_applied",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 477,
      "end_line_number": 504,
      "source_code": "def test_bp_exception_handler_applied(app: Sanic):\n    class Error(Exception):\n        pass\n\n    handled = Blueprint(\"handled\")\n    nothandled = Blueprint(\"nothandled\")\n\n    @handled.exception(Error)\n    def handle_error(req, e):\n        return text(\"handled {}\".format(e))\n\n    @handled.route(\"/ok\")\n    def ok(request):\n        raise Error(\"uh oh\")\n\n    @nothandled.route(\"/notok\")\n    def notok(request):\n        raise Error(\"uh oh\")\n\n    app.blueprint(handled)\n    app.blueprint(nothandled)\n\n    _, response = app.test_client.get(\"/ok\")\n    assert response.status == 200\n    assert response.text == \"handled uh oh\"\n\n    _, response = app.test_client.get(\"/notok\")\n    assert response.status == 500",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'handled uh oh'",
        "assert response.status == 500"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "handled.exception",
          "body": "@app.route('/')\ndef exception(request):\n    raise SanicExceptionTestException(\"You won't see me\")"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_bp_exception_handler_applied` test is to verify that the Sanic framework correctly applies exception handling for routes defined within a blueprint. It ensures that when an exception is raised in a route, the appropriate error handler is invoked, returning the expected response.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks two behaviors: \n1. When an exception of type `Error` is raised in the `/ok` route, it should be handled by the `handle_error` function, returning a 200 status with a message indicating the error was handled.\n2. When the same exception is raised in the `/notok` route, which does not have an associated error handler, it should result in a 500 status code, indicating an unhandled error.\n\n**Code Being Tested and How It Works**:  \nThe test defines a custom exception class `Error` and two blueprints: `handled` and `nothandled`. The `handled` blueprint has an exception handler for the `Error` class, which returns a text response when the error occurs. The `/ok` route in the `handled` blueprint raises the `Error`, triggering the handler. The `/notok` route in the `nothandled` blueprint raises the same error but lacks a handler, leading to a default 500 error response. The test uses the `app.test_client.get` method to simulate HTTP GET requests to these routes and asserts the expected responses.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Blueprints**: It demonstrates the use of blueprints in Sanic to organize routes and their associated error handling.\n- **Custom Exception Handling**: It showcases how to define custom exceptions and associate them with specific handlers, allowing for tailored error responses.\n- **Assertions**: The test uses assertions to validate the response status and content, ensuring that the application behaves as expected under different conditions.\n- **Isolation of Tests**: Each route and its behavior are tested in isolation, allowing for clear identification of where issues may arise in the application."
    },
    {
      "name": "test_bp_exception_handler_not_applied",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 507,
      "end_line_number": 526,
      "source_code": "def test_bp_exception_handler_not_applied(app: Sanic):\n    class Error(Exception):\n        pass\n\n    handled = Blueprint(\"handled\")\n    nothandled = Blueprint(\"nothandled\")\n\n    @handled.exception(Error)\n    def handle_error(req, e):\n        return text(\"handled {}\".format(e))\n\n    @nothandled.route(\"/notok\")\n    def notok(request):\n        raise Error(\"uh oh\")\n\n    app.blueprint(handled)\n    app.blueprint(nothandled)\n\n    _, response = app.test_client.get(\"/notok\")\n    assert response.status == 500",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "handled.exception",
          "body": "@app.route('/')\ndef exception(request):\n    raise SanicExceptionTestException(\"You won't see me\")"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_bp_exception_handler_not_applied` is designed to verify that an exception handler defined in a Sanic blueprint does not apply to routes that are not part of that blueprint. Specifically, it checks that an unhandled exception in a route results in a 500 Internal Server Error response.\n\n**Specific Functionality or Behavior Verified**:  \nThis test confirms that when an `Error` exception is raised in the `nothandled` blueprint's route `/notok`, the exception is not caught by the `handled` blueprint's exception handler. As a result, the response status should be 500, indicating that the error was not handled.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes two blueprints: `handled` and `nothandled`. The `handled` blueprint has an exception handler for the `Error` exception, while the `nothandled` blueprint raises the same exception in its route. The test sets up the application with both blueprints and then makes a GET request to the `/notok` route. The expected outcome is that the response status is 500, indicating that the exception was not handled.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Blueprints**: The test utilizes Sanic's blueprint feature to organize routes and exception handlers, demonstrating how to isolate error handling within specific parts of the application.\n- **Direct Assertion**: The test directly asserts the response status after making a request, which is a common practice in unit testing to verify expected outcomes.\n- **Custom Exception**: The test defines a custom exception class (`Error`) to simulate error conditions, showcasing how to create and handle application-specific exceptions in a structured manner."
    },
    {
      "name": "test_bp_listeners",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 529,
      "end_line_number": 563,
      "source_code": "def test_bp_listeners(app: Sanic):\n    app.route(\"/\")(lambda x: x)\n    blueprint = Blueprint(\"test_middleware\")\n\n    order = []\n\n    @blueprint.listener(\"before_server_start\")\n    def handler_1(sanic, loop):\n        order.append(1)\n\n    @blueprint.listener(\"after_server_start\")\n    def handler_2(sanic, loop):\n        order.append(2)\n\n    @blueprint.listener(\"after_server_start\")\n    def handler_3(sanic, loop):\n        order.append(3)\n\n    @blueprint.listener(\"before_server_stop\")\n    def handler_4(sanic, loop):\n        order.append(5)\n\n    @blueprint.listener(\"before_server_stop\")\n    def handler_5(sanic, loop):\n        order.append(4)\n\n    @blueprint.listener(\"after_server_stop\")\n    def handler_6(sanic, loop):\n        order.append(6)\n\n    app.blueprint(blueprint)\n\n    request, response = app.test_client.get(\"/\")\n\n    assert order == [1, 2, 3, 4, 5, 6]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert order == [1, 2, 3, 4, 5, 6]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_bp_listeners` function is designed to verify the correct execution order of event listeners associated with a Sanic application and its blueprints during the server's lifecycle events, specifically before and after server start and stop.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the listeners for the events `before_server_start`, `after_server_start`, `before_server_stop`, and `after_server_stop` are triggered in the expected order. The expected order is defined in the `order` list, which should contain the integers `[1, 2, 3, 4, 5, 6]` after the server processes a request.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Sanic application and a blueprint with several listeners. Each listener appends a number to the `order` list when triggered. The listeners are registered for the following events:\n- `before_server_start` (handlers 1)\n- `after_server_start` (handlers 2 and 3)\n- `before_server_stop` (handlers 4 and 5)\n- `after_server_stop` (handler 6)\n\nAfter registering the blueprint and making a GET request to the root endpoint, the test asserts that the `order` list matches the expected sequence, confirming that the listeners were executed in the correct order.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Listener Registration**: The test demonstrates the use of event listeners in a web framework, showcasing how to register and trigger them.\n- **Order Verification**: It employs a simple list to track the order of execution, allowing for straightforward assertions on the sequence of events.\n- **Integration Testing**: The test integrates multiple components (app, blueprint, listeners) to ensure they work together as expected, simulating a real-world scenario where the server starts and stops.\n- **Assertions**: The use of assertions to validate the final state of the `order` list is a common practice in unit testing, ensuring that the code behaves as intended."
    },
    {
      "name": "test_bp_static",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 566,
      "end_line_number": 579,
      "source_code": "def test_bp_static(app: Sanic):\n    current_file = inspect.getfile(inspect.currentframe())\n    with open(current_file, \"rb\") as file:\n        current_file_contents = file.read()\n\n    blueprint = Blueprint(\"test_static\")\n\n    blueprint.static(\"/testing.file\", current_file)\n\n    app.blueprint(blueprint)\n\n    request, response = app.test_client.get(\"/testing.file\")\n    assert response.status == 200\n    assert response.body == current_file_contents",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == current_file_contents"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_bp_static` function is designed to verify that a static file served by a Sanic application through a blueprint is accessible and returns the correct content. It ensures that the static file handling mechanism of the Sanic framework works as expected.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a static file is requested via a specific route (\"/testing.file\"), the server responds with a status code of 200 (indicating success) and that the content of the response matches the actual content of the file being served. This confirms both the routing and file serving functionalities.\n\n**Code Being Tested and How It Works**:  \nThe test creates a new `Blueprint` instance and registers a static file route that points to the current test file. It uses the `app.test_client.get` method to simulate an HTTP GET request to the static file's URL. The response is then validated by asserting that the status code is 200 and that the response body matches the contents of the file read at the start of the test.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The test utilizes the `app` fixture, which is likely set up to provide a Sanic application instance for testing.\n- **Blueprints**: It demonstrates the use of blueprints in Sanic, allowing for modular organization of routes and static file handling.\n- **File Handling**: The test reads the current file's contents to ensure that the correct file is being served, showcasing a practical approach to testing file responses.\n- **Assertions**: It employs assertions to validate both the HTTP response status and the content, which is a common practice in unit testing to ensure expected outcomes."
    },
    {
      "name": "test_bp_static_content_type",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 583,
      "end_line_number": 601,
      "source_code": "def test_bp_static_content_type(app, file_name):\n    # This is done here, since no other test loads a file here\n    current_file = inspect.getfile(inspect.currentframe())\n    current_directory = os.path.dirname(os.path.abspath(current_file))\n    static_directory = os.path.join(current_directory, \"static\")\n\n    blueprint = Blueprint(\"test_static\")\n    blueprint.static(\n        \"/testing.file\",\n        get_file_path(static_directory, file_name),\n        content_type=\"text/html; charset=utf-8\",\n    )\n\n    app.blueprint(blueprint)\n\n    request, response = app.test_client.get(\"/testing.file\")\n    assert response.status == 200\n    assert response.body == get_file_content(static_directory, file_name)\n    assert response.headers[\"Content-Type\"] == \"text/html; charset=utf-8\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.html'])"
      ],
      "arguments": [
        "app",
        "file_name"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == get_file_content(static_directory, file_name)",
        "assert response.headers['Content-Type'] == 'text/html; charset=utf-8'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_bp_static_content_type` test verifies that a static file served by a Sanic application returns the correct HTTP status, body content, and content type when accessed via a specific URL endpoint.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that:\n1. The HTTP response status is 200 (OK).\n2. The response body matches the content of the specified static file.\n3. The `Content-Type` header of the response is set to \"text/html; charset=utf-8\".\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Sanic application with a blueprint that serves a static file. The `Blueprint` class is used to define a new route (`/testing.file`) that points to a file located in a static directory. The `get_file_path` function constructs the full path to the file, while `get_file_content` reads the file's content. The test then simulates a GET request to the `/testing.file` endpoint using `app.test_client.get`, and asserts the expected outcomes.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Setup and Teardown**: The test dynamically determines the current file and directory to locate the static file, ensuring that the test environment is correctly configured.\n- **Assertions**: The test employs multiple assertions to validate different aspects of the response, ensuring comprehensive verification of the functionality.\n- **Blueprint Usage**: The test demonstrates the use of blueprints in Sanic to modularize routes and static file serving, which is a common pattern in web application development."
    },
    {
      "name": "test_bp_shorthand",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 604,
      "end_line_number": 686,
      "source_code": "def test_bp_shorthand(app: Sanic):\n    blueprint = Blueprint(\"test_shorhand_routes\")\n    ev = asyncio.Event()\n\n    @blueprint.get(\"/get\")\n    def handler(request):\n        return text(\"OK\")\n\n    @blueprint.put(\"/put\")\n    def put_handler(request):\n        return text(\"OK\")\n\n    @blueprint.post(\"/post\")\n    def post_handler(request):\n        return text(\"OK\")\n\n    @blueprint.head(\"/head\")\n    def head_handler(request):\n        return text(\"OK\")\n\n    @blueprint.options(\"/options\")\n    def options_handler(request):\n        return text(\"OK\")\n\n    @blueprint.patch(\"/patch\")\n    def patch_handler(request):\n        return text(\"OK\")\n\n    @blueprint.delete(\"/delete\")\n    def delete_handler(request):\n        return text(\"OK\")\n\n    @blueprint.websocket(\"/ws/\", strict_slashes=True)\n    async def websocket_handler(request, ws):\n        ev.set()\n\n    app.blueprint(blueprint)\n\n    request, response = app.test_client.get(\"/get\")\n    assert response.body == b\"OK\"\n\n    request, response = app.test_client.post(\"/get\")\n    assert response.status == 405\n\n    request, response = app.test_client.put(\"/put\")\n    assert response.body == b\"OK\"\n\n    request, response = app.test_client.get(\"/post\")\n    assert response.status == 405\n\n    request, response = app.test_client.post(\"/post\")\n    assert response.body == b\"OK\"\n\n    request, response = app.test_client.get(\"/post\")\n    assert response.status == 405\n\n    request, response = app.test_client.head(\"/head\")\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/head\")\n    assert response.status == 405\n\n    request, response = app.test_client.options(\"/options\")\n    assert response.body == b\"OK\"\n\n    request, response = app.test_client.get(\"/options\")\n    assert response.status == 405\n\n    request, response = app.test_client.patch(\"/patch\")\n    assert response.body == b\"OK\"\n\n    request, response = app.test_client.get(\"/patch\")\n    assert response.status == 405\n\n    request, response = app.test_client.delete(\"/delete\")\n    assert response.body == b\"OK\"\n\n    request, response = app.test_client.get(\"/delete\")\n    assert response.status == 405\n\n    request, response = app.test_client.websocket(\"/ws/\")\n    assert response.opened is True\n    assert ev.is_set()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.body == b'OK'",
        "assert response.status == 405",
        "assert response.body == b'OK'",
        "assert response.status == 405",
        "assert response.body == b'OK'",
        "assert response.status == 405",
        "assert response.status == 200",
        "assert response.status == 405",
        "assert response.body == b'OK'",
        "assert response.status == 405",
        "assert response.body == b'OK'",
        "assert response.status == 405",
        "assert response.body == b'OK'",
        "assert response.status == 405",
        "assert response.opened is True",
        "assert ev.is_set()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "blueprint.patch('/patch')",
        "app.test_client.patch('/patch')"
      ],
      "methods_under_test": [
        {
          "name": "blueprint.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "blueprint.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "blueprint.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "blueprint.head",
          "body": "def head(self, request):\n    return text('', headers={'method': 'HEAD'})"
        },
        {
          "name": "blueprint.options",
          "body": "def options(self, request):\n    return text('', headers={'method': 'OPTIONS'})"
        },
        {
          "name": "blueprint.patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "blueprint.delete",
          "body": "def delete(self, request):\n    return text('I am delete method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.head",
          "body": "def head(self, request):\n    return text('', headers={'method': 'HEAD'})"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.options",
          "body": "def options(self, request):\n    return text('', headers={'method': 'OPTIONS'})"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.delete",
          "body": "def delete(self, request):\n    return text('I am delete method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_bp_shorthand` function is designed to verify the correct behavior of various HTTP methods (GET, POST, PUT, HEAD, OPTIONS, PATCH, DELETE) when interacting with routes defined in a Sanic blueprint. It ensures that the routes respond appropriately to valid requests and return the correct HTTP status codes for invalid requests.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n- Each defined route responds correctly to its corresponding HTTP method (e.g., GET to `/get` returns \"OK\").\n- Invalid methods for a route return a 405 Method Not Allowed status.\n- The websocket route opens successfully and sets an event, confirming that the websocket connection is established.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Sanic application with a blueprint that defines several routes. Each route is associated with a specific HTTP method and returns a simple text response. The test client is then used to send requests to these routes, and assertions are made on the responses to ensure they match expected outcomes. For example, a GET request to `/get` should return \"OK\", while a POST request to the same route should return a 405 status.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Blueprint Usage**: The test demonstrates the use of blueprints in Sanic, allowing for modular route definitions.\n- **Asynchronous Testing**: The test includes an asynchronous websocket handler, showcasing how to handle websocket connections in tests.\n- **Event Handling**: The use of `asyncio.Event` to signal when the websocket connection is established is a notable pattern for managing asynchronous events in tests.\n- **Assertions**: The test employs assertions to validate both the response body and status codes, ensuring comprehensive coverage of expected behaviors for each route."
    },
    {
      "name": "test_bp_group",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 689,
      "end_line_number": 726,
      "source_code": "def test_bp_group(app: Sanic):\n    deep_0 = Blueprint(\"deep_0\", url_prefix=\"/deep\")\n    deep_1 = Blueprint(\"deep_1\", url_prefix=\"/deep1\")\n\n    @deep_0.route(\"/\")\n    def handler(request):\n        return text(\"D0_OK\")\n\n    @deep_1.route(\"/bottom\")\n    def bottom_handler(request):\n        return text(\"D1B_OK\")\n\n    mid_0 = Blueprint.group(deep_0, deep_1, url_prefix=\"/mid\")\n    mid_1 = Blueprint(\"mid_tier\", url_prefix=\"/mid1\")\n\n    @mid_1.route(\"/\")\n    def handler1(request):\n        return text(\"M1_OK\")\n\n    top = Blueprint.group(mid_0, mid_1)\n\n    app.blueprint(top)\n\n    @app.route(\"/\")\n    def handler2(request):\n        return text(\"TOP_OK\")\n\n    request, response = app.test_client.get(\"/\")\n    assert response.text == \"TOP_OK\"\n\n    request, response = app.test_client.get(\"/mid1\")\n    assert response.text == \"M1_OK\"\n\n    request, response = app.test_client.get(\"/mid/deep\")\n    assert response.text == \"D0_OK\"\n\n    request, response = app.test_client.get(\"/mid/deep1/bottom\")\n    assert response.text == \"D1B_OK\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'TOP_OK'",
        "assert response.text == 'M1_OK'",
        "assert response.text == 'D0_OK'",
        "assert response.text == 'D1B_OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_bp_group` function is to verify the correct routing and response behavior of a Sanic application that utilizes nested blueprints. It ensures that requests to various endpoints return the expected responses, confirming that the blueprints are properly registered and that their routes are functioning as intended.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the application correctly handles requests to multiple routes defined within nested blueprints. It verifies that:\n- The root route returns \"TOP_OK\".\n- The mid-tier blueprint route returns \"M1_OK\".\n- The deep blueprints return \"D0_OK\" and \"D1B_OK\" for their respective endpoints.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the creation of several blueprints (`deep_0`, `deep_1`, `mid_0`, `mid_1`, and `top`) with specific URL prefixes. Each blueprint has defined routes that return specific text responses. The `app.blueprint(top)` line registers the top-level blueprint, which includes the nested blueprints. The test then simulates HTTP GET requests to various endpoints using `app.test_client.get()` and asserts that the responses match the expected output.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Blueprints**: The test demonstrates the use of blueprints to organize routes in a modular way, allowing for better structure and maintainability of the application.\n- **Assertions**: The test employs assertions to validate the responses from the application, ensuring that the expected output matches the actual output.\n- **HTTP Client Simulation**: The use of `app.test_client.get()` simulates HTTP requests to the application, allowing for end-to-end testing of the routing logic without needing to run a live server.\n- **Nested Blueprint Groups**: The test showcases the ability to group blueprints, which helps in managing complex routing scenarios and maintaining a clean URL structure."
    },
    {
      "name": "test_bp_group_with_default_url_prefix",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 729,
      "end_line_number": 771,
      "source_code": "def test_bp_group_with_default_url_prefix(app: Sanic):\n    from sanic.response import json\n\n    bp_resources = Blueprint(\"bp_resources\")\n\n    @bp_resources.get(\"/\")\n    def list_resources_handler(request):\n        resource = {}\n        return json([resource])\n\n    bp_resource = Blueprint(\"bp_resource\", url_prefix=\"/<resource_id>\")\n\n    @bp_resource.get(\"/\")\n    def get_resource_hander(request, resource_id):\n        resource = {\"resource_id\": resource_id}\n        return json(resource)\n\n    bp_resources_group = Blueprint.group(\n        bp_resources, bp_resource, url_prefix=\"/resources\"\n    )\n    bp_api_v1 = Blueprint(\"bp_api_v1\")\n\n    @bp_api_v1.get(\"/info\")\n    def api_v1_info(request):\n        return text(\"api_version: v1\")\n\n    bp_api_v1_group = Blueprint.group(\n        bp_api_v1, bp_resources_group, url_prefix=\"/v1\"\n    )\n    bp_api_group = Blueprint.group(bp_api_v1_group, url_prefix=\"/api\")\n    app.blueprint(bp_api_group)\n\n    request, response = app.test_client.get(\"/api/v1/info\")\n    assert response.text == \"api_version: v1\"\n\n    request, response = app.test_client.get(\"/api/v1/resources\")\n    assert response.json == [{}]\n\n    from uuid import uuid4\n\n    resource_id = str(uuid4())\n    request, response = app.test_client.get(f\"/api/v1/resources/{resource_id}\")\n    assert response.json == {\"resource_id\": resource_id}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'api_version: v1'",
        "assert response.json == [{}]",
        "assert response.json == {'resource_id': resource_id}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "bp_resources.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp_resource.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp_api_v1.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:\nThe primary purpose of the `test_bp_group_with_default_url_prefix` test is to verify the correct registration and functionality of multiple Sanic blueprints grouped under a common URL prefix. It ensures that the endpoints defined in the blueprints respond as expected when accessed via the constructed URLs.\n\n**Specific Functionality or Behavior Verified**:\nThis test checks that:\n1. The `/api/v1/info` endpoint returns the correct API version.\n2. The `/api/v1/resources` endpoint returns an empty list of resources.\n3. The `/api/v1/resources/<resource_id>` endpoint returns the correct resource ID based on a dynamically generated UUID.\n\n**Code Being Tested and How It Works**:\nThe test sets up several blueprints:\n- `bp_resources`: Handles requests to list resources.\n- `bp_resource`: Handles requests for a specific resource identified by `resource_id`.\n- `bp_api_v1`: Provides an endpoint for API version information.\n\nThese blueprints are grouped under a common URL prefix `/api/v1`, which is then registered with the main Sanic application instance. The test uses the `app.test_client.get` method to simulate HTTP GET requests to the defined endpoints and asserts that the responses match the expected values.\n\n**Notable Testing Patterns or Techniques Used**:\n- **Blueprints**: The test demonstrates the use of Sanic's blueprint feature, which allows for modular organization of routes and handlers.\n- **Dynamic URL Generation**: The test generates a UUID for the resource ID dynamically, showcasing how to handle variable URL segments in tests.\n- **Assertions**: The test employs assertions to validate the response content and status, ensuring that the application behaves as intended.\n- **Test Client**: The use of `app.test_client` allows for simulating requests to the application without needing to run a server, facilitating efficient testing of the API endpoints."
    },
    {
      "name": "test_blueprint_middleware_with_args",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 774,
      "end_line_number": 801,
      "source_code": "def test_blueprint_middleware_with_args(app: Sanic):\n    bp = Blueprint(name=\"with_args_bp\", url_prefix=\"/wa\")\n\n    @bp.middleware\n    def middleware_with_no_tag(request: Request):\n        if request.headers.get(\"content-type\") == \"application/json\":\n            request.headers[\"accepts\"] = \"plain/text\"\n        else:\n            request.headers[\"accepts\"] = \"application/json\"\n\n    @bp.route(\"/\")\n    def default_route(request):\n        if request.headers.get(\"accepts\") == \"application/json\":\n            return json({\"test\": \"value\"})\n        else:\n            return text(\"value\")\n\n    app.blueprint(bp)\n\n    _, response = app.test_client.get(\n        \"/wa\", headers={\"content-type\": \"application/json\"}\n    )\n    assert response.text == \"value\"\n\n    _, response = app.test_client.get(\n        \"/wa\", headers={\"content-type\": \"plain/text\"}\n    )\n    assert response.json.get(\"test\") == \"value\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'value'",
        "assert response.json.get('test') == 'value'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response.json.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "request.headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "request.headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_blueprint_middleware_with_args` is designed to verify the behavior of middleware in a Sanic application when handling requests with different `Content-Type` headers. It ensures that the middleware correctly modifies the request headers and that the appropriate response is returned based on the modified headers.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main behaviors:\n1. When a request with `Content-Type: application/json` is sent, the middleware changes the `accepts` header to `plain/text`, and the response should return a plain text response.\n2. When a request with `Content-Type: plain/text` is sent, the middleware sets the `accepts` header to `application/json`, and the response should return a JSON response.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes:\n- A middleware function `middleware_with_no_tag` that modifies the `accepts` header based on the `Content-Type` of the incoming request.\n- A route `default_route` that returns a JSON response if the `accepts` header is `application/json`, otherwise it returns a plain text response.\nThe test sets up a Sanic application with a blueprint containing these components, then simulates GET requests to the route with different headers to validate the middleware's effect on the response.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Blueprints**: The test utilizes Sanic's blueprint feature to encapsulate middleware and routes, promoting modularity and reusability.\n- **Request Simulation**: The test uses `app.test_client.get` to simulate HTTP GET requests, allowing for easy testing of the application's behavior in response to different inputs.\n- **Assertions**: The test employs assertions to verify that the actual responses match the expected outcomes, ensuring that the middleware and route logic function correctly under varying conditions."
    },
    {
      "name": "test_static_blueprint_name",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 805,
      "end_line_number": 829,
      "source_code": "def test_static_blueprint_name(static_file_directory, file_name):\n    app = Sanic(\"app\")\n    current_file = inspect.getfile(inspect.currentframe())\n    with open(current_file, \"rb\") as file:\n        file.read()\n\n    bp = Blueprint(name=\"static\", url_prefix=\"/static\", strict_slashes=False)\n\n    bp.static(\n        \"/test.file/\",\n        get_file_path(static_file_directory, file_name),\n        name=\"static.testing\",\n        strict_slashes=True,\n    )\n\n    app.blueprint(bp)\n\n    uri = app.url_for(\"static\", name=\"static.testing\")\n    assert uri == \"/static/test.file/\"\n\n    _, response = app.test_client.get(\"/static/test.file\")\n    assert response.status == 404\n\n    _, response = app.test_client.get(\"/static/test.file/\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file'])"
      ],
      "arguments": [
        "static_file_directory",
        "file_name"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert uri == '/static/test.file/'",
        "assert response.status == 404",
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_static_blueprint_name` test verifies the correct registration and behavior of a static file route within a Sanic application using a blueprint. It ensures that the URL generation and response handling for static files work as expected.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. The URL generated for the static file route is correct.\n2. A request to the static file without a trailing slash returns a 404 status.\n3. A request to the static file with a trailing slash returns a 200 status, indicating successful retrieval of the file.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the following components:\n- **`app.url_for`**: This method generates the URL for the static file route based on the blueprint name and route name.\n- **`app.test_client.get`**: This simulates HTTP GET requests to the application to test the responses for the static file route.\n- **`get_file_path`**: This utility function constructs the file path for the static file based on the provided directory and filename.\n\nThe blueprint is created with a static route that serves a file, and the test checks the URL generation and response status for different request formats.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses `@pytest.mark.parametrize` to run the test with different file names, allowing for easy extension and testing of multiple scenarios without duplicating code.\n- **Assertions**: The test employs assertions to validate expected outcomes, ensuring that the application behaves correctly under the specified conditions.\n- **Blueprint Usage**: The test demonstrates the use of blueprints in Sanic, encapsulating route definitions and allowing for modular application design."
    },
    {
      "name": "test_static_blueprintp_mw",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 833,
      "end_line_number": 860,
      "source_code": "def test_static_blueprintp_mw(app: Sanic, static_file_directory, file_name):\n    current_file = inspect.getfile(inspect.currentframe())  # type: ignore\n    with open(current_file, \"rb\") as file:\n        file.read()\n\n    triggered = False\n\n    bp = Blueprint(name=\"test_mw\", url_prefix=\"\")\n\n    @bp.middleware(\"request\")\n    def bp_mw1(request):\n        nonlocal triggered\n        triggered = True\n\n    bp.static(\n        \"/test.file\",\n        get_file_path(static_file_directory, file_name),\n        strict_slashes=True,\n        name=\"static\",\n    )\n\n    app.blueprint(bp)\n\n    uri = app.url_for(\"test_mw.static\")\n    assert uri == \"/test.file\"\n\n    _, response = app.test_client.get(\"/test.file\")\n    assert triggered is True",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file'])"
      ],
      "arguments": [
        "app",
        "static_file_directory",
        "file_name"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert uri == '/test.file'",
        "assert triggered is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_static_blueprintp_mw` test is to verify that a middleware function associated with a Sanic blueprint is correctly triggered when a static file is requested. It ensures that the middleware behaves as expected in the context of serving static files.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks two main behaviors: \n1. It verifies that the URL generated for the static file is correct by asserting that `app.url_for(\"test_mw.static\")` returns the expected path (`\"/test.file\"`).\n2. It confirms that the middleware function (`bp_mw1`) is executed when a GET request is made to the static file endpoint, indicated by the `triggered` variable being set to `True`.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the following components:\n- **Blueprint**: A Sanic blueprint named `test_mw` is created, which includes a middleware function that sets a flag (`triggered`) to `True` when a request is received.\n- **Static File Serving**: The blueprint serves a static file located at the path returned by `get_file_path(static_file_directory, file_name)`.\n- **Sanic Application**: The blueprint is registered with the Sanic application (`app`), and the test client is used to simulate a GET request to the static file endpoint.\n\nThe middleware is expected to be triggered upon this request, and the test checks that the flag is set correctly.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Nonlocal Variable**: The use of `nonlocal` allows the middleware to modify the `triggered` variable defined in the outer scope, which is a common pattern for tracking state across nested functions.\n- **Blueprints**: The test demonstrates the use of blueprints in Sanic, which encapsulate routes and middleware, promoting modularity and reusability in web applications.\n- **Assertions**: The test employs assertions to validate both the URL generation and the middleware execution, which are essential for confirming that the application behaves as intended."
    },
    {
      "name": "test_websocket_route",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 863,
      "end_line_number": 877,
      "source_code": "def test_websocket_route(app: Sanic):\n    event = asyncio.Event()\n\n    async def websocket_handler(request, ws):\n        assert ws.subprotocol is None\n        event.set()\n\n    bp = Blueprint(name=\"handler\", url_prefix=\"/ws\")\n    bp.add_websocket_route(websocket_handler, \"/test\", name=\"test\")\n\n    app.blueprint(bp)\n\n    _, response = app.test_client.websocket(\"/ws/test\")\n    assert response.opened is True\n    assert event.is_set()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.opened is True",
        "assert event.is_set()",
        "assert ws.subprotocol is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_websocket_route` function is designed to verify the correct behavior of a WebSocket route defined within a Sanic application. Specifically, it checks that the WebSocket connection can be established successfully and that the handler behaves as expected when invoked.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that:\n1. The WebSocket connection opens successfully (`response.opened is True`).\n2. The WebSocket handler correctly identifies that no subprotocol is set (`ws.subprotocol is None`).\n3. The event signaling mechanism works as intended, confirming that the handler was executed (`event.is_set()`).\n\n**Code Being Tested and How It Works**:  \nThe test sets up a WebSocket route using a Sanic `Blueprint`. The `websocket_handler` function is defined to assert that the `ws.subprotocol` is `None` and to signal completion by setting an `asyncio.Event`. The route is added to the application, and a WebSocket connection is initiated to the specified route (`/ws/test`). The assertions check the state of the connection and the event to ensure the handler executed correctly.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test utilizes `asyncio.Event` to manage asynchronous behavior, ensuring that the test waits for the handler to complete before making assertions.\n- **Blueprints**: The use of a `Blueprint` allows for modular route definitions, which is a common pattern in web frameworks to organize code.\n- **Assertions**: The test employs assertions to validate the expected outcomes, which is a fundamental practice in unit testing to ensure code correctness."
    },
    {
      "name": "test_duplicate_blueprint",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 880,
      "end_line_number": 893,
      "source_code": "def test_duplicate_blueprint(app: Sanic):\n    bp_name = \"bp\"\n    bp = Blueprint(bp_name)\n    bp1 = Blueprint(bp_name)\n\n    app.blueprint(bp)\n\n    with pytest.raises(AssertionError) as excinfo:\n        app.blueprint(bp1)\n\n    assert str(excinfo.value) == (\n        f'A blueprint with the name \"{bp_name}\" is already registered.  '\n        \"Blueprint names must be unique.\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(excinfo.value) == f'A blueprint with the name \"{bp_name}\" is already registered.  Blueprint names must be unique.'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_duplicate_blueprint` function is designed to verify that the Sanic application correctly raises an `AssertionError` when attempting to register a blueprint with a name that has already been registered. This ensures that blueprint names remain unique within the application.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks the behavior of the `app.blueprint()` method when a duplicate blueprint name is provided. It confirms that the application raises an appropriate error and that the error message clearly indicates the reason for the failure, which is the uniqueness constraint on blueprint names.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `Sanic` application instance and its method `blueprint()`. The test first creates two blueprints with the same name (`bp_name`). It registers the first blueprint (`bp`) with the application. When the test attempts to register the second blueprint (`bp1`), it expects an `AssertionError` to be raised, indicating that a blueprint with that name is already registered. The error message is then asserted to match the expected message, ensuring that the application provides clear feedback on the error.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises()` context manager to assert that an exception is raised during the execution of the code block that registers the second blueprint. This is a common pattern in unit testing for verifying that specific exceptions are thrown under certain conditions. Additionally, the test uses string comparison to validate that the error message is both accurate and informative, which is crucial for debugging and user experience."
    },
    {
      "name": "test_strict_slashes_behavior_adoption",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 896,
      "end_line_number": 938,
      "source_code": "def test_strict_slashes_behavior_adoption():\n    app = Sanic(\"app\")\n    app.strict_slashes = True\n    bp = Blueprint(\"bp\")\n    bp2 = Blueprint(\"bp2\", strict_slashes=False)\n\n    @app.get(\"/test\")\n    def handler_test(request):\n        return text(\"Test\")\n\n    @app.get(\"/f1\", strict_slashes=False)\n    def f1(request):\n        return text(\"f1\")\n\n    @bp.get(\"/one\", strict_slashes=False)\n    def one(request):\n        return text(\"one\")\n\n    @bp.get(\"/second\")\n    def second(request):\n        return text(\"second\")\n\n    @bp2.get(\"/third\")\n    def third(request):\n        return text(\"third\")\n\n    app.blueprint(bp)\n    app.blueprint(bp2)\n\n    assert app.test_client.get(\"/test\")[1].status == 200\n    assert app.test_client.get(\"/test/\")[1].status == 404\n\n    assert app.test_client.get(\"/one\")[1].status == 200\n    assert app.test_client.get(\"/one/\")[1].status == 200\n\n    assert app.test_client.get(\"/second\")[1].status == 200\n    assert app.test_client.get(\"/second/\")[1].status == 404\n\n    assert app.test_client.get(\"/third\")[1].status == 200\n    assert app.test_client.get(\"/third/\")[1].status == 200\n\n    assert app.test_client.get(\"/f1\")[1].status == 200\n    assert app.test_client.get(\"/f1/\")[1].status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.test_client.get('/test')[1].status == 200",
        "assert app.test_client.get('/test/')[1].status == 404",
        "assert app.test_client.get('/one')[1].status == 200",
        "assert app.test_client.get('/one/')[1].status == 200",
        "assert app.test_client.get('/second')[1].status == 200",
        "assert app.test_client.get('/second/')[1].status == 404",
        "assert app.test_client.get('/third')[1].status == 200",
        "assert app.test_client.get('/third/')[1].status == 200",
        "assert app.test_client.get('/f1')[1].status == 200",
        "assert app.test_client.get('/f1/')[1].status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp2.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_strict_slashes_behavior_adoption` test is to verify the behavior of route handling in the Sanic web framework when the `strict_slashes` setting is applied. It checks how the application responds to requests with and without trailing slashes for various routes defined in the application and blueprints.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically verifies that routes behave correctly according to the `strict_slashes` setting. It ensures that:\n- Routes defined with `strict_slashes=True` return a 404 status when accessed with a trailing slash.\n- Routes defined with `strict_slashes=False` return a 200 status regardless of the presence of a trailing slash.\n- The test also checks that the application correctly handles routes defined in both the main app and blueprints with varying `strict_slashes` settings.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes several route definitions using the Sanic framework:\n- The main application (`app`) has a route `/test` that is strictly defined (no trailing slash allowed).\n- The blueprint `bp` has routes `/one` (non-strict) and `/second` (strict), while `bp2` has a non-strict route `/third`.\n- The test client is used to simulate GET requests to these routes, and the responses are asserted against expected status codes (200 or 404) based on the `strict_slashes` configuration.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Setup and Teardown**: The test initializes the application and blueprints within the test function, ensuring a clean state for each test run.\n- **Assertions**: It uses assertions to validate the HTTP response status codes, which is a common practice in unit testing to confirm that the application behaves as expected.\n- **Blueprints**: The use of blueprints allows for modular route definitions, which is a key feature in web frameworks for organizing code.\n- **Direct Testing of HTTP Responses**: The test directly interacts with the HTTP client to simulate requests and check responses, which is essential for testing web applications."
    },
    {
      "name": "test_blueprint_group_versioning",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 941,
      "end_line_number": 982,
      "source_code": "def test_blueprint_group_versioning():\n    app = Sanic(name=\"blueprint-group-test\")\n\n    bp1 = Blueprint(name=\"bp1\", url_prefix=\"/bp1\")\n    bp2 = Blueprint(name=\"bp2\", url_prefix=\"/bp2\", version=2)\n\n    bp3 = Blueprint(name=\"bp3\", url_prefix=\"/bp3\")\n\n    @bp3.get(\"/r1\")\n    async def bp3_r1(request):\n        return json({\"from\": \"bp3/r1\"})\n\n    @bp1.get(\"/pre-group\")\n    async def pre_group(request):\n        return json({\"from\": \"bp1/pre-group\"})\n\n    group = Blueprint.group([bp1, bp2], url_prefix=\"/group1\", version=1)\n\n    group2 = Blueprint.group([bp3])\n\n    @bp1.get(\"/r1\")\n    async def r1(request):\n        return json({\"from\": \"bp1/r1\"})\n\n    @bp2.get(\"/r2\")\n    async def r2(request):\n        return json({\"from\": \"bp2/r2\"})\n\n    @bp2.get(\"/r3\", version=3)\n    async def r3(request):\n        return json({\"from\": \"bp2/r3\"})\n\n    app.blueprint([group, group2])\n\n    assert app.test_client.get(\"/v1/group1/bp1/r1/\")[1].status == 200\n    assert app.test_client.get(\"/v2/group1/bp2/r2\")[1].status == 200\n    assert app.test_client.get(\"/v1/group1/bp1/pre-group\")[1].status == 200\n    assert app.test_client.get(\"/v3/group1/bp2/r3\")[1].status == 200\n    assert app.test_client.get(\"/bp3/r1\")[1].status == 200\n\n    assert group.version == 1\n    assert group2.strict_slashes is None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.test_client.get('/v1/group1/bp1/r1/')[1].status == 200",
        "assert app.test_client.get('/v2/group1/bp2/r2')[1].status == 200",
        "assert app.test_client.get('/v1/group1/bp1/pre-group')[1].status == 200",
        "assert app.test_client.get('/v3/group1/bp2/r3')[1].status == 200",
        "assert app.test_client.get('/bp3/r1')[1].status == 200",
        "assert group.version == 1",
        "assert group2.strict_slashes is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "bp3.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp1.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp1.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp2.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp2.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_blueprint_group_versioning` test is to verify the correct behavior of Sanic's Blueprint grouping and versioning features. It ensures that routes defined within grouped blueprints respond correctly based on their specified versions and URL prefixes.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that HTTP GET requests to various endpoints return the expected HTTP status codes (200 OK) for both versioned and non-versioned routes. It also verifies that the versioning of the blueprint groups is correctly applied and that the `strict_slashes` attribute behaves as expected.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Sanic application and defines multiple blueprints (`bp1`, `bp2`, and `bp3`) with specific URL prefixes and versions. It groups `bp1` and `bp2` under a common URL prefix `/group1` with version 1, while `bp3` is grouped separately. The test then makes several GET requests to the defined routes and checks the responses. The assertions confirm that the routes are accessible and return the correct status codes, indicating that the routing and versioning logic is functioning as intended.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the outcomes of HTTP requests, which is a common pattern in unit testing. It also utilizes asynchronous route handlers, reflecting the asynchronous nature of the Sanic framework. The grouping of blueprints and the use of versioning demonstrate a structured approach to organizing routes, which is essential for maintaining a clean and scalable API design. Additionally, the test checks attributes of the blueprint groups, such as `version` and `strict_slashes`, to ensure that the configuration is correctly applied."
    },
    {
      "name": "test_blueprint_group_strict_slashes",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 985,
      "end_line_number": 1033,
      "source_code": "def test_blueprint_group_strict_slashes():\n    app = Sanic(name=\"blueprint-group-test\")\n    bp1 = Blueprint(name=\"bp1\", url_prefix=None, strict_slashes=False)\n\n    bp2 = Blueprint(\n        name=\"bp2\", version=3, url_prefix=\"/bp2\", strict_slashes=None\n    )\n\n    bp3 = Blueprint(\n        name=\"bp3\", version=None, url_prefix=\"/bp3/\", strict_slashes=None\n    )\n\n    @bp1.get(\"/r1\")\n    async def bp1_r1(request):\n        return json({\"from\": \"bp1/r1\"})\n\n    @bp2.get(\"/r1\")\n    async def bp2_r1(request):\n        return json({\"from\": \"bp2/r1\"})\n\n    @bp2.get(\"/r2/\")\n    async def bp2_r2(request):\n        return json({\"from\": \"bp2/r2\"})\n\n    @bp3.get(\"/r1\")\n    async def bp3_r1(request):\n        return json({\"from\": \"bp3/r1\"})\n\n    group = Blueprint.group(\n        [bp1, bp2],\n        url_prefix=\"/slash-check/\",\n        version=1.3,\n        strict_slashes=True,\n    )\n\n    group2 = Blueprint.group(\n        [bp3], url_prefix=\"/other-prefix/\", version=\"v2\", strict_slashes=False\n    )\n\n    app.blueprint(group)\n    app.blueprint(group2)\n\n    assert app.test_client.get(\"/v1.3/slash-check/r1\")[1].status == 200\n    assert app.test_client.get(\"/v1.3/slash-check/r1/\")[1].status == 200\n    assert app.test_client.get(\"/v3/slash-check/bp2/r1\")[1].status == 200\n    assert app.test_client.get(\"/v3/slash-check/bp2/r1/\")[1].status == 404\n    assert app.test_client.get(\"/v3/slash-check/bp2/r2\")[1].status == 404\n    assert app.test_client.get(\"/v3/slash-check/bp2/r2/\")[1].status == 200\n    assert app.test_client.get(\"/v2/other-prefix/bp3/r1\")[1].status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.test_client.get('/v1.3/slash-check/r1')[1].status == 200",
        "assert app.test_client.get('/v1.3/slash-check/r1/')[1].status == 200",
        "assert app.test_client.get('/v3/slash-check/bp2/r1')[1].status == 200",
        "assert app.test_client.get('/v3/slash-check/bp2/r1/')[1].status == 404",
        "assert app.test_client.get('/v3/slash-check/bp2/r2')[1].status == 404",
        "assert app.test_client.get('/v3/slash-check/bp2/r2/')[1].status == 200",
        "assert app.test_client.get('/v2/other-prefix/bp3/r1')[1].status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "bp1.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp2.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp2.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp3.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_blueprint_group_strict_slashes` test is to verify the behavior of Sanic's blueprint routing system, specifically focusing on how strict slashes are handled when grouping blueprints. It ensures that the application correctly responds to requests with and without trailing slashes based on the `strict_slashes` setting.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks the routing behavior of multiple blueprints when they are grouped together with different `strict_slashes` configurations. It verifies that:\n- Routes respond correctly to requests with and without trailing slashes.\n- The expected HTTP status codes (200 for success, 404 for not found) are returned based on the defined routes and their configurations.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Sanic application and defines three blueprints (`bp1`, `bp2`, and `bp3`) with varying `strict_slashes` settings. It groups `bp1` and `bp2` under a common URL prefix with strict slashes enforced, while `bp3` is grouped separately without strict slashes. The test then makes several GET requests to various endpoints and asserts the expected HTTP status codes:\n- For example, `app.test_client.get(\"/v1.3/slash-check/r1\")` checks if the route responds correctly without a trailing slash, while `app.test_client.get(\"/v3/slash-check/bp2/r1/\")` checks the same route with a trailing slash, expecting a 404 status.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Setup and Teardown**: The test initializes a new Sanic application and blueprints, ensuring a clean state for each test run.\n- **Assertions**: It uses assertions to validate the HTTP response status codes, which is a common practice in unit testing to confirm that the application behaves as expected.\n- **Grouping Blueprints**: The test demonstrates the use of blueprint grouping, a powerful feature in Sanic that allows for modular route management, making it easier to organize and maintain routes.\n- **Asynchronous Testing**: The test leverages asynchronous route handlers, which is a key feature of Sanic, allowing for non-blocking I/O operations."
    },
    {
      "name": "test_blueprint_registered_multiple_apps",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 1036,
      "end_line_number": 1050,
      "source_code": "def test_blueprint_registered_multiple_apps():\n    app1 = Sanic(\"app1\")\n    app2 = Sanic(\"app2\")\n    bp = Blueprint(\"bp\")\n\n    @bp.get(\"/\")\n    async def handler(request):\n        return text(request.route.name)\n\n    app1.blueprint(bp)\n    app2.blueprint(bp)\n\n    for app in (app1, app2):\n        _, response = app.test_client.get(\"/\")\n        assert response.text == f\"{app.name}.bp.handler\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == f'{app.name}.bp.handler'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "bp.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_blueprint_registered_multiple_apps` verifies that a single `Blueprint` can be registered with multiple `Sanic` applications and that the route handlers respond correctly based on the application context.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when a `Blueprint` is registered with two different `Sanic` applications (`app1` and `app2`), the route defined in the `Blueprint` returns the expected response for each application. Specifically, it ensures that the response text reflects the application's name combined with the route handler's name.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `bp.get` method, which defines a route handler for the `Blueprint`, and the `app.test_client.get` method, which simulates a GET request to the registered route. The handler returns the text representation of the route name, which is constructed using the application's name and the handler's name. The test asserts that the response text matches the expected format for both applications.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the following techniques:\n- **Setup and Teardown**: It initializes two separate `Sanic` applications and a `Blueprint` before executing the test logic.\n- **Parameterization**: Although not explicitly shown in this test, the structure allows for easy extension to test additional applications or routes.\n- **Assertions**: It uses assertions to validate that the responses from both applications are as expected, ensuring that the `Blueprint` behaves consistently across different application contexts."
    },
    {
      "name": "test_bp_set_attribute_warning",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 1053,
      "end_line_number": 1060,
      "source_code": "def test_bp_set_attribute_warning():\n    bp = Blueprint(\"bp\")\n    message = (\n        \"Setting variables on Blueprint instances is not allowed. You should \"\n        \"change your Blueprint instance to use instance.ctx.foo instead.\"\n    )\n    with pytest.raises(AttributeError, match=message):\n        bp.foo = 1",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_bp_set_attribute_warning` test is to verify that attempting to set an attribute directly on a `Blueprint` instance raises an `AttributeError`. This ensures that the design of the `Blueprint` class enforces its intended usage, preventing users from inadvertently modifying the instance in a way that could lead to unexpected behavior.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `Blueprint` class does not allow the assignment of arbitrary attributes (in this case, `bp.foo = 1`). It confirms that the framework correctly raises an `AttributeError` with a specific error message when such an assignment is attempted, thereby guiding users to use the appropriate context (`instance.ctx.foo`) for storing data.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `Blueprint` class, which is part of the Sanic web framework. When the test attempts to set `bp.foo = 1`, it triggers the internal logic of the `Blueprint` class that prevents direct attribute assignments. The expected behavior is that this action raises an `AttributeError`, and the test checks for this exception and its accompanying message.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that an exception is raised during the execution of the code block. This is a common pattern in unit testing for verifying that specific error conditions are met. Additionally, the use of the `match` parameter allows for checking that the exception message is not only raised but also matches the expected string, ensuring that the error handling is both functional and informative."
    },
    {
      "name": "test_early_registration",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 1063,
      "end_line_number": 1088,
      "source_code": "def test_early_registration(app: Sanic):\n    assert len(app.router.routes) == 0\n\n    bp = Blueprint(\"bp\")\n\n    @bp.get(\"/one\")\n    async def one(_):\n        return text(\"one\")\n\n    app.blueprint(bp)\n\n    assert len(app.router.routes) == 1\n\n    @bp.get(\"/two\")\n    async def two(_):\n        return text(\"two\")\n\n    @bp.get(\"/three\")\n    async def three(_):\n        return text(\"three\")\n\n    assert len(app.router.routes) == 3\n\n    for path in (\"one\", \"two\", \"three\"):\n        _, response = app.test_client.get(f\"/{path}\")\n        assert response.text == path",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(app.router.routes) == 0",
        "assert len(app.router.routes) == 1",
        "assert len(app.router.routes) == 3",
        "assert response.text == path"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "bp.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_early_registration` function is designed to verify the behavior of the Sanic application when registering blueprints and ensuring that the routing system correctly reflects the registered routes. It checks that routes are added as expected and that the application can respond to requests for those routes.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies that:\n1. Initially, the application has no routes registered.\n2. After registering a blueprint with one route, the application has one route.\n3. After adding two additional routes to the same blueprint, the application correctly reflects a total of three routes.\n4. The application responds correctly to GET requests for each of the defined routes, returning the expected text.\n\n**Code Being Tested and How It Works**:  \nThe code being tested involves the Sanic framework's routing and blueprint functionality. The test:\n- Initializes a Sanic application and checks the initial state of the router.\n- Defines a blueprint with three GET routes (`/one`, `/two`, and `/three`).\n- Registers the blueprint with the application.\n- Uses assertions to check the number of routes in the router after each registration step.\n- Sends GET requests to each route using the application's test client and verifies that the responses match the expected output.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertions**: The test uses assertions to validate the state of the application at various points, ensuring that the number of routes matches expectations and that responses are correct.\n- **Blueprints**: The test demonstrates the use of blueprints in Sanic, which allows for modular route definitions and organization of code.\n- **Test Client**: The use of `app.test_client.get` simulates HTTP requests to the application, allowing for verification of route handling and response generation.\n- **Incremental Testing**: The test checks the state of the application incrementally after each route registration, which helps isolate issues related to route registration and response handling."
    },
    {
      "name": "test_remove_double_slashes_defined_on_bp",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 1091,
      "end_line_number": 1100,
      "source_code": "def test_remove_double_slashes_defined_on_bp(app: Sanic):\n    bp = Blueprint(\"bp\", url_prefix=\"/foo/\", strict_slashes=True)\n\n    @bp.get(\"/\")\n    async def handler(_): ...\n\n    app.blueprint(bp)\n    app.router.finalize()\n\n    assert app.router.routes[0].path == \"foo/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.router.routes[0].path == 'foo/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "bp.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_remove_double_slashes_defined_on_bp` aims to verify that when a Sanic blueprint is defined with a URL prefix and strict slashes enabled, the resulting route correctly handles the path without introducing double slashes.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the route defined in the blueprint, which is set to respond to the path `/`, is correctly registered under the prefixed path `/foo/` without any additional slashes. The expected outcome is that the route's path should be exactly `foo/`.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the Sanic framework's routing mechanism. A blueprint is created with a URL prefix of `/foo/` and strict slashes enabled. The route defined within the blueprint responds to the path `/`. After registering the blueprint with the main application and finalizing the router, the test asserts that the first route in the application's router has the path `foo/`. This confirms that the framework correctly processes the URL prefix and strict slashes settings.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the Arrange-Act-Assert (AAA) pattern, where:\n- **Arrange**: The blueprint is set up with a specific URL prefix and strict slashes.\n- **Act**: The blueprint is registered with the application, and the router is finalized.\n- **Assert**: The test checks the resulting route's path to ensure it matches the expected value. This pattern helps in maintaining clarity and structure in the test, making it easier to understand the setup, execution, and verification steps."
    },
    {
      "name": "test_remove_double_slashes_defined_on_register",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 1103,
      "end_line_number": 1112,
      "source_code": "def test_remove_double_slashes_defined_on_register(app: Sanic):\n    bp = Blueprint(\"bp\")\n\n    @bp.get(\"/\")\n    async def index(_): ...\n\n    app.blueprint(bp, url_prefix=\"/foo/\", strict_slashes=True)\n    app.router.finalize()\n\n    assert app.router.routes[0].path == \"foo/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.router.routes[0].path == 'foo/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "bp.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_remove_double_slashes_defined_on_register` aims to verify that when a blueprint is registered with a URL prefix and strict slashes enabled, the resulting route does not contain double slashes in its path.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the path of the route created by the blueprint registration is correctly formatted as `foo/` without any unintended double slashes, ensuring that the routing behaves as expected when strict slashes are enforced.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the registration of a Sanic blueprint with a URL prefix of `/foo/` and strict slashes set to `True`. The blueprint defines a single route at the root path (`/`). After registering the blueprint, the test asserts that the first route in the application's router has the path `foo/`, confirming that the registration process correctly handles the URL prefix and strict slashes.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the expected outcome of the route registration. It also utilizes the Sanic framework's blueprint functionality, which allows for modular route definitions. The test is structured to isolate the behavior of the blueprint registration, ensuring that it adheres to the specified routing rules without side effects from other parts of the application."
    },
    {
      "name": "test_blueprint_copy_returns_blueprint_with_the_name_of_original_blueprint",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 1115,
      "end_line_number": 1125,
      "source_code": "def test_blueprint_copy_returns_blueprint_with_the_name_of_original_blueprint(\n    app: Sanic,\n):\n    # arrange\n    bp = Blueprint(\"bp\")\n\n    # act\n    actual = bp.copy(\"new_bp_name\")\n\n    # assert\n    assert bp.name == actual.copied_from",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert bp.name == actual.copied_from"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_blueprint_copy_returns_blueprint_with_the_name_of_original_blueprint` aims to verify that when a blueprint is copied using the `copy` method, the new blueprint retains a reference to the original blueprint's name through the `copied_from` attribute.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `copied_from` attribute of the newly created blueprint (`actual`) matches the name of the original blueprint (`bp`). This ensures that the copying mechanism correctly tracks the source of the new blueprint.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `Blueprint` class and its `copy` method. When `bp.copy(\"new_bp_name\")` is called, it creates a new blueprint instance with the name \"new_bp_name\". The test then asserts that the `copied_from` attribute of this new instance (`actual`) is equal to the name of the original blueprint (`bp.name`), which is \"bp\". This confirms that the copying process correctly sets the `copied_from` attribute.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test follows the Arrange-Act-Assert (AAA) pattern, which is a common structure in unit testing. It first sets up the necessary conditions (arranging the original blueprint), then performs the action (copying the blueprint), and finally asserts the expected outcome (checking the `copied_from` attribute). This clear separation of steps enhances readability and maintainability of the test."
    },
    {
      "name": "test_blueprint_copy_returns_blueprint_with_overwritten_properties",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 1128,
      "end_line_number": 1152,
      "source_code": "def test_blueprint_copy_returns_blueprint_with_overwritten_properties(\n    app: Sanic,\n):\n    # arrange\n    bp = Blueprint(\"bp\")\n    to_override_attrs = expected = dict(\n        url_prefix=\"v2\",\n        version=\"v2\",\n        version_prefix=\"v2\",\n        allow_route_overwrite=True,\n        strict_slashes=True,\n    )\n\n    # act\n    actual = bp.copy(\n        \"new_bp_name\",\n        **to_override_attrs,\n    )\n\n    # assert\n    assert all(\n        value == getattr(actual, key)\n        for key, value in expected.items()\n        if hasattr(actual, key)\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert all((value == getattr(actual, key) for (key, value) in expected.items() if hasattr(actual, key)))"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_blueprint_copy_returns_blueprint_with_overwritten_properties` aims to verify that the `copy` method of the `Blueprint` class correctly creates a new blueprint instance with specified properties that override the defaults of the original blueprint.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the properties of the newly created blueprint (after copying) match the expected values provided in the `to_override_attrs` dictionary. It ensures that the `copy` method not only creates a new instance but also applies the specified overrides correctly.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `copy` method of the `Blueprint` class. The test first creates an instance of `Blueprint` named `bp`. It then calls the `copy` method with a new name and a set of attributes to override. The `copy` method is expected to return a new `Blueprint` instance (`actual`) that has the overridden properties. The test then asserts that each property in the `expected` dictionary matches the corresponding property in the `actual` blueprint, using `getattr` to access the properties dynamically.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the **Arrange-Act-Assert** pattern, which is a common structure in unit testing. The \"Arrange\" phase sets up the initial conditions (creating the blueprint and defining expected attributes), the \"Act\" phase executes the method under test (calling `bp.copy`), and the \"Assert\" phase verifies the outcome (comparing the actual properties to the expected ones). Additionally, it uses a generator expression within the `all()` function to succinctly check multiple conditions in a single assertion, enhancing readability and efficiency."
    },
    {
      "name": "test_dev",
      "module": "test_prepare",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_prepare.py",
      "line_number": 30,
      "end_line_number": 34,
      "source_code": "def test_dev(app: Sanic):\n    app.prepare(dev=True)\n\n    assert app.state.is_debug\n    assert app.state.auto_reload",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "pathlib.Path",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.application.state.ApplicationServerInfo"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.state.is_debug",
        "assert app.state.auto_reload"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_dev` function is designed to verify that the Sanic application is correctly configured for development mode. Specifically, it checks that the application is in debug mode and that auto-reloading is enabled when the application is prepared with the `dev=True` argument.\n\n**Specific Functionality or Behavior Verified**:  \nThis test asserts two key properties of the application state after invoking `app.prepare(dev=True)`: \n1. `app.state.is_debug` should be `True`, indicating that the application is in debug mode.\n2. `app.state.auto_reload` should also be `True`, confirming that the application is set to automatically reload when code changes are detected.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `prepare` method of the `Sanic` application class. When called with `dev=True`, this method is expected to modify the application's state to enable debugging features. The assertions in the test check the state attributes `is_debug` and `auto_reload` to ensure they reflect the expected configuration for a development environment.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The test utilizes a fixture (`no_skip`) that automatically runs before each test, ensuring that the application does not skip auto-reload checks during testing. This helps maintain a clean testing environment.\n- **Direct State Assertions**: The test directly asserts the state of the application after invoking a method, which is a common practice in unit testing to verify that the method behaves as expected.\n- **Isolation**: The test is isolated from other tests due to the use of fixtures, ensuring that changes to the application state do not affect other tests. This promotes reliability and consistency in test outcomes."
    },
    {
      "name": "test_motd_display",
      "module": "test_prepare",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_prepare.py",
      "line_number": 37,
      "end_line_number": 41,
      "source_code": "def test_motd_display(app: Sanic):\n    app.prepare(motd_display={\"foo\": \"bar\"})\n\n    assert app.config.MOTD_DISPLAY[\"foo\"] == \"bar\"\n    del app.config.MOTD_DISPLAY[\"foo\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "pathlib.Path",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.application.state.ApplicationServerInfo"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.config.MOTD_DISPLAY['foo'] == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_motd_display` test is to verify that the Sanic application correctly handles the configuration of the \"Message of the Day\" (MOTD) display feature. Specifically, it checks that the application can accept a custom MOTD display dictionary and that the configuration is properly set.\n\n**Specific Functionality or Behavior Verified**:  \nThis test verifies that when the `motd_display` parameter is provided to the `app.prepare()` method, the application correctly updates its configuration to include the specified key-value pairs. In this case, it checks that the key \"foo\" is set to \"bar\" in the `MOTD_DISPLAY` configuration.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `app.prepare()` method, which is expected to accept a dictionary for the `motd_display` parameter. When `app.prepare(motd_display={\"foo\": \"bar\"})` is called, it should populate the `app.config.MOTD_DISPLAY` with the provided dictionary. The assertion `assert app.config.MOTD_DISPLAY[\"foo\"] == \"bar\"` checks that this behavior occurs as expected. The subsequent line `del app.config.MOTD_DISPLAY[\"foo\"]` is used to clean up the configuration after the test, ensuring that it does not affect other tests.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern to validate the expected state of the application configuration. It uses the `assert` statement to check the correctness of the configuration after invoking the method under test. Additionally, the test is structured to be isolated, as it modifies the application state and cleans up afterward, which is a good practice in unit testing to avoid side effects on other tests. The use of a fixture (`app`) suggests that the test is part of a larger test suite that sets up the Sanic application context automatically."
    },
    {
      "name": "test_reload_dir",
      "module": "test_prepare",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_prepare.py",
      "line_number": 45,
      "end_line_number": 59,
      "source_code": "def test_reload_dir(app: Sanic, dirs, caplog):\n    messages = []\n    with caplog.at_level(logging.WARNING):\n        app.prepare(reload_dir=dirs)\n\n    if isinstance(dirs, str):\n        dirs = (dirs,)\n        for d in dirs:\n            assert Path(d) in app.state.reload_dirs\n            messages.append(\n                f\"Directory {d} could not be located\",\n            )\n\n    for message in messages:\n        assert (\"sanic.root\", logging.WARNING, message) in caplog.record_tuples",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('dirs', ('./foo', ('./foo', './bar')))"
      ],
      "arguments": [
        "app",
        "dirs",
        "caplog"
      ],
      "imports": [
        "logging",
        "os",
        "pathlib.Path",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.application.state.ApplicationServerInfo"
      ],
      "fixtures": [],
      "assertions": [
        "assert ('sanic.root', logging.WARNING, message) in caplog.record_tuples",
        "assert Path(d) in app.state.reload_dirs"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_reload_dir` function is designed to verify the behavior of the `Sanic` application when it is instructed to prepare for reloading from specified directories. It ensures that the application correctly identifies the directories intended for reloading and logs appropriate warnings if any of those directories cannot be located.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the directories specified in the `reload_dir` parameter are correctly added to the application's state. It also verifies that if a directory cannot be found, a warning message is logged, indicating the issue. This ensures that the application behaves as expected when handling directory reloads.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `app.prepare(reload_dir=dirs)` method call, which is expected to populate `app.state.reload_dirs` with the provided directories. The test checks if each directory in `dirs` is present in `app.state.reload_dirs`. If `dirs` is a string, it is converted to a tuple for uniform processing. The test also captures log messages at the WARNING level to confirm that appropriate warnings are generated when directories are not found.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses `pytest.mark.parametrize` to run the same test logic with different directory inputs, enhancing coverage and reducing code duplication.\n- **Logging Capture**: The `caplog` fixture is employed to capture log messages generated during the test, allowing for verification of logging behavior without modifying the actual logging configuration.\n- **Assertions**: The test includes assertions to validate both the state of the application and the correctness of logged messages, ensuring comprehensive verification of the functionality being tested."
    },
    {
      "name": "test_fast",
      "module": "test_prepare",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_prepare.py",
      "line_number": 62,
      "end_line_number": 85,
      "source_code": "def test_fast(app: Sanic, caplog):\n    @app.after_server_start\n    async def stop(app, _):\n        app.stop()\n\n    try:\n        workers = len(os.sched_getaffinity(0))\n    except AttributeError:\n        workers = os.cpu_count() or 1\n\n    with caplog.at_level(logging.INFO):\n        app.prepare(fast=True)\n\n    assert app.state.fast\n    assert app.state.workers == workers\n\n    messages = [m[2] for m in caplog.record_tuples]\n\n    if workers == 1:\n        worker_fragment = \"single worker\"\n    else:\n        worker_fragment = f\"w/ {workers} workers\"\n\n    assert f\"mode: production, goin' fast {worker_fragment}\" in messages",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "caplog"
      ],
      "imports": [
        "logging",
        "os",
        "pathlib.Path",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.application.state.ApplicationServerInfo"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.state.fast",
        "assert app.state.workers == workers",
        "assert f\"mode: production, goin' fast {worker_fragment}\" in messages"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_fast` function is designed to verify the behavior of the Sanic application when it is prepared in \"fast\" mode. It checks that the application correctly sets its state to indicate that it is running in fast mode and that the number of workers matches the expected count based on the system's CPU affinity or available CPU cores.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically verifies three key aspects:\n1. The application state is set to fast mode (`app.state.fast`).\n2. The number of workers (`app.state.workers`) is correctly initialized based on the system's capabilities.\n3. A log message confirming the mode and worker count is generated, ensuring that the application is running in the expected configuration.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `app.prepare(fast=True)` method, which is expected to configure the application for fast operation. The test checks the state of the application after this method is called. It also uses the `caplog` fixture to capture log messages generated during the preparation phase, allowing assertions on the content of those logs to confirm that the application is operating in the correct mode.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The test utilizes the `caplog` fixture from pytest to capture log messages, which is a common pattern for verifying logging behavior in tests.\n- **State Assertions**: The test asserts the state of the application after invoking the method under test, ensuring that the application behaves as expected.\n- **Conditional Logic**: The test includes conditional logic to handle different worker counts, demonstrating adaptability in testing based on the environment.\n- **Exception Handling**: The test includes a try-except block to gracefully handle the absence of `os.sched_getaffinity`, ensuring compatibility across different systems."
    },
    {
      "name": "test_no_request_id_not_called",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 14,
      "end_line_number": 19,
      "source_code": "def test_no_request_id_not_called(monkeypatch):\n    monkeypatch.setattr(uuid, \"uuid4\", Mock())\n    request = Request(b\"/\", {}, None, \"GET\", None, None)\n\n    assert request._id is None\n    uuid.uuid4.assert_not_called()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert request._id is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_no_request_id_not_called` test is to verify that when a `Request` object is created without an explicit request ID, the UUID generation function (`uuid.uuid4`) is not called, and the request ID remains `None`.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the internal `_id` attribute of the `Request` object is `None` when the request is instantiated without a request ID. It also ensures that the UUID generation function is not invoked, confirming that the system does not generate a new request ID in this scenario.\n\n**Code Being Tested and How It Works**:  \nThe test creates a `Request` object using the `Request` class from the Sanic framework, passing in parameters that do not include a request ID. The assertion `assert request._id is None` checks that the `_id` attribute is indeed `None`. The line `uuid.uuid4.assert_not_called()` verifies that the mocked `uuid4` function was not called during the instantiation of the `Request` object, indicating that no new UUID was generated.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `monkeypatch` fixture from `pytest` to replace the `uuid.uuid4` function with a mock object. This allows the test to control and verify interactions with the UUID generation function without actually generating a UUID. The use of assertions to check both the state of the `Request` object and the behavior of the mocked function is a common pattern in unit testing, ensuring that the code behaves as expected under specific conditions."
    },
    {
      "name": "test_request_id_generates_from_request",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 22,
      "end_line_number": 30,
      "source_code": "def test_request_id_generates_from_request(monkeypatch):\n    monkeypatch.setattr(Request, \"generate_id\", Mock())\n    Request.generate_id.return_value = 1\n    request = Request(b\"/\", {}, None, \"GET\", None, Mock())\n    request.app.config.REQUEST_ID_HEADER = \"foo\"\n\n    for _ in range(10):\n        request.id\n    Request.generate_id.assert_called_once_with(request)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_request_id_generates_from_request` aims to verify that the `Request` class correctly generates a request ID when accessed multiple times, ensuring that the ID generation logic is invoked as expected.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `generate_id` method of the `Request` class is called exactly once when the request ID is accessed multiple times. It ensures that the ID generation is efficient and does not invoke the ID generation method more than necessary.\n\n**Code Being Tested and How It Works**:  \nThe test modifies the `generate_id` method of the `Request` class using `monkeypatch` to replace it with a mock that returns a fixed value (1). A `Request` object is created, and the request ID is accessed ten times in a loop. The assertion checks that `generate_id` was called only once with the `request` object as an argument, confirming that the ID is cached after the first call.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Monkeypatching**: The test uses `monkeypatch` to temporarily replace the `generate_id` method, allowing for controlled testing of the method's behavior without invoking the actual implementation.\n- **Mocking**: The `Mock` class from `unittest.mock` is used to create a mock object for `generate_id`, enabling the test to track how many times it is called and with what arguments.\n- **Looping for Access**: The test accesses the request ID multiple times to ensure that the caching behavior is functioning correctly, which is a common pattern in performance-related tests."
    },
    {
      "name": "test_request_id_defaults_uuid",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 33,
      "end_line_number": 40,
      "source_code": "def test_request_id_defaults_uuid():\n    request = Request(b\"/\", {}, None, \"GET\", None, Mock())\n    request.app.config.REQUEST_ID_HEADER = \"foo\"\n\n    assert isinstance(request.id, UUID)\n\n    # Makes sure that it has been cached and not called multiple times\n    assert request.id == request.id == request._id",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(request.id, UUID)",
        "assert request.id == request.id == request._id"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_request_id_defaults_uuid` test is to verify that when a `Request` object is created without a specified request ID, it defaults to generating a UUID. This ensures that every request has a unique identifier, which is crucial for tracking and logging purposes in web applications.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main behaviors: \n1. It confirms that the `id` attribute of the `Request` instance is of type `UUID`, indicating that a UUID has been generated.\n2. It verifies that the generated UUID is cached correctly by ensuring that multiple accesses to `request.id` return the same value, which is also stored in `request._id`. This prevents unnecessary re-computation of the ID.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `id` property of the `Request` class. When accessed, this property checks if `_id` is already set. If not, it attempts to retrieve the request ID from the headers using the configured `REQUEST_ID_HEADER`. If no ID is found, it generates a new ID using the `generate_id` method, which defaults to creating a UUID. The generated ID is then cached in `_id` for future access. The relevant part of the code is:\n\n```python\n@property\ndef id(self) -> Optional[Union[uuid.UUID, str, int]]:\n    ...\n    if not self._id:\n        self._id = self.headers.getone(\n            self.app.config.REQUEST_ID_HEADER,\n            self.__class__.generate_id(self),\n        )\n    ...\n```\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the following notable patterns:\n- **Assertions**: It uses assertions to validate the expected outcomes, specifically checking the type of the generated ID and ensuring that it is cached correctly.\n- **Mocking**: Although not directly used in this specific test, the surrounding tests utilize mocking (e.g., `Mock()`) to isolate the behavior of the `Request` class from external dependencies, ensuring that the tests focus solely on the functionality of the `Request` class itself.\n- **Property Testing**: The test leverages the property decorator to access the `id`, demonstrating how properties can encapsulate logic while providing a clean interface for users of the class."
    },
    {
      "name": "test_name_none",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 43,
      "end_line_number": 46,
      "source_code": "def test_name_none():\n    request = Request(b\"/\", {}, None, \"GET\", None, None)\n\n    assert request.name is None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.name is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_name_none` function is designed to verify that a newly created `Request` object has its `name` attribute set to `None` when no specific name is provided during its initialization.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks the default behavior of the `Request` class in the Sanic framework, specifically ensuring that the `name` attribute is correctly initialized to `None` when the request is created without a route or name.\n\n**Code Being Tested and How It Works**:  \nThe test creates an instance of the `Request` class with the following parameters: a byte string representing the URL (`b\"/\"`), an empty dictionary for headers, `None` for the body, the HTTP method as `\"GET\"`, and `None` for the route. After instantiation, the test asserts that the `name` attribute of the `request` object is `None`, confirming that the default behavior is as expected.\n\n**Notable Testing Patterns or Techniques Used**:  \nThis test employs a straightforward assertion pattern, where the expected outcome (the `name` being `None`) is directly compared to the actual outcome. It uses the `assert` statement, which is a common practice in unit testing to validate conditions. The simplicity of this test highlights the importance of verifying default values in object-oriented programming, ensuring that the class behaves correctly when initialized with minimal parameters."
    },
    {
      "name": "test_name_from_route",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 49,
      "end_line_number": 54,
      "source_code": "def test_name_from_route():\n    request = Request(b\"/\", {}, None, \"GET\", None, None)\n    route = Mock()\n    request.route = route\n\n    assert request.name == route.name",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.name == route.name"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_name_from_route` unit test is designed to verify that the `name` attribute of a `Request` object correctly reflects the `name` of the associated route. This ensures that the routing mechanism in the Sanic framework is functioning as expected, particularly in how it associates requests with their corresponding routes.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when a `Request` object is created and assigned a route (mocked in this case), the `name` property of the `Request` object matches the `name` property of the mocked route. This confirms that the `Request` object is correctly retrieving and exposing the route's name.\n\n**Code Being Tested and How It Works**:  \nThe test creates a `Request` object with a mock route. The line `request.route = route` assigns the mocked route to the request. The assertion `assert request.name == route.name` checks if the `name` attribute of the `Request` object is equal to the `name` of the mocked route. Since the route is a mock, it does not have a predefined name, so the test implicitly assumes that the `Request` object will return `None` for its `name` unless the route's name is explicitly set.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of mocking via the `Mock` class from the `unittest.mock` module. This allows for the creation of a mock object that simulates the behavior of a route without needing a full implementation. The test is straightforward and focuses on a single assertion, which is a common pattern in unit testing to ensure clarity and maintainability. Additionally, the test does not rely on any external dependencies, making it isolated and fast, which is a best practice in unit testing."
    },
    {
      "name": "test_name_from_set",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 57,
      "end_line_number": 61,
      "source_code": "def test_name_from_set():\n    request = Request(b\"/\", {}, None, \"GET\", None, None)\n    request._name = \"foo\"\n\n    assert request.name == \"foo\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.name == 'foo'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_name_from_set` unit test is designed to verify that the `Request` object can correctly retrieve a name that has been explicitly set on it. This ensures that the internal state of the `Request` object can be manipulated and accessed as expected.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when the `_name` attribute of a `Request` object is set to \"foo\", the `name` property of the same object returns \"foo\". This confirms that the `name` property correctly reflects the value assigned to `_name`.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `Request` class from the Sanic framework. In the test, a `Request` object is instantiated with a mock request. The `_name` attribute is directly set to \"foo\". The assertion `assert request.name == \"foo\"` checks if the `name` property retrieves the value of `_name`. This implies that the `name` property is likely implemented to return the value of `_name` when accessed.\n\n**Notable Testing Patterns or Techniques Used**:  \nThis test employs a straightforward assertion pattern to validate the expected behavior of an object's property. It directly manipulates an internal attribute (`_name`) and checks the public interface (`name`), which is a common practice in unit testing to ensure encapsulation and proper behavior of class properties. The test is simple and does not require any mocking or complex setup, making it easy to understand and maintain."
    },
    {
      "name": "test_request_id",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 72,
      "end_line_number": 83,
      "source_code": "def test_request_id(request_id, expected_type):\n    app = Sanic(\"req-generator\")\n\n    @app.get(\"/\")\n    async def get(request):\n        return response.empty()\n\n    request, _ = app.test_client.get(\n        \"/\", headers={\"X-REQUEST-ID\": f\"{request_id}\"}\n    )\n    assert request.id == request_id\n    assert type(request.id) == expected_type",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('request_id,expected_type', ((99, int), (uuid4(), UUID), ('foo', str)))"
      ],
      "arguments": [
        "request_id",
        "expected_type"
      ],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.id == request_id",
        "assert type(request.id) == expected_type"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_request_id` function is designed to verify that the Sanic framework correctly assigns a request ID from the HTTP headers to the request object. It ensures that the request ID is both correctly set and of the expected type.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks two main assertions: first, that the request ID extracted from the headers matches the provided `request_id`, and second, that the type of the request ID is as expected (either `int`, `str`, or `UUID`), as specified by the `expected_type` parameter.\n\n**Code Being Tested and How It Works**:  \nThe test creates a Sanic application instance and defines a simple GET route that returns an empty response. It then simulates a GET request to this route, including a custom header `X-REQUEST-ID` with the value of `request_id`. The test retrieves the request object from the response and asserts that the `request.id` matches the `request_id` and is of the type specified by `expected_type`. The relevant methods being tested include `app.get` for defining the route and `app.test_client.get` for simulating the request.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs parameterized testing using `pytest`, allowing it to run multiple scenarios with different combinations of `request_id` and `expected_type`. This approach enhances test coverage and ensures that the functionality is robust across various input types. Additionally, the use of assertions to validate both the value and type of the request ID demonstrates a thorough testing strategy, ensuring that both correctness and type safety are maintained."
    },
    {
      "name": "test_custom_generator",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 86,
      "end_line_number": 103,
      "source_code": "def test_custom_generator():\n    REQUEST_ID = 99\n\n    class FooRequest(Request):\n        @classmethod\n        def generate_id(cls, request):\n            return int(request.headers[\"some-other-request-id\"]) * 2\n\n    app = Sanic(\"req-generator\", request_class=FooRequest)\n\n    @app.get(\"/\")\n    async def get(request):\n        return response.empty()\n\n    request, _ = app.test_client.get(\n        \"/\", headers={\"SOME-OTHER-REQUEST-ID\": f\"{REQUEST_ID}\"}\n    )\n    assert request.id == REQUEST_ID * 2",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.id == REQUEST_ID * 2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:\nThe `test_custom_generator` unit test is designed to verify that a custom request ID generation mechanism works correctly within a Sanic application. Specifically, it checks that the request ID is generated based on a specific header value, ensuring that the application can handle custom request ID logic.\n\n**Specific Functionality or Behavior Verified**:\nThis test confirms that the `generate_id` method of the `FooRequest` class correctly processes the `some-other-request-id` header from the incoming request. It asserts that the generated request ID is double the value of the provided header, ensuring that the custom logic for ID generation is functioning as intended.\n\n**Code Being Tested and How It Works**:\nThe test creates a subclass of `Request` called `FooRequest`, which overrides the `generate_id` class method. This method retrieves the value of the `some-other-request-id` header, converts it to an integer, and multiplies it by 2. The Sanic application is instantiated with this custom request class. The test then simulates a GET request to the root endpoint (\"/\") with the header set to a specific value (99). Finally, it asserts that the request ID returned is 198 (99 * 2).\n\n**Notable Testing Patterns or Techniques Used**:\nThe test employs the following patterns:\n- **Subclassing**: It creates a custom request class to modify the behavior of request ID generation.\n- **Dependency Injection**: The custom request class is injected into the Sanic application, allowing for flexible testing of different request behaviors.\n- **Asynchronous Testing**: The test uses asynchronous request handling, which is a common pattern in web frameworks like Sanic.\n- **Header Manipulation**: It demonstrates how to manipulate HTTP headers in tests to simulate different request scenarios."
    },
    {
      "name": "test_route_assigned_to_request",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 106,
      "end_line_number": 112,
      "source_code": "def test_route_assigned_to_request(app):\n    @app.get(\"/\")\n    async def get(request):\n        return response.empty()\n\n    request, _ = app.test_client.get(\"/\")\n    assert request.route is list(app.router.routes)[0]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.route is list(app.router.routes)[0]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_route_assigned_to_request` test is to verify that the route associated with a request is correctly assigned and can be accessed through the request object in a Sanic application.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a GET request is made to the root endpoint (\"/\"), the route associated with that request matches the first route defined in the application's router. This ensures that the routing mechanism of the Sanic framework is functioning as expected.\n\n**Code Being Tested and How It Works**:  \nThe test defines a simple GET route at the root (\"/\") that returns an empty response. It then uses the `app.test_client.get(\"/\")` method to simulate a GET request to this route. The response is unpacked to get the request object, and the test asserts that the `request.route` is the same as the first route in the application's router (`list(app.router.routes)[0]`). This confirms that the request is correctly linked to the defined route.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Route Definition**: The test uses a decorator to define a route within the test function, showcasing how routes can be dynamically added in tests.\n- **Request Simulation**: It employs the `app.test_client.get()` method to simulate a client request, which is a common pattern in testing web applications to verify endpoint behavior.\n- **Assertion of Route Assignment**: The test uses an assertion to check the relationship between the request and the route, which is crucial for ensuring that the routing logic is correctly implemented. This pattern of asserting relationships is common in unit tests to validate expected outcomes."
    },
    {
      "name": "test_protocol_attribute",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 115,
      "end_line_number": 127,
      "source_code": "def test_protocol_attribute(app):\n    retrieved = None\n\n    @app.get(\"/\")\n    async def get(request):\n        nonlocal retrieved\n        retrieved = request.protocol\n        return response.empty()\n\n    headers = {\"Connection\": \"keep-alive\"}\n    _ = app.test_client.get(\"/\", headers=headers)\n\n    assert isinstance(retrieved, HttpProtocol)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(retrieved, HttpProtocol)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_protocol_attribute` test is designed to verify that the `protocol` attribute of the request object in a Sanic application correctly reflects the HTTP protocol being used for the incoming request.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `protocol` attribute of the request object is an instance of `HttpProtocol`. This ensures that the application is correctly identifying and handling the protocol used in the request, which is crucial for proper request processing and response generation.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route (`@app.get(\"/\")`) that captures the incoming request. Inside the route handler, it assigns the `request.protocol` to a variable `retrieved`. The test then simulates a GET request to the root endpoint (\"/\") with a header indicating a persistent connection (`\"Connection\": \"keep-alive\"`). After the request is processed, the test asserts that `retrieved` is an instance of `HttpProtocol`, confirming that the protocol was correctly identified.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Nonlocal Variable**: The use of `nonlocal` allows the inner function to modify the `retrieved` variable defined in the outer scope, which is a common pattern in asynchronous testing to capture values from callbacks.\n- **Asynchronous Testing**: The test leverages asynchronous route handlers, which is a key feature of the Sanic framework, allowing for non-blocking I/O operations.\n- **Header Manipulation**: The test demonstrates how to manipulate request headers to simulate different client behaviors, which is essential for testing various scenarios in web applications."
    },
    {
      "name": "test_ipv6_address_is_not_wrapped",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 130,
      "end_line_number": 145,
      "source_code": "def test_ipv6_address_is_not_wrapped(app):\n    @app.get(\"/\")\n    async def get(request):\n        return response.json(\n            {\n                \"client_ip\": request.conn_info.client_ip,\n                \"client\": request.conn_info.client,\n            }\n        )\n\n    request, resp = app.test_client.get(\"/\", host=\"::1\")\n\n    assert request.route is list(app.router.routes)[0]\n    assert resp.json[\"client\"] == \"[::1]\"\n    assert resp.json[\"client_ip\"] == \"::1\"\n    assert request.ip == \"::1\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.route is list(app.router.routes)[0]",
        "assert resp.json['client'] == '[::1]'",
        "assert resp.json['client_ip'] == '::1'",
        "assert request.ip == '::1'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_ipv6_address_is_not_wrapped` test is to verify that the Sanic application correctly handles and returns the client's IPv6 address without any unintended modifications or wrapping.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a request is made from an IPv6 address (`::1`), the application correctly identifies and returns this address in both the `client_ip` and `client` fields of the JSON response. It also ensures that the request's IP attribute is set correctly.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route in the Sanic application that responds to GET requests at the root URL (`/`). The route handler returns a JSON response containing the client's IP address and connection information. The test then simulates a GET request to this route using the IPv6 loopback address (`::1`). It checks that:\n- The route matched is the expected one.\n- The JSON response contains the correct values for `client` and `client_ip`.\n- The request's IP attribute is correctly set to `::1`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the expected outcomes against the actual results. It uses the Sanic test client to simulate requests, which is a common pattern in unit testing web applications. The test also leverages the `async` capabilities of Sanic, ensuring that the asynchronous nature of the framework is properly handled during the test execution."
    },
    {
      "name": "test_request_accept",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 148,
      "end_line_number": 195,
      "source_code": "def test_request_accept():\n    app = Sanic(\"req-generator\")\n\n    @app.get(\"/\")\n    async def get(request):\n        return response.empty()\n\n    header_value = \"text/plain;format=flowed, text/plain, text/*, */*\"\n    request, _ = app.test_client.get(\n        \"/\",\n        headers={\"Accept\": header_value},\n    )\n    assert str(request.accept) == header_value\n    match = request.accept.match(\n        \"*/*;format=flowed\",\n        \"text/plain;format=flowed\",\n        \"text/plain\",\n        \"text/*\",\n        \"*/*\",\n    )\n    assert match == \"*/*;format=flowed\"\n    assert match.header.mime == \"text/plain\"\n    assert match.header.params == {\"format\": \"flowed\"}\n\n    header_value = (\n        \"text/plain; q=0.5,   text/html, text/x-dvi; q=0.8, text/x-c\"\n    )\n    request, _ = app.test_client.get(\n        \"/\",\n        headers={\"Accept\": header_value},\n    )\n    assert [str(i) for i in request.accept] == [\n        \"text/html\",\n        \"text/x-c\",\n        \"text/x-dvi;q=0.8\",\n        \"text/plain;q=0.5\",\n    ]\n    match = request.accept.match(\n        \"application/json\",\n        \"text/plain\",  # Has lower q in accept header\n        \"text/html;format=flowed\",  # Params mismatch\n        \"text/*\",  # Matches\n        \"*/*\",\n    )\n    assert match == \"text/*\"\n    assert match.header.mime == \"text/html\"\n    assert match.header.q == 1.0\n    assert not match.header.params",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(request.accept) == header_value",
        "assert match == '*/*;format=flowed'",
        "assert match.header.mime == 'text/plain'",
        "assert match.header.params == {'format': 'flowed'}",
        "assert [str(i) for i in request.accept] == ['text/html', 'text/x-c', 'text/x-dvi;q=0.8', 'text/plain;q=0.5']",
        "assert match == 'text/*'",
        "assert match.header.mime == 'text/html'",
        "assert match.header.q == 1.0",
        "assert not match.header.params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_request_accept` function is designed to verify the behavior of the Sanic framework's request handling, specifically focusing on the parsing and matching of the `Accept` HTTP header. It ensures that the application correctly interprets various `Accept` header values and matches them against expected content types.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main functionalities: \n1. It verifies that the `request.accept` property accurately reflects the `Accept` header sent in the request.\n2. It tests the matching logic of the `request.accept.match` method to ensure it correctly identifies the best content type based on the provided `Accept` header values, including handling of quality factors (q-values) and parameters.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes:\n- The Sanic application instance (`app`) and its route handler for the root path (`/`), which returns an empty response.\n- The `app.test_client.get` method, which simulates a GET request to the application with specified headers.\n- The `request.accept` property, which parses the `Accept` header into a structured format.\n- The `request.accept.match` method, which attempts to find the best match for the requested content types from a list of options.\n\nThe test first sends a request with a complex `Accept` header and checks if the parsed result matches the expected string. It then tests the matching functionality with various content types, asserting that the correct match is returned based on the rules of content negotiation.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterized Testing**: The test uses multiple assertions to cover different scenarios of the `Accept` header, ensuring comprehensive coverage of the matching logic.\n- **Assertions**: The test employs assertions to validate the expected outcomes, such as checking the string representation of the `request.accept`, the match results, and the properties of the match object (like `mime` and `params`).\n- **Simulated Requests**: The use of `app.test_client.get` allows for simulating HTTP requests in a controlled environment, enabling the testing of request handling without needing a live server."
    },
    {
      "name": "test_bad_url_parse",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 198,
      "end_line_number": 209,
      "source_code": "def test_bad_url_parse():\n    message = \"Bad URL: my.redacted-domain.com:443\"\n    with pytest.raises(BadURL, match=message):\n        Request(\n            b\"my.redacted-domain.com:443\",\n            Mock(),\n            Mock(),\n            Mock(),\n            Mock(),\n            Mock(),\n            Mock(),\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_bad_url_parse` function is designed to verify that the `Request` class correctly raises a `BadURL` exception when provided with an invalid URL format. This ensures that the application can handle erroneous input gracefully and maintain robustness.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that when a malformed URL (in this case, \"my.redacted-domain.com:443\") is passed to the `Request` constructor, it raises a `BadURL` exception with a specific error message. This behavior is crucial for validating input and preventing further processing of invalid URLs.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `Request` class, which is likely part of a web framework (in this case, Sanic). The constructor of `Request` is expected to parse the provided URL and validate its format. If the URL does not conform to expected standards, it raises a `BadURL` exception. The test uses the `pytest.raises` context manager to assert that the exception is raised as expected.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest` framework's `raises` context manager to assert that an exception is thrown, which is a common pattern in unit testing for verifying error handling. Additionally, the use of the `match` parameter allows for checking that the exception message matches the expected output, ensuring that not only is the correct exception raised, but it also conveys the appropriate error message. This enhances the test's reliability by confirming both the occurrence and the nature of the error."
    },
    {
      "name": "test_request_scope_raises_exception_when_no_asgi",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 212,
      "end_line_number": 222,
      "source_code": "def test_request_scope_raises_exception_when_no_asgi():\n    app = Sanic(\"no_asgi\")\n\n    @app.get(\"/\")\n    async def get(request):\n        return request.scope\n\n    request, response = app.test_client.get(\"/\")\n    assert response.status == 500\n    with pytest.raises(NotImplementedError):\n        _ = request.scope",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_request_scope_raises_exception_when_no_asgi` is designed to verify that when a Sanic application is not running in ASGI mode, attempting to access the request scope raises a `NotImplementedError`. This ensures that the application behaves correctly and fails gracefully when the request context is not available.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the response status is 500 (Internal Server Error) when the endpoint is accessed, indicating that an error occurred. It also confirms that accessing `request.scope` raises a `NotImplementedError`, which is the expected behavior when the request context is not properly set up.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `app.get` method, which defines a route that returns `request.scope`. The `app.test_client.get(\"/\")` method is used to simulate a GET request to the defined route. Since the application is not configured to run in ASGI mode, accessing `request.scope` is not valid, leading to the expected error.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that a specific exception (`NotImplementedError`) is raised when accessing `request.scope`. This pattern is effective for testing error conditions. Additionally, the test checks the response status code to ensure that the application correctly identifies the error state, demonstrating a combination of functional and exception testing."
    },
    {
      "name": "test_cannot_get_request_outside_of_cycle",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 238,
      "end_line_number": 240,
      "source_code": "def test_cannot_get_request_outside_of_cycle():\n    with pytest.raises(SanicException, match=\"No current request\"):\n        Request.get_current()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_cannot_get_request_outside_of_cycle` is designed to verify that an attempt to access the current request context outside of an active request cycle raises a `SanicException`. This ensures that the framework enforces proper request handling and prevents misuse of the request context.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that when `Request.get_current()` is called without an active request context, it raises a `SanicException` with the message \"No current request\". This behavior is crucial for maintaining the integrity of request handling in the Sanic framework.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `Request.get_current()` method, which is expected to return the current request object. However, if there is no active request (i.e., the code is executed outside of a request handling cycle), it should raise a `SanicException`. The test uses the `pytest.raises` context manager to assert that the exception is raised as expected.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager, a common pattern in unit testing that allows for the verification of exceptions. This technique is effective for ensuring that specific error conditions are handled correctly in the codebase. Additionally, the use of a specific exception message in the `match` parameter helps confirm that the correct exception is raised, providing a more robust test."
    },
    {
      "name": "test_get_current_request",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 243,
      "end_line_number": 249,
      "source_code": "def test_get_current_request(app):\n    @app.get(\"/\")\n    async def get(request):\n        return response.json({\"same\": request is Request.get_current()})\n\n    _, resp = app.test_client.get(\"/\")\n    assert resp.json[\"same\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.json['same']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_get_current_request` function aims to verify that the `Request.get_current()` method correctly returns the current request object being processed in the Sanic application.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks whether the request object returned by `Request.get_current()` is the same as the request object passed to the route handler. It ensures that the context of the current request is accurately maintained and accessible within the request handling logic.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route at the root URL (\"/\") that returns a JSON response indicating whether the current request object is the same as the one retrieved by `Request.get_current()`. The test then simulates a GET request to this route using `app.test_client.get(\"/\")` and asserts that the JSON response contains a key `\"same\"` with a value of `True`, confirming that both references point to the same request object.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test is designed to work with asynchronous code, leveraging Sanic's async capabilities to handle requests and responses.\n- **Route Definition within Test**: The route is defined within the test function, allowing for isolated testing of specific behaviors without affecting the global application state.\n- **Direct Assertion**: The test uses a direct assertion to validate the expected behavior, which is a common practice in unit testing to ensure clarity and simplicity in verifying outcomes."
    },
    {
      "name": "test_request_stream_id",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 252,
      "end_line_number": 261,
      "source_code": "def test_request_stream_id(app):\n    @app.get(\"/\")\n    async def get(request):\n        try:\n            request.stream_id\n        except Exception as e:\n            return response.text(str(e))\n\n    _, resp = app.test_client.get(\"/\")\n    assert resp.text == \"Stream ID is only a property of a HTTP/3 request\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.text == 'Stream ID is only a property of a HTTP/3 request'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_request_stream_id` unit test is designed to verify the behavior of the `stream_id` property in the request object when handling HTTP requests in a Sanic application. Specifically, it checks that accessing `request.stream_id` raises an appropriate exception when the request is not an HTTP/3 request.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a request is made to the root endpoint (\"/\"), the application correctly handles the absence of a `stream_id` property for non-HTTP/3 requests. It verifies that an exception is raised and that the response text accurately reflects this situation.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route using the `@app.get(\"/\")` decorator, which attempts to access `request.stream_id`. If an exception occurs, it catches the exception and returns a text response containing the exception message. The test then makes a GET request to the root endpoint and asserts that the response text matches the expected message: \"Stream ID is only a property of a HTTP/3 request\".\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Exception Handling**: The test utilizes a try-except block to handle potential exceptions when accessing `request.stream_id`, allowing for graceful error handling and response generation.\n- **Assertion**: The test employs an assertion to compare the actual response text with the expected output, ensuring that the application behaves as intended.\n- **Asynchronous Testing**: The test is structured to work within an asynchronous context, which is typical for web frameworks like Sanic that support asynchronous request handling."
    },
    {
      "name": "test_request_safe",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 276,
      "end_line_number": 278,
      "source_code": "def test_request_safe(method, safe):\n    request = Request(b\"/\", {}, None, method, None, None)\n    assert request.is_safe is safe",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('method,safe', (('DELETE', False), ('GET', True), ('HEAD', True), ('OPTIONS', True), ('PATCH', False), ('POST', False), ('PUT', False)))"
      ],
      "arguments": [
        "method",
        "safe"
      ],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.is_safe is safe"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_request_safe` function is designed to verify the behavior of the `is_safe` property of the `Request` class in the Sanic framework. It checks whether the HTTP method provided to the `Request` instance is classified as a \"safe\" method according to the HTTP specification.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically verifies that the `is_safe` property correctly identifies safe HTTP methods (such as GET and HEAD) and returns a boolean value that matches the expected `safe` argument. The test ensures that the implementation adheres to the definition of safe methods as outlined in RFC 7231.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `is_safe` property of the `Request` class, which checks if the HTTP method of the request is included in a predefined set of safe methods (`SAFE_HTTP_METHODS`). The test creates a `Request` object with a specified method and then asserts that the `is_safe` property returns the expected boolean value (`safe`).\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs parameterized testing by taking `method` and `safe` as arguments, allowing for multiple combinations of HTTP methods and their expected safety status to be tested efficiently. This approach enhances test coverage and reduces redundancy by enabling the same test logic to be applied to various input scenarios. Additionally, the use of assertions directly compares the output of the `is_safe` property with the expected value, ensuring clarity in the test's intent and results."
    },
    {
      "name": "test_request_idempotent",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 293,
      "end_line_number": 295,
      "source_code": "def test_request_idempotent(method, idempotent):\n    request = Request(b\"/\", {}, None, method, None, None)\n    assert request.is_idempotent is idempotent",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('method,idempotent', (('DELETE', True), ('GET', True), ('HEAD', True), ('OPTIONS', True), ('PATCH', False), ('POST', False), ('PUT', True)))"
      ],
      "arguments": [
        "method",
        "idempotent"
      ],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.is_idempotent is idempotent"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_request_idempotent` function is designed to verify the behavior of the `Request` class in the Sanic framework, specifically checking whether the `is_idempotent` property correctly reflects the idempotency of HTTP methods.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the `is_idempotent` attribute of a `Request` object is set correctly based on the HTTP method provided. It asserts that the value of `request.is_idempotent` matches the expected `idempotent` boolean value.\n\n**Code Being Tested and How It Works**:  \nThe test creates an instance of the `Request` class with a specified HTTP method. The `Request` class is expected to have an `is_idempotent` property that determines if the method is idempotent (i.e., methods like GET, PUT, and DELETE should return True, while POST and PATCH should return False). The test uses the `assert` statement to compare the actual value of `request.is_idempotent` against the expected `idempotent` value passed as an argument.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test utilizes parameterization through the `pytest.mark.parametrize` decorator (though not shown directly in the `test_request_idempotent` function, it is implied that this test is part of a larger suite where methods and their idempotency are defined). This allows for multiple sets of inputs (HTTP methods and their expected idempotency) to be tested efficiently without duplicating code. The use of assertions ensures that the test will fail if the actual behavior does not match the expected behavior, providing immediate feedback on the correctness of the implementation."
    },
    {
      "name": "test_request_cacheable",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 310,
      "end_line_number": 312,
      "source_code": "def test_request_cacheable(method, cacheable):\n    request = Request(b\"/\", {}, None, method, None, None)\n    assert request.is_cacheable is cacheable",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('method,cacheable', (('DELETE', False), ('GET', True), ('HEAD', True), ('OPTIONS', False), ('PATCH', False), ('POST', False), ('PUT', False)))"
      ],
      "arguments": [
        "method",
        "cacheable"
      ],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.is_cacheable is cacheable"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_request_cacheable` function is designed to verify the behavior of the `Request` class in determining whether a given HTTP method is cacheable. It ensures that the `is_cacheable` property of the `Request` object correctly reflects the expected cacheability of various HTTP methods.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the `is_cacheable` attribute of the `Request` instance returns the correct boolean value based on the HTTP method provided. The test uses parameterized inputs to cover multiple HTTP methods and their expected cacheability outcomes.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `Request` class, specifically its `is_cacheable` property. The `Request` object is instantiated with various parameters, including the HTTP method. The `is_cacheable` property is likely implemented to return `True` for methods like `GET` and `HEAD`, which are generally cacheable, and `False` for methods like `POST`, `PUT`, and `DELETE`, which are typically not cacheable. The assertion checks if the actual value of `request.is_cacheable` matches the expected `cacheable` value provided by the test parameters.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `@pytest.mark.parametrize` decorator, which allows for the execution of the same test function with multiple sets of input data. This pattern enhances test coverage and reduces code duplication by systematically testing various combinations of HTTP methods and their expected cacheability. The use of assertions to validate the expected outcomes is a standard practice in unit testing, ensuring that the code behaves as intended."
    },
    {
      "name": "test_custom_ctx",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 315,
      "end_line_number": 338,
      "source_code": "def test_custom_ctx():\n    class CustomContext:\n        FOO = \"foo\"\n\n    class CustomRequest(Request[Sanic, CustomContext]):\n        @staticmethod\n        def make_context() -> CustomContext:\n            return CustomContext()\n\n    app = Sanic(\"Test\", request_class=CustomRequest)\n\n    @app.get(\"/\")\n    async def handler(request: CustomRequest):\n        return response.json(\n            [\n                isinstance(request, CustomRequest),\n                isinstance(request.ctx, CustomContext),\n                request.ctx.FOO,\n            ]\n        )\n\n    _, resp = app.test_client.get(\"/\")\n\n    assert resp.json == [True, True, \"foo\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.json == [True, True, 'foo']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_custom_ctx` function is designed to verify the correct behavior of a custom request context in a Sanic web application. It ensures that the custom request class can successfully create and utilize a custom context, allowing for the expected attributes and types to be present in the request handling.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks three specific assertions: \n1. Whether the request object is an instance of `CustomRequest`.\n2. Whether the context (`ctx`) of the request is an instance of `CustomContext`.\n3. Whether the `FOO` attribute of the context equals the string \"foo\". \n\nThese assertions confirm that the custom request and context are functioning as intended within the Sanic application.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `CustomRequest` class, which extends the base `Request` class from Sanic. It overrides the `make_context` method to return an instance of `CustomContext`, which contains a single attribute `FOO`. The Sanic application is instantiated with this custom request class, and a route is defined that returns a JSON response containing the results of the aforementioned assertions. The test client then makes a GET request to the root endpoint (\"/\"), and the response is validated against the expected output.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Custom Request and Context Classes**: It demonstrates how to extend existing classes to introduce custom behavior in a web framework.\n- **Asynchronous Testing**: The use of an asynchronous handler function showcases how to test asynchronous routes in a web application.\n- **Direct Assertions**: The test directly asserts the expected output of the response, which is a common practice in unit testing to ensure that the code behaves as expected.\n- **Integration Testing**: By testing the interaction between the request, context, and response, the test serves as an integration test that verifies multiple components of the application work together correctly."
    },
    {
      "name": "test_load_from_object",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 48,
      "end_line_number": 52,
      "source_code": "def test_load_from_object(app: Sanic):\n    app.config.load(ConfigTest)\n    assert \"CONFIG_VALUE\" in app.config\n    assert app.config.CONFIG_VALUE == \"should be used\"\n    assert \"not_for_config\" not in app.config",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'CONFIG_VALUE' in app.config",
        "assert app.config.CONFIG_VALUE == 'should be used'",
        "assert 'not_for_config' not in app.config"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.config.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_load_from_object` function is designed to verify that the Sanic application can successfully load configuration values from a given configuration object (in this case, `ConfigTest`). It ensures that the expected configuration values are present and correctly set in the application's configuration.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks three specific assertions: \n1. It verifies that the key `\"CONFIG_VALUE\"` exists in the application's configuration.\n2. It confirms that the value associated with `\"CONFIG_VALUE\"` is equal to `\"should be used\"`.\n3. It ensures that the key `\"not_for_config\"` is not present in the application's configuration, indicating that the configuration loading process correctly filters out unwanted keys.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `load` method of the `app.config` object, which is invoked with `app.config.load(ConfigTest)`. This method is responsible for loading configuration values from the provided object into the application's configuration. The method likely involves iterating over the attributes of the `ConfigTest` class and populating the `app.config` dictionary with these values, while also applying any necessary filtering to exclude certain attributes.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the state of the application configuration after loading. It follows a straightforward Arrange-Act-Assert pattern:\n- **Arrange**: The application is set up with a specific configuration object.\n- **Act**: The configuration is loaded into the application.\n- **Assert**: The test checks the expected outcomes regarding the presence and values of configuration keys. This approach ensures clarity and maintainability in the test structure. Additionally, the test does not rely on external resources, making it a unit test that focuses solely on the functionality of the configuration loading mechanism."
    },
    {
      "name": "test_load_from_object_string",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 55,
      "end_line_number": 59,
      "source_code": "def test_load_from_object_string(app: Sanic):\n    app.config.load(\"tests.test_config.ConfigTest\")\n    assert \"CONFIG_VALUE\" in app.config\n    assert app.config.CONFIG_VALUE == \"should be used\"\n    assert \"not_for_config\" not in app.config",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'CONFIG_VALUE' in app.config",
        "assert app.config.CONFIG_VALUE == 'should be used'",
        "assert 'not_for_config' not in app.config"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.config.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_load_from_object_string` test verifies that the Sanic application can correctly load configuration settings from a specified configuration class using its string representation. This ensures that the application can dynamically import and utilize configuration settings defined in external modules.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks three key assertions: \n1. It confirms that the configuration contains a key named `\"CONFIG_VALUE\"`.\n2. It verifies that the value of `CONFIG_VALUE` is equal to `\"should be used\"`.\n3. It ensures that a key named `\"not_for_config\"` is absent from the configuration. This validates both the presence of expected configuration values and the exclusion of unwanted ones.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `load` method of the `app.config` object, which is responsible for loading configuration settings from a given source. In this case, the source is a string that represents the path to a configuration class (`\"tests.test_config.ConfigTest\"`). The method attempts to import this class and populate the application's configuration with its attributes. The assertions following the load operation check the integrity and correctness of the loaded configuration.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs direct assertions to validate the state of the application configuration after loading. It uses a string-based reference to the configuration class, demonstrating a common pattern in testing where dynamic imports are necessary. Additionally, the test is structured to be clear and concise, focusing on specific expected outcomes, which is a hallmark of effective unit testing. The use of descriptive assertion messages would further enhance clarity, although they are not present in this case."
    },
    {
      "name": "test_load_from_instance",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 62,
      "end_line_number": 68,
      "source_code": "def test_load_from_instance(app: Sanic):\n    app.config.load(ConfigTest())\n    assert \"CONFIG_VALUE\" in app.config\n    assert app.config.CONFIG_VALUE == \"should be used\"\n    assert app.config.ANOTHER_VALUE == \"should be used\"\n    assert \"not_for_config\" not in app.config\n    assert \"another_not_for_config\" not in app.config",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'CONFIG_VALUE' in app.config",
        "assert app.config.CONFIG_VALUE == 'should be used'",
        "assert app.config.ANOTHER_VALUE == 'should be used'",
        "assert 'not_for_config' not in app.config",
        "assert 'another_not_for_config' not in app.config"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.config.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_load_from_instance` function is designed to verify that the configuration values from a given configuration instance (`ConfigTest`) are correctly loaded into the `app.config` of a Sanic application. It ensures that the expected configuration values are present and that unwanted values are absent.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks for the presence of specific configuration keys (`CONFIG_VALUE` and `ANOTHER_VALUE`) and their expected values. It also verifies that certain keys (`not_for_config` and `another_not_for_config`) are not included in the configuration, ensuring that the loading mechanism respects the intended configuration structure.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `load` method of the `app.config` object, which is invoked with an instance of `ConfigTest`. This method is expected to populate the `app.config` dictionary with the attributes defined in the `ConfigTest` class. The assertions following the method call confirm that the configuration has been loaded correctly by checking for the presence and values of specific keys.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs direct assertions to validate the state of the application configuration after loading. It uses a simple and straightforward approach to verify both the presence and absence of configuration keys, which is a common pattern in unit testing to ensure that the system behaves as expected. The use of a dedicated configuration class (`ConfigTest`) allows for clear separation of configuration logic and facilitates testing of various configurations in isolation."
    },
    {
      "name": "test_load_from_object_string_exception",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 71,
      "end_line_number": 73,
      "source_code": "def test_load_from_object_string_exception(app: Sanic):\n    with pytest.raises(ImportError):\n        app.config.load(\"test_config.Config.test\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.config.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_load_from_object_string_exception` test is to verify that the `load` method of the `app.config` raises an `ImportError` when attempting to load a configuration from a non-existent object string.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks the error handling of the `load` method when provided with an invalid string that does not correspond to a valid Python module or object. It ensures that the application correctly raises an `ImportError`, which is crucial for maintaining robustness in configuration loading.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `load` method of the `app.config` object. The method attempts to import a configuration class or object based on the provided string. If the string does not point to a valid object (in this case, \"test_config.Config.test\"), the method should raise an `ImportError`. This behavior is essential for preventing the application from starting with an invalid configuration.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that an exception is raised during the execution of the `load` method. This is a common pattern in unit testing for verifying that specific exceptions are thrown under certain conditions. The use of a descriptive test name also follows best practices, making it clear what the test is intended to validate."
    },
    {
      "name": "test_auto_env_prefix",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 76,
      "end_line_number": 80,
      "source_code": "def test_auto_env_prefix():\n    environ[\"SANIC_TEST_ANSWER\"] = \"42\"\n    app = Sanic(name=\"Test\")\n    assert app.config.TEST_ANSWER == 42\n    del environ[\"SANIC_TEST_ANSWER\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.config.TEST_ANSWER == 42"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_auto_env_prefix` function is designed to verify that the Sanic application correctly loads and converts environment variables prefixed with \"SANIC_\" into its configuration settings. Specifically, it checks that the environment variable `SANIC_TEST_ANSWER` is correctly interpreted as an integer value in the application's configuration.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the Sanic application can read an environment variable, convert its string value to an integer, and store it in the application's configuration under the key `TEST_ANSWER`. The expected outcome is that `app.config.TEST_ANSWER` should equal `42` after the environment variable is set.\n\n**Code Being Tested and How It Works**:  \nThe relevant code in the Sanic framework is responsible for loading environment variables into the application's configuration. When the application is instantiated, it checks for environment variables that match the expected prefix (in this case, \"SANIC_\"). The value of `SANIC_TEST_ANSWER`, which is set to the string \"42\", is converted to an integer and assigned to `app.config.TEST_ANSWER`. The test then asserts that this value is indeed `42`. After the assertion, the environment variable is deleted to clean up.\n\n**Notable Testing Patterns or Techniques Used**:  \nThis test employs a common pattern in unit testing where environment variables are temporarily set for the duration of the test. It uses assertions to verify that the application behaves as expected when these variables are present. Additionally, the test ensures that the environment is restored to its original state by deleting the variable after the assertion, which is a good practice to avoid side effects on other tests. This pattern of setup and teardown is crucial for maintaining test isolation and reliability."
    },
    {
      "name": "test_auto_bool_env_prefix",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 83,
      "end_line_number": 87,
      "source_code": "def test_auto_bool_env_prefix():\n    environ[\"SANIC_TEST_ANSWER\"] = \"True\"\n    app = Sanic(name=\"Test\")\n    assert app.config.TEST_ANSWER is True\n    del environ[\"SANIC_TEST_ANSWER\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.config.TEST_ANSWER is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_auto_bool_env_prefix` unit test is designed to verify that the Sanic application correctly interprets and loads boolean values from environment variables prefixed with \"SANIC_\". Specifically, it checks that the environment variable `SANIC_TEST_ANSWER` set to the string \"True\" is correctly converted to the boolean value `True` in the application's configuration.\n\n**Specific Functionality or Behavior Verified**:  \nThis test confirms that the Sanic framework's configuration system can automatically convert environment variable strings representing boolean values (\"True\" or \"False\") into actual Python boolean types. It ensures that the application correctly recognizes and processes the environment variable with the specified prefix.\n\n**Code Being Tested and How It Works**:  \nThe relevant code being tested is part of the Sanic application's configuration loading mechanism, which is responsible for reading environment variables and converting them into appropriate types based on predefined rules. In this case, the environment variable `SANIC_TEST_ANSWER` is set to \"True\", and the test asserts that `app.config.TEST_ANSWER` evaluates to `True`. The conversion logic is likely implemented in the `load_environment_vars` method of the `Config` class, which checks for environment variables that start with the specified prefix and applies type conversion.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward setup and teardown pattern by manipulating the `environ` dictionary to simulate the presence of an environment variable. It uses assertions to validate the expected outcome, ensuring that the application configuration reflects the correct boolean value. The test also cleans up by deleting the environment variable after the assertion, which is a good practice to avoid side effects on other tests. This approach ensures isolation and repeatability of the test."
    },
    {
      "name": "test_empty_load_env_prefix",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 91,
      "end_line_number": 95,
      "source_code": "def test_empty_load_env_prefix(env_prefix):\n    environ[\"SANIC_TEST_ANSWER\"] = \"42\"\n    app = Sanic(name=\"Test\", env_prefix=env_prefix)\n    assert getattr(app.config, \"TEST_ANSWER\", None) is None\n    del environ[\"SANIC_TEST_ANSWER\"]",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('env_prefix', [None, ''])"
      ],
      "arguments": [
        "env_prefix"
      ],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert getattr(app.config, 'TEST_ANSWER', None) is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_empty_load_env_prefix` test is designed to verify that when an environment variable prefixed with a specific `env_prefix` is not set, the corresponding configuration value in the Sanic application remains `None`. This ensures that the application does not inadvertently load any configuration values when the expected environment variable is absent.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `TEST_ANSWER` configuration attribute of the Sanic application is `None` when the environment variable `SANIC_TEST_ANSWER` is not loaded due to the absence of the specified `env_prefix`. It confirms that the application correctly respects the absence of the environment variable.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the Sanic application's configuration loading mechanism, which is expected to read environment variables prefixed with a specified string (in this case, `env_prefix`). The test sets an environment variable `SANIC_TEST_ANSWER` to \"42\" but does not use the `env_prefix` to load it into the app's configuration. After creating the Sanic app instance, the test asserts that `app.config.TEST_ANSWER` is `None`, indicating that the app did not load the value from the environment variable.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a setup-and-teardown pattern by manipulating the `environ` dictionary to simulate the presence and absence of environment variables. It uses assertions to validate the expected state of the application configuration. Additionally, the test is parameterized with `env_prefix`, allowing it to be run with different prefixes to ensure robustness in various scenarios. This approach helps in verifying that the application behaves correctly regardless of the prefix used."
    },
    {
      "name": "test_env_prefix",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 98,
      "end_line_number": 102,
      "source_code": "def test_env_prefix():\n    environ[\"MYAPP_TEST_ANSWER\"] = \"42\"\n    app = Sanic(name=\"Test\", env_prefix=\"MYAPP_\")\n    assert app.config.TEST_ANSWER == 42\n    del environ[\"MYAPP_TEST_ANSWER\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.config.TEST_ANSWER == 42"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_env_prefix` function is designed to verify that the Sanic application correctly reads and processes environment variables prefixed with a specified string (in this case, \"MYAPP_\"). It ensures that the application configuration can be populated from environment variables, which is a common practice for managing application settings.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the environment variable `MYAPP_TEST_ANSWER` is correctly interpreted as an integer value (42) and assigned to the application configuration under the key `TEST_ANSWER`. It confirms that the application can convert string representations of numbers from environment variables into their appropriate types.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the Sanic application instantiation with an `env_prefix` argument. When the application is created, it looks for environment variables that start with the specified prefix (\"MYAPP_\") and populates its configuration accordingly. The test sets the environment variable `MYAPP_TEST_ANSWER` to the string \"42\", creates a Sanic app instance, and then asserts that `app.config.TEST_ANSWER` equals the integer 42. After the assertion, it cleans up by deleting the environment variable.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a setup-and-teardown pattern by modifying the environment variable before the test and cleaning it up afterward. It uses direct assertions to validate the expected outcome, which is a straightforward approach in unit testing. The test also demonstrates the use of environment variables to influence application behavior, a common technique in configuration management for applications."
    },
    {
      "name": "test_env_prefix_float_values",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 105,
      "end_line_number": 109,
      "source_code": "def test_env_prefix_float_values():\n    environ[\"MYAPP_TEST_ROI\"] = \"2.3\"\n    app = Sanic(name=\"Test\", env_prefix=\"MYAPP_\")\n    assert app.config.TEST_ROI == 2.3\n    del environ[\"MYAPP_TEST_ROI\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.config.TEST_ROI == 2.3"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_env_prefix_float_values` test is designed to verify that the Sanic application correctly converts and assigns environment variable values to its configuration settings, specifically for float values.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when an environment variable (`MYAPP_TEST_ROI`) is set to a string representation of a float (`\"2.3\"`), the Sanic application correctly parses this string and assigns it as a float (`2.3`) to the corresponding configuration attribute (`app.config.TEST_ROI`).\n\n**Code Being Tested and How It Works**:  \nThe code under test is part of the Sanic framework's configuration loading mechanism, which automatically converts environment variable values into appropriate types (int, float, bool) based on their content. In this case, the `app.config` is expected to hydrate the `TEST_ROI` attribute from the environment variable `MYAPP_TEST_ROI` by converting the string `\"2.3\"` into the float `2.3`. The test sets the environment variable, initializes the Sanic app with the specified prefix, checks the value, and then cleans up by deleting the environment variable.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward setup-assert-teardown pattern. It sets up the environment variable before creating the app instance, asserts the expected outcome, and then cleans up by deleting the environment variable. This ensures that the test does not have side effects on subsequent tests. Additionally, the use of assertions to validate the expected state of the application configuration is a common practice in unit testing to ensure correctness."
    },
    {
      "name": "test_env_prefix_string_value",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 112,
      "end_line_number": 116,
      "source_code": "def test_env_prefix_string_value():\n    environ[\"MYAPP_TEST_TOKEN\"] = \"somerandomtesttoken\"\n    app = Sanic(name=\"Test\", env_prefix=\"MYAPP_\")\n    assert app.config.TEST_TOKEN == \"somerandomtesttoken\"\n    del environ[\"MYAPP_TEST_TOKEN\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.config.TEST_TOKEN == 'somerandomtesttoken'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_env_prefix_string_value` test is designed to verify that the Sanic application correctly reads and applies configuration values from environment variables, specifically when using a defined prefix for those variables.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the Sanic application can retrieve a string value from an environment variable prefixed with \"MYAPP_\" and correctly assign it to the application's configuration attribute `TEST_TOKEN`. It ensures that the application can handle string values from the environment as expected.\n\n**Code Being Tested and How It Works**:  \nThe relevant code being tested is the Sanic application's configuration handling mechanism. When the application is instantiated with the `env_prefix` parameter set to \"MYAPP_\", it looks for environment variables that start with this prefix. In this case, the environment variable `MYAPP_TEST_TOKEN` is set to \"somerandomtesttoken\". The test asserts that `app.config.TEST_TOKEN` retrieves this value correctly. After the assertion, the environment variable is deleted to clean up the test environment.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Environment Manipulation**: The test temporarily sets an environment variable to simulate the application's behavior in a real-world scenario where configuration values are often sourced from the environment.\n- **Assertion**: The test uses a simple assertion to verify that the expected value matches the actual value retrieved from the application configuration.\n- **Cleanup**: The test includes a cleanup step by deleting the environment variable after the test runs, ensuring that the test does not affect subsequent tests or the environment."
    },
    {
      "name": "test_env_w_custom_converter",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 119,
      "end_line_number": 126,
      "source_code": "def test_env_w_custom_converter():\n    environ[\"SANIC_TEST_ANSWER\"] = \"42\"\n\n    config = Config(converters=[UltimateAnswer])\n    app = Sanic(name=\"Test\", config=config)\n    assert isinstance(app.config.TEST_ANSWER, UltimateAnswer)\n    assert app.config.TEST_ANSWER.answer == 42\n    del environ[\"SANIC_TEST_ANSWER\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(app.config.TEST_ANSWER, UltimateAnswer)",
        "assert app.config.TEST_ANSWER.answer == 42"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_env_w_custom_converter` unit test is designed to verify that the Sanic application correctly processes environment variables using a custom converter. Specifically, it checks that the environment variable `SANIC_TEST_ANSWER` is converted into an instance of the `UltimateAnswer` class, which encapsulates the integer value 42.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when the environment variable `SANIC_TEST_ANSWER` is set to \"42\", the Sanic application correctly interprets this value using the provided custom converter (`UltimateAnswer`). It verifies that the resulting configuration value is indeed an instance of `UltimateAnswer` and that the `answer` attribute of this instance equals 42.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the Sanic application configuration system, particularly how it handles environment variables and custom converters. The `Config` class is instantiated with a list of converters, including `UltimateAnswer`. When the Sanic app is created, it reads the environment variable, applies the converter, and stores the result in the app's configuration. The assertions check the type and value of the configuration property `TEST_ANSWER`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of environment variable manipulation to simulate different configurations for the Sanic application. It uses assertions to validate the expected outcomes, ensuring that the application behaves correctly when custom converters are applied. Additionally, the test cleans up by deleting the environment variable after the assertions, which is a good practice to avoid side effects on other tests."
    },
    {
      "name": "test_env_lowercase",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 129,
      "end_line_number": 133,
      "source_code": "def test_env_lowercase():\n    environ[\"SANIC_test_answer\"] = \"42\"\n    app = Sanic(name=\"Test\")\n    assert \"test_answer\" not in app.config\n    del environ[\"SANIC_test_answer\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'test_answer' not in app.config"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_env_lowercase` function is designed to verify that environment variables with lowercase names do not automatically populate the application configuration in the Sanic framework. Specifically, it checks that the variable `SANIC_test_answer` does not result in a configuration entry for `test_answer`.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the Sanic application does not interpret environment variables in a case-insensitive manner when loading configuration values. It confirms that the lowercase environment variable `SANIC_test_answer` does not create a corresponding entry in the `app.config` dictionary.\n\n**Code Being Tested and How It Works**:  \nThe test sets an environment variable `SANIC_test_answer` to the string \"42\" and then initializes a Sanic application instance. After the application is created, the test asserts that the key `test_answer` is not present in the application's configuration (`app.config`). Finally, it cleans up by deleting the environment variable. The relevant code from the Sanic framework is likely responsible for loading environment variables into the configuration, which is expected to be case-sensitive.\n\n**Notable Testing Patterns or Techniques Used**:  \nThis test employs a common pattern in unit testing where environment variables are manipulated to simulate different configurations without altering the actual application code. It also demonstrates the use of assertions to validate expected outcomes, ensuring that the application behaves correctly under specific conditions. The cleanup step (deleting the environment variable) is a good practice to prevent side effects on other tests."
    },
    {
      "name": "test_add_converter_multiple_times",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 136,
      "end_line_number": 148,
      "source_code": "def test_add_converter_multiple_times(caplog):\n    def converter(): ...\n\n    message = (\n        \"Configuration value converter 'converter' has already been registered\"\n    )\n    config = Config()\n    config.register_type(converter)\n    with caplog.at_level(logging.WARNING):\n        config.register_type(converter)\n\n    assert (\"sanic.error\", logging.WARNING, message) in caplog.record_tuples\n    assert len(config._converters) == 5",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "caplog"
      ],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert ('sanic.error', logging.WARNING, message) in caplog.record_tuples",
        "assert len(config._converters) == 5"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_add_converter_multiple_times` is designed to verify that the `Config` class correctly handles the registration of a converter function that has already been registered. It ensures that the system logs a warning when an attempt is made to register the same converter multiple times.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main behaviors: \n1. It verifies that a warning message is logged when a converter is registered more than once.\n2. It confirms that the total number of converters in the configuration remains unchanged (specifically, it checks that there are 5 converters after the duplicate registration attempt).\n\n**Code Being Tested and How It Works**:  \nThe relevant code being tested is the `register_type` method of the `Config` class. This method is responsible for adding a converter function to the internal list of converters (`self._converters`). If the converter is already present in this list, it logs a warning message and does not add it again. The test first registers a converter, then attempts to register it again while capturing log output. The expected behavior is that the warning message is logged, and the count of converters remains the same.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `caplog` fixture from pytest to capture log messages generated during the test execution. This allows for verification of logging behavior without needing to inspect the log output manually. Additionally, the test uses assertions to check both the presence of the warning message in the log records and the length of the `_converters` list, demonstrating a clear and effective approach to validating multiple aspects of the functionality being tested."
    },
    {
      "name": "test_load_from_file",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 151,
      "end_line_number": 167,
      "source_code": "def test_load_from_file(app: Sanic):\n    config = dedent(\n        \"\"\"\n    VALUE = 'some value'\n    condition = 1 == 1\n    if condition:\n        CONDITIONAL = 'should be set'\n    \"\"\"\n    )\n    with temp_path() as config_path:\n        config_path.write_text(config)\n        app.config.load(str(config_path))\n        assert \"VALUE\" in app.config\n        assert app.config.VALUE == \"some value\"\n        assert \"CONDITIONAL\" in app.config\n        assert app.config.CONDITIONAL == \"should be set\"\n        assert \"condition\" not in app.config",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'VALUE' in app.config",
        "assert app.config.VALUE == 'some value'",
        "assert 'CONDITIONAL' in app.config",
        "assert app.config.CONDITIONAL == 'should be set'",
        "assert 'condition' not in app.config"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "temp_path",
          "body": "@contextmanager\ndef temp_path():\n    \"\"\"a simple cross platform replacement for NamedTemporaryFile\"\"\"\n    with TemporaryDirectory() as td:\n        yield Path(td, 'file')"
        },
        {
          "name": "app.config.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_load_from_file` function is designed to verify that the Sanic application's configuration can be correctly loaded from a file. It ensures that the expected configuration values are set and that any conditions in the configuration file are properly evaluated.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that:\n1. The configuration value `VALUE` is present and correctly set to `'some value'`.\n2. The conditional configuration value `CONDITIONAL` is set when the condition evaluates to `True`.\n3. The variable `condition` is not included in the application configuration, demonstrating that only explicitly defined configuration variables are loaded.\n\n**Code Being Tested and How It Works**:  \nThe test uses a temporary file created by the `temp_path` context manager to store the configuration. The `app.config.load` method is called with the path to this temporary file, which reads the configuration. The assertions then check the presence and values of the expected configuration variables in the `app.config` object. The relevant code being tested is the `load` method of the `app.config` object, which processes the configuration file and populates the application's configuration.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Manager**: The use of `temp_path` as a context manager allows for the creation and automatic cleanup of a temporary file, ensuring that the test environment remains clean.\n- **Assertions**: The test employs multiple assertions to validate the state of the application configuration after loading, which is a common practice in unit testing to ensure that all expected outcomes are verified.\n- **Conditional Logic Testing**: The test effectively demonstrates how to verify the behavior of conditional logic within configuration files, ensuring that only the intended variables are loaded based on the conditions defined."
    },
    {
      "name": "test_load_from_missing_file",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 170,
      "end_line_number": 172,
      "source_code": "def test_load_from_missing_file(app: Sanic):\n    with pytest.raises(IOError):\n        app.config.load(\"non-existent file\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.config.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_load_from_missing_file` unit test is designed to verify that the `load` method of the `app.config` object raises an `IOError` when attempting to load a configuration from a non-existent file. This ensures that the application handles file loading errors gracefully and provides appropriate feedback.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks for the correct exception type (`IOError`) when the `load` method is called with a file path that does not exist. This behavior is crucial for maintaining robustness in the application, as it prevents the application from proceeding with invalid configurations.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `load` method of the `app.config` object. The method attempts to load configuration data from a specified file. If the file does not exist, it is expected to raise an `IOError`. The test simulates this scenario by passing a string representing a non-existent file to the `load` method, thereby triggering the exception.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that an exception is raised during the execution of the code block. This is a common pattern in unit testing that allows for clean and readable exception handling tests. Additionally, the test is structured to be concise, focusing solely on the expected outcome without unnecessary complexity, which is a hallmark of effective unit tests."
    },
    {
      "name": "test_load_from_envvar",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 175,
      "end_line_number": 182,
      "source_code": "def test_load_from_envvar(app: Sanic):\n    config = \"VALUE = 'some value'\"\n    with temp_path() as config_path:\n        config_path.write_text(config)\n        environ[\"APP_CONFIG\"] = str(config_path)\n        app.config.load(\"${APP_CONFIG}\")\n        assert \"VALUE\" in app.config\n        assert app.config.VALUE == \"some value\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'VALUE' in app.config",
        "assert app.config.VALUE == 'some value'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "temp_path",
          "body": "@contextmanager\ndef temp_path():\n    \"\"\"a simple cross platform replacement for NamedTemporaryFile\"\"\"\n    with TemporaryDirectory() as td:\n        yield Path(td, 'file')"
        },
        {
          "name": "app.config.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:\nThe `test_load_from_envvar` function is designed to verify that the Sanic application can correctly load configuration settings from an environment variable that points to a configuration file. This ensures that the application can dynamically configure itself based on the environment in which it is running.\n\n**Specific Functionality or Behavior Verified**:\nThe test checks that when a configuration file is specified via an environment variable (`APP_CONFIG`), the application successfully loads the configuration defined in that file. Specifically, it verifies that the key \"VALUE\" is present in the application's configuration and that its value matches the expected string \"some value\".\n\n**Code Being Tested and How It Works**:\nThe test utilizes a context manager `temp_path` to create a temporary file that simulates a configuration file. The configuration file contains a single line defining `VALUE`. The environment variable `APP_CONFIG` is set to the path of this temporary file. The method `app.config.load(\"${APP_CONFIG}\")` is then called, which is expected to read the configuration from the specified file. After loading, assertions are made to confirm that the configuration has been loaded correctly.\n\n**Notable Testing Patterns or Techniques Used**:\n- **Context Manager**: The use of `temp_path` as a context manager allows for the creation and automatic cleanup of a temporary file, ensuring that the test environment remains clean.\n- **Environment Variable Manipulation**: The test temporarily sets an environment variable to simulate different configurations without modifying the global environment permanently.\n- **Assertions**: The test employs assertions to validate the expected outcomes, ensuring that the configuration loading behaves as intended.\n- **Isolation**: The test is isolated from other tests, as it uses a temporary file and environment variable, preventing side effects on other tests that may run in the same environment."
    },
    {
      "name": "test_load_from_missing_envvar",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 185,
      "end_line_number": 192,
      "source_code": "def test_load_from_missing_envvar(app: Sanic):\n    with pytest.raises(IOError) as e:\n        app.config.load(\"non-existent variable\")\n        assert str(e.value) == (\n            \"The environment variable 'non-existent \"\n            \"variable' is not set and thus configuration \"\n            \"could not be loaded.\"\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(e.value) == \"The environment variable 'non-existent variable' is not set and thus configuration could not be loaded.\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.config.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_load_from_missing_envvar` unit test is designed to verify that the application correctly raises an `IOError` when attempting to load a configuration from a non-existent environment variable. This ensures that the application handles missing environment variables gracefully and provides a clear error message.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that when the `app.config.load` method is called with a string representing a non-existent environment variable, it raises an `IOError`. Additionally, it verifies that the error message returned is informative and matches the expected format, indicating that the variable is not set.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `load` method of the `app.config` object. This method is expected to attempt to load configuration settings based on the provided input. If the input refers to an environment variable that does not exist, the method should raise an `IOError` with a specific message. The relevant part of the code is:\n```python\napp.config.load(\"non-existent variable\")\n```\nThis line simulates the scenario where the application tries to load a configuration from an environment variable that is not defined.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that an exception is raised during the execution of the code block. This is a common pattern in unit testing for verifying that specific exceptions are thrown under certain conditions. Additionally, the test includes an assertion to check the content of the exception message, ensuring that it provides the expected feedback to the user. This combination of exception handling and message verification enhances the robustness of the test."
    },
    {
      "name": "test_load_config_from_file_invalid_syntax",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 195,
      "end_line_number": 201,
      "source_code": "def test_load_config_from_file_invalid_syntax(app: Sanic):\n    config = \"VALUE = some value\"\n    with temp_path() as config_path:\n        config_path.write_text(config)\n\n        with pytest.raises(PyFileError):\n            app.config.load(config_path)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "temp_path",
          "body": "@contextmanager\ndef temp_path():\n    \"\"\"a simple cross platform replacement for NamedTemporaryFile\"\"\"\n    with TemporaryDirectory() as td:\n        yield Path(td, 'file')"
        },
        {
          "name": "app.config.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:\nThe primary purpose of the `test_load_config_from_file_invalid_syntax` test is to verify that the configuration loading mechanism in the Sanic application correctly raises an error when the configuration file contains invalid syntax. This ensures that the application can handle erroneous configurations gracefully and prevents runtime issues due to misconfigured settings.\n\n**Specific Functionality or Behavior Verified**:\nThis test specifically checks that when a configuration file is loaded with invalid syntax (in this case, a missing quotation mark around a string value), the application raises a `PyFileError`. This behavior is crucial for maintaining the integrity of the application's configuration and ensuring that only valid configurations are accepted.\n\n**Code Being Tested and How It Works**:\nThe code being tested is the `app.config.load` method, which is responsible for loading configuration settings from a specified file. In the test, a temporary file is created with invalid syntax (`\"VALUE = some value\"`), and the `load` method is called with the path to this file. The expectation is that the method will raise a `PyFileError`, indicating that the syntax of the configuration file is not valid.\n\n**Notable Testing Patterns or Techniques Used**:\n1. **Context Manager**: The test uses a context manager (`temp_path`) to create a temporary file for the configuration. This ensures that the file is automatically cleaned up after the test, promoting good resource management.\n2. **Exception Assertion**: The test employs `pytest.raises` to assert that a specific exception (`PyFileError`) is raised during the execution of the `load` method. This is a common pattern in unit testing to verify that error handling works as expected.\n3. **Isolation**: The test is isolated from other tests, as it creates its own temporary configuration file, ensuring that it does not interfere with the state of the application or other tests. \n\nOverall, this test is a clear example of how to validate error handling in configuration loading, ensuring robustness in the application's configuration management."
    },
    {
      "name": "test_overwrite_exisiting_config",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 204,
      "end_line_number": 211,
      "source_code": "def test_overwrite_exisiting_config(app: Sanic):\n    app.config.DEFAULT = 1\n\n    class Config:\n        DEFAULT = 2\n\n    app.config.load(Config)\n    assert app.config.DEFAULT == 2",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.config.DEFAULT == 2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.config.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_overwrite_exisiting_config` is designed to verify that the configuration loading mechanism in the Sanic application correctly overwrites existing configuration values when a new configuration class is loaded.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a configuration class (`Config`) with a `DEFAULT` attribute is loaded into the application, it successfully replaces the previously set value of `app.config.DEFAULT`. The expected outcome is that after loading the new configuration, `app.config.DEFAULT` should equal `2`.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `load` method of the `app.config` object, which is responsible for loading configuration settings from a given class. Initially, `app.config.DEFAULT` is set to `1`. The `Config` class is defined with a `DEFAULT` attribute set to `2`. When `app.config.load(Config)` is called, it should overwrite the existing `DEFAULT` value with the new one from the `Config` class. The assertion `assert app.config.DEFAULT == 2` checks if this behavior is correctly implemented.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern to validate the expected outcome after a configuration change. It uses a class-based configuration approach, which is a common pattern in applications that require flexible and dynamic configuration management. The test also demonstrates the use of a simple setup where the initial state is modified, and the outcome is verified, which is a fundamental aspect of unit testing."
    },
    {
      "name": "test_overwrite_exisiting_config_ignore_lowercase",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 214,
      "end_line_number": 221,
      "source_code": "def test_overwrite_exisiting_config_ignore_lowercase(app: Sanic):\n    app.config.default = 1\n\n    class Config:\n        default = 2\n\n    app.config.load(Config)\n    assert app.config.default == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.config.default == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.config.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_overwrite_exisiting_config_ignore_lowercase` is designed to verify that the configuration loading mechanism in the Sanic application correctly ignores case sensitivity when overwriting existing configuration values. Specifically, it checks that a configuration value set directly on the app instance remains unchanged after loading a new configuration class.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a configuration class (`Config`) is loaded that contains a value for `default`, it does not overwrite the existing value set directly on the app instance (`app.config.default`). The expected behavior is that the app's configuration retains the value of `1`, despite the presence of a conflicting value of `2` in the `Config` class.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `app.config.load` method, which is responsible for loading configuration settings from a given class. In this test, `app.config.default` is initially set to `1`. A new configuration class `Config` is defined with `default` set to `2`. When `app.config.load(Config)` is called, it should not change the existing `default` value of `1`. The assertion `assert app.config.default == 1` checks that the value remains unchanged after loading the new configuration.\n\n**Notable Testing Patterns or Techniques Used**:  \nThis test employs a straightforward assertion pattern to validate the expected outcome. It uses a class-based configuration to simulate loading new settings, which is a common practice in configuration management. The test also demonstrates the principle of isolation by ensuring that the test's outcome is not affected by external factors, focusing solely on the behavior of the configuration loading mechanism. Additionally, the naming of the test function follows a descriptive pattern, indicating its purpose clearly, which is a good practice in unit testing."
    },
    {
      "name": "test_missing_config",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 224,
      "end_line_number": 226,
      "source_code": "def test_missing_config(app: Sanic):\n    with pytest.raises(AttributeError, match=\"Config has no 'NON_EXISTENT'\"):\n        _ = app.config.NON_EXISTENT",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_missing_config` function is designed to verify that an attempt to access a non-existent configuration attribute in the `Sanic` application raises an `AttributeError`. This ensures that the application correctly handles cases where a requested configuration key is not defined.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that when the attribute `NON_EXISTENT` is accessed on the `app.config` object, it raises an `AttributeError` with a message indicating that the configuration does not contain the specified key. This behavior is crucial for maintaining robust error handling in the application.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the configuration management system of the `Sanic` application. When `app.config.NON_EXISTENT` is accessed, the underlying implementation should check for the existence of the attribute. If it does not exist, it raises an `AttributeError`. The test uses the `pytest.raises` context manager to assert that this exception is raised, and it checks that the exception message matches the expected string.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager, which is a common pattern in unit testing for asserting that specific exceptions are raised during the execution of a block of code. Additionally, the use of the `match` parameter allows for verifying that the exception message contains the expected text, ensuring that not only the exception type is correct but also the context of the error is accurately reported. This enhances the reliability of the test by confirming both the occurrence and the reason for the failure."
    },
    {
      "name": "test_config_defaults",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 229,
      "end_line_number": 235,
      "source_code": "def test_config_defaults():\n    \"\"\"\n    load DEFAULT_CONFIG\n    \"\"\"\n    conf = Config()\n    for key, value in DEFAULT_CONFIG.items():\n        assert getattr(conf, key) == value",
      "docstring": "load DEFAULT_CONFIG",
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert getattr(conf, key) == value"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_config_defaults` function is designed to verify that the default configuration values defined in `DEFAULT_CONFIG` are correctly loaded into an instance of the `Config` class. This ensures that the application starts with the expected default settings.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that each key in the `DEFAULT_CONFIG` dictionary corresponds to an attribute in the `Config` instance, and that the value of that attribute matches the expected value from `DEFAULT_CONFIG`. This confirms that the configuration loading mechanism is functioning as intended.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `Config` class, which is expected to have attributes that align with the keys in the `DEFAULT_CONFIG` dictionary. The test creates an instance of `Config` and iterates over the items in `DEFAULT_CONFIG`, using `getattr` to retrieve the value of each attribute dynamically. The assertion checks that the retrieved value matches the expected value from `DEFAULT_CONFIG`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Dynamic Attribute Access**: The use of `getattr` allows for flexible access to attributes based on the keys in `DEFAULT_CONFIG`, making the test adaptable to changes in the configuration structure.\n- **Iterative Validation**: The test employs a loop to validate multiple attributes in a single test case, which is efficient and keeps the test concise.\n- **Assertion**: The use of `assert` statements provides a straightforward way to verify that the actual values match the expected values, which is a common practice in unit testing to ensure correctness."
    },
    {
      "name": "test_config_custom_defaults",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 238,
      "end_line_number": 253,
      "source_code": "def test_config_custom_defaults():\n    \"\"\"\n    we should have all the variables from defaults rewriting them with\n    custom defaults passed in\n    Config\n    \"\"\"\n    custom_defaults = {\n        \"REQUEST_MAX_SIZE\": 1,\n        \"KEEP_ALIVE\": False,\n        \"ACCESS_LOG\": False,\n    }\n    conf = Config(defaults=custom_defaults)\n    for key, value in DEFAULT_CONFIG.items():\n        if key in custom_defaults.keys():\n            value = custom_defaults[key]\n        assert getattr(conf, key) == value",
      "docstring": "we should have all the variables from defaults rewriting them with\ncustom defaults passed in\nConfig",
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert getattr(conf, key) == value"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_config_custom_defaults` unit test is designed to verify that when a `Config` object is initialized with custom default values, these values correctly overwrite the corresponding default values defined in `DEFAULT_CONFIG`. This ensures that the configuration system behaves as expected when custom settings are provided.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that each configuration variable in `DEFAULT_CONFIG` is present in the `Config` instance and that its value matches either the default value or the custom value if it has been specified. This confirms that the custom defaults are effectively applied and that the configuration system can handle overrides correctly.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `Config` class, which is initialized with a dictionary of custom defaults. The test iterates over the `DEFAULT_CONFIG` dictionary, checking if each key exists in the `custom_defaults`. If it does, the test uses the value from `custom_defaults`; otherwise, it uses the value from `DEFAULT_CONFIG`. The assertion `assert getattr(conf, key) == value` ensures that the value retrieved from the `Config` instance matches the expected value.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a parameterized approach by iterating through a dictionary of default configurations, which allows for concise and scalable verification of multiple configuration settings in a single test. It also uses assertions to validate the state of the `Config` object, which is a common practice in unit testing to ensure that the code behaves as intended. The use of a docstring to describe the test's purpose enhances readability and maintainability."
    },
    {
      "name": "test_config_custom_defaults_with_env",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 256,
      "end_line_number": 289,
      "source_code": "def test_config_custom_defaults_with_env():\n    \"\"\"\n    test that environment variables has higher priority than DEFAULT_CONFIG\n    and passed defaults dict\n    \"\"\"\n    custom_defaults = {\n        \"REQUEST_MAX_SIZE123\": 1,\n        \"KEEP_ALIVE123\": False,\n        \"ACCESS_LOG123\": False,\n    }\n\n    environ_defaults = {\n        \"SANIC_REQUEST_MAX_SIZE123\": \"2\",\n        \"SANIC_KEEP_ALIVE123\": \"True\",\n        \"SANIC_ACCESS_LOG123\": \"False\",\n    }\n\n    for key, value in environ_defaults.items():\n        environ[key] = value\n\n    conf = Config(defaults=custom_defaults)\n    for key, value in DEFAULT_CONFIG.items():\n        if \"SANIC_\" + key in environ_defaults.keys():\n            value = environ_defaults[\"SANIC_\" + key]\n            try:\n                value = int(value)\n            except ValueError:\n                if value in [\"True\", \"False\"]:\n                    value = value == \"True\"\n\n        assert getattr(conf, key) == value\n\n    for key, value in environ_defaults.items():\n        del environ[key]",
      "docstring": "test that environment variables has higher priority than DEFAULT_CONFIG\nand passed defaults dict",
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert getattr(conf, key) == value"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_config_custom_defaults_with_env` test is to verify that environment variables take precedence over default configuration values and any custom defaults provided when initializing the `Config` object. This ensures that the application can be configured dynamically based on the environment in which it is running.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that when environment variables are set, they correctly override the values defined in the `DEFAULT_CONFIG` and the `custom_defaults` dictionary. It ensures that the configuration system behaves as expected when different sources of configuration are provided.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `Config` class, which is responsible for managing application configuration. The test sets up a dictionary of custom defaults and a dictionary of environment variables. It populates the environment with these variables, creates a `Config` instance with the custom defaults, and then iterates over the keys in `DEFAULT_CONFIG`. For each key, it checks if there is a corresponding environment variable. If so, it attempts to convert the value to the appropriate type (int or bool) and asserts that the value in the `Config` instance matches the expected value. After the assertions, it cleans up by deleting the environment variables.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Setup and Teardown**: It modifies the environment variables at the beginning of the test and cleans them up afterward to avoid side effects on other tests.\n- **Dynamic Assertions**: The test dynamically checks each configuration key against the expected value, allowing it to validate multiple configuration settings in a single test case.\n- **Type Conversion Handling**: The test includes logic to handle type conversion for integers and booleans, demonstrating robust testing of the configuration system's ability to interpret different types of input correctly."
    },
    {
      "name": "test_config_access_log_passing_in_run",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 293,
      "end_line_number": 301,
      "source_code": "def test_config_access_log_passing_in_run(app: Sanic, access_log):\n    assert app.config.ACCESS_LOG is False\n\n    @app.listener(\"after_server_start\")\n    async def _request(sanic, loop):\n        app.stop()\n\n    app.run(port=1340, access_log=access_log, single_process=True)\n    assert app.config.ACCESS_LOG is access_log",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('access_log', (True, False))"
      ],
      "arguments": [
        "app",
        "access_log"
      ],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.config.ACCESS_LOG is False",
        "assert app.config.ACCESS_LOG is access_log"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_config_access_log_passing_in_run` test is to verify that the `access_log` configuration setting in the Sanic application behaves correctly when passed as an argument during the application's run method. Specifically, it checks that the application starts with the expected access log setting and that this setting is correctly applied.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the `ACCESS_LOG` configuration attribute of the Sanic application reflects the value passed to the `app.run()` method. It asserts that the initial value of `ACCESS_LOG` is `False` and then checks that after running the application with a specified `access_log` value, the configuration is updated to match that value.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `app.run()` method, which is responsible for starting the Sanic server. The method takes an `access_log` parameter that determines whether access logging is enabled. The test first asserts that `app.config.ACCESS_LOG` is `False`, indicating that logging is disabled by default. After running the server with the specified `access_log` value, it asserts that `app.config.ACCESS_LOG` matches the value passed to `app.run()`, confirming that the configuration was updated correctly.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the state of the application before and after the server is run. It also utilizes an asynchronous listener (`after_server_start`) to stop the application immediately after it starts, ensuring that the test does not hang indefinitely. The use of parameterization (`@pytest.mark.parametrize`) allows the test to be run multiple times with different values for `access_log`, enhancing coverage and ensuring that both `True` and `False` cases are tested efficiently."
    },
    {
      "name": "test_config_rewrite_keep_alive",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 323,
      "end_line_number": 335,
      "source_code": "def test_config_rewrite_keep_alive():\n    config = Config()\n    assert config.KEEP_ALIVE == DEFAULT_CONFIG[\"KEEP_ALIVE\"]\n    config = Config(keep_alive=True)\n    assert config.KEEP_ALIVE is True\n    config = Config(keep_alive=False)\n    assert config.KEEP_ALIVE is False\n\n    # use defaults\n    config = Config(defaults={\"KEEP_ALIVE\": False})\n    assert config.KEEP_ALIVE is False\n    config = Config(defaults={\"KEEP_ALIVE\": True})\n    assert config.KEEP_ALIVE is True",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert config.KEEP_ALIVE == DEFAULT_CONFIG['KEEP_ALIVE']",
        "assert config.KEEP_ALIVE is True",
        "assert config.KEEP_ALIVE is False",
        "assert config.KEEP_ALIVE is False",
        "assert config.KEEP_ALIVE is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_config_rewrite_keep_alive` function is designed to verify the behavior of the `Config` class regarding the `KEEP_ALIVE` setting. It ensures that the configuration can be correctly initialized with default values, as well as with explicit values provided during instantiation.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. The default value of `KEEP_ALIVE` matches a predefined constant (`DEFAULT_CONFIG[\"KEEP_ALIVE\"]`).\n2. The `KEEP_ALIVE` setting can be explicitly set to `True` or `False` when creating a `Config` instance.\n3. The `KEEP_ALIVE` setting can also be overridden using a `defaults` dictionary during instantiation.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `Config` class, which presumably manages application configuration settings. The test creates instances of `Config` with various parameters:\n- The first instance uses the default constructor to check the default value.\n- Subsequent instances use the `keep_alive` parameter to set the value directly.\n- Finally, it tests the ability to set `KEEP_ALIVE` through a `defaults` dictionary, ensuring that the configuration behaves as expected in all scenarios.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs straightforward assertions to validate expected outcomes, which is a common pattern in unit testing. It uses the `assert` statement to check conditions, which is a simple yet effective way to verify that the code behaves as intended. The test also demonstrates the practice of isolating configuration behavior, ensuring that different ways of setting the same configuration option yield consistent results."
    },
    {
      "name": "test_update",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 354,
      "end_line_number": 356,
      "source_code": "def test_update(app: Sanic, conf_object):\n    app.update_config(conf_object)\n    assert app.config[\"TEST_SETTING_VALUE\"] == 1",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('conf_object', [_test_setting_as_dict, _test_setting_as_class, _test_setting_as_module], ids=['from_dict', 'from_class', 'from_file'])"
      ],
      "arguments": [
        "app",
        "conf_object"
      ],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.config['TEST_SETTING_VALUE'] == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_update` function is designed to verify that the `update_config` method of the `Sanic` application correctly updates the application's configuration settings when provided with various types of configuration objects (dictionary, class, or module).\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that after calling `update_config` with a configuration object, the value of the setting `TEST_SETTING_VALUE` in the application's configuration is set to `1`. This ensures that the configuration update mechanism is functioning as expected.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `update_config` method of the `Sanic` application. This method is responsible for processing the provided configuration object, filtering out keys that do not meet certain criteria (in this case, only uppercase keys are retained), and updating the application's internal configuration dictionary. The test asserts that the expected configuration value is present after the update, confirming that the method correctly interprets and applies the configuration settings.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs parameterized testing using `pytest.mark.parametrize`, which allows it to run the same test logic with different input configurations (a dictionary, a class, and a module). This technique enhances test coverage and ensures that the `update_config` method behaves correctly across various input types without duplicating code. Additionally, the use of assertions to validate the expected state of the application configuration is a standard practice in unit testing, ensuring that the test fails if the actual behavior does not match the expected outcome."
    },
    {
      "name": "test_update_from_lowercase_key",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 359,
      "end_line_number": 362,
      "source_code": "def test_update_from_lowercase_key(app: Sanic):\n    d = {\"test_setting_value\": 1}\n    app.update_config(d)\n    assert \"test_setting_value\" not in app.config",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'test_setting_value' not in app.config"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_update_from_lowercase_key` test is to verify that when a configuration setting is updated using a lowercase key, the setting is not added to the application's configuration. This ensures that the application correctly handles case sensitivity in configuration keys.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the key `\"test_setting_value\"` is not present in the `app.config` after calling `app.update_config(d)`, where `d` contains the key in lowercase. This behavior is crucial for maintaining the integrity of the configuration system, particularly in environments where case sensitivity is important.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `update_config` method of the `Sanic` application instance. The method is expected to update the application's configuration with the provided dictionary. However, the test asserts that the key `\"test_setting_value\"` is not included in the configuration after the update, indicating that the method may ignore or handle lowercase keys differently, possibly due to a design choice or a requirement in the configuration management.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion to validate the expected state of the configuration after an operation. It uses the `assert` statement to check for the absence of the key in the configuration, which is a common pattern in unit testing to verify outcomes. The test is also structured to be simple and focused, which is a best practice in unit testing, allowing for easy identification of failures and clear understanding of the test's intent."
    },
    {
      "name": "test_config_set_methods",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 365,
      "end_line_number": 409,
      "source_code": "def test_config_set_methods(app: Sanic, monkeypatch: MonkeyPatch):\n    post_set = Mock()\n    monkeypatch.setattr(Config, \"_post_set\", post_set)\n\n    app.config.FOO = 1\n    post_set.assert_called_once_with(\"FOO\", 1)\n    post_set.reset_mock()\n\n    app.config[\"FOO\"] = 2\n    post_set.assert_called_once_with(\"FOO\", 2)\n    post_set.reset_mock()\n\n    app.config.update({\"FOO\": 3})\n    post_set.assert_called_once_with(\"FOO\", 3)\n    post_set.reset_mock()\n\n    app.config.update([(\"FOO\", 4)])\n    post_set.assert_called_once_with(\"FOO\", 4)\n    post_set.reset_mock()\n\n    app.config.update(FOO=5)\n    post_set.assert_called_once_with(\"FOO\", 5)\n    post_set.reset_mock()\n\n    app.config.update({\"FOO\": 6}, {\"BAR\": 7})\n    post_set.assert_has_calls(\n        calls=[\n            call(\"FOO\", 6),\n            call(\"BAR\", 7),\n        ]\n    )\n    post_set.reset_mock()\n\n    app.config.update({\"FOO\": 8}, BAR=9)\n    post_set.assert_has_calls(\n        calls=[\n            call(\"FOO\", 8),\n            call(\"BAR\", 9),\n        ],\n        any_order=True,\n    )\n    post_set.reset_mock()\n\n    app.config.update_config({\"FOO\": 10})\n    post_set.assert_called_once_with(\"FOO\", 10)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "monkeypatch"
      ],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "post_set.reset_mock",
          "body": "def reset_mock(self, *args, **kwargs):\n    super().reset_mock(*args, **kwargs)\n    self.await_count = 0"
        },
        {
          "name": "post_set.reset_mock",
          "body": "def reset_mock(self, *args, **kwargs):\n    super().reset_mock(*args, **kwargs)\n    self.await_count = 0"
        },
        {
          "name": "post_set.reset_mock",
          "body": "def reset_mock(self, *args, **kwargs):\n    super().reset_mock(*args, **kwargs)\n    self.await_count = 0"
        },
        {
          "name": "post_set.reset_mock",
          "body": "def reset_mock(self, *args, **kwargs):\n    super().reset_mock(*args, **kwargs)\n    self.await_count = 0"
        },
        {
          "name": "post_set.reset_mock",
          "body": "def reset_mock(self, *args, **kwargs):\n    super().reset_mock(*args, **kwargs)\n    self.await_count = 0"
        },
        {
          "name": "post_set.reset_mock",
          "body": "def reset_mock(self, *args, **kwargs):\n    super().reset_mock(*args, **kwargs)\n    self.await_count = 0"
        },
        {
          "name": "post_set.reset_mock",
          "body": "def reset_mock(self, *args, **kwargs):\n    super().reset_mock(*args, **kwargs)\n    self.await_count = 0"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_config_set_methods` function is designed to verify that the configuration settings of a Sanic application correctly trigger the `_post_set` method whenever a configuration value is set or updated. This ensures that any necessary side effects or additional logic associated with changing configuration values are executed as expected.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks multiple ways of setting a configuration value (direct assignment, dictionary updates, and keyword arguments) and confirms that the `_post_set` method is called with the correct key-value pairs. It also verifies that the method can handle multiple updates in a single call and that the order of calls can be asserted when necessary.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `app.config` object, which is part of the Sanic framework. The test uses a mock object (`post_set`) to replace the actual `_post_set` method in the `Config` class. Each time a configuration value is set or updated, the test asserts that `post_set` is called with the expected arguments. The `reset_mock` method is used to clear the call history of the mock after each assertion, ensuring that each test case is independent.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test uses the `Mock` class to create a mock object for `_post_set`, allowing the test to track calls to this method without executing its actual implementation.\n- **Monkeypatching**: The `monkeypatch` fixture is used to replace the `_post_set` method in the `Config` class with the mock, enabling controlled testing of side effects.\n- **Assertions**: The test employs various assertion methods (`assert_called_once_with`, `assert_has_calls`) to verify that the mock was called with the expected parameters, ensuring that the configuration behavior is correct.\n- **Resetting Mocks**: The use of `reset_mock` after each assertion helps maintain test isolation, preventing interference between different assertions."
    },
    {
      "name": "test_negative_proxy_count",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 412,
      "end_line_number": 421,
      "source_code": "def test_negative_proxy_count(app: Sanic):\n    app.config.PROXIES_COUNT = -1\n\n    message = (\n        \"PROXIES_COUNT cannot be negative. \"\n        \"https://sanic.readthedocs.io/en/latest/sanic/config.html\"\n        \"#proxy-configuration\"\n    )\n    with pytest.raises(ValueError, match=message):\n        app.prepare()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_negative_proxy_count` unit test is designed to verify that the Sanic application correctly raises a `ValueError` when the `PROXIES_COUNT` configuration is set to a negative value. This ensures that the application enforces valid configuration settings and prevents misconfiguration that could lead to unexpected behavior.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that when `PROXIES_COUNT` is set to -1, the application raises a `ValueError` with a specific error message. This behavior is crucial for maintaining the integrity of the application's configuration, as negative proxy counts do not make logical sense in the context of proxy handling.\n\n**Code Being Tested and How It Works**:  \nThe relevant code being tested is found in the `_helper` method of the Sanic application, which checks the value of `self.config.PROXIES_COUNT`. If this value is negative, it raises a `ValueError` with a predefined message. The test sets `app.config.PROXIES_COUNT` to -1 and then calls `app.prepare()`, which triggers the check and the subsequent exception if the condition is met.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that a specific exception is raised during the execution of the code block. This pattern is effective for testing error conditions and ensures that the test fails if the expected exception is not raised. Additionally, the use of a specific error message in the `match` parameter allows for precise verification that the correct error is raised, enhancing the robustness of the test."
    },
    {
      "name": "test_convert_local_cert_creator",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 435,
      "end_line_number": 439,
      "source_code": "def test_convert_local_cert_creator(passed, expected):\n    os.environ[\"SANIC_LOCAL_CERT_CREATOR\"] = passed\n    app = Sanic(\"Test\")\n    assert app.config.LOCAL_CERT_CREATOR is expected\n    del os.environ[\"SANIC_LOCAL_CERT_CREATOR\"]",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('passed,expected', (('auto', LocalCertCreator.AUTO), ('mkcert', LocalCertCreator.MKCERT), ('trustme', LocalCertCreator.TRUSTME), ('AUTO', LocalCertCreator.AUTO), ('MKCERT', LocalCertCreator.MKCERT), ('TRUSTME', LocalCertCreator.TRUSTME)))"
      ],
      "arguments": [
        "passed",
        "expected"
      ],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.config.LOCAL_CERT_CREATOR is expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_convert_local_cert_creator` unit test is designed to verify that the `Sanic` application correctly reads the `SANIC_LOCAL_CERT_CREATOR` environment variable and sets the `LOCAL_CERT_CREATOR` configuration option accordingly. This ensures that the application can dynamically adjust its behavior based on environment settings.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when the `SANIC_LOCAL_CERT_CREATOR` environment variable is set to a specific value (`passed`), the `app.config.LOCAL_CERT_CREATOR` is equal to the expected value (`expected`). This confirms that the application correctly interprets the environment variable and applies it to its configuration.\n\n**Code Being Tested and How It Works**:  \nThe relevant code involves setting an environment variable and creating an instance of the `Sanic` application. The test sets the `SANIC_LOCAL_CERT_CREATOR` environment variable to the value of `passed`, then instantiates the `Sanic` application. The assertion checks if `app.config.LOCAL_CERT_CREATOR` matches the `expected` value. After the assertion, the environment variable is deleted to clean up and avoid side effects on other tests.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of environment variables to simulate different configurations, which is a common technique in testing to isolate and control the environment in which the code runs. Additionally, it uses assertions to validate the expected state of the application configuration, ensuring that the application behaves correctly based on the environment setup. The cleanup step (deleting the environment variable) is also a good practice to maintain test isolation."
    },
    {
      "name": "test_create_task",
      "module": "test_create_task",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_create_task.py",
      "line_number": 12,
      "end_line_number": 36,
      "source_code": "def test_create_task(app):\n    e = Event()\n\n    async def coro():\n        await asyncio.sleep(0.05)\n        e.set()\n\n    @app.route(\"/early\")\n    def not_set(request):\n        return text(str(e.is_set()))\n\n    @app.route(\"/late\")\n    async def set(request):\n        await asyncio.sleep(0.1)\n        return text(str(e.is_set()))\n\n    app.add_task(coro)\n\n    request, response = app.test_client.get(\"/early\")\n    assert response.body == b\"False\"\n\n    app.signal_router.reset()\n    app.add_task(coro)\n    request, response = app.test_client.get(\"/late\")\n    assert response.body == b\"True\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "sys",
        "threading.Event",
        "pytest",
        "sanic.exceptions.SanicException",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.body == b'False'",
        "assert response.body == b'True'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.add_task",
          "body": "def add_task(self, func):\n    loop = asyncio.get_event_loop()\n    self.stay_active_task = loop.create_task(func(self))"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.signal_router.reset",
          "body": "@pytest.fixture(autouse=True)\ndef reset():\n    try:\n        del os.environ['SANIC_MOTD_OUTPUT']\n    except KeyError:\n        ..."
        },
        {
          "name": "app.add_task",
          "body": "def add_task(self, func):\n    loop = asyncio.get_event_loop()\n    self.stay_active_task = loop.create_task(func(self))"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_create_task` function is designed to verify the behavior of asynchronous task creation and execution within a Sanic web application. It specifically tests whether a task can be scheduled to run and whether it correctly updates the state of an event object that indicates whether the task has completed.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two routes (`/early` and `/late`) to confirm that the event `e` is not set when accessed immediately after the task is scheduled (`/early`), and that it is set after a delay when accessed later (`/late`). This ensures that the task is executed as expected and that the application correctly reflects the state of the event.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the `app.add_task` method to schedule an asynchronous coroutine (`coro`) that sets the event `e` after a short delay. The two routes defined (`not_set` and `set`) return the state of the event `e` as a string. The first route is expected to return `False` (indicating the event is not set), while the second route, after a longer delay, is expected to return `True` (indicating the event has been set).\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test leverages asynchronous programming with `asyncio` to handle the timing of task execution and HTTP request handling.\n- **Event Object**: The use of `threading.Event` allows for a simple mechanism to track whether the task has completed, showcasing a common pattern in concurrent programming.\n- **Route Testing**: The test directly interacts with the application\u2019s routing mechanism to validate the responses from defined endpoints, ensuring that the application behaves correctly under different conditions.\n- **State Resetting**: The test resets the signal router between requests to ensure that the state is clean for each test case, which is a good practice in unit testing to avoid side effects."
    },
    {
      "name": "test_create_task_with_app_arg",
      "module": "test_create_task",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_create_task.py",
      "line_number": 39,
      "end_line_number": 54,
      "source_code": "def test_create_task_with_app_arg(app):\n    @app.after_server_start\n    async def setup_q(app, _):\n        app.ctx.q = asyncio.Queue()\n\n    @app.route(\"/\")\n    async def not_set(request):\n        return text(await request.app.ctx.q.get())\n\n    async def coro(app):\n        await app.ctx.q.put(app.name)\n\n    app.add_task(coro)\n\n    _, response = app.test_client.get(\"/\")\n    assert response.text == \"test_create_task_with_app_arg\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "sys",
        "threading.Event",
        "pytest",
        "sanic.exceptions.SanicException",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'test_create_task_with_app_arg'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.add_task",
          "body": "def add_task(self, func):\n    loop = asyncio.get_event_loop()\n    self.stay_active_task = loop.create_task(func(self))"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.ctx.q.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "request.app.ctx.q.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_create_task_with_app_arg` test is to verify that a task can be created and executed within the Sanic application context, specifically ensuring that the task can interact with the application\u2019s context (ctx) and that it correctly places a value into an asyncio queue.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a task is added to the Sanic application, it can successfully put the application name into an asyncio queue, and that the queue can be accessed via a route handler to return the expected value. The test asserts that the response from the route matches the application name, confirming that the task executed as intended.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes:\n- `app.add_task`: This method is used to register a coroutine (task) that will run in the background. In this case, the coroutine `coro` is defined to put the application name into the queue.\n- `app.ctx.q.put`: This method is called within the `coro` to add the application name to the queue.\n- `request.app.ctx.q.get`: This method is called in the route handler `not_set` to retrieve the value from the queue when a GET request is made to the root endpoint.\n\nThe test sets up the application context by defining an asyncio queue in the `setup_q` function, which is registered to run after the server starts. The task is then added, and a request is made to the root route to check the response.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test leverages asynchronous programming patterns, using `async def` for coroutines and `await` for asynchronous calls, which is essential for testing in an async framework like Sanic.\n- **Context Management**: The test demonstrates the use of application context (`app.ctx`) to store and retrieve state (the queue), showcasing how to manage shared state in an asynchronous environment.\n- **Assertions**: The test uses assertions to validate the expected outcome, ensuring that the response from the route matches the application name, which is a direct result of the task's execution."
    },
    {
      "name": "test_create_named_task",
      "module": "test_create_task",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_create_task.py",
      "line_number": 58,
      "end_line_number": 76,
      "source_code": "def test_create_named_task(app, port):\n    async def dummy(): ...\n\n    @app.before_server_start\n    async def setup(app, _):\n        app.add_task(dummy, name=\"dummy_task\")\n\n    @app.after_server_start\n    async def stop(app, _):\n        task = app.get_task(\"dummy_task\")\n\n        assert app._task_registry\n        assert isinstance(task, asyncio.Task)\n\n        assert task.get_name() == \"dummy_task\"\n\n        app.stop()\n\n    app.run(single_process=True, port=port)",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(sys.version_info < (3, 8), reason='Not supported in 3.7')"
      ],
      "arguments": [
        "app",
        "port"
      ],
      "imports": [
        "asyncio",
        "sys",
        "threading.Event",
        "pytest",
        "sanic.exceptions.SanicException",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert app._task_registry",
        "assert isinstance(task, asyncio.Task)",
        "assert task.get_name() == 'dummy_task'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "app.add_task",
          "body": "def add_task(self, func):\n    loop = asyncio.get_event_loop()\n    self.stay_active_task = loop.create_task(func(self))"
        },
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_create_named_task` unit test is designed to verify the functionality of adding a named task to a Sanic application and ensuring that the task can be retrieved and is correctly registered within the application's task registry.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that:\n1. A task can be added to the application before the server starts.\n2. The task is correctly registered in the application's internal task registry.\n3. The task can be retrieved by its name and is an instance of `asyncio.Task`.\n4. The task's name matches the expected name (\"dummy_task\").\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the following methods:\n- `app.add_task`: This method schedules a coroutine to run after the event loop has started. It allows naming the task for later reference.\n- `app.get_task`: This method retrieves a task by its name from the application's task registry.\n- `app.run`: This method starts the Sanic application, triggering the execution of tasks registered in the `before_server_start` listener.\n\nThe test defines a dummy coroutine and registers it as a task named \"dummy_task\" in the `before_server_start` listener. After the server starts, it checks the task's registration and properties.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test is structured to work with asynchronous code, utilizing `async def` for the dummy task and the server's lifecycle hooks.\n- **Setup and Teardown**: The use of `before_server_start` and `after_server_start` hooks allows for setup and verification of the task's state in a controlled manner.\n- **Assertions**: The test employs assertions to validate the expected state of the application and the task, ensuring that the task is registered and correctly instantiated.\n- **Integration Testing**: This test serves as an integration test, verifying the interaction between the application lifecycle and task management features of the Sanic framework."
    },
    {
      "name": "test_named_task_called",
      "module": "test_create_task",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_create_task.py",
      "line_number": 79,
      "end_line_number": 95,
      "source_code": "def test_named_task_called(app):\n    e = Event()\n\n    async def coro():\n        e.set()\n\n    @app.route(\"/\")\n    async def isset(request):\n        await asyncio.sleep(0.05)\n        return text(str(e.is_set()))\n\n    @app.before_server_start\n    async def setup(app, _):\n        app.add_task(coro, name=\"dummy_task\")\n\n    request, response = app.test_client.get(\"/\")\n    assert response.body == b\"True\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "sys",
        "threading.Event",
        "pytest",
        "sanic.exceptions.SanicException",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.body == b'True'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.add_task",
          "body": "def add_task(self, func):\n    loop = asyncio.get_event_loop()\n    self.stay_active_task = loop.create_task(func(self))"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_named_task_called` function is designed to verify that a named asynchronous task can be successfully registered and executed within a Sanic application. It checks that the task's completion can be reflected in the response of an HTTP request.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically verifies that the asynchronous task (`coro`) sets an event (`e`) to indicate its completion, and that this state can be accessed via an HTTP route. The expected behavior is that when a GET request is made to the root endpoint (\"/\"), the response should confirm that the task has been executed and the event is set.\n\n**Code Being Tested and How It Works**:  \nThe test sets up an asynchronous task (`coro`) that sets an event (`e`) after a short delay. The route handler (`isset`) waits for this delay and then returns the state of the event as a string. The task is registered to run before the server starts using `app.add_task(coro, name=\"dummy_task\")`. When the test client makes a GET request to the root endpoint, it checks if the response body is `b\"True\"`, indicating that the event was set by the task.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test leverages asynchronous programming with `async def` and `await`, which is essential for testing asynchronous tasks in frameworks like Sanic.\n- **Event Handling**: The use of `threading.Event` allows for synchronization between the task and the HTTP request, ensuring that the test accurately reflects the task's completion state.\n- **Setup and Teardown**: The test utilizes the Sanic app's lifecycle hooks (`@app.before_server_start`) to ensure that the task is registered before any requests are processed, demonstrating a common pattern in integration testing where setup is crucial for the test's success."
    },
    {
      "name": "test_create_named_task_fails_outside_app",
      "module": "test_create_task",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_create_task.py",
      "line_number": 99,
      "end_line_number": 109,
      "source_code": "def test_create_named_task_fails_outside_app(app):\n    async def dummy(): ...\n\n    message = \"Cannot name task outside of a running application\"\n    with pytest.raises(RuntimeError, match=message):\n        app.add_task(dummy, name=\"dummy_task\")\n    assert not app._task_registry\n\n    message = 'Registered task named \"dummy_task\" not found.'\n    with pytest.raises(SanicException, match=message):\n        app.get_task(\"dummy_task\")",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(sys.version_info < (3, 8), reason='Not supported in 3.7')"
      ],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "sys",
        "threading.Event",
        "pytest",
        "sanic.exceptions.SanicException",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert not app._task_registry"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.add_task",
          "body": "def add_task(self, func):\n    loop = asyncio.get_event_loop()\n    self.stay_active_task = loop.create_task(func(self))"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_create_named_task_fails_outside_app` is designed to verify that attempting to add a named task to the Sanic application outside of a running application context raises the appropriate exceptions. It ensures that the application enforces its constraints regarding task registration.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main behaviors: \n1. It verifies that a `RuntimeError` is raised with a specific message when trying to add a named task outside of a running application.\n2. It confirms that the task registry remains empty after the failed attempt to add the task, and that a subsequent attempt to retrieve the task raises a `SanicException` indicating that the task was not found.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `add_task` method of the Sanic application, which is responsible for registering tasks. The method checks if the application is running before allowing a task to be named. If the application is not running, it raises a `RuntimeError`. The `get_task` method is also tested, which retrieves a task by its name and raises a `SanicException` if the task is not found in the registry.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that specific exceptions are raised, which is a common pattern in unit testing for verifying error conditions. Additionally, it uses assertions to check the state of the application\u2019s task registry, ensuring that it behaves as expected after the attempted operation. The use of descriptive error messages in the assertions enhances the clarity of the test's intent and expected outcomes."
    },
    {
      "name": "test_matching",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 125,
      "end_line_number": 177,
      "source_code": "def test_matching(path, headers, expected):\n    app = Sanic(\"dev\")\n    bp1 = Blueprint(\"bp1\", url_prefix=\"/bp1\")\n    bp2 = Blueprint(\"bp2\", url_prefix=\"/bp2\", strict_slashes=True)\n    bp3 = Blueprint(\"bp3\", url_prefix=\"/bp3\", strict_slashes=False)\n    bp4 = Blueprint(\"bp4\", url_prefix=\"/bp4\", host=\"maybe.com\")\n\n    def handler(request):\n        return text(\"Hello!\")\n\n    defs = (\n        (\"/\", None, None),\n        (\"/host\", None, \"matching.com\"),\n        (\"/without\", None, None),\n        (\"/with/\", None, None),\n        (\"/expwithout\", False, None),\n        (\"/expwith/\", False, None),\n        (\"/without/strict\", True, None),\n        (\"/with/strict/\", True, None),\n    )\n    for uri, strict_slashes, host in defs:\n        params = {\"uri\": uri}\n        if strict_slashes is not None:\n            params[\"strict_slashes\"] = strict_slashes\n        if host is not None:\n            params[\"host\"] = host\n        app.route(**params)(handler)\n        bp1.route(**params)(handler)\n        bp2.route(**params)(handler)\n        bp3.route(**params)(handler)\n        bp4.route(**params)(handler)\n\n    app.blueprint(bp1)\n    app.blueprint(bp2)\n    app.blueprint(bp3)\n    app.blueprint(bp4)\n\n    app.router.finalize()\n\n    request = Request(path, headers, None, \"GET\", None, app)\n\n    try:\n        app.router.get(\n            request.path, request.method, request.headers.get(\"host\")\n        )\n    except NotFound:\n        response = 404\n    except Exception:\n        response = 500\n    else:\n        response = 200\n\n    assert response == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('path,headers,expected', ((b'/', {}, 200), (b'/', {'host': 'maybe.com'}, 200), (b'/host', {'host': 'matching.com'}, 200), (b'/host', {'host': 'wrong.com'}, 404), (b'/without', {}, 200), (b'/without/', {}, 200), (b'/with', {}, 200), (b'/with/', {}, 200), (b'/expwithout', {}, 200), (b'/expwithout/', {}, 200), (b'/expwith', {}, 200), (b'/expwith/', {}, 200), (b'/without/strict', {}, 200), (b'/without/strict/', {}, 404), (b'/with/strict', {}, 404), (b'/with/strict/', {}, 200), (b'/bp1', {}, 200), (b'/bp1', {'host': 'maybe.com'}, 200), (b'/bp1/host', {'host': 'matching.com'}, 200), (b'/bp1/host', {'host': 'wrong.com'}, 404), (b'/bp1/without', {}, 200), (b'/bp1/without/', {}, 200), (b'/bp1/with', {}, 200), (b'/bp1/with/', {}, 200), (b'/bp1/expwithout', {}, 200), (b'/bp1/expwithout/', {}, 200), (b'/bp1/expwith', {}, 200), (b'/bp1/expwith/', {}, 200), (b'/bp1/without/strict', {}, 200), (b'/bp1/without/strict/', {}, 404), (b'/bp1/with/strict', {}, 404), (b'/bp1/with/strict/', {}, 200), (b'/bp2/', {}, 200), (b'/bp2/', {'host': 'maybe.com'}, 200), (b'/bp2/host', {'host': 'matching.com'}, 200), (b'/bp2/host', {'host': 'wrong.com'}, 404), (b'/bp2/without', {}, 200), (b'/bp2/without/', {}, 404), (b'/bp2/with', {}, 404), (b'/bp2/with/', {}, 200), (b'/bp2/expwithout', {}, 200), (b'/bp2/expwithout/', {}, 200), (b'/bp2/expwith', {}, 200), (b'/bp2/expwith/', {}, 200), (b'/bp2/without/strict', {}, 200), (b'/bp2/without/strict/', {}, 404), (b'/bp2/with/strict', {}, 404), (b'/bp2/with/strict/', {}, 200), (b'/bp3', {}, 200), (b'/bp3', {'host': 'maybe.com'}, 200), (b'/bp3/host', {'host': 'matching.com'}, 200), (b'/bp3/host', {'host': 'wrong.com'}, 404), (b'/bp3/without', {}, 200), (b'/bp3/without/', {}, 200), (b'/bp3/with', {}, 200), (b'/bp3/with/', {}, 200), (b'/bp3/expwithout', {}, 200), (b'/bp3/expwithout/', {}, 200), (b'/bp3/expwith', {}, 200), (b'/bp3/expwith/', {}, 200), (b'/bp3/without/strict', {}, 200), (b'/bp3/without/strict/', {}, 404), (b'/bp3/with/strict', {}, 404), (b'/bp3/with/strict/', {}, 200), (b'/bp4', {}, 404), (b'/bp4', {'host': 'maybe.com'}, 200), (b'/bp4/host', {'host': 'matching.com'}, 200), (b'/bp4/host', {'host': 'wrong.com'}, 404), (b'/bp4/without', {}, 404), (b'/bp4/without/', {}, 404), (b'/bp4/with', {}, 404), (b'/bp4/with/', {}, 404), (b'/bp4/expwithout', {}, 404), (b'/bp4/expwithout/', {}, 404), (b'/bp4/expwith', {}, 404), (b'/bp4/expwith/', {}, 404), (b'/bp4/without/strict', {}, 404), (b'/bp4/without/strict/', {}, 404), (b'/bp4/with/strict', {}, 404), (b'/bp4/with/strict/', {}, 404)))"
      ],
      "arguments": [
        "path",
        "headers",
        "expected"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.router.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "request.headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_matching` function is designed to verify the routing behavior of a Sanic web application, specifically how it handles different paths, headers, and the expected HTTP response status codes. It ensures that the application correctly matches routes based on the provided path and headers.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks whether the application returns the correct HTTP status code (200, 404, or 500) based on the defined routes and the incoming request's path and headers. It validates that the routing logic correctly identifies whether a route exists and handles strict slashes and host matching appropriately.\n\n**Code Being Tested and How It Works**:  \nThe code sets up a Sanic application with multiple blueprints and routes defined with various configurations (e.g., strict slashes, host). The `handler` function returns a simple text response. The test constructs a `Request` object with the specified `path` and `headers`, then attempts to retrieve the route using `app.router.get()`. Depending on whether the route is found, it assigns a response status (200 for success, 404 for not found, and 500 for other exceptions) and asserts that this response matches the expected value.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterized Testing**: The test is likely part of a parameterized test suite, as indicated by the `@pytest.mark.parametrize` decorator, allowing it to run multiple scenarios with different inputs (path, headers, expected status).\n- **Exception Handling**: The test includes a try-except block to handle potential exceptions when retrieving the route, ensuring that the test can gracefully handle errors and assert the correct response status.\n- **Blueprints**: The use of blueprints allows for modular route definitions, making it easier to manage and test different parts of the application independently."
    },
    {
      "name": "test_versioned_routes_get",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 186,
      "end_line_number": 202,
      "source_code": "def test_versioned_routes_get(app, method):\n    method = method.lower()\n\n    func = getattr(app, method)\n    if callable(func):\n\n        @func(f\"/{method}\", version=1)\n        def handler(request):\n            return text(\"OK\")\n\n    else:\n        raise Exception(f\"Method: {method} is not callable\")\n\n    client_method = getattr(app.test_client, method)\n\n    request, response = client_method(f\"/v1/{method}\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('method', HTTP_METHODS)"
      ],
      "arguments": [
        "app",
        "method"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_versioned_routes_get` function is designed to verify that versioned routes in a Sanic application respond correctly to HTTP GET requests. Specifically, it checks that a GET request to a versioned route returns a successful HTTP status code (200).\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a route is defined with a specific HTTP method (GET, POST, etc.) and a version, the application correctly handles requests to that route and responds with the expected status code. It confirms that the routing mechanism respects the versioning specified in the route definition.\n\n**Code Being Tested and How It Works**:  \nThe test dynamically retrieves the HTTP method (e.g., GET) from the `app` object and checks if it is callable. If it is, a route is defined using the method and a version (version 1). The handler for this route simply returns a text response \"OK\". The test then simulates a client request to the versioned route (e.g., `/v1/get`) and asserts that the response status is 200, indicating a successful request.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Dynamic Method Retrieval**: The test uses `getattr` to dynamically access the HTTP method on the `app` object, allowing for flexible testing of different methods.\n- **Versioning**: The test specifically checks the behavior of versioned routes, which is a common pattern in RESTful APIs to manage changes in the API over time.\n- **Client Simulation**: It utilizes the test client provided by Sanic to simulate HTTP requests, which is a standard practice in testing web applications to ensure that routes behave as expected under various conditions."
    },
    {
      "name": "test_shorthand_routes_get",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 205,
      "end_line_number": 214,
      "source_code": "def test_shorthand_routes_get(app):\n    @app.get(\"/get\")\n    def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/get\")\n    assert response.text == \"OK\"\n\n    request, response = app.test_client.post(\"/get\")\n    assert response.status == 405",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert response.status == 405"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_shorthand_routes_get` function is designed to verify the behavior of a simple GET route in a Sanic web application. It ensures that the route correctly responds to GET requests and appropriately handles unsupported HTTP methods.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks two main behaviors: \n1. When a GET request is made to the `/get` endpoint, the response should return the text \"OK\".\n2. When a POST request is made to the same endpoint, the server should respond with a 405 Method Not Allowed status, indicating that the POST method is not supported for this route.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes:\n- The route handler defined by `@app.get(\"/get\")`, which returns a text response \"OK\" when accessed via a GET request.\n- The `app.test_client.get` method simulates a GET request to the `/get` endpoint, while `app.test_client.post` simulates a POST request to the same endpoint. The expected behavior is defined by the assertions that follow each request.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertion-Based Testing**: The test uses assertions to validate the expected outcomes of the requests, ensuring that the actual responses match the expected results.\n- **Route Definition and Testing**: The test demonstrates the use of decorators to define routes and immediately test their behavior, showcasing a common pattern in web application testing.\n- **HTTP Method Verification**: By testing both GET and POST methods, the test effectively verifies the correct implementation of HTTP method handling in the application."
    },
    {
      "name": "test_shorthand_routes_multiple",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 217,
      "end_line_number": 231,
      "source_code": "def test_shorthand_routes_multiple(app):\n    @app.get(\"/get\")\n    def get_handler(request):\n        return text(\"OK\")\n\n    @app.options(\"/get\")\n    def options_handler(request):\n        return text(\"\")\n\n    request, response = app.test_client.get(\"/get/\")\n    assert response.status == 200\n    assert response.text == \"OK\"\n\n    request, response = app.test_client.options(\"/get/\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'OK'",
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.options",
          "body": "def options(self, request):\n    return text('', headers={'method': 'OPTIONS'})"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.options",
          "body": "def options(self, request):\n    return text('', headers={'method': 'OPTIONS'})"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_shorthand_routes_multiple` test is designed to verify the correct behavior of HTTP GET and OPTIONS requests for a specific route (`/get`) in a Sanic web application. It ensures that the application correctly handles these requests and returns the expected responses.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that:\n1. A GET request to `/get/` returns a status code of 200 and the response text \"OK\".\n2. An OPTIONS request to `/get/` also returns a status code of 200, confirming that the server correctly handles OPTIONS requests.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes:\n- The `app.get` method, which registers a handler for GET requests to the `/get` route, returning \"OK\".\n- The `app.options` method, which registers a handler for OPTIONS requests to the same route, returning an empty response.\n- The `app.test_client.get` and `app.test_client.options` methods, which simulate client requests to the application for testing purposes.\n\nThe test sets up the route handlers and then uses the test client to make requests to the defined routes, asserting the expected outcomes.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertion**: The test uses assertions to validate the response status and content, ensuring that the application behaves as expected.\n- **Route Registration**: The test demonstrates the use of route registration in Sanic, showcasing how to define multiple HTTP methods for the same endpoint.\n- **Test Client**: The use of `app.test_client` allows for simulating requests to the application, which is a common pattern in testing web applications to verify endpoint behavior without needing to run a server."
    },
    {
      "name": "test_route_strict_slash",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 234,
      "end_line_number": 253,
      "source_code": "def test_route_strict_slash(app):\n    @app.get(\"/get\", strict_slashes=True)\n    def handler1(request):\n        return text(\"OK\")\n\n    @app.post(\"/post/\", strict_slashes=True)\n    def handler2(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/get\")\n    assert response.text == \"OK\"\n\n    request, response = app.test_client.get(\"/get/\")\n    assert response.status == 404\n\n    request, response = app.test_client.post(\"/post/\")\n    assert response.text == \"OK\"\n\n    request, response = app.test_client.post(\"/post\")\n    assert response.status == 404",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert response.status == 404",
        "assert response.text == 'OK'",
        "assert response.status == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_route_strict_slash` test verifies the behavior of route handling in a Sanic web application when the `strict_slashes` option is enabled. It ensures that routes are correctly matched based on the presence or absence of a trailing slash.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that:\n- A GET request to `/get` returns a successful response (200 OK).\n- A GET request to `/get/` returns a 404 Not Found status, indicating that the route does not match due to the strict slash requirement.\n- A POST request to `/post/` returns a successful response (200 OK).\n- A POST request to `/post` returns a 404 Not Found status, again due to the strict slash requirement.\n\n**Code Being Tested and How It Works**:  \nThe test defines two routes in the Sanic application:\n- A GET route at `/get` that returns \"OK\" when accessed without a trailing slash.\n- A POST route at `/post/` that also returns \"OK\" when accessed with a trailing slash.  \nThe test then uses the `app.test_client` to simulate requests to these routes and checks the responses against expected outcomes.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertion Checks**: The test uses assertions to validate the response text and status codes, ensuring that the application behaves as expected under different request conditions.\n- **Route Configuration**: The test demonstrates the use of route decorators with the `strict_slashes` parameter, showcasing how route matching can be controlled in a web framework.\n- **Client Simulation**: The use of `app.test_client` allows for simulating HTTP requests to the application, which is a common practice in unit testing web applications to verify endpoint behavior without needing to run a server."
    },
    {
      "name": "test_route_invalid_parameter_syntax",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 256,
      "end_line_number": 263,
      "source_code": "def test_route_invalid_parameter_syntax(app):\n    with pytest.raises(InvalidUsage):\n\n        @app.get(\"/get/<:str>\", strict_slashes=True)\n        def handler(request):\n            return text(\"OK\")\n\n        request, response = app.test_client.get(\"/get\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_route_invalid_parameter_syntax` test is to verify that the Sanic application correctly raises an `InvalidUsage` exception when an invalid route parameter syntax is defined. Specifically, it checks that the application does not accept a route definition that uses an invalid syntax for parameter declaration.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the application enforces proper syntax for route parameters. In this case, the test checks that using a colon (`:`) in the route parameter declaration (`<:str>`) is invalid and should trigger an exception. The expected behavior is that the application should not allow this route to be registered and should raise an appropriate error.\n\n**Code Being Tested and How It Works**:  \nThe code being tested involves the `app.get` method, which is used to define a route in the Sanic application. The test attempts to define a route with an invalid parameter syntax and then immediately calls the `app.test_client.get` method to simulate a request to that route. However, since the route definition is invalid, the test expects the `InvalidUsage` exception to be raised before the request is processed.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that an exception is raised during the execution of the code block that defines the route. This is a common pattern in unit testing to verify that specific error conditions are handled correctly. Additionally, the test uses a clear structure where the route definition and the request simulation are encapsulated within the context manager, ensuring that the exception is expected only during the route definition phase."
    },
    {
      "name": "test_route_strict_slash_default_value",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 266,
      "end_line_number": 274,
      "source_code": "def test_route_strict_slash_default_value():\n    app = Sanic(\"test_route_strict_slash\", strict_slashes=True)\n\n    @app.get(\"/get\")\n    def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/get/\")\n    assert response.status == 404",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_route_strict_slash_default_value` is designed to verify the behavior of the Sanic web framework when handling routes with strict slash enforcement. Specifically, it checks that a request to a route with a trailing slash (\"/get/\") returns a 404 Not Found status when the route is defined without a trailing slash (\"/get\") and strict slashes are enabled.\n\n**Specific Functionality or Behavior Verified**:  \nThis test confirms that when the `strict_slashes` parameter is set to `True`, the Sanic application does not allow requests to the route with a trailing slash unless the route is explicitly defined to accept it. In this case, the expected behavior is that accessing \"/get/\" results in a 404 error, indicating that the route is not found.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `app.get` method, which registers a route handler for the GET HTTP method, and the `app.test_client.get` method, which simulates a client request to the application. The route handler defined for \"/get\" returns a simple text response \"OK\". However, since the request is made to \"/get/\", which does not match the defined route due to strict slashes being enabled, the application responds with a 404 status.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern, using `assert` to verify the response status. It also utilizes the Sanic testing client to simulate HTTP requests, which is a common technique in unit testing web applications. The test is structured to be self-contained, initializing the application and defining the route within the test function, ensuring that it does not interfere with other tests. This encapsulation is a good practice for maintaining test isolation."
    },
    {
      "name": "test_route_strict_slash_without_passing_default_value",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 277,
      "end_line_number": 283,
      "source_code": "def test_route_strict_slash_without_passing_default_value(app):\n    @app.get(\"/get\")\n    def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/get/\")\n    assert response.text == \"OK\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_route_strict_slash_without_passing_default_value` is designed to verify the behavior of a Sanic web application route when accessed with a trailing slash, specifically when the route is defined without a strict slash enforcement.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a GET request is made to the route `/get/` (with a trailing slash), the application correctly returns a response with the text \"OK\". This is significant because it confirms that the route can be accessed with a trailing slash, which is important for user experience and URL consistency.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the route handler defined by `@app.get(\"/get\")`, which returns a text response \"OK\". The test simulates a GET request to the URL `/get/` using `app.test_client.get(\"/get/\")`, and then asserts that the response text matches \"OK\". This indicates that the route handler is functioning as expected when accessed with a trailing slash.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern, where the response from the application is directly compared to the expected output. It uses the Sanic testing client to simulate HTTP requests, which is a common technique in unit testing web applications. The test also implicitly relies on the configuration of the Sanic app to allow for flexible routing behavior regarding trailing slashes, showcasing the importance of route definitions in web frameworks."
    },
    {
      "name": "test_route_strict_slash_default_value_can_be_overwritten",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 286,
      "end_line_number": 294,
      "source_code": "def test_route_strict_slash_default_value_can_be_overwritten():\n    app = Sanic(\"test_route_strict_slash\", strict_slashes=True)\n\n    @app.get(\"/get\", strict_slashes=False)\n    def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/get/\")\n    assert response.text == \"OK\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_route_strict_slash_default_value_can_be_overwritten` aims to verify that the Sanic framework allows the default behavior of strict slashes to be overridden at the route level. Specifically, it checks that a route defined with `strict_slashes=False` can successfully handle requests with a trailing slash.\n\n**Specific Functionality or Behavior Verified**:  \nThis test confirms that when a route is defined with `strict_slashes=False`, it can accept requests that include a trailing slash (e.g., `/get/`) and return the expected response. In this case, it ensures that the response text is \"OK\" when accessing the route with a trailing slash.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `app.get` method, which registers a route handler for the GET request at the path `/get` with `strict_slashes` set to `False`. The handler returns a text response \"OK\". The test then simulates a GET request to `/get/` using `app.test_client.get`, and it asserts that the response text matches \"OK\". This demonstrates that the route correctly processes the request despite the trailing slash.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of a test client (`app.test_client.get`) to simulate HTTP requests, which is a common pattern in testing web applications. It also utilizes assertions to validate the response, ensuring that the expected behavior aligns with the actual output. The test is structured to be clear and straightforward, focusing on a specific aspect of route handling in the Sanic framework."
    },
    {
      "name": "test_route_slashes_overload",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 297,
      "end_line_number": 316,
      "source_code": "def test_route_slashes_overload(app):\n    @app.get(\"/hello/\")\n    def handler_get(request):\n        return text(\"OK\")\n\n    @app.post(\"/hello/\")\n    def handler_post(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/hello\")\n    assert response.text == \"OK\"\n\n    request, response = app.test_client.get(\"/hello/\")\n    assert response.text == \"OK\"\n\n    request, response = app.test_client.post(\"/hello\")\n    assert response.text == \"OK\"\n\n    request, response = app.test_client.post(\"/hello/\")\n    assert response.text == \"OK\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert response.text == 'OK'",
        "assert response.text == 'OK'",
        "assert response.text == 'OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_route_slashes_overload` test is designed to verify that the Sanic web framework correctly handles routes with and without trailing slashes. It ensures that both GET and POST requests to the `/hello` and `/hello/` endpoints return the expected response.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the application responds with \"OK\" for both GET and POST requests, regardless of whether the request URL includes a trailing slash. This behavior is crucial for user experience and API consistency, as clients may use either format.\n\n**Code Being Tested and How It Works**:  \nThe test defines two route handlers for the `/hello/` endpoint: one for GET requests and another for POST requests. The handlers return a simple text response of \"OK\". The test then makes requests to both `/hello` and `/hello/` for both HTTP methods and asserts that the response text is \"OK\". This confirms that the application correctly routes requests to the appropriate handler regardless of the presence of a trailing slash.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern, where the response from the application is compared against an expected value. It uses the `app.test_client` to simulate HTTP requests, which is a common technique in testing web applications. The test also demonstrates the use of multiple assertions to cover different scenarios (GET and POST with and without slashes), ensuring comprehensive coverage of the routing behavior."
    },
    {
      "name": "test_route_optional_slash",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 319,
      "end_line_number": 328,
      "source_code": "def test_route_optional_slash(app):\n    @app.get(\"/get\")\n    def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/get\")\n    assert response.text == \"OK\"\n\n    request, response = app.test_client.get(\"/get/\")\n    assert response.text == \"OK\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert response.text == 'OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_route_optional_slash` test verifies that the Sanic web framework correctly handles routes with optional trailing slashes. Specifically, it checks that both `/get` and `/get/` return the same response.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the route defined at `/get` responds with the same output (\"OK\") regardless of whether the request is made with or without a trailing slash. This behavior is crucial for user experience and API consistency.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route handler for the path `/get` that returns a plain text response of \"OK\". It then makes two GET requests using the test client: one to `/get` and another to `/get/`. The assertions confirm that both responses have the expected text content of \"OK\". The relevant methods being tested include `app.get` for route definition and `app.test_client.get` for simulating HTTP GET requests.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward approach to unit testing by using assertions to validate the output of HTTP requests. It leverages the Sanic framework's built-in test client to simulate requests, which is a common pattern in testing web applications. The test is structured to be clear and concise, focusing on a specific aspect of routing behavior without unnecessary complexity."
    },
    {
      "name": "test_route_strict_slashes_set_to_false_and_host_is_a_list",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 331,
      "end_line_number": 369,
      "source_code": "def test_route_strict_slashes_set_to_false_and_host_is_a_list(app):\n    # Part of regression test for issue #1120\n    test_client = SanicTestClient(app, port=42101)\n    site1 = f\"127.0.0.1:{test_client.port}\"\n\n    # before fix, this raises a RouteExists error\n    @app.get(\"/get\", host=[site1, \"site2.com\"], strict_slashes=False)\n    def get_handler(request):\n        return text(\"OK\")\n\n    request, response = test_client.get(\"http://\" + site1 + \"/get\")\n    assert response.text == \"OK\"\n\n    app.router.finalized = False\n\n    @app.post(\"/post\", host=[site1, \"site2.com\"], strict_slashes=False)\n    def post_handler(request):\n        return text(\"OK\")\n\n    request, response = test_client.post(\"http://\" + site1 + \"/post\")\n    assert response.text == \"OK\"\n\n    app.router.finalized = False\n\n    @app.put(\"/put\", host=[site1, \"site2.com\"], strict_slashes=False)\n    def put_handler(request):\n        return text(\"OK\")\n\n    request, response = test_client.put(\"http://\" + site1 + \"/put\")\n    assert response.text == \"OK\"\n\n    app.router.finalized = False\n\n    @app.delete(\"/delete\", host=[site1, \"site2.com\"], strict_slashes=False)\n    def delete_handler(request):\n        return text(\"OK\")\n\n    request, response = test_client.delete(\"http://\" + site1 + \"/delete\")\n    assert response.text == \"OK\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert response.text == 'OK'",
        "assert response.text == 'OK'",
        "assert response.text == 'OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "test_client.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.delete",
          "body": "def delete(self, request):\n    return text('I am delete method')"
        },
        {
          "name": "test_client.delete",
          "body": "def delete(self, request):\n    return text('I am delete method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the test `test_route_strict_slashes_set_to_false_and_host_is_a_list` is to verify that the Sanic application can correctly handle routes with strict slashes disabled and multiple host definitions. This test serves as a regression check for a previously identified issue (issue #1120) where a `RouteExists` error was raised under similar conditions.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that HTTP methods (GET, POST, PUT, DELETE) can be successfully executed on defined routes without raising errors, even when strict slashes are set to `False` and the host parameter is a list. It ensures that the application responds with the expected output (\"OK\") for each method.\n\n**Code Being Tested and How It Works**:  \nThe code being tested involves the Sanic application\u2019s routing mechanism. The test defines four routes (`/get`, `/post`, `/put`, `/delete`) with the `strict_slashes` parameter set to `False` and a list of hosts. Each route is associated with a handler function that returns a simple text response. The test client (`SanicTestClient`) is used to simulate HTTP requests to these routes, and the responses are asserted to ensure they match the expected output.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Setup and Teardown**: The test client is instantiated at the beginning, and the router is reset (`app.router.finalized = False`) after each route definition to allow for multiple route registrations.\n- **Parameterized Testing**: The use of a list for the `host` parameter allows for testing multiple host scenarios in a single test case.\n- **Assertions**: The test uses assertions to validate the response text for each HTTP method, ensuring that the application behaves as expected under the defined conditions. This pattern of asserting responses is common in unit tests to confirm functionality."
    },
    {
      "name": "test_shorthand_routes_post",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 372,
      "end_line_number": 381,
      "source_code": "def test_shorthand_routes_post(app):\n    @app.post(\"/post\")\n    def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.post(\"/post\")\n    assert response.text == \"OK\"\n\n    request, response = app.test_client.get(\"/post\")\n    assert response.status == 405",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert response.status == 405"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_shorthand_routes_post` function is designed to verify the behavior of the Sanic web framework when handling POST requests to a specific route (`/post`). It checks that the route correctly processes a POST request and returns the expected response, while also ensuring that a GET request to the same route results in a \"Method Not Allowed\" (405) status.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies two key behaviors:\n1. When a POST request is made to the `/post` route, the response should return \"OK\".\n2. When a GET request is made to the same route, the server should respond with a 405 status code, indicating that the method is not allowed for that endpoint.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes:\n- The `app.post` method, which defines a route handler for POST requests at `/post`. The handler returns a text response of \"OK\".\n- The `app.test_client.post` method, which simulates a POST request to the `/post` route and captures the request and response.\n- The `app.test_client.get` method, which simulates a GET request to the same route to verify the 405 status response.\n\nThe test uses assertions to validate the response text and status code, ensuring that the application behaves as expected for both request types.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the following patterns:\n- **Route Definition**: It defines a route handler directly within the test, showcasing how to set up routes dynamically for testing purposes.\n- **Client Simulation**: It uses the `app.test_client` to simulate HTTP requests, allowing for easy testing of route behavior without needing to run a live server.\n- **Assertions**: It utilizes assertions to validate the correctness of the responses, ensuring that the application adheres to expected HTTP standards (e.g., returning a 405 status for unsupported methods)."
    },
    {
      "name": "test_shorthand_routes_put",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 384,
      "end_line_number": 393,
      "source_code": "def test_shorthand_routes_put(app):\n    @app.put(\"/put\")\n    def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.put(\"/put\")\n    assert response.text == \"OK\"\n\n    request, response = app.test_client.get(\"/put\")\n    assert response.status == 405",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert response.status == 405"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.test_client.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_shorthand_routes_put` function is designed to verify the behavior of a PUT route in a Sanic web application. Specifically, it checks that the route correctly handles PUT requests and responds with the expected output, while also ensuring that GET requests to the same route return a 405 Method Not Allowed status.\n\n**Specific Functionality or Behavior Verified**:  \nThis test verifies two key behaviors: \n1. When a PUT request is made to the `/put` endpoint, the response should return \"OK\" with a status code of 200.\n2. When a GET request is made to the same endpoint, the response should return a 405 status code, indicating that the method is not allowed for that route.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `app.put` method, which registers a handler for PUT requests to the `/put` route. The handler simply returns a text response of \"OK\". The test uses the `app.test_client` to simulate HTTP requests to the application:\n- The first request is a PUT request to `/put`, which should invoke the registered handler and return \"OK\".\n- The second request is a GET request to `/put`, which should not be handled by the PUT route, thus returning a 405 status code.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward approach to unit testing by using assertions to validate the expected outcomes of HTTP requests. It utilizes the Sanic testing client to simulate requests, which is a common pattern in web application testing. The test also demonstrates the use of route method verification, ensuring that the application correctly distinguishes between different HTTP methods (PUT vs. GET) and responds appropriately."
    },
    {
      "name": "test_shorthand_routes_delete",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 396,
      "end_line_number": 405,
      "source_code": "def test_shorthand_routes_delete(app):\n    @app.delete(\"/delete\")\n    def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.delete(\"/delete\")\n    assert response.text == \"OK\"\n\n    request, response = app.test_client.get(\"/delete\")\n    assert response.status == 405",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert response.status == 405"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.delete",
          "body": "def delete(self, request):\n    return text('I am delete method')"
        },
        {
          "name": "app.test_client.delete",
          "body": "def delete(self, request):\n    return text('I am delete method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_shorthand_routes_delete` test is to verify the behavior of the DELETE HTTP method in a Sanic web application. It ensures that a DELETE route correctly returns a response when accessed and that accessing the same route with a GET request results in a 405 Method Not Allowed error.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks two specific behaviors: \n1. When a DELETE request is made to the `/delete` endpoint, the response should return \"OK\" with a status code of 200.\n2. When a GET request is made to the same endpoint, the response should return a 405 status code, indicating that the method is not allowed for that route.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `app.delete` method, which registers a handler for DELETE requests at the specified route (`/delete`). The handler returns a text response \"OK\". The test uses `app.test_client.delete` to simulate a DELETE request and checks the response. It also uses `app.test_client.get` to simulate a GET request to the same route, verifying that the server correctly responds with a 405 status code.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward approach to unit testing by using assertions to validate expected outcomes. It utilizes the Sanic testing client to simulate HTTP requests, which allows for testing the application's routing and response behavior in isolation. The use of assertions (`assert response.text == \"OK\"` and `assert response.status == 405`) is a common pattern in unit tests to ensure that the actual output matches the expected output. Additionally, the test is structured to be clear and concise, focusing on specific HTTP methods and their expected behaviors."
    },
    {
      "name": "test_shorthand_routes_patch",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 408,
      "end_line_number": 417,
      "source_code": "def test_shorthand_routes_patch(app):\n    @app.patch(\"/patch\")\n    def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.patch(\"/patch\")\n    assert response.text == \"OK\"\n\n    request, response = app.test_client.get(\"/patch\")\n    assert response.status == 405",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert response.status == 405"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "app.patch('/patch')",
        "app.test_client.patch('/patch')"
      ],
      "methods_under_test": [
        {
          "name": "app.patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "app.test_client.patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_shorthand_routes_patch` test is to verify the correct behavior of the PATCH HTTP method in a Sanic web application. It ensures that the application can handle PATCH requests appropriately and responds with the expected status codes for unsupported methods.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks two main behaviors: \n1. When a PATCH request is made to the `/patch` endpoint, the server should return a response with the text \"OK\".\n2. When a GET request is made to the same `/patch` endpoint, the server should respond with a 405 Method Not Allowed status, indicating that the GET method is not supported for this route.\n\n**Code Being Tested and How It Works**:  \nThe test defines a PATCH route using the `@app.patch(\"/patch\")` decorator, which associates the `handler` function with the `/patch` URL. The `handler` function simply returns a text response \"OK\". The test then simulates a PATCH request to this endpoint using `app.test_client.patch(\"/patch\")` and checks that the response text matches \"OK\". Subsequently, it simulates a GET request to the same endpoint and asserts that the response status is 405, confirming that the route does not support GET requests.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward unit testing pattern where:\n- It uses decorators to define routes, which is a common practice in web frameworks to associate HTTP methods with handler functions.\n- It utilizes assertions to validate the expected outcomes of the requests, ensuring that the application behaves as intended.\n- The test client is used to simulate HTTP requests, allowing for isolated testing of route handlers without needing to run the entire application server. This approach is efficient for unit tests, focusing on specific functionalities."
    },
    {
      "name": "test_shorthand_routes_head",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 420,
      "end_line_number": 429,
      "source_code": "def test_shorthand_routes_head(app):\n    @app.head(\"/head\")\n    def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.head(\"/head\")\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/head\")\n    assert response.status == 405",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.status == 405"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.head",
          "body": "def head(self, request):\n    return text('', headers={'method': 'HEAD'})"
        },
        {
          "name": "app.test_client.head",
          "body": "def head(self, request):\n    return text('', headers={'method': 'HEAD'})"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_shorthand_routes_head` test is designed to verify the behavior of HTTP HEAD and GET requests on a specific route (\"/head\") in a Sanic web application. It ensures that the application correctly handles HEAD requests by returning a 200 status code and that GET requests to the same route return a 405 Method Not Allowed status.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks two key behaviors:\n1. When a HEAD request is made to the \"/head\" route, the response status should be 200, indicating that the request was successful.\n2. When a GET request is made to the same route, the response status should be 405, indicating that the method is not allowed for that route.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes:\n- The `app.head` method, which registers a handler for HEAD requests at the \"/head\" route. The handler returns a response with a status of 200 and a body of \"OK\".\n- The `app.test_client.head` method, which simulates a HEAD request to the application.\n- The `app.test_client.get` method, which simulates a GET request to the same route.\n\nThe test first registers a handler for HEAD requests and then uses the test client to make both a HEAD and a GET request to the \"/head\" route, asserting the expected response statuses.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Route Registration**: The test dynamically registers a route handler for HEAD requests, demonstrating the flexibility of the Sanic framework in handling different HTTP methods.\n- **Client Simulation**: The use of `app.test_client` allows for simulating HTTP requests to the application, which is a common pattern in testing web applications.\n- **Assertion of Response Status**: The test employs assertions to verify the correctness of the response status codes, which is a fundamental practice in unit testing to ensure that the application behaves as expected under different conditions."
    },
    {
      "name": "test_shorthand_routes_options",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 432,
      "end_line_number": 441,
      "source_code": "def test_shorthand_routes_options(app):\n    @app.options(\"/options\")\n    def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.options(\"/options\")\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/options\")\n    assert response.status == 405",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.status == 405"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.options",
          "body": "def options(self, request):\n    return text('', headers={'method': 'OPTIONS'})"
        },
        {
          "name": "app.test_client.options",
          "body": "def options(self, request):\n    return text('', headers={'method': 'OPTIONS'})"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_shorthand_routes_options` test verifies the behavior of the OPTIONS HTTP method in a Sanic web application. It ensures that the application correctly handles OPTIONS requests and responds with the appropriate status codes for both OPTIONS and GET requests to the same route.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks two key behaviors:\n1. When an OPTIONS request is made to the `/options` route, the server should respond with a status code of 200, indicating that the request was successful.\n2. When a GET request is made to the same `/options` route, the server should respond with a status code of 405, indicating that the method is not allowed for that route.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route handler for the OPTIONS method using the `@app.options` decorator. The handler simply returns a text response \"OK\". The test then uses the `app.test_client` to simulate HTTP requests:\n- It first sends an OPTIONS request to `/options` and asserts that the response status is 200.\n- Next, it sends a GET request to the same route and asserts that the response status is 405. This behavior is expected because the route is defined only for OPTIONS and not for GET.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Route Definition**: The test dynamically defines a route within the test function, showcasing the flexibility of the Sanic framework in handling routes.\n- **Client Simulation**: It uses `app.test_client` to simulate HTTP requests, which is a common pattern in testing web applications to verify the behavior of routes without needing to run a server.\n- **Assertion Checks**: The test employs assertions to validate the expected outcomes of the requests, ensuring that the application behaves as intended under different HTTP methods."
    },
    {
      "name": "test_static_routes",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 444,
      "end_line_number": 457,
      "source_code": "def test_static_routes(app):\n    @app.route(\"/test\")\n    async def handler1(request):\n        return text(\"OK1\")\n\n    @app.route(\"/pizazz\")\n    async def handler2(request):\n        return text(\"OK2\")\n\n    request, response = app.test_client.get(\"/test\")\n    assert response.text == \"OK1\"\n\n    request, response = app.test_client.get(\"/pizazz\")\n    assert response.text == \"OK2\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK1'",
        "assert response.text == 'OK2'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_static_routes` function is designed to verify that the static routes defined in the Sanic application respond correctly to HTTP GET requests. Specifically, it checks that the routes `/test` and `/pizazz` return the expected responses.\n\n**Specific Functionality or Behavior Verified**:  \nThis test confirms that when a GET request is made to the `/test` route, the response text is \"OK1\", and when a GET request is made to the `/pizazz` route, the response text is \"OK2\". This ensures that the routing and response handling for these static endpoints are functioning as intended.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes two route handlers defined within the `test_static_routes` function. The first handler responds to the `/test` route with \"OK1\", and the second handler responds to the `/pizazz` route with \"OK2\". The test uses the `app.test_client.get` method to simulate GET requests to these routes and checks the response text against the expected values.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern, using `assert` statements to validate the response text. It also utilizes the Sanic testing client to simulate HTTP requests, which is a common technique in unit testing web applications. The test is structured to be clear and concise, focusing on specific routes and their expected outputs, which is a best practice in unit testing to ensure maintainability and clarity."
    },
    {
      "name": "test_dynamic_route",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 460,
      "end_line_number": 473,
      "source_code": "def test_dynamic_route(app):\n    results = []\n\n    @app.route(\"/folder/<name>\")\n    async def handler(request, name):\n        results.append(name)\n        return text(\"OK\")\n\n    app.router.finalize(False)\n\n    request, response = app.test_client.get(\"/folder/test123\")\n\n    assert response.text == \"OK\"\n    assert results[0] == \"test123\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert results[0] == 'test123'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_dynamic_route` function is designed to verify the behavior of dynamic routing in a Sanic web application. It specifically tests that the application correctly handles a route with a dynamic segment, capturing the value passed in the URL and returning the expected response.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a request is made to the route `/folder/<name>`, the application correctly extracts the `name` parameter from the URL and appends it to a results list. It also verifies that the response text is \"OK\", indicating that the handler executed successfully.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the route definition and the request handling mechanism of the Sanic application. The route is defined using the `@app.route` decorator, which maps the URL pattern to the `handler` function. When a GET request is made to `/folder/test123`, the `handler` function is invoked, appending the extracted `name` (\"test123\") to the `results` list and returning a response with the text \"OK\". The test then asserts that the response text matches the expected value and that the first entry in the `results` list is the correct name.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Asynchronous Testing**: The handler function is defined as an asynchronous function, which is a common pattern in modern web frameworks to handle I/O-bound operations efficiently.\n- **Assertions**: The test uses assertions to validate the expected outcomes, ensuring that both the response content and the internal state (the `results` list) are as expected.\n- **Dynamic Routing**: The test demonstrates the use of dynamic URL segments, showcasing how parameters can be captured from the URL and used within the application logic."
    },
    {
      "name": "test_dynamic_route_string",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 476,
      "end_line_number": 492,
      "source_code": "def test_dynamic_route_string(app):\n    results = []\n\n    @app.route(\"/folder/<name:str>\")\n    async def handler(request, name):\n        results.append(name)\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/folder/test123\")\n\n    assert response.text == \"OK\"\n    assert results[0] == \"test123\"\n\n    request, response = app.test_client.get(\"/folder/favicon.ico\")\n\n    assert response.text == \"OK\"\n    assert results[1] == \"favicon.ico\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert results[0] == 'test123'",
        "assert response.text == 'OK'",
        "assert results[1] == 'favicon.ico'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_dynamic_route_string` unit test is designed to verify that the Sanic web framework correctly handles dynamic routing with string parameters in the URL. It ensures that the application can extract the specified string from the URL and that the corresponding handler function processes it as expected.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks two main behaviors: \n1. The ability of the route handler to correctly capture and return the string parameter from the URL (e.g., `/folder/test123` should yield `test123`).\n2. The correct response from the handler when accessing different dynamic routes, confirming that the application responds with \"OK\" for valid routes and captures the parameter values accurately.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route `/folder/<name:str>` where `<name:str>` is a dynamic segment that captures string values from the URL. The handler function appends the captured name to a results list and returns a text response \"OK\". The test then simulates two GET requests using `app.test_client.get()`, first to `/folder/test123` and then to `/folder/favicon.ico`. It asserts that the response text is \"OK\" for both requests and verifies that the correct values were appended to the results list.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test leverages asynchronous route handlers, which is a common pattern in modern web frameworks to handle I/O-bound operations efficiently.\n- **Dynamic Routing**: It demonstrates the use of dynamic route parameters, showcasing how the framework can parse and utilize URL segments.\n- **Assertions**: The test employs assertions to validate both the response content and the internal state (the `results` list), ensuring that the application behaves as expected under different scenarios."
    },
    {
      "name": "test_dynamic_route_int",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 495,
      "end_line_number": 508,
      "source_code": "def test_dynamic_route_int(app):\n    results = []\n\n    @app.route(\"/folder/<folder_id:int>\")\n    async def handler(request, folder_id):\n        results.append(folder_id)\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/folder/12345\")\n    assert response.text == \"OK\"\n    assert isinstance(results[0], int)\n\n    request, response = app.test_client.get(\"/folder/asdf\")\n    assert response.status == 404",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert isinstance(results[0], int)",
        "assert response.status == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_dynamic_route_int` function is designed to verify the behavior of a dynamic route in a Sanic web application that accepts an integer as a path parameter. It ensures that the route correctly processes valid integer inputs and returns a 404 status for invalid inputs.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main scenarios: \n1. When a valid integer (e.g., `12345`) is provided in the URL, the route should return a response with the text \"OK\" and confirm that the extracted `folder_id` is indeed an integer.\n2. When an invalid input (e.g., `asdf`) is provided, the route should return a 404 status, indicating that the requested resource was not found.\n\n**Code Being Tested and How It Works**:  \nThe code under test defines a route using the Sanic framework with the path `/folder/<folder_id:int>`, where `<folder_id:int>` specifies that the `folder_id` parameter must be an integer. The route handler appends the `folder_id` to a results list and returns a text response \"OK\". The test uses the `app.test_client.get` method to simulate HTTP GET requests to the defined route, checking both the response content and status.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertions**: The test employs assertions to validate the expected outcomes, such as checking the response text and the type of the `folder_id`.\n- **Error Handling**: It tests the route's ability to handle invalid input gracefully by asserting a 404 status for non-integer values.\n- **Separation of Concerns**: The test is structured to isolate the route's functionality, focusing solely on the behavior of the dynamic route without interference from other parts of the application."
    },
    {
      "name": "test_dynamic_route_number",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 511,
      "end_line_number": 536,
      "source_code": "def test_dynamic_route_number(app):\n    results = []\n\n    @app.route(\"/weight/<weight:float>\")\n    async def handler(request, weight):\n        results.append(weight)\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/weight/12345\")\n    assert response.text == \"OK\"\n    assert isinstance(results[0], float)\n\n    request, response = app.test_client.get(\"/weight/1234.56\")\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/weight/.12\")\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/weight/12.\")\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/weight/1234-56\")\n    assert response.status == 404\n\n    request, response = app.test_client.get(\"/weight/12.34.56\")\n    assert response.status == 404",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert isinstance(results[0], float)",
        "assert response.status == 200",
        "assert response.status == 200",
        "assert response.status == 200",
        "assert response.status == 404",
        "assert response.status == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_dynamic_route_number` test case is designed to verify the behavior of a dynamic route in a Sanic web application that accepts a floating-point number as a URL parameter. It ensures that the application correctly processes valid float inputs and returns appropriate responses for both valid and invalid formats.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. The route correctly handles valid float inputs (e.g., `12345`, `1234.56`, `.12`, `12.`) and returns a 200 status code with the response text \"OK\".\n2. The route rejects invalid float formats (e.g., `1234-56`, `12.34.56`) and returns a 404 status code.\n3. The captured weight from the request is indeed of type `float`.\n\n**Code Being Tested and How It Works**:  \nThe code under test defines a route `/weight/<weight:float>` that uses a handler function to process incoming requests. The handler appends the parsed weight to a results list and returns a response with the text \"OK\". The test client simulates GET requests to this route with various weight values, checking both the response content and the type of the captured weight.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization of Routes**: The test utilizes Sanic's dynamic routing capabilities to define a route that accepts a float parameter, showcasing how to handle different data types in URL paths.\n- **Assertions**: Multiple assertions are employed to validate both the response content and the status codes, ensuring comprehensive coverage of expected behaviors.\n- **Asynchronous Testing**: The test leverages asynchronous handlers and requests, which is a common pattern in modern web frameworks to handle I/O-bound operations efficiently."
    },
    {
      "name": "test_dynamic_route_regex",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 539,
      "end_line_number": 554,
      "source_code": "def test_dynamic_route_regex(app):\n    @app.route(\"/folder/<folder_id:[A-Za-z0-9]{0,4}>\")\n    async def handler(request, folder_id):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/folder/test\")\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/folder/test1\")\n    assert response.status == 404\n\n    request, response = app.test_client.get(\"/folder/test-123\")\n    assert response.status == 404\n\n    request, response = app.test_client.get(\"/folder/\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.status == 404",
        "assert response.status == 404",
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_dynamic_route_regex` function is designed to verify the behavior of dynamic routing in a Sanic web application, specifically focusing on the regex pattern used to match route parameters. It ensures that the application correctly handles valid and invalid folder IDs based on the defined regex constraints.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. A valid folder ID (up to 4 alphanumeric characters) returns a 200 OK status.\n2. A folder ID exceeding the defined length or containing invalid characters returns a 404 Not Found status.\n3. An empty folder path (\"/folder/\") is also handled correctly, returning a 200 OK status.\n\n**Code Being Tested and How It Works**:  \nThe code under test defines a route `/folder/<folder_id:[A-Za-z0-9]{0,4}>`, where `folder_id` is constrained by a regex pattern that allows only alphanumeric characters with a maximum length of 4. The test uses the `app.test_client.get` method to simulate HTTP GET requests to various endpoints and checks the response status codes to validate the routing logic.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterized Testing**: The test effectively checks multiple scenarios (valid and invalid folder IDs) in a single function, demonstrating a form of parameterized testing.\n- **Assertions**: The use of assertions (`assert response.status == ...`) to validate expected outcomes is a standard practice in unit testing, ensuring that the application behaves as intended.\n- **Asynchronous Testing**: The handler function is defined as asynchronous, which is a common pattern in modern web frameworks like Sanic, allowing for non-blocking I/O operations."
    },
    {
      "name": "test_dynamic_route_uuid",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 557,
      "end_line_number": 577,
      "source_code": "def test_dynamic_route_uuid(app):\n    import uuid\n\n    results = []\n\n    @app.route(\"/quirky/<unique_id:uuid>\")\n    async def handler(request, unique_id):\n        results.append(unique_id)\n        return text(\"OK\")\n\n    url = \"/quirky/123e4567-e89b-12d3-a456-426655440000\"\n    request, response = app.test_client.get(url)\n    assert response.text == \"OK\"\n    assert isinstance(results[0], uuid.UUID)\n\n    generated_uuid = uuid.uuid4()\n    request, response = app.test_client.get(f\"/quirky/{generated_uuid}\")\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/quirky/non-existing\")\n    assert response.status == 404",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert isinstance(results[0], uuid.UUID)",
        "assert response.status == 200",
        "assert response.status == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_dynamic_route_uuid` function is designed to verify the behavior of a dynamic route in a Sanic web application that accepts a UUID as a path parameter. It ensures that the application correctly handles valid UUIDs, returns appropriate responses, and rejects invalid inputs.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks three main scenarios:\n1. A valid UUID is passed in the URL, and the response is \"OK\" with the UUID correctly parsed and stored.\n2. A randomly generated UUID is passed, and the response status is 200, indicating successful handling.\n3. An invalid UUID (a non-existing string) is passed, and the response status is 404, indicating that the route does not exist.\n\n**Code Being Tested and How It Works**:  \nThe code under test defines a route `/quirky/<unique_id:uuid>` that uses a UUID type converter. The handler function appends the parsed UUID to a results list and returns a text response \"OK\". The test simulates HTTP GET requests to this route using the Sanic test client, checking the response text and status codes based on the input provided.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test uses async functions to handle requests, which is essential for testing web applications that operate asynchronously.\n- **Assertions**: The test employs assertions to validate the response text and types, ensuring that the application behaves as expected under different conditions.\n- **UUID Handling**: The test leverages Python's `uuid` module to generate and validate UUIDs, demonstrating the use of built-in libraries for type safety and correctness in web routing."
    },
    {
      "name": "test_dynamic_route_path",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 580,
      "end_line_number": 603,
      "source_code": "def test_dynamic_route_path(app):\n    @app.route(\"/<path:path>/info\")\n    async def handler(request, path):\n        return text(\"OK\")\n\n    app.router.finalize()\n\n    request, response = app.test_client.get(\"/path/1/info\")\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/info\")\n    assert response.status == 404\n\n    app.router.reset()\n\n    @app.route(\"/<path:path>\")\n    async def handler1(request, path):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/info\")\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/whatever/you/set\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.status == 404",
        "assert response.status == 200",
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.router.reset",
          "body": "@pytest.fixture(autouse=True)\ndef reset():\n    try:\n        del os.environ['SANIC_MOTD_OUTPUT']\n    except KeyError:\n        ..."
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_dynamic_route_path` function is designed to verify the behavior of dynamic route handling in a Sanic web application. It specifically tests how the application responds to requests with different path parameters and ensures that the routing logic correctly identifies valid and invalid paths.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main scenarios: \n1. It verifies that a request to a dynamically defined route (e.g., `/path/1/info`) returns a successful response (HTTP status 200).\n2. It confirms that a request to a non-existent route (e.g., `/info`) returns a 404 Not Found status. After resetting the router, it tests additional dynamic routes to ensure they function correctly.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the Sanic application's routing mechanism. The test defines a route with a dynamic path parameter (`<path:path>`) and an endpoint that returns a simple text response. The `app.test_client.get` method simulates HTTP GET requests to the defined routes, allowing the test to assert the expected HTTP status codes based on the defined routes. The `app.router.reset()` method is used to clear the previously defined routes, allowing for a fresh set of routes to be tested.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several key testing patterns:\n- **Setup and Teardown**: The use of `app.router.reset()` ensures that the test environment is clean before defining new routes, preventing interference between tests.\n- **Parameterized Testing**: Although not explicitly shown in this test, the overall test suite demonstrates the use of parameterized tests (e.g., `@pytest.mark.parametrize`) to validate multiple scenarios efficiently.\n- **Assertions**: The test uses assertions to validate the expected outcomes, checking both successful responses and error handling, which is crucial for ensuring the robustness of the routing logic."
    },
    {
      "name": "test_dynamic_route_unhashable",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 606,
      "end_line_number": 621,
      "source_code": "def test_dynamic_route_unhashable(app):\n    @app.route(\"/folder/<unhashable:[A-Za-z0-9/]+>/end/\")\n    async def handler(request, unhashable):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/folder/test/asdf/end/\")\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/folder/test///////end/\")\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/folder/test/end/\")\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/folder/test/nope/\")\n    assert response.status == 404",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.status == 200",
        "assert response.status == 200",
        "assert response.status == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_dynamic_route_unhashable` test is designed to verify the behavior of dynamic routing in a Sanic web application when using unhashable parameters in the route definition. It specifically checks how the application handles various URL patterns that include alphanumeric characters and slashes.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the application correctly responds with a 200 status code for valid routes that match the defined pattern and a 404 status code for invalid routes that do not match. It ensures that the routing mechanism can handle multiple slashes and correctly identifies valid and invalid paths.\n\n**Code Being Tested and How It Works**:  \nThe code under test defines a route using a regular expression to match the `unhashable` parameter, which allows alphanumeric characters and slashes. The test then makes several GET requests to different URLs:\n- `/folder/test/asdf/end/` (valid)\n- `/folder/test///////end/` (valid, multiple slashes)\n- `/folder/test/end/` (valid)\n- `/folder/test/nope/` (invalid)\n\nThe expected responses are asserted against the actual responses to confirm that the routing logic behaves as intended.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the HTTP response status codes, which is a common pattern in unit testing. It also utilizes parameterized routes with regular expressions, showcasing the flexibility of Sanic's routing capabilities. The test structure is straightforward, focusing on clear input-output verification, which is essential for effective unit testing."
    },
    {
      "name": "test_websocket_route",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 625,
      "end_line_number": 636,
      "source_code": "def test_websocket_route(app, url):\n    ev = asyncio.Event()\n\n    @app.websocket(url)\n    async def handler(request, ws):\n        assert request.scheme == \"ws\"\n        assert ws.subprotocol is None\n        ev.set()\n\n    request, response = app.test_client.websocket(url)\n    assert response.opened is True\n    assert ev.is_set()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('url', ['/ws', 'ws'])"
      ],
      "arguments": [
        "app",
        "url"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.opened is True",
        "assert ev.is_set()",
        "assert request.scheme == 'ws'",
        "assert ws.subprotocol is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_websocket_route` function is designed to verify the correct behavior of a WebSocket route in a Sanic application. It ensures that the WebSocket connection is established properly and that the request and WebSocket properties are as expected.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. The WebSocket request scheme is \"ws\".\n2. The WebSocket subprotocol is `None` (indicating no subprotocol was specified).\n3. The WebSocket connection is successfully opened.\n4. An event signaling that the WebSocket handler has been invoked is set.\n\n**Code Being Tested and How It Works**:  \nThe test defines a WebSocket handler using the `@app.websocket(url)` decorator. Inside the handler, assertions are made to verify the request's scheme and the WebSocket's subprotocol. The test client then attempts to open a WebSocket connection to the specified URL. The assertions confirm that the connection is opened and that the event indicating the handler was executed is set.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test utilizes `async` functions and `asyncio.Event` to handle asynchronous behavior, which is crucial for testing WebSocket interactions.\n- **Assertions**: Multiple assertions are employed to validate different aspects of the WebSocket connection and handler behavior, ensuring comprehensive coverage of the expected outcomes.\n- **Event Signaling**: The use of `asyncio.Event` allows the test to synchronize the completion of the WebSocket handler execution, ensuring that the test only proceeds after the handler has run."
    },
    {
      "name": "test_websocket_route_invalid_handler",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 639,
      "end_line_number": 648,
      "source_code": "def test_websocket_route_invalid_handler(app):\n    with pytest.raises(ValueError) as e:\n\n        @app.websocket(\"/\")\n        async def handler(): ...\n\n    assert e.match(\n        r\"Required parameter `request` and/or `ws` missing in the \"\n        r\"handler\\(\\) route\\?\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert e.match('Required parameter `request` and/or `ws` missing in the handler\\\\(\\\\) route\\\\?')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_websocket_route_invalid_handler` is designed to verify that the Sanic framework correctly raises a `ValueError` when a websocket route handler is defined without the required parameters. Specifically, it checks that the handler function must include both `request` and `ws` parameters to be valid.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the framework enforces the requirement for the handler function to accept the necessary parameters. If the parameters are missing, the test expects a `ValueError` to be raised, indicating that the handler is improperly defined.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the registration of a websocket route handler using the `@app.websocket(\"/\")` decorator. The test attempts to define a handler function that does not accept any parameters. When this occurs, the framework's internal logic should detect the missing parameters and raise a `ValueError` with a specific error message. The assertion checks that the raised error message matches the expected pattern, confirming that the error handling works as intended.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that a specific exception (`ValueError`) is raised during the execution of the code block. Additionally, it uses a regular expression match to verify that the error message contains the expected text, which is a common technique for validating error handling in unit tests. This approach ensures that not only is the exception raised, but it also conveys the correct information about the nature of the error."
    },
    {
      "name": "test_websocket_route_with_subprotocols",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 678,
      "end_line_number": 691,
      "source_code": "def test_websocket_route_with_subprotocols(app, subprotocols, expected):\n    results = []\n\n    @app.websocket(\"/ws\", subprotocols=[\"zero\", \"one\", \"two\", \"three\"])\n    async def handler(request, ws):\n        nonlocal results\n        results = ws.subprotocol\n        assert ws.subprotocol is not None\n\n    _, response = SanicTestClient(app).websocket(\n        \"/ws\", subprotocols=subprotocols\n    )\n    assert response.opened is True\n    assert results == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('subprotocols,expected', ((['one'], 'one'), (['three', 'one'], 'one'), (['tree'], None), (None, None)))"
      ],
      "arguments": [
        "app",
        "subprotocols",
        "expected"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.opened is True",
        "assert results == expected",
        "assert ws.subprotocol is not None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_websocket_route_with_subprotocols` is designed to verify that a WebSocket route in a Sanic application correctly handles subprotocols during the WebSocket handshake process. It ensures that the server can accept a specified subprotocol from the client and that the expected subprotocol is returned.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main behaviors: \n1. It verifies that the WebSocket connection is successfully opened (`response.opened is True`).\n2. It confirms that the subprotocol returned by the WebSocket handler matches the expected value provided in the test parameters (`results == expected`).\n\n**Code Being Tested and How It Works**:  \nThe code under test involves a WebSocket route defined in the Sanic application. The route is set up to accept specific subprotocols (`[\"zero\", \"one\", \"two\", \"three\"]`). The test uses the `SanicTestClient` to initiate a WebSocket connection to the route with a given set of subprotocols (`subprotocols`). The handler captures the subprotocol chosen by the client and asserts that it is not `None`. The results are then compared against the expected value to ensure correctness.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test utilizes asynchronous functions to handle WebSocket connections, which is essential for testing real-time communication protocols.\n- **Nonlocal Variables**: The use of `nonlocal` allows the inner handler function to modify the `results` list defined in the outer test function, facilitating the capture of the subprotocol.\n- **Assertions**: The test employs assertions to validate the expected outcomes, ensuring that both the connection state and the subprotocol are as intended.\n- **Parameterization**: Although not directly shown in this specific test, the surrounding tests in the codebase utilize `pytest.mark.parametrize`, indicating a pattern of testing multiple scenarios with different inputs, which enhances test coverage and robustness."
    },
    {
      "name": "test_add_webscoket_route",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 695,
      "end_line_number": 705,
      "source_code": "def test_add_webscoket_route(app, strict_slashes):\n    ev = asyncio.Event()\n\n    async def handler(request, ws):\n        assert ws.subprotocol is None\n        ev.set()\n\n    app.add_websocket_route(handler, \"/ws\", strict_slashes=strict_slashes)\n    request, response = app.test_client.websocket(\"/ws\")\n    assert response.opened is True\n    assert ev.is_set()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('strict_slashes', [True, False, None])"
      ],
      "arguments": [
        "app",
        "strict_slashes"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.opened is True",
        "assert ev.is_set()",
        "assert ws.subprotocol is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_add_webscoket_route` function is designed to verify the correct addition of a WebSocket route to a Sanic application. It ensures that the WebSocket handler is properly registered and that it behaves as expected when a connection is established.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. The WebSocket connection is successfully opened (`response.opened is True`).\n2. The event signaling that the handler has been invoked is set (`ev.is_set()`), indicating that the handler was executed.\n3. The `subprotocol` of the WebSocket connection is `None`, confirming that no subprotocol was specified during the handshake.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `add_websocket_route` method of the Sanic application, which registers a WebSocket handler for a specified URI. The test creates an asynchronous handler that asserts the `subprotocol` is `None` and sets an event when invoked. The test then simulates a WebSocket connection to the registered route (`/ws`) and checks the expected outcomes.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test uses `async` functions and `asyncio.Event` to handle asynchronous behavior, ensuring that the WebSocket handler is tested in a non-blocking manner.\n- **Assertions**: It employs assertions to validate the state of the WebSocket connection and the execution of the handler, which is a common practice in unit testing to verify expected outcomes.\n- **Parameterization**: The test is parameterized with `strict_slashes`, allowing it to run multiple scenarios with different configurations, enhancing coverage without duplicating code."
    },
    {
      "name": "test_add_webscoket_route_with_version",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 708,
      "end_line_number": 718,
      "source_code": "def test_add_webscoket_route_with_version(app):\n    ev = asyncio.Event()\n\n    async def handler(request, ws):\n        assert ws.subprotocol is None\n        ev.set()\n\n    app.add_websocket_route(handler, \"/ws\", version=1)\n    request, response = app.test_client.websocket(\"/v1/ws\")\n    assert response.opened is True\n    assert ev.is_set()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.opened is True",
        "assert ev.is_set()",
        "assert ws.subprotocol is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_add_webscoket_route_with_version` is designed to verify that a websocket route can be successfully added to the application with a specified version, and that the websocket connection behaves as expected when accessed via the correct versioned URL.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that:\n1. The websocket connection is successfully opened.\n2. The event signaling that the websocket handler has been invoked is set, indicating that the handler executed correctly.\n3. The websocket's subprotocol is `None`, confirming that no subprotocol was specified during the connection.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `add_websocket_route` method of the `app` object, which registers a websocket handler for the specified URI (`/ws`) with a version parameter set to `1`. The handler asserts that the websocket's subprotocol is `None` and sets an event when invoked. The test then simulates a websocket connection to the versioned URI (`/v1/ws`) and checks the response to ensure the connection is opened and the event is set.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test uses `async` functions and `asyncio.Event` to handle asynchronous operations, ensuring that the websocket handler can be tested in a non-blocking manner.\n- **Assertions**: It employs assertions to validate the state of the websocket connection and the event, which are crucial for confirming the expected behavior of the websocket route.\n- **Separation of Concerns**: The test clearly separates the setup (adding the route), execution (establishing the websocket connection), and verification (asserting conditions), which enhances readability and maintainability."
    },
    {
      "name": "test_route_duplicate",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 721,
      "end_line_number": 740,
      "source_code": "def test_route_duplicate(app):\n    with pytest.raises(RouteExists):\n\n        @app.route(\"/test\")\n        async def handler1(request):\n            pass\n\n        @app.route(\"/test\")\n        async def handler2(request):\n            pass\n\n    with pytest.raises(RouteExists):\n\n        @app.route(\"/test/<dynamic>/\")\n        async def handler3(request, dynamic):\n            pass\n\n        @app.route(\"/test/<dynamic>/\")\n        async def handler4(request, dynamic):\n            pass",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_route_duplicate` function is designed to verify that the Sanic application correctly raises a `RouteExists` exception when attempting to register multiple routes with the same path. This ensures that the routing system enforces unique route definitions, preventing conflicts that could lead to unexpected behavior.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks for the handling of duplicate route definitions. It verifies that when two asynchronous route handlers are registered for the same path (both static and dynamic), the application raises the appropriate exception (`RouteExists`). This behavior is crucial for maintaining the integrity of the routing system in the application.\n\n**Code Being Tested and How It Works**:  \nThe test uses the `@app.route` decorator to define two asynchronous route handlers for the same path (`\"/test\"` and `\"/test/<dynamic>/\"`). The first block of the test attempts to register `handler1` and `handler2` for the static route, while the second block does the same for a dynamic route. The `with pytest.raises(RouteExists)` context manager is used to assert that the expected exception is raised when the duplicate routes are defined.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Manager for Exception Testing**: The use of `with pytest.raises(RouteExists)` is a common pattern in testing to assert that specific exceptions are raised during the execution of a block of code. This pattern enhances readability and clearly indicates the expected outcome.\n- **Asynchronous Testing**: The test leverages asynchronous route handlers, which is a key feature of the Sanic framework. This demonstrates the ability to test asynchronous code effectively within the unit test framework.\n- **Route Registration Verification**: By attempting to register duplicate routes, the test directly verifies the application's routing logic, ensuring that it adheres to the expected behavior of rejecting duplicate definitions."
    },
    {
      "name": "test_double_stack_route",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 743,
      "end_line_number": 752,
      "source_code": "def test_double_stack_route(app):\n    @app.route(\"/test/1\", name=\"test1\")\n    @app.route(\"/test/2\", name=\"test2\")\n    async def handler1(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/test/1\")\n    assert response.status == 200\n    request, response = app.test_client.get(\"/test/2\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_double_stack_route` function is designed to verify that two separate routes (`/test/1` and `/test/2`) in a Sanic web application return a successful HTTP response (status code 200) when accessed via GET requests.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks the correct registration and handling of multiple routes in the Sanic application. It ensures that both routes respond appropriately and independently, confirming that the routing mechanism works as expected.\n\n**Code Being Tested and How It Works**:  \nThe test defines two routes using the `@app.route` decorator, both pointing to the same asynchronous handler function `handler1`, which returns a simple text response \"OK\". The test then simulates GET requests to both routes using `app.test_client.get`, capturing the response for each request. The assertions check that the HTTP status of both responses is 200, indicating successful handling of the requests.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test leverages asynchronous route handlers, which is a common pattern in modern web frameworks like Sanic. This allows for non-blocking I/O operations.\n- **Route Registration**: The use of decorators to register multiple routes to the same handler demonstrates a flexible routing mechanism.\n- **Assertions**: The test employs simple assertions to validate the expected outcomes, which is a fundamental practice in unit testing to ensure that the code behaves as intended."
    },
    {
      "name": "test_method_not_allowed",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 772,
      "end_line_number": 781,
      "source_code": "def test_method_not_allowed(app):\n    @app.route(\"/test\", methods=[\"GET\"])\n    async def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/test\")\n    assert response.status == 200\n\n    request, response = app.test_client.post(\"/test\")\n    assert response.status == 405",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.status == 405"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_method_not_allowed` test case is designed to verify that the Sanic web framework correctly handles HTTP methods that are not allowed for a specific route. It ensures that when a client attempts to use a method (POST) that is not permitted on a defined route (which only allows GET), the server responds with the appropriate HTTP status code (405 Method Not Allowed).\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks two behaviors: \n1. It confirms that a GET request to the `/test` route returns a 200 OK status, indicating that the route is accessible via the GET method.\n2. It verifies that a POST request to the same route returns a 405 status, indicating that the POST method is not allowed for that route.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the route handler defined for the Sanic application:\n```python\n@app.route(\"/test\", methods=[\"GET\"])\nasync def handler(request):\n    return text(\"OK\")\n```\nThis handler is set to respond only to GET requests. The test uses the `app.test_client` to simulate HTTP requests to this route. The first request is a GET request, which should return a 200 status, while the second request is a POST request, which should return a 405 status due to the method restriction.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Client Simulation**: The test utilizes `app.test_client` to simulate HTTP requests, allowing for easy testing of route behaviors without needing to run a live server.\n- **Assertion Checks**: The test employs assertions to validate the response status codes, ensuring that the application behaves as expected under different request methods.\n- **Asynchronous Testing**: The test is structured to work with asynchronous route handlers, which is a common pattern in modern web frameworks like Sanic, allowing for non-blocking I/O operations."
    },
    {
      "name": "test_static_add_route",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 785,
      "end_line_number": 799,
      "source_code": "def test_static_add_route(app, strict_slashes):\n    async def handler1(request):\n        return text(\"OK1\")\n\n    async def handler2(request):\n        return text(\"OK2\")\n\n    app.add_route(handler1, \"/test\", strict_slashes=strict_slashes)\n    app.add_route(handler2, \"/test2\", strict_slashes=strict_slashes)\n\n    request, response = app.test_client.get(\"/test\")\n    assert response.text == \"OK1\"\n\n    request, response = app.test_client.get(\"/test2\")\n    assert response.text == \"OK2\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('strict_slashes', [True, False, None])"
      ],
      "arguments": [
        "app",
        "strict_slashes"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK1'",
        "assert response.text == 'OK2'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_static_add_route` function is designed to verify that static routes can be added to a Sanic application and that these routes respond correctly to HTTP GET requests. It ensures that the application correctly handles requests to the specified endpoints and returns the expected responses.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when two asynchronous handler functions (`handler1` and `handler2`) are registered to the routes `/test` and `/test2`, respectively, the application responds with the correct text (\"OK1\" for `/test` and \"OK2\" for `/test2`) when these routes are accessed via GET requests.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `app.add_route` method, which registers the provided handler functions to specific URL paths. The `app.test_client.get` method is then used to simulate GET requests to these routes. The assertions check that the response text matches the expected output, confirming that the routing and handler invocation are functioning as intended.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the Arrange-Act-Assert (AAA) pattern:\n- **Arrange**: The routes and their corresponding handlers are set up using `app.add_route`.\n- **Act**: The test client simulates GET requests to the defined routes.\n- **Assert**: The test checks the response text against expected values using assertions. This pattern helps maintain clarity and structure in the test, making it easier to understand the flow of operations. Additionally, the use of asynchronous handlers reflects the asynchronous nature of the Sanic framework, ensuring that the test is appropriate for the context in which it operates."
    },
    {
      "name": "test_unquote_add_route",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 803,
      "end_line_number": 814,
      "source_code": "def test_unquote_add_route(app, unquote):\n    async def handler1(_, foo):\n        return text(foo)\n\n    app.add_route(handler1, \"/<foo>\", unquote=unquote)\n    value = \"\u554a\" if unquote else r\"%E5%95%8A\"\n\n    _, response = app.test_client.get(\"/\u554a\")\n    assert response.text == value\n\n    _, response = app.test_client.get(r\"/%E5%95%8A\")\n    assert response.text == value",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('unquote', [True, False, None])"
      ],
      "arguments": [
        "app",
        "unquote"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == value",
        "assert response.text == value"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_unquote_add_route` function is designed to verify the behavior of the Sanic web framework when adding a route that can handle both URL-encoded and decoded path parameters. It specifically tests how the `unquote` parameter affects the handling of these parameters in the route.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the route correctly returns the expected response when accessed with both a decoded URL (e.g., `/\u554a`) and an encoded URL (e.g., `/%E5%95%8A`). The expected output varies based on the value of the `unquote` parameter, ensuring that the application behaves correctly in both scenarios.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `app.add_route` method, which registers an asynchronous handler (`handler1`) for the route `\"/<foo>\"`. The handler returns the value of the `foo` parameter as text. The test then simulates GET requests to this route using the Sanic test client, checking the response text against the expected value, which is determined by the `unquote` flag.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of asynchronous testing with the Sanic framework, utilizing the `app.test_client.get` method to simulate HTTP GET requests. It also uses assertions to validate the response, ensuring that the application correctly handles both encoded and decoded URL parameters. The conditional assignment of the `value` variable based on the `unquote` parameter is a notable technique that allows for flexible testing of different input scenarios."
    },
    {
      "name": "test_dynamic_add_route",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 817,
      "end_line_number": 828,
      "source_code": "def test_dynamic_add_route(app):\n    results = []\n\n    async def handler(request, name):\n        results.append(name)\n        return text(\"OK\")\n\n    app.add_route(handler, \"/folder/<name>\")\n    request, response = app.test_client.get(\"/folder/test123\")\n\n    assert response.text == \"OK\"\n    assert results[0] == \"test123\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert results[0] == 'test123'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_dynamic_add_route` function is designed to verify that the Sanic application can dynamically add a route that captures a variable from the URL and correctly processes requests to that route.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a request is made to the dynamically added route `/folder/<name>`, the application correctly invokes the handler function, captures the variable `name` from the URL, and returns the expected response. It also verifies that the captured variable is correctly appended to the `results` list.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `app.add_route(handler, \"/folder/<name>\")` method, which registers the `handler` function to respond to GET requests at the specified path. The `handler` function takes two parameters: `request` and `name`. When a request is made to `/folder/test123`, the `name` parameter is populated with the value `test123`, which is then appended to the `results` list. The function returns a text response \"OK\". The test then checks that the response text is \"OK\" and that the first element of the `results` list matches the expected value.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of asynchronous handlers, which is a common pattern in web frameworks like Sanic. It also utilizes assertions to validate the expected outcomes, ensuring that both the response content and the internal state (the `results` list) are as expected. The test structure is straightforward, focusing on a single route and its behavior, which is a good practice for unit tests to maintain clarity and isolation of functionality."
    },
    {
      "name": "test_dynamic_add_route_string",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 831,
      "end_line_number": 847,
      "source_code": "def test_dynamic_add_route_string(app):\n    results = []\n\n    async def handler(request, name):\n        results.append(name)\n        return text(\"OK\")\n\n    app.add_route(handler, \"/folder/<name:str>\")\n    request, response = app.test_client.get(\"/folder/test123\")\n\n    assert response.text == \"OK\"\n    assert results[0] == \"test123\"\n\n    request, response = app.test_client.get(\"/folder/favicon.ico\")\n\n    assert response.text == \"OK\"\n    assert results[1] == \"favicon.ico\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert results[0] == 'test123'",
        "assert response.text == 'OK'",
        "assert results[1] == 'favicon.ico'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_dynamic_add_route_string` test verifies that the Sanic application can dynamically add a route that captures a string parameter from the URL and correctly invokes the associated handler function.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a request is made to a dynamically added route (in this case, `/folder/<name:str>`), the application correctly extracts the string parameter from the URL and passes it to the handler. It also ensures that the response from the handler is as expected.\n\n**Code Being Tested and How It Works**:  \nThe test defines an asynchronous handler function that appends the captured `name` parameter to a `results` list and returns a text response \"OK\". The route is added to the app using `app.add_route(handler, \"/folder/<name:str>\")`. The test then simulates two GET requests: one to `/folder/test123` and another to `/folder/favicon.ico`. It asserts that the response text is \"OK\" for both requests and verifies that the correct parameters were captured in the `results` list.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test uses asynchronous functions to handle requests, which is essential for testing web applications that operate in an asynchronous environment.\n- **Dynamic Route Testing**: It tests the dynamic routing capabilities of the Sanic framework by using route parameters, ensuring that the framework can handle variable paths correctly.\n- **Assertions**: The test employs assertions to validate both the response content and the internal state (the `results` list), ensuring that the application behaves as expected under different scenarios."
    },
    {
      "name": "test_dynamic_add_route_int",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 850,
      "end_line_number": 864,
      "source_code": "def test_dynamic_add_route_int(app):\n    results = []\n\n    async def handler(request, folder_id):\n        results.append(folder_id)\n        return text(\"OK\")\n\n    app.add_route(handler, \"/folder/<folder_id:int>\")\n\n    request, response = app.test_client.get(\"/folder/12345\")\n    assert response.text == \"OK\"\n    assert isinstance(results[0], int)\n\n    request, response = app.test_client.get(\"/folder/asdf\")\n    assert response.status == 404",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert isinstance(results[0], int)",
        "assert response.status == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_dynamic_add_route_int` test case is designed to verify the behavior of a dynamic route in a Sanic web application that accepts an integer parameter. It ensures that the route correctly processes valid integer inputs and returns a 404 status for invalid inputs.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main functionalities: \n1. When a valid integer (e.g., `12345`) is passed in the URL, the handler should return a response with the text \"OK\" and the integer should be appended to the `results` list.\n2. When an invalid input (e.g., `asdf`) is provided, the route should return a 404 status, indicating that the route could not be matched.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `app.add_route` method, which registers a new route with a dynamic integer parameter (`<folder_id:int>`). The `handler` function processes incoming requests, appending the integer `folder_id` to the `results` list and returning a text response. The test uses the `app.test_client.get` method to simulate GET requests to the defined route, checking both the response content and status.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test utilizes asynchronous functions to handle requests, which is a common pattern in web frameworks like Sanic that support async operations.\n- **Assertions**: The test employs assertions to validate the expected outcomes, ensuring that the response text and status are as intended.\n- **Dynamic Routing**: The test demonstrates the use of dynamic routing with type constraints (e.g., `int`), showcasing how the framework can handle different types of parameters in URLs."
    },
    {
      "name": "test_dynamic_add_route_number",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 867,
      "end_line_number": 893,
      "source_code": "def test_dynamic_add_route_number(app):\n    results = []\n\n    async def handler(request, weight):\n        results.append(weight)\n        return text(\"OK\")\n\n    app.add_route(handler, \"/weight/<weight:float>\")\n\n    request, response = app.test_client.get(\"/weight/12345\")\n    assert response.text == \"OK\"\n    assert isinstance(results[0], float)\n\n    request, response = app.test_client.get(\"/weight/1234.56\")\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/weight/.12\")\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/weight/12.\")\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/weight/1234-56\")\n    assert response.status == 404\n\n    request, response = app.test_client.get(\"/weight/12.34.56\")\n    assert response.status == 404",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert isinstance(results[0], float)",
        "assert response.status == 200",
        "assert response.status == 200",
        "assert response.status == 200",
        "assert response.status == 404",
        "assert response.status == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_dynamic_add_route_number` test is to verify that the Sanic application correctly handles dynamic route parameters of type float. It ensures that the application can parse float values from the URL and respond appropriately, while also validating that invalid float formats return a 404 error.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks the following behaviors:\n1. Successful handling of valid float parameters in the URL (e.g., `/weight/12345`, `/weight/1234.56`, `/weight/.12`, `/weight/12.`).\n2. Correct response text and type for the first valid float request.\n3. Proper handling of invalid float formats that should return a 404 status (e.g., `/weight/1234-56`, `/weight/12.34.56`).\n\n**Code Being Tested and How It Works**:  \nThe code being tested includes the `app.add_route` method, which registers an asynchronous handler function for the route `/weight/<weight:float>`. The handler appends the parsed weight to a results list and returns a text response \"OK\". The test then simulates GET requests to this route using the `app.test_client.get` method, checking both the response text and status codes based on the input.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test uses an asynchronous handler, which is a common pattern in modern web frameworks to handle I/O-bound operations efficiently.\n- **Parameterization of Routes**: The test leverages dynamic route parameters to validate different input formats, showcasing the flexibility of the routing system.\n- **Assertions**: Multiple assertions are used to validate both the response content and the status codes, ensuring comprehensive coverage of expected behaviors."
    },
    {
      "name": "test_dynamic_add_route_regex",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 896,
      "end_line_number": 912,
      "source_code": "def test_dynamic_add_route_regex(app):\n    async def handler(request, folder_id):\n        return text(\"OK\")\n\n    app.add_route(handler, \"/folder/<folder_id:[A-Za-z0-9]{0,4}>\")\n\n    request, response = app.test_client.get(\"/folder/test\")\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/folder/test1\")\n    assert response.status == 404\n\n    request, response = app.test_client.get(\"/folder/test-123\")\n    assert response.status == 404\n\n    request, response = app.test_client.get(\"/folder/\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.status == 404",
        "assert response.status == 404",
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_dynamic_add_route_regex` test is to verify that the Sanic application correctly handles dynamic routing with regular expressions, specifically ensuring that the route defined for folder IDs only accepts valid patterns and returns appropriate HTTP status codes.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that:\n1. A valid folder ID (up to 4 alphanumeric characters) returns a 200 OK status.\n2. A folder ID exceeding the defined pattern (e.g., \"test1\" or \"test-123\") returns a 404 Not Found status.\n3. An empty folder ID (\"/folder/\") returns a 200 OK status, indicating that the route can handle optional parameters.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `app.add_route` method, which registers an asynchronous handler function for the route `/folder/<folder_id:[A-Za-z0-9]{0,4}>`. The handler returns a simple text response \"OK\". The test then simulates HTTP GET requests to various endpoints:\n- `/folder/test` matches the regex and returns 200.\n- `/folder/test1` and `/folder/test-123` do not match the regex and return 404.\n- `/folder/` is tested to ensure it can handle an empty folder ID, returning 200.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the following patterns:\n- **Parameterized Testing**: It checks multiple scenarios (valid and invalid folder IDs) to ensure comprehensive coverage of the route's behavior.\n- **Asynchronous Testing**: The use of `async def` for the handler and the test client allows for testing asynchronous behavior, which is crucial in web frameworks like Sanic.\n- **Assertions**: The test uses assertions to validate the expected HTTP response statuses, ensuring that the application behaves as intended under different conditions."
    },
    {
      "name": "test_dynamic_add_route_unhashable",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 915,
      "end_line_number": 931,
      "source_code": "def test_dynamic_add_route_unhashable(app):\n    async def handler(request, unhashable):\n        return text(\"OK\")\n\n    app.add_route(handler, \"/folder/<unhashable:[A-Za-z0-9/]+>/end/\")\n\n    request, response = app.test_client.get(\"/folder/test/asdf/end/\")\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/folder/test///////end/\")\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/folder/test/end/\")\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/folder/test/nope/\")\n    assert response.status == 404",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.status == 200",
        "assert response.status == 200",
        "assert response.status == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_dynamic_add_route_unhashable` test is designed to verify the behavior of a Sanic application when handling dynamic routes that include unhashable parameters in the URL. It specifically checks if the application correctly processes requests with various valid and invalid unhashable segments.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the application responds with a 200 status code for valid URLs that match the defined route pattern, and a 404 status code for invalid URLs that do not match the expected format. It ensures that the route can handle multiple segments in the unhashable parameter and that it correctly identifies when a request does not conform to the expected pattern.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `app.add_route` method, which registers a route handler for the path `/folder/<unhashable:[A-Za-z0-9/]+>/end/`. The handler function returns a simple text response \"OK\". The test then makes several GET requests to this route with different URL patterns, asserting the expected HTTP response status for each request. The valid patterns include segments with alphanumeric characters and slashes, while the invalid pattern tests a case that does not conform to the regex.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the response status codes, which is a common practice in unit testing to ensure that the application behaves as expected. It also demonstrates the use of regex in route definitions to handle dynamic URL segments, showcasing how Sanic can manage complex routing scenarios. The test is structured to cover multiple cases, ensuring comprehensive coverage of the route's behavior."
    },
    {
      "name": "test_add_route_duplicate",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 934,
      "end_line_number": 955,
      "source_code": "def test_add_route_duplicate(app):\n    with pytest.raises(RouteExists):\n\n        async def handler1(request):\n            pass\n\n        async def handler2(request):\n            pass\n\n        app.add_route(handler1, \"/test\")\n        app.add_route(handler2, \"/test\")\n\n    with pytest.raises(RouteExists):\n\n        async def handler1(request, dynamic):\n            pass\n\n        async def handler2(request, dynamic):\n            pass\n\n        app.add_route(handler1, \"/test/<dynamic>/\")\n        app.add_route(handler2, \"/test/<dynamic>/\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_add_route_duplicate` test is designed to verify that the Sanic application correctly raises a `RouteExists` exception when attempting to add multiple routes with the same path. This ensures that the routing system prevents duplicate route definitions, which could lead to ambiguous behavior in the application.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two scenarios: \n1. Adding two asynchronous route handlers (`handler1` and `handler2`) to the same path (`/test`) and expecting a `RouteExists` exception to be raised on the second addition.\n2. Adding two asynchronous route handlers with a dynamic segment in the path (`/test/<dynamic>/`) and similarly expecting a `RouteExists` exception on the second addition.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `add_route` method of the Sanic application instance (`app`). This method is responsible for registering a route with a specified handler and path. When a route is added, the method checks if the path already exists in the routing table. If it does, it raises a `RouteExists` exception, which is what the test is asserting.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that specific exceptions are raised during the execution of the code block. This is a common pattern in unit testing to verify that error handling works as expected. Additionally, the use of asynchronous functions (`async def`) indicates that the test is designed to work with asynchronous code, which is a key feature of the Sanic framework. The test is structured to clearly separate the two scenarios being tested, enhancing readability and maintainability."
    },
    {
      "name": "test_add_route_method_not_allowed",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 958,
      "end_line_number": 968,
      "source_code": "def test_add_route_method_not_allowed(app):\n    async def handler(request):\n        return text(\"OK\")\n\n    app.add_route(handler, \"/test\", methods=[\"GET\"])\n\n    request, response = app.test_client.get(\"/test\")\n    assert response.status == 200\n\n    request, response = app.test_client.post(\"/test\")\n    assert response.status == 405",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.status == 405"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_add_route_method_not_allowed` test is to verify that the Sanic application correctly handles HTTP methods that are not allowed for a specific route. Specifically, it checks that a route defined to accept only GET requests returns a 405 Method Not Allowed status when a POST request is made.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a route is added with specific allowed methods (in this case, only GET), any attempt to access that route with a method that is not allowed (like POST) results in the appropriate HTTP response status code (405). It also confirms that the route works as expected for the allowed method (GET), returning a 200 status.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `app.add_route` method, which registers a route handler for the specified path (\"/test\") and HTTP methods ([\"GET\"]). The test then uses the `app.test_client` to simulate HTTP requests to this route. The first request is a GET request, which should return a 200 status, while the second request is a POST request, which should return a 405 status. The relevant methods being tested are `app.test_client.get` and `app.test_client.post`, which handle the respective HTTP requests.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the Arrange-Act-Assert (AAA) pattern, where:\n- **Arrange**: The route is set up with the handler and allowed methods.\n- **Act**: Two requests are made to the route (one GET and one POST).\n- **Assert**: The test checks the response status codes to ensure they match the expected outcomes (200 for GET and 405 for POST). This pattern helps in maintaining clarity and structure in the test, making it easier to understand the intent and flow of the test case."
    },
    {
      "name": "test_removing_slash",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 971,
      "end_line_number": 980,
      "source_code": "def test_removing_slash(app):\n    @app.get(\"/rest/<resource>\")\n    def get(_):\n        pass\n\n    @app.post(\"/rest/<resource>\")\n    def post(_):\n        pass\n\n    assert len(app.router.routes_all.keys()) == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(app.router.routes_all.keys()) == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_removing_slash` test is designed to verify the behavior of the Sanic web framework when defining routes with and without trailing slashes. Specifically, it checks that the application correctly registers routes and that the expected number of routes is present in the router.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a route is defined with a trailing slash (e.g., `/rest/<resource>`), it does not create multiple routes for the same endpoint. The assertion checks that only one route is registered in the application's router, confirming that the framework handles the trailing slash correctly.\n\n**Code Being Tested and How It Works**:  \nThe test defines two routes using the Sanic application instance: a GET route and a POST route for the path `/rest/<resource>`. The `app.router.routes_all.keys()` method is used to retrieve all registered routes, and the test asserts that the length of this collection is equal to 1, indicating that only one route has been registered for the specified path.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Route Definition**: The test utilizes decorators to define routes, which is a common pattern in web frameworks to associate HTTP methods with specific URL paths.\n- **Assertions**: The test employs a simple assertion to validate the expected state of the application after route definitions, ensuring that the framework behaves as intended.\n- **Minimal Setup**: The test is concise and focuses solely on the behavior of route registration, demonstrating a clear and isolated unit test approach."
    },
    {
      "name": "test_overload_routes",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 983,
      "end_line_number": 1009,
      "source_code": "def test_overload_routes(app):\n    @app.route(\"/overload\", methods=[\"GET\"])\n    async def handler1(request):\n        return text(\"OK1\")\n\n    @app.route(\"/overload\", methods=[\"POST\", \"PUT\"])\n    async def handler2(request):\n        return text(\"OK2\")\n\n    request, response = app.test_client.get(\"/overload\")\n    assert response.text == \"OK1\"\n\n    request, response = app.test_client.post(\"/overload\")\n    assert response.text == \"OK2\"\n\n    request, response = app.test_client.put(\"/overload\")\n    assert response.text == \"OK2\"\n\n    request, response = app.test_client.delete(\"/overload\")\n    assert response.status == 405\n\n    app.router.reset()\n    with pytest.raises(RouteExists):\n\n        @app.route(\"/overload\", methods=[\"PUT\", \"DELETE\"])\n        async def handler3(request):\n            return text(\"Duplicated\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK1'",
        "assert response.text == 'OK2'",
        "assert response.text == 'OK2'",
        "assert response.status == 405"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.test_client.delete",
          "body": "def delete(self, request):\n    return text('I am delete method')"
        },
        {
          "name": "app.router.reset",
          "body": "@pytest.fixture(autouse=True)\ndef reset():\n    try:\n        del os.environ['SANIC_MOTD_OUTPUT']\n    except KeyError:\n        ..."
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_overload_routes` function is designed to verify the behavior of route overloads in a Sanic web application. It checks that different HTTP methods (GET, POST, PUT) can be handled by the same route while ensuring that the correct responses are returned based on the method used.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically verifies that:\n1. A GET request to the `/overload` route returns \"OK1\".\n2. Both POST and PUT requests to the same route return \"OK2\".\n3. A DELETE request to the route returns a 405 Method Not Allowed status.\n4. Attempting to register a new route with conflicting methods raises a `RouteExists` exception.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the Sanic application\u2019s routing mechanism. The `@app.route` decorator is used to define handlers for different HTTP methods on the same endpoint (`/overload`). The `app.test_client` is utilized to simulate HTTP requests to the application, allowing the test to assert the expected responses. The `app.router.reset()` method is called to clear the routes before testing for route conflicts, ensuring a clean state.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test uses async functions to handle requests, which is essential for testing web applications that operate asynchronously.\n- **Assertions**: The test employs assertions to validate the responses from the application, ensuring that the expected output matches the actual output.\n- **Exception Handling**: The test checks for the correct handling of exceptions (specifically `RouteExists`) when trying to register conflicting routes, demonstrating robust error handling in the routing logic."
    },
    {
      "name": "test_unmergeable_overload_routes",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 1012,
      "end_line_number": 1049,
      "source_code": "def test_unmergeable_overload_routes(app):\n    @app.route(\"/overload_whole\", methods=None)\n    async def handler1(request):\n        return text(\"OK1\")\n\n    @app.route(\"/overload_whole\", methods=[\"POST\", \"PUT\"])\n    async def handler2(request):\n        return text(\"OK1\")\n\n    assert len(app.router.static_routes) == 1\n    assert len(app.router.static_routes[(\"overload_whole\",)].methods) == 3\n\n    request, response = app.test_client.get(\"/overload_whole\")\n    assert response.text == \"OK1\"\n\n    request, response = app.test_client.post(\"/overload_whole\")\n    assert response.text == \"OK1\"\n\n    request, response = app.test_client.put(\"/overload_whole\")\n    assert response.text == \"OK1\"\n\n    app.router.reset()\n\n    @app.route(\"/overload_part\", methods=[\"GET\"])\n    async def handler3(request):\n        return text(\"OK1\")\n\n    with pytest.raises(RouteExists):\n\n        @app.route(\"/overload_part\")\n        async def handler4(request):\n            return text(\"Duplicated\")\n\n    request, response = app.test_client.get(\"/overload_part\")\n    assert response.text == \"OK1\"\n\n    request, response = app.test_client.post(\"/overload_part\")\n    assert response.status == 405",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(app.router.static_routes) == 1",
        "assert len(app.router.static_routes['overload_whole',].methods) == 3",
        "assert response.text == 'OK1'",
        "assert response.text == 'OK1'",
        "assert response.text == 'OK1'",
        "assert response.text == 'OK1'",
        "assert response.status == 405"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.router.reset",
          "body": "@pytest.fixture(autouse=True)\ndef reset():\n    try:\n        del os.environ['SANIC_MOTD_OUTPUT']\n    except KeyError:\n        ..."
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_unmergeable_overload_routes` function is designed to verify the behavior of route handling in the Sanic web framework, specifically focusing on how the framework manages routes that have overlapping paths but different HTTP methods. It ensures that the application can correctly handle multiple routes with the same path but different methods and that it raises appropriate errors when attempting to define duplicate routes.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. A route can be defined with multiple HTTP methods (GET, POST, PUT) and that the correct handler is invoked based on the method used.\n2. The application correctly identifies and prevents the addition of duplicate routes with the same path and method.\n3. The application returns the expected responses for valid requests and the correct status code for unsupported methods.\n\n**Code Being Tested and How It Works**:  \nThe test defines two handlers for the same route (`/overload_whole`), one for GET requests and another for POST and PUT requests. It asserts that:\n- The number of static routes is as expected.\n- The correct response is returned for each method (GET, POST, PUT).\n- After resetting the router, it attempts to add a new route (`/overload_part`) and checks that adding a duplicate route raises a `RouteExists` exception.\n- It verifies that the correct response is returned for a GET request to `/overload_part` and that a POST request to the same route results in a 405 Method Not Allowed status.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertions**: The test uses assertions to validate the expected outcomes, such as checking the length of routes and the content of responses.\n- **Exception Handling**: It employs `pytest.raises` to assert that an exception is raised when attempting to add a duplicate route, demonstrating the use of context managers for exception testing.\n- **Route Resetting**: The test utilizes `app.router.reset()` to clear the routes between tests, ensuring that each test runs in isolation without interference from previous tests.\n- **Asynchronous Testing**: The test is structured to work with asynchronous handlers, which is a common pattern in modern web frameworks like Sanic."
    },
    {
      "name": "test_unicode_routes",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 1052,
      "end_line_number": 1067,
      "source_code": "def test_unicode_routes(app):\n    @app.get(\"/\u4f60\u597d\")\n    def handler1(request):\n        return text(\"OK1\")\n\n    request, response = app.test_client.get(\"/\u4f60\u597d\")\n    assert response.text == \"OK1\"\n\n    app.router.reset()\n\n    @app.route(\"/overload/<param>\", methods=[\"GET\"], unquote=True)\n    async def handler2(request, param):\n        return text(\"OK2 \" + param)\n\n    request, response = app.test_client.get(\"/overload/\u4f60\u597d\")\n    assert response.text == \"OK2 \u4f60\u597d\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK1'",
        "assert response.text == 'OK2 \u4f60\u597d'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.router.reset",
          "body": "@pytest.fixture(autouse=True)\ndef reset():\n    try:\n        del os.environ['SANIC_MOTD_OUTPUT']\n    except KeyError:\n        ..."
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_unicode_routes` function is designed to verify that the Sanic web framework correctly handles routes with Unicode characters in their paths. Specifically, it tests both a simple route and a parameterized route that includes Unicode characters.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. A GET request to the route `/\u4f60\u597d` returns the expected response \"OK1\".\n2. A GET request to the route `/overload/\u4f60\u597d` returns the expected response \"OK2 \u4f60\u597d\", demonstrating that the framework can correctly process and return responses for routes with dynamic parameters that include Unicode characters.\n\n**Code Being Tested and How It Works**:  \nThe test defines two routes:\n- The first route is a simple GET route mapped to `/\u4f60\u597d`, which returns a static text response \"OK1\".\n- The second route is a parameterized GET route mapped to `/overload/<param>`, where `<param>` can accept any string, including Unicode characters. This route concatenates \"OK2 \" with the parameter value and returns it.\n\nThe test uses the `app.test_client.get` method to simulate HTTP GET requests to these routes and checks the responses against the expected output using assertions.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Route Resetting**: The `app.router.reset()` method is called between the two route definitions to ensure that the routes do not interfere with each other, maintaining a clean state for each test.\n- **Assertions**: The test employs assertions to validate that the actual responses match the expected responses, which is a fundamental practice in unit testing to ensure correctness.\n- **Unicode Handling**: The test specifically focuses on Unicode handling, which is crucial for applications that may deal with internationalization or non-ASCII characters in URLs."
    },
    {
      "name": "test_uri_with_different_method_and_different_params",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 1070,
      "end_line_number": 1085,
      "source_code": "def test_uri_with_different_method_and_different_params(app):\n    @app.route(\"/ads/<ad_id>\", methods=[\"GET\"])\n    async def ad_get(request, ad_id):\n        return json({\"ad_id\": ad_id})\n\n    @app.route(\"/ads/<action>\", methods=[\"POST\"])\n    async def ad_post(request, action):\n        return json({\"action\": action})\n\n    request, response = app.test_client.get(\"/ads/1234\")\n    assert response.status == 200\n    assert response.json == {\"ad_id\": \"1234\"}\n\n    request, response = app.test_client.post(\"/ads/post\")\n    assert response.status == 200\n    assert response.json == {\"action\": \"post\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.json == {'ad_id': '1234'}",
        "assert response.status == 200",
        "assert response.json == {'action': 'post'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_uri_with_different_method_and_different_params` test is to verify that the Sanic application correctly handles different HTTP methods (GET and POST) for specific routes, and that it returns the expected JSON responses based on the parameters provided in the URL.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that:\n1. A GET request to the `/ads/<ad_id>` route returns a 200 status code and the correct JSON response containing the `ad_id`.\n2. A POST request to the `/ads/<action>` route also returns a 200 status code and the correct JSON response containing the `action`.\n\n**Code Being Tested and How It Works**:  \nThe code being tested includes two route handlers:\n- `ad_get`: Handles GET requests to `/ads/<ad_id>`, returning a JSON object with the `ad_id` extracted from the URL.\n- `ad_post`: Handles POST requests to `/ads/<action>`, returning a JSON object with the `action` extracted from the URL.\n\nThe test uses the `app.test_client` to simulate HTTP requests to these routes and checks the responses for correctness.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Route Testing**: The test defines routes within the test function, allowing for isolated testing of specific behaviors without affecting the global application state.\n- **Assertions**: The test uses assertions to validate the response status and JSON content, ensuring that the application behaves as expected.\n- **Asynchronous Testing**: The test is designed to work with asynchronous route handlers, which is a common pattern in modern web frameworks like Sanic."
    },
    {
      "name": "test_uri_with_different_method_and_same_params",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 1088,
      "end_line_number": 1103,
      "source_code": "def test_uri_with_different_method_and_same_params(app):\n    @app.route(\"/ads/<ad_id>\", methods=[\"GET\"])\n    async def ad_get(request, ad_id):\n        return json({\"ad_id\": ad_id})\n\n    @app.route(\"/ads/<ad_id>\", methods=[\"POST\"])\n    async def ad_post(request, ad_id):\n        return json({\"ad_id\": ad_id})\n\n    request, response = app.test_client.get(\"/ads/1234\")\n    assert response.status == 200\n    assert response.json == {\"ad_id\": \"1234\"}\n\n    request, response = app.test_client.post(\"/ads/post\")\n    assert response.status == 200\n    assert response.json == {\"ad_id\": \"post\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.json == {'ad_id': '1234'}",
        "assert response.status == 200",
        "assert response.json == {'ad_id': 'post'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_uri_with_different_method_and_same_params` aims to verify that the Sanic application correctly handles HTTP requests with the same URI but different HTTP methods (GET and POST) while ensuring that the parameters passed in the URI are processed correctly.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that:\n1. A GET request to the endpoint `/ads/<ad_id>` returns the correct JSON response with the `ad_id` extracted from the URL.\n2. A POST request to the same endpoint also returns the correct JSON response, confirming that the server can differentiate between the two methods and handle them appropriately.\n\n**Code Being Tested and How It Works**:  \nThe code under test consists of two route handlers:\n- `ad_get`: Handles GET requests to `/ads/<ad_id>` and returns a JSON object containing the `ad_id`.\n- `ad_post`: Handles POST requests to `/ads/<ad_id>` and similarly returns a JSON object with the `ad_id`.\n\nThe test simulates requests to these endpoints using `app.test_client.get` and `app.test_client.post`, asserting that the responses have a status code of 200 and that the returned JSON matches the expected output based on the input parameters.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses URL parameters (`<ad_id>`) to dynamically test different inputs, ensuring that the application can handle various values correctly.\n- **Assertions**: The test employs assertions to validate both the HTTP response status and the content of the JSON response, ensuring comprehensive verification of the endpoint's behavior.\n- **Asynchronous Testing**: The use of async route handlers and the test client indicates that the test is designed to work with asynchronous operations, which is a common pattern in modern web frameworks like Sanic."
    },
    {
      "name": "test_route_raise_ParameterNameConflicts",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 1106,
      "end_line_number": 1112,
      "source_code": "def test_route_raise_ParameterNameConflicts(app):\n    @app.get(\"/api/v1/<user>/<user>/\")\n    def handler(request, user):\n        return text(\"OK\")\n\n    with pytest.raises(ParameterNameConflicts):\n        app.router.finalize()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_route_raise_ParameterNameConflicts` is designed to verify that the Sanic application correctly raises a `ParameterNameConflicts` exception when there are conflicting parameter names in the route definition. Specifically, it checks that defining two route parameters with the same name (`<user>`) in the URL path results in an appropriate error during the finalization of the router.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the routing mechanism of the Sanic framework enforces unique parameter names within a single route. By attempting to finalize the router with a route that has duplicate parameter names, the test confirms that the expected exception (`ParameterNameConflicts`) is raised, indicating that the framework is correctly handling this edge case.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `app.get` method, which is used to define a route in the Sanic application. The route defined in the test is `\"/api/v1/<user>/<user>/\"`, where `<user>` is specified twice. When `app.router.finalize()` is called, the router attempts to finalize the route definitions. The expected behavior is that it detects the duplicate parameter names and raises a `ParameterNameConflicts` exception, which is what the test is asserting.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that a specific exception is raised during the execution of the code block. This is a common pattern in unit testing for verifying that error conditions are handled correctly. Additionally, the use of a fixture (`app`) to provide a fresh instance of the Sanic application for each test ensures isolation and prevents side effects from other tests, which is a best practice in unit testing."
    },
    {
      "name": "test_route_invalid_host",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 1115,
      "end_line_number": 1125,
      "source_code": "def test_route_invalid_host(app):\n    host = 321\n    with pytest.raises(ValueError) as excinfo:\n\n        @app.get(\"/test\", host=host)\n        def handler(request):\n            return text(\"pass\")\n\n    assert str(excinfo.value) == (\n        \"Expected either string or Iterable of \" \"host strings, not {!r}\"\n    ).format(host)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(excinfo.value) == 'Expected either string or Iterable of host strings, not {!r}'.format(host)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_route_invalid_host` test is designed to verify that the Sanic framework correctly raises a `ValueError` when an invalid host type (in this case, an integer) is provided to the route decorator.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the application raises a `ValueError` with an appropriate error message when the `host` parameter of the `@app.get` decorator is not a string or an iterable of strings. It ensures that the framework enforces type constraints on the `host` parameter.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `app.get` method, which is a decorator used to define a route in the Sanic application. When the decorator is applied with an invalid `host` argument, the expected behavior is that it raises a `ValueError`. The test captures this exception using `pytest.raises` and checks the message to confirm it matches the expected format, indicating that the error handling is functioning correctly.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that an exception is raised during the execution of the code block. This is a common pattern in unit testing for verifying that specific error conditions are handled as expected. Additionally, the use of formatted strings in the assertion allows for clear and precise validation of the error message, ensuring that the test not only checks for the occurrence of an error but also verifies its correctness."
    },
    {
      "name": "test_route_with_regex_group",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 1128,
      "end_line_number": 1134,
      "source_code": "def test_route_with_regex_group(app):\n    @app.route(r\"/path/to/<ext:file\\.(txt)>\")\n    async def handler(request, ext):\n        return text(ext)\n\n    _, response = app.test_client.get(\"/path/to/file.txt\")\n    assert response.text == \"txt\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'txt'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_route_with_regex_group` is designed to verify that the Sanic web framework correctly handles route definitions that utilize regular expression groups to capture parts of the URL. Specifically, it checks if the framework can extract the file extension from a URL that matches a defined pattern.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a request is made to a specific route (in this case, `/path/to/file.txt`), the handler correctly captures the file extension (`txt`) using a regex group defined in the route. The expected behavior is that the response text should match the captured extension.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a route defined with a regex pattern: `r\"/path/to/<ext:file\\.(txt)>\"`. The `handler` function is set to return the captured extension when the route is accessed. The test simulates a GET request to the route using `app.test_client.get(\"/path/to/file.txt\")`, and it asserts that the response text equals `\"txt\"`, confirming that the regex group worked as intended.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the following patterns:\n- **Asynchronous Testing**: The handler is defined as an asynchronous function, which is common in modern web frameworks to handle I/O-bound operations efficiently.\n- **Route Testing**: It uses the `test_client` to simulate HTTP requests, allowing for integration-style testing of route handlers.\n- **Assertion**: The test uses a simple assertion to verify the correctness of the response, which is a fundamental practice in unit testing to ensure expected outcomes."
    },
    {
      "name": "test_route_with_regex_named_group",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 1137,
      "end_line_number": 1143,
      "source_code": "def test_route_with_regex_named_group(app):\n    @app.route(r\"/path/to/<ext:file\\.(?P<ext>txt)>\")\n    async def handler(request, ext):\n        return text(ext)\n\n    _, response = app.test_client.get(\"/path/to/file.txt\")\n    assert response.text == \"txt\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'txt'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_route_with_regex_named_group` is designed to verify that the Sanic web framework correctly handles routes defined with regex patterns that include named groups. Specifically, it checks if the route can successfully extract a named parameter from the URL and return it in the response.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a request is made to a specific URL (`/path/to/file.txt`), the framework correctly identifies the file extension (`txt`) from the URL using the regex pattern defined in the route. The expected behavior is that the response text matches the extracted file extension.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a route defined with a regex pattern: `r\"/path/to/<ext:file\\.(?P<ext>txt)>\"`. The `handler` function is an asynchronous function that takes the request and the extracted `ext` parameter, returning the value of `ext` as the response text. The test simulates a GET request to the URL `/path/to/file.txt` using `app.test_client.get`, and it asserts that the response text is equal to `\"txt\"`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of a regex-based route definition, which is a common pattern in web frameworks for dynamic URL handling. It also utilizes the `assert` statement to validate the response, which is a straightforward and effective way to check expected outcomes in unit tests. Additionally, the test is structured to be asynchronous, reflecting the nature of the Sanic framework, which is designed for handling asynchronous requests."
    },
    {
      "name": "test_route_with_regex_named_group_invalid",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 1146,
      "end_line_number": 1156,
      "source_code": "def test_route_with_regex_named_group_invalid(app):\n    @app.route(r\"/path/to/<ext:file\\.(?P<wrong>txt)>\")\n    async def handler(request, ext):\n        return text(ext)\n\n    with pytest.raises(InvalidUsage) as e:\n        app.router.finalize()\n\n    assert e.match(\n        re.escape(\"Named group (wrong) must match your named parameter (ext)\")\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert e.match(re.escape('Named group (wrong) must match your named parameter (ext)'))"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_route_with_regex_named_group_invalid` is designed to verify that the Sanic framework correctly raises an `InvalidUsage` exception when a route is defined with a regex named group that does not match the corresponding named parameter in the route path.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a route is defined with a regex pattern that includes a named group (`(?P<wrong>txt)`) that does not correspond to the named parameter (`<ext:file\\.(?P<wrong>txt)>`), the application raises an appropriate error indicating the mismatch. The expected error message is validated to ensure it accurately describes the issue.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves defining a route in a Sanic application using a regex pattern that includes a named group. The route is defined as `@app.route(r\"/path/to/<ext:file\\.(?P<wrong>txt)>\")`, where `wrong` is the named group that does not match the parameter `ext`. When `app.router.finalize()` is called, the router attempts to compile the route, which triggers the validation logic that checks for consistency between named groups and parameters. If a mismatch is detected, an `InvalidUsage` exception is raised.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that an exception is raised during the execution of `app.router.finalize()`. This is a common pattern in unit testing to verify that specific error conditions are handled correctly. Additionally, the use of `re.escape` in the assertion ensures that the error message is matched literally, which is a good practice to avoid issues with special characters in the message string."
    },
    {
      "name": "test_route_with_regex_group_ambiguous",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 1159,
      "end_line_number": 1172,
      "source_code": "def test_route_with_regex_group_ambiguous(app):\n    @app.route(r\"/path/to/<ext:file(?:\\.)(txt)>\")\n    async def handler(request, ext):\n        return text(ext)\n\n    with pytest.raises(InvalidUsage) as e:\n        app.router.finalize()\n\n    assert e.match(\n        re.escape(\n            r\"Could not compile pattern file(?:\\.)(txt). Try using a named \"\n            \"group instead: '(?P<ext>your_matching_group)'\"\n        )\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert e.match(re.escape(\"Could not compile pattern file(?:\\\\.)(txt). Try using a named group instead: '(?P<ext>your_matching_group)'\"))"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_route_with_regex_group_ambiguous` aims to verify that the Sanic framework correctly raises an `InvalidUsage` exception when a route is defined with an ambiguous regex pattern that cannot be compiled. This ensures that the routing system enforces proper regex syntax and provides meaningful error messages to developers.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that when a route is defined with a regex group that is ambiguous (in this case, `file(?:\\.)(txt)`), the application raises an `InvalidUsage` exception during the finalization of the router. It also verifies that the exception message suggests using a named group instead, which is a best practice for clarity and maintainability.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the route definition using a regex pattern in the Sanic application. The route is defined as `@app.route(r\"/path/to/<ext:file(?:\\.)(txt)>\")`, which attempts to match a file extension but uses an ambiguous regex group. When `app.router.finalize()` is called, the router attempts to compile the regex pattern. Since the pattern is ambiguous, it raises an `InvalidUsage` exception, which is then caught in the test.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that an exception is raised during the execution of `app.router.finalize()`. This is a common pattern in unit testing to verify that specific error conditions are handled correctly. Additionally, the use of `assert e.match(...)` with a regex-escaped string checks that the exception message matches the expected output, ensuring that the error handling provides clear guidance to the developer."
    },
    {
      "name": "test_route_with_bad_named_param",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 1175,
      "end_line_number": 1181,
      "source_code": "def test_route_with_bad_named_param(app):\n    @app.route(\"/foo/<__bar__>\")\n    async def handler(request):\n        return text(\"...\")\n\n    with pytest.raises(SanicException):\n        app.router.finalize()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_route_with_bad_named_param` test is designed to verify that the Sanic framework correctly raises a `SanicException` when a route is defined with an invalid named parameter format. Specifically, it checks that the router does not accept parameters that are not compliant with the expected naming conventions.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the Sanic router enforces naming rules for route parameters. In this case, the test checks that using double underscores (`__bar__`) in the parameter name is invalid and triggers an appropriate exception when the router is finalized.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves defining a route with a parameter named `__bar__` using the `@app.route` decorator. The `app.router.finalize()` method is called to finalize the routing configuration. If the parameter name is invalid, the method should raise a `SanicException`, which is what the test expects to happen.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the context manager `pytest.raises` to assert that a specific exception (`SanicException`) is raised during the execution of `app.router.finalize()`. This pattern is a common technique in unit testing to verify that error conditions are handled correctly. Additionally, the test is structured to be asynchronous, aligning with the asynchronous nature of the Sanic framework, although the specific handler does not perform any asynchronous operations in this case."
    },
    {
      "name": "test_routes_with_and_without_slash_definitions",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 1184,
      "end_line_number": 1237,
      "source_code": "def test_routes_with_and_without_slash_definitions(app):\n    bar = Blueprint(\"bar\", url_prefix=\"bar\")\n    baz = Blueprint(\"baz\", url_prefix=\"/baz\")\n    fizz = Blueprint(\"fizz\", url_prefix=\"fizz/\")\n    buzz = Blueprint(\"buzz\", url_prefix=\"/buzz/\")\n\n    instances = (\n        (app, \"foo\"),\n        (bar, \"bar\"),\n        (baz, \"baz\"),\n        (fizz, \"fizz\"),\n        (buzz, \"buzz\"),\n    )\n\n    for instance, term in instances:\n        route = f\"/{term}\" if isinstance(instance, Sanic) else \"\"\n\n        @instance.get(route, strict_slashes=True)\n        def get_without(request):\n            return text(f\"{term}_without\")\n\n        @instance.get(f\"{route}/\", strict_slashes=True)\n        def get_with(request):\n            return text(f\"{term}_with\")\n\n        @instance.post(route, strict_slashes=True)\n        def post_without(request):\n            return text(f\"{term}_without\")\n\n        @instance.post(f\"{route}/\", strict_slashes=True)\n        def post_with(request):\n            return text(f\"{term}_with\")\n\n    app.blueprint(bar)\n    app.blueprint(baz)\n    app.blueprint(fizz)\n    app.blueprint(buzz)\n\n    for _, term in instances:\n        _, response = app.test_client.get(f\"/{term}\")\n        assert response.status == 200\n        assert response.text == f\"{term}_without\"\n\n        _, response = app.test_client.get(f\"/{term}/\")\n        assert response.status == 200\n        assert response.text == f\"{term}_with\"\n\n        _, response = app.test_client.post(f\"/{term}\")\n        assert response.status == 200\n        assert response.text == f\"{term}_without\"\n\n        _, response = app.test_client.post(f\"/{term}/\")\n        assert response.status == 200\n        assert response.text == f\"{term}_with\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == f'{term}_without'",
        "assert response.status == 200",
        "assert response.text == f'{term}_with'",
        "assert response.status == 200",
        "assert response.text == f'{term}_without'",
        "assert response.status == 200",
        "assert response.text == f'{term}_with'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "instance.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "instance.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "instance.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "instance.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_routes_with_and_without_slash_definitions` test is to verify the behavior of route definitions in a Sanic application, specifically how routes respond to requests with and without trailing slashes. It ensures that the application correctly handles both types of requests and returns the expected responses.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that for each defined route, both the GET and POST methods return the correct responses when accessed with and without a trailing slash. It asserts that the responses are consistent with the expected output, confirming that the `strict_slashes` behavior is functioning as intended.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves creating multiple route handlers using the Sanic framework. Each route is defined with and without a trailing slash, and the test client is used to send requests to these routes. The routes are set up using the `Blueprint` feature of Sanic, allowing for modular route definitions. The test then sends GET and POST requests to each route and checks the response status and body to ensure they match the expected values (e.g., `\"{term}_without\"` for routes without a slash and `\"{term}_with\"` for routes with a slash).\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterized Testing**: The test uses a tuple of instances to iterate over different route definitions, reducing code duplication and improving maintainability.\n- **Assertions**: The test employs assertions to validate the response status and content, ensuring that the application behaves as expected under different conditions.\n- **Blueprints**: The use of Blueprints allows for organized route management, making it easier to test multiple routes in a structured manner.\n- **Strict Slashes Behavior**: The test specifically checks the `strict_slashes` parameter, which is a key feature in web frameworks that affects how routes are matched based on trailing slashes."
    },
    {
      "name": "test_added_route_ctx_kwargs",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 1240,
      "end_line_number": 1248,
      "source_code": "def test_added_route_ctx_kwargs(app):\n    @app.route(\"/\", ctx_foo=\"foo\", ctx_bar=99)\n    async def handler(request: Request):\n        return empty()\n\n    request, _ = app.test_client.get(\"/\")\n\n    assert request.route.ctx.foo == \"foo\"\n    assert request.route.ctx.bar == 99",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.route.ctx.foo == 'foo'",
        "assert request.route.ctx.bar == 99"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_added_route_ctx_kwargs` test verifies that custom context variables (`ctx_foo` and `ctx_bar`) can be successfully added to a route in a Sanic application and that they can be accessed correctly within the request context.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a route is defined with specific context keyword arguments, those arguments are correctly stored in the request's route context and can be retrieved as expected.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route at the root path (`\"/\"`) of the Sanic application with two context variables: `ctx_foo` set to `\"foo\"` and `ctx_bar` set to `99`. It then simulates a GET request to this route using `app.test_client.get(\"/\")`. After the request is made, the test asserts that the values of `ctx.foo` and `ctx.bar` in the request's route context match the expected values.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test leverages asynchronous route handling, which is a common pattern in modern web frameworks like Sanic.\n- **Contextual Assertions**: It checks the state of the request's context after a route is hit, ensuring that the context is correctly populated with the expected values.\n- **Route Definition with Context**: The test demonstrates the ability to define routes with additional context parameters, showcasing the flexibility of the Sanic framework in handling request contexts."
    },
    {
      "name": "test_added_bad_route_kwargs",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 1251,
      "end_line_number": 1256,
      "source_code": "def test_added_bad_route_kwargs(app):\n    message = \"Unexpected keyword arguments: foo, bar\"\n    with pytest.raises(TypeError, match=message):\n\n        @app.route(\"/\", foo=\"foo\", bar=99)\n        async def handler(request: Request): ...",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_added_bad_route_kwargs` test is to verify that the Sanic application correctly raises a `TypeError` when unexpected keyword arguments are passed to the route decorator.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when the `@app.route` decorator is used with keyword arguments that are not recognized (in this case, `foo` and `bar`), the application raises a `TypeError` with a specific error message indicating the unexpected arguments.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the route registration mechanism of the Sanic framework. When the `@app.route` decorator is invoked with invalid keyword arguments, the underlying implementation should validate these arguments and raise an appropriate error. The test uses a context manager (`with pytest.raises(...)`) to assert that the expected exception is raised during the execution of the route definition.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of the `pytest.raises` context manager to assert that a specific exception is raised, which is a common pattern in unit testing for error handling. Additionally, it uses the `match` parameter to ensure that the error message contains the expected text, providing a more precise verification of the error condition. This approach helps ensure that not only is an error raised, but that it is the correct error with the expected message."
    },
    {
      "name": "test_methods",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_views.py",
      "line_number": 11,
      "end_line_number": 37,
      "source_code": "def test_methods(app, method):\n    class DummyView(HTTPMethodView):\n        async def get(self, request):\n            return text(\"\", headers={\"method\": \"GET\"})\n\n        def post(self, request):\n            return text(\"\", headers={\"method\": \"POST\"})\n\n        async def put(self, request):\n            return text(\"\", headers={\"method\": \"PUT\"})\n\n        def head(self, request):\n            return text(\"\", headers={\"method\": \"HEAD\"})\n\n        def options(self, request):\n            return text(\"\", headers={\"method\": \"OPTIONS\"})\n\n        async def patch(self, request):\n            return text(\"\", headers={\"method\": \"PATCH\"})\n\n        def delete(self, request):\n            return text(\"\", headers={\"method\": \"DELETE\"})\n\n    app.add_route(DummyView.as_view(), \"/\")\n\n    request, response = getattr(app.test_client, method.lower())(\"/\")\n    assert response.headers[\"method\"] == method",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('method', HTTP_METHODS)"
      ],
      "arguments": [
        "app",
        "method"
      ],
      "imports": [
        "pytest",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.headers['method'] == method"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_methods` function is designed to verify that the Sanic application correctly handles various HTTP methods (GET, POST, PUT, HEAD, OPTIONS, PATCH, DELETE) and returns the appropriate method in the response headers.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a request is made using a specific HTTP method, the response headers contain the correct \"method\" value that matches the method used in the request. This ensures that the application is correctly identifying and responding to different HTTP methods.\n\n**Code Being Tested and How It Works**:  \nThe test defines a `DummyView` class that inherits from `HTTPMethodView`, implementing methods for each HTTP verb. Each method returns a response with a header indicating the method used. The test then adds this view to the Sanic app and simulates requests using the specified HTTP method. The assertion checks that the response header \"method\" matches the expected method.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterized Testing**: The test is likely part of a parameterized test suite, where `method` is passed as an argument, allowing the same test logic to be executed for multiple HTTP methods.\n- **Asynchronous Testing**: The use of `async` in the view methods indicates that the test is designed to work with asynchronous code, which is a common pattern in modern web frameworks like Sanic.\n- **HTTP Method Verification**: The test specifically verifies the behavior of the application in response to different HTTP methods, ensuring that the application adheres to RESTful principles."
    },
    {
      "name": "test_unexisting_methods",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_views.py",
      "line_number": 40,
      "end_line_number": 49,
      "source_code": "def test_unexisting_methods(app):\n    class DummyView(HTTPMethodView):\n        def get(self, request):\n            return text(\"I am get method\")\n\n    app.add_route(DummyView.as_view(), \"/\")\n    request, response = app.test_client.get(\"/\")\n    assert response.body == b\"I am get method\"\n    request, response = app.test_client.post(\"/\")\n    assert b\"Method POST not allowed for URL /\" in response.body",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.body == b'I am get method'",
        "assert b'Method POST not allowed for URL /' in response.body"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_unexisting_methods` test is to verify the behavior of the Sanic application when an HTTP request is made to a route that does not support the requested HTTP method. Specifically, it checks that a GET request is handled correctly and that a POST request results in a \"Method Not Allowed\" response.\n\n**Specific Functionality or Behavior Verified**:  \nThe test confirms two key behaviors:\n1. A GET request to the root URL (\"/\") returns the expected response body, indicating that the GET method is correctly implemented.\n2. A POST request to the same URL returns a 405 status code with a message indicating that the POST method is not allowed, demonstrating proper handling of unsupported methods.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `DummyView` class, which inherits from `HTTPMethodView`. This class implements a `get` method that returns a text response when a GET request is made. The test adds this view to the Sanic application at the root URL (\"/\"). When the test client sends a GET request, it expects to receive the response \"I am get method\". For the POST request, since the `DummyView` does not implement a `post` method, the application raises a `MethodNotAllowed` exception, which results in a response indicating that the POST method is not allowed for the specified URL.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Setup and Teardown**: The test uses the `app` fixture to set up the Sanic application context, ensuring that the test runs in an isolated environment.\n- **Assertion**: It uses assertions to validate the response body and status code, which is a common practice in unit testing to ensure that the actual output matches the expected output.\n- **HTTP Method Testing**: The test specifically checks the behavior of different HTTP methods (GET and POST) against the same route, which is a crucial aspect of testing web applications to ensure they handle requests appropriately based on the method used."
    },
    {
      "name": "test_argument_methods",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_views.py",
      "line_number": 52,
      "end_line_number": 61,
      "source_code": "def test_argument_methods(app):\n    class DummyView(HTTPMethodView):\n        def get(self, request, my_param_here):\n            return text(\"I am get method with %s\" % my_param_here)\n\n    app.add_route(DummyView.as_view(), \"/<my_param_here>\")\n\n    request, response = app.test_client.get(\"/test123\")\n\n    assert response.text == \"I am get method with test123\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'I am get method with test123'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_argument_methods` function is designed to verify that the Sanic web framework correctly handles route parameters in HTTP GET requests. Specifically, it checks that the parameter passed in the URL is correctly received and processed by the view method.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a GET request is made to a specific route with a dynamic parameter (in this case, `my_param_here`), the response returned by the server includes the expected text that incorporates the value of that parameter. It confirms that the routing and parameter handling mechanisms of the Sanic application are functioning as intended.\n\n**Code Being Tested and How It Works**:  \nThe test defines a `DummyView` class that inherits from `HTTPMethodView`. This class implements a `get` method that takes a request and a parameter (`my_param_here`). The route is added to the app using `app.add_route`, mapping the URL pattern `\"/<my_param_here>\"` to the `DummyView`. When a GET request is made to `\"/test123\"`, the `get` method is invoked, and it returns a text response formatted with the parameter value. The test then asserts that the response text matches the expected output: `\"I am get method with test123\"`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterized Routing**: The test utilizes dynamic URL parameters, showcasing how Sanic can handle variable parts in routes.\n- **Assertion**: The test employs a simple assertion to verify that the response text matches the expected output, which is a common practice in unit testing to validate functionality.\n- **HTTP Method Testing**: By using the `HTTPMethodView`, the test demonstrates how to structure views that can handle multiple HTTP methods, although only the GET method is tested here."
    },
    {
      "name": "test_with_bp",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_views.py",
      "line_number": 64,
      "end_line_number": 76,
      "source_code": "def test_with_bp(app):\n    bp = Blueprint(\"test_text\")\n\n    class DummyView(HTTPMethodView):\n        def get(self, request):\n            return text(\"I am get method\")\n\n    bp.add_route(DummyView.as_view(), \"/\")\n\n    app.blueprint(bp)\n    request, response = app.test_client.get(\"/\")\n\n    assert response.text == \"I am get method\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'I am get method'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_with_bp` function is to verify that a Sanic application can successfully register and respond to routes defined within a Blueprint. It ensures that the application correctly handles HTTP GET requests routed through the Blueprint.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a GET request is made to the root path (\"/\") of the registered Blueprint, the response text matches the expected output (\"I am get method\"). This confirms that the route is correctly set up and that the view function is executed as intended.\n\n**Code Being Tested and How It Works**:  \nThe code being tested includes the `app.test_client.get` method, which simulates an HTTP GET request to the application. The `DummyView` class, which inherits from `HTTPMethodView`, defines a `get` method that returns a text response. The Blueprint (`bp`) is created and the `DummyView` is added to it with the route \"/\". The Blueprint is then registered with the application (`app.blueprint(bp)`), allowing the application to handle requests directed to the Blueprint's routes.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of a Blueprint to modularize the route handling, which is a common pattern in web frameworks to organize code. It also utilizes the `app.test_client` to simulate requests, allowing for isolated testing of the application's routing and response behavior. The use of assertions to compare the actual response with the expected output is a standard practice in unit testing to validate functionality."
    },
    {
      "name": "test_with_attach",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_views.py",
      "line_number": 79,
      "end_line_number": 88,
      "source_code": "def test_with_attach(app):\n    class DummyView(HTTPMethodView):\n        def get(self, request):\n            return text(\"I am get method\")\n\n    DummyView.attach(app, \"/\")\n\n    request, response = app.test_client.get(\"/\")\n\n    assert response.text == \"I am get method\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'I am get method'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_with_attach` function is designed to verify that a view can be successfully attached to a Sanic application and that it responds correctly to HTTP GET requests.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a GET request is made to the root URL (\"/\"), the application returns the expected response text \"I am get method\". This ensures that the view is properly registered and functioning as intended.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `DummyView` class, which inherits from `HTTPMethodView`. The `get` method of this class returns a text response when invoked. The line `DummyView.attach(app, \"/\")` attaches this view to the Sanic application at the root URL. The test then uses `app.test_client.get(\"/\")` to simulate a GET request to this URL, capturing the request and response. Finally, it asserts that the response text matches the expected output.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of a test client provided by the Sanic framework to simulate HTTP requests, which is a common pattern in web application testing. It also utilizes assertions to validate the response, ensuring that the application behaves as expected. The use of a class-based view (`HTTPMethodView`) demonstrates a structured approach to defining endpoints in the application."
    },
    {
      "name": "test_with_sub_init",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_views.py",
      "line_number": 91,
      "end_line_number": 98,
      "source_code": "def test_with_sub_init(app):\n    class DummyView(HTTPMethodView, attach=app, uri=\"/\"):\n        def get(self, request):\n            return text(\"I am get method\")\n\n    request, response = app.test_client.get(\"/\")\n\n    assert response.text == \"I am get method\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'I am get method'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_with_sub_init` test case is designed to verify that a Sanic application can correctly handle HTTP GET requests routed to a view that is initialized with specific parameters, including attaching the view to the application and defining its URI.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a GET request is made to the root URI (\"/\"), the response returned by the `DummyView` is as expected, specifically that it returns the text \"I am get method\". This ensures that the view is properly set up and responds correctly to incoming requests.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `DummyView` class, which inherits from `HTTPMethodView`. The view's `get` method is defined to return a text response. The view is attached to the Sanic application (`app`) with the URI set to \"/\". The test simulates a GET request to this URI using `app.test_client.get(\"/\")`, capturing the request and response. The assertion checks that the response text matches the expected output.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Class-based Views**: The test utilizes a class-based view (`DummyView`) to encapsulate the HTTP method handling, which is a common pattern in web frameworks for organizing code.\n- **Test Client**: The use of `app.test_client.get()` allows for simulating HTTP requests to the application, enabling the test to verify the behavior of the application as it would operate in a real-world scenario.\n- **Assertion**: The test employs a straightforward assertion to validate the response, ensuring that the expected output matches the actual output, which is a fundamental aspect of unit testing."
    },
    {
      "name": "test_with_attach_and_bp",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_views.py",
      "line_number": 101,
      "end_line_number": 113,
      "source_code": "def test_with_attach_and_bp(app):\n    bp = Blueprint(\"test_text\")\n\n    class DummyView(HTTPMethodView):\n        def get(self, request):\n            return text(\"I am get method\")\n\n    DummyView.attach(bp, \"/\")\n\n    app.blueprint(bp)\n    request, response = app.test_client.get(\"/\")\n\n    assert response.text == \"I am get method\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'I am get method'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_with_attach_and_bp` test is to verify that a Sanic application can successfully register a blueprint containing a view, and that the view responds correctly to HTTP GET requests.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a GET request is made to the root URL (\"/\"), the response text matches the expected output \"I am get method\". This ensures that the view is correctly attached to the blueprint and that the routing is functioning as intended.\n\n**Code Being Tested and How It Works**:  \nThe code being tested involves the `DummyView` class, which inherits from `HTTPMethodView`. The `get` method of this class returns a text response when invoked. The test creates a blueprint (`bp`), attaches the `DummyView` to it at the root path (\"/\"), and then registers the blueprint with the Sanic application instance (`app`). The test client then simulates a GET request to the root URL, and the response is checked to ensure it matches the expected output.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of blueprints, which are a way to organize routes and views in a Sanic application. It also utilizes the test client provided by Sanic to simulate HTTP requests and capture responses, allowing for straightforward verification of the application's behavior. The use of assertions to compare the actual response with the expected output is a common pattern in unit testing, ensuring that the functionality behaves as intended."
    },
    {
      "name": "test_with_sub_init_and_bp",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_views.py",
      "line_number": 116,
      "end_line_number": 126,
      "source_code": "def test_with_sub_init_and_bp(app):\n    bp = Blueprint(\"test_text\")\n\n    class DummyView(HTTPMethodView, attach=bp, uri=\"/\"):\n        def get(self, request):\n            return text(\"I am get method\")\n\n    app.blueprint(bp)\n    request, response = app.test_client.get(\"/\")\n\n    assert response.text == \"I am get method\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'I am get method'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_with_sub_init_and_bp` aims to verify that a Sanic application can correctly handle requests routed through a blueprint that utilizes a subclass of `HTTPMethodView`. It ensures that the application responds appropriately to a GET request at the specified route.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a GET request is made to the root URL (\"/\"), the application returns the expected response text \"I am get method\". This confirms that the routing and view handling are functioning as intended when using a blueprint with a method view.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `app.test_client.get` method, which simulates a GET request to the application. The `DummyView` class, which inherits from `HTTPMethodView`, defines a `get` method that returns a text response. The blueprint `bp` is created and the `DummyView` is attached to it, allowing the application to route requests to the view. The test then checks the response from the application to ensure it matches the expected output.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of blueprints, which are a way to organize routes and views in a Sanic application. It also utilizes the `HTTPMethodView` class, which allows for defining methods corresponding to HTTP verbs (like GET). The test uses assertions to validate the response, a common practice in unit testing to ensure that the actual output matches the expected output. Additionally, the test structure follows a clear pattern of setup (creating the blueprint and view), execution (making the GET request), and verification (asserting the response)."
    },
    {
      "name": "test_with_bp_with_url_prefix",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_views.py",
      "line_number": 129,
      "end_line_number": 141,
      "source_code": "def test_with_bp_with_url_prefix(app):\n    bp = Blueprint(\"test_text\", url_prefix=\"/test1\")\n\n    class DummyView(HTTPMethodView):\n        def get(self, request):\n            return text(\"I am get method\")\n\n    bp.add_route(DummyView.as_view(), \"/\")\n\n    app.blueprint(bp)\n    request, response = app.test_client.get(\"/test1/\")\n\n    assert response.text == \"I am get method\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'I am get method'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_with_bp_with_url_prefix` is designed to verify that a Sanic application can correctly handle requests routed through a Blueprint with a specified URL prefix. It ensures that the application responds appropriately when accessing a route defined within the Blueprint.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that a GET request to the URL `/test1/` returns the expected response text \"I am get method\". It confirms that the URL prefix is correctly applied and that the route defined in the Blueprint is accessible.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the creation of a Blueprint (`bp`) with a URL prefix of `/test1`. A `DummyView` class is defined, which inherits from `HTTPMethodView` and implements a `get` method that returns a text response. The route is added to the Blueprint, and the Blueprint is registered with the application. The test then simulates a GET request to the prefixed URL, checking that the response matches the expected output.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of Blueprints to modularize route definitions, which is a common pattern in web frameworks to organize code. It also utilizes the Sanic test client to simulate HTTP requests, allowing for straightforward verification of response behavior. The assertion at the end of the test checks the response content, ensuring that the application behaves as intended when the route is accessed."
    },
    {
      "name": "test_with_middleware",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_views.py",
      "line_number": 144,
      "end_line_number": 160,
      "source_code": "def test_with_middleware(app):\n    class DummyView(HTTPMethodView):\n        def get(self, request):\n            return text(\"I am get method\")\n\n    app.add_route(DummyView.as_view(), \"/\")\n\n    results = []\n\n    @app.middleware\n    async def handler(request):\n        results.append(request)\n\n    request, response = app.test_client.get(\"/\")\n\n    assert response.text == \"I am get method\"\n    assert type(results[0]) is Request",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'I am get method'",
        "assert type(results[0]) is Request"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_with_middleware` function is designed to verify the integration of middleware in a Sanic web application. Specifically, it checks that the middleware correctly processes incoming requests and that the expected response is returned from the route handler.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a GET request is made to the root endpoint (\"/\"), the middleware captures the request and that the response from the `DummyView` class's `get` method is as expected. It also verifies that the request object appended to the `results` list is of the correct type (`Request`).\n\n**Code Being Tested and How It Works**:  \nThe test defines a `DummyView` class that inherits from `HTTPMethodView`, implementing a `get` method that returns a simple text response. The middleware function `handler` is registered to the app, which appends the incoming request to the `results` list. The test then simulates a GET request to the root endpoint using `app.test_client.get(\"/\")`, capturing the request and response. Finally, it asserts that the response text matches the expected output and that the type of the first element in `results` is `Request`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Middleware Testing**: The test effectively demonstrates how to test middleware by checking its interaction with requests and responses.\n- **Assertions**: It uses assertions to validate both the response content and the type of the captured request, ensuring that the middleware behaves as intended.\n- **Anonymous Inner Classes**: The use of an inner class (`DummyView`) allows for encapsulation of the view logic within the test, keeping the test self-contained and focused."
    },
    {
      "name": "test_with_middleware_response",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_views.py",
      "line_number": 163,
      "end_line_number": 186,
      "source_code": "def test_with_middleware_response(app):\n    results = []\n\n    @app.middleware(\"request\")\n    async def process_request(request):\n        results.append(request)\n\n    @app.middleware(\"response\")\n    async def process_response(request, response):\n        results.append(request)\n        results.append(response)\n\n    class DummyView(HTTPMethodView):\n        def get(self, request):\n            return text(\"I am get method\")\n\n    app.add_route(DummyView.as_view(), \"/\")\n\n    request, response = app.test_client.get(\"/\")\n\n    assert response.text == \"I am get method\"\n    assert type(results[0]) is Request\n    assert type(results[1]) is Request\n    assert isinstance(results[2], HTTPResponse)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'I am get method'",
        "assert type(results[0]) is Request",
        "assert type(results[1]) is Request",
        "assert isinstance(results[2], HTTPResponse)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_with_middleware_response` test is designed to verify the correct functioning of middleware in a Sanic web application, specifically ensuring that both request and response middleware are executed properly and that they can access and manipulate the request and response objects.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the middleware correctly appends the request and response objects to a results list. It also verifies that the response from the `DummyView` is as expected and that the types of the objects in the results list are correct, confirming that the middleware is processing the request and response as intended.\n\n**Code Being Tested and How It Works**:  \nThe test sets up two middleware functions: one for processing requests and another for processing responses. The `DummyView` class defines a simple GET endpoint that returns a text response. The test then simulates a GET request to this endpoint using `app.test_client.get(\"/\")`. After the request is processed, the test asserts that the response text matches the expected output and checks the types of the objects stored in the `results` list to ensure they are instances of `Request` and `HTTPResponse`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Middleware Testing**: The test effectively demonstrates how to test middleware by checking the order of execution and the data passed through it.\n- **Asynchronous Testing**: The use of `async` functions allows for testing asynchronous behavior, which is crucial in web frameworks like Sanic.\n- **Assertions on Types**: The test employs type assertions to ensure that the middleware is interacting with the correct types of objects, which helps catch potential issues with data handling in the middleware."
    },
    {
      "name": "test_with_custom_class_methods",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_views.py",
      "line_number": 189,
      "end_line_number": 204,
      "source_code": "def test_with_custom_class_methods(app):\n    class DummyView(HTTPMethodView):\n        global_var = 0\n\n        def _iternal_method(self):\n            self.global_var += 10\n\n        def get(self, request):\n            self._iternal_method()\n            return text(\n                f\"I am get method and global var \" f\"is {self.global_var}\"\n            )\n\n    app.add_route(DummyView.as_view(), \"/\")\n    request, response = app.test_client.get(\"/\")\n    assert response.text == \"I am get method and global var is 10\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'I am get method and global var is 10'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "self._iternal_method",
          "body": "def _iternal_method(self):\n    self.global_var += 10"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_with_custom_class_methods` test is to verify that a custom HTTP method view in a Sanic application correctly updates and returns a class-level variable when a GET request is made.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `global_var` attribute of the `DummyView` class is incremented by 10 when the `get` method is called, and that the response text reflects this updated value.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `DummyView` class, which inherits from `HTTPMethodView`. It has a class variable `global_var` initialized to 0. The `_iternal_method` method increments `global_var` by 10. The `get` method calls `_iternal_method` and returns a text response that includes the current value of `global_var`. The test adds this view to the Sanic app and makes a GET request to the root URL (\"/\"). It then asserts that the response text is \"I am get method and global var is 10\".\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of a class-based view (`HTTPMethodView`) to encapsulate behavior and state. It also utilizes the Sanic testing client to simulate HTTP requests and validate responses. The assertion at the end of the test confirms that the expected output matches the actual output, ensuring that the internal state of the view is correctly modified and reflected in the response."
    },
    {
      "name": "test_with_decorator",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_views.py",
      "line_number": 207,
      "end_line_number": 226,
      "source_code": "def test_with_decorator(app):\n    results = []\n\n    def stupid_decorator(view):\n        def decorator(*args, **kwargs):\n            results.append(1)\n            return view(*args, **kwargs)\n\n        return decorator\n\n    class DummyView(HTTPMethodView):\n        decorators = [stupid_decorator]\n\n        def get(self, request):\n            return text(\"I am get method\")\n\n    app.add_route(DummyView.as_view(), \"/\")\n    request, response = app.test_client.get(\"/\")\n    assert response.text == \"I am get method\"\n    assert results[0] == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'I am get method'",
        "assert results[0] == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_with_decorator` test is to verify that a custom decorator can be applied to a view in a Sanic application, and that it correctly modifies the behavior of the view while still returning the expected response.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks two key behaviors: \n1. The response from the `DummyView`'s `get` method should return the string \"I am get method\".\n2. The decorator (`stupid_decorator`) should be invoked, which appends a value to the `results` list, confirming that the decorator is functioning as intended.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `DummyView` class, which inherits from `HTTPMethodView`. It defines a `get` method that returns a text response. The `stupid_decorator` is applied to this view, which appends `1` to the `results` list each time the view is called. The test adds the view to the Sanic app's routing and then simulates a GET request to the root URL (\"/\"). The assertions check that the response text matches the expected output and that the decorator was executed.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Decorator Testing**: It demonstrates how to test the interaction between decorators and view methods, ensuring that decorators can modify behavior without breaking the core functionality.\n- **Assertions**: It uses assertions to validate both the output of the view and the side effects of the decorator, ensuring comprehensive coverage of the functionality.\n- **Sanic Testing Client**: The use of `app.test_client.get` allows for simulating HTTP requests in a controlled environment, which is essential for testing web applications."
    },
    {
      "name": "test_vhosts",
      "module": "test_vhosts",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_vhosts.py",
      "line_number": 9,
      "end_line_number": 26,
      "source_code": "def test_vhosts():\n    app = Sanic(\"app\")\n\n    @app.route(\"/\", host=\"example.com\")\n    async def handler1(request):\n        return text(\"You're at example.com!\")\n\n    @app.route(\"/\", host=\"subdomain.example.com\")\n    async def handler2(request):\n        return text(\"You're at subdomain.example.com!\")\n\n    headers = {\"Host\": \"example.com\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert response.text == \"You're at example.com!\"\n\n    headers = {\"Host\": \"subdomain.example.com\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert response.text == \"You're at subdomain.example.com!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "sanic_routing.exceptions.RouteExists",
        "sanic.Sanic",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == \"You're at example.com!\"",
        "assert response.text == \"You're at subdomain.example.com!\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_vhosts` function is designed to verify that the Sanic application correctly routes requests to different handlers based on the `Host` header in the HTTP request. It ensures that requests to specific hostnames return the expected responses.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a request is made to the root path (\"/\") with a specific `Host` header, the application responds with the correct text message associated with that host. It verifies that the application distinguishes between requests for \"example.com\" and \"subdomain.example.com\".\n\n**Code Being Tested and How It Works**:  \nThe code under test includes two route handlers defined within a Sanic application. The first handler responds to requests with the `Host` header set to \"example.com\", returning the message \"You're at example.com!\". The second handler responds to requests with the `Host` header set to \"subdomain.example.com\", returning \"You're at subdomain.example.com!\". The test uses the `app.test_client.get` method to simulate HTTP GET requests with different headers and checks the response text against the expected output.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test leverages asynchronous route handlers, which is a common pattern in modern web frameworks like Sanic.\n- **Header Manipulation**: It demonstrates how to manipulate HTTP headers in tests to simulate different request scenarios.\n- **Assertions**: The test uses assertions to validate that the responses match the expected output, ensuring that the routing logic behaves correctly based on the `Host` header.\n- **Isolation**: Each test case is isolated, focusing on a specific aspect of the routing functionality, which is a best practice in unit testing."
    },
    {
      "name": "test_vhosts_with_list",
      "module": "test_vhosts",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_vhosts.py",
      "line_number": 29,
      "end_line_number": 40,
      "source_code": "def test_vhosts_with_list(app):\n    @app.route(\"/\", host=[\"hello.com\", \"world.com\"])\n    async def handler(request):\n        return text(\"Hello, world!\")\n\n    headers = {\"Host\": \"hello.com\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert response.text == \"Hello, world!\"\n\n    headers = {\"Host\": \"world.com\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert response.text == \"Hello, world!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic_routing.exceptions.RouteExists",
        "sanic.Sanic",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'Hello, world!'",
        "assert response.text == 'Hello, world!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_vhosts_with_list` function is designed to verify that the Sanic application correctly handles virtual hosts specified as a list. It ensures that requests to different hostnames are routed to the same handler and return the expected response.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when requests are made to the application with the `Host` header set to either \"hello.com\" or \"world.com\", the response is consistently \"Hello, world!\". This confirms that the application can serve multiple hostnames with the same route.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the Sanic framework's routing mechanism. The route is defined with a host parameter that accepts a list of hostnames. The `app.route` decorator registers the handler function, which returns a text response. The test simulates HTTP GET requests to the root endpoint (\"/\") with different `Host` headers, and it checks the response text to ensure it matches the expected output.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization of Routes**: The use of a list for the `host` parameter allows for flexible routing based on multiple hostnames.\n- **Assertions**: The test employs assertions to validate the response content, ensuring that the application behaves as expected for different inputs.\n- **Simulated Requests**: The test uses the `app.test_client.get` method to simulate HTTP requests, which is a common pattern in unit testing web applications to verify routing and response behavior."
    },
    {
      "name": "test_vhosts_with_defaults",
      "module": "test_vhosts",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_vhosts.py",
      "line_number": 43,
      "end_line_number": 56,
      "source_code": "def test_vhosts_with_defaults(app):\n    @app.route(\"/\", host=\"hello.com\")\n    async def handler1(request):\n        return text(\"Hello, world!\")\n\n    with pytest.raises(RouteExists):\n\n        @app.route(\"/\")\n        async def handler2(request):\n            return text(\"default\")\n\n    headers = {\"Host\": \"hello.com\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert response.text == \"Hello, world!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic_routing.exceptions.RouteExists",
        "sanic.Sanic",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'Hello, world!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_vhosts_with_defaults` test verifies that the Sanic application correctly handles route definitions with host-specific routing, ensuring that a route defined for a specific host cannot be overridden by a default route without a host specification.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a route is defined for the host \"hello.com\", any attempt to define a route for the same path (\"/\") without specifying a host raises a `RouteExists` exception. It also confirms that requests to the defined route return the expected response.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route for the path \"/\" that is specific to the host \"hello.com\". When a request is made to this route with the appropriate host header, it returns \"Hello, world!\". The test then attempts to define another route for the same path without a host, which should raise a `RouteExists` exception, indicating that the route cannot be redefined. Finally, it sends a GET request to the route and asserts that the response text matches the expected output.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Exception Testing**: The use of `pytest.raises` to assert that a specific exception (`RouteExists`) is raised when trying to create a conflicting route.\n- **Header Manipulation**: The test simulates a request with a specific \"Host\" header to ensure that the routing logic correctly identifies and processes the request based on the host.\n- **Asynchronous Testing**: The test leverages asynchronous route handlers, which is a common pattern in modern web frameworks like Sanic, allowing for non-blocking I/O operations."
    },
    {
      "name": "test_get_logo_returns_expected_logo",
      "module": "test_logo",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_logo.py",
      "line_number": 25,
      "end_line_number": 29,
      "source_code": "def test_get_logo_returns_expected_logo(tty, full, expected):\n    with patch(\"sys.stdout.isatty\") as isatty:\n        isatty.return_value = tty\n        logo = get_logo(full=full)\n    assert logo is expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('tty,full,expected', ((True, False, COLOR_LOGO), (True, True, FULL_COLOR_LOGO), (False, False, BASE_LOGO), (False, True, BASE_LOGO)))"
      ],
      "arguments": [
        "tty",
        "full",
        "expected"
      ],
      "imports": [
        "os",
        "sys",
        "unittest.mock.patch",
        "pytest",
        "sanic.application.logo.BASE_LOGO",
        "sanic.application.logo.COLOR_LOGO",
        "sanic.application.logo.FULL_COLOR_LOGO",
        "sanic.application.logo.get_logo"
      ],
      "fixtures": [],
      "assertions": [
        "assert logo is expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_get_logo_returns_expected_logo` test is to verify that the `get_logo` function returns the correct logo based on the terminal type (TTY) and whether the full logo is requested. It ensures that the function behaves as expected under different conditions.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks the output of the `get_logo` function against predefined expected values for various combinations of terminal capabilities (TTY) and the `full` parameter. It confirms that the function returns the appropriate logo string based on these inputs.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `get_logo` function from the `sanic.application.logo` module. The function's behavior is influenced by the `sys.stdout.isatty()` method, which indicates whether the output is connected to a terminal. The test uses the `patch` function from the `unittest.mock` module to mock the return value of `isatty`, allowing the test to simulate different terminal conditions without requiring an actual terminal.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses `pytest.mark.parametrize` to run the same test logic with multiple sets of input values (TTY, full, expected). This approach reduces code duplication and enhances test coverage by systematically checking various scenarios.\n- **Mocking**: The `patch` function is employed to mock the behavior of `sys.stdout.isatty`, allowing the test to control the environment in which `get_logo` operates. This technique isolates the function under test from external dependencies, ensuring that the test results are reliable and focused solely on the function's logic."
    },
    {
      "name": "test_get_logo_returns_no_colors_on_apple_terminal",
      "module": "test_logo",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_logo.py",
      "line_number": 32,
      "end_line_number": 41,
      "source_code": "def test_get_logo_returns_no_colors_on_apple_terminal():\n    platform = sys.platform\n    sys.platform = \"darwin\"\n    os.environ[\"TERM_PROGRAM\"] = \"Apple_Terminal\"\n    with patch(\"sys.stdout.isatty\") as isatty:\n        isatty.return_value = False\n        logo = get_logo()\n    assert \"\\033\" not in logo\n    sys.platform = platform\n    del os.environ[\"TERM_PROGRAM\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "os",
        "sys",
        "unittest.mock.patch",
        "pytest",
        "sanic.application.logo.BASE_LOGO",
        "sanic.application.logo.COLOR_LOGO",
        "sanic.application.logo.FULL_COLOR_LOGO",
        "sanic.application.logo.get_logo"
      ],
      "fixtures": [],
      "assertions": [
        "assert '\\x1b' not in logo"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_get_logo_returns_no_colors_on_apple_terminal` is designed to verify that the Sanic logo returned by the `get_logo` function does not contain any ANSI escape codes when the code is executed in an Apple Terminal environment. This is important because ANSI codes are used for color formatting in terminal outputs, and the test ensures that the logo is displayed in a plain format when the terminal does not support colors.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that when the platform is set to \"darwin\" (macOS) and the `TERM_PROGRAM` environment variable is set to \"Apple_Terminal\", the output of the `get_logo` function does not include any ANSI escape sequences (represented by the presence of `\\033` in the output). This behavior is crucial for ensuring that users in environments that do not support color formatting receive a correctly formatted logo.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `get_logo` function, which returns different versions of the Sanic logo based on the terminal's capabilities and the provided parameters. The function checks if the terminal is a TTY (using `is_atty()`) and whether it is running on macOS with Apple Terminal. If both conditions are met, it strips any ANSI codes from the logo using a regular expression. The test manipulates the environment to simulate this scenario and then asserts that the returned logo does not contain any ANSI escape codes.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `patch` function from the `unittest.mock` module to temporarily replace the behavior of `sys.stdout.isatty` during the test execution. This allows the test to simulate a non-TTY environment without affecting the global state of the application. Additionally, the test restores the original platform and cleans up the environment variable after execution, ensuring that the test does not have side effects on subsequent tests. This pattern of setup and teardown is a common practice in unit testing to maintain isolation between tests."
    },
    {
      "name": "test_bp_group_indexing",
      "module": "test_blueprint_group",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprint_group.py",
      "line_number": 18,
      "end_line_number": 26,
      "source_code": "def test_bp_group_indexing(app: Sanic):\n    blueprint_1 = Blueprint(\"blueprint_1\", url_prefix=\"/bp1\")\n    blueprint_2 = Blueprint(\"blueprint_2\", url_prefix=\"/bp2\")\n\n    group = Blueprint.group(blueprint_1, blueprint_2)\n    assert group[0] == blueprint_1\n\n    with raises(expected_exception=IndexError):\n        _ = group[3]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "pytest.raises",
        "sanic.app.Sanic",
        "sanic.blueprint_group.BlueprintGroup",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert group[0] == blueprint_1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_bp_group_indexing` test is to verify the correct indexing behavior of a `BlueprintGroup` in the Sanic framework. It ensures that the blueprints can be accessed by their index and that an `IndexError` is raised when attempting to access an out-of-bounds index.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks two behaviors: \n1. It confirms that the first blueprint in the group can be accessed correctly using its index (i.e., `group[0]` should return `blueprint_1`).\n2. It verifies that accessing an index that is out of range (in this case, `group[3]`) raises an `IndexError`, which is the expected behavior for list-like structures in Python.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `Blueprint.group` method, which creates a `BlueprintGroup` containing multiple blueprints. The test initializes two blueprints (`blueprint_1` and `blueprint_2`), groups them together, and then checks the indexing functionality. The `BlueprintGroup` class is designed to behave like a list, allowing access to its elements via indexing. The `__getitem__` method is implicitly tested here, which retrieves the blueprint at the specified index.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `raises` context manager from the `pytest` library to assert that an `IndexError` is raised when accessing an invalid index. This is a common pattern in unit testing to handle expected exceptions cleanly. Additionally, the use of assertions (`assert`) to verify expected outcomes is a standard practice in unit tests, ensuring that the code behaves as intended. The test is structured to be clear and concise, focusing on specific behaviors without unnecessary complexity."
    },
    {
      "name": "test_bp_group_set_item_by_index",
      "module": "test_blueprint_group",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprint_group.py",
      "line_number": 29,
      "end_line_number": 36,
      "source_code": "def test_bp_group_set_item_by_index(app: Sanic):\n    blueprint_1 = Blueprint(\"blueprint_1\", url_prefix=\"/bp1\")\n    blueprint_2 = Blueprint(\"blueprint_2\", url_prefix=\"/bp2\")\n\n    group = Blueprint.group(blueprint_1, blueprint_2)\n    group[0] = blueprint_2\n\n    assert group[0] == blueprint_2",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "pytest.raises",
        "sanic.app.Sanic",
        "sanic.blueprint_group.BlueprintGroup",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert group[0] == blueprint_2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_bp_group_set_item_by_index` test is to verify that the `__setitem__` method of the `BlueprintGroup` class correctly updates an item at a specified index. This ensures that the functionality of modifying the group of blueprints behaves as expected.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a blueprint is assigned to an index in the blueprint group, the assignment is successful and the blueprint at that index reflects the new value. It asserts that the blueprint at index `0` is equal to `blueprint_2` after the assignment.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `__setitem__` method of the `BlueprintGroup` class, which allows for indexed assignment of `Blueprint` objects. The method takes an index and a `Blueprint` instance, replacing the existing blueprint at that index with the new one. The test first creates two blueprints, groups them, and then assigns `blueprint_2` to index `0`. The assertion checks that the blueprint at index `0` is indeed `blueprint_2`, confirming that the assignment was successful.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern to validate the expected outcome. It uses the `assert` statement to compare the current state of the blueprint group with the expected state after the modification. This direct comparison is a common technique in unit testing to ensure that the code under test behaves as intended. Additionally, the test is structured to be simple and focused, which is a best practice in unit testing to isolate specific behaviors for verification."
    },
    {
      "name": "test_bp_group_with_additional_route_params",
      "module": "test_blueprint_group",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprint_group.py",
      "line_number": 39,
      "end_line_number": 101,
      "source_code": "def test_bp_group_with_additional_route_params(app: Sanic):\n    blueprint_1 = Blueprint(\"blueprint_1\", url_prefix=\"/bp1\")\n    blueprint_2 = Blueprint(\"blueprint_2\", url_prefix=\"/bp2\")\n\n    @blueprint_1.route(\n        \"/request_path\", methods=frozenset({\"PUT\", \"POST\"}), version=2\n    )\n    def blueprint_1_v2_method_with_put_and_post(request: Request):\n        if request.method == \"PUT\":\n            return text(\"PUT_OK\")\n        elif request.method == \"POST\":\n            return text(\"POST_OK\")\n\n    @blueprint_2.route(\n        \"/route/<param>\", methods=frozenset({\"DELETE\", \"PATCH\"}), name=\"test\"\n    )\n    def blueprint_2_named_method(request: Request, param):\n        if request.method == \"DELETE\":\n            return text(f\"DELETE_{param}\")\n        elif request.method == \"PATCH\":\n            return text(f\"PATCH_{param}\")\n\n    blueprint_group = Blueprint.group(\n        blueprint_1, blueprint_2, url_prefix=\"/api\"\n    )\n\n    @blueprint_group.middleware(\"request\")\n    def authenticate_request(request: Request):\n        global AUTH\n        auth = request.headers.get(\"authorization\")\n        if auth:\n            # Dummy auth check. We can have anything here and it's fine.\n            if AUTH not in auth:\n                return text(\"Unauthorized\", status=401)\n        else:\n            return text(\"Unauthorized\", status=401)\n\n    @blueprint_group.middleware(\"response\")\n    def enhance_response_middleware(request: Request, response: HTTPResponse):\n        response.headers.add(\"x-test-middleware\", \"value\")\n\n    app.blueprint(blueprint_group)\n\n    header = {\"authorization\": \" \".join([\"Basic\", AUTH])}\n    _, response = app.test_client.put(\n        \"/v2/api/bp1/request_path\", headers=header\n    )\n    assert response.text == \"PUT_OK\"\n    assert response.headers.get(\"x-test-middleware\") == \"value\"\n\n    _, response = app.test_client.post(\n        \"/v2/api/bp1/request_path\", headers=header\n    )\n    assert response.text == \"POST_OK\"\n\n    _, response = app.test_client.delete(\"/api/bp2/route/bp2\", headers=header)\n    assert response.text == \"DELETE_bp2\"\n\n    _, response = app.test_client.patch(\"/api/bp2/route/bp2\", headers=header)\n    assert response.text == \"PATCH_bp2\"\n\n    _, response = app.test_client.put(\"/v2/api/bp1/request_path\")\n    assert response.status == 401",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "pytest.raises",
        "sanic.app.Sanic",
        "sanic.blueprint_group.BlueprintGroup",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'PUT_OK'",
        "assert response.headers.get('x-test-middleware') == 'value'",
        "assert response.text == 'POST_OK'",
        "assert response.text == 'DELETE_bp2'",
        "assert response.text == 'PATCH_bp2'",
        "assert response.status == 401"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "app.test_client.patch('/api/bp2/route/bp2', headers=header)"
      ],
      "methods_under_test": [
        {
          "name": "app.test_client.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.delete",
          "body": "def delete(self, request):\n    return text('I am delete method')"
        },
        {
          "name": "app.test_client.patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "app.test_client.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "request.headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response.headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_bp_group_with_additional_route_params` test is to verify the correct behavior of a Sanic application that utilizes blueprints with various HTTP methods, middleware for authentication, and response enhancement. It ensures that the application correctly handles requests to different routes and responds appropriately based on the request method and authentication status.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies that:\n1. The application correctly processes `PUT` and `POST` requests to the `/bp1/request_path` endpoint, returning the expected responses.\n2. The middleware correctly authenticates requests, returning a 401 status for unauthorized access.\n3. The application correctly handles `DELETE` and `PATCH` requests to the `/bp2/route/<param>` endpoint, returning responses that include the parameter in the response text.\n4. The response headers are enhanced by the middleware, specifically checking for the presence of the `x-test-middleware` header.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes:\n- Two blueprints (`blueprint_1` and `blueprint_2`) with defined routes for handling `PUT`, `POST`, `DELETE`, and `PATCH` requests.\n- Middleware functions for request authentication and response enhancement.\n- The test client is used to simulate HTTP requests to the defined routes, checking the responses against expected values.\n\nThe routes are defined as follows:\n- `blueprint_1` handles `PUT` and `POST` requests at `/bp1/request_path`.\n- `blueprint_2` handles `DELETE` and `PATCH` requests at `/bp2/route/<param>`, where `<param>` is a dynamic segment of the URL.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Blueprints**: The test utilizes Sanic's blueprint feature to organize routes and middleware, promoting modularity and reusability.\n- **Middleware**: The test includes middleware for authentication and response modification, demonstrating how middleware can be used to enforce security and modify responses globally.\n- **Assertions**: The test employs assertions to validate the correctness of responses, including checking response text and headers, which is a common practice in unit testing to ensure expected outcomes.\n- **HTTP Method Testing**: The test methodically checks various HTTP methods, ensuring that the application behaves correctly for each method, which is crucial for RESTful APIs."
    },
    {
      "name": "test_bp_group",
      "module": "test_blueprint_group",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprint_group.py",
      "line_number": 104,
      "end_line_number": 213,
      "source_code": "def test_bp_group(app: Sanic):\n    blueprint_1 = Blueprint(\"blueprint_1\", url_prefix=\"/bp1\")\n    blueprint_2 = Blueprint(\"blueprint_2\", url_prefix=\"/bp2\")\n\n    @blueprint_1.route(\"/\")\n    def blueprint_1_default_route(request):\n        return text(\"BP1_OK\")\n\n    @blueprint_1.route(\"/invalid\")\n    def blueprint_1_error(request: Request):\n        raise BadRequest(\"Invalid\")\n\n    @blueprint_2.route(\"/\")\n    def blueprint_2_default_route(request):\n        return text(\"BP2_OK\")\n\n    @blueprint_2.route(\"/error\")\n    def blueprint_2_error(request: Request):\n        raise ServerError(\"Error\")\n\n    blueprint_group_1 = Blueprint.group(\n        blueprint_1, blueprint_2, url_prefix=\"/bp\"\n    )\n\n    blueprint_3 = Blueprint(\"blueprint_3\", url_prefix=\"/bp3\")\n\n    @blueprint_group_1.exception(BadRequest)\n    def handle_group_exception(request, exception):\n        return text(\"BP1_ERR_OK\")\n\n    @blueprint_group_1.middleware(\"request\")\n    def blueprint_group_1_middleware(request):\n        global MIDDLEWARE_INVOKE_COUNTER\n        MIDDLEWARE_INVOKE_COUNTER[\"request\"] += 1\n\n    @blueprint_group_1.middleware\n    def blueprint_group_1_middleware_not_called(request):\n        global MIDDLEWARE_INVOKE_COUNTER\n        MIDDLEWARE_INVOKE_COUNTER[\"request\"] += 1\n\n    @blueprint_group_1.on_request\n    def blueprint_group_1_convenience_1(request):\n        global MIDDLEWARE_INVOKE_COUNTER\n        MIDDLEWARE_INVOKE_COUNTER[\"request\"] += 1\n\n    @blueprint_group_1.on_request()\n    def blueprint_group_1_convenience_2(request):\n        global MIDDLEWARE_INVOKE_COUNTER\n        MIDDLEWARE_INVOKE_COUNTER[\"request\"] += 1\n\n    @blueprint_3.route(\"/\")\n    def blueprint_3_default_route(request):\n        return text(\"BP3_OK\")\n\n    @blueprint_3.route(\"/forbidden\")\n    def blueprint_3_forbidden(request: Request):\n        raise Forbidden(\"Forbidden\")\n\n    blueprint_group_2 = Blueprint.group(\n        blueprint_group_1, blueprint_3, url_prefix=\"/api\"\n    )\n\n    @blueprint_group_2.exception(SanicException)\n    def handle_non_handled_exception(request, exception):\n        return text(\"BP2_ERR_OK\")\n\n    @blueprint_group_2.middleware(\"response\")\n    def blueprint_group_2_middleware(request, response):\n        global MIDDLEWARE_INVOKE_COUNTER\n        MIDDLEWARE_INVOKE_COUNTER[\"response\"] += 1\n\n    @blueprint_group_2.on_response\n    def blueprint_group_2_middleware_convenience_1(request, response):\n        global MIDDLEWARE_INVOKE_COUNTER\n        MIDDLEWARE_INVOKE_COUNTER[\"response\"] += 1\n\n    @blueprint_group_2.on_response()\n    def blueprint_group_2_middleware_convenience_2(request, response):\n        global MIDDLEWARE_INVOKE_COUNTER\n        MIDDLEWARE_INVOKE_COUNTER[\"response\"] += 1\n\n    app.blueprint(blueprint_group_2)\n\n    @app.route(\"/\")\n    def app_default_route(request):\n        return text(\"APP_OK\")\n\n    _, response = app.test_client.get(\"/\")\n    assert response.text == \"APP_OK\"\n\n    _, response = app.test_client.get(\"/api/bp/bp1\")\n    assert response.text == \"BP1_OK\"\n\n    _, response = app.test_client.get(\"/api/bp/bp1/invalid\")\n    assert response.text == \"BP1_ERR_OK\"\n\n    _, response = app.test_client.get(\"/api/bp/bp2\")\n    assert response.text == \"BP2_OK\"\n\n    _, response = app.test_client.get(\"/api/bp/bp2/error\")\n    assert response.text == \"BP2_ERR_OK\"\n\n    _, response = app.test_client.get(\"/api/bp3\")\n    assert response.text == \"BP3_OK\"\n\n    _, response = app.test_client.get(\"/api/bp3/forbidden\")\n    assert response.text == \"BP2_ERR_OK\"\n\n    assert MIDDLEWARE_INVOKE_COUNTER[\"response\"] == 18\n    assert MIDDLEWARE_INVOKE_COUNTER[\"request\"] == 16",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "pytest.raises",
        "sanic.app.Sanic",
        "sanic.blueprint_group.BlueprintGroup",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'APP_OK'",
        "assert response.text == 'BP1_OK'",
        "assert response.text == 'BP1_ERR_OK'",
        "assert response.text == 'BP2_OK'",
        "assert response.text == 'BP2_ERR_OK'",
        "assert response.text == 'BP3_OK'",
        "assert response.text == 'BP2_ERR_OK'",
        "assert MIDDLEWARE_INVOKE_COUNTER['response'] == 18",
        "assert MIDDLEWARE_INVOKE_COUNTER['request'] == 16"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "blueprint_group_1.exception",
          "body": "@app.route('/')\ndef exception(request):\n    raise SanicExceptionTestException(\"You won't see me\")"
        },
        {
          "name": "blueprint_group_2.exception",
          "body": "@app.route('/')\ndef exception(request):\n    raise SanicExceptionTestException(\"You won't see me\")"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_bp_group` function is to validate the behavior and functionality of multiple Sanic blueprints and their interactions when grouped together. It ensures that routes defined within these blueprints respond correctly to HTTP requests and that middleware and exception handling are functioning as expected.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies that:\n1. The default routes for the application and blueprints return the expected responses.\n2. Exception handling works correctly, returning appropriate responses when errors are raised (e.g., `BadRequest`, `ServerError`, `Forbidden`).\n3. Middleware is invoked the expected number of times for both request and response phases, ensuring that the middleware logic is executed correctly.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves:\n- Multiple blueprints (`blueprint_1`, `blueprint_2`, and `blueprint_3`) with defined routes that return specific text responses.\n- Grouping of blueprints into `blueprint_group_1` and `blueprint_group_2`, which allows for shared middleware and exception handling.\n- Middleware functions that increment a global counter (`MIDDLEWARE_INVOKE_COUNTER`) to track how many times they are called during the request/response lifecycle.\n- The test client is used to simulate HTTP GET requests to various routes, and assertions are made to check the responses against expected values.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Blueprint Grouping**: The test demonstrates the use of blueprint grouping in Sanic, allowing for organized route management and shared functionality.\n- **Middleware and Exception Handling**: It showcases how middleware can be applied at different levels (request and response) and how exceptions can be handled specifically for grouped blueprints.\n- **Assertions**: The test employs assertions to validate both the content of the responses and the invocation counts of middleware, ensuring comprehensive coverage of the functionality being tested."
    },
    {
      "name": "test_bp_group_list_operations",
      "module": "test_blueprint_group",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprint_group.py",
      "line_number": 216,
      "end_line_number": 249,
      "source_code": "def test_bp_group_list_operations(app: Sanic):\n    blueprint_1 = Blueprint(\"blueprint_1\", url_prefix=\"/bp1\")\n    blueprint_2 = Blueprint(\"blueprint_2\", url_prefix=\"/bp2\")\n\n    @blueprint_1.route(\"/\")\n    def blueprint_1_default_route(request):\n        return text(\"BP1_OK\")\n\n    @blueprint_2.route(\"/\")\n    def blueprint_2_default_route(request):\n        return text(\"BP2_OK\")\n\n    blueprint_group_1 = Blueprint.group(\n        blueprint_1, blueprint_2, url_prefix=\"/bp\"\n    )\n\n    blueprint_3 = Blueprint(\"blueprint_2\", url_prefix=\"/bp3\")\n\n    @blueprint_3.route(\"/second\")\n    def blueprint_3_second_route(request):\n        return text(\"BP3_OK\")\n\n    assert len(blueprint_group_1) == 2\n\n    blueprint_group_1.append(blueprint_3)\n    assert len(blueprint_group_1) == 3\n\n    del blueprint_group_1[2]\n    assert len(blueprint_group_1) == 2\n\n    blueprint_group_1[1] = blueprint_3\n    assert len(blueprint_group_1) == 2\n\n    assert blueprint_group_1.url_prefix == \"/bp\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "pytest.raises",
        "sanic.app.Sanic",
        "sanic.blueprint_group.BlueprintGroup",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(blueprint_group_1) == 2",
        "assert len(blueprint_group_1) == 3",
        "assert len(blueprint_group_1) == 2",
        "assert len(blueprint_group_1) == 2",
        "assert blueprint_group_1.url_prefix == '/bp'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_bp_group_list_operations` test verifies the behavior of grouping multiple blueprints in a Sanic application and ensures that operations such as appending, deleting, and replacing blueprints within a group function as expected.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks the following behaviors:\n1. The initial count of blueprints in the group.\n2. The count after appending a new blueprint.\n3. The count after deleting a blueprint.\n4. The count after replacing a blueprint.\n5. The URL prefix of the blueprint group.\n\n**Code Being Tested and How It Works**:  \nThe test creates two blueprints (`blueprint_1` and `blueprint_2`) and groups them under a new blueprint group (`blueprint_group_1`) with a URL prefix of `/bp`. It then performs a series of assertions to validate the length of the group after various operations:\n- Initially, it asserts that the group contains 2 blueprints.\n- After appending a third blueprint (`blueprint_3`), it asserts the count is 3.\n- It deletes the third blueprint and checks the count again, asserting it returns to 2.\n- It replaces the second blueprint with `blueprint_3` and checks that the count remains 2.\n- Finally, it asserts that the URL prefix of the group is `/bp`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs direct assertions to validate the state of the blueprint group after each operation, which is a straightforward approach to unit testing. It uses the `assert` statement to check conditions, ensuring that the expected outcomes match the actual results. This method is effective for verifying the integrity of the blueprint group operations in a clear and concise manner."
    },
    {
      "name": "test_bp_group_as_list",
      "module": "test_blueprint_group",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprint_group.py",
      "line_number": 252,
      "end_line_number": 256,
      "source_code": "def test_bp_group_as_list():\n    blueprint_1 = Blueprint(\"blueprint_1\", url_prefix=\"/bp1\")\n    blueprint_2 = Blueprint(\"blueprint_2\", url_prefix=\"/bp2\")\n    blueprint_group_1 = Blueprint.group([blueprint_1, blueprint_2])\n    assert len(blueprint_group_1) == 2",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "pytest.raises",
        "sanic.app.Sanic",
        "sanic.blueprint_group.BlueprintGroup",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(blueprint_group_1) == 2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_bp_group_as_list` function aims to verify the correct behavior of the `Blueprint.group` method in the Sanic framework, specifically ensuring that it can successfully group multiple `Blueprint` instances and that the resulting group behaves like a list in terms of length.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when two `Blueprint` instances are grouped together using the `Blueprint.group` method, the length of the resulting `BlueprintGroup` object is equal to 2. This confirms that the grouping operation correctly aggregates the blueprints.\n\n**Code Being Tested and How It Works**:  \nThe test creates two `Blueprint` instances (`blueprint_1` and `blueprint_2`) with specified URL prefixes. It then groups these blueprints into a `BlueprintGroup` using the `Blueprint.group` method. The assertion `assert len(blueprint_group_1) == 2` checks that the length of the `blueprint_group_1` object, which should contain both blueprints, is indeed 2. The `Blueprint.group` method is expected to aggregate the provided blueprints into a single group, which is designed to behave like a list.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern to validate the expected outcome. It uses the built-in `assert` statement to check the length of the `BlueprintGroup`, which is a common practice in unit testing to ensure that the code behaves as intended. The test is also structured to be simple and focused, making it easy to understand the specific functionality being verified without extraneous complexity."
    },
    {
      "name": "test_bp_group_as_nested_group",
      "module": "test_blueprint_group",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprint_group.py",
      "line_number": 259,
      "end_line_number": 265,
      "source_code": "def test_bp_group_as_nested_group():\n    blueprint_1 = Blueprint(\"blueprint_1\", url_prefix=\"/bp1\")\n    blueprint_2 = Blueprint(\"blueprint_2\", url_prefix=\"/bp2\")\n    blueprint_group_1 = Blueprint.group(\n        Blueprint.group(blueprint_1, blueprint_2)\n    )\n    assert len(blueprint_group_1) == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "pytest.raises",
        "sanic.app.Sanic",
        "sanic.blueprint_group.BlueprintGroup",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(blueprint_group_1) == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_bp_group_as_nested_group` aims to verify the behavior of creating a nested blueprint group using the Sanic framework's `Blueprint.group` method. It specifically checks that when two blueprints are grouped together into a nested group, the resulting group behaves as expected in terms of its length.\n\n**Specific Functionality or Behavior Verified**:  \nThe test asserts that the length of the nested blueprint group is equal to 1. This is significant because it indicates that the grouping operation has successfully encapsulated the two blueprints into a single group, rather than treating them as separate entities.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves creating two blueprints (`blueprint_1` and `blueprint_2`) and then nesting them within another blueprint group using `Blueprint.group`. The assertion `assert len(blueprint_group_1) == 1` checks that the outer group contains only one item, which is the inner group that contains both blueprints. This behavior is expected based on the design of the `Blueprint.group` method, which is intended to allow for hierarchical organization of blueprints.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern to validate the expected outcome. It uses the `assert` statement to check the length of the resulting blueprint group, which is a common technique in unit testing to verify that a function or method produces the correct result. Additionally, the test demonstrates the use of nested structures, which is a useful pattern for organizing related functionality in web applications."
    },
    {
      "name": "test_blueprint_group_insert",
      "module": "test_blueprint_group",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprint_group.py",
      "line_number": 268,
      "end_line_number": 302,
      "source_code": "def test_blueprint_group_insert():\n    blueprint_1 = Blueprint(\n        \"blueprint_1\", url_prefix=\"/bp1\", strict_slashes=True, version=1\n    )\n    blueprint_2 = Blueprint(\"blueprint_2\", url_prefix=\"/bp2\")\n    blueprint_3 = Blueprint(\"blueprint_3\", url_prefix=None)\n    group = BlueprintGroup(\n        url_prefix=\"/test\", version=1.3, strict_slashes=False\n    )\n    group.insert(0, blueprint_1)\n    group.insert(0, blueprint_2)\n    group.insert(0, blueprint_3)\n\n    @blueprint_1.route(\"/\")\n    def blueprint_1_default_route(request):\n        return text(\"BP1_OK\")\n\n    @blueprint_2.route(\"/\")\n    def blueprint_2_default_route(request):\n        return text(\"BP2_OK\")\n\n    @blueprint_3.route(\"/\")\n    def blueprint_3_default_route(request):\n        return text(\"BP3_OK\")\n\n    app = Sanic(\"PropTest\")\n    app.blueprint(group)\n    app.router.finalize()\n\n    routes = [(route.path, route.strict) for route in app.router.routes]\n\n    assert len(routes) == 3\n    assert (\"v1/test/bp1/\", True) in routes\n    assert (\"v1.3/test/bp2\", False) in routes\n    assert (\"v1.3/test\", False) in routes",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "pytest.raises",
        "sanic.app.Sanic",
        "sanic.blueprint_group.BlueprintGroup",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(routes) == 3",
        "assert ('v1/test/bp1/', True) in routes",
        "assert ('v1.3/test/bp2', False) in routes",
        "assert ('v1.3/test', False) in routes"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_blueprint_group_insert` test is to verify the correct insertion and routing behavior of multiple blueprints within a `BlueprintGroup` in the Sanic web framework. It ensures that the routes are registered correctly with the expected URL paths and strict slash behavior.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that three blueprints are inserted into a blueprint group and that their routes are accessible with the correct URL prefixes and strict slash settings. It asserts that the total number of routes is as expected and that each route is defined with the correct path and strictness.\n\n**Code Being Tested and How It Works**:  \nThe test creates three `Blueprint` instances with different URL prefixes and strict slash settings. It then creates a `BlueprintGroup` and inserts the blueprints into it. After registering the group with a Sanic application, the test finalizes the router and retrieves the list of routes. The assertions check that the number of routes is three and that the paths and strictness of each route match the expected values based on the blueprints' configurations.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Setup and Teardown**: The test sets up the necessary components (blueprints and application) within the test function, ensuring isolation and repeatability.\n- **Assertions**: It uses assertions to validate the expected outcomes, which is a fundamental practice in unit testing to confirm that the code behaves as intended.\n- **Route Finalization**: The call to `app.router.finalize()` is crucial as it compiles the routes, ensuring that any changes made to the blueprints are reflected in the application's routing table before assertions are made."
    },
    {
      "name": "test_bp_group_properties",
      "module": "test_blueprint_group",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprint_group.py",
      "line_number": 305,
      "end_line_number": 337,
      "source_code": "def test_bp_group_properties():\n    blueprint_1 = Blueprint(\"blueprint_1\", url_prefix=\"/bp1\")\n    blueprint_2 = Blueprint(\"blueprint_2\", url_prefix=\"/bp2\")\n    group = Blueprint.group(\n        blueprint_1,\n        blueprint_2,\n        version=1,\n        version_prefix=\"/api/v\",\n        url_prefix=\"/grouped\",\n        strict_slashes=True,\n    )\n    primary = Blueprint.group(group, url_prefix=\"/primary\")\n\n    @blueprint_1.route(\"/\")\n    def blueprint_1_default_route(request):\n        return text(\"BP1_OK\")\n\n    @blueprint_2.route(\"/\")\n    def blueprint_2_default_route(request):\n        return text(\"BP2_OK\")\n\n    app = Sanic(\"PropTest\")\n    app.blueprint(group)\n    app.blueprint(primary)\n    app.router.finalize()\n\n    routes = [route.path for route in app.router.routes]\n\n    assert len(routes) == 4\n    assert \"api/v1/grouped/bp1/\" in routes\n    assert \"api/v1/grouped/bp2/\" in routes\n    assert \"api/v1/primary/grouped/bp1\" in routes\n    assert \"api/v1/primary/grouped/bp2\" in routes",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "pytest.raises",
        "sanic.app.Sanic",
        "sanic.blueprint_group.BlueprintGroup",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(routes) == 4",
        "assert 'api/v1/grouped/bp1/' in routes",
        "assert 'api/v1/grouped/bp2/' in routes",
        "assert 'api/v1/primary/grouped/bp1' in routes",
        "assert 'api/v1/primary/grouped/bp2' in routes"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_bp_group_properties` test is to verify the correct registration and routing of multiple blueprints within a Sanic application, ensuring that the expected routes are generated based on the defined URL prefixes and versioning.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the routes created by grouping blueprints are correctly formed according to the specified URL prefixes and versioning. It asserts that the total number of routes is as expected and that each route is present in the application's router.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves creating two blueprints (`blueprint_1` and `blueprint_2`) and grouping them into a parent blueprint (`group`) with a version prefix and URL prefix. A secondary grouping (`primary`) is also created. The test then registers these blueprints with a Sanic application instance and finalizes the router. The routes are extracted from the router, and assertions are made to ensure that the expected routes exist and that the total count of routes is correct.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the following notable patterns:\n- **Setup and Teardown**: The test sets up the necessary blueprints and application context before performing assertions, ensuring a clean state for each test run.\n- **Assertions**: It uses assertions to validate the expected outcomes, checking both the count of routes and the presence of specific route paths.\n- **Blueprint Grouping**: The test demonstrates the use of blueprint grouping, a common pattern in web frameworks to organize routes and handlers logically.\n- **Versioning and URL Prefixing**: It showcases how to manage versioning and URL prefixes in a structured manner, which is crucial for maintaining API compatibility."
    },
    {
      "name": "test_nested_bp_group_properties",
      "module": "test_blueprint_group",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprint_group.py",
      "line_number": 340,
      "end_line_number": 354,
      "source_code": "def test_nested_bp_group_properties():\n    one = Blueprint(\"one\", url_prefix=\"/one\")\n    two = Blueprint.group(one)\n    three = Blueprint.group(two, url_prefix=\"/three\")\n\n    @one.route(\"/four\")\n    def handler(request):\n        return text(\"pi\")\n\n    app = Sanic(\"PropTest\")\n    app.blueprint(three)\n    app.router.finalize()\n\n    routes = [route.path for route in app.router.routes]\n    assert routes == [\"three/one/four\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "pytest.raises",
        "sanic.app.Sanic",
        "sanic.blueprint_group.BlueprintGroup",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert routes == ['three/one/four']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_nested_bp_group_properties` test verifies the correct registration and routing of nested blueprints in a Sanic application. It ensures that the routes defined within nested blueprints are correctly prefixed and accessible as expected.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that a route defined in a nested blueprint structure is correctly resolved to the expected URL path. In this case, it confirms that the route `/four` from the blueprint `one` is accessible under the path `three/one/four` when the blueprints are grouped and registered.\n\n**Code Being Tested and How It Works**:  \nThe test creates three blueprints: `one`, `two`, and `three`. The blueprint `two` is created as a group of `one`, and `three` is created as a group of `two` with an additional URL prefix of `/three`. A route is defined in `one` that returns the text \"pi\" when accessed. The Sanic application is then instantiated, and the nested blueprint `three` is registered. After finalizing the router, the test checks the paths of the registered routes to ensure that the expected route `three/one/four` is present.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern to validate the expected outcome against the actual result. It uses the `assert` statement to compare the list of registered routes with the expected list, which is a common practice in unit testing to ensure that the code behaves as intended. Additionally, the test demonstrates the use of blueprint grouping, which is a feature of the Sanic framework that allows for organized route management and URL structuring."
    },
    {
      "name": "test_route",
      "module": "test_versioning",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_versioning.py",
      "line_number": 14,
      "end_line_number": 18,
      "source_code": "def test_route(app, handler):\n    app.route(\"/\", version=1)(handler)\n\n    _, response = app.test_client.get(\"/v1\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "handler"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_route` function is designed to verify that a specific route in a Sanic web application correctly handles GET requests and returns the expected HTTP status code (200 OK) when accessed.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the route defined at the path \"/\" with versioning (v1) responds successfully to a GET request. It ensures that the application correctly routes the request to the appropriate handler and that the handler returns a valid response.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `app.route` method, which registers a route with a specified path and version. The `handler` function is defined to return a simple text response. The test then uses `app.test_client.get` to simulate a GET request to the versioned route \"/v1\". The expected behavior is that the response status should be 200, indicating a successful request.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Route Registration**: The test demonstrates the use of dynamic route registration with versioning, which is a common pattern in web applications to manage different versions of APIs.\n- **Client Simulation**: It utilizes the test client provided by Sanic to simulate HTTP requests, allowing for easy testing of route behavior without needing to run a live server.\n- **Assertion**: The test employs a straightforward assertion to verify the response status, which is a fundamental practice in unit testing to confirm that the actual output matches the expected output."
    },
    {
      "name": "test_bp",
      "module": "test_versioning",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_versioning.py",
      "line_number": 21,
      "end_line_number": 27,
      "source_code": "def test_bp(app, handler):\n    bp = Blueprint(\"Test\", version=1)\n    bp.route(\"/\")(handler)\n    app.blueprint(bp)\n\n    _, response = app.test_client.get(\"/v1\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "handler"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_bp` function is designed to verify that a Sanic application can successfully register a blueprint and handle a GET request to a specific route, ensuring that the response status is 200 (OK).\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks the functionality of the Sanic framework's blueprint routing mechanism. It specifically verifies that when a route is defined within a blueprint and the blueprint is added to the application, the application can correctly respond to requests made to that route.\n\n**Code Being Tested and How It Works**:  \nThe test creates a new `Blueprint` instance named \"Test\" with a version of 1. It defines a route (\"/\") that is associated with the provided `handler` function. The `app.blueprint(bp)` line registers the blueprint with the Sanic application. The test then simulates a GET request to the route \"/v1\" using `app.test_client.get(\"/v1\")`, and it checks that the response status is 200, indicating that the request was successfully processed.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Blueprint Registration**: The test demonstrates the use of blueprints in Sanic, which allows for modular route definitions and organization of code.\n- **Client Simulation**: It utilizes the `test_client` to simulate HTTP requests, which is a common technique in testing web applications to verify endpoint behavior without needing to run a live server.\n- **Assertion**: The test employs an assertion to validate the expected outcome (response status), which is a fundamental practice in unit testing to ensure that the code behaves as intended."
    },
    {
      "name": "test_bp_use_route",
      "module": "test_versioning",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_versioning.py",
      "line_number": 30,
      "end_line_number": 36,
      "source_code": "def test_bp_use_route(app, handler):\n    bp = Blueprint(\"Test\", version=1)\n    bp.route(\"/\", version=1.1)(handler)\n    app.blueprint(bp)\n\n    _, response = app.test_client.get(\"/v1.1\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "handler"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_bp_use_route` function is designed to verify that a route defined within a Sanic Blueprint can be accessed correctly and returns the expected HTTP status code. Specifically, it checks that a GET request to the versioned route responds with a 200 status, indicating success.\n\n**Specific Functionality or Behavior Verified**:  \nThis test confirms that the application correctly handles versioned routes within a Blueprint. It ensures that the route defined with version 1.1 responds appropriately when accessed, validating the versioning mechanism in the routing system.\n\n**Code Being Tested and How It Works**:  \nThe test creates a Blueprint named \"Test\" with a version of 1.1 and associates a handler function with the root path (\"/\"). The handler is expected to return a simple text response. The test then registers this Blueprint with the main application instance (`app`). It simulates a GET request to the versioned route \"/v1.1\" using the test client and checks that the response status is 200, indicating that the route is functioning as intended.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Blueprint Usage**: The test demonstrates the use of Blueprints in Sanic, which allows for modular route definitions and versioning.\n- **Versioning**: It tests the versioning feature of routes, ensuring that different versions of the same route can coexist and be accessed correctly.\n- **Assertion**: The test employs a straightforward assertion to validate the response status, which is a common practice in unit testing to confirm expected outcomes."
    },
    {
      "name": "test_bp_group",
      "module": "test_versioning",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_versioning.py",
      "line_number": 39,
      "end_line_number": 46,
      "source_code": "def test_bp_group(app, handler):\n    bp = Blueprint(\"Test\")\n    bp.route(\"/\")(handler)\n    group = Blueprint.group(bp, version=1)\n    app.blueprint(group)\n\n    _, response = app.test_client.get(\"/v1\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "handler"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_bp_group` function is designed to verify that a Sanic application correctly handles routing for a blueprint that is grouped with a versioning scheme. It ensures that the application can respond to a request made to a specific versioned endpoint.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a GET request is made to the endpoint `/v1`, the application returns a successful HTTP status code of 200. This indicates that the routing and handling of the request through the blueprint group is functioning as expected.\n\n**Code Being Tested and How It Works**:  \nThe test creates a new `Blueprint` instance named \"Test\" and associates a route with it that points to the `handler` function. The `Blueprint.group` method is then used to create a versioned group of blueprints, which is added to the main application instance (`app`). The `app.test_client.get(\"/v1\")` call simulates a GET request to the `/v1` endpoint, and the response is checked to ensure it has a status of 200, confirming that the request was processed successfully.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Blueprints and Versioning**: The test utilizes Sanic's blueprint feature to organize routes and apply versioning, which is a common pattern in RESTful API design.\n- **Test Client**: The use of `app.test_client.get` allows for simulating HTTP requests to the application, enabling the verification of response statuses and behaviors without needing to run a live server.\n- **Assertion**: The test employs a simple assertion to validate the response status, which is a fundamental practice in unit testing to confirm expected outcomes."
    },
    {
      "name": "test_bp_group_use_bp",
      "module": "test_versioning",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_versioning.py",
      "line_number": 49,
      "end_line_number": 56,
      "source_code": "def test_bp_group_use_bp(app, handler):\n    bp = Blueprint(\"Test\", version=1.1)\n    bp.route(\"/\")(handler)\n    group = Blueprint.group(bp, version=1)\n    app.blueprint(group)\n\n    _, response = app.test_client.get(\"/v1.1\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "handler"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_bp_group_use_bp` is designed to verify that a Sanic application can correctly register and respond to routes defined within a blueprint that is grouped with a specific versioning scheme. It ensures that the application can handle requests to a versioned endpoint and return the expected response.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a request is made to the endpoint `/v1.1`, the application responds with a status code of 200, indicating a successful request. It confirms that the route defined in the blueprint is accessible and functioning as intended.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the Sanic framework's ability to handle blueprints and versioning. The test creates a blueprint `bp` with a version of 1.1 and associates a handler function with the route `/`. It then groups this blueprint under a new version (1) and registers it with the application. The line `app.test_client.get(\"/v1.1\")` simulates an HTTP GET request to the versioned endpoint, and the assertion checks that the response status is 200.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of blueprints, a common pattern in web frameworks for organizing routes and handlers. It also utilizes the Sanic test client to simulate HTTP requests, allowing for straightforward verification of the application's behavior without needing to run a live server. The use of assertions to validate the response status is a standard practice in unit testing to ensure that the application behaves as expected."
    },
    {
      "name": "test_bp_group_use_registration",
      "module": "test_versioning",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_versioning.py",
      "line_number": 59,
      "end_line_number": 66,
      "source_code": "def test_bp_group_use_registration(app, handler):\n    bp = Blueprint(\"Test\", version=1.1)\n    bp.route(\"/\")(handler)\n    group = Blueprint.group(bp, version=1)\n    app.blueprint(group, version=1.2)\n\n    _, response = app.test_client.get(\"/v1.2\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "handler"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_bp_group_use_registration` aims to verify that a Sanic application correctly registers and responds to a route defined within a versioned blueprint group. It ensures that the application can handle requests to the specified versioned endpoint and returns the expected HTTP status.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a GET request is made to the endpoint `/v1.2`, the application responds with a status code of 200, indicating a successful request. This confirms that the route has been properly registered and is accessible.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the Sanic application and its routing mechanism. The test creates a blueprint (`bp`) with a version of 1.1 and registers a handler for the root route (`/`). It then groups this blueprint under a new version (1) and registers it with the application under a different version (1.2). The `app.test_client.get(\"/v1.2\")` call simulates a GET request to the versioned endpoint, and the assertion checks if the response status is 200.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of blueprints to organize routes and versioning, which is a common pattern in web frameworks to manage different versions of APIs. It also utilizes the Sanic test client to simulate HTTP requests, allowing for straightforward verification of the application's behavior without needing to run a live server. The use of assertions to validate the response status is a standard practice in unit testing to ensure that the expected outcomes are met."
    },
    {
      "name": "test_bp_group_use_route",
      "module": "test_versioning",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_versioning.py",
      "line_number": 69,
      "end_line_number": 76,
      "source_code": "def test_bp_group_use_route(app, handler):\n    bp = Blueprint(\"Test\", version=1.1)\n    bp.route(\"/\", version=1.3)(handler)\n    group = Blueprint.group(bp, version=1)\n    app.blueprint(group, version=1.2)\n\n    _, response = app.test_client.get(\"/v1.3\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "handler"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_bp_group_use_route` test verifies that a route defined within a Sanic Blueprint can be accessed correctly when the Blueprint is grouped and registered with the application. It specifically checks that the correct versioning of the route is respected and that the expected HTTP status code is returned.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a route is defined with a specific version (1.3 in this case) and the Blueprint is grouped with a different version (1), the application can still correctly route requests to the intended handler. It checks that a GET request to the versioned route returns a 200 OK status, indicating successful handling of the request.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the Sanic application and its routing mechanism. The `app.test_client.get(\"/v1.3\")` line simulates a GET request to the route defined in the Blueprint. The handler function, which returns a simple text response, is associated with the route. The test checks that the response status is 200, confirming that the route is correctly set up and accessible.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of a test client to simulate HTTP requests, which is a common pattern in testing web applications. It also utilizes assertions to validate the expected outcomes, specifically checking the response status. The use of versioning in the route definitions demonstrates a pattern of managing API versions, which is crucial for maintaining backward compatibility in web services. Additionally, the test leverages the Sanic Blueprint feature to organize routes, showcasing modular design in the application structure."
    },
    {
      "name": "test_version_prefix_route",
      "module": "test_versioning",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_versioning.py",
      "line_number": 79,
      "end_line_number": 83,
      "source_code": "def test_version_prefix_route(app, handler):\n    app.route(\"/\", version=1, version_prefix=\"/api/v\")(handler)\n\n    _, response = app.test_client.get(\"/api/v1\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "handler"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_version_prefix_route` unit test is designed to verify that the Sanic application correctly handles versioned routes with a specified version prefix. Specifically, it checks that a GET request to the route `/api/v1` returns a successful HTTP status code (200).\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the application can route requests to the correct handler based on the versioning scheme defined in the route. It confirms that the application recognizes the version prefix `/api/v` and correctly maps it to the intended handler for version 1 of the API.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a route in the Sanic application using `app.route` with a version of 1 and a version prefix of `/api/v`. The handler function is defined to return a simple text response. The test then simulates a GET request to the URL `/api/v1` using `app.test_client.get`. The expected outcome is that the response status is 200, indicating that the request was successfully processed.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Route Registration**: The test demonstrates the use of dynamic route registration with versioning, which is a common pattern in RESTful API design.\n- **Client Simulation**: It utilizes the test client provided by Sanic to simulate HTTP requests, allowing for straightforward testing of route behavior without needing to run a live server.\n- **Assertion**: The test employs a simple assertion to verify the response status, which is a fundamental practice in unit testing to confirm expected outcomes."
    },
    {
      "name": "test_version_prefix_bp",
      "module": "test_versioning",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_versioning.py",
      "line_number": 86,
      "end_line_number": 92,
      "source_code": "def test_version_prefix_bp(app, handler):\n    bp = Blueprint(\"Test\", version=1, version_prefix=\"/api/v\")\n    bp.route(\"/\")(handler)\n    app.blueprint(bp)\n\n    _, response = app.test_client.get(\"/api/v1\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "handler"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_version_prefix_bp` test is designed to verify that a Sanic application correctly handles versioned routes using a blueprint. Specifically, it checks that a GET request to the versioned endpoint `/api/v1` returns a successful HTTP status code (200).\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the application can register a blueprint with a version prefix and that the route defined within that blueprint is accessible and responds as expected. It confirms that the versioning mechanism works correctly by testing the endpoint associated with the specified version.\n\n**Code Being Tested and How It Works**:  \nThe test creates a blueprint named \"Test\" with a version of 1 and a version prefix of `/api/v`. It defines a route that maps to a handler function. The handler is expected to return a simple text response. The test then makes a GET request to the endpoint `/api/v1`, which should trigger the handler and return a response. The assertion checks that the response status is 200, indicating success.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Blueprint Usage**: The test demonstrates the use of blueprints in Sanic, which allows for modular route management and versioning.\n- **HTTP Client Testing**: It utilizes the `app.test_client.get` method to simulate an HTTP GET request, allowing for testing of the application's response to client requests.\n- **Assertion**: The test employs a straightforward assertion to validate the response status, which is a common practice in unit testing to ensure expected outcomes."
    },
    {
      "name": "test_version_prefix_bp_use_route",
      "module": "test_versioning",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_versioning.py",
      "line_number": 95,
      "end_line_number": 101,
      "source_code": "def test_version_prefix_bp_use_route(app, handler):\n    bp = Blueprint(\"Test\", version=1, version_prefix=\"/ignore/v\")\n    bp.route(\"/\", version=1.1, version_prefix=\"/api/v\")(handler)\n    app.blueprint(bp)\n\n    _, response = app.test_client.get(\"/api/v1.1\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "handler"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_version_prefix_bp_use_route` is designed to verify that a specific route defined in a Sanic blueprint can be accessed correctly when using versioning and a version prefix. It ensures that the application correctly handles versioned routes and responds with the expected status code.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a GET request is made to the route `/api/v1.1`, the application returns a 200 status code, indicating a successful response. It confirms that the route is properly registered and accessible under the specified versioning scheme.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the Sanic application and its routing mechanism. A blueprint is created with a version and a version prefix. A route is then defined within this blueprint that responds to GET requests at the path `/api/v1.1`. The test client of the app is used to simulate a GET request to this route, and the response status is asserted to be 200. The relevant code for the route handler is a simple function that returns a text response.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of blueprints to organize routes and manage versioning, which is a common pattern in web frameworks to modularize code. It also utilizes the test client provided by Sanic to simulate HTTP requests, allowing for integration-style testing of the routing logic. The assertion checks the response status, which is a standard practice in unit tests to validate expected outcomes."
    },
    {
      "name": "test_version_prefix_bp_group",
      "module": "test_versioning",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_versioning.py",
      "line_number": 104,
      "end_line_number": 111,
      "source_code": "def test_version_prefix_bp_group(app, handler):\n    bp = Blueprint(\"Test\")\n    bp.route(\"/\")(handler)\n    group = Blueprint.group(bp, version=1, version_prefix=\"/api/v\")\n    app.blueprint(group)\n\n    _, response = app.test_client.get(\"/api/v1\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "handler"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_version_prefix_bp_group` unit test is designed to verify that a Sanic application correctly handles versioned routes defined within a blueprint. Specifically, it checks that a request to a versioned endpoint returns the expected HTTP status code.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a GET request is made to the `/api/v1` endpoint, the application responds with a status code of 200, indicating a successful request. This confirms that the routing and versioning logic for the blueprint is functioning as intended.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a blueprint (`bp`) and registers a route that maps to a handler function. The `Blueprint.group` method is then used to create a versioned group of blueprints, which is added to the main application. The `app.test_client.get` method simulates a GET request to the `/api/v1` endpoint. The handler function, when invoked, returns a simple text response, which is expected to be served correctly at the specified route.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Blueprints**: The test utilizes Sanic's blueprint feature to organize routes and group them by version, which is a common pattern in web applications for managing API versions.\n- **Test Client**: The use of `app.test_client` allows for simulating HTTP requests to the application, enabling the test to verify the behavior of the application as if it were receiving real requests.\n- **Assertions**: The test employs assertions to validate the response status, ensuring that the application behaves as expected under the defined conditions."
    },
    {
      "name": "test_version_prefix_bp_group_use_bp",
      "module": "test_versioning",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_versioning.py",
      "line_number": 114,
      "end_line_number": 121,
      "source_code": "def test_version_prefix_bp_group_use_bp(app, handler):\n    bp = Blueprint(\"Test\", version=1.1, version_prefix=\"/api/v\")\n    bp.route(\"/\")(handler)\n    group = Blueprint.group(bp, version=1, version_prefix=\"/ignore/v\")\n    app.blueprint(group)\n\n    _, response = app.test_client.get(\"/api/v1.1\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "handler"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_version_prefix_bp_group_use_bp` is designed to verify that a Sanic application correctly handles versioned routes when using blueprints. Specifically, it checks that a request to a specific versioned endpoint returns a successful response.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a blueprint with a specified version (1.1) is registered under a versioned prefix (\"/api/v\"), the application can successfully respond to a GET request made to that versioned endpoint (\"/api/v1.1\") with a status code of 200.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the Sanic framework's ability to manage blueprints and their versioning. The test creates a blueprint (`bp`) with a version of 1.1 and associates a handler function to the root route. It then groups this blueprint under another blueprint with a different version prefix (\"/ignore/v\"). The application (`app`) is then instructed to use this grouped blueprint. The test client simulates a GET request to the endpoint \"/api/v1.1\", and the expected behavior is that the response status should be 200, indicating a successful request.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of blueprints to modularize route definitions, which is a common pattern in web frameworks to organize code. It also utilizes the Sanic test client to simulate HTTP requests, allowing for straightforward verification of the application's behavior without needing to run a full server. The assertion checks the response status, which is a standard practice in unit testing to confirm that the application behaves as expected under specific conditions."
    },
    {
      "name": "test_version_prefix_bp_group_use_registration",
      "module": "test_versioning",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_versioning.py",
      "line_number": 124,
      "end_line_number": 131,
      "source_code": "def test_version_prefix_bp_group_use_registration(app, handler):\n    bp = Blueprint(\"Test\", version=1.1, version_prefix=\"/alsoignore/v\")\n    bp.route(\"/\")(handler)\n    group = Blueprint.group(bp, version=1, version_prefix=\"/ignore/v\")\n    app.blueprint(group, version=1.2, version_prefix=\"/api/v\")\n\n    _, response = app.test_client.get(\"/api/v1.2\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "handler"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_version_prefix_bp_group_use_registration` aims to verify that the Sanic application correctly handles versioned blueprints and their routes. Specifically, it checks that a request to a specific versioned endpoint returns a successful HTTP status code (200).\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the application can register blueprints with versioning and that the routing works as expected when accessing a versioned endpoint. It confirms that the correct handler is invoked for the specified version and that the response is as intended.\n\n**Code Being Tested and How It Works**:  \nThe test creates a blueprint (`bp`) with a version of 1.1 and a version prefix of `/alsoignore/v`. It registers a route that uses a provided handler. Then, it groups this blueprint under a new version (1) with a different prefix (`/ignore/v`) and registers it in the application with a version of 1.2 and a prefix of `/api/v`. The test then makes a GET request to the endpoint `/api/v1.2`, expecting a response with a status of 200, which indicates that the request was successfully processed.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Blueprints and Versioning**: The test utilizes the concept of blueprints in Sanic, which allows for modular route management and versioning, demonstrating how to group and register blueprints with specific versions.\n- **Client Simulation**: It employs the `app.test_client.get` method to simulate an HTTP GET request, allowing for testing of the application's routing and response handling without needing to run a live server.\n- **Assertion**: The test uses an assertion to verify the expected outcome (HTTP status 200), which is a common practice in unit testing to validate that the code behaves as intended."
    },
    {
      "name": "test_version_prefix_bp_group_use_route",
      "module": "test_versioning",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_versioning.py",
      "line_number": 134,
      "end_line_number": 141,
      "source_code": "def test_version_prefix_bp_group_use_route(app, handler):\n    bp = Blueprint(\"Test\", version=1.1, version_prefix=\"/alsoignore/v\")\n    bp.route(\"/\", version=1.3, version_prefix=\"/api/v\")(handler)\n    group = Blueprint.group(bp, version=1, version_prefix=\"/ignore/v\")\n    app.blueprint(group, version=1.2, version_prefix=\"/stillignoring/v\")\n\n    _, response = app.test_client.get(\"/api/v1.3\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "handler"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_version_prefix_bp_group_use_route` test is to verify that the Sanic application correctly handles versioned routes defined within a blueprint and that the appropriate response is returned when accessing a specific versioned endpoint.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a GET request is made to the route `/api/v1.3`, the application responds with a status code of 200, indicating a successful request. It ensures that the versioning and prefixing of routes are functioning as intended.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves creating a blueprint (`bp`) with a version and a version prefix. A route is defined on this blueprint that responds to GET requests at the path `/` with a specific version (`1.3`) and prefix (`/api/v`). The blueprint is then grouped and registered with the main application (`app`) under a different version and prefix. The test simulates a GET request to the `/api/v1.3` endpoint, which should trigger the handler associated with that route, returning a successful response.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of blueprints to organize routes and manage versioning, which is a common pattern in web frameworks to modularize code. It also utilizes the `app.test_client.get` method to simulate HTTP requests, allowing for integration-style testing of the application's routing and response behavior. The assertion checks the response status, which is a standard practice in unit tests to validate expected outcomes."
    },
    {
      "name": "test_utf8_query_string",
      "module": "test_utf8",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_utf8.py",
      "line_number": 11,
      "end_line_number": 17,
      "source_code": "def test_utf8_query_string(app):\n    @app.route(\"/\")\n    async def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/\", params=[(\"utf8\", \"\u2713\")])\n    assert request.args.get(\"utf8\") == \"\u2713\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "json.dumps",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.args.get('utf8') == '\u2713'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "request.args.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_utf8_query_string` test verifies that the Sanic application correctly handles UTF-8 encoded query string parameters. Specifically, it checks whether the application can receive and correctly interpret a query parameter containing a UTF-8 character (the checkmark \"\u2713\").\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a GET request is made to the root endpoint (\"/\") with a query parameter `utf8` set to \"\u2713\", the application correctly retrieves this parameter from the request's arguments. The assertion confirms that the value retrieved matches the expected UTF-8 character.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route handler for the root path (\"/\") that simply returns a text response \"OK\". It then simulates a GET request to this endpoint using `app.test_client.get`, passing the UTF-8 character as a query parameter. The `request.args.get(\"utf8\")` method is called to retrieve the value of the `utf8` parameter from the request, and the test asserts that this value is equal to \"\u2713\".\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of an asynchronous route handler and the Sanic testing client to simulate HTTP requests. It uses parameterized requests to test the handling of specific input (UTF-8 characters) and asserts the correctness of the output. This pattern of defining routes within the test function allows for isolated testing of specific behaviors without affecting the global application state."
    },
    {
      "name": "test_utf8_response",
      "module": "test_utf8",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_utf8.py",
      "line_number": 20,
      "end_line_number": 26,
      "source_code": "def test_utf8_response(app):\n    @app.route(\"/\")\n    async def handler(request):\n        return text(\"\u2713\")\n\n    request, response = app.test_client.get(\"/\")\n    assert response.text == \"\u2713\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "json.dumps",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == '\u2713'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_utf8_response` unit test is designed to verify that the Sanic web application correctly returns a UTF-8 encoded response when a specific route is accessed. It ensures that the application can handle and respond with UTF-8 characters properly.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a GET request is made to the root endpoint (\"/\"), the response text matches the expected UTF-8 character \"\u2713\". This confirms that the application can return UTF-8 characters in its responses.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a route handler defined within the test, which responds to GET requests at the root URL (\"/\") with the text \"\u2713\". The line `request, response = app.test_client.get(\"/\")` simulates a GET request to this route, and the assertion `assert response.text == \"\u2713\"` checks that the response's text content is exactly what is expected.\n\n**Notable Testing Patterns or Techniques Used**:  \nThis test employs the use of an asynchronous route handler, which is a common pattern in modern web frameworks like Sanic. It also utilizes the `app.test_client.get` method to simulate HTTP requests, allowing for straightforward testing of route responses. The test is structured to be simple and direct, focusing solely on the expected output of the route without additional complexity."
    },
    {
      "name": "test_utf8_post_json",
      "module": "test_utf8",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_utf8.py",
      "line_number": 39,
      "end_line_number": 52,
      "source_code": "def test_utf8_post_json(app):\n    @app.post(\"/\")\n    async def handler(request):\n        return text(\"OK\")\n\n    payload = {\"test\": \"\u2713\"}\n    headers = {\"content-type\": \"application/json\"}\n\n    request, response = app.test_client.post(\n        \"/\", data=json_dumps(payload), headers=headers\n    )\n\n    assert request.json.get(\"test\") == \"\u2713\"\n    assert response.text == \"OK\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "json.dumps",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.json.get('test') == '\u2713'",
        "assert response.text == 'OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "request.json.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_utf8_post_json` test is designed to verify that the Sanic application can correctly handle a POST request with a JSON payload containing UTF-8 characters. Specifically, it checks that the application can receive and process a JSON object with a UTF-8 character (the checkmark \"\u2713\") and return the expected response.\n\n**Specific Functionality or Behavior Verified**:  \nThis test verifies two main behaviors: \n1. The request's JSON payload is correctly parsed, and the UTF-8 character is accurately retrieved from it.\n2. The response from the server matches the expected output (\"OK\"), confirming that the handler processes the request correctly.\n\n**Code Being Tested and How It Works**:  \nThe test defines a POST route at the root (\"/\") of the application, which returns a simple text response \"OK\". It then constructs a JSON payload containing a UTF-8 character and sends it to the server using the test client. The assertions check that:\n- The parsed JSON from the request contains the expected UTF-8 character.\n- The response text from the server is \"OK\".\n\nThe relevant code being tested includes:\n- The `app.post` method, which defines the route and its handler.\n- The `app.test_client.post` method, which simulates sending a POST request to the application.\n- The `request.json.get` method, which retrieves the value from the parsed JSON payload.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Asynchronous Testing**: The test is structured to work with asynchronous code, which is common in web frameworks like Sanic. This allows for non-blocking I/O operations.\n- **Mocking and Dependency Injection**: The `app` argument is likely a fixture that provides a test instance of the Sanic application, allowing for isolated testing without affecting the actual application state.\n- **Assertions**: The use of assertions to validate both the request's parsed JSON and the response ensures that the test checks both input handling and output correctness, which is crucial for verifying the integrity of the application\u2019s behavior."
    },
    {
      "name": "test_invalid_usage_exception_handler",
      "module": "test_exceptions_handler",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions_handler.py",
      "line_number": 89,
      "end_line_number": 91,
      "source_code": "def test_invalid_usage_exception_handler(exception_handler_app: Sanic):\n    request, response = exception_handler_app.test_client.get(\"/1\")\n    assert response.status == 400",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "exception_handler_app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "typing.Callable",
        "typing.List",
        "unittest.mock.Mock",
        "pytest",
        "bs4.BeautifulSoup",
        "pytest.LogCaptureFixture",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.handlers",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.ServerError",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 400"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_handler_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_invalid_usage_exception_handler` unit test is designed to verify that the Sanic application correctly handles invalid usage scenarios by returning a `400 Bad Request` status code when a specific route is accessed.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks the behavior of the application when a request is made to the `/1` endpoint. It asserts that the response status is `400`, indicating that the application has appropriately identified the request as invalid.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `exception_handler_app.test_client.get` method, which simulates an HTTP GET request to the specified route (`/1`). The expectation is that this route is configured to trigger a `BadRequest` exception, which should result in a `400` status code being returned in the response. The `exception_handler_app` is presumably set up to handle exceptions in a way that translates certain errors into HTTP responses.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern, where the response status is directly compared to the expected value (`400`). This is a common practice in unit testing to ensure that the application behaves as intended under specific conditions. Additionally, the use of a test client (`exception_handler_app.test_client`) allows for easy simulation of HTTP requests, making it a practical approach for testing web applications."
    },
    {
      "name": "test_server_error_exception_handler",
      "module": "test_exceptions_handler",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions_handler.py",
      "line_number": 94,
      "end_line_number": 97,
      "source_code": "def test_server_error_exception_handler(exception_handler_app: Sanic):\n    request, response = exception_handler_app.test_client.get(\"/2\")\n    assert response.status == 200\n    assert response.text == \"OK\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "exception_handler_app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "typing.Callable",
        "typing.List",
        "unittest.mock.Mock",
        "pytest",
        "bs4.BeautifulSoup",
        "pytest.LogCaptureFixture",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.handlers",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.ServerError",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_handler_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_server_error_exception_handler` unit test is designed to verify that the Sanic application correctly handles a specific route (\"/2\") and returns the expected response when accessed. It ensures that the application behaves as intended under normal conditions, specifically checking for a successful HTTP response.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a GET request is made to the \"/2\" endpoint, the application responds with a status code of 200 (indicating success) and that the response body contains the text \"OK\". This confirms that the endpoint is functioning correctly and returning the expected output.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `get` method of the `exception_handler_app` instance, which is a Sanic application. The `get` method is expected to return a text response with the content \"I am get method\". However, the test asserts that the response text should be \"OK\", indicating that there may be a discrepancy between the expected and actual behavior of the application. This could suggest that the route handling or response generation logic needs to be reviewed.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern, where the response status and body are checked against expected values. It uses the Sanic testing client to simulate a GET request to the application, which is a common technique in unit testing web applications. The test is structured to be clear and concise, focusing on specific assertions that validate the behavior of the application under test."
    },
    {
      "name": "test_not_found_exception_handler",
      "module": "test_exceptions_handler",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions_handler.py",
      "line_number": 100,
      "end_line_number": 102,
      "source_code": "def test_not_found_exception_handler(exception_handler_app: Sanic):\n    request, response = exception_handler_app.test_client.get(\"/3\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "exception_handler_app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "typing.Callable",
        "typing.List",
        "unittest.mock.Mock",
        "pytest",
        "bs4.BeautifulSoup",
        "pytest.LogCaptureFixture",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.handlers",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.ServerError",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_handler_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_not_found_exception_handler` unit test is designed to verify the behavior of the Sanic application when a request is made to a non-existent route. Specifically, it checks that the application does not raise an error and instead returns a successful response (HTTP status 200) when accessing a route that is expected to be handled by a custom exception handler.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the application correctly handles requests to a route (in this case, `/3`) that does not exist, and that it does not trigger a NotFound exception. Instead, it verifies that the response status is 200, indicating that the request was processed successfully, which is contrary to the expected behavior for a non-existent route.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `exception_handler_app.test_client.get` method, which simulates an HTTP GET request to the specified route. The method is expected to return a response object that contains a status code. In this case, the `get` method is defined to return a simple text response (\"I am get method\") with a status of 200, regardless of the route requested. This behavior is likely part of a custom exception handling mechanism that overrides the default behavior of returning a 404 status for non-existent routes.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern, where the response status is directly compared to the expected value (200). It utilizes the Sanic testing client to simulate requests, which is a common technique in unit testing web applications. The test also demonstrates the use of dependency injection by accepting `exception_handler_app` as an argument, allowing for flexible testing of different application configurations. This pattern is useful for isolating tests and ensuring that they can be run independently of the actual application environment."
    },
    {
      "name": "test_text_exception__handler",
      "module": "test_exceptions_handler",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions_handler.py",
      "line_number": 105,
      "end_line_number": 108,
      "source_code": "def test_text_exception__handler(exception_handler_app: Sanic):\n    request, response = exception_handler_app.test_client.get(\"/random\")\n    assert response.status == 200\n    assert response.text == \"Done.\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "exception_handler_app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "typing.Callable",
        "typing.List",
        "unittest.mock.Mock",
        "pytest",
        "bs4.BeautifulSoup",
        "pytest.LogCaptureFixture",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.handlers",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.ServerError",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'Done.'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_handler_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_text_exception__handler` unit test is designed to verify that the `exception_handler_app` correctly handles a GET request to the `/random` endpoint, ensuring that it returns a successful response with the expected content.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the response status code is `200`, indicating a successful request, and that the response body contains the string \"Done.\". This ensures that the application behaves as expected when the endpoint is accessed.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `get` method of the `exception_handler_app`, which is expected to return a plain text response. The method is invoked through the test client with a GET request to the `/random` endpoint. The expected behavior is that the method should return a response with a status of `200` and a body of \"Done.\".\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern, using `assert` statements to validate the response's status and body. It utilizes the Sanic framework's test client to simulate HTTP requests, which is a common technique in testing web applications. The test is structured to be clear and concise, focusing on the specific outcome of the request without unnecessary complexity."
    },
    {
      "name": "test_async_exception_handler",
      "module": "test_exceptions_handler",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions_handler.py",
      "line_number": 111,
      "end_line_number": 114,
      "source_code": "def test_async_exception_handler(exception_handler_app: Sanic):\n    request, response = exception_handler_app.test_client.get(\"/7\")\n    assert response.status == 200\n    assert response.text == \"foo,bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "exception_handler_app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "typing.Callable",
        "typing.List",
        "unittest.mock.Mock",
        "pytest",
        "bs4.BeautifulSoup",
        "pytest.LogCaptureFixture",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.handlers",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.ServerError",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'foo,bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_handler_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_async_exception_handler` unit test is designed to verify that the `exception_handler_app` correctly handles a GET request to the endpoint `/7`, ensuring that the response status is 200 and the response text is \"foo,bar\". This test checks the normal operation of the application when no exceptions are raised.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically verifies that the application responds with a successful HTTP status code (200) and the expected content (\"foo,bar\") when the endpoint `/7` is accessed. This indicates that the application is functioning as intended for this specific route.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `get` method of the `exception_handler_app`'s test client, which is expected to return a response when a GET request is made to the specified endpoint. The method is expected to return a response with a status of 200 and a body containing the string \"foo,bar\". The test checks these conditions using assertions.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern, where the response's status and text are directly compared to expected values. This is a common practice in unit testing to ensure that the output of a function or method matches the expected results. Additionally, the use of a test client to simulate HTTP requests is a typical technique in testing web applications, allowing for the verification of endpoint behavior without needing to run a full server."
    },
    {
      "name": "test_html_traceback_output_in_debug_mode",
      "module": "test_exceptions_handler",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions_handler.py",
      "line_number": 117,
      "end_line_number": 129,
      "source_code": "def test_html_traceback_output_in_debug_mode(exception_handler_app: Sanic):\n    request, response = exception_handler_app.test_client.get(\"/4\", debug=True)\n    assert response.status == 500\n    soup = BeautifulSoup(response.body, \"html.parser\")\n    html = str(soup)\n\n    assert \"handler_4\" in html\n    assert \"foo = bar\" in html\n\n    summary_text = soup.select(\"h3\")[0].text\n    assert \"NameError: name 'bar' is not defined\" == summary_text\n    request_text = soup.select(\"h2\")[-1].text\n    assert \"GET /4\" == request_text",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "exception_handler_app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "typing.Callable",
        "typing.List",
        "unittest.mock.Mock",
        "pytest",
        "bs4.BeautifulSoup",
        "pytest.LogCaptureFixture",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.handlers",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.ServerError",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert 'handler_4' in html",
        "assert 'foo = bar' in html",
        "assert \"NameError: name 'bar' is not defined\" == summary_text",
        "assert 'GET /4' == request_text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_handler_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_html_traceback_output_in_debug_mode` is designed to verify that the Sanic application correctly handles exceptions in debug mode by returning an appropriate HTML response that includes detailed traceback information. This is crucial for developers to diagnose issues during development.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when a request is made to a specific endpoint (`/4`) that triggers an exception, the application responds with a 500 status code, indicating a server error. It also verifies that the HTML response contains specific error messages and details about the exception, including the type of error and the request path.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the Sanic framework's exception handling mechanism. When the endpoint `/4` is accessed, it is expected to raise a `NameError` due to a variable (`bar`) not being defined. The `exception_handler_app.test_client.get` method simulates a GET request to this endpoint with debug mode enabled. The response is then parsed using BeautifulSoup to extract and verify the presence of specific error messages and the traceback details in the HTML content.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable techniques:\n- **Assertion Checks**: It uses assertions to validate the response status and the content of the HTML response, ensuring that the expected error messages are present.\n- **HTML Parsing**: BeautifulSoup is utilized to parse the HTML response, allowing for easy extraction of specific elements (like headers) to verify the correctness of the error output.\n- **Debug Mode Testing**: The test specifically checks the behavior of the application in debug mode, which is essential for development and troubleshooting, ensuring that developers receive detailed error information when issues arise."
    },
    {
      "name": "test_inherited_exception_handler",
      "module": "test_exceptions_handler",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions_handler.py",
      "line_number": 132,
      "end_line_number": 134,
      "source_code": "def test_inherited_exception_handler(exception_handler_app: Sanic):\n    request, response = exception_handler_app.test_client.get(\"/5\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "exception_handler_app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "typing.Callable",
        "typing.List",
        "unittest.mock.Mock",
        "pytest",
        "bs4.BeautifulSoup",
        "pytest.LogCaptureFixture",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.handlers",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.ServerError",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_handler_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_inherited_exception_handler` unit test is designed to verify that the `exception_handler_app` correctly handles a GET request to the endpoint `/5`, ensuring that it returns a successful HTTP status code (200). This indicates that the application is functioning as expected when no exceptions are raised.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks the normal operation of the GET method in the `exception_handler_app`. It confirms that the application can process a request to the specified route without encountering any errors, resulting in a successful response.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `get` method of the `exception_handler_app`, which is expected to return a simple text response when accessed. The method is defined as follows:  \n```python\ndef get(self, request):\n    return text('I am get method')\n```\nWhen a GET request is made to `/5`, the application should respond with a status code of 200, indicating that the request was successful and the response body contains the expected text.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern, where the response status is checked against an expected value (200). This is a common practice in unit testing to validate that the application behaves correctly under normal conditions. The use of `assert` statements provides a clear and concise way to verify outcomes, making it easy to identify failures in the test case. Additionally, the test leverages the `test_client` provided by the Sanic framework to simulate HTTP requests, which is a typical technique in testing web applications."
    },
    {
      "name": "test_chained_exception_handler",
      "module": "test_exceptions_handler",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions_handler.py",
      "line_number": 137,
      "end_line_number": 152,
      "source_code": "def test_chained_exception_handler(exception_handler_app: Sanic):\n    request, response = exception_handler_app.test_client.get(\n        \"/6/0\", debug=True\n    )\n    assert response.status == 500\n\n    soup = BeautifulSoup(response.body, \"html.parser\")\n    html = str(soup)\n\n    assert \"handler_6\" in html\n    assert \"foo = 1 / arg\" in html\n    assert \"ValueError\" in html\n    assert \"GET /6\" in html\n\n    summary_text = soup.select(\"h3\")[0].text\n    assert \"ZeroDivisionError: division by zero\" == summary_text",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "exception_handler_app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "typing.Callable",
        "typing.List",
        "unittest.mock.Mock",
        "pytest",
        "bs4.BeautifulSoup",
        "pytest.LogCaptureFixture",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.handlers",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.ServerError",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert 'handler_6' in html",
        "assert 'foo = 1 / arg' in html",
        "assert 'ValueError' in html",
        "assert 'GET /6' in html",
        "assert 'ZeroDivisionError: division by zero' == summary_text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_handler_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_chained_exception_handler` unit test is designed to verify that the Sanic application correctly handles a specific type of error (a division by zero) and that it provides an appropriate error response, including relevant debugging information in the HTML response.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a request is made to the endpoint `/6/0`, which is expected to trigger a `ZeroDivisionError`, the application responds with a 500 Internal Server Error status. Additionally, it verifies that the response body contains specific details about the error, including the handler name, the line of code that caused the error, the type of exception raised, and the request path.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the error handling mechanism of the Sanic application, specifically how it processes exceptions that occur during request handling. The `exception_handler_app.test_client.get` method simulates a GET request to the endpoint `/6/0`. The application is expected to catch the `ZeroDivisionError`, and the error handling logic should format the response to include detailed information about the error, which is then parsed and asserted in the test.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertions**: The test uses multiple assertions to validate the response status and the content of the response body, ensuring comprehensive verification of the error handling.\n- **HTML Parsing**: The test employs BeautifulSoup to parse the HTML response, allowing for targeted assertions on specific elements within the response, which is a common technique for testing web applications.\n- **Debug Mode**: The test explicitly sets the `debug` parameter to `True`, which is significant as it may alter the error handling behavior, providing more detailed output for debugging purposes. This highlights the importance of testing different configurations of the application."
    },
    {
      "name": "test_exception_handler_lookup",
      "module": "test_exceptions_handler",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions_handler.py",
      "line_number": 155,
      "end_line_number": 200,
      "source_code": "def test_exception_handler_lookup(exception_handler_app: Sanic):\n    class CustomError(Exception):\n        pass\n\n    class CustomServerError(ServerError):\n        pass\n\n    def custom_error_handler():\n        pass\n\n    def server_error_handler():\n        pass\n\n    def import_error_handler():\n        pass\n\n    try:\n        ModuleNotFoundError  # noqa: F823\n    except Exception:\n\n        class ModuleNotFoundError(ImportError):\n            pass\n\n    handler = ErrorHandler()\n    handler.add(ImportError, import_error_handler)\n    handler.add(CustomError, custom_error_handler)\n    handler.add(ServerError, server_error_handler)\n\n    assert handler.lookup(ImportError(), None) == import_error_handler\n    assert handler.lookup(ModuleNotFoundError(), None) == import_error_handler\n    assert handler.lookup(CustomError(), None) == custom_error_handler\n    assert handler.lookup(ServerError(\"Error\"), None) == server_error_handler\n    assert (\n        handler.lookup(CustomServerError(\"Error\"), None)\n        == server_error_handler\n    )\n\n    # once again to ensure there is no caching bug\n    assert handler.lookup(ImportError(), None) == import_error_handler\n    assert handler.lookup(ModuleNotFoundError(), None) == import_error_handler\n    assert handler.lookup(CustomError(), None) == custom_error_handler\n    assert handler.lookup(ServerError(\"Error\"), None) == server_error_handler\n    assert (\n        handler.lookup(CustomServerError(\"Error\"), None)\n        == server_error_handler\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "exception_handler_app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "typing.Callable",
        "typing.List",
        "unittest.mock.Mock",
        "pytest",
        "bs4.BeautifulSoup",
        "pytest.LogCaptureFixture",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.handlers",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.ServerError",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert handler.lookup(ImportError(), None) == import_error_handler",
        "assert handler.lookup(ModuleNotFoundError(), None) == import_error_handler",
        "assert handler.lookup(CustomError(), None) == custom_error_handler",
        "assert handler.lookup(ServerError('Error'), None) == server_error_handler",
        "assert handler.lookup(CustomServerError('Error'), None) == server_error_handler",
        "assert handler.lookup(ImportError(), None) == import_error_handler",
        "assert handler.lookup(ModuleNotFoundError(), None) == import_error_handler",
        "assert handler.lookup(CustomError(), None) == custom_error_handler",
        "assert handler.lookup(ServerError('Error'), None) == server_error_handler",
        "assert handler.lookup(CustomServerError('Error'), None) == server_error_handler"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_exception_handler_lookup` test is to verify the functionality of the `ErrorHandler` class in correctly associating specific exception types with their corresponding handler functions. This ensures that when an exception is raised, the appropriate handler is invoked, facilitating proper error management in the Sanic application.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the `lookup` method of the `ErrorHandler` class returns the correct handler for various exception instances, including custom exceptions and built-in exceptions. It also verifies that the handler lookup does not cache results incorrectly by performing the lookups twice.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `ErrorHandler` class, which manages exception handling in the Sanic framework. The test defines several custom exceptions and their corresponding handlers, adds them to the `ErrorHandler` instance, and then calls the `lookup` method with different exception instances. The expected behavior is that each call to `lookup` returns the correct handler function associated with the exception type.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Assertion-Based Testing**: It uses assertions to verify that the output of the `lookup` method matches the expected handler for each exception type.\n- **Custom Exception Classes**: It defines custom exception classes to test the flexibility of the error handling mechanism.\n- **Redundant Assertions**: The test performs the same assertions twice to ensure that there are no caching issues in the handler lookup process, which is a common technique to validate state consistency in tests."
    },
    {
      "name": "test_exception_handler_processed_request_middleware",
      "module": "test_exceptions_handler",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions_handler.py",
      "line_number": 203,
      "end_line_number": 208,
      "source_code": "def test_exception_handler_processed_request_middleware(\n    exception_handler_app: Sanic,\n):\n    request, response = exception_handler_app.test_client.get(\"/8\")\n    assert response.status == 200\n    assert response.text == \"Done.\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "exception_handler_app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "typing.Callable",
        "typing.List",
        "unittest.mock.Mock",
        "pytest",
        "bs4.BeautifulSoup",
        "pytest.LogCaptureFixture",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.handlers",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.ServerError",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'Done.'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_handler_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_exception_handler_processed_request_middleware` is designed to verify that the middleware in the `exception_handler_app` correctly processes a request and returns the expected response. Specifically, it checks that the middleware is functioning as intended by ensuring that a GET request to a specific endpoint returns a successful status and the correct response body.\n\n**Specific Functionality or Behavior Verified**:  \nThis test verifies that when a GET request is made to the endpoint `/8`, the response status is `200 OK` and the response body is `\"Done.\"`. This indicates that the middleware has successfully processed the request and returned the expected output.\n\n**Code Being Tested and How It Works**:  \nThe code being tested involves the `exception_handler_app` which is a Sanic application. The method `exception_handler_app.test_client.get` simulates a GET request to the application. The expected behavior is defined in the middleware, which is expected to set the response body to `\"Done.\"` when the request is processed. The middleware is defined as follows:\n```python\n@exception_handler_app.middleware\nasync def some_request_middleware(request):\n    request.ctx.middleware_ran = \"Done.\"\n```\nHowever, the actual response body returned in the test is `\"I am get method\"` from the `get` method, which suggests that the middleware's intended behavior may not be correctly implemented or tested.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the response status and body, which is a common practice in unit testing to ensure that the output of a function or method matches expected results. Additionally, it utilizes the Sanic framework's built-in testing client to simulate HTTP requests, allowing for a straightforward way to test the application's behavior in response to various inputs. The test is structured to be clear and concise, focusing on a single aspect of the application's functionality, which is a best practice in unit testing."
    },
    {
      "name": "test_error_handler_noisy_log",
      "module": "test_exceptions_handler",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions_handler.py",
      "line_number": 211,
      "end_line_number": 225,
      "source_code": "def test_error_handler_noisy_log(\n    exception_handler_app: Sanic, monkeypatch: MonkeyPatch\n):\n    err_logger = Mock()\n    monkeypatch.setattr(handlers.error, \"error_logger\", err_logger)\n\n    exception_handler_app.config[\"NOISY_EXCEPTIONS\"] = False\n    exception_handler_app.test_client.get(\"/1\")\n    err_logger.exception.assert_not_called()\n\n    exception_handler_app.config[\"NOISY_EXCEPTIONS\"] = True\n    request, _ = exception_handler_app.test_client.get(\"/1\")\n    err_logger.exception.assert_called_with(\n        \"Exception occurred while handling uri: %s\", repr(request.url)\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "exception_handler_app",
        "monkeypatch"
      ],
      "imports": [
        "asyncio",
        "logging",
        "typing.Callable",
        "typing.List",
        "unittest.mock.Mock",
        "pytest",
        "bs4.BeautifulSoup",
        "pytest.LogCaptureFixture",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.handlers",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.ServerError",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_handler_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "exception_handler_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_error_handler_noisy_log` unit test is designed to verify the behavior of the error logging mechanism in a Sanic application when handling exceptions, specifically focusing on the configuration setting `NOISY_EXCEPTIONS`. It checks whether exceptions are logged based on the value of this configuration.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies two scenarios: \n1. When `NOISY_EXCEPTIONS` is set to `False`, it ensures that the error logger does not log any exceptions.\n2. When `NOISY_EXCEPTIONS` is set to `True`, it confirms that the error logger logs the exception with the appropriate message, including the request URL.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the Sanic application's error handling mechanism. The test uses a mock logger (`err_logger`) to intercept logging calls. It first sets the `NOISY_EXCEPTIONS` configuration to `False` and makes a GET request to the endpoint `/1`, asserting that the logger's `exception` method is not called. Then, it sets `NOISY_EXCEPTIONS` to `True`, makes the same request, and asserts that the logger's `exception` method is called with a specific message that includes the request URL.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Monkey Patching**: The test uses `monkeypatch` to replace the actual error logger with a mock object, allowing for verification of logging behavior without affecting the actual logging system.\n- **Assertions**: The test employs assertions to validate that the logger behaves as expected under different configurations, ensuring that the application\u2019s logging logic is correctly implemented.\n- **Separation of Concerns**: By testing the logging behavior separately from the actual request handling, the test adheres to the principle of separation of concerns, focusing solely on the error handling aspect."
    },
    {
      "name": "test_exception_handler_response_was_sent",
      "module": "test_exceptions_handler",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions_handler.py",
      "line_number": 228,
      "end_line_number": 266,
      "source_code": "def test_exception_handler_response_was_sent(\n    app: Sanic,\n    caplog: LogCaptureFixture,\n    message_in_records: Callable[[List[logging.LogRecord], str], bool],\n):\n    exception_handler_ran = False\n\n    @app.exception(ServerError)\n    async def exception_handler(request, exception):\n        nonlocal exception_handler_ran\n        exception_handler_ran = True\n        return text(\"Error\")\n\n    @app.route(\"/1\")\n    async def handler1(request: Request):\n        response = await request.respond()\n        await response.send(\"some text\")\n        raise ServerError(\"Exception\")\n\n    @app.route(\"/2\")\n    async def handler2(request: Request):\n        await request.respond()\n        raise ServerError(\"Exception\")\n\n    with caplog.at_level(logging.WARNING):\n        _, response = app.test_client.get(\"/1\")\n        assert \"some text\" in response.text\n\n    message_in_records(\n        caplog.records,\n        (\n            \"An error occurred while handling the request after at \"\n            \"least some part of the response was sent to the client. \"\n            \"Therefore, the response from your custom exception \"\n        ),\n    )\n\n    _, response = app.test_client.get(\"/2\")\n    assert \"Error\" in response.text",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "caplog",
        "message_in_records"
      ],
      "imports": [
        "asyncio",
        "logging",
        "typing.Callable",
        "typing.List",
        "unittest.mock.Mock",
        "pytest",
        "bs4.BeautifulSoup",
        "pytest.LogCaptureFixture",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.handlers",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.ServerError",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'Error' in response.text",
        "assert 'some text' in response.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.exception",
          "body": "@app.route('/')\ndef exception(request):\n    raise SanicExceptionTestException(\"You won't see me\")"
        },
        {
          "name": "message_in_records",
          "body": "@pytest.fixture(scope='function')\ndef message_in_records():\n\n    def msg_in_log(records: List[LogRecord], msg: str):\n        error_captured = False\n        for record in records:\n            if msg in record.message:\n                error_captured = True\n                break\n        return error_captured\n    return msg_in_log"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_exception_handler_response_was_sent` test is to verify that the Sanic framework correctly handles exceptions raised after a partial response has been sent to the client. It ensures that the custom exception handler is invoked and that the appropriate response is returned to the client, even when an error occurs after some data has already been sent.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks two scenarios: \n1. When a `ServerError` is raised after sending part of a response (in the `/1` route), it verifies that the initial part of the response (\"some text\") is still sent to the client.\n2. It also checks that when a `ServerError` is raised without any prior response being sent (in the `/2` route), the custom error message (\"Error\") is returned to the client.\n\n**Code Being Tested and How It Works**:  \nThe test defines two routes (`/1` and `/2`) within a Sanic application. The `/1` route sends a partial response before raising a `ServerError`, while the `/2` route raises the error immediately after responding. The test uses the `caplog` fixture to capture log messages at the WARNING level, ensuring that the appropriate warning message is logged when an error occurs after a response has been partially sent. The `message_in_records` function checks if specific log messages are present in the captured logs.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The test utilizes fixtures like `caplog` for capturing log output and `message_in_records` for verifying log messages, which promotes modular and reusable test code.\n- **Nonlocal Variable**: The use of a `nonlocal` variable (`exception_handler_ran`) allows the test to track whether the custom exception handler was executed, demonstrating a technique for maintaining state across nested functions.\n- **Asynchronous Testing**: The test leverages asynchronous route handlers and the Sanic test client to simulate HTTP requests, showcasing the ability to test asynchronous code effectively.\n- **Assertions**: The test employs assertions to validate both the content of the responses and the presence of specific log messages, ensuring comprehensive verification of the expected behavior."
    },
    {
      "name": "test_errir_on_duplicate",
      "module": "test_exceptions_handler",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions_handler.py",
      "line_number": 269,
      "end_line_number": 280,
      "source_code": "def test_errir_on_duplicate(app: Sanic):\n    @app.exception(ServerError)\n    async def exception_handler_1(request, exception): ...\n\n    message = (\n        \"Duplicate exception handler definition on: route=__ALL_ROUTES__ and \"\n        \"exception=<class 'sanic.exceptions.ServerError'>\"\n    )\n    with pytest.raises(ServerError, match=message):\n\n        @app.exception(ServerError)\n        async def exception_handler_2(request, exception): ...",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "typing.Callable",
        "typing.List",
        "unittest.mock.Mock",
        "pytest",
        "bs4.BeautifulSoup",
        "pytest.LogCaptureFixture",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.handlers",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.ServerError",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.exception",
          "body": "@app.route('/')\ndef exception(request):\n    raise SanicExceptionTestException(\"You won't see me\")"
        },
        {
          "name": "app.exception",
          "body": "@app.route('/')\ndef exception(request):\n    raise SanicExceptionTestException(\"You won't see me\")"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_errir_on_duplicate` test is designed to verify that the Sanic application correctly raises a `ServerError` when an attempt is made to register multiple exception handlers for the same exception type (`ServerError`) within the same application context. This ensures that the framework enforces uniqueness in exception handler definitions, preventing potential conflicts or ambiguities in error handling.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that when a second exception handler for `ServerError` is defined after the first one, the application raises a `ServerError` with a specific error message indicating that a duplicate handler definition has occurred. This behavior is crucial for maintaining the integrity of the application's error handling mechanism.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `app.exception` decorator, which is used to register exception handlers in the Sanic framework. In the test, the first handler (`exception_handler_1`) is registered without issue. However, when the second handler (`exception_handler_2`) is defined, the test expects the application to raise a `ServerError` with a predefined message. The message indicates the route and the exception type that caused the conflict, which is checked using `pytest.raises` with the `match` argument to ensure the error message matches the expected output.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that an exception is raised during the execution of the code block where the second exception handler is defined. This is a common pattern in unit testing to verify that specific error conditions are met. Additionally, the use of a specific error message in the assertion helps ensure that not only is an error raised, but it is the correct error with the expected details, enhancing the robustness of the test."
    },
    {
      "name": "test_annotated_handlers",
      "module": "test_handler_annotations",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_handler_annotations.py",
      "line_number": 17,
      "end_line_number": 39,
      "source_code": "def test_annotated_handlers(app, idx, path, expectation):\n    def build_response(num, foo):\n        return json({\"num\": num, \"type\": type(foo).__name__})\n\n    @app.get(\"/<foo>\")\n    def handler0(_, foo: str):\n        return build_response(0, foo)\n\n    @app.get(\"/<foo>\")\n    def handler1(_, foo: int):\n        return build_response(1, foo)\n\n    @app.get(\"/<foo>\")\n    def handler2(_, foo: float):\n        return build_response(2, foo)\n\n    @app.get(\"/<foo>\")\n    def handler3(_, foo: UUID):\n        return build_response(3, foo)\n\n    _, response = app.test_client.get(path)\n    assert response.json[\"num\"] == idx\n    assert response.json[\"type\"] == expectation",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('idx,path,expectation', ((0, '/abc', 'str'), (1, '/123', 'int'), (2, '/123.5', 'float'), (3, '/8af729fe-2b94-4a95-a168-c07068568429', 'UUID')))"
      ],
      "arguments": [
        "app",
        "idx",
        "path",
        "expectation"
      ],
      "imports": [
        "uuid.UUID",
        "pytest",
        "sanic.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json['num'] == idx",
        "assert response.json['type'] == expectation"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "build_response",
          "body": "def build_response(num, foo):\n    return json({'num': num, 'type': type(foo).__name__})"
        },
        {
          "name": "build_response",
          "body": "def build_response(num, foo):\n    return json({'num': num, 'type': type(foo).__name__})"
        },
        {
          "name": "build_response",
          "body": "def build_response(num, foo):\n    return json({'num': num, 'type': type(foo).__name__})"
        },
        {
          "name": "build_response",
          "body": "def build_response(num, foo):\n    return json({'num': num, 'type': type(foo).__name__})"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_annotated_handlers` function is designed to verify that the Sanic web framework correctly handles route parameter type annotations. It checks whether the framework can correctly infer and respond with the expected data type based on the input provided in the URL.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies that when a request is made to a specific path with a parameter, the response correctly indicates the type of the parameter (e.g., string, integer, float, UUID) and the corresponding index of the handler that processed the request. This ensures that the routing and type handling mechanisms of the Sanic application are functioning as intended.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes multiple route handlers defined with the same path but different type annotations for the `foo` parameter. Each handler calls the `build_response` function, which constructs a JSON response containing the index of the handler and the type of the parameter. The test uses the `app.test_client.get(path)` method to simulate a GET request to the specified path, and then it asserts that the response's JSON matches the expected index and type.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses `pytest.mark.parametrize` to run the same test logic with different sets of input values (index, path, and expected type). This allows for efficient testing of multiple scenarios without duplicating code.\n- **Anonymous Functions**: The `build_response` function is defined within the test, encapsulating the response-building logic and keeping it local to the test context.\n- **Assertions**: The test employs assertions to validate the correctness of the response, ensuring that both the numerical index and the type of the parameter are as expected. This is a common practice in unit testing to confirm that the code behaves as intended."
    },
    {
      "name": "test_no_sugar",
      "module": "test_coffee",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_coffee.py",
      "line_number": 19,
      "end_line_number": 24,
      "source_code": "def test_no_sugar(sugar):\n    if sugar:\n        with pytest.raises(SanicException):\n            assert has_sugar(sugar)\n    else:\n        assert not has_sugar(sugar)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('sugar', (True, False))"
      ],
      "arguments": [
        "sugar"
      ],
      "imports": [
        "logging",
        "unittest.mock.patch",
        "pytest",
        "sanic.application.logo.COFFEE_LOGO",
        "sanic.application.logo.get_logo",
        "sanic.exceptions.SanicException"
      ],
      "fixtures": [],
      "assertions": [
        "assert not has_sugar(sugar)",
        "assert has_sugar(sugar)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "has_sugar",
          "body": "def has_sugar(value):\n    if value:\n        raise SanicException('I said no sugar please')\n    return False"
        },
        {
          "name": "has_sugar",
          "body": "def has_sugar(value):\n    if value:\n        raise SanicException('I said no sugar please')\n    return False"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_no_sugar` function is designed to verify the behavior of the `has_sugar` function when provided with different inputs (specifically, whether the input contains sugar or not). It ensures that the function raises an exception when sugar is present and confirms that it returns `False` when sugar is absent.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two scenarios based on the `sugar` input:\n1. If `sugar` is truthy (indicating the presence of sugar), it asserts that calling `has_sugar(sugar)` raises a `SanicException`.\n2. If `sugar` is falsy (indicating the absence of sugar), it asserts that `has_sugar(sugar)` returns `False`.\n\n**Code Being Tested and How It Works**:  \nThe `has_sugar` function takes a single argument, `value`. If `value` is truthy (i.e., not `None`, `False`, or an empty value), it raises a `SanicException` with a specific message. If `value` is falsy, it simply returns `False`. This logic is critical for the test, as it directly correlates to the assertions made in `test_no_sugar`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterized Testing**: The test utilizes a parameter (`sugar`) to run through different scenarios, allowing for flexible input testing without duplicating code.\n- **Exception Testing**: The use of `pytest.raises` is a common pattern to assert that specific exceptions are raised under certain conditions, ensuring that error handling in the code is functioning as expected.\n- **Logical Assertions**: The test employs straightforward assertions to validate the expected outcomes, making it easy to understand the intent and results of the test."
    },
    {
      "name": "test_get_logo_returns_expected_logo",
      "module": "test_coffee",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_coffee.py",
      "line_number": 27,
      "end_line_number": 31,
      "source_code": "def test_get_logo_returns_expected_logo():\n    with patch(\"sys.stdout.isatty\") as isatty:\n        isatty.return_value = True\n        logo = get_logo(coffee=True)\n    assert logo is COFFEE_LOGO",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "unittest.mock.patch",
        "pytest",
        "sanic.application.logo.COFFEE_LOGO",
        "sanic.application.logo.get_logo",
        "sanic.exceptions.SanicException"
      ],
      "fixtures": [],
      "assertions": [
        "assert logo is COFFEE_LOGO"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_get_logo_returns_expected_logo` test is to verify that the `get_logo` function returns the correct logo string when the `coffee` argument is set to `True`. This ensures that the function behaves as expected under this specific condition.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that the output of the `get_logo` function matches the predefined constant `COFFEE_LOGO`. It ensures that when the terminal is capable of displaying the logo (indicated by `sys.stdout.isatty()` returning `True`), the correct logo is returned.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `get_logo` function, which returns different logo strings based on the input parameters and the terminal's capabilities. When `coffee=True`, the function should return `COFFEE_LOGO` if the terminal supports it. The test uses the `patch` function from the `unittest.mock` module to mock the behavior of `sys.stdout.isatty`, simulating a terminal that supports color output.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the mocking technique using `patch` to control the environment in which the `get_logo` function operates. By mocking `sys.stdout.isatty`, the test isolates the function's behavior from the actual terminal state, allowing for a controlled test scenario. Additionally, the use of assertions (`assert logo is COFFEE_LOGO`) checks for identity rather than equality, which is a more stringent check ensuring that the returned object is the exact same instance as `COFFEE_LOGO`."
    },
    {
      "name": "test_logo_true",
      "module": "test_coffee",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_coffee.py",
      "line_number": 34,
      "end_line_number": 48,
      "source_code": "def test_logo_true(app, caplog):\n    @app.after_server_start\n    async def shutdown(*_):\n        app.stop()\n\n    with patch(\"sys.stdout.isatty\") as isatty:\n        isatty.return_value = True\n        with caplog.at_level(logging.DEBUG):\n            app.make_coffee(single_process=True)\n\n    # Only in the regular logo\n    assert \"    \u2584\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2588\u2588    \" not in caplog.text\n\n    # Only in the coffee logo\n    assert \"    \u2588\u2588       \u2588\u2588\u2580\u2580\u2584   \" in caplog.text",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "caplog"
      ],
      "imports": [
        "logging",
        "unittest.mock.patch",
        "pytest",
        "sanic.application.logo.COFFEE_LOGO",
        "sanic.application.logo.get_logo",
        "sanic.exceptions.SanicException"
      ],
      "fixtures": [],
      "assertions": [
        "assert '    \u2584\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2588\u2588    ' not in caplog.text",
        "assert '    \u2588\u2588       \u2588\u2588\u2580\u2580\u2584   ' in caplog.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        },
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_logo_true` unit test is designed to verify that the correct logo is displayed when the `app.make_coffee` method is called in a Sanic application. Specifically, it checks that the coffee logo is used instead of the regular logo when the application is configured to make coffee.\n\n**Specific Functionality or Behavior Verified**:  \nThe test asserts that the output log does not contain the regular logo string and does contain the coffee logo string. This ensures that the application behaves as expected when the `make_coffee` method is invoked, confirming that the correct logo is rendered based on the application's state.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `app.make_coffee(single_process=True)` method, which is expected to generate log output that includes the coffee logo when the application is running in a single process mode. The test uses the `caplog` fixture to capture log messages at the DEBUG level, allowing it to inspect the output for specific strings that represent the logos.\n\n**Notable Testing Patterns or Techniques Used**:  \n1. **Mocking**: The test uses `unittest.mock.patch` to mock `sys.stdout.isatty`, simulating a terminal environment that supports colored output. This is crucial for testing the logo rendering logic without relying on the actual terminal capabilities.\n2. **Log Capture**: The `caplog` fixture from pytest is employed to capture log messages generated during the test execution, enabling assertions on the log content.\n3. **Asynchronous Testing**: The test defines an asynchronous shutdown function to ensure that the application stops after the server starts, demonstrating the handling of asynchronous operations in the test setup."
    },
    {
      "name": "test_custom_request",
      "module": "test_custom_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_custom_request.py",
      "line_number": 19,
      "end_line_number": 46,
      "source_code": "def test_custom_request():\n    app = Sanic(name=\"Test\", request_class=CustomRequest)\n\n    @app.route(\"/post\", methods=[\"POST\"])\n    async def post_handler(request):\n        return text(\"OK\")\n\n    @app.route(\"/get\")\n    async def get_handler(request):\n        return text(\"OK\")\n\n    payload = {\"test\": \"OK\"}\n    headers = {\"content-type\": \"application/json\"}\n\n    request, response = app.test_client.post(\n        \"/post\", data=json_dumps(payload), headers=headers\n    )\n\n    assert request.body == b'{\"TEST\":\"OK\"}'\n    assert request.json.get(\"TEST\") == \"OK\"\n    assert response.text == \"OK\"\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/get\")\n\n    assert request.body == b\"\"\n    assert response.text == \"OK\"\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "io.BytesIO",
        "sanic.Sanic",
        "sanic.request.Request",
        "sanic.response.json_dumps",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.body == b'{\"TEST\":\"OK\"}'",
        "assert request.json.get('TEST') == 'OK'",
        "assert response.text == 'OK'",
        "assert response.status == 200",
        "assert request.body == b''",
        "assert response.text == 'OK'",
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "request.json.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_custom_request` function is designed to verify the behavior of a custom request class (`CustomRequest`) in a Sanic web application. It ensures that the request body is processed correctly, specifically that the body is transformed to uppercase, and that the application responds appropriately to both POST and GET requests.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. The request body is correctly modified to uppercase when a JSON payload is sent in a POST request.\n2. The application returns the expected response text (\"OK\") and status code (200) for both POST and GET requests.\n3. The request body for the GET request is empty, confirming that no body is sent with GET requests.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Sanic application with a custom request class that overrides the `receive_body` method. This method reads the incoming request body, converts it to uppercase, and assigns it to `self.body`. The test then sends a POST request with a JSON payload and checks:\n- If the modified request body matches the expected uppercase format.\n- If the JSON parsing retrieves the correct value.\n- If the response text and status are as expected.\n\nFor the GET request, it verifies that the request body is empty and that the response is correct.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test leverages Sanic's asynchronous capabilities, allowing for non-blocking request handling.\n- **Client Simulation**: It uses `app.test_client` to simulate HTTP requests to the application, which is a common pattern in testing web applications.\n- **Assertions**: The test employs assertions to validate the expected outcomes, ensuring that the application behaves as intended under the specified conditions."
    },
    {
      "name": "test_redirect_default_302",
      "module": "test_redirect",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_redirect.py",
      "line_number": 41,
      "end_line_number": 51,
      "source_code": "def test_redirect_default_302(redirect_app):\n    \"\"\"\n    We expect a 302 default status code and the headers to be set.\n    \"\"\"\n    request, response = redirect_app.test_client.get(\n        \"/redirect_init\", allow_redirects=False\n    )\n\n    assert response.status == 302\n    assert response.headers[\"Location\"] == \"/redirect_target\"\n    assert response.headers[\"Content-Type\"] == \"text/html; charset=utf-8\"",
      "docstring": "We expect a 302 default status code and the headers to be set.",
      "decorators": [],
      "arguments": [
        "redirect_app"
      ],
      "imports": [
        "urllib.parse.quote",
        "pytest",
        "sanic.response.redirect",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 302",
        "assert response.headers['Location'] == '/redirect_target'",
        "assert response.headers['Content-Type'] == 'text/html; charset=utf-8'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "redirect_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_redirect_default_302` unit test is designed to verify that the application correctly performs an HTTP redirect with a default status code of 302. It ensures that the appropriate headers are set in the response, specifically the `Location` header indicating where the redirect points.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a GET request is made to the `/redirect_init` endpoint, the response status is 302, and the `Location` header is set to `/redirect_target`. Additionally, it verifies that the `Content-Type` header is correctly set to `text/html; charset=utf-8`, confirming that the response is formatted as expected.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `redirect_app.test_client.get` method, which simulates a client making a GET request to the specified endpoint. The method is expected to return a response that includes a status code and headers. The `redirect` function in the codebase is responsible for generating the redirect response, setting the status code and headers accordingly. The test checks the output of this function by asserting the values of the response's status and headers.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the expected outcomes, which is a common practice in unit testing. It also utilizes the `allow_redirects=False` parameter in the GET request to ensure that the test captures the initial redirect response rather than following it. This approach isolates the test to focus solely on the redirect behavior without side effects from subsequent requests. Additionally, the use of descriptive docstrings enhances the readability and maintainability of the test by clearly stating its intent."
    },
    {
      "name": "test_redirect_headers_none",
      "module": "test_redirect",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_redirect.py",
      "line_number": 54,
      "end_line_number": 60,
      "source_code": "def test_redirect_headers_none(redirect_app):\n    request, response = redirect_app.test_client.get(\n        uri=\"/redirect_init\", headers=None, allow_redirects=False\n    )\n\n    assert response.status == 302\n    assert response.headers[\"Location\"] == \"/redirect_target\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "redirect_app"
      ],
      "imports": [
        "urllib.parse.quote",
        "pytest",
        "sanic.response.redirect",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 302",
        "assert response.headers['Location'] == '/redirect_target'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "redirect_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_redirect_headers_none` test is designed to verify the behavior of the redirect functionality in the Sanic web framework when no headers are provided in the request. Specifically, it checks that a redirect response is correctly generated with the expected status code and location.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a GET request is made to the `/redirect_init` endpoint with `allow_redirects` set to `False`, the server responds with a 302 status code and a `Location` header pointing to the `/redirect_target` URL. This confirms that the redirect logic is functioning as intended even when no headers are specified.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `redirect_app.test_client.get` method, which simulates an HTTP GET request to the specified URI. The method is expected to return a response object that includes the HTTP status and headers. The test checks that the response status is 302 (indicating a redirect) and that the `Location` header is set to `/redirect_target`, which is the expected behavior for a redirect.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern, using `assert` statements to validate the response's status and headers. It also utilizes the `redirect_app` fixture, which likely sets up a test instance of the Sanic application, allowing for isolated testing of the redirect functionality. The use of `allow_redirects=False` is a notable technique here, as it explicitly tests the server's behavior in handling redirects without automatically following them, ensuring that the test focuses on the response generated by the initial request."
    },
    {
      "name": "test_redirect_with_301",
      "module": "test_redirect",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_redirect.py",
      "line_number": 63,
      "end_line_number": 72,
      "source_code": "def test_redirect_with_301(redirect_app):\n    \"\"\"\n    Test redirection with a different status code.\n    \"\"\"\n    request, response = redirect_app.test_client.get(\n        \"/redirect_init_with_301\", allow_redirects=False\n    )\n\n    assert response.status == 301\n    assert response.headers[\"Location\"] == \"/redirect_target\"",
      "docstring": "Test redirection with a different status code.",
      "decorators": [],
      "arguments": [
        "redirect_app"
      ],
      "imports": [
        "urllib.parse.quote",
        "pytest",
        "sanic.response.redirect",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 301",
        "assert response.headers['Location'] == '/redirect_target'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "redirect_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_redirect_with_301` unit test is designed to verify that the application correctly handles HTTP redirection with a 301 status code. This ensures that when a client requests a specific endpoint, the server responds with the appropriate redirect status and location.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when a GET request is made to the `/redirect_init_with_301` endpoint, the server responds with a 301 status code and includes a `Location` header pointing to the `/redirect_target` URL. This behavior is crucial for ensuring that clients are redirected correctly and that search engines understand the permanent nature of the redirect.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `redirect_app.test_client.get` method, which simulates a client making a GET request to the specified endpoint. The method is expected to return a response object that includes the HTTP status and headers. The test specifically checks the `status` attribute of the response to confirm it is 301 and verifies that the `Location` header is set to the expected redirect target.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the response's status and headers, which is a common pattern in unit testing to ensure that the actual output matches the expected output. Additionally, the test uses the `allow_redirects=False` parameter to prevent automatic following of redirects, allowing for direct verification of the response's status and headers without interference from the client\u2019s behavior. This technique is essential for testing redirection logic explicitly."
    },
    {
      "name": "test_get_then_redirect_follow_redirect",
      "module": "test_redirect",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_redirect.py",
      "line_number": 75,
      "end_line_number": 84,
      "source_code": "def test_get_then_redirect_follow_redirect(redirect_app):\n    \"\"\"\n    With `allow_redirects` we expect a 200.\n    \"\"\"\n    request, response = redirect_app.test_client.get(\n        \"/redirect_init\", allow_redirects=True\n    )\n\n    assert response.status == 200\n    assert response.text == \"OK\"",
      "docstring": "With `allow_redirects` we expect a 200.",
      "decorators": [],
      "arguments": [
        "redirect_app"
      ],
      "imports": [
        "urllib.parse.quote",
        "pytest",
        "sanic.response.redirect",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "redirect_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_get_then_redirect_follow_redirect` test is to verify that when a GET request is made to the `/redirect_init` endpoint with the `allow_redirects` option set to `True`, the response status is 200 (OK) and the response body contains the text \"OK\". This ensures that the application correctly handles redirections and returns the expected final response.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks the behavior of the application when following redirects. It confirms that the application correctly processes a series of redirects and ultimately returns a successful response (HTTP status 200) with the expected content. The test ensures that the redirection logic is functioning as intended.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `get` method of the `test_client` associated with the `redirect_app`. When the `get` method is called with the path `/redirect_init` and `allow_redirects=True`, it initiates a request that may involve one or more redirects. The expected behavior is that the final response after following all redirects should have a status of 200 and a body of \"OK\". The test checks these conditions using assertions.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern to validate the response status and content. It uses the `assert` statement to check that the response status equals 200 and that the response text matches \"OK\". This direct approach is effective for unit tests, as it clearly defines the expected outcomes and allows for easy identification of failures. Additionally, the use of `allow_redirects=True` is a notable technique that tests the handling of HTTP redirects within the application."
    },
    {
      "name": "test_chained_redirect",
      "module": "test_redirect",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_redirect.py",
      "line_number": 87,
      "end_line_number": 96,
      "source_code": "def test_chained_redirect(redirect_app):\n    \"\"\"Test test_client is working for redirection\"\"\"\n    request, response = redirect_app.test_client.get(\"/1\")\n    assert request.url.endswith(\"/1\")\n    assert response.status == 200\n    assert response.text == \"OK\"\n    try:\n        assert response.url.endswith(\"/3\")\n    except AttributeError:\n        assert response.url.path.endswith(\"/3\")",
      "docstring": "Test test_client is working for redirection",
      "decorators": [],
      "arguments": [
        "redirect_app"
      ],
      "imports": [
        "urllib.parse.quote",
        "pytest",
        "sanic.response.redirect",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.url.endswith('/1')",
        "assert response.status == 200",
        "assert response.text == 'OK'",
        "assert response.url.endswith('/3')",
        "assert response.url.path.endswith('/3')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "redirect_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_chained_redirect` function is designed to verify that the Sanic application's test client correctly handles a series of HTTP redirects. It ensures that the client can follow redirects and that the final response is as expected.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that:\n1. The initial request to the endpoint `/1` returns a status code of 200.\n2. The response text is \"OK\".\n3. The final URL after following redirects ends with `/3`, confirming that the redirection chain is functioning correctly.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `redirect_app.test_client.get` method, which simulates an HTTP GET request to the specified endpoint. The method is expected to return a tuple containing the request and response objects. The assertions validate the properties of the request and response, specifically checking the URL, status code, and response text. The test also includes a fallback mechanism to handle potential differences in how the URL is represented in the response object.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertion Checks**: The test employs multiple assertions to validate different aspects of the response, ensuring comprehensive coverage of the expected behavior.\n- **Exception Handling**: The use of a try-except block allows the test to gracefully handle the case where the `response` object may not have a `url` attribute, thus ensuring robustness in the test.\n- **Redirection Testing**: The test specifically focuses on the behavior of HTTP redirects, which is a common scenario in web applications, making it a critical aspect of testing web frameworks like Sanic."
    },
    {
      "name": "test_redirect_with_header_injection",
      "module": "test_redirect",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_redirect.py",
      "line_number": 99,
      "end_line_number": 109,
      "source_code": "def test_redirect_with_header_injection(redirect_app):\n    \"\"\"\n    Test redirection to a URL with header and body injections.\n    \"\"\"\n    request, response = redirect_app.test_client.get(\n        \"/redirect_with_header_injection\", allow_redirects=False\n    )\n\n    assert response.status == 302\n    assert \"test-header\" not in response.headers\n    assert not response.text.startswith(\"test-body\")",
      "docstring": "Test redirection to a URL with header and body injections.",
      "decorators": [],
      "arguments": [
        "redirect_app"
      ],
      "imports": [
        "urllib.parse.quote",
        "pytest",
        "sanic.response.redirect",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 302",
        "assert 'test-header' not in response.headers",
        "assert not response.text.startswith('test-body')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "redirect_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_redirect_with_header_injection` aims to verify that a redirection endpoint correctly handles requests that may include header and body injections, ensuring that such injections do not affect the response.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when a request is made to the `/redirect_with_header_injection` endpoint with `allow_redirects` set to `False`, the response status is a 302 (indicating a redirection), and that the response does not include a specific header (`test-header`) or a body that starts with a specific string (`test-body`). This ensures that the application is not vulnerable to header injection attacks.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `get` method of the `redirect_app.test_client`, which simulates an HTTP GET request to the specified endpoint. The method is expected to return an HTTP response object. The assertions in the test validate the response's status and content, confirming that the application behaves as intended when faced with potential header and body injections.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate expected outcomes, a common practice in unit testing. It also utilizes the `allow_redirects` parameter to control the behavior of the request, allowing the test to focus specifically on the initial response without following the redirection. This pattern is effective for isolating and testing specific behaviors in web applications."
    },
    {
      "name": "test_redirect_with_params",
      "module": "test_redirect",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_redirect.py",
      "line_number": 120,
      "end_line_number": 135,
      "source_code": "def test_redirect_with_params(app, test_str):\n    use_in_uri = quote(test_str)\n\n    @app.route(\"/api/v1/test/<test>/\")\n    async def init_handler(request, test):\n        return redirect(f\"/api/v2/test/{use_in_uri}/\")\n\n    @app.route(\"/api/v2/test/<test>/\", unquote=True)\n    async def target_handler(request, test):\n        assert test == quote(test_str)\n        return text(\"OK\")\n\n    _, response = app.test_client.get(f\"/api/v1/test/{use_in_uri}/\")\n    assert response.status == 200\n\n    assert response.body == b\"OK\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('test_str', ['sanic-test', 'sanictest', 'sanic test'])"
      ],
      "arguments": [
        "app",
        "test_str"
      ],
      "imports": [
        "urllib.parse.quote",
        "pytest",
        "sanic.response.redirect",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == b'OK'",
        "assert test == quote(test_str)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_redirect_with_params` function is designed to verify that the Sanic application correctly handles URL redirection with parameters. It ensures that when a request is made to a specific endpoint, the application redirects to another endpoint with the expected parameters encoded properly.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that:\n1. The application correctly redirects from the `/api/v1/test/<test>/` endpoint to the `/api/v2/test/<test>/` endpoint.\n2. The parameter passed in the URL is correctly quoted and unquoted, ensuring that special characters in the parameter do not cause issues.\n3. The final response from the redirected endpoint returns a status code of 200 and the expected body content (\"OK\").\n\n**Code Being Tested and How It Works**:  \nThe test defines two route handlers:\n- `init_handler`: This handler responds to requests at `/api/v1/test/<test>/` and performs a redirect to `/api/v2/test/{use_in_uri}/`, where `use_in_uri` is the URL-encoded version of `test_str`.\n- `target_handler`: This handler responds to requests at `/api/v2/test/<test>/` and asserts that the `test` parameter matches the URL-encoded `test_str`, returning a response with the text \"OK\".\n\nThe test then simulates a GET request to the initial endpoint and checks the response status and body.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses `pytest.mark.parametrize` to run the same test logic with multiple values of `test_str`, allowing for comprehensive testing of different input scenarios.\n- **Asynchronous Testing**: The use of `async def` for route handlers indicates that the test is designed to work with asynchronous code, which is common in web frameworks like Sanic.\n- **Assertions**: The test employs assertions to validate both the response status and the content of the response, ensuring that the application behaves as expected under various conditions."
    },
    {
      "name": "test_no_body_requests",
      "module": "test_pipelining",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_pipelining.py",
      "line_number": 6,
      "end_line_number": 24,
      "source_code": "def test_no_body_requests(app, port):\n    @app.get(\"/\")\n    async def handler(request):\n        return json(\n            {\n                \"request_id\": str(request.id),\n                \"connection_id\": id(request.conn_info),\n            }\n        )\n\n    client = ReusableClient(app, port=port)\n\n    with client:\n        _, response1 = client.get(\"/\")\n        _, response2 = client.get(\"/\")\n\n    assert response1.status == response2.status == 200\n    assert response1.json[\"request_id\"] != response2.json[\"request_id\"]\n    assert response1.json[\"connection_id\"] == response2.json[\"connection_id\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "port"
      ],
      "imports": [
        "sanic_testing.reusable.ReusableClient",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response1.status == response2.status == 200",
        "assert response1.json['request_id'] != response2.json['request_id']",
        "assert response1.json['connection_id'] == response2.json['connection_id']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_no_body_requests` function is designed to verify the behavior of the Sanic application when handling GET requests that do not include a body. It ensures that the application correctly generates unique request IDs for each request while maintaining the same connection ID for requests made over the same connection.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. Both GET requests return a successful HTTP status code (200).\n2. Each request generates a unique `request_id`, confirming that the server distinguishes between different requests.\n3. The `connection_id` remains the same for both requests, indicating that they are processed over the same connection.\n\n**Code Being Tested and How It Works**:  \nThe test defines a simple GET handler that returns a JSON response containing the `request_id` and `connection_id`. The `ReusableClient` is used to simulate two GET requests to the root endpoint (\"/\"). The responses are then validated against the expected behavior outlined above. The handler utilizes the `request` object to access the unique identifiers.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Reusable Client**: The use of `ReusableClient` allows for efficient testing of the application by reusing the same client instance for multiple requests, which is particularly useful for maintaining connection state.\n- **Asynchronous Testing**: The test leverages asynchronous functions to handle requests, which is a common pattern in modern web frameworks like Sanic that support asynchronous I/O.\n- **Assertions**: The test employs multiple assertions to validate different aspects of the response, ensuring comprehensive coverage of the expected behavior."
    },
    {
      "name": "test_json_body_requests",
      "module": "test_pipelining",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_pipelining.py",
      "line_number": 27,
      "end_line_number": 47,
      "source_code": "def test_json_body_requests(app, port):\n    @app.post(\"/\")\n    async def handler(request):\n        return json(\n            {\n                \"request_id\": str(request.id),\n                \"connection_id\": id(request.conn_info),\n                \"foo\": request.json.get(\"foo\"),\n            }\n        )\n\n    client = ReusableClient(app, port=port)\n\n    with client:\n        _, response1 = client.post(\"/\", json={\"foo\": True})\n        _, response2 = client.post(\"/\", json={\"foo\": True})\n\n    assert response1.status == response2.status == 200\n    assert response1.json[\"foo\"] is response2.json[\"foo\"] is True\n    assert response1.json[\"request_id\"] != response2.json[\"request_id\"]\n    assert response1.json[\"connection_id\"] == response2.json[\"connection_id\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "port"
      ],
      "imports": [
        "sanic_testing.reusable.ReusableClient",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response1.status == response2.status == 200",
        "assert response1.json['foo'] is response2.json['foo'] is True",
        "assert response1.json['request_id'] != response2.json['request_id']",
        "assert response1.json['connection_id'] == response2.json['connection_id']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "request.json.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_json_body_requests` function is designed to verify the behavior of a Sanic application when handling JSON body requests. It ensures that the application correctly processes multiple requests with identical JSON payloads and checks the uniqueness of request identifiers and connection information.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. Both requests return a successful HTTP status code (200).\n2. The JSON response for the key \"foo\" is consistent across both requests.\n3. The \"request_id\" is unique for each request, confirming that each request is treated independently.\n4. The \"connection_id\" remains the same for both requests, indicating that they are processed over the same connection.\n\n**Code Being Tested and How It Works**:  \nThe test defines a POST handler for the root endpoint (\"/\") that returns a JSON response containing the request's ID, connection ID, and the value of \"foo\" from the JSON body. The `ReusableClient` is used to simulate two POST requests to this endpoint with the same JSON payload (`{\"foo\": True}`). The assertions then validate the expected behavior of the handler.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Reusable Client**: The use of `ReusableClient` allows for efficient testing of the application by reusing the same client instance for multiple requests.\n- **Asynchronous Testing**: The test leverages asynchronous request handling, which is crucial for testing web applications that operate in an asynchronous environment.\n- **Assertions**: Multiple assertions are employed to validate different aspects of the response, ensuring comprehensive coverage of the expected behavior. This includes checking status codes, response content, and the uniqueness of identifiers."
    },
    {
      "name": "test_streaming_body_requests",
      "module": "test_pipelining",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_pipelining.py",
      "line_number": 50,
      "end_line_number": 77,
      "source_code": "def test_streaming_body_requests(app, port):\n    @app.post(\"/\", stream=True)\n    async def handler(request):\n        data = [part.decode(\"utf-8\") async for part in request.stream]\n        return json(\n            {\n                \"request_id\": str(request.id),\n                \"connection_id\": id(request.conn_info),\n                \"data\": data,\n            }\n        )\n\n    data = [\"hello\", \"world\"]\n\n    client = ReusableClient(app, port=port)\n\n    async def stream(data):\n        for value in data:\n            yield value.encode(\"utf-8\")\n\n    with client:\n        _, response1 = client.post(\"/\", data=stream(data))\n        _, response2 = client.post(\"/\", data=stream(data))\n\n    assert response1.status == response2.status == 200\n    assert response1.json[\"data\"] == response2.json[\"data\"] == data\n    assert response1.json[\"request_id\"] != response2.json[\"request_id\"]\n    assert response1.json[\"connection_id\"] == response2.json[\"connection_id\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "port"
      ],
      "imports": [
        "sanic_testing.reusable.ReusableClient",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response1.status == response2.status == 200",
        "assert response1.json['data'] == response2.json['data'] == data",
        "assert response1.json['request_id'] != response2.json['request_id']",
        "assert response1.json['connection_id'] == response2.json['connection_id']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_streaming_body_requests` function is designed to verify the behavior of a Sanic application when handling streaming body requests. It ensures that the application can correctly process streamed data and return appropriate responses, including unique request IDs and consistent connection IDs.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. The HTTP status code for both requests is 200, indicating successful processing.\n2. The data returned in the response matches the data sent in the request.\n3. Each request generates a unique request ID, confirming that the server distinguishes between different requests.\n4. The connection ID remains the same for both requests, indicating that they are processed over the same connection.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes an asynchronous handler defined for POST requests at the root endpoint (\"/\"). This handler reads streamed data from the request, decodes it, and returns a JSON response containing the request ID, connection ID, and the streamed data. The test uses a `ReusableClient` to simulate sending two separate streaming requests with the same data, allowing for the verification of the aforementioned behaviors.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test leverages asynchronous programming to handle streaming data, which is essential for I/O-bound operations in web applications.\n- **Data Streaming**: The use of a generator function (`stream`) to yield data simulates real-world scenarios where data is sent in chunks rather than all at once.\n- **Assertions**: Multiple assertions are employed to validate different aspects of the responses, ensuring comprehensive coverage of the expected behavior.\n- **Context Management**: The `with client:` statement ensures that the client is properly managed, allowing for clean setup and teardown of the test environment."
    },
    {
      "name": "test_bad_headers",
      "module": "test_pipelining",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_pipelining.py",
      "line_number": 80,
      "end_line_number": 100,
      "source_code": "def test_bad_headers(app, port):\n    @app.get(\"/\")\n    async def handler(request):\n        return text(\"\")\n\n    @app.on_response\n    async def reqid(request, response):\n        response.headers[\"x-request-id\"] = request.id\n\n    client = ReusableClient(app, port=port)\n    bad_headers = {\"bad\": \"bad\" * 5_000}\n\n    with client:\n        _, response1 = client.get(\"/\")\n        _, response2 = client.get(\"/\", headers=bad_headers)\n\n    assert response1.status == 200\n    assert response2.status == 413\n    assert (\n        response1.headers[\"x-request-id\"] != response2.headers[\"x-request-id\"]\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "port"
      ],
      "imports": [
        "sanic_testing.reusable.ReusableClient",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response1.status == 200",
        "assert response2.status == 413",
        "assert response1.headers['x-request-id'] != response2.headers['x-request-id']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_bad_headers` function is designed to verify the behavior of the application when it receives HTTP requests with excessively large headers. Specifically, it checks that the application can handle a valid request and appropriately rejects a request with oversized headers.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies that:\n1. A request without any special headers returns a successful HTTP status code (200).\n2. A request with a header that exceeds the acceptable size limit returns an HTTP status code indicating that the request is too large (413).\n3. The `x-request-id` header is unique for each request, ensuring that the application correctly generates a new request ID for each incoming request.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a simple Sanic application with a GET endpoint that returns an empty response. It also includes an event listener that adds a unique `x-request-id` header to the response based on the request's ID. The `ReusableClient` is used to simulate HTTP requests to the application. The test sends two requests: one without any special headers and another with a large header (`bad_headers`). The responses are then checked for their status codes and the uniqueness of the `x-request-id` header.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The use of a context manager (`with client:`) ensures that the client is properly set up and torn down, managing resources effectively.\n- **Assertions**: The test employs assertions to validate the expected outcomes, ensuring that the application behaves correctly under different conditions.\n- **Separation of Concerns**: The test isolates the behavior of the application by focusing on the response to specific header conditions, which helps in identifying issues related to header handling without interference from other application logic."
    },
    {
      "name": "test_deprecation",
      "module": "test_deprecation",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_deprecation.py",
      "line_number": 7,
      "end_line_number": 10,
      "source_code": "def test_deprecation():\n    message = r\"\\[DEPRECATION v9\\.9\\] hello\"\n    with pytest.warns(DeprecationWarning, match=message):\n        deprecation(\"hello\", 9.9)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "sanic.Sanic",
        "sanic.log.deprecation"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_deprecation` function is designed to verify that the `deprecation` function from the Sanic framework correctly raises a `DeprecationWarning` with a specific message format when invoked. This ensures that developers are informed about deprecated features in a consistent manner.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when the `deprecation` function is called with the arguments `\"hello\"` and `9.9`, it triggers a `DeprecationWarning` that matches the expected message pattern `\"[DEPRECATION v9.9] hello\"`. This is crucial for maintaining awareness of deprecated features in the codebase.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `deprecation` function, which is expected to issue a warning when deprecated features are used. The test uses the `pytest.warns` context manager to assert that a `DeprecationWarning` is raised during the execution of `deprecation(\"hello\", 9.9)`. The `match` parameter ensures that the warning message conforms to the specified regex pattern, confirming that the warning is not only raised but also formatted correctly.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.warns` context manager, a powerful feature of the `pytest` framework that allows for the assertion of warnings in a clean and readable manner. The use of a regex pattern for matching the warning message is a notable technique, as it provides flexibility in verifying that the warning message adheres to a specific format without being overly strict on the exact string. This approach enhances the robustness of the test by allowing for minor variations in the warning message while still ensuring that the essential information is conveyed."
    },
    {
      "name": "test_deprecation_filter",
      "module": "test_deprecation",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_deprecation.py",
      "line_number": 17,
      "end_line_number": 20,
      "source_code": "def test_deprecation_filter(app: Sanic, filter, expected, recwarn):\n    app.config.DEPRECATION_FILTER = filter\n    deprecation(\"hello\", 9.9)\n    assert len(recwarn) == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('filter,expected', (('default', 1), ('once', 1), ('ignore', 0)))"
      ],
      "arguments": [
        "app",
        "filter",
        "expected",
        "recwarn"
      ],
      "imports": [
        "pytest",
        "sanic.Sanic",
        "sanic.log.deprecation"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(recwarn) == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_deprecation_filter` unit test is designed to verify the behavior of the deprecation warning system in the Sanic framework, specifically how different deprecation filters affect the number of warnings generated when a deprecated function is called.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the number of deprecation warnings captured by the `recwarn` fixture matches the expected count based on the specified filter. It tests three different filters: \"default\", \"once\", and \"ignore\", ensuring that the system behaves correctly under each condition.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `deprecation` function from the Sanic logging module, which is called with a message and a version number. The `app.config.DEPRECATION_FILTER` is set to the current filter being tested. The `deprecation` function is expected to trigger a warning, which is then captured by the `recwarn` fixture. The assertion checks that the length of `recwarn` matches the expected number of warnings based on the filter applied.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses `pytest.mark.parametrize` to run the same test logic with different sets of input values (filters and expected warning counts), promoting code reuse and clarity.\n- **Warning Capture**: The `recwarn` fixture is utilized to capture warnings emitted during the test, allowing for assertions on the number of warnings generated.\n- **Configuration Testing**: The test modifies the application configuration dynamically to test different behaviors, showcasing how configuration impacts functionality."
    },
    {
      "name": "test_single_listener",
      "module": "test_server_events",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_server_events.py",
      "line_number": 56,
      "end_line_number": 62,
      "source_code": "def test_single_listener(app, listener_name):\n    \"\"\"Test that listeners on their own work\"\"\"\n    output = []\n    # Register listener\n    app.listener(listener_name)(create_listener(listener_name, output))\n    start_stop_app(app)\n    assert app.name + listener_name == output.pop()",
      "docstring": "Test that listeners on their own work",
      "decorators": [
        "pytest.mark.parametrize('listener_name', AVAILABLE_LISTENERS)"
      ],
      "arguments": [
        "app",
        "listener_name"
      ],
      "imports": [
        "asyncio",
        "signal",
        "contextlib.closing",
        "socket.socket",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic.Blueprint",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.SanicException",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.name + listener_name == output.pop()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "start_stop_app",
          "body": "def start_stop_app(random_name_app, **run_kwargs):\n\n    @random_name_app.after_server_start\n    async def shutdown(app):\n        await asyncio.sleep(1.1)\n        app.stop()\n    try:\n        random_name_app.run(HOST, get_port(), single_process=True, **run_kwargs)\n    except KeyboardInterrupt:\n        pass"
        },
        {
          "name": "create_listener",
          "body": "def create_listener(listener_name, in_list):\n\n    async def _listener(app, loop):\n        print(f'DEBUG MESSAGE FOR PYTEST for {listener_name}')\n        in_list.insert(0, app.name + listener_name)\n    return _listener"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:\nThe `test_single_listener` function is designed to verify that a single event listener can be registered and executed correctly within a Sanic application. It ensures that when the application starts, the listener is triggered and performs its intended action.\n\n**Specific Functionality or Behavior Verified**:\nThis test specifically checks that the output generated by the listener matches the expected format, which is the concatenation of the application's name and the listener's name. It confirms that the listener is functioning as intended when the application is started and stopped.\n\n**Code Being Tested and How It Works**:\nThe test registers a listener using the `app.listener(listener_name)` decorator, which associates the listener with a specific event (e.g., `before_server_start`, `after_server_start`, etc.). The `create_listener` function creates an asynchronous listener that appends a formatted string to the `output` list when triggered. The `start_stop_app` function runs the application, which in turn triggers the registered listener. After the application stops, the test asserts that the expected output (the concatenated string) is the last item popped from the `output` list.\n\n**Notable Testing Patterns or Techniques Used**:\n- **Parameterization**: The test uses `pytest.mark.parametrize` to run the same test logic for multiple listener names defined in `AVAILABLE_LISTENERS`. This allows for efficient testing of various scenarios without duplicating code.\n- **Asynchronous Testing**: The listener is defined as an asynchronous function, and the test framework is set up to handle asynchronous code execution, ensuring that the listener's behavior is tested in a realistic environment.\n- **Output Verification**: The test captures the output of the listener in a list and verifies it after the application has run, demonstrating a common pattern of asserting side effects in unit tests."
    },
    {
      "name": "test_single_listener_no_loop",
      "module": "test_server_events",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_server_events.py",
      "line_number": 66,
      "end_line_number": 72,
      "source_code": "def test_single_listener_no_loop(app, listener_name):\n    \"\"\"Test that listeners on their own work\"\"\"\n    output = []\n    # Register listener\n    app.listener(listener_name)(create_listener_no_loop(listener_name, output))\n    start_stop_app(app)\n    assert app.name + listener_name == output.pop()",
      "docstring": "Test that listeners on their own work",
      "decorators": [
        "pytest.mark.parametrize('listener_name', AVAILABLE_LISTENERS)"
      ],
      "arguments": [
        "app",
        "listener_name"
      ],
      "imports": [
        "asyncio",
        "signal",
        "contextlib.closing",
        "socket.socket",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic.Blueprint",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.SanicException",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.name + listener_name == output.pop()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "start_stop_app",
          "body": "def start_stop_app(random_name_app, **run_kwargs):\n\n    @random_name_app.after_server_start\n    async def shutdown(app):\n        await asyncio.sleep(1.1)\n        app.stop()\n    try:\n        random_name_app.run(HOST, get_port(), single_process=True, **run_kwargs)\n    except KeyboardInterrupt:\n        pass"
        },
        {
          "name": "create_listener_no_loop",
          "body": "def create_listener_no_loop(listener_name, in_list):\n\n    async def _listener(app):\n        print(f'DEBUG MESSAGE FOR PYTEST for {listener_name}')\n        in_list.insert(0, app.name + listener_name)\n    return _listener"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:\nThe `test_single_listener_no_loop` function is designed to verify that a listener registered with the Sanic application can execute correctly without requiring an event loop. It ensures that the listener behaves as expected when triggered, specifically checking that it appends the correct output to a list.\n\n**Specific Functionality or Behavior Verified**:\nThis test checks that when a listener is registered and the application is started, the listener executes and modifies the output list as intended. The assertion at the end confirms that the output from the listener matches the expected format, which is a concatenation of the application name and the listener name.\n\n**Code Being Tested and How It Works**:\nThe test registers a listener using the `create_listener_no_loop` function, which defines an asynchronous listener that appends a formatted string to the `output` list when triggered. The `start_stop_app` function is then called to run the application, which will invoke the listener upon server start. The listener is expected to execute and modify the `output` list before the application stops after a brief delay.\n\n**Notable Testing Patterns or Techniques Used**:\n- **Parameterization**: The test uses `pytest.mark.parametrize` to run the same test logic for multiple listener names defined in `AVAILABLE_LISTENERS`, ensuring comprehensive coverage of different listener scenarios.\n- **Asynchronous Testing**: The test leverages asynchronous functions to handle the event-driven nature of the Sanic framework, allowing for non-blocking execution and proper handling of asynchronous listeners.\n- **Output Verification**: The test captures the output in a list and verifies it against the expected result, demonstrating a common pattern in unit tests where the state or output of a function is checked after execution."
    },
    {
      "name": "test_register_listener",
      "module": "test_server_events",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_server_events.py",
      "line_number": 76,
      "end_line_number": 86,
      "source_code": "def test_register_listener(app, listener_name):\n    \"\"\"\n    Test that listeners on their own work with\n    app.register_listener method\n    \"\"\"\n    output = []\n    # Register listener\n    listener = create_listener(listener_name, output)\n    app.register_listener(listener, event=listener_name)\n    start_stop_app(app)\n    assert app.name + listener_name == output.pop()",
      "docstring": "Test that listeners on their own work with\napp.register_listener method",
      "decorators": [
        "pytest.mark.parametrize('listener_name', AVAILABLE_LISTENERS)"
      ],
      "arguments": [
        "app",
        "listener_name"
      ],
      "imports": [
        "asyncio",
        "signal",
        "contextlib.closing",
        "socket.socket",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic.Blueprint",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.SanicException",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.name + listener_name == output.pop()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "create_listener",
          "body": "def create_listener(listener_name, in_list):\n\n    async def _listener(app, loop):\n        print(f'DEBUG MESSAGE FOR PYTEST for {listener_name}')\n        in_list.insert(0, app.name + listener_name)\n    return _listener"
        },
        {
          "name": "start_stop_app",
          "body": "def start_stop_app(random_name_app, **run_kwargs):\n\n    @random_name_app.after_server_start\n    async def shutdown(app):\n        await asyncio.sleep(1.1)\n        app.stop()\n    try:\n        random_name_app.run(HOST, get_port(), single_process=True, **run_kwargs)\n    except KeyboardInterrupt:\n        pass"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:\nThe `test_register_listener` function is designed to verify that the Sanic application correctly registers and executes event listeners using the `app.register_listener` method. It ensures that when a listener is registered for a specific event, it behaves as expected when that event occurs.\n\n**Specific Functionality or Behavior Verified**:\nThis test specifically checks that the listener, when triggered, modifies a shared output list to include a concatenated string of the application name and the listener name. The test asserts that this expected output is produced after the application starts and the listener is executed.\n\n**Code Being Tested and How It Works**:\nThe test utilizes the `create_listener` function to create an asynchronous listener that appends a string to the `output` list when the event is triggered. The `start_stop_app` function is called to start the application, which in turn triggers the registered listener. The listener is expected to execute during the application's lifecycle, specifically when the server starts, and the output is validated by checking that the last item popped from the `output` list matches the expected format (`app.name + listener_name`).\n\n**Notable Testing Patterns or Techniques Used**:\n- **Parameterization**: The test is likely part of a parameterized test suite, as indicated by the use of `listener_name` which iterates over a predefined list of available listeners. This allows for testing multiple scenarios with minimal code duplication.\n- **Asynchronous Testing**: The listener is defined as an asynchronous function, and the test framework (pytest) is set up to handle asynchronous code execution, ensuring that the listener's behavior is tested in a real-world asynchronous context.\n- **Assertions**: The test uses assertions to validate the expected outcome, ensuring that the listener's functionality is correctly implemented and that the application behaves as intended when the listener is registered and triggered."
    },
    {
      "name": "test_all_listeners",
      "module": "test_server_events",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_server_events.py",
      "line_number": 89,
      "end_line_number": 96,
      "source_code": "def test_all_listeners(app):\n    output = []\n    for listener_name in AVAILABLE_LISTENERS:\n        listener = create_listener(listener_name, output)\n        app.listener(listener_name)(listener)\n    start_stop_app(app)\n    for listener_name in AVAILABLE_LISTENERS:\n        assert app.name + listener_name == output.pop()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "signal",
        "contextlib.closing",
        "socket.socket",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic.Blueprint",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.SanicException",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.name + listener_name == output.pop()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "start_stop_app",
          "body": "def start_stop_app(random_name_app, **run_kwargs):\n\n    @random_name_app.after_server_start\n    async def shutdown(app):\n        await asyncio.sleep(1.1)\n        app.stop()\n    try:\n        random_name_app.run(HOST, get_port(), single_process=True, **run_kwargs)\n    except KeyboardInterrupt:\n        pass"
        },
        {
          "name": "create_listener",
          "body": "def create_listener(listener_name, in_list):\n\n    async def _listener(app, loop):\n        print(f'DEBUG MESSAGE FOR PYTEST for {listener_name}')\n        in_list.insert(0, app.name + listener_name)\n    return _listener"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_all_listeners` function is designed to verify that all available listeners in the Sanic application framework are correctly registered and invoked during the application's lifecycle. It ensures that each listener is triggered as expected when the application starts and stops.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that for each listener defined in the `AVAILABLE_LISTENERS` list, the corresponding listener function is executed, and the output generated matches the expected format. Specifically, it asserts that the output from the listeners matches the concatenation of the application name and the listener name, confirming that the listeners are functioning correctly.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the `create_listener` function to create asynchronous listener functions that append a formatted string to an output list. The `start_stop_app` function is then called to run the application, which triggers the registered listeners. After the application has started and stopped, the test checks that the expected output (formatted as `app.name + listener_name`) is present in the output list, ensuring that each listener was executed in the correct order.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test iterates over a predefined list of listener names (`AVAILABLE_LISTENERS`), allowing for a single test function to validate multiple scenarios without duplicating code.\n- **Asynchronous Testing**: The use of asynchronous listener functions and the `start_stop_app` function demonstrates the handling of asynchronous operations within the test, ensuring that the event loop is properly managed.\n- **Assertions**: The test employs assertions to validate the expected outcomes, ensuring that the listeners produce the correct output when invoked. This is a fundamental aspect of unit testing, providing a clear pass/fail criterion for the test."
    },
    {
      "name": "test_all_listeners_as_convenience",
      "module": "test_server_events",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_server_events.py",
      "line_number": 99,
      "end_line_number": 107,
      "source_code": "def test_all_listeners_as_convenience(app):\n    output = []\n    for listener_name in AVAILABLE_LISTENERS:\n        listener = create_listener(listener_name, output)\n        method = getattr(app, listener_name)\n        method(listener)\n    start_stop_app(app)\n    for listener_name in AVAILABLE_LISTENERS:\n        assert app.name + listener_name == output.pop()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "signal",
        "contextlib.closing",
        "socket.socket",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic.Blueprint",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.SanicException",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.name + listener_name == output.pop()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "start_stop_app",
          "body": "def start_stop_app(random_name_app, **run_kwargs):\n\n    @random_name_app.after_server_start\n    async def shutdown(app):\n        await asyncio.sleep(1.1)\n        app.stop()\n    try:\n        random_name_app.run(HOST, get_port(), single_process=True, **run_kwargs)\n    except KeyboardInterrupt:\n        pass"
        },
        {
          "name": "create_listener",
          "body": "def create_listener(listener_name, in_list):\n\n    async def _listener(app, loop):\n        print(f'DEBUG MESSAGE FOR PYTEST for {listener_name}')\n        in_list.insert(0, app.name + listener_name)\n    return _listener"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_all_listeners_as_convenience` function is designed to verify that all available listeners can be registered and invoked correctly on a Sanic application instance. It ensures that the listeners behave as expected when triggered, confirming that the application can handle multiple listener registrations seamlessly.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that each listener, when registered using the convenience method (i.e., dynamically accessed via `getattr`), correctly appends a formatted string (combining the application name and listener name) to an output list. After starting and stopping the application, it asserts that the expected output matches the order of listener invocations.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the `create_listener` function to create asynchronous listener functions that append a formatted string to the `output` list. The `start_stop_app` function is called to run the application, which triggers the registered listeners. The test then verifies that the output list contains the expected strings in the correct order, indicating that each listener was invoked properly. The relevant code includes:\n- `create_listener`: Generates a listener that appends a string to the output list.\n- `start_stop_app`: Starts the application and triggers the listeners.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Dynamic Method Access**: The test uses `getattr` to dynamically call listener methods based on their names, showcasing flexibility in listener registration.\n- **Output Verification**: The test collects output in a list and verifies it after the application has run, ensuring that the order of listener execution is correct.\n- **Asynchronous Testing**: The test is designed to work with asynchronous listeners, which is a common pattern in modern web frameworks like Sanic, allowing for non-blocking operations during server events."
    },
    {
      "name": "test_create_server_trigger_events",
      "module": "test_server_events",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_server_events.py",
      "line_number": 143,
      "end_line_number": 201,
      "source_code": "def test_create_server_trigger_events(app):\n    \"\"\"Test if create_server can trigger server events\"\"\"\n\n    def stop_on_alarm(signum, frame):\n        raise KeyboardInterrupt(\"...\")\n\n    flag1 = False\n    flag2 = False\n    flag3 = False\n\n    async def stop(app, loop):\n        nonlocal flag1\n        flag1 = True\n\n    async def before_stop(app, loop):\n        nonlocal flag2\n        flag2 = True\n\n    async def after_stop(app, loop):\n        nonlocal flag3\n        flag3 = True\n\n    app.listener(\"after_server_start\")(stop)\n    app.listener(\"before_server_stop\")(before_stop)\n    app.listener(\"after_server_stop\")(after_stop)\n\n    loop = asyncio.get_event_loop()\n\n    # Use random port for tests\n\n    signal.signal(signal.SIGALRM, stop_on_alarm)\n    signal.alarm(1)\n    with closing(socket()) as sock:\n        sock.bind((\"127.0.0.1\", 0))\n\n        serv_coro = app.create_server(\n            return_asyncio_server=True, sock=sock, debug=True\n        )\n        serv_task = asyncio.ensure_future(serv_coro, loop=loop)\n        server = loop.run_until_complete(serv_task)\n        loop.run_until_complete(server.startup())\n        loop.run_until_complete(server.after_start())\n        try:\n            loop.run_forever()\n        except KeyboardInterrupt:\n            loop.stop()\n        finally:\n            # Run the on_stop function if provided\n            loop.run_until_complete(server.before_stop())\n\n            # Wait for server to close\n            close_task = server.close()\n            loop.run_until_complete(close_task)\n\n            # Complete all tasks on the loop\n            for connection in server.connections:\n                connection.close_if_idle()\n            loop.run_until_complete(server.after_stop())\n        assert flag1 and flag2 and flag3",
      "docstring": "Test if create_server can trigger server events",
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "signal",
        "contextlib.closing",
        "socket.socket",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic.Blueprint",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.SanicException",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert flag1 and flag2 and flag3"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "loop.stop",
          "body": "def stop(app):\n    app.stop()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_create_server_trigger_events` test is to verify that the Sanic application can correctly trigger lifecycle events when a server is created and subsequently started and stopped. It ensures that the appropriate event listeners are invoked during the server's lifecycle.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the flags (`flag1`, `flag2`, and `flag3`) are set to `True` when the corresponding server lifecycle events (`after_server_start`, `before_server_stop`, and `after_server_stop`) are triggered. This confirms that the event listeners are functioning as expected during the server's startup and shutdown processes.\n\n**Code Being Tested and How It Works**:  \nThe test sets up an asynchronous Sanic application and registers three event listeners for the server's lifecycle events. It creates a server using a randomly assigned port and starts it. The server is then run in an event loop until interrupted. Upon stopping the server, the test checks if the flags were set, indicating that the listeners were called. The relevant code includes the creation of the server, the event loop management, and the assertions that validate the expected behavior.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test utilizes `async` functions and the asyncio event loop to handle asynchronous operations, which is crucial for testing server behavior in an asynchronous framework like Sanic.\n- **Signal Handling**: The test employs signal handling to manage timeouts, ensuring that the test does not hang indefinitely if the server does not behave as expected.\n- **Nonlocal Variables**: The use of `nonlocal` allows the test to modify the flags defined in the outer scope, which is a common pattern in Python to maintain state across nested functions.\n- **Assertions**: The test concludes with assertions to verify that all expected flags are set, providing a clear pass/fail outcome based on the server's lifecycle event handling."
    },
    {
      "name": "test_reload_listeners_attached",
      "module": "test_server_events",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_server_events.py",
      "line_number": 217,
      "end_line_number": 226,
      "source_code": "def test_reload_listeners_attached(app):\n    async def dummy(*_): ...\n\n    app.reload_process_start(dummy)\n    app.reload_process_stop(dummy)\n    app.listener(\"reload_process_start\")(dummy)\n    app.listener(\"reload_process_stop\")(dummy)\n\n    assert len(app.listeners.get(\"reload_process_start\")) == 2\n    assert len(app.listeners.get(\"reload_process_stop\")) == 2",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "signal",
        "contextlib.closing",
        "socket.socket",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic.Blueprint",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.SanicException",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(app.listeners.get('reload_process_start')) == 2",
        "assert len(app.listeners.get('reload_process_stop')) == 2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.reload_process_start",
          "body": "@app.reload_process_start\ndef reload_process_start(_):\n    results.append('reload_process_start')"
        },
        {
          "name": "app.reload_process_stop",
          "body": "@app.reload_process_stop\ndef reload_process_stop(_):\n    results.append('reload_process_stop')"
        },
        {
          "name": "app.listeners.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.listeners.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_reload_listeners_attached` test verifies that the Sanic application correctly registers and counts listeners for the `reload_process_start` and `reload_process_stop` events. It ensures that both the direct method calls and the listener decorator are functioning as expected.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that two listeners are attached to each of the specified events (`reload_process_start` and `reload_process_stop`). It confirms that the application can handle multiple listeners for the same event without any issues.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `reload_process_start` and `reload_process_stop` methods, which are designed to register listeners for their respective events. The test first defines a dummy asynchronous function and registers it as a listener using both the direct method calls (`app.reload_process_start(dummy)` and `app.reload_process_stop(dummy)`) and the listener decorator (`app.listener(\"reload_process_start\")(dummy)` and `app.listener(\"reload_process_stop\")(dummy)`). Finally, it asserts that the length of the listeners for each event is equal to 2, indicating that both registration methods successfully added the listener.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test uses an asynchronous dummy function to simulate a listener, which is essential for testing asynchronous frameworks like Sanic.\n- **Direct Method Calls and Decorators**: It demonstrates the use of both direct method calls and decorators to register listeners, showcasing flexibility in how listeners can be added.\n- **Assertions on State**: The test employs assertions to verify the internal state of the application (i.e., the number of listeners), which is a common practice in unit testing to ensure that the code behaves as expected."
    },
    {
      "name": "test_priority_ordering",
      "module": "test_server_events",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_server_events.py",
      "line_number": 229,
      "end_line_number": 274,
      "source_code": "def test_priority_ordering(app):\n    output = []\n    bp = Blueprint(\"bp\")\n\n    @app.before_server_start\n    async def first(app):\n        output.append(\"first\")\n\n    @app.listener(\"before_server_start\", priority=2)\n    async def second(app):\n        output.append(\"second\")\n\n    @app.before_server_start(priority=3)\n    async def third(app):\n        output.append(\"third\")\n\n    @bp.before_server_start\n    async def bp_first(app):\n        output.append(\"bp_first\")\n\n    @bp.listener(\"before_server_start\", priority=2)\n    async def bp_second(app):\n        output.append(\"bp_second\")\n\n    @bp.before_server_start(priority=3)\n    async def bp_third(app):\n        output.append(\"bp_third\")\n\n    @app.before_server_start\n    async def fourth(app):\n        output.append(\"fourth\")\n\n    app.blueprint(bp)\n    start_stop_app(app)\n\n    # The order of the listeners is:\n    # priority descending, app before bp, definition order ascending\n    assert output == [\n        \"third\",\n        \"bp_third\",\n        \"second\",\n        \"bp_second\",\n        \"first\",\n        \"fourth\",\n        \"bp_first\",\n    ]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "signal",
        "contextlib.closing",
        "socket.socket",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic.Blueprint",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.SanicException",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert output == ['third', 'bp_third', 'second', 'bp_second', 'first', 'fourth', 'bp_first']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "start_stop_app",
          "body": "def start_stop_app(random_name_app, **run_kwargs):\n\n    @random_name_app.after_server_start\n    async def shutdown(app):\n        await asyncio.sleep(1.1)\n        app.stop()\n    try:\n        random_name_app.run(HOST, get_port(), single_process=True, **run_kwargs)\n    except KeyboardInterrupt:\n        pass"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_priority_ordering` function is designed to verify the correct execution order of server start listeners in a Sanic application, particularly focusing on how the priority levels affect the order of execution.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the listeners registered with different priorities and in different contexts (application vs. blueprint) are executed in the expected order when the server starts. It ensures that higher priority listeners are executed before lower priority ones, and that listeners defined in the application context are executed before those in the blueprint context when priorities are equal.\n\n**Code Being Tested and How It Works**:  \nThe test sets up multiple asynchronous listeners using the Sanic framework's event system. It defines several listeners with varying priorities and attaches them to both the main application and a blueprint. After registering these listeners, the `start_stop_app` function is called to simulate starting the server, which triggers the execution of the listeners. The expected order of execution is then asserted against the actual order captured in the `output` list.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test utilizes asynchronous functions to handle the event listeners, which is crucial for testing frameworks like Sanic that are built on asynchronous I/O.\n- **Priority-Based Execution**: The test leverages a priority system to determine the order of listener execution, showcasing how to manage and test complex event-driven behavior.\n- **Blueprints**: The use of blueprints demonstrates modular application design, allowing for organized grouping of routes and listeners, which is a common pattern in web frameworks.\n- **Assertions**: The test concludes with an assertion that checks if the actual output matches the expected order, ensuring that the implementation adheres to the defined behavior."
    },
    {
      "name": "test_app",
      "module": "test_http",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_http.py",
      "line_number": 21,
      "end_line_number": 33,
      "source_code": "def test_app(app: Sanic):\n    app.config.KEEP_ALIVE_TIMEOUT = 1\n\n    @app.get(\"/\")\n    async def base_handler(request):\n        return text(\"111122223333444455556666777788889999\")\n\n    @app.post(\"/upload\", stream=True)\n    async def upload_handler(request):\n        data = [part.decode(\"utf-8\") async for part in request.stream]\n        return json(data)\n\n    return app",
      "docstring": null,
      "decorators": [
        "pytest.fixture"
      ],
      "arguments": [
        "app"
      ],
      "imports": [
        "json",
        "collections.namedtuple",
        "pathlib.Path",
        "sys.version_info",
        "pytest",
        "sanic_testing.reusable.ReusableClient",
        "sanic.json",
        "sanic.text",
        "sanic.app.Sanic",
        "tests.client.RawClient"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_app` function is to set up a Sanic application with specific routes for testing. It defines a basic GET handler and a POST handler that processes streamed data, allowing for the verification of the application's behavior when handling different types of requests.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies that the application can correctly handle GET requests to the root endpoint (\"/\") and POST requests to the \"/upload\" endpoint. It ensures that the application returns the expected responses for these requests, particularly focusing on the ability to handle streamed data in the POST request.\n\n**Code Being Tested and How It Works**:  \nThe code being tested includes two route handlers:\n1. A GET handler at the root (\"/\") that returns a long string of numbers as text.\n2. A POST handler at \"/upload\" that reads streamed data from the request, decodes it, and returns it as a JSON response. The streamed data is processed asynchronously, allowing for efficient handling of potentially large payloads.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of fixtures to set up the application context (`test_app`) and to create a reusable client for making requests (`runner` and `client`). It utilizes asynchronous programming patterns with `async def` for the route handlers and the test functions, ensuring that the application can handle concurrent requests effectively. The test also leverages the Sanic testing utilities to simulate HTTP requests and validate responses, ensuring that the application behaves as expected under various conditions."
    },
    {
      "name": "test_full_message",
      "module": "test_http",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_http.py",
      "line_number": 67,
      "end_line_number": 80,
      "source_code": "def test_full_message(client):\n    client.send(\n        \"\"\"\n        GET / HTTP/1.1\n        host: localhost:7777\n\n        \"\"\"\n    )\n    response = client.recv()\n\n    # AltSvcCheck touchup removes the Alt-Svc header from the\n    # response in the Python 3.9+ in this case\n    assert len(response) == (151 if version_info < (3, 9) else 140)\n    assert b\"200 OK\" in response",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "client"
      ],
      "imports": [
        "json",
        "collections.namedtuple",
        "pathlib.Path",
        "sys.version_info",
        "pytest",
        "sanic_testing.reusable.ReusableClient",
        "sanic.json",
        "sanic.text",
        "sanic.app.Sanic",
        "tests.client.RawClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(response) == (151 if version_info < (3, 9) else 140)",
        "assert b'200 OK' in response"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "client.recv",
          "body": "def recv(**kwargs):\n    nonlocal runner\n    nonlocal raw\n    method = raw.recv_until if 'until' in kwargs else raw.recv\n    return runner._run(method(**kwargs))"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_full_message` function is designed to verify the behavior of an HTTP client when sending a GET request to a server and receiving a response. It specifically checks the length of the response and ensures that the response status indicates a successful request (200 OK).\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks two key aspects of the server's response: \n1. The length of the response, which varies based on the Python version being used (151 bytes for versions prior to 3.9 and 140 bytes for 3.9 and later).\n2. The presence of the \"200 OK\" status in the response, confirming that the request was processed successfully.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes a `client` fixture that simulates an HTTP client. The `client.send` method sends a raw HTTP GET request to the server, while `client.recv` retrieves the server's response. The response is then validated against the expected length and status. The `version_info` variable is used to determine the Python version at runtime, affecting the expected response length.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The test leverages a pytest fixture (`client`) to set up the necessary context for sending and receiving HTTP messages, promoting code reusability and separation of concerns.\n- **Conditional Assertions**: The test employs conditional logic to assert different expected outcomes based on the Python version, demonstrating adaptability in testing across different environments.\n- **Direct Response Validation**: The test directly checks the response's content and status, ensuring that the server behaves as expected under the given conditions."
    },
    {
      "name": "test_transfer_chunked",
      "module": "test_http",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_http.py",
      "line_number": 83,
      "end_line_number": 98,
      "source_code": "def test_transfer_chunked(client):\n    client.send(\n        \"\"\"\n        POST /upload HTTP/1.1\n        transfer-encoding: chunked\n\n        \"\"\"\n    )\n    client.send(b\"3\\r\\nfoo\\r\\n\")\n    client.send(b\"3\\r\\nbar\\r\\n\")\n    client.send(b\"0\\r\\n\\r\\n\")\n    response = client.recv()\n    _, body = response.rsplit(b\"\\r\\n\\r\\n\", 1)\n    data = stdjson.loads(body)\n\n    assert data == [\"foo\", \"bar\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "client"
      ],
      "imports": [
        "json",
        "collections.namedtuple",
        "pathlib.Path",
        "sys.version_info",
        "pytest",
        "sanic_testing.reusable.ReusableClient",
        "sanic.json",
        "sanic.text",
        "sanic.app.Sanic",
        "tests.client.RawClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert data == ['foo', 'bar']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "client.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "client.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "client.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "client.recv",
          "body": "def recv(**kwargs):\n    nonlocal runner\n    nonlocal raw\n    method = raw.recv_until if 'until' in kwargs else raw.recv\n    return runner._run(method(**kwargs))"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_transfer_chunked` function is designed to verify the correct handling of HTTP requests that use chunked transfer encoding. Specifically, it tests whether the server can correctly process and reconstruct the body of a POST request sent in chunks.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the server correctly receives and processes data sent in a chunked format, ensuring that the final output matches the expected list of strings. In this case, it verifies that the server can handle two chunks of data (\"foo\" and \"bar\") and that it correctly identifies the end of the data stream.\n\n**Code Being Tested and How It Works**:  \nThe test sends a POST request to the `/upload` endpoint with the `transfer-encoding: chunked` header, followed by two chunks of data (`b\"3\\r\\nfoo\\r\\n\"` and `b\"3\\r\\nbar\\r\\n\"`), and a terminating chunk (`b\"0\\r\\n\\r\\n\"`). After sending the request, it waits for the server's response using `client.recv()`. The response is then split to extract the body, which is parsed from bytes to a Python object using `stdjson.loads()`. Finally, the test asserts that the parsed data matches the expected list `[\"foo\", \"bar\"]`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Chunked Transfer Encoding**: It simulates a real-world scenario where data is sent in chunks, which is a common practice in HTTP/1.1 for streaming data.\n- **Asynchronous Testing**: The use of `async` functions and the `client` fixture indicates that the test is designed to work with asynchronous code, which is typical in web frameworks like Sanic.\n- **Assertions**: The test uses a straightforward assertion to validate the output, ensuring that the server's response matches the expected result, which is a fundamental practice in unit testing.\n- **Fixture Usage**: The `client` fixture abstracts the details of sending and receiving messages, promoting code reuse and clarity in the test."
    },
    {
      "name": "test_url_encoding",
      "module": "test_http",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_http.py",
      "line_number": 101,
      "end_line_number": 112,
      "source_code": "def test_url_encoding(client):\n    client.send(\n        \"\"\"\n        GET /invalid\\xa0url HTTP/1.1\n\n        \"\"\"\n    )\n    response = client.recv()\n    headers, body = response.rsplit(b\"\\r\\n\\r\\n\", 1)\n\n    assert b\"400 Bad Request\" in headers\n    assert b\"URL may only contain US-ASCII characters.\" in body",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "client"
      ],
      "imports": [
        "json",
        "collections.namedtuple",
        "pathlib.Path",
        "sys.version_info",
        "pytest",
        "sanic_testing.reusable.ReusableClient",
        "sanic.json",
        "sanic.text",
        "sanic.app.Sanic",
        "tests.client.RawClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert b'400 Bad Request' in headers",
        "assert b'URL may only contain US-ASCII characters.' in body"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "client.recv",
          "body": "def recv(**kwargs):\n    nonlocal runner\n    nonlocal raw\n    method = raw.recv_until if 'until' in kwargs else raw.recv\n    return runner._run(method(**kwargs))"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_url_encoding` function is designed to verify that the Sanic web framework correctly handles invalid URL encodings by returning a `400 Bad Request` response when a URL contains non-US-ASCII characters.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a URL with an invalid character (in this case, a non-breaking space represented by `\\xa0`) is sent in a GET request, the server responds with the appropriate error status and message. It ensures that the server enforces URL encoding rules by rejecting requests that do not conform to the US-ASCII character set.\n\n**Code Being Tested and How It Works**:  \nThe test sends a malformed GET request to the server using the `client.send` method. The request includes an invalid URL (`/invalid\\xa0url`). After sending the request, it waits for the server's response using `client.recv()`. The response is then split into headers and body, and assertions are made to check that the headers contain the `400 Bad Request` status and that the body includes a specific error message indicating that the URL may only contain US-ASCII characters.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertion Checks**: The test uses assertions to validate the response's headers and body, ensuring that the server behaves as expected when faced with invalid input.\n- **Fixture Usage**: The `client` argument is likely a pytest fixture that abstracts the setup and teardown of the test client, allowing for clean and reusable test code.\n- **Separation of Concerns**: The test focuses solely on the URL encoding aspect of the request handling, demonstrating a clear separation of concerns in testing different functionalities of the web framework."
    },
    {
      "name": "test_invalid_content_length",
      "module": "test_http",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_http.py",
      "line_number": 124,
      "end_line_number": 139,
      "source_code": "def test_invalid_content_length(content_length, client):\n    body = b\"Hello\" * 10\n    client.send(\n        b\"POST /upload HTTP/1.1\\r\\n\"\n        + b\"content-length: \"\n        + content_length\n        + b\"\\r\\n\\r\\n\"\n        + body\n        + b\"\\r\\n\\r\\n\"\n    )\n\n    response = client.recv()\n    headers, body = response.rsplit(b\"\\r\\n\\r\\n\", 1)\n\n    assert b\"400 Bad Request\" in headers\n    assert b\"Bad content-length\" in body",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('content_length', (b'-50', b'+50', b'5_0', b'50.5'))"
      ],
      "arguments": [
        "content_length",
        "client"
      ],
      "imports": [
        "json",
        "collections.namedtuple",
        "pathlib.Path",
        "sys.version_info",
        "pytest",
        "sanic_testing.reusable.ReusableClient",
        "sanic.json",
        "sanic.text",
        "sanic.app.Sanic",
        "tests.client.RawClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert b'400 Bad Request' in headers",
        "assert b'Bad content-length' in body"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "client.recv",
          "body": "def recv(**kwargs):\n    nonlocal runner\n    nonlocal raw\n    method = raw.recv_until if 'until' in kwargs else raw.recv\n    return runner._run(method(**kwargs))"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_invalid_content_length` function is designed to verify that the server correctly handles invalid `Content-Length` headers in HTTP requests. Specifically, it checks that the server responds with a `400 Bad Request` status and an appropriate error message when the `Content-Length` value is malformed.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the server rejects requests with invalid `Content-Length` values, such as negative numbers, non-numeric characters, or improperly formatted strings. The expected behavior is that the server should return a `400 Bad Request` response along with a message indicating that the `Content-Length` is bad.\n\n**Code Being Tested and How It Works**:  \nThe test sends a POST request to the `/upload` endpoint with a malformed `Content-Length` header followed by a body of data. The `client.send` method constructs the HTTP request, and the `client.recv` method retrieves the server's response. The response is then split into headers and body to assert that the correct status and error message are present. The relevant code being tested is the server's request handling logic that processes the `Content-Length` header.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses `pytest.mark.parametrize` to run the same test logic with multiple invalid `Content-Length` values, enhancing coverage and reducing code duplication.\n- **Assertions**: The test employs assertions to validate the response's status and body content, ensuring that the server behaves as expected under various input conditions.\n- **Fixture Usage**: The `client` fixture is utilized to simulate HTTP client behavior, allowing for easy sending and receiving of requests and responses in a controlled testing environment."
    },
    {
      "name": "test_invalid_chunk_length",
      "module": "test_http",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_http.py",
      "line_number": 151,
      "end_line_number": 167,
      "source_code": "def test_invalid_chunk_length(chunk_length, client):\n    body = b\"Hello\" * 10\n    client.send(\n        b\"POST /upload HTTP/1.1\\r\\n\"\n        + b\"transfer-encoding: chunked\\r\\n\\r\\n\"\n        + chunk_length\n        + b\"\\r\\n\"\n        + body\n        + b\"\\r\\n\"\n        + b\"0\\r\\n\\r\\n\"\n    )\n\n    response = client.recv()\n    headers, body = response.rsplit(b\"\\r\\n\\r\\n\", 1)\n\n    assert b\"400 Bad Request\" in headers\n    assert b\"Bad chunked encoding\" in body",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('chunk_length', (b'-50', b'+50', b'5_0', b'50.5'))"
      ],
      "arguments": [
        "chunk_length",
        "client"
      ],
      "imports": [
        "json",
        "collections.namedtuple",
        "pathlib.Path",
        "sys.version_info",
        "pytest",
        "sanic_testing.reusable.ReusableClient",
        "sanic.json",
        "sanic.text",
        "sanic.app.Sanic",
        "tests.client.RawClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert b'400 Bad Request' in headers",
        "assert b'Bad chunked encoding' in body"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "client.recv",
          "body": "def recv(**kwargs):\n    nonlocal runner\n    nonlocal raw\n    method = raw.recv_until if 'until' in kwargs else raw.recv\n    return runner._run(method(**kwargs))"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_invalid_chunk_length` unit test is designed to verify that the server correctly handles invalid chunk lengths in HTTP requests using chunked transfer encoding. Specifically, it checks that the server responds with a \"400 Bad Request\" status and an appropriate error message when the chunk length is malformed.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when the client sends a POST request with an invalid chunk length (e.g., negative values, non-numeric characters), the server responds with a 400 status code and a message indicating \"Bad chunked encoding.\" This behavior is crucial for maintaining the integrity of HTTP communication and preventing malformed requests from being processed.\n\n**Code Being Tested and How It Works**:  \nThe test sends a POST request to the `/upload` endpoint with a header indicating chunked transfer encoding. The body of the request includes an invalid chunk length followed by a valid data chunk and a terminating zero-length chunk. The server's request handling code processes the incoming data, checks the validity of the chunk length, and raises a `BadRequest` exception if the length is invalid. The test then captures the server's response and asserts that it contains the expected error status and message.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses `pytest.mark.parametrize` to run the same test logic with multiple invalid chunk lengths, enhancing coverage and ensuring that various edge cases are tested efficiently.\n- **Assertions**: The test employs assertions to validate the response headers and body, ensuring that the server's behavior aligns with the expected outcomes for invalid input.\n- **Fixture Usage**: The `client` fixture is utilized to simulate the HTTP client, allowing for controlled sending and receiving of requests and responses during the test. This encapsulates the setup and teardown of the test environment, promoting reusability and clarity."
    },
    {
      "name": "test_smuggle",
      "module": "test_http",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_http.py",
      "line_number": 170,
      "end_line_number": 193,
      "source_code": "def test_smuggle(client):\n    client.send(\n        \"\"\"\n        POST /upload HTTP/1.1\n        Content-Length: 5\n        Transfer-Encoding: chunked\n        Transfer-Encoding: xchunked\n\n        5\n        hello\n        0\n\n        GET / HTTP/1.1\n        \n        \"\"\"  # noqa\n    )\n\n    response = client.recv()\n    num_responses = response.count(b\"HTTP/1.1\")\n    assert num_responses == 1\n\n    headers, body = response.rsplit(b\"\\r\\n\\r\\n\", 1)\n    assert b\"400 Bad Request\" in headers\n    assert b\"Bad Request\" in body",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "client"
      ],
      "imports": [
        "json",
        "collections.namedtuple",
        "pathlib.Path",
        "sys.version_info",
        "pytest",
        "sanic_testing.reusable.ReusableClient",
        "sanic.json",
        "sanic.text",
        "sanic.app.Sanic",
        "tests.client.RawClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert num_responses == 1",
        "assert b'400 Bad Request' in headers",
        "assert b'Bad Request' in body"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "client.recv",
          "body": "def recv(**kwargs):\n    nonlocal runner\n    nonlocal raw\n    method = raw.recv_until if 'until' in kwargs else raw.recv\n    return runner._run(method(**kwargs))"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_smuggle` function is designed to verify the behavior of the HTTP server when it receives a malformed request that includes multiple `Transfer-Encoding` headers. Specifically, it checks that the server correctly identifies this as a bad request and responds with a `400 Bad Request` status.\n\n**Specific Functionality or Behavior Verified**:  \nThe test ensures that the server processes the incoming request and only returns a single HTTP response. It also verifies that the response contains the appropriate status code and message indicating a bad request, confirming that the server handles protocol violations correctly.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with a `client` object that simulates an HTTP client. It sends a crafted HTTP request with conflicting `Transfer-Encoding` headers and a subsequent `GET` request. The `client.recv()` method is then called to receive the server's response. The test checks that the response contains exactly one HTTP response and that it includes the expected `400 Bad Request` status in the headers and body.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The `client` is provided as a fixture, allowing for easy setup and teardown of the test environment.\n- **Assertions**: The test employs assertions to validate the number of responses and the content of the response, ensuring that the server behaves as expected under erroneous conditions.\n- **Raw HTTP Message Simulation**: The test sends a raw HTTP message, which is a common technique in testing HTTP servers to simulate real-world scenarios and edge cases."
    },
    {
      "name": "test_logo_base",
      "module": "test_motd",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_motd.py",
      "line_number": 23,
      "end_line_number": 27,
      "source_code": "def test_logo_base(app, run_startup):\n    logs = run_startup(app)\n\n    assert logs[0][1] == logging.DEBUG\n    assert logs[0][2] == BASE_LOGO",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "run_startup"
      ],
      "imports": [
        "logging",
        "os",
        "platform",
        "sys",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.__version__",
        "sanic.application.logo.BASE_LOGO",
        "sanic.application.motd.MOTD",
        "sanic.application.motd.MOTDTTY"
      ],
      "fixtures": [],
      "assertions": [
        "assert logs[0][1] == logging.DEBUG",
        "assert logs[0][2] == BASE_LOGO"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "run_startup",
          "body": "@pytest.fixture(scope='function')\ndef run_startup(caplog):\n\n    def run(app):\n        nonlocal caplog\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n        with caplog.at_level(logging.DEBUG):\n            server = app.create_server(debug=True, return_asyncio_server=True, port=PORT)\n            loop._stopping = False\n            _server = loop.run_until_complete(server)\n            _server.close()\n            loop.run_until_complete(_server.wait_closed())\n            app.stop()\n        return caplog.record_tuples\n    return run"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_logo_base` function is designed to verify that the logging behavior of the Sanic application correctly logs the base logo at the DEBUG level when the application starts up.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks two specific assertions: \n1. It confirms that the first log entry recorded during the application startup is at the DEBUG level.\n2. It verifies that the content of the first log entry matches the expected `BASE_LOGO` constant.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the `run_startup` fixture, which sets up a new event loop, starts the Sanic application server, and captures log messages generated during the startup process. The `app.create_server` method is called with `debug=True`, which enables detailed logging. The logs are captured using the `caplog` fixture, and the test then inspects the first log entry to ensure it meets the expected criteria.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixtures**: The use of the `run_startup` fixture allows for reusable setup code that initializes the application and captures logs, promoting DRY (Don't Repeat Yourself) principles.\n- **Log Capture**: The `caplog` fixture is employed to capture log messages, enabling assertions on log content and levels, which is a common technique in testing logging behavior.\n- **Asynchronous Testing**: The test leverages asyncio to handle the asynchronous nature of the Sanic application, ensuring that the server is properly started and stopped within the test context."
    },
    {
      "name": "test_motd_with_expected_info",
      "module": "test_motd",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_motd.py",
      "line_number": 30,
      "end_line_number": 38,
      "source_code": "def test_motd_with_expected_info(app, run_startup):\n    logs = run_startup(app)\n\n    assert logs[1][2] == f\"Sanic v{__version__}\"\n    assert logs[3][2] == \"app: test_motd_with_expected_info\"\n    assert logs[4][2] == \"mode: debug, single worker\"\n    assert logs[5][2] == \"server: sanic, HTTP/1.1\"\n    assert logs[6][2] == f\"python: {platform.python_version()}\"\n    assert logs[7][2] == f\"platform: {platform.platform()}\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "run_startup"
      ],
      "imports": [
        "logging",
        "os",
        "platform",
        "sys",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.__version__",
        "sanic.application.logo.BASE_LOGO",
        "sanic.application.motd.MOTD",
        "sanic.application.motd.MOTDTTY"
      ],
      "fixtures": [],
      "assertions": [
        "assert logs[1][2] == f'Sanic v{__version__}'",
        "assert logs[3][2] == 'app: test_motd_with_expected_info'",
        "assert logs[4][2] == 'mode: debug, single worker'",
        "assert logs[5][2] == 'server: sanic, HTTP/1.1'",
        "assert logs[6][2] == f'python: {platform.python_version()}'",
        "assert logs[7][2] == f'platform: {platform.platform()}'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "run_startup",
          "body": "@pytest.fixture(scope='function')\ndef run_startup(caplog):\n\n    def run(app):\n        nonlocal caplog\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n        with caplog.at_level(logging.DEBUG):\n            server = app.create_server(debug=True, return_asyncio_server=True, port=PORT)\n            loop._stopping = False\n            _server = loop.run_until_complete(server)\n            _server.close()\n            loop.run_until_complete(_server.wait_closed())\n            app.stop()\n        return caplog.record_tuples\n    return run"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_motd_with_expected_info` unit test is designed to verify that the startup logs of a Sanic application contain the expected information about the application, including its version, mode, server type, Python version, and platform details. This ensures that the application is correctly configured and provides the necessary information upon startup.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks specific log entries generated during the startup of the Sanic application. It asserts that the logs contain the correct version of Sanic, the name of the application, the mode in which it is running (debug mode with a single worker), the server type, and the Python and platform versions. Each assertion corresponds to a specific log entry, ensuring that the application outputs the expected messages.\n\n**Code Being Tested and How It Works**:  \nThe code being tested involves the `run_startup` fixture, which sets up a new event loop, runs the Sanic application, and captures the logs generated during the startup process. The `app.create_server` method is called with debug mode enabled, and the logs are captured using the `caplog` fixture. After the server is started, it is closed, and the captured logs are returned for assertions. The assertions in the test compare the captured log entries against expected values, which are formatted strings that include dynamic content like the Sanic version and Python version.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable testing patterns:\n- **Fixtures**: The `run_startup` fixture is used to encapsulate the setup and teardown logic for running the application and capturing logs, promoting code reuse and clarity.\n- **Assertions**: The test uses simple assertions to verify that specific log entries match expected values, which is a straightforward approach to validate output.\n- **Dynamic Content Handling**: The test dynamically constructs expected log messages using formatted strings, ensuring that the test remains valid even if the version numbers change.\n- **Logging Capture**: The use of `caplog` allows for effective capturing and inspection of log messages, which is essential for verifying logging behavior in applications."
    },
    {
      "name": "test_motd_init",
      "module": "test_motd",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_motd.py",
      "line_number": 41,
      "end_line_number": 47,
      "source_code": "def test_motd_init():\n    _orig = MOTDTTY.set_variables\n    MOTDTTY.set_variables = Mock()\n    motd = MOTDTTY(None, \"\", {}, {})\n\n    motd.set_variables.assert_called_once()\n    MOTDTTY.set_variables = _orig",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "os",
        "platform",
        "sys",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.__version__",
        "sanic.application.logo.BASE_LOGO",
        "sanic.application.motd.MOTD",
        "sanic.application.motd.MOTDTTY"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_motd_init` function is designed to verify that the `set_variables` method of the `MOTDTTY` class is called exactly once during the initialization of an instance of `MOTDTTY`. This ensures that the necessary setup for the message of the day (MOTD) is performed correctly when an instance is created.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that the `set_variables` method is invoked during the instantiation of the `MOTDTTY` class. This is crucial for ensuring that any required variables or configurations are set up properly when the MOTD is initialized.\n\n**Code Being Tested and How It Works**:  \nThe test temporarily replaces the `set_variables` method of the `MOTDTTY` class with a mock object using `Mock()`. This allows the test to track whether the method is called without executing its original functionality. After creating an instance of `MOTDTTY`, the test asserts that `set_variables` was called exactly once. Finally, it restores the original `set_variables` method to maintain the integrity of the class for subsequent tests.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The use of `Mock()` allows the test to intercept calls to `set_variables` without executing its actual implementation, which is a common practice in unit testing to isolate the behavior being tested.\n- **State Restoration**: The test saves the original `set_variables` method and restores it after the test completes, ensuring that the test does not have side effects on other tests that may rely on the original method.\n- **Assertion**: The use of `assert_called_once()` provides a clear and concise way to verify that the method was called the expected number of times, which is a fundamental aspect of unit testing to ensure correctness."
    },
    {
      "name": "test_motd_display",
      "module": "test_motd",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_motd.py",
      "line_number": 50,
      "end_line_number": 69,
      "source_code": "def test_motd_display(caplog):\n    motd = MOTDTTY(\"       foobar        \", \"\", {\"one\": \"1\"}, {\"two\": \"2\"})\n\n    with caplog.at_level(logging.INFO):\n        motd.display()\n\n    version_line = f\"Sanic v{__version__}\".center(motd.centering_length)\n    assert (\n        \"\".join(caplog.messages)\n        == f\"\"\"\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502 {version_line} \u2502\n  \u2502                                \u2502\n  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n  \u2502        foobar         \u2502 one: 1 \u2502\n  \u2502                       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n  \u2502                       \u2502 two: 2 \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\"\"\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "caplog"
      ],
      "imports": [
        "logging",
        "os",
        "platform",
        "sys",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.__version__",
        "sanic.application.logo.BASE_LOGO",
        "sanic.application.motd.MOTD",
        "sanic.application.motd.MOTDTTY"
      ],
      "fixtures": [],
      "assertions": [
        "assert ''.join(caplog.messages) == f'\\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n  \u2502 {version_line} \u2502\\n  \u2502                                \u2502\\n  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n  \u2502        foobar         \u2502 one: 1 \u2502\\n  \u2502                       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n  \u2502                       \u2502 two: 2 \u2502\\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "motd.display",
          "body": "@app.on_response\ndef display(_, response):\n    response['foo'] = 'bar'\n    return json(response)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_motd_display` test is to verify that the `display` method of the `MOTDTTY` class correctly formats and logs the message of the day (MOTD) with the expected output structure, including the version of the Sanic framework and additional data.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when the `display` method is called, it produces a well-structured log message that includes the Sanic version, a provided message (\"foobar\"), and key-value pairs from the additional data dictionaries. It ensures that the output matches a predefined format, which is crucial for maintaining consistent logging behavior.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `display` method of the `MOTDTTY` class. This method constructs a formatted string that includes the Sanic version, a running action, and additional data. It uses various string manipulation techniques to center and format the output, and it logs the final result using the `logger.info` method. The test creates an instance of `MOTDTTY` with specific parameters and captures the log output using the `caplog` fixture.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `caplog` fixture from pytest to capture log messages at a specified logging level (INFO in this case). It uses assertions to compare the actual log output against an expected formatted string, ensuring that the output matches the intended design. The test also utilizes string manipulation techniques to create the expected output dynamically, which helps in maintaining flexibility in the test as the code evolves."
    },
    {
      "name": "test_reload_dirs",
      "module": "test_motd",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_motd.py",
      "line_number": 73,
      "end_line_number": 84,
      "source_code": "def test_reload_dirs(app):\n    app.config.LOGO = None\n    app.config.MOTD = True\n    app.config.AUTO_RELOAD = True\n\n    with patch.object(MOTD, \"output\") as mock:\n        app.prepare(\n            reload_dir=\"./\", auto_reload=True, motd_display={\"foo\": \"bar\"}\n        )\n    mock.assert_called()\n    assert mock.call_args.args[2][\"auto-reload\"] == f\"enabled, {os.getcwd()}\"\n    assert mock.call_args.args[3] == {\"foo\": \"bar\"}",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(sys.version_info < (3, 8), reason='Not on 3.7')"
      ],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "platform",
        "sys",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.__version__",
        "sanic.application.logo.BASE_LOGO",
        "sanic.application.motd.MOTD",
        "sanic.application.motd.MOTDTTY"
      ],
      "fixtures": [],
      "assertions": [
        "assert mock.call_args.args[2]['auto-reload'] == f'enabled, {os.getcwd()}'",
        "assert mock.call_args.args[3] == {'foo': 'bar'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_reload_dirs` function is designed to verify the behavior of the `app.prepare` method in the Sanic application framework when the application is configured for auto-reloading. Specifically, it checks that the correct parameters are passed to the `MOTD.output` method when the application is prepared for reloading.\n\n**Specific Functionality or Behavior Verified**:  \nThe test ensures that when the application is set to auto-reload, the `MOTD.output` method is called with the expected arguments. It verifies that the `auto-reload` argument is correctly formatted to indicate that it is enabled, along with the current working directory, and that the `motd_display` argument is passed as expected.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `app.prepare` method, which is invoked with specific parameters: `reload_dir`, `auto_reload`, and `motd_display`. The test uses the `patch.object` function from the `unittest.mock` module to replace the `MOTD.output` method with a mock object, allowing the test to assert that it was called and to inspect the arguments it received. The assertions check that the third and fourth arguments of the call match the expected values.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test employs mocking to isolate the `MOTD.output` method, allowing the test to focus on verifying the interaction without executing the actual method.\n- **Assertions**: It uses assertions to validate that the method was called and that the arguments passed to it are correct, ensuring that the application behaves as intended under the specified configuration.\n- **Context Management**: The use of a `with` statement for the mock ensures that the mock is only active within that block, maintaining clean test isolation."
    },
    {
      "name": "test_shutdown_tasks_on_app_stop",
      "module": "test_tasks",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tasks.py",
      "line_number": 95,
      "end_line_number": 110,
      "source_code": "def test_shutdown_tasks_on_app_stop():\n    class TestSanic(Sanic):\n        shutdown_tasks = Mock()\n\n    app = TestSanic(\"Test\")\n\n    @app.route(\"/\")\n    async def handler(_):\n        return empty()\n\n    app.test_client.get(\"/\")\n\n    app.shutdown_tasks.call_args == [\n        call(timeout=0),\n        call(15.0),\n    ]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "asyncio.tasks.Task",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "sanic.app.Sanic",
        "sanic.application.state.ApplicationServerInfo",
        "sanic.application.state.ServerStage",
        "sanic.response.empty",
        "unittest.mock.AsyncMock",
        "tests.asyncmock.AsyncMock"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_shutdown_tasks_on_app_stop` test is designed to verify that the shutdown tasks of a Sanic application are correctly invoked when the application is stopped. This ensures that any necessary cleanup or finalization tasks are executed, which is crucial for maintaining application stability and resource management.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that the `shutdown_tasks` method is called with the expected arguments when the application is stopped. It asserts that the shutdown tasks are triggered with a timeout of `0` and `15.0` seconds, indicating that the application is handling shutdown procedures as intended.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves a subclass of the `Sanic` application, `TestSanic`, which mocks the `shutdown_tasks` method. The test sets up a simple route and makes a GET request to it, which simulates the application running. After the request, it checks the call arguments of the mocked `shutdown_tasks` to ensure they match the expected values. The `app.test_client.get(\"/\")` line simulates a client request to the application, which would typically trigger the shutdown process.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs mocking using the `Mock` class from the `unittest.mock` module to replace the actual `shutdown_tasks` method with a mock object. This allows the test to verify interactions with the method without executing its real implementation. Additionally, the use of assertions to compare the call arguments of the mock provides a clear and effective way to validate that the application behaves as expected during the shutdown process."
    },
    {
      "name": "test_app_loop_running",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 31,
      "end_line_number": 38,
      "source_code": "def test_app_loop_running(app: Sanic):\n    @app.get(\"/test\")\n    async def handler(request):\n        assert isinstance(app.loop, asyncio.AbstractEventLoop)\n        return text(\"pass\")\n\n    request, response = app.test_client.get(\"/test\")\n    assert response.text == \"pass\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'pass'",
        "assert isinstance(app.loop, asyncio.AbstractEventLoop)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_app_loop_running` test is designed to verify that the Sanic application is correctly utilizing an asyncio event loop. It checks that the application\u2019s loop is an instance of `asyncio.AbstractEventLoop`, ensuring that the application is set up to handle asynchronous operations properly.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically verifies two behaviors: \n1. It confirms that the application\u2019s event loop is of the correct type (`asyncio.AbstractEventLoop`), which is crucial for asynchronous programming in Python.\n2. It checks that the HTTP GET request to the `/test` endpoint returns the expected response text \"pass\", indicating that the request handling is functioning correctly.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route handler for the `/test` endpoint using the `@app.get` decorator. Inside this handler, it asserts that `app.loop` is an instance of `asyncio.AbstractEventLoop`. The handler then returns a simple text response \"pass\". The test client makes a GET request to this endpoint, and the response is checked to ensure it matches the expected output. The relevant methods being tested are `app.get` for route registration and `app.test_client.get` for simulating the HTTP request.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Asynchronous Testing**: It uses asynchronous functions to handle requests and responses, which is essential for testing applications built on asynchronous frameworks like Sanic.\n- **Direct Assertion**: The test includes direct assertions within the handler to validate the state of the application\u2019s loop, demonstrating a clear and immediate check of the application\u2019s configuration.\n- **Integration Testing**: By making an actual HTTP request to the application, the test serves as an integration test, ensuring that the routing and response mechanisms work together as expected."
    },
    {
      "name": "test_create_asyncio_server",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 42,
      "end_line_number": 47,
      "source_code": "def test_create_asyncio_server(app: Sanic, port: int):\n    loop = asyncio.get_event_loop()\n    asyncio_srv_coro = app.create_server(return_asyncio_server=True, port=port)\n    assert isawaitable(asyncio_srv_coro)\n    srv = loop.run_until_complete(asyncio_srv_coro)\n    assert srv.is_serving() is True",
      "docstring": null,
      "decorators": [
        "pytest.mark.asyncio"
      ],
      "arguments": [
        "app",
        "port"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert isawaitable(asyncio_srv_coro)",
        "assert srv.is_serving() is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_create_asyncio_server` function is designed to verify that the `create_server` method of the Sanic application correctly returns an awaitable coroutine that, when awaited, produces a server instance that is actively serving requests.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks two key behaviors: first, it confirms that the coroutine returned by `create_server` is indeed awaitable, ensuring that it can be awaited in an asynchronous context. Second, it verifies that the server instance returned from the coroutine is in a serving state, indicating that it is ready to handle incoming requests.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `create_server` method of the Sanic application, which is expected to return a coroutine when called with the `return_asyncio_server=True` argument. The test uses `asyncio.get_event_loop()` to obtain the current event loop and then runs the coroutine using `loop.run_until_complete()`. After awaiting the coroutine, it checks the `is_serving()` method of the returned server instance to ensure it is serving.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate expected outcomes, specifically checking for awaitability and the server's serving state. It also utilizes the asyncio event loop to manage asynchronous operations, which is a common pattern in testing asynchronous code. The test is structured to be straightforward, focusing on a single aspect of functionality, which is a best practice in unit testing to ensure clarity and maintainability."
    },
    {
      "name": "test_asyncio_server_no_start_serving",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 51,
      "end_line_number": 59,
      "source_code": "def test_asyncio_server_no_start_serving(app: Sanic, port):\n    loop = asyncio.get_event_loop()\n    asyncio_srv_coro = app.create_server(\n        port=port,\n        return_asyncio_server=True,\n        asyncio_server_kwargs=dict(start_serving=False),\n    )\n    srv = loop.run_until_complete(asyncio_srv_coro)\n    assert srv.is_serving() is False",
      "docstring": null,
      "decorators": [
        "pytest.mark.asyncio"
      ],
      "arguments": [
        "app",
        "port"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert srv.is_serving() is False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_asyncio_server_no_start_serving` is designed to verify that when a Sanic server is created with the `start_serving` option set to `False`, the server does not start serving requests immediately. This ensures that the server's behavior aligns with the expected configuration when it is initialized.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that the server instance returned by `app.create_server` is not in a serving state immediately after creation. The assertion `assert srv.is_serving() is False` confirms that the server is correctly configured to not serve requests until explicitly instructed to do so.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `create_server` method of the Sanic application, which is responsible for setting up an asyncio server. The method is called with `asyncio_server_kwargs` that includes `start_serving=False`. This configuration prevents the server from starting to serve requests right away. The test uses the asyncio event loop to run the coroutine that creates the server and then checks the state of the server using the `is_serving()` method.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of asynchronous testing with the asyncio event loop, which is a common pattern in modern Python applications that utilize asynchronous programming. It also utilizes assertions to validate the state of the server, ensuring that the test is both clear and effective in confirming the expected behavior. The use of `asyncio.get_event_loop()` and `loop.run_until_complete()` demonstrates a typical approach to managing asynchronous operations in unit tests."
    },
    {
      "name": "test_asyncio_server_start_serving",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 63,
      "end_line_number": 76,
      "source_code": "def test_asyncio_server_start_serving(app: Sanic):\n    loop = asyncio.get_event_loop()\n    asyncio_srv_coro = app.create_server(\n        port=43124,\n        return_asyncio_server=True,\n        asyncio_server_kwargs=dict(start_serving=False),\n    )\n    srv = loop.run_until_complete(asyncio_srv_coro)\n    assert srv.is_serving() is False\n    loop.run_until_complete(srv.startup())\n    loop.run_until_complete(srv.start_serving())\n    assert srv.is_serving() is True\n    wait_close = srv.close()\n    loop.run_until_complete(wait_close)",
      "docstring": null,
      "decorators": [
        "pytest.mark.asyncio"
      ],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert srv.is_serving() is False",
        "assert srv.is_serving() is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_asyncio_server_start_serving` test is to verify the behavior of the Sanic server when it is created with the `start_serving` option set to `False`. It ensures that the server does not start serving requests immediately upon creation and only begins serving after explicitly calling the `start_serving()` method.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks two key behaviors: \n1. It confirms that the server is not serving immediately after creation (`srv.is_serving()` returns `False`).\n2. It verifies that after calling `startup()` and `start_serving()`, the server successfully transitions to a serving state (`srv.is_serving()` returns `True`).\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `create_server` method of the Sanic application, which returns a coroutine for creating an `AsyncioServer`. The server is instantiated with `start_serving` set to `False`, meaning it should not start serving requests right away. The test then:\n- Awaits the server creation coroutine to get the server instance.\n- Asserts that the server is not serving.\n- Calls `startup()` to initialize the server.\n- Calls `start_serving()` to begin serving requests.\n- Asserts that the server is now serving.\n- Finally, it closes the server to clean up resources.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Asynchronous Testing**: It uses `asyncio` to handle asynchronous operations, ensuring that the server's lifecycle methods are awaited properly.\n- **Assertions**: It uses assertions to validate the server's state before and after specific method calls, ensuring that the server behaves as expected.\n- **Event Loop Management**: The test directly interacts with the event loop to run coroutines, demonstrating a common pattern in testing asynchronous code in Python."
    },
    {
      "name": "test_create_server_main",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 81,
      "end_line_number": 94,
      "source_code": "def test_create_server_main(app: Sanic, caplog, port):\n    app.listener(\"main_process_start\")(lambda *_: ...)\n    loop = asyncio.get_event_loop()\n    with caplog.at_level(logging.INFO):\n        asyncio_srv_coro = app.create_server(\n            return_asyncio_server=True, port=port\n        )\n        loop.run_until_complete(asyncio_srv_coro)\n    assert (\n        \"sanic.root\",\n        30,\n        \"Listener events for the main process are not available with \"\n        \"create_server()\",\n    ) in caplog.record_tuples",
      "docstring": null,
      "decorators": [
        "pytest.mark.asyncio"
      ],
      "arguments": [
        "app",
        "caplog",
        "port"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert ('sanic.root', 30, 'Listener events for the main process are not available with create_server()') in caplog.record_tuples"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_create_server_main` test is designed to verify that the Sanic application correctly logs a specific message when the main process starts and the server is created using the `create_server()` method. This ensures that the application behaves as expected in terms of logging listener events.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when the server is created, a log entry is generated indicating that listener events for the main process are not available. This is important for understanding the limitations of the `create_server()` method in the context of the Sanic application lifecycle.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `create_server()` method of the Sanic application. It sets up a listener for the \"main_process_start\" event, which is expected to log a message when the server is created. The test uses the `caplog` fixture to capture log messages at the INFO level. After invoking `create_server()`, it asserts that the specific log message is present in the captured logs, confirming that the expected behavior occurred.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The test utilizes the `caplog` fixture from pytest to capture log messages, allowing for easy verification of logging behavior.\n- **Asynchronous Testing**: The test is marked with `@pytest.mark.asyncio`, indicating that it is an asynchronous test, which is essential for testing the asynchronous nature of the Sanic framework.\n- **Event Listener**: The test demonstrates the use of event listeners in Sanic, showcasing how to register a listener for specific application lifecycle events and verify their behavior through logging."
    },
    {
      "name": "test_create_server_no_startup",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 98,
      "end_line_number": 110,
      "source_code": "def test_create_server_no_startup(app: Sanic, port):\n    loop = asyncio.get_event_loop()\n    asyncio_srv_coro = app.create_server(\n        port=port,\n        return_asyncio_server=True,\n        asyncio_server_kwargs=dict(start_serving=False),\n    )\n    srv = loop.run_until_complete(asyncio_srv_coro)\n    message = (\n        \"Cannot run Sanic server without first running await server.startup()\"\n    )\n    with pytest.raises(SanicException, match=message):\n        loop.run_until_complete(srv.start_serving())",
      "docstring": null,
      "decorators": [
        "pytest.mark.asyncio"
      ],
      "arguments": [
        "app",
        "port"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_create_server_no_startup` test is to verify that attempting to start a Sanic server without first invoking the `startup()` method raises the appropriate exception (`SanicException`). This ensures that the server lifecycle is correctly enforced, preventing misuse of the server API.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the server cannot be started (via `start_serving()`) unless it has been properly initialized with `await server.startup()`. The test expects a `SanicException` to be raised with a specific error message when this condition is violated.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `create_server` method of the Sanic application, which creates an instance of the server but does not start it. The test sets the `start_serving` argument to `False` in the `asyncio_server_kwargs`, indicating that the server should not start serving immediately. After creating the server instance, the test attempts to call `srv.start_serving()`, which should fail because the server has not gone through the necessary startup process.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that an exception is raised during the execution of `srv.start_serving()`. This is a common pattern in unit testing for verifying that specific error conditions are handled correctly. Additionally, the use of `asyncio` to manage asynchronous operations is notable, as it reflects the asynchronous nature of the Sanic framework and ensures that the test runs in an event loop context."
    },
    {
      "name": "test_create_server_main_convenience",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 114,
      "end_line_number": 127,
      "source_code": "def test_create_server_main_convenience(app: Sanic, caplog, port):\n    app.main_process_start(lambda *_: ...)\n    loop = asyncio.get_event_loop()\n    with caplog.at_level(logging.INFO):\n        asyncio_srv_coro = app.create_server(\n            return_asyncio_server=True, port=port\n        )\n        loop.run_until_complete(asyncio_srv_coro)\n    assert (\n        \"sanic.root\",\n        30,\n        \"Listener events for the main process are not available with \"\n        \"create_server()\",\n    ) in caplog.record_tuples",
      "docstring": null,
      "decorators": [
        "pytest.mark.asyncio"
      ],
      "arguments": [
        "app",
        "caplog",
        "port"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert ('sanic.root', 30, 'Listener events for the main process are not available with create_server()') in caplog.record_tuples"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.main_process_start",
          "body": "@app.listener('main_process_start')\ndef main_process_start(app, loop):\n    logger.info('main_process_start')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_create_server_main_convenience` test is designed to verify that the Sanic application correctly logs an informational message when the main process starts and the server is created using the `create_server` method. This ensures that the application behaves as expected in terms of logging important lifecycle events.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that when the server is created, the log message indicating that listener events for the main process are not available is recorded. This is important for understanding the server's operational state and ensuring that the application correctly handles lifecycle events.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `app.main_process_start` listener, which logs a message when the main process starts. The test invokes this listener by calling `app.main_process_start(lambda *_: ...)`, simulating the start of the main process. It then creates the server using `app.create_server`, and the test checks the log records captured by `caplog` to assert that the expected log message is present.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `caplog` fixture from pytest to capture log messages at a specified logging level (INFO in this case). It also uses the asyncio event loop to run asynchronous code, ensuring that the server creation and logging occur within the correct context. The use of assertions to check the contents of `caplog.record_tuples` is a common pattern for verifying logging behavior in tests."
    },
    {
      "name": "test_app_loop_not_running",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 130,
      "end_line_number": 137,
      "source_code": "def test_app_loop_not_running(app: Sanic):\n    with pytest.raises(SanicException) as excinfo:\n        app.loop\n\n    assert str(excinfo.value) == (\n        \"Loop can only be retrieved after the app has started \"\n        \"running. Not supported with `create_server` function\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(excinfo.value) == 'Loop can only be retrieved after the app has started running. Not supported with `create_server` function'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_app_loop_not_running` test is designed to verify that an attempt to access the event loop of a Sanic application before it has started running raises the appropriate exception. This ensures that the application behaves correctly and prevents misuse of the API.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that accessing the `app.loop` property raises a `SanicException` when the application is not in a running state. It confirms that the error message returned is accurate and informative, guiding the user on the correct usage of the application.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `app.loop` property of the Sanic application. When the application is not running (i.e., it has not been started with `app.run()` or similar methods), accessing `app.loop` should trigger a `SanicException`. The test captures this exception and asserts that the message matches the expected output, which indicates that the loop can only be accessed after the application has started.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that an exception is raised during the execution of the code block. This is a common pattern in unit testing for verifying that specific error conditions are handled correctly. Additionally, the test checks the exception message to ensure it provides clear guidance on the error, which is a good practice for user-facing APIs."
    },
    {
      "name": "test_app_run_raise_type_error",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 140,
      "end_line_number": 149,
      "source_code": "def test_app_run_raise_type_error(app: Sanic, port):\n    with pytest.raises(TypeError) as excinfo:\n        app.run(loop=\"loop\", port=port)\n\n    assert str(excinfo.value) == (\n        \"loop is not a valid argument. To use an existing loop, \"\n        \"change to create_server().\\nSee more: \"\n        \"https://sanic.readthedocs.io/en/latest/sanic/deploying.html\"\n        \"#asynchronous-support\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "port"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(excinfo.value) == 'loop is not a valid argument. To use an existing loop, change to create_server().\\nSee more: https://sanic.readthedocs.io/en/latest/sanic/deploying.html#asynchronous-support'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_app_run_raise_type_error` is designed to verify that the `app.run()` method of the Sanic application raises a `TypeError` when an invalid argument (`loop=\"loop\"`) is passed. This ensures that the application correctly handles erroneous input and provides informative error messages.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that when the `loop` parameter is incorrectly set to a string instead of a valid loop object, the application raises a `TypeError`. It also verifies that the error message returned is accurate and informative, guiding the user on how to properly use the `create_server()` method instead.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `app.run()` method, which is expected to start the Sanic application. The method is invoked with a string argument for `loop`, which is not a valid input. The test captures the exception raised and checks the message against an expected string that explains the error and provides a link to the documentation for further guidance.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that a specific exception is raised during the execution of the code block. This is a common pattern in unit testing for verifying that error handling works as intended. Additionally, the test includes an assertion to compare the actual error message with an expected string, ensuring that the error handling not only occurs but also provides meaningful feedback to the user."
    },
    {
      "name": "test_app_route_raise_value_error",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 152,
      "end_line_number": 162,
      "source_code": "def test_app_route_raise_value_error(app: Sanic):\n    with pytest.raises(ValueError) as excinfo:\n\n        @app.route(\"/test\")\n        async def handler():\n            return text(\"test\")\n\n    assert (\n        str(excinfo.value)\n        == \"Required parameter `request` missing in the handler() route?\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(excinfo.value) == 'Required parameter `request` missing in the handler() route?'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_app_route_raise_value_error` is designed to verify that a `ValueError` is raised when a route handler is defined without the required `request` parameter in the Sanic web framework. This ensures that the framework enforces the correct signature for route handlers.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that when a route is defined without the necessary `request` argument, a `ValueError` is raised with a specific error message. This behavior is crucial for maintaining the integrity of route definitions in the application.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves defining a route handler for the path `/test` without including the `request` parameter. The test uses the `pytest.raises` context manager to assert that a `ValueError` is raised when the handler is registered. The expected error message is then compared to ensure it matches the anticipated output, which indicates that the framework correctly identifies the missing parameter.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that an exception is raised during the execution of the code block. This is a common pattern in unit testing for verifying that specific error conditions are met. Additionally, the use of an assertion to check the error message ensures that not only is the exception raised, but it also conveys the correct information about the nature of the error. This combination of exception handling and message verification is a robust approach to testing error conditions in Python applications."
    },
    {
      "name": "test_app_handle_request_handler_is_none",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 165,
      "end_line_number": 185,
      "source_code": "def test_app_handle_request_handler_is_none(app: Sanic, monkeypatch):\n    app.config.TOUCHUP = False\n    route = Mock(spec=Route)\n    route.extra.request_middleware = []\n    route.extra.response_middleware = []\n\n    def mockreturn(*args, **kwargs):\n        return route, None, {}\n\n    monkeypatch.setattr(app.router, \"get\", mockreturn)\n\n    @app.get(\"/test\")\n    def handler(request):\n        return text(\"test\")\n\n    _, response = app.test_client.get(\"/test\")\n\n    assert (\n        \"'None' was returned while requesting a handler from the router\"\n        in response.text\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "monkeypatch"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert \"'None' was returned while requesting a handler from the router\" in response.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the test `test_app_handle_request_handler_is_none` is to verify the behavior of the Sanic application when a request is made to a route that does not have a valid handler. Specifically, it checks that the application correctly handles the scenario where the router returns `None` for the handler, ensuring that an appropriate error message is returned in the response.\n\n**Specific Functionality or Behavior Verified**:  \nThis test verifies that when a request is made to a specific route (`/test`), and the router fails to provide a valid handler (returns `None`), the response contains a specific error message indicating that no handler was found. The test asserts that the response text includes the string \"'None' was returned while requesting a handler from the router\".\n\n**Code Being Tested and How It Works**:  \nThe code being tested involves the `app.get` method, which is used to define a route handler for the GET request to `/test`. The test uses the `monkeypatch` fixture to override the behavior of the `app.router.get` method, simulating a scenario where it returns a mock route but with `None` as the handler. The test then makes a GET request to the `/test` endpoint using `app.test_client.get`, and checks the response for the expected error message.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `monkeypatch` technique to modify the behavior of the router dynamically, allowing for controlled testing of edge cases without altering the actual implementation. Additionally, the use of `Mock` from the `unittest.mock` library helps create a mock object that simulates the route's behavior, ensuring that the test remains isolated and focused on the specific scenario being tested. The assertion checks for the presence of a specific error message in the response, which is a common pattern in unit tests to validate expected outcomes."
    },
    {
      "name": "test_app_enable_websocket",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 190,
      "end_line_number": 200,
      "source_code": "def test_app_enable_websocket(app: Sanic, websocket_enabled, enable):\n    app.websocket_enabled = websocket_enabled\n    app.enable_websocket(enable=enable)\n\n    assert app.websocket_enabled == enable\n\n    @app.websocket(\"/ws\")\n    async def handler(request, ws):\n        await ws.send(\"test\")\n\n    assert app.websocket_enabled is True",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('websocket_enabled', [True, False])",
        "pytest.mark.parametrize('enable', [True, False])"
      ],
      "arguments": [
        "app",
        "websocket_enabled",
        "enable"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.websocket_enabled == enable",
        "assert app.websocket_enabled is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "ws.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_app_enable_websocket` test is to verify that the Sanic application correctly enables or disables WebSocket functionality based on the provided configuration. It ensures that the `websocket_enabled` attribute of the app reflects the expected state after invoking the `enable_websocket` method.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks two main behaviors: \n1. It asserts that the `websocket_enabled` attribute of the app matches the `enable` parameter after calling `app.enable_websocket()`.\n2. It confirms that the WebSocket functionality is indeed enabled by checking that `app.websocket_enabled` is `True` after the handler for the WebSocket route is defined.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `enable_websocket` method of the Sanic application, which modifies the `websocket_enabled` attribute based on the input parameter. The test sets up the application state by assigning a value to `app.websocket_enabled` and then calls `app.enable_websocket(enable=enable)`. The subsequent assertions validate that the state of `websocket_enabled` is as expected. Additionally, a WebSocket route is defined, which is a typical use case for enabling WebSocket support in a web application.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the state of the application before and after the method call, which is a common pattern in unit testing. It also utilizes parameterization (though not explicitly shown in this snippet) to allow for different configurations of `websocket_enabled` and `enable`, making the test more robust and comprehensive. The use of an asynchronous handler for the WebSocket route demonstrates the handling of asynchronous operations, which is crucial in testing frameworks like Sanic that are built on asynchronous I/O."
    },
    {
      "name": "test_app_websocket_parameters",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 204,
      "end_line_number": 230,
      "source_code": "def test_app_websocket_parameters(websocket_protocol_mock, app: Sanic):\n    app.config.WEBSOCKET_MAX_SIZE = 44\n    app.config.WEBSOCKET_PING_TIMEOUT = 48\n    app.config.WEBSOCKET_PING_INTERVAL = 50\n\n    @app.websocket(\"/ws\")\n    async def handler(request, ws):\n        await ws.send(\"test\")\n\n    try:\n        # This will fail because WebSocketProtocol is mocked and only the\n        # call kwargs matter\n        app.test_client.get(\"/ws\")\n    except Exception:\n        pass\n\n    websocket_protocol_call_args = websocket_protocol_mock.call_args\n    ws_kwargs = websocket_protocol_call_args[1]\n    assert ws_kwargs[\"websocket_max_size\"] == app.config.WEBSOCKET_MAX_SIZE\n    assert (\n        ws_kwargs[\"websocket_ping_timeout\"]\n        == app.config.WEBSOCKET_PING_TIMEOUT\n    )\n    assert (\n        ws_kwargs[\"websocket_ping_interval\"]\n        == app.config.WEBSOCKET_PING_INTERVAL\n    )",
      "docstring": null,
      "decorators": [
        "patch('sanic.mixins.startup.WebSocketProtocol')"
      ],
      "arguments": [
        "websocket_protocol_mock",
        "app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert ws_kwargs['websocket_max_size'] == app.config.WEBSOCKET_MAX_SIZE",
        "assert ws_kwargs['websocket_ping_timeout'] == app.config.WEBSOCKET_PING_TIMEOUT",
        "assert ws_kwargs['websocket_ping_interval'] == app.config.WEBSOCKET_PING_INTERVAL"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "ws.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_app_websocket_parameters` test is to verify that the configuration parameters for WebSocket connections in a Sanic application are correctly passed to the `WebSocketProtocol` when a WebSocket route is defined and accessed.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the parameters `WEBSOCKET_MAX_SIZE`, `WEBSOCKET_PING_TIMEOUT`, and `WEBSOCKET_PING_INTERVAL` from the application configuration are correctly set in the `WebSocketProtocol` instance. It ensures that these parameters are being utilized as expected when a WebSocket connection is initiated.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the Sanic application setup, where a WebSocket route (`/ws`) is defined. The test mocks the `WebSocketProtocol` to intercept its instantiation and capture the arguments passed to it. The test then attempts to access the WebSocket route using `app.test_client.get(\"/ws\")`, which is expected to fail due to the mock. After the attempt, it retrieves the call arguments from the mock and asserts that the configuration values match the expected values set in the application configuration.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test uses the `patch` decorator to mock the `WebSocketProtocol`, allowing the test to focus on verifying the parameters without needing a real WebSocket connection.\n- **Assertions**: It employs assertions to validate that the parameters passed to the mocked protocol match the expected configuration values.\n- **Exception Handling**: The test includes a try-except block to handle the expected failure when attempting to access the WebSocket route, ensuring that the test can proceed to validate the mock's call arguments without interruption."
    },
    {
      "name": "test_handle_request_with_nested_exception",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 233,
      "end_line_number": 249,
      "source_code": "def test_handle_request_with_nested_exception(app: Sanic, monkeypatch):\n    err_msg = \"Mock Exception\"\n\n    def mock_error_handler_response(*args, **kwargs):\n        raise Exception(err_msg)\n\n    monkeypatch.setattr(\n        app.error_handler, \"response\", mock_error_handler_response\n    )\n\n    @app.get(\"/\")\n    def handler(request):\n        raise Exception\n\n    request, response = app.test_client.get(\"/\")\n    assert response.status == 500\n    assert response.text == \"An error occurred while handling an error\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "monkeypatch"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert response.text == 'An error occurred while handling an error'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_handle_request_with_nested_exception` aims to verify the behavior of the Sanic application when an exception occurs while handling another exception. Specifically, it checks that the application correctly returns a 500 Internal Server Error status and a specific error message when nested exceptions are raised.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when an error handler itself raises an exception, the application responds with a 500 status code and a predefined error message: \"An error occurred while handling an error.\" This is crucial for maintaining robust error handling in web applications, ensuring that users receive meaningful feedback even in failure scenarios.\n\n**Code Being Tested and How It Works**:  \nThe test modifies the application's error handler using `monkeypatch` to simulate an error condition. The `mock_error_handler_response` function is defined to raise an exception with a specific message when invoked. The test then defines a route (`@app.get(\"/\")`) that raises an exception when accessed. When a GET request is made to this route, the modified error handler is triggered, leading to the nested exception scenario. The test checks the response status and content to confirm the expected behavior.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Monkeypatching**: The test uses the `monkeypatch` fixture to replace the error handler's response method with a mock function that raises an exception. This allows for controlled testing of error handling without modifying the actual application code.\n- **Assertion Checks**: The test includes assertions to verify that the response status is 500 and that the response text matches the expected error message, ensuring that the application behaves as intended under error conditions.\n- **Isolation of Tests**: By using a fixture (`app: Sanic`), the test ensures that it runs in a controlled environment, minimizing side effects from other tests and maintaining test isolation."
    },
    {
      "name": "test_handle_request_with_nested_exception_debug",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 252,
      "end_line_number": 271,
      "source_code": "def test_handle_request_with_nested_exception_debug(app: Sanic, monkeypatch):\n    err_msg = \"Mock Exception\"\n\n    def mock_error_handler_response(*args, **kwargs):\n        raise Exception(err_msg)\n\n    monkeypatch.setattr(\n        app.error_handler, \"response\", mock_error_handler_response\n    )\n\n    @app.get(\"/\")\n    def handler(request):\n        raise Exception\n\n    request, response = app.test_client.get(\"/\", debug=True)\n    assert response.status == 500\n    assert response.text.startswith(\n        f\"Error while handling error: {err_msg}\\n\"\n        \"Stack: Traceback (most recent call last):\\n\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "monkeypatch"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert response.text.startswith(f'Error while handling error: {err_msg}\\nStack: Traceback (most recent call last):\\n')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_handle_request_with_nested_exception_debug` is designed to verify the behavior of the Sanic application when an exception occurs during error handling while in debug mode. It ensures that the application correctly captures and formats the error message and stack trace when a nested exception is raised.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when an error occurs in the error handler (due to a mock error being raised), the response status is set to 500 (Internal Server Error) and that the response text starts with a specific error message indicating that an error occurred while handling another error, along with a stack trace.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the Sanic application's error handling mechanism. The test uses the `monkeypatch` fixture to replace the default error handler's response method with a mock function that raises an exception. The test then defines a route that also raises an exception. When a GET request is made to this route with `debug=True`, the application should trigger the error handler, which in turn raises another exception. The test checks that the response correctly reflects this error scenario.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Monkeypatching**: The test uses the `monkeypatch` fixture to modify the behavior of the error handler dynamically, allowing for controlled testing of error scenarios without altering the actual application code.\n- **Debug Mode Testing**: The test specifically sets the `debug` flag to `True` to ensure that the application provides detailed error messages, which is crucial for debugging.\n- **Assertions on Response**: The test employs assertions to validate both the HTTP status code and the content of the response, ensuring that the application behaves as expected under error conditions."
    },
    {
      "name": "test_handle_request_with_nested_sanic_exception",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 274,
      "end_line_number": 298,
      "source_code": "def test_handle_request_with_nested_sanic_exception(\n    app: Sanic, monkeypatch, caplog\n):\n    def mock_error_handler_response(*args, **kwargs):\n        raise SanicException(\"Mock SanicException\")\n\n    monkeypatch.setattr(\n        app.error_handler, \"response\", mock_error_handler_response\n    )\n\n    @app.get(\"/\")\n    def handler(request):\n        raise Exception\n\n    with caplog.at_level(logging.ERROR):\n        request, response = app.test_client.get(\"/\")\n    port = request.server_port\n    assert port > 0\n    assert response.status == 500\n    assert \"Mock SanicException\" in response.text\n    assert (\n        \"sanic.error\",\n        logging.ERROR,\n        f\"Exception occurred while handling uri: 'http://127.0.0.1:{port}/'\",\n    ) in caplog.record_tuples",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "monkeypatch",
        "caplog"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert port > 0",
        "assert response.status == 500",
        "assert 'Mock SanicException' in response.text",
        "assert ('sanic.error', logging.ERROR, f\"Exception occurred while handling uri: 'http://127.0.0.1:{port}/'\") in caplog.record_tuples"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_handle_request_with_nested_sanic_exception` aims to verify the behavior of the Sanic application when an exception occurs during request handling, specifically when that exception is nested within another exception raised by a custom error handler.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a `SanicException` is raised by the error handler, the application correctly returns a 500 Internal Server Error status, includes the exception message in the response text, and logs the appropriate error message. It ensures that the logging captures the context of the error, including the URI that caused the issue.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves a Sanic application where a route handler raises a generic `Exception`. The test uses `monkeypatch` to replace the default error handler's response method with a mock that raises a `SanicException`. When a GET request is made to the root endpoint (\"/\"), the application should trigger the error handling mechanism, resulting in a 500 status code and a response containing the message \"Mock SanicException\". The test also checks that the server port is valid and that the error is logged correctly.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Monkeypatching**: The test uses `monkeypatch` to modify the behavior of the error handler dynamically, allowing for controlled testing of error scenarios without altering the actual application code.\n- **Logging Capture**: The `caplog` fixture is employed to capture log messages during the test execution, enabling verification of the logging output against expected values.\n- **Assertions**: Multiple assertions are made to validate the response status, content, and logging behavior, ensuring comprehensive coverage of the expected outcomes."
    },
    {
      "name": "test_app_name_required",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 301,
      "end_line_number": 303,
      "source_code": "def test_app_name_required():\n    with pytest.raises(TypeError):\n        Sanic()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_app_name_required` test is designed to verify that the `Sanic` application constructor raises a `TypeError` when it is called without any arguments. This ensures that the application requires a name to be instantiated, which is a fundamental requirement for the `Sanic` framework.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks for the enforcement of the application name requirement. By expecting a `TypeError`, it confirms that the `Sanic` constructor is correctly implemented to handle cases where the name is not provided, thereby preventing the creation of an unnamed application instance.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `Sanic` class constructor. When `Sanic()` is called without any parameters, it should trigger a `TypeError`. This behavior is expected because the constructor likely has a signature that mandates at least one argument (the application name). The test uses the `pytest.raises` context manager to assert that the error is raised during the execution of the constructor.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager, which is a common pattern in unit testing for asserting that specific exceptions are raised during the execution of code. This technique allows for clean and readable tests that clearly express the expected behavior in error scenarios. Additionally, the test is concise, focusing solely on the requirement of the application name, which enhances maintainability and clarity."
    },
    {
      "name": "test_app_has_test_mode_sync",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 306,
      "end_line_number": 315,
      "source_code": "def test_app_has_test_mode_sync():\n    app = Sanic(\"test\")\n\n    @app.get(\"/\")\n    def handler(request):\n        assert request.app.test_mode\n        return text(\"test\")\n\n    _, response = app.test_client.get(\"/\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert request.app.test_mode"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_app_has_test_mode_sync` is designed to verify that the Sanic application is correctly configured to operate in test mode. It checks that the application instance has the `test_mode` attribute set to `True` when handling a request.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically verifies two behaviors: \n1. It asserts that the `test_mode` attribute of the application instance (`request.app.test_mode`) is `True` during the handling of a request.\n2. It confirms that the HTTP GET request to the root endpoint (\"/\") returns a successful response with a status code of 200.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `app.get` method, which registers a route handler for GET requests, and the `app.test_client.get` method, which simulates a client making a GET request to the application. The handler function checks the `test_mode` attribute of the application and returns a text response. The test client then makes a GET request to the root URL, and the response status is asserted to be 200, indicating a successful request.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern to validate expected outcomes. It uses inline assertions within the request handler to check the application state (`request.app.test_mode`) and utilizes the test client to simulate HTTP requests. This approach allows for direct verification of both application behavior and response handling in a controlled test environment. Additionally, the use of a simple route handler demonstrates the ease of setting up and testing routes in the Sanic framework."
    },
    {
      "name": "test_app_registry",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 318,
      "end_line_number": 324,
      "source_code": "def test_app_registry():\n    assert len(Sanic._app_registry) == 0\n    instance = Sanic(\"test\")\n    assert len(Sanic._app_registry) == 1\n    assert Sanic._app_registry[\"test\"] is instance\n    Sanic.unregister_app(instance)\n    assert len(Sanic._app_registry) == 0",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(Sanic._app_registry) == 0",
        "assert len(Sanic._app_registry) == 1",
        "assert Sanic._app_registry['test'] is instance",
        "assert len(Sanic._app_registry) == 0"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_app_registry` function is designed to verify the behavior of the `Sanic` application's internal registry for managing application instances. It ensures that the registry correctly tracks the number of registered applications and that the registration and unregistration processes function as expected.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that:\n1. The registry starts empty.\n2. A new `Sanic` instance can be successfully registered, increasing the registry count.\n3. The registered instance can be retrieved from the registry using its name.\n4. The instance can be unregistered, returning the registry to its initial empty state.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `Sanic` class's `_app_registry`, which is a class-level dictionary that holds references to registered `Sanic` instances keyed by their names. The test:\n- Asserts the initial state of `_app_registry` is empty.\n- Creates a new `Sanic` instance named \"test\", which triggers the registration process.\n- Checks that the instance is correctly stored in `_app_registry`.\n- Calls `Sanic.unregister_app(instance)` to remove the instance from the registry and verifies that the registry is empty again.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern to validate expected outcomes at each step. It uses:\n- Assertions to check the length of the registry and the identity of the registered instance.\n- A clear sequence of operations (initial state check, registration, retrieval, and unregistration) to ensure that the state of the registry is accurately reflected throughout the test. This methodical approach helps in isolating issues related to the app registry's functionality."
    },
    {
      "name": "test_app_registry_wrong_type",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 327,
      "end_line_number": 331,
      "source_code": "def test_app_registry_wrong_type():\n    with pytest.raises(\n        SanicException, match=\"Registered app must be an instance of Sanic\"\n    ):\n        Sanic.register_app(1)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_app_registry_wrong_type` test is designed to verify that the `Sanic.register_app` method correctly raises a `SanicException` when an invalid type (in this case, an integer) is passed as an argument. This ensures that the application enforces type safety for registered applications.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `Sanic.register_app` method does not accept non-Sanic instances. It expects a `SanicException` to be raised with a specific error message indicating that the registered app must be an instance of the `Sanic` class.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `Sanic.register_app` method. When this method is called with an argument that is not an instance of `Sanic`, it should raise a `SanicException`. The test uses the `pytest.raises` context manager to assert that the exception is raised and that the message matches the expected string.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager, which is a common pattern in unit testing for asserting that specific exceptions are raised during the execution of a block of code. Additionally, it uses the `match` parameter to verify that the exception message is not only raised but also contains the expected text, ensuring that the error handling is both functional and informative."
    },
    {
      "name": "test_app_registry_name_reuse",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 334,
      "end_line_number": 342,
      "source_code": "def test_app_registry_name_reuse():\n    Sanic(\"test\")\n    Sanic.test_mode = False\n    with pytest.raises(\n        SanicException, match='Sanic app name \"test\" already in use.'\n    ):\n        Sanic(\"test\")\n    Sanic.test_mode = True\n    Sanic(\"test\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_app_registry_name_reuse` test verifies that the Sanic application framework correctly handles attempts to register multiple instances of an application with the same name when not in test mode. It ensures that an appropriate exception is raised when a duplicate application name is used.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a Sanic application is instantiated with a name that is already in use (in this case, \"test\"), a `SanicException` is raised with the message indicating that the app name is already in use. It also tests that this behavior is bypassed when the `test_mode` is enabled, allowing the reuse of the app name.\n\n**Code Being Tested and How It Works**:  \nThe test first creates a Sanic application instance with the name \"test\". It then sets `Sanic.test_mode` to `False`, which means that the framework should enforce unique application names. When a second instance of Sanic is created with the same name, the `register_app` method is invoked, which checks if the name is already in the `_app_registry`. Since it is, a `SanicException` is raised. After that, the test sets `test_mode` to `True` and creates another instance with the same name, which should succeed without raising an exception.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that a specific exception is raised during the execution of the code block. This is a common pattern in unit testing to verify that error handling works as expected. Additionally, the use of `match` in `pytest.raises` allows for checking that the exception message is exactly what is expected, ensuring that not only is an exception raised, but it is the correct one with the appropriate message."
    },
    {
      "name": "test_app_registry_retrieval",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 345,
      "end_line_number": 347,
      "source_code": "def test_app_registry_retrieval():\n    instance = Sanic(\"test\")\n    assert Sanic.get_app(\"test\") is instance",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert Sanic.get_app('test') is instance"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_app_registry_retrieval` test verifies that the `Sanic.get_app` method correctly retrieves an instance of a `Sanic` application that has been registered with a specific name. This ensures that the application registry functionality is working as intended.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a `Sanic` instance is created with the name \"test\", calling `Sanic.get_app(\"test\")` returns the same instance. It confirms that the application registry is able to store and retrieve application instances based on their names.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `get_app` class method of the `Sanic` class. This method looks up an application instance in the `_app_registry` dictionary using the provided name. If the name exists in the registry, it returns the corresponding `Sanic` instance. The test creates an instance of `Sanic` with the name \"test\" and then asserts that retrieving the app with `Sanic.get_app(\"test\")` returns the same instance.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern using `assert` to validate the expected outcome. It also follows the Arrange-Act-Assert (AAA) pattern: it first arranges the necessary conditions by creating an instance of `Sanic`, then acts by calling the `get_app` method, and finally asserts that the result matches the expected instance. This clear structure enhances readability and maintainability of the test."
    },
    {
      "name": "test_app_registry_retrieval_from_multiple",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 350,
      "end_line_number": 353,
      "source_code": "def test_app_registry_retrieval_from_multiple():\n    instance = Sanic(\"test\")\n    Sanic(\"something_else\")\n    assert Sanic.get_app(\"test\") is instance",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert Sanic.get_app('test') is instance"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_app_registry_retrieval_from_multiple` aims to verify that the `Sanic` application registry correctly retrieves an application instance by its name, even when multiple instances of `Sanic` are created.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when multiple `Sanic` instances are created, the `get_app` method can still accurately return the correct instance associated with a given name. In this case, it ensures that the instance named \"test\" is the same as the one retrieved by `Sanic.get_app(\"test\")`.\n\n**Code Being Tested and How It Works**:  \nThe code being tested involves the `Sanic` class's ability to manage a registry of application instances. The `get_app` method is designed to return the instance of `Sanic` that corresponds to the provided name. The test first creates an instance named \"test\" and another instance named \"something_else\". It then asserts that calling `Sanic.get_app(\"test\")` returns the original instance created for \"test\", confirming that the registry is functioning correctly.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern, using `assert` to validate that the expected instance is returned. It also demonstrates the use of setup code to create multiple instances, which is a common technique in unit testing to ensure that the system under test behaves correctly under various conditions. The test is designed to be simple and direct, focusing on a specific aspect of the application's behavior without introducing unnecessary complexity."
    },
    {
      "name": "test_get_app_does_not_exist",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 356,
      "end_line_number": 368,
      "source_code": "def test_get_app_does_not_exist():\n    with pytest.raises(\n        SanicException,\n        match=(\n            \"Sanic app name 'does-not-exist' not found.\\n\"\n            \"App instantiation must occur outside \"\n            \"if __name__ == '__main__' \"\n            \"block or by using an AppLoader.\\nSee \"\n            \"https://sanic.dev/en/guide/deployment/app-loader.html\"\n            \" for more details.\"\n        ),\n    ):\n        Sanic.get_app(\"does-not-exist\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_get_app_does_not_exist` test is to verify that the `Sanic.get_app` method raises a `SanicException` when attempting to retrieve an application by a name that does not exist in the application's registry.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the correct exception is raised with the expected error message when a non-existent app name is provided. It ensures that the error handling in the `get_app` method functions as intended when the app name is not found.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `get_app` class method of the `Sanic` class. When called with a name that is not registered, it attempts to retrieve the app from the `_app_registry` dictionary. If the name is not found, it raises a `SanicException` with a detailed message explaining the error and providing guidance on proper app instantiation. The relevant part of the code checks for the existence of the app name in the registry and raises the exception if it is absent.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that an exception is raised during the execution of the code block. It also uses the `match` parameter to verify that the exception message matches the expected string, ensuring that not only is the exception raised, but it also contains the correct information. This pattern is effective for testing error conditions and validating that the application behaves correctly under exceptional circumstances."
    },
    {
      "name": "test_get_app_does_not_exist_force_create",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 371,
      "end_line_number": 374,
      "source_code": "def test_get_app_does_not_exist_force_create():\n    assert isinstance(\n        Sanic.get_app(\"does-not-exist\", force_create=True), Sanic\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(Sanic.get_app('does-not-exist', force_create=True), Sanic)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_get_app_does_not_exist_force_create` is designed to verify the behavior of the `Sanic.get_app` method when attempting to retrieve an application instance that does not exist in the registry, with the `force_create` flag set to `True`. This ensures that the method can create a new instance of the `Sanic` application when requested.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that when a non-existent application name (\"does-not-exist\") is provided to `Sanic.get_app` with `force_create=True`, the method successfully creates and returns a new instance of the `Sanic` class. The assertion confirms that the returned object is indeed an instance of `Sanic`.\n\n**Code Being Tested and How It Works**:  \nThe relevant code being tested is the `get_app` method of the `Sanic` class, which is responsible for retrieving an application instance by name. If the specified name does not exist in the `_app_registry`, and `force_create` is set to `True`, the method will instantiate a new `Sanic` application. The method's implementation includes logic to handle both retrieval and creation of application instances, ensuring that it can manage multiple instances effectively.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern using `assert isinstance(...)`, which is a common technique in unit testing to validate the type of an object. This approach is effective for confirming that the method behaves as expected under the specified conditions. Additionally, the test is isolated and does not depend on any external state, which is a hallmark of good unit testing practice."
    },
    {
      "name": "test_get_app_default",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 377,
      "end_line_number": 379,
      "source_code": "def test_get_app_default():\n    instance = Sanic(\"test\")\n    assert Sanic.get_app() is instance",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert Sanic.get_app() is instance"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_get_app_default` test is to verify that the `Sanic.get_app()` method correctly returns the instance of the `Sanic` application that has been created. This ensures that the application instance can be retrieved as expected, which is crucial for the functionality of the Sanic framework.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a `Sanic` instance is created (in this case, named \"test\"), calling `Sanic.get_app()` returns the same instance. It confirms that the `get_app()` method is functioning correctly in returning the currently registered application instance.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `get_app()` class method of the `Sanic` class. When an instance of `Sanic` is created with the name \"test\", it is registered in the internal application registry. The `get_app()` method retrieves this instance based on its name. The assertion `assert Sanic.get_app() is instance` checks that the instance returned by `get_app()` is indeed the same as the one created, ensuring that the registration and retrieval mechanisms are working as intended.\n\n**Notable Testing Patterns or Techniques Used**:  \nThis test employs a straightforward assertion pattern, using the `assert` statement to validate the expected outcome. It does not involve any complex mocking or parameterization, making it a simple and direct unit test. The use of the `is` operator checks for object identity, ensuring that the exact instance is returned rather than a different instance that may have the same properties. This is a common practice in unit testing to ensure that the correct object is being manipulated or returned by the method under test."
    },
    {
      "name": "test_get_app_no_default",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 382,
      "end_line_number": 386,
      "source_code": "def test_get_app_no_default():\n    with pytest.raises(\n        SanicException, match=\"No Sanic apps have been registered.\"\n    ):\n        Sanic.get_app()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_get_app_no_default` test is designed to verify that the `Sanic.get_app()` method raises a `SanicException` when no Sanic applications have been registered. This ensures that the application behaves correctly in scenarios where an attempt is made to retrieve an app that does not exist.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks for the correct exception type (`SanicException`) and the appropriate error message (\"No Sanic apps have been registered.\") when invoking `Sanic.get_app()` without any prior app registration. It confirms that the method enforces the requirement for at least one registered app before it can be accessed.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `Sanic.get_app()` method, which is expected to return a registered Sanic application. If no applications are registered, it should raise a `SanicException`. The test uses the `pytest.raises` context manager to assert that the exception is raised during the execution of `Sanic.get_app()`. The `match` parameter ensures that the exception message matches the expected string.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager, a common pattern in unit testing for asserting that specific exceptions are raised during code execution. This pattern enhances readability and conciseness, allowing for clear expectations regarding error handling. Additionally, the use of a specific error message in the `match` parameter ensures that not only the type of exception is verified, but also the correctness of the error message, which is crucial for debugging and user feedback."
    },
    {
      "name": "test_get_app_default_ambiguous",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 389,
      "end_line_number": 398,
      "source_code": "def test_get_app_default_ambiguous():\n    Sanic(\"test1\")\n    Sanic(\"test2\")\n    with pytest.raises(\n        SanicException,\n        match=re.escape(\n            'Multiple Sanic apps found, use Sanic.get_app(\"app_name\")'\n        ),\n    ):\n        Sanic.get_app()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_get_app_default_ambiguous` test is designed to verify that the `Sanic.get_app()` method raises a `SanicException` when multiple Sanic app instances are registered without specifying which one to retrieve. This ensures that the application correctly handles ambiguous situations where it cannot determine which app instance to return.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks the behavior of the `Sanic.get_app()` method when there are multiple Sanic app instances created. It confirms that the method raises an exception with a specific error message, indicating that the user should specify the app name to resolve the ambiguity.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `Sanic.get_app()` method, which is responsible for retrieving a registered Sanic app instance. When called without any arguments, it checks the number of registered apps. If more than one app is found, it raises a `SanicException` with the message: 'Multiple Sanic apps found, use Sanic.get_app(\"app_name\")'. The test creates two instances of `Sanic` (named \"test1\" and \"test2\") and then calls `Sanic.get_app()` to trigger the exception.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises()` context manager to assert that an exception is raised during the execution of the code block. It also uses the `match` parameter to verify that the exception message matches the expected output, ensuring that the error handling is both functional and informative. This pattern is effective for testing error conditions in a clean and readable manner."
    },
    {
      "name": "test_app_set_attribute_warning",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 401,
      "end_line_number": 407,
      "source_code": "def test_app_set_attribute_warning(app: Sanic):\n    message = (\n        \"Setting variables on Sanic instances is not allowed. You should \"\n        \"change your Sanic instance to use instance.ctx.foo instead.\"\n    )\n    with pytest.raises(AttributeError, match=message):\n        app.foo = 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_app_set_attribute_warning` test is to ensure that attempting to set arbitrary attributes directly on a `Sanic` instance raises an `AttributeError`. This is a safeguard to enforce the use of the `ctx` attribute for storing instance-specific data.\n\n**Specific Functionality or Behavior Verified**:  \nThis test verifies that the `Sanic` framework does not allow users to set attributes directly on the `Sanic` instance. Instead, it enforces the use of the `ctx` (context) attribute for such purposes, thereby promoting a cleaner and more structured way to manage instance-specific data.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the behavior of the `Sanic` instance when an attempt is made to set an attribute (in this case, `foo`). The test uses the `pytest.raises` context manager to assert that an `AttributeError` is raised with a specific error message when `app.foo = 1` is executed. The expected error message indicates that setting variables directly on the `Sanic` instance is not allowed.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager, which is a common pattern in unit testing for asserting that specific exceptions are raised during the execution of a block of code. Additionally, it uses a string match to verify that the raised exception contains the expected error message, ensuring that not only is the correct exception raised, but also that it conveys the appropriate information to the user. This enhances the robustness of the test by checking both the type of exception and its message."
    },
    {
      "name": "test_app_set_context",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 410,
      "end_line_number": 414,
      "source_code": "def test_app_set_context(app: Sanic):\n    app.ctx.foo = 1\n\n    retrieved = Sanic.get_app(app.name)\n    assert retrieved.ctx.foo == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert retrieved.ctx.foo == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_app_set_context` test verifies that the context (`ctx`) of a Sanic application instance can be set and subsequently retrieved correctly. It ensures that the application context behaves as expected when accessed through the `get_app` method.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a value is assigned to an attribute (`foo`) in the application context (`ctx`), it can be retrieved correctly from the same application instance using the `Sanic.get_app` method. This confirms that the context is shared and consistent across the application instance.\n\n**Code Being Tested and How It Works**:  \nThe test first assigns the value `1` to `app.ctx.foo`. It then retrieves the application instance using `Sanic.get_app(app.name)`, which should return the same instance that was modified. The assertion `assert retrieved.ctx.foo == 1` checks that the value of `foo` in the retrieved context matches the value that was set, thereby validating the integrity of the context management in the Sanic framework.\n\n**Notable Testing Patterns or Techniques Used**:  \nThis test employs a straightforward assertion pattern to validate the expected state of the application context. It uses the `get_app` class method to retrieve the application instance, demonstrating a common practice in unit tests where the state of an object is manipulated and then verified. The test also implicitly relies on the setup of the Sanic application instance, which is provided as a fixture (`app: Sanic`), showcasing the use of dependency injection in testing."
    },
    {
      "name": "test_subclass_initialisation",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 417,
      "end_line_number": 421,
      "source_code": "def test_subclass_initialisation():\n    class CustomSanic(Sanic):\n        pass\n\n    CustomSanic(\"test_subclass_initialisation\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_subclass_initialisation` test is designed to verify that a subclass of the `Sanic` application can be instantiated without any errors. This ensures that the subclassing mechanism works correctly and that the `Sanic` framework allows for custom extensions.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that creating an instance of a subclass (`CustomSanic`) does not raise any exceptions. It implicitly verifies that the constructor of the `Sanic` class can handle subclass instances properly, which is crucial for users who may want to extend the functionality of the `Sanic` framework.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the instantiation of the `CustomSanic` class, which inherits from `Sanic`. The line `CustomSanic(\"test_subclass_initialisation\")` creates an instance of `CustomSanic`, passing a string as the application name. The test does not include any assertions, but the absence of exceptions during instantiation is the primary check.\n\n**Notable Testing Patterns or Techniques Used**:  \nThis test employs a straightforward approach by simply attempting to instantiate a class and relying on the absence of exceptions as a form of verification. This pattern is common in unit tests where the goal is to ensure that certain operations (like instantiation) do not fail. However, it lacks explicit assertions, which could enhance clarity and intent by confirming that the instance behaves as expected after creation."
    },
    {
      "name": "test_bad_custom_config",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 424,
      "end_line_number": 432,
      "source_code": "def test_bad_custom_config():\n    with pytest.raises(\n        SanicException,\n        match=(\n            \"When instantiating Sanic with config, you cannot also pass \"\n            \"env_prefix\"\n        ),\n    ):\n        Sanic(\"test\", config=1, env_prefix=1)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_bad_custom_config` unit test is designed to verify that the `Sanic` application raises a `SanicException` when it is instantiated with both a `config` argument and an `env_prefix` argument. This ensures that the application enforces its configuration rules correctly.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks for the correct exception type (`SanicException`) and the appropriate error message when conflicting parameters are provided during the instantiation of the `Sanic` application. It ensures that the application does not allow both `config` and `env_prefix` to be set simultaneously.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the constructor of the `Sanic` class. When an instance of `Sanic` is created with the parameters `config=1` and `env_prefix=1`, the constructor should validate these parameters and raise a `SanicException` if both are provided. The test uses the `pytest.raises` context manager to assert that the exception is raised and that the message matches the expected output.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager, which is a common pattern in unit testing to assert that specific exceptions are raised during the execution of a block of code. Additionally, it uses the `match` argument to verify that the exception message is exactly what is expected, ensuring that not only the exception type is correct but also the reason for the exception is clear and informative. This enhances the robustness of the test by checking both the occurrence of the exception and its correctness."
    },
    {
      "name": "test_custom_config",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 435,
      "end_line_number": 441,
      "source_code": "def test_custom_config():\n    class CustomConfig(Config): ...\n\n    config = CustomConfig()\n    app = Sanic(\"custom\", config=config)\n\n    assert app.config == config",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.config == config"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_custom_config` function is designed to verify that a custom configuration class can be successfully instantiated and assigned to a Sanic application, ensuring that the application's configuration reflects the custom settings.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a `CustomConfig` instance is created and passed to the Sanic application, the application's configuration (`app.config`) is equal to the `CustomConfig` instance. This confirms that the application correctly utilizes the provided configuration.\n\n**Code Being Tested and How It Works**:  \nThe test creates a subclass of `Config` called `CustomConfig`, instantiates it, and then initializes a Sanic application with this custom configuration. The assertion `assert app.config == config` checks if the application's configuration matches the instance of `CustomConfig`. If they are equal, it indicates that the application has correctly adopted the custom configuration.\n\n**Notable Testing Patterns or Techniques Used**:  \nThis test employs a straightforward assertion pattern to validate the equality of two objects. It uses class inheritance to create a custom configuration, demonstrating the flexibility of the configuration system in Sanic. The test is simple and direct, focusing on the instantiation and assignment of configuration, which is a common pattern in unit testing to ensure that components interact correctly."
    },
    {
      "name": "test_custom_context",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 444,
      "end_line_number": 450,
      "source_code": "def test_custom_context():\n    class CustomContext: ...\n\n    ctx = CustomContext()\n    app = Sanic(\"custom\", ctx=ctx)\n\n    assert app.ctx == ctx",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.ctx == ctx"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_custom_context` function is designed to verify that a custom context can be successfully assigned to a Sanic application instance and that the application correctly retains this context.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a `CustomContext` instance is created and passed to the Sanic application during initialization, the application\u2019s context (`app.ctx`) matches the provided context (`ctx`). This ensures that the application can utilize custom context objects as intended.\n\n**Code Being Tested and How It Works**:  \nThe relevant code creates a class `CustomContext`, instantiates it, and then initializes a Sanic application with this context. The assertion `assert app.ctx == ctx` confirms that the context stored in the application (`app.ctx`) is indeed the same instance as the one created (`ctx`). This is a straightforward check to ensure that the context management feature of the Sanic framework is functioning correctly.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a simple assertion pattern to validate the expected state of the application after initialization. It uses a class definition to create a custom context, demonstrating the flexibility of the Sanic framework in allowing users to define their own context types. The test is also structured in a way that isolates the functionality being tested, ensuring that it does not depend on other tests or external factors, which is a common best practice in unit testing."
    },
    {
      "name": "test_uvloop_config",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 454,
      "end_line_number": 476,
      "source_code": "def test_uvloop_config(app: Sanic, monkeypatch, use):\n    @app.get(\"/test\", name=\"test\")\n    def handler(request):\n        return text(\"ok\")\n\n    try_use_uvloop = Mock()\n    monkeypatch.setattr(sanic.mixins.startup, \"try_use_uvloop\", try_use_uvloop)\n\n    # Default config\n    app.test_client.get(\"/test\")\n    if OS_IS_WINDOWS:\n        try_use_uvloop.assert_not_called()\n    else:\n        try_use_uvloop.assert_called_once()\n\n    try_use_uvloop.reset_mock()\n    app.config[\"USE_UVLOOP\"] = use\n    app.test_client.get(\"/test\")\n\n    if use:\n        try_use_uvloop.assert_called_once()\n    else:\n        try_use_uvloop.assert_not_called()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('use', (False, True))"
      ],
      "arguments": [
        "app",
        "monkeypatch",
        "use"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "try_use_uvloop.reset_mock",
          "body": "def reset_mock(self, *args, **kwargs):\n    super().reset_mock(*args, **kwargs)\n    self.await_count = 0"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_uvloop_config` function is designed to verify the behavior of the Sanic application regarding the usage of the `uvloop` event loop based on the application's configuration. It checks whether the `try_use_uvloop` function is called or not, depending on the operating system and the configuration setting for `USE_UVLOOP`.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically verifies that:\n1. The `try_use_uvloop` function is called when the application is not running on Windows and `USE_UVLOOP` is set to `True`.\n2. The `try_use_uvloop` function is not called when the application is running on Windows or when `USE_UVLOOP` is set to `False`.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes:\n- The `app.get` method, which defines a simple route that returns a text response.\n- The `app.test_client.get` method, which simulates a GET request to the defined route.\n- The `try_use_uvloop` function, which is mocked to track whether it is called during the test.\n\nThe test first checks the default behavior of the application regarding `try_use_uvloop` before modifying the configuration. It then updates the `USE_UVLOOP` setting and checks the behavior again to ensure that the application responds correctly to the configuration change.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The `try_use_uvloop` function is mocked using `Mock()` to intercept calls and verify whether it was called or not.\n- **Monkeypatching**: The `monkeypatch` fixture is used to replace the `try_use_uvloop` function in the `sanic.mixins.startup` module with the mock, allowing for controlled testing of its invocation.\n- **Parameterized Testing**: The test is decorated with `@pytest.mark.parametrize`, allowing it to run multiple times with different values for `USE_UVLOOP`, enhancing coverage and ensuring that both `True` and `False` scenarios are tested."
    },
    {
      "name": "test_uvloop_cannot_never_called_with_create_server",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 480,
      "end_line_number": 514,
      "source_code": "def test_uvloop_cannot_never_called_with_create_server(caplog, monkeypatch):\n    apps = (Sanic(\"default-uvloop\"), Sanic(\"no-uvloop\"), Sanic(\"yes-uvloop\"))\n\n    apps[1].config.USE_UVLOOP = False\n    apps[2].config.USE_UVLOOP = True\n\n    try_use_uvloop = Mock()\n    monkeypatch.setattr(sanic.mixins.startup, \"try_use_uvloop\", try_use_uvloop)\n\n    loop = asyncio.get_event_loop()\n\n    with caplog.at_level(logging.WARNING):\n        for app in apps:\n            srv_coro = app.create_server(\n                return_asyncio_server=True,\n                asyncio_server_kwargs=dict(start_serving=False),\n                port=get_port(),\n            )\n            loop.run_until_complete(srv_coro)\n\n    try_use_uvloop.assert_not_called()  # Check it didn't try to change policy\n\n    message = (\n        \"You are trying to change the uvloop configuration, but \"\n        \"this is only effective when using the run(...) method. \"\n        \"When using the create_server(...) method Sanic will use \"\n        \"the already existing loop.\"\n    )\n\n    counter = Counter([(r[1], r[2]) for r in caplog.record_tuples])\n    modified = sum(\n        1 for app in apps if not isinstance(app.config.USE_UVLOOP, Default)\n    )\n\n    assert counter[(logging.WARNING, message)] == modified",
      "docstring": null,
      "decorators": [
        "pytest.mark.asyncio"
      ],
      "arguments": [
        "caplog",
        "monkeypatch"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert counter[logging.WARNING, message] == modified"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_port",
          "body": "def get_port():\n    sock = socket.socket()\n    sock.bind(('', 0))\n    return sock.getsockname()[1]"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_uvloop_cannot_never_called_with_create_server` verifies that the `try_use_uvloop` function is not called when creating a server instance using the `create_server` method in the Sanic framework. It ensures that the uvloop configuration is respected and that warnings are logged appropriately when the configuration is inconsistent.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when multiple Sanic applications are created with different `USE_UVLOOP` settings, the `try_use_uvloop` function does not get invoked. It also verifies that a specific warning message is logged when the uvloop configuration is attempted to be changed inappropriately.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `create_server` method of the Sanic application instances. The test sets up three Sanic applications with different uvloop configurations. It uses a mock for `try_use_uvloop` to intercept calls to it and checks that it is not called during the server creation process. The test also captures log messages to assert that the correct warning is emitted based on the applications' configurations.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The `Mock` class is used to replace the `try_use_uvloop` function, allowing the test to assert that it was not called.\n- **Monkeypatching**: The `monkeypatch` fixture is used to temporarily replace the `try_use_uvloop` function in the Sanic mixins, facilitating controlled testing of the behavior.\n- **Logging Capture**: The `caplog` fixture captures log messages at the WARNING level, enabling assertions on the emitted log messages to ensure the correct warnings are raised.\n- **Counter**: The `Counter` class is used to tally the occurrences of specific log messages, allowing for a straightforward comparison against expected values."
    },
    {
      "name": "test_multiple_uvloop_configs_display_warning",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 518,
      "end_line_number": 548,
      "source_code": "def test_multiple_uvloop_configs_display_warning(caplog):\n    Sanic._uvloop_setting = None  # Reset the setting (changed in prev tests)\n\n    default_uvloop = Sanic(\"default-uvloop\")\n    no_uvloop = Sanic(\"no-uvloop\")\n    yes_uvloop = Sanic(\"yes-uvloop\")\n\n    no_uvloop.config.USE_UVLOOP = False\n    yes_uvloop.config.USE_UVLOOP = True\n\n    loop = asyncio.get_event_loop()\n\n    with caplog.at_level(logging.WARNING):\n        for app in (default_uvloop, no_uvloop, yes_uvloop):\n            srv_coro = app.create_server(\n                return_asyncio_server=True,\n                asyncio_server_kwargs=dict(start_serving=False),\n                port=get_port(),\n            )\n            srv = loop.run_until_complete(srv_coro)\n            loop.run_until_complete(srv.startup())\n\n    message = (\n        \"It looks like you're running several apps with different \"\n        \"uvloop settings. This is not supported and may lead to \"\n        \"unintended behaviour.\"\n    )\n\n    counter = Counter([(r[1], r[2]) for r in caplog.record_tuples])\n\n    assert counter[(logging.WARNING, message)] == 3",
      "docstring": null,
      "decorators": [
        "pytest.mark.asyncio"
      ],
      "arguments": [
        "caplog"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert counter[logging.WARNING, message] == 3"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_port",
          "body": "def get_port():\n    sock = socket.socket()\n    sock.bind(('', 0))\n    return sock.getsockname()[1]"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_multiple_uvloop_configs_display_warning` aims to verify that when multiple Sanic applications are instantiated with differing configurations for the `USE_UVLOOP` setting, a specific warning message is logged. This ensures that the application correctly handles the scenario where inconsistent uvloop settings could lead to unintended behavior.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the warning message is logged three times when three different Sanic applications are created: one with the default setting, one explicitly set to not use uvloop, and one set to use uvloop. The expected behavior is that the application should log a warning indicating that running multiple apps with different uvloop settings is unsupported.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the creation of three Sanic applications with different `USE_UVLOOP` configurations. The `create_server` method is called for each application, which triggers the logging of a warning if the applications have conflicting uvloop settings. The test uses the `caplog` fixture to capture log messages at the WARNING level, allowing the test to assert that the specific warning message appears the expected number of times.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The test utilizes the `caplog` fixture from pytest to capture log output, which is a common pattern for testing logging behavior.\n- **Loop Management**: The test manages the asyncio event loop explicitly, ensuring that the server creation and startup processes are executed in a controlled manner.\n- **Counter for Assertions**: The test employs a `Counter` to tally the occurrences of the specific warning message, allowing for a clear assertion that the expected number of warnings were logged. This pattern is effective for verifying that logging behavior meets expectations in a concise manner."
    },
    {
      "name": "test_cannot_run_fast_and_workers",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 551,
      "end_line_number": 554,
      "source_code": "def test_cannot_run_fast_and_workers(app: Sanic, port):\n    message = \"You cannot use both fast=True and workers=X\"\n    with pytest.raises(RuntimeError, match=message):\n        app.run(fast=True, workers=4, port=port)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "port"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_cannot_run_fast_and_workers` is designed to verify that the `Sanic` application does not allow the simultaneous use of the `fast` mode and multiple workers. It ensures that an appropriate error is raised when both options are specified.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when the `app.run()` method is called with `fast=True` and `workers=4`, a `RuntimeError` is raised with a specific error message. This behavior is crucial for maintaining the integrity of the application's configuration, as using both options together is logically inconsistent.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `app.run()` method from the `Sanic` framework. The method is expected to validate its parameters and raise a `RuntimeError` if conflicting options are provided. In this case, the method checks if both `fast` and `workers` are set, and if so, it raises an error with the message \"You cannot use both fast=True and workers=X\".\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that a specific exception is raised during the execution of the code block. The `match` parameter is used to verify that the raised exception contains the expected error message. This pattern is effective for testing error handling and ensuring that the application behaves correctly under invalid configurations."
    },
    {
      "name": "test_no_workers",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 557,
      "end_line_number": 559,
      "source_code": "def test_no_workers(app: Sanic, port):\n    with pytest.raises(RuntimeError, match=\"Cannot serve with no workers\"):\n        app.run(workers=0, port=port)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "port"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_no_workers` test is designed to verify that the `app.run` method of the Sanic application raises a `RuntimeError` when it is called with zero workers. This is crucial for ensuring that the application does not attempt to start without the necessary worker processes, which are essential for handling requests.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that the application correctly raises a `RuntimeError` with the message \"Cannot serve with no workers\" when the `workers` parameter is set to 0. This behavior is important to prevent the application from running in an invalid state that could lead to unexpected behavior or crashes.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `app.run` method, which is responsible for starting the Sanic server. The relevant part of the implementation checks the number of workers specified. If the number of workers is zero, it raises a `RuntimeError`. The test uses the `pytest.raises` context manager to assert that this exception is raised when the method is invoked with `workers=0`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that an exception is raised, which is a common pattern in unit testing for verifying error conditions. Additionally, the use of parameterized inputs (in this case, `workers=0`) allows for clear and concise testing of edge cases. The test is structured to be straightforward, focusing solely on the expected failure condition, which enhances its clarity and maintainability."
    },
    {
      "name": "test_cannot_run_single_process_and_workers_or_auto_reload",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 570,
      "end_line_number": 577,
      "source_code": "def test_cannot_run_single_process_and_workers_or_auto_reload(\n    app: Sanic, extra, port\n):\n    message = (\n        \"Single process cannot be run with multiple workers or auto-reload\"\n    )\n    with pytest.raises(RuntimeError, match=message):\n        app.run(single_process=True, port=port, **extra)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('extra', ({'fast': True}, {'workers': 2}, {'auto_reload': True}))"
      ],
      "arguments": [
        "app",
        "extra",
        "port"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_cannot_run_single_process_and_workers_or_auto_reload` is designed to verify that the Sanic application cannot be run in a single process mode while also attempting to use multiple workers or enabling auto-reload functionality. This is important to ensure that the application behaves correctly and raises an appropriate error when conflicting configurations are provided.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that a `RuntimeError` is raised with a specific error message when the application is instructed to run in single process mode (`single_process=True`) while also specifying multiple workers or enabling auto-reload. This behavior is crucial for maintaining the integrity of the application's execution model.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `app.run()` method of the Sanic application. The method is expected to handle various configurations for running the server, including the number of processes and whether to enable auto-reload. In this test, the `app.run()` method is called with `single_process=True`, a specified port, and additional parameters (`**extra`). The test checks that this call raises a `RuntimeError` with the message \"Single process cannot be run with multiple workers or auto-reload\".\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that a specific exception is raised during the execution of the code block. This is a common pattern in unit testing that allows for clean and readable assertions about expected exceptions. Additionally, the use of a specific error message in the `match` parameter ensures that not only is the correct type of exception raised, but also that it contains the expected message, providing a more robust verification of the application's behavior under erroneous conditions."
    },
    {
      "name": "test_default_configure_logging",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 580,
      "end_line_number": 584,
      "source_code": "def test_default_configure_logging():\n    with patch(\"sanic.app.logging\") as mock:\n        Sanic(\"Test\")\n\n    mock.config.dictConfig.assert_called_with(LOGGING_CONFIG_DEFAULTS)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_default_configure_logging` function is designed to verify that the default logging configuration for a Sanic application is correctly set up when an instance of the Sanic app is created without any custom logging configuration.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `dictConfig` method of the logging configuration is called with the expected default logging configuration, `LOGGING_CONFIG_DEFAULTS`, when a new Sanic application is instantiated.\n\n**Code Being Tested and How It Works**:  \nThe test uses the `patch` function from the `unittest.mock` module to replace the actual logging configuration in the Sanic app with a mock object. When the `Sanic(\"Test\")` constructor is called, it triggers the logging configuration setup. The test then asserts that the `dictConfig` method of the mocked logging configuration was called with the correct default configuration.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test employs mocking to isolate the logging configuration from the actual logging implementation, allowing for verification of interactions without side effects.\n- **Assertion**: The test uses `assert_called_with` to ensure that the mock's `dictConfig` method was called with the expected argument, which is a common pattern in unit tests to validate that specific interactions occurred as intended."
    },
    {
      "name": "test_custom_configure_logging",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 587,
      "end_line_number": 591,
      "source_code": "def test_custom_configure_logging():\n    with patch(\"sanic.app.logging\") as mock:\n        Sanic(\"Test\", log_config={\"foo\": \"bar\"})\n\n    mock.config.dictConfig.assert_called_with({\"foo\": \"bar\"})",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_custom_configure_logging` function is designed to verify that the Sanic application correctly configures its logging settings when provided with a custom logging configuration.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a Sanic application is instantiated with a custom logging configuration (in this case, `{\"foo\": \"bar\"}`), the logging configuration is applied correctly by asserting that the `dictConfig` method of the logging configuration is called with the expected parameters.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the instantiation of the `Sanic` class with a custom `log_config` argument. The `Sanic` constructor is expected to call the `dictConfig` method from the logging module with the provided configuration. The test uses the `patch` function from the `unittest.mock` module to replace the actual logging configuration with a mock object, allowing the test to verify that the `dictConfig` method is called with the correct arguments without affecting the global logging configuration.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the mocking technique using `patch` to isolate the logging configuration from the actual logging module. This allows for verification of interactions with the logging configuration without side effects. Additionally, the use of assertions on the mock object (`mock.config.dictConfig.assert_called_with(...)`) is a common pattern in unit testing to confirm that specific methods were called with expected arguments, ensuring that the code behaves as intended."
    },
    {
      "name": "test_disable_configure_logging",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 594,
      "end_line_number": 598,
      "source_code": "def test_disable_configure_logging():\n    with patch(\"sanic.app.logging\") as mock:\n        Sanic(\"Test\", configure_logging=False)\n\n    mock.config.dictConfig.assert_not_called()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_disable_configure_logging` test verifies that when the `Sanic` application is instantiated with the `configure_logging` parameter set to `False`, the logging configuration is not applied.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `dictConfig` method of the logging configuration is not called when logging is disabled. This ensures that the application does not set up any logging configuration, which is crucial for scenarios where logging is not desired.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `Sanic` class constructor, which accepts a `configure_logging` parameter. When this parameter is set to `False`, the expected behavior is that the logging configuration should not be initialized. The test uses the `patch` function from the `unittest.mock` module to replace the actual logging configuration with a mock object, allowing the test to assert whether `dictConfig` was called or not.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the mocking technique to isolate the logging configuration from the actual logging library. By using `patch`, it creates a controlled environment where the logging behavior can be monitored without affecting the global logging state. The assertion `mock.config.dictConfig.assert_not_called()` is a clear and direct way to verify that the logging configuration was indeed not invoked, demonstrating effective use of mocks in unit testing."
    },
    {
      "name": "test_inspector",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 602,
      "end_line_number": 604,
      "source_code": "def test_inspector(inspector):\n    app = Sanic(\"Test\", inspector=inspector)\n    assert app.config.INSPECTOR is inspector",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('inspector', (True, False))"
      ],
      "arguments": [
        "inspector"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.config.INSPECTOR is inspector"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_inspector` function is designed to verify that the `inspector` instance passed to the `Sanic` application is correctly assigned to the application's configuration. This ensures that the application is properly set up to utilize the inspector functionality.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the `INSPECTOR` configuration attribute of the `Sanic` application instance (`app`) is the same object as the `inspector` argument provided to the test. This confirms that the application is configured to use the specified inspector instance.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the initialization of a `Sanic` application with an `inspector` parameter. When the `Sanic` app is created, it should store the provided `inspector` in its configuration. The assertion `assert app.config.INSPECTOR is inspector` checks that the reference to the `INSPECTOR` in the app's configuration matches the `inspector` passed in, ensuring that the application is correctly configured to use the inspector.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern to validate the expected state of the application configuration. It uses the `is` operator to check for object identity, which is appropriate here since it verifies that both references point to the same instance. The test is also structured to be simple and direct, focusing solely on the configuration aspect of the `Sanic` application, which is a common practice in unit testing to isolate specific behaviors."
    },
    {
      "name": "test_build_endpoint_name",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 607,
      "end_line_number": 610,
      "source_code": "def test_build_endpoint_name():\n    app = Sanic(\"Test\")\n    name = app._build_endpoint_name(\"foo\", \"bar\")\n    assert name == \"Test.foo.bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert name == 'Test.foo.bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_build_endpoint_name` function is designed to verify the correct construction of endpoint names in a Sanic application. It ensures that the internal method `_build_endpoint_name` generates the expected formatted string when given specific inputs.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the method `_build_endpoint_name` concatenates the application name with the provided endpoint components (\"foo\" and \"bar\") in the correct format, which should be \"Test.foo.bar\". This is crucial for ensuring that endpoint names are consistently formatted, which can affect routing and URL generation in the application.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the private method `_build_endpoint_name` of the `Sanic` class. When called with the arguments \"foo\" and \"bar\", it is expected to return a string that combines the app's name (\"Test\") with the provided endpoint names, separated by a dot. The method likely constructs the name by accessing the app's name attribute and appending the endpoint names.\n\n**Notable Testing Patterns or Techniques Used**:  \nThis test employs a straightforward assertion pattern, where the result of the method call is compared against an expected value using a simple `assert` statement. It does not utilize any mocking or complex setup, reflecting a unit test's goal of testing a specific piece of functionality in isolation. The test is also self-contained, as it creates a new instance of the `Sanic` application specifically for this test case."
    },
    {
      "name": "test_manager_in_main_process_only",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 613,
      "end_line_number": 627,
      "source_code": "def test_manager_in_main_process_only(app: Sanic):\n    message = \"Can only access the manager from the main process\"\n\n    with pytest.raises(SanicException, match=message):\n        app.manager\n\n    app._manager = 1\n    environ[\"SANIC_WORKER_PROCESS\"] = \"ok\"\n\n    with pytest.raises(SanicException, match=message):\n        app.manager\n\n    del environ[\"SANIC_WORKER_PROCESS\"]\n\n    assert app.manager == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.manager == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_manager_in_main_process_only` test is to verify that the `manager` property of the `Sanic` application can only be accessed from the main process. It ensures that attempts to access the manager from a worker process or when the manager is not initialized raise the appropriate exceptions.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks for the correct handling of access restrictions to the `manager` property. It verifies that a `SanicException` is raised with the expected message when trying to access the manager from a worker process or when the environment variable `SANIC_WORKER_PROCESS` is set, indicating that the access is not allowed.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `manager` property of the `Sanic` class. The property checks if the `SANIC_WORKER_PROCESS` environment variable is set or if the `_manager` attribute is not initialized. If either condition is true, it raises a `SanicException` with a specific error message. The test first attempts to access the manager without initialization, then sets `_manager` to a value and simulates a worker process by setting the environment variable, followed by another access attempt, and finally checks that the manager can be accessed correctly when the environment variable is removed.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of `pytest.raises` to assert that specific exceptions are raised under certain conditions, which is a common pattern in unit testing for verifying error handling. Additionally, it manipulates the environment variable `SANIC_WORKER_PROCESS` to simulate different execution contexts, showcasing the use of environment configuration in tests. The test also includes assertions to confirm the expected state of the `manager` property after the conditions are reset, ensuring that the property behaves correctly when accessed from the main process."
    },
    {
      "name": "test_inspector_in_main_process_only",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 630,
      "end_line_number": 644,
      "source_code": "def test_inspector_in_main_process_only(app: Sanic):\n    message = \"Can only access the inspector from the main process\"\n\n    with pytest.raises(SanicException, match=message):\n        app.inspector\n\n    app._inspector = 1\n    environ[\"SANIC_WORKER_PROCESS\"] = \"ok\"\n\n    with pytest.raises(SanicException, match=message):\n        app.inspector\n\n    del environ[\"SANIC_WORKER_PROCESS\"]\n\n    assert app.inspector == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.inspector == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_inspector_in_main_process_only` test is to verify that the `inspector` property of the `Sanic` application can only be accessed from the main process. It ensures that attempts to access the inspector from a worker process or before it is properly initialized raise the appropriate exceptions.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that accessing the `inspector` property raises a `SanicException` with a specific error message when the application is in a worker process or when the inspector has not been enabled. It also verifies that once the inspector is set and accessed from the main process, it returns the expected value.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `inspector` property of the `Sanic` application. The property checks the environment variable `SANIC_WORKER_PROCESS` to determine if it is being accessed from a worker process. If the variable is set or if the inspector is not initialized, it raises a `SanicException` with a message indicating that the inspector can only be accessed from the main process. The test sets the inspector to a value (1) and manipulates the environment variable to simulate different scenarios.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that specific exceptions are raised under certain conditions, which is a common pattern in unit testing for verifying error handling. Additionally, it uses environment variable manipulation to simulate different execution contexts (main process vs. worker process), showcasing the test's ability to validate behavior based on external conditions. The use of assertions to check the final state of the `inspector` property further confirms that the property behaves as expected when accessed correctly."
    },
    {
      "name": "test_stop_trigger_terminate",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 647,
      "end_line_number": 665,
      "source_code": "def test_stop_trigger_terminate(app: Sanic):\n    app.multiplexer = Mock()\n\n    app.stop()\n\n    app.multiplexer.terminate.assert_called_once()\n    app.multiplexer.reset_mock()\n    assert len(Sanic._app_registry) == 1\n    Sanic._app_registry.clear()\n\n    app.stop(terminate=True)\n\n    app.multiplexer.terminate.assert_called_once()\n    app.multiplexer.reset_mock()\n    assert len(Sanic._app_registry) == 0\n    Sanic._app_registry.clear()\n\n    app.stop(unregister=False)\n    app.multiplexer.terminate.assert_called_once()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(Sanic._app_registry) == 1",
        "assert len(Sanic._app_registry) == 0"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        },
        {
          "name": "app.multiplexer.reset_mock",
          "body": "def reset_mock(self, *args, **kwargs):\n    super().reset_mock(*args, **kwargs)\n    self.await_count = 0"
        },
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        },
        {
          "name": "app.multiplexer.reset_mock",
          "body": "def reset_mock(self, *args, **kwargs):\n    super().reset_mock(*args, **kwargs)\n    self.await_count = 0"
        },
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_stop_trigger_terminate` function is designed to verify the behavior of the `stop` method in the `Sanic` application, specifically ensuring that the `multiplexer`'s `terminate` method is called appropriately under different conditions.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. The `terminate` method is called once when `app.stop()` is invoked without any parameters.\n2. The `terminate` method is called once again when `app.stop(terminate=True)` is called.\n3. The `terminate` method is still called when `app.stop(unregister=False)` is executed.\n4. The state of the `Sanic._app_registry` is correctly updated after each stop call, ensuring that the application is registered or unregistered as expected.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `stop` method of the `Sanic` application, which is responsible for stopping the application and managing its lifecycle. The `multiplexer` is a component that handles the termination of processes. The test uses a mock object to simulate the `multiplexer`, allowing the test to assert that the `terminate` method is called without actually executing any real termination logic. The assertions check the call count of `terminate` and the state of the application registry before and after the stop calls.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The `multiplexer` is mocked to isolate the test from the actual implementation, allowing for controlled testing of interactions.\n- **Assertions**: The test uses assertions to verify that the expected methods are called the correct number of times and that the application registry is in the expected state.\n- **State Resetting**: The `reset_mock` method is used to clear the call history of the mock object between assertions, ensuring that each test case is independent and does not interfere with others."
    },
    {
      "name": "test_refresh_pass_passthru_data_to_new_instance",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 668,
      "end_line_number": 674,
      "source_code": "def test_refresh_pass_passthru_data_to_new_instance(app: Sanic):\n    # arrange\n    passthru = {\"_inspector\": 2, \"config\": {\"TOUCHUP\": 23}}\n    app = app.refresh(passthru)\n\n    assert app.inspector == 2\n    assert app.config.TOUCHUP == 23",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.inspector == 2",
        "assert app.config.TOUCHUP == 23"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_refresh_pass_passthru_data_to_new_instance` test is to verify that the `refresh` method of the `Sanic` application correctly updates the application's attributes based on the provided `passthru` dictionary. This ensures that the application can be refreshed with new configurations or states.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `inspector` attribute and a configuration value (`TOUCHUP`) are correctly set to the values specified in the `passthru` dictionary after calling the `refresh` method. It confirms that the application instance retains the updated state.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `refresh` method of the `Sanic` class. This method takes an optional dictionary (`passthru`) and updates the instance's attributes accordingly. If the `passthru` dictionary contains nested dictionaries, it sets the corresponding attributes on the application instance. The test creates a dictionary with an `_inspector` key and a nested `config` dictionary, then calls `app.refresh(passthru)`. After the refresh, it asserts that `app.inspector` is set to `2` and `app.config.TOUCHUP` is set to `23`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the Arrange-Act-Assert (AAA) pattern, where:\n- **Arrange**: The test sets up the necessary data (`passthru` dictionary).\n- **Act**: It calls the `refresh` method on the `app` instance.\n- **Assert**: It checks the expected outcomes using assertions to ensure the state of the application is as intended after the method call. This pattern enhances readability and maintainability of the test. Additionally, the test uses direct assertions to validate the state of the application, which is a common practice in unit testing to ensure that the code behaves as expected."
    },
    {
      "name": "test_setup",
      "module": "test_timeout_logic",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_timeout_logic.py",
      "line_number": 35,
      "end_line_number": 38,
      "source_code": "def test_setup(protocol: HttpProtocol):\n    assert protocol._task is not None\n    assert protocol._http is not None\n    assert protocol._time is not None",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "protocol"
      ],
      "imports": [
        "asyncio",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.exceptions.RequestTimeout",
        "sanic.exceptions.ServiceUnavailable",
        "sanic.http.Stage",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert protocol._task is not None",
        "assert protocol._http is not None",
        "assert protocol._time is not None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_setup` function is designed to verify that the essential attributes of the `protocol` object, specifically `_task`, `_http`, and `_time`, are properly initialized and not set to `None`. This ensures that the `HttpProtocol` class is correctly set up before any further operations are performed.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks the initialization state of the `protocol` object. It asserts that the `_task`, `_http`, and `_time` attributes are all instantiated, which is crucial for the proper functioning of the protocol's operations. If any of these attributes were `None`, it would indicate a failure in the setup process, potentially leading to runtime errors during the protocol's execution.\n\n**Code Being Tested and How It Works**:  \nThe test indirectly verifies the behavior of the `_setup` and `_setup_connection` methods within the `HttpProtocolMixin` class. These methods are responsible for initializing the protocol's state, including setting up the HTTP connection and recording the current time. The test does not call these methods directly but relies on the assumption that they are invoked during the instantiation of the `protocol` object.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs simple assertions to validate the state of the `protocol` object. It uses direct attribute checks, which is a straightforward and effective approach for unit tests. The absence of a docstring and the lack of a specific method under test suggest that this test is primarily focused on ensuring the integrity of the object's state rather than testing a specific function or method in isolation. This pattern is common in unit tests where the goal is to validate the setup and initialization of complex objects."
    },
    {
      "name": "test_check_timeouts_no_timeout",
      "module": "test_timeout_logic",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_timeout_logic.py",
      "line_number": 41,
      "end_line_number": 50,
      "source_code": "def test_check_timeouts_no_timeout(protocol: HttpProtocol):\n    protocol.keep_alive_timeout = 1\n    protocol.loop.call_later = Mock()\n    protocol.check_timeouts()\n    protocol._task.cancel.assert_not_called()\n    assert protocol._http.stage is Stage.IDLE\n    assert protocol._http.exception is None\n    protocol.loop.call_later.assert_called_with(\n        protocol.keep_alive_timeout / 2, protocol.check_timeouts\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "protocol"
      ],
      "imports": [
        "asyncio",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.exceptions.RequestTimeout",
        "sanic.exceptions.ServiceUnavailable",
        "sanic.http.Stage",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert protocol._http.stage is Stage.IDLE",
        "assert protocol._http.exception is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_check_timeouts_no_timeout` test is to verify that the `check_timeouts` method of the `HttpProtocol` class behaves correctly when there are no timeouts triggered. Specifically, it ensures that the connection remains active and that no cancellation of tasks occurs when the keep-alive timeout has not been exceeded.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when the protocol is in an idle state and the elapsed time since the last activity is less than the keep-alive timeout, the following conditions hold true:\n1. The task associated with the protocol is not canceled.\n2. The HTTP stage remains in `Stage.IDLE`.\n3. No exceptions are set on the HTTP object.\n4. The `check_timeouts` method is scheduled to be called again after half of the keep-alive timeout duration.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `check_timeouts` method within the `HttpProtocol` class. This method checks the elapsed time since the last recorded time (`_time`) and compares it against various timeout thresholds (keep-alive, request, and response timeouts). If the elapsed time exceeds the keep-alive timeout while in the `Stage.IDLE`, it should not cancel the task or set any exceptions. Instead, it should schedule the next call to `check_timeouts` using `loop.call_later`, which is mocked in the test to verify that it is called with the correct timing.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable testing techniques:\n1. **Mocking**: The `loop.call_later` method is mocked to control and verify the scheduling of the next timeout check without actually waiting for real time to pass.\n2. **Assertions**: The test uses assertions to confirm that the task cancellation method (`_task.cancel`) is not called, and it checks the state of the protocol's HTTP object to ensure it remains idle and free of exceptions.\n3. **Fixture Usage**: The `protocol` fixture sets up a controlled environment for the test, ensuring that each test runs with a fresh instance of `HttpProtocol` and its dependencies, promoting isolation and repeatability of tests."
    },
    {
      "name": "test_check_timeouts_keep_alive_timeout",
      "module": "test_timeout_logic",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_timeout_logic.py",
      "line_number": 53,
      "end_line_number": 58,
      "source_code": "def test_check_timeouts_keep_alive_timeout(protocol: HttpProtocol):\n    protocol._http.stage = Stage.IDLE\n    protocol._time = 0\n    protocol.check_timeouts()\n    protocol._task.cancel.assert_called_once()\n    assert protocol._http.exception is None",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "protocol"
      ],
      "imports": [
        "asyncio",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.exceptions.RequestTimeout",
        "sanic.exceptions.ServiceUnavailable",
        "sanic.http.Stage",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert protocol._http.exception is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_check_timeouts_keep_alive_timeout` is designed to verify that the `check_timeouts` method of the `HttpProtocol` class correctly handles the scenario where the protocol is in the IDLE state and the keep-alive timeout has expired. Specifically, it checks that the connection is canceled and that no exceptions are raised during this process.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when the protocol is in the IDLE state and the timeout conditions are met, the connection is properly canceled (indicated by the assertion that `_task.cancel` is called once) and that the `_http.exception` attribute remains `None`, indicating that no errors occurred during the timeout check.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `check_timeouts` method within the `HttpProtocol` class. This method checks the elapsed time since the last activity and determines if any timeouts have occurred based on the current state of the protocol. In the IDLE state, if the elapsed time exceeds the `keep_alive_timeout`, the method should cancel the connection task and ensure that no exceptions are set in the `_http` object.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the expected outcomes, specifically using `assert_called_once` to confirm that the cancellation of the task occurs exactly once. It also uses a direct assertion to check that no exceptions were raised during the timeout check. This pattern of asserting method calls and state conditions is common in unit testing to ensure that the code behaves as expected under specific conditions. Additionally, the test is structured to be run with a mock `protocol` object, allowing for isolated testing of the timeout logic without dependencies on the broader application context."
    },
    {
      "name": "test_check_timeouts_request_timeout",
      "module": "test_timeout_logic",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_timeout_logic.py",
      "line_number": 61,
      "end_line_number": 66,
      "source_code": "def test_check_timeouts_request_timeout(protocol: HttpProtocol):\n    protocol._http.stage = Stage.REQUEST\n    protocol._time = 0\n    protocol.check_timeouts()\n    protocol._task.cancel.assert_called_once()\n    assert isinstance(protocol._http.exception, RequestTimeout)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "protocol"
      ],
      "imports": [
        "asyncio",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.exceptions.RequestTimeout",
        "sanic.exceptions.ServiceUnavailable",
        "sanic.http.Stage",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(protocol._http.exception, RequestTimeout)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_check_timeouts_request_timeout` is designed to verify that the `check_timeouts` method of the `HttpProtocol` class correctly identifies a request timeout scenario and handles it appropriately by canceling the associated task and raising a `RequestTimeout` exception.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when the protocol is in the `REQUEST` stage and the time is set to zero (indicating a timeout), the method `check_timeouts` will cancel the current task and set the `_http.exception` attribute to an instance of `RequestTimeout`. This ensures that the system behaves correctly under timeout conditions.\n\n**Code Being Tested and How It Works**:  \nThe relevant code being tested is the `check_timeouts` method within the `HttpProtocol` class. When invoked, this method assesses the current state of the protocol (in this case, whether it is in the `REQUEST` stage) and checks if the elapsed time exceeds the allowed timeout threshold. If it does, it cancels the ongoing task (using `protocol._task.cancel()`) and raises a `RequestTimeout` exception, which is stored in `protocol._http.exception`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the expected outcomes. It uses `assert_called_once()` to ensure that the task cancellation method was invoked exactly once, which is a common pattern in unit testing to verify interactions with mock objects. Additionally, the test checks the type of the exception raised, ensuring that the correct exception type (`RequestTimeout`) is set, which is a typical approach to confirm that error handling is functioning as intended. The test is structured to be clear and concise, focusing on a single behavior, which is a best practice in unit testing."
    },
    {
      "name": "test_check_timeouts_response_timeout",
      "module": "test_timeout_logic",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_timeout_logic.py",
      "line_number": 69,
      "end_line_number": 74,
      "source_code": "def test_check_timeouts_response_timeout(protocol: HttpProtocol):\n    protocol._http.stage = Stage.RESPONSE\n    protocol._time = 0\n    protocol.check_timeouts()\n    protocol._task.cancel.assert_called_once()\n    assert isinstance(protocol._http.exception, ServiceUnavailable)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "protocol"
      ],
      "imports": [
        "asyncio",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.exceptions.RequestTimeout",
        "sanic.exceptions.ServiceUnavailable",
        "sanic.http.Stage",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(protocol._http.exception, ServiceUnavailable)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_check_timeouts_response_timeout` is designed to verify that the `check_timeouts` method of the `HttpProtocol` class correctly handles a timeout scenario when the protocol is in the RESPONSE stage. Specifically, it checks that the appropriate timeout behavior is triggered, leading to the cancellation of the current task and the setting of a `ServiceUnavailable` exception.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when the protocol is in the RESPONSE stage and the timeout condition is met (indicated by `_time` being set to 0), the task associated with the protocol is canceled, and a `ServiceUnavailable` exception is raised. This behavior is crucial for maintaining the reliability and responsiveness of the server when it encounters timeout situations.\n\n**Code Being Tested and How It Works**:  \nThe code under test is part of the `HttpProtocol` class, specifically the `check_timeouts` method. When invoked, this method checks the current state of the protocol (in this case, the RESPONSE stage) and the elapsed time. If the conditions for a timeout are met, it cancels the ongoing task (using `protocol._task.cancel()`) and sets an exception on the HTTP context (`protocol._http.exception`). The test sets up the protocol's state to simulate this timeout scenario and verifies the expected outcomes.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs mocking to isolate the behavior of the `HttpProtocol` class. It uses `Mock()` to create a mock task that allows assertions on whether the `cancel` method was called. Additionally, it uses assertions to check the type of the exception raised, ensuring that the correct exception (`ServiceUnavailable`) is set in the protocol's HTTP context. This approach of using mocks and assertions is a common pattern in unit testing to verify interactions and state changes without relying on the full implementation of dependencies."
    },
    {
      "name": "test_load_module_from_file_location",
      "module": "test_utils",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_utils.py",
      "line_number": 19,
      "end_line_number": 22,
      "source_code": "def test_load_module_from_file_location(location):\n    module = load_module_from_file_location(location)\n\n    assert isinstance(module, ModuleType)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('location', (Path(__file__).parent / 'static' / 'app_test_config.py', str(Path(__file__).parent / 'static' / 'app_test_config.py'), str(Path(__file__).parent / 'static' / 'app_test_config.py').encode()))"
      ],
      "arguments": [
        "location"
      ],
      "imports": [
        "os.environ",
        "pathlib.Path",
        "types.ModuleType",
        "pytest",
        "sanic.exceptions.LoadFileException",
        "sanic.utils.load_module_from_file_location"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(module, ModuleType)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_load_module_from_file_location` test is to verify that the `load_module_from_file_location` function correctly loads a Python module from a specified file location and returns an instance of `ModuleType`.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the output of the `load_module_from_file_location` function is indeed a module. It uses the `isinstance` function to assert that the returned object is of type `ModuleType`, which confirms that the function successfully loaded a module.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `load_module_from_file_location` function, which takes a file path (as a string, bytes, or `Path` object) and attempts to load a Python module from that location. The function handles different types of input, including paths that may contain environment variables. It checks for the existence of these environment variables and raises a `LoadFileException` if any are not defined. The test uses various parameterized inputs to ensure that the function can handle different formats of file paths.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.mark.parametrize` decorator to run the same test logic with multiple input values, which enhances test coverage and ensures that the function behaves correctly across different types of file paths. This approach allows for efficient testing of multiple scenarios without duplicating code. Additionally, the use of `assert` statements provides a straightforward way to validate the expected outcomes of the function under test."
    },
    {
      "name": "test_loaded_module_from_file_location_name",
      "module": "test_utils",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_utils.py",
      "line_number": 25,
      "end_line_number": 33,
      "source_code": "def test_loaded_module_from_file_location_name():\n    module = load_module_from_file_location(\n        str(Path(__file__).parent / \"static\" / \"app_test_config.py\")\n    )\n\n    name = module.__name__\n    if \"C:\\\\\" in name:\n        name = name.split(\"\\\\\")[-1]\n    assert name == \"app_test_config\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "os.environ",
        "pathlib.Path",
        "types.ModuleType",
        "pytest",
        "sanic.exceptions.LoadFileException",
        "sanic.utils.load_module_from_file_location"
      ],
      "fixtures": [],
      "assertions": [
        "assert name == 'app_test_config'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_loaded_module_from_file_location_name` test is to verify that a module loaded from a specified file location has the correct name. This ensures that the `load_module_from_file_location` function behaves as expected when loading Python modules from file paths.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the name of the loaded module matches the expected name, which is `\"app_test_config\"`. It also handles potential discrepancies in the module name that may arise from different file path formats, particularly on Windows systems.\n\n**Code Being Tested and How It Works**:  \nThe test calls the `load_module_from_file_location` function with the path to `app_test_config.py`, which is located in a `static` directory relative to the test file. After loading the module, it retrieves the module's name using `module.__name__`. If the name contains a Windows-style path (indicated by the presence of `\"C:\\\\\"`), it extracts just the module name from the full path. Finally, it asserts that the name is equal to `\"app_test_config\"`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern to validate the expected outcome. It also includes a conditional check to handle platform-specific path formats, demonstrating a consideration for cross-platform compatibility. The use of `assert` statements is a common practice in unit testing to confirm that the actual output matches the expected output."
    },
    {
      "name": "test_load_module_from_file_location_with_non_existing_env_variable",
      "module": "test_utils",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_utils.py",
      "line_number": 36,
      "end_line_number": 41,
      "source_code": "def test_load_module_from_file_location_with_non_existing_env_variable():\n    with pytest.raises(\n        LoadFileException,\n        match=\"The following environment variables are not set: MuuMilk\",\n    ):\n        load_module_from_file_location(\"${MuuMilk}\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "os.environ",
        "pathlib.Path",
        "types.ModuleType",
        "pytest",
        "sanic.exceptions.LoadFileException",
        "sanic.utils.load_module_from_file_location"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the test `test_load_module_from_file_location_with_non_existing_env_variable` is to verify that the `load_module_from_file_location` function correctly raises a `LoadFileException` when an environment variable referenced in the file location string does not exist.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks the error handling behavior of the `load_module_from_file_location` function. It ensures that when an invalid environment variable (in this case, `MuuMilk`) is used in the file path, the function raises an exception with a message indicating which environment variables are not set.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `load_module_from_file_location` function, which attempts to load a module from a specified file path. The function checks if the provided path contains any environment variables in the format `${some_env_var}`. If such variables are found, it verifies their existence in the environment. If any are missing, it raises a `LoadFileException` with a message listing the undefined variables. In this test, the input is the string `${MuuMilk}`, which does not correspond to any existing environment variable, triggering the exception.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that an exception is raised during the execution of the code block. It also uses the `match` parameter to verify that the exception message contains the expected text, ensuring that the test not only checks for the occurrence of the exception but also validates the correctness of the error message. This pattern is effective for testing error conditions in a clean and readable manner."
    },
    {
      "name": "test_load_module_from_file_location_using_env",
      "module": "test_utils",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_utils.py",
      "line_number": 44,
      "end_line_number": 49,
      "source_code": "def test_load_module_from_file_location_using_env():\n    environ[\"APP_TEST_CONFIG\"] = \"static/app_test_config.py\"\n    location = str(Path(__file__).parent / \"${APP_TEST_CONFIG}\")\n    module = load_module_from_file_location(location)\n\n    assert isinstance(module, ModuleType)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "os.environ",
        "pathlib.Path",
        "types.ModuleType",
        "pytest",
        "sanic.exceptions.LoadFileException",
        "sanic.utils.load_module_from_file_location"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(module, ModuleType)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_load_module_from_file_location_using_env` test is to verify that the `load_module_from_file_location` function can successfully load a Python module specified by a file path that includes an environment variable. This ensures that the function can handle dynamic file paths based on environment configurations.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when the environment variable `APP_TEST_CONFIG` is set to a valid file path, the module loaded from that path is indeed of type `ModuleType`. This confirms that the module loading mechanism works correctly with environment variables.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `load_module_from_file_location` function, which takes a file path (potentially containing environment variables) and returns the loaded module. In this test, the environment variable `APP_TEST_CONFIG` is set to point to `static/app_test_config.py`. The test constructs the file path using this environment variable and calls the function. The assertion checks that the returned object is an instance of `ModuleType`, indicating that a module was successfully loaded.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of environment variables to dynamically set the file path, showcasing a common pattern in configuration management for applications. It also uses the `assert` statement to validate the type of the returned module, which is a straightforward yet effective way to ensure that the function behaves as expected. The test is structured to be simple and focused, making it easy to understand the intent and outcome."
    },
    {
      "name": "test_handler_operation_order",
      "module": "test_handler",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_handler.py",
      "line_number": 6,
      "end_line_number": 36,
      "source_code": "def test_handler_operation_order(app: Sanic):\n    operations = []\n\n    @app.on_request\n    async def on_request(_):\n        nonlocal operations\n        operations.append(1)\n\n    @app.on_response\n    async def on_response(*_):\n        nonlocal operations\n        operations.append(5)\n\n    @app.get(\"/\")\n    async def handler(_):\n        nonlocal operations\n        operations.append(3)\n        return empty()\n\n    @app.signal(Event.HTTP_HANDLER_BEFORE)\n    async def handler_before(**_):\n        nonlocal operations\n        operations.append(2)\n\n    @app.signal(Event.HTTP_HANDLER_AFTER)\n    async def handler_after(**_):\n        nonlocal operations\n        operations.append(4)\n\n    app.test_client.get(\"/\")\n    assert operations == [1, 2, 3, 4, 5]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "sanic.app.Sanic",
        "sanic.response.empty",
        "sanic.signals.Event"
      ],
      "fixtures": [],
      "assertions": [
        "assert operations == [1, 2, 3, 4, 5]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_handler_operation_order` test is to verify the order of operations executed during the lifecycle of an HTTP request in a Sanic application. It ensures that the various event handlers and middleware functions are called in the expected sequence when a request is made to the application.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the operations are executed in the correct order: \n1. The `on_request` handler is triggered first.\n2. The `handler_before` signal is emitted next.\n3. The main request handler is executed.\n4. The `handler_after` signal is emitted.\n5. Finally, the `on_response` handler is called.\n\nThe expected order of operations is validated by asserting that the `operations` list matches the sequence `[1, 2, 3, 4, 5]`.\n\n**Code Being Tested and How It Works**:  \nThe code being tested includes several asynchronous functions registered as event handlers and route handlers in a Sanic application. The `on_request` and `on_response` handlers are triggered at the beginning and end of the request lifecycle, respectively. The `handler_before` and `handler_after` functions are connected to specific HTTP events, ensuring they are called at the appropriate times. The main handler for the route `\"/\"` appends its own operation to the list when it is executed. The test simulates a GET request to the root endpoint using `app.test_client.get(\"/\")`, which triggers the entire sequence of operations.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Nonlocal Variables**: The use of `nonlocal` allows the inner functions to modify the `operations` list defined in the outer scope, which is a common pattern in Python for maintaining state across nested functions.\n- **Event-Driven Testing**: The test leverages Sanic's event-driven architecture by registering handlers for specific events, allowing for a clear and structured way to test the order of operations.\n- **Assertions**: The final assertion checks the order of operations in a single line, making it easy to verify the expected behavior succinctly. This is a common practice in unit tests to ensure that the output matches the expected results."
    },
    {
      "name": "test_register_system_signals",
      "module": "test_signal_handlers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_signal_handlers.py",
      "line_number": 44,
      "end_line_number": 56,
      "source_code": "def test_register_system_signals(app):\n    \"\"\"Test if sanic register system signals\"\"\"\n\n    @app.route(\"/hello\")\n    async def hello_route(request):\n        return HTTPResponse()\n\n    app.listener(\"after_server_start\")(stop)\n    app.listener(\"before_server_start\")(set_loop)\n    app.listener(\"after_server_stop\")(after)\n\n    app.run(HOST, PORT, single_process=True)\n    assert calledq.get() is True",
      "docstring": "Test if sanic register system signals",
      "decorators": [
        "pytest.mark.skipif(os.name == 'nt', reason='May hang CI on py38/windows')"
      ],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "os",
        "signal",
        "queue.Queue",
        "types.SimpleNamespace",
        "typing.Optional",
        "unittest.mock.MagicMock",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.compat.ctrlc_workaround_for_windows",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ServerError",
        "sanic.response.HTTPResponse",
        "sanic.signals.Event"
      ],
      "fixtures": [],
      "assertions": [
        "assert calledq.get() is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "calledq.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_register_system_signals` function aims to verify that the Sanic application correctly registers system signals when the server starts. This is crucial for ensuring that the application can handle system events like shutdowns gracefully.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks whether the application responds correctly to system signals by asserting that a specific condition (`calledq.get()`) returns `True`. This indicates that the expected signal handling behavior has been triggered during the server's lifecycle.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a simple route (`/hello`) and registers listeners for various server events (like `after_server_start`, `before_server_start`, and `after_server_stop`). It then runs the application with system signals enabled. The `app.run` method is responsible for starting the server, and the `calledq.get()` method is expected to return `True` if the signal handling was registered and executed correctly.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test uses asynchronous route handlers and listeners, which is a common pattern in modern web frameworks like Sanic.\n- **Event Listener Registration**: The test demonstrates the use of event listeners to hook into the application lifecycle, allowing for custom behavior during specific events.\n- **Assertions**: The test employs assertions to validate the expected outcome, ensuring that the application behaves as intended when system signals are registered."
    },
    {
      "name": "test_no_register_system_signals_fails",
      "module": "test_signal_handlers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_signal_handlers.py",
      "line_number": 60,
      "end_line_number": 77,
      "source_code": "def test_no_register_system_signals_fails(app):\n    \"\"\"Test if sanic don't register system signals\"\"\"\n\n    @app.route(\"/hello\")\n    async def hello_route(request):\n        return HTTPResponse()\n\n    app.listener(\"after_server_start\")(stop)\n    app.listener(\"before_server_start\")(set_loop)\n    app.listener(\"after_server_stop\")(after)\n\n    message = (\n        r\"Cannot run Sanic\\.serve with register_sys_signals=False\\. Use \"\n        r\"Sanic.serve_single\\.\"\n    )\n    with pytest.raises(RuntimeError, match=message):\n        app.prepare(HOST, PORT, register_sys_signals=False)\n    assert calledq.empty()",
      "docstring": "Test if sanic don't register system signals",
      "decorators": [
        "pytest.mark.skipif(os.name == 'nt', reason='May hang CI on py38/windows')"
      ],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "os",
        "signal",
        "queue.Queue",
        "types.SimpleNamespace",
        "typing.Optional",
        "unittest.mock.MagicMock",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.compat.ctrlc_workaround_for_windows",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ServerError",
        "sanic.response.HTTPResponse",
        "sanic.signals.Event"
      ],
      "fixtures": [],
      "assertions": [
        "assert calledq.empty()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_no_register_system_signals_fails` is designed to verify that the Sanic application raises a `RuntimeError` when attempting to prepare the application with the `register_sys_signals` parameter set to `False`. This ensures that the application correctly enforces the requirement for system signal registration during its startup process.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that the application does not allow the server to start without registering system signals, which are crucial for handling events like termination signals (e.g., SIGINT). The expected behavior is that a `RuntimeError` is raised with a specific message when the application is prepared with `register_sys_signals=False`.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `app.prepare()` method, which is called with `register_sys_signals=False`. The test sets up a simple route and attaches listeners for server lifecycle events. When `app.prepare()` is invoked, it checks the `register_sys_signals` flag. If set to `False`, it raises a `RuntimeError` with a message indicating that the server cannot run without registering system signals. The test also checks that a queue (`calledq`) remains empty, which likely indicates that no unexpected signals were processed.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises()` context manager to assert that a specific exception is raised during the execution of the code block. This is a common pattern in unit testing to verify that error handling works as expected. Additionally, the use of a regex pattern in the `match` argument allows for flexible matching of the error message, ensuring that the test is not overly strict while still confirming the presence of the expected error condition. The test also utilizes the `assert` statement to confirm the state of `calledq`, ensuring that no signals were processed during the test execution."
    },
    {
      "name": "test_dont_register_system_signals",
      "module": "test_signal_handlers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_signal_handlers.py",
      "line_number": 81,
      "end_line_number": 93,
      "source_code": "def test_dont_register_system_signals(app):\n    \"\"\"Test if sanic don't register system signals\"\"\"\n\n    @app.route(\"/hello\")\n    async def hello_route(request):\n        return HTTPResponse()\n\n    app.listener(\"after_server_start\")(stop)\n    app.listener(\"before_server_start\")(set_loop)\n    app.listener(\"after_server_stop\")(after)\n\n    app.run(HOST, PORT, register_sys_signals=False, single_process=True)\n    assert calledq.get() is False",
      "docstring": "Test if sanic don't register system signals",
      "decorators": [
        "pytest.mark.skipif(os.name == 'nt', reason='May hang CI on py38/windows')"
      ],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "os",
        "signal",
        "queue.Queue",
        "types.SimpleNamespace",
        "typing.Optional",
        "unittest.mock.MagicMock",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.compat.ctrlc_workaround_for_windows",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ServerError",
        "sanic.response.HTTPResponse",
        "sanic.signals.Event"
      ],
      "fixtures": [],
      "assertions": [
        "assert calledq.get() is False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "calledq.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_dont_register_system_signals` test is to verify that the Sanic application does not register system signals when the `register_sys_signals` parameter is set to `False` during the application run. This is crucial for ensuring that the application behaves as expected in environments where signal handling is not desired or supported.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the application does not respond to system signals (like SIGINT) by asserting that a certain condition (`calledq.get()`) returns `False`. This indicates that the application has not registered any signal handlers that would typically be triggered by such signals.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a simple Sanic application with a route (`/hello`) and registers several listeners for different server events (like `after_server_start`, `before_server_start`, and `after_server_stop`). It then runs the application with `register_sys_signals=False`, which is the key parameter being tested. The assertion `assert calledq.get() is False` checks the state of `calledq`, which presumably tracks whether any signal handlers were invoked, confirming that no system signals were registered.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of asynchronous programming with the Sanic framework, as indicated by the use of `async def` for the route handler. It also utilizes decorators to register listeners for application events, showcasing a common pattern in event-driven programming. The use of assertions to validate the expected state after running the application is a standard practice in unit testing, ensuring that the behavior of the code aligns with the specified requirements. Additionally, the test is structured to be run in an environment that supports pytest, leveraging its capabilities for asynchronous testing with the `@pytest.mark.asyncio` decorator."
    },
    {
      "name": "test_windows_workaround",
      "module": "test_signal_handlers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_signal_handlers.py",
      "line_number": 97,
      "end_line_number": 139,
      "source_code": "def test_windows_workaround():\n    \"\"\"Test Windows workaround (on any other OS)\"\"\"\n\n    # At least some code coverage, even though this test doesn't work on\n    # Windows...\n    class MockApp:\n        def __init__(self):\n            self.state = SimpleNamespace()\n            self.state.is_stopping = False\n\n        def stop(self):\n            assert not self.state.is_stopping\n            self.state.is_stopping = True\n\n        def add_task(self, func):\n            loop = asyncio.get_event_loop()\n            self.stay_active_task = loop.create_task(func(self))\n\n    async def atest(stop_first):\n        app = MockApp()\n        ctrlc_workaround_for_windows(app)\n        await asyncio.sleep(0.05)\n        if stop_first:\n            app.stop()\n            await asyncio.sleep(0.2)\n        assert app.state.is_stopping == stop_first\n        # First Ctrl+C: should call app.stop() within 0.1 seconds\n        os.kill(os.getpid(), signal.SIGINT)\n        await asyncio.sleep(0.2)\n        assert app.state.is_stopping\n        assert app.stay_active_task.result() is None\n        # Second Ctrl+C should raise\n        with pytest.raises(KeyboardInterrupt):\n            os.kill(os.getpid(), signal.SIGINT)\n        return \"OK\"\n\n    # Run in our private loop\n    loop = asyncio.new_event_loop()\n    asyncio.set_event_loop(loop)\n    res = loop.run_until_complete(atest(False))\n    assert res == \"OK\"\n    res = loop.run_until_complete(atest(True))\n    assert res == \"OK\"",
      "docstring": "Test Windows workaround (on any other OS)",
      "decorators": [
        "pytest.mark.skipif(os.name == 'nt', reason='windows cannot SIGINT processes')"
      ],
      "arguments": [],
      "imports": [
        "asyncio",
        "os",
        "signal",
        "queue.Queue",
        "types.SimpleNamespace",
        "typing.Optional",
        "unittest.mock.MagicMock",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.compat.ctrlc_workaround_for_windows",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ServerError",
        "sanic.response.HTTPResponse",
        "sanic.signals.Event"
      ],
      "fixtures": [],
      "assertions": [
        "assert res == 'OK'",
        "assert res == 'OK'",
        "assert app.state.is_stopping == stop_first",
        "assert app.state.is_stopping",
        "assert app.stay_active_task.result() is None",
        "assert not self.state.is_stopping"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_windows_workaround` function aims to verify the behavior of a workaround for handling `SIGINT` (Ctrl+C) signals in a Sanic application running on non-Windows operating systems. It ensures that the application can gracefully stop when receiving a signal, and that subsequent signals behave as expected.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two scenarios: \n1. When the application is instructed to stop first (`stop_first` is `True`), it verifies that the application stops correctly and that the state reflects this.\n2. It also tests the behavior of the application when it receives a `SIGINT` signal, ensuring that the application stops within a specified time frame and that a second `SIGINT` raises a `KeyboardInterrupt`.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `ctrlc_workaround_for_windows` function, which sets up a signal handler for `SIGINT` and starts an asynchronous task that keeps the application active. The `MockApp` class simulates the behavior of a Sanic application, allowing the test to assert the state of the application during the signal handling process. The `stop` method in `MockApp` changes the state to indicate that the application is stopping, and the `add_task` method allows the test to run asynchronous functions.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The `MockApp` class is used to simulate the behavior of a real Sanic application without requiring a full application context.\n- **Asynchronous Testing**: The test uses `asyncio` to handle asynchronous operations, allowing for non-blocking waits and signal handling.\n- **Signal Handling**: The test directly interacts with operating system signals to verify the application's response to `SIGINT`, showcasing how to test signal-driven behavior in an asynchronous context.\n- **Assertions**: Multiple assertions are used to validate the state of the application and the results of tasks, ensuring that the expected behavior occurs under different conditions."
    },
    {
      "name": "test_signals_with_invalid_invocation",
      "module": "test_signal_handlers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_signal_handlers.py",
      "line_number": 143,
      "end_line_number": 153,
      "source_code": "def test_signals_with_invalid_invocation(app):\n    \"\"\"Test if sanic register fails with invalid invocation\"\"\"\n\n    @app.route(\"/hello\")\n    async def hello_route(request):\n        return HTTPResponse()\n\n    with pytest.raises(\n        BadRequest, match=\"Invalid event registration: Missing event name\"\n    ):\n        app.listener(stop)",
      "docstring": "Test if sanic register fails with invalid invocation",
      "decorators": [
        "pytest.mark.skipif(os.name == 'nt', reason='May hang CI on py38/windows')"
      ],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "os",
        "signal",
        "queue.Queue",
        "types.SimpleNamespace",
        "typing.Optional",
        "unittest.mock.MagicMock",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.compat.ctrlc_workaround_for_windows",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ServerError",
        "sanic.response.HTTPResponse",
        "sanic.signals.Event"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_signals_with_invalid_invocation` aims to verify that the Sanic application correctly raises a `BadRequest` exception when an invalid event registration is attempted, specifically when the event name is missing.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks the error handling mechanism of the Sanic framework when an event listener is registered without a valid event name. It ensures that the application does not silently fail or behave unexpectedly, but instead raises an appropriate exception with a clear error message.\n\n**Code Being Tested and How It Works**:  \nThe test defines a simple route `/hello` that returns an HTTP response. It then attempts to register a listener for an event (in this case, `stop`) without providing a valid event name. The `app.listener(stop)` call is expected to trigger the error handling logic in the Sanic framework, which should raise a `BadRequest` exception with the message \"Invalid event registration: Missing event name\".\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Manager for Exception Testing**: The test uses `pytest.raises` as a context manager to assert that a specific exception (`BadRequest`) is raised during the execution of the code block. This is a common pattern in unit testing to verify that error conditions are handled correctly.\n- **Match Parameter**: The `match` parameter in `pytest.raises` is utilized to ensure that the exception message matches the expected string, providing a more granular check that the correct error is raised with the appropriate message.\n- **Asynchronous Testing**: Although the test itself does not involve asynchronous code, it is structured to fit within the asynchronous context of the Sanic framework, which is important for testing web applications that handle asynchronous requests."
    },
    {
      "name": "test_signal_server_lifecycle_exception",
      "module": "test_signal_handlers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_signal_handlers.py",
      "line_number": 156,
      "end_line_number": 176,
      "source_code": "def test_signal_server_lifecycle_exception(app: Sanic):\n    trigger: Optional[Exception] = None\n\n    @app.route(\"/hello\")\n    async def hello_route(request):\n        return HTTPResponse()\n\n    @app.signal(Event.SERVER_EXCEPTION_REPORT)\n    async def test_signal(exception: Exception):\n        nonlocal trigger\n        trigger = exception\n\n    @app.before_server_start\n    async def test_before_server_start(app):\n        raise ServerError(\"test_before_server_start\")\n\n    with pytest.raises(ServerError, match=\"test_before_server_start\"):\n        app.run(single_process=True)\n\n    assert isinstance(trigger, ServerError)\n    assert str(trigger) == \"test_before_server_start\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "os",
        "signal",
        "queue.Queue",
        "types.SimpleNamespace",
        "typing.Optional",
        "unittest.mock.MagicMock",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.compat.ctrlc_workaround_for_windows",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ServerError",
        "sanic.response.HTTPResponse",
        "sanic.signals.Event"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(trigger, ServerError)",
        "assert str(trigger) == 'test_before_server_start'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_signal_server_lifecycle_exception` test is to verify that the Sanic application correctly handles exceptions raised during the server's lifecycle, specifically during the `before_server_start` phase. It ensures that such exceptions are reported and can be captured through the appropriate signal.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a `ServerError` is raised in the `before_server_start` listener, it is properly caught and reported via the `Event.SERVER_EXCEPTION_REPORT` signal. The test also confirms that the exception is of the expected type and contains the correct message.\n\n**Code Being Tested and How It Works**:  \nThe test defines a Sanic application with a route and a signal handler for `Event.SERVER_EXCEPTION_REPORT`. It raises a `ServerError` with a specific message in the `before_server_start` listener. The `app.run()` method is called within a context that expects a `ServerError` to be raised, which is verified using `pytest.raises()`. After the server run, the test checks that the `trigger` variable, which captures the exception, is indeed a `ServerError` and that its message matches the expected string.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Signal Handling**: The test utilizes Sanic's signal mechanism to handle exceptions during the server lifecycle, demonstrating how to respond to specific events in the application lifecycle.\n- **Context Management with pytest.raises**: It employs `pytest.raises()` to assert that the expected exception is raised during the execution of `app.run()`, ensuring that the test fails if the exception is not raised.\n- **Nonlocal Variable**: The use of a `nonlocal` variable (`trigger`) allows the test to capture the exception raised in the signal handler, showcasing a technique for sharing state between nested functions."
    },
    {
      "name": "test_url_attributes_with_ssl_context",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 140,
      "end_line_number": 160,
      "source_code": "def test_url_attributes_with_ssl_context(app, path, query, expected_url):\n    context = ssl.create_default_context(purpose=ssl.Purpose.CLIENT_AUTH)\n    context.load_cert_chain(localhost_cert, localhost_key)\n\n    async def handler(request):\n        return text(\"OK\")\n\n    app.add_route(handler, path)\n\n    request, _ = app.test_client.get(\n        f\"https://{HOST}:{PORT}\" + path + f\"?{query}\",\n        server_kwargs={\"ssl\": context},\n    )\n    assert request.url == expected_url.format(HOST, request.server_port)\n\n    parsed = urlparse(request.url)\n\n    assert parsed.scheme == request.scheme\n    assert parsed.path == request.path\n    assert parsed.query == request.query_string\n    assert parsed.netloc == request.host",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('path,query,expected_url', [('/foo', '', 'https://{}:{}/foo'), ('/bar/baz', '', 'https://{}:{}/bar/baz'), ('/moo/boo', 'arg1=val1', 'https://{}:{}/moo/boo?arg1=val1')])"
      ],
      "arguments": [
        "app",
        "path",
        "query",
        "expected_url"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.url == expected_url.format(HOST, request.server_port)",
        "assert parsed.scheme == request.scheme",
        "assert parsed.path == request.path",
        "assert parsed.query == request.query_string",
        "assert parsed.netloc == request.host"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_url_attributes_with_ssl_context` test is to verify that the Sanic application correctly constructs URLs with SSL context, ensuring that the URL attributes (such as scheme, path, query, and host) are accurately represented in the request object when accessed over HTTPS.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a request is made to a specific path with SSL enabled, the resulting URL matches the expected format. It also verifies that the individual components of the URL (scheme, path, query, and netloc) are correctly parsed and correspond to the request's attributes.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `app.test_client.get` method, which simulates an HTTP GET request to the Sanic application. The test sets up an SSL context with a certificate and key, adds a route handler, and then makes a request to the specified path. The assertions confirm that the constructed URL and its components match the expected values, ensuring that the application handles SSL requests properly.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs parameterization via `pytest.mark.parametrize`, allowing it to run multiple scenarios with different paths, queries, and expected URLs. This approach enhances test coverage and reduces redundancy. Additionally, the use of assertions to validate both the complete URL and its individual components demonstrates a thorough verification of the request's properties, ensuring that the application behaves as expected under SSL conditions."
    },
    {
      "name": "test_url_attributes_with_ssl_dict",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 171,
      "end_line_number": 190,
      "source_code": "def test_url_attributes_with_ssl_dict(app, path, query, expected_url):\n    ssl_dict = {\"cert\": localhost_cert, \"key\": localhost_key}\n\n    async def handler(request):\n        return text(\"OK\")\n\n    app.add_route(handler, path)\n\n    request, _ = app.test_client.get(\n        f\"https://{HOST}:{PORT}\" + path + f\"?{query}\",\n        server_kwargs={\"ssl\": ssl_dict},\n    )\n    assert request.url == expected_url.format(HOST, request.server_port)\n\n    parsed = urlparse(request.url)\n\n    assert parsed.scheme == request.scheme\n    assert parsed.path == request.path\n    assert parsed.query == request.query_string\n    assert parsed.netloc == request.host",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('path,query,expected_url', [('/foo', '', 'https://{}:{}/foo'), ('/bar/baz', '', 'https://{}:{}/bar/baz'), ('/moo/boo', 'arg1=val1', 'https://{}:{}/moo/boo?arg1=val1')])"
      ],
      "arguments": [
        "app",
        "path",
        "query",
        "expected_url"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.url == expected_url.format(HOST, request.server_port)",
        "assert parsed.scheme == request.scheme",
        "assert parsed.path == request.path",
        "assert parsed.query == request.query_string",
        "assert parsed.netloc == request.host"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_url_attributes_with_ssl_dict` function is designed to verify that the Sanic application correctly constructs URLs with SSL attributes when accessed via HTTPS. It ensures that the URL generated by the application matches the expected format, taking into account the provided SSL certificate and key.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the URL returned by the request matches the expected URL format, including the correct scheme (HTTPS), path, and query parameters. It also verifies that the parsed components of the URL (scheme, path, query, and netloc) align with the request's attributes, ensuring that the application handles SSL configurations properly.\n\n**Code Being Tested and How It Works**:  \nThe test sets up an asynchronous route handler that returns a simple text response. It then makes a GET request to the application using the test client, specifying the SSL dictionary containing the certificate and key. The request is constructed with the specified path and query parameters. The assertions confirm that the constructed URL and its components are as expected, validating the behavior of the `app.test_client.get` method and the routing mechanism of the Sanic application.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses `pytest.mark.parametrize` to run multiple scenarios with different paths, queries, and expected URLs, promoting code reuse and coverage of various cases.\n- **Asynchronous Testing**: The test leverages asynchronous handlers and requests, which is essential for testing web applications that operate in an asynchronous environment.\n- **Assertions on URL Components**: The test includes multiple assertions to validate not just the full URL but also its individual components, ensuring comprehensive verification of the URL construction logic."
    },
    {
      "name": "test_cert_sni_single",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 193,
      "end_line_number": 215,
      "source_code": "def test_cert_sni_single(app):\n    @app.get(\"/sni\")\n    async def handler1(request):\n        return text(request.conn_info.server_name)\n\n    @app.get(\"/commonname\")\n    async def handler2(request):\n        return text(request.conn_info.cert.get(\"commonName\"))\n\n    port = app.test_client.port\n    _, response = app.test_client.get(\n        f\"https://localhost:{port}/sni\",\n        server_kwargs={\"ssl\": localhost_dir},\n    )\n    assert response.status == 200\n    assert response.text == \"localhost\"\n\n    _, response = app.test_client.get(\n        f\"https://localhost:{port}/commonname\",\n        server_kwargs={\"ssl\": localhost_dir},\n    )\n    assert response.status == 200\n    assert response.text == \"localhost\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'localhost'",
        "assert response.status == 200",
        "assert response.text == 'localhost'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "request.conn_info.cert.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_cert_sni_single` test is designed to verify the correct handling of Server Name Indication (SNI) in a Sanic web application. It checks that the application correctly returns the server name and the common name from the SSL certificate when accessed via HTTPS.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically verifies that:\n1. The endpoint `/sni` returns the expected server name (`localhost`).\n2. The endpoint `/commonname` returns the common name from the SSL certificate, which is also expected to be `localhost`.\n\n**Code Being Tested and How It Works**:  \nThe test defines two asynchronous route handlers:\n- `handler1` for the `/sni` endpoint, which returns the server name from the request's connection information.\n- `handler2` for the `/commonname` endpoint, which retrieves the common name from the SSL certificate associated with the request.\n\nThe test then simulates HTTP GET requests to both endpoints using the Sanic test client, specifying SSL parameters to ensure the requests are treated as secure. The responses are checked for a status code of 200 and the expected text content.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test uses asynchronous route handlers and requests, which is essential for testing web applications that handle I/O-bound operations.\n- **Direct Assertion**: The test employs direct assertions to validate the response status and content, ensuring that the application behaves as expected under specific conditions.\n- **Mocking SSL Context**: The test uses `server_kwargs` to provide a mock SSL context, allowing the test to simulate secure connections without needing a real SSL setup. This is crucial for testing SNI behavior in a controlled environment."
    },
    {
      "name": "test_cert_sni_list",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 218,
      "end_line_number": 275,
      "source_code": "def test_cert_sni_list(app):\n    ssl_list = [sanic_dir, localhost_dir]\n\n    @app.get(\"/sni\")\n    async def handler1(request):\n        return text(request.conn_info.server_name)\n\n    @app.get(\"/commonname\")\n    async def handler2(request):\n        return text(request.conn_info.cert.get(\"commonName\"))\n\n    # This test should match the localhost cert\n    port = app.test_client.port\n    _, response = app.test_client.get(\n        f\"https://localhost:{port}/sni\",\n        server_kwargs={\"ssl\": ssl_list},\n    )\n    assert response.status == 200\n    assert response.text == \"localhost\"\n\n    request, response = app.test_client.get(\n        f\"https://localhost:{port}/commonname\",\n        server_kwargs={\"ssl\": ssl_list},\n    )\n    assert response.status == 200\n    assert response.text == \"localhost\"\n\n    # This part should use the sanic.example cert because it matches\n    with replace_server_name(\"www.sanic.example\"):\n        _, response = app.test_client.get(\n            f\"https://127.0.0.1:{port}/sni\",\n            server_kwargs={\"ssl\": ssl_list},\n        )\n        assert response.status == 200\n        assert response.text == \"www.sanic.example\"\n\n        _, response = app.test_client.get(\n            f\"https://127.0.0.1:{port}/commonname\",\n            server_kwargs={\"ssl\": ssl_list},\n        )\n        assert response.status == 200\n        assert response.text == \"sanic.example\"\n\n    # This part should use the sanic.example cert, that being the first listed\n    with replace_server_name(\"invalid.test\"):\n        _, response = app.test_client.get(\n            f\"https://127.0.0.1:{port}/sni\",\n            server_kwargs={\"ssl\": ssl_list},\n        )\n        assert response.status == 200\n        assert response.text == \"invalid.test\"\n\n        _, response = app.test_client.get(\n            f\"https://127.0.0.1:{port}/commonname\",\n            server_kwargs={\"ssl\": ssl_list},\n        )\n        assert response.status == 200\n        assert response.text == \"sanic.example\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'localhost'",
        "assert response.status == 200",
        "assert response.text == 'localhost'",
        "assert response.status == 200",
        "assert response.text == 'www.sanic.example'",
        "assert response.status == 200",
        "assert response.text == 'sanic.example'",
        "assert response.status == 200",
        "assert response.text == 'invalid.test'",
        "assert response.status == 200",
        "assert response.text == 'sanic.example'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "replace_server_name",
          "body": "@contextmanager\ndef replace_server_name(hostname):\n    \"\"\"Temporarily replace the server name sent with all TLS requests with\n    a fake hostname.\"\"\"\n\n    def hack_wrap_bio(self, incoming, outgoing, server_side=False, server_hostname=None, session=None):\n        return orig_wrap_bio(self, incoming, outgoing, server_side, hostname, session)\n    (orig_wrap_bio, ssl.SSLContext.wrap_bio) = (ssl.SSLContext.wrap_bio, hack_wrap_bio)\n    try:\n        yield\n    finally:\n        ssl.SSLContext.wrap_bio = orig_wrap_bio"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "replace_server_name",
          "body": "@contextmanager\ndef replace_server_name(hostname):\n    \"\"\"Temporarily replace the server name sent with all TLS requests with\n    a fake hostname.\"\"\"\n\n    def hack_wrap_bio(self, incoming, outgoing, server_side=False, server_hostname=None, session=None):\n        return orig_wrap_bio(self, incoming, outgoing, server_side, hostname, session)\n    (orig_wrap_bio, ssl.SSLContext.wrap_bio) = (ssl.SSLContext.wrap_bio, hack_wrap_bio)\n    try:\n        yield\n    finally:\n        ssl.SSLContext.wrap_bio = orig_wrap_bio"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "request.conn_info.cert.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_cert_sni_list` function is designed to verify the correct behavior of the Sanic application when handling Server Name Indication (SNI) in SSL/TLS connections. It ensures that the application responds with the appropriate server name and common name based on the SSL certificates provided.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the application correctly identifies and returns the server name and common name from the SSL certificate based on the requested hostname. It verifies that the correct certificate is used for different hostnames, including localhost and other specified names, and that the application responds with the expected HTTP status and text.\n\n**Code Being Tested and How It Works**:  \nThe test sets up two routes (`/sni` and `/commonname`) that return the server name and the common name from the SSL certificate, respectively. It uses the `app.test_client.get` method to simulate HTTPS requests to these endpoints, passing a list of SSL certificates. The `replace_server_name` context manager temporarily alters the server name used in the SSL handshake, allowing the test to simulate requests for different hostnames. The assertions confirm that the responses match the expected values based on the certificates used.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Managers**: The use of `replace_server_name` as a context manager allows for temporary changes to the server name during the test, ensuring that the original state is restored afterward.\n- **Asynchronous Testing**: The test leverages asynchronous route handlers and requests, which is a common pattern in modern web frameworks like Sanic.\n- **Assertions**: Multiple assertions are employed to validate both the HTTP response status and the content returned by the application, ensuring comprehensive verification of the expected behavior.\n- **Parameterized Testing**: Although not directly in this test, the surrounding context shows the use of parameterized tests, which can help in testing various scenarios with different inputs efficiently."
    },
    {
      "name": "test_missing_sni",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 279,
      "end_line_number": 294,
      "source_code": "def test_missing_sni(app):\n    \"\"\"The sanic cert does not list 127.0.0.1 and httpx does not send\n    IP as SNI anyway.\"\"\"\n    ssl_list = [None, sanic_dir]\n\n    @app.get(\"/sni\")\n    async def handler(request):\n        return text(request.conn_info.server_name)\n\n    port = app.test_client.port\n    with pytest.raises(Exception) as exc:\n        app.test_client.get(\n            f\"https://127.0.0.1:{port}/sni\",\n            server_kwargs={\"ssl\": ssl_list},\n        )\n    assert \"Request and response object expected\" in str(exc.value)",
      "docstring": "The sanic cert does not list 127.0.0.1 and httpx does not send\nIP as SNI anyway.",
      "decorators": [
        "pytest.mark.xfail"
      ],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'Request and response object expected' in str(exc.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_missing_sni` unit test is designed to verify the behavior of the Sanic application when an SSL connection is attempted without a valid Server Name Indication (SNI). Specifically, it checks that the application raises an appropriate exception when the server certificate does not include the IP address `127.0.0.1`, which is a common scenario in local development environments.\n\n**Specific Functionality or Behavior Verified**:  \nThe test ensures that when a request is made to the `/sni` endpoint over HTTPS with an SSL configuration that does not include the necessary SNI information, the application raises an exception. The test specifically asserts that the exception message contains the phrase \"Request and response object expected,\" indicating that the request handling failed due to the missing SNI.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `app.get` method, which defines an asynchronous route handler for the `/sni` endpoint. This handler returns the server name from the connection information. The test then attempts to make a GET request to this endpoint using the `app.test_client.get` method, passing an SSL configuration that includes `None` and a directory for the Sanic certificate. The test expects an exception to be raised due to the invalid SSL configuration.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that an exception is raised during the execution of the request. This is a common pattern in unit testing to verify that specific error conditions are handled correctly. Additionally, the use of an asynchronous route handler and the Sanic test client demonstrates the test's focus on asynchronous behavior and HTTP request handling in a web application context. The test also includes a docstring that provides context about the expected behavior, enhancing the readability and maintainability of the test."
    },
    {
      "name": "test_no_matching_cert",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 298,
      "end_line_number": 314,
      "source_code": "def test_no_matching_cert(app):\n    \"\"\"The sanic cert does not list 127.0.0.1 and httpx does not send\n    IP as SNI anyway.\"\"\"\n    ssl_list = [None, sanic_dir]\n\n    @app.get(\"/sni\")\n    async def handler(request):\n        return text(request.conn_info.server_name)\n\n    port = app.test_client.port\n    with replace_server_name(\"invalid.test\"):\n        with pytest.raises(Exception) as exc:\n            app.test_client.get(\n                f\"https://127.0.0.1:{port}/sni\",\n                server_kwargs={\"ssl\": ssl_list},\n            )\n    assert \"Request and response object expected\" in str(exc.value)",
      "docstring": "The sanic cert does not list 127.0.0.1 and httpx does not send\nIP as SNI anyway.",
      "decorators": [
        "pytest.mark.xfail"
      ],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'Request and response object expected' in str(exc.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "replace_server_name",
          "body": "@contextmanager\ndef replace_server_name(hostname):\n    \"\"\"Temporarily replace the server name sent with all TLS requests with\n    a fake hostname.\"\"\"\n\n    def hack_wrap_bio(self, incoming, outgoing, server_side=False, server_hostname=None, session=None):\n        return orig_wrap_bio(self, incoming, outgoing, server_side, hostname, session)\n    (orig_wrap_bio, ssl.SSLContext.wrap_bio) = (ssl.SSLContext.wrap_bio, hack_wrap_bio)\n    try:\n        yield\n    finally:\n        ssl.SSLContext.wrap_bio = orig_wrap_bio"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_no_matching_cert` unit test is designed to verify that when a request is made to a Sanic application with an SSL certificate that does not match the server name (in this case, `127.0.0.1`), an appropriate exception is raised. This is particularly relevant for scenarios where the server name indication (SNI) is not correctly handled, ensuring that the application behaves as expected under these conditions.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that an exception is raised when attempting to access the `/sni` endpoint using an invalid server name (`invalid.test`) while the SSL certificate does not include `127.0.0.1`. The expected behavior is that the application should not be able to process the request correctly, leading to an exception that contains the message \"Request and response object expected\".\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the Sanic application's `get` method, which handles incoming GET requests. The test sets up a route (`/sni`) that returns the server name from the connection information. The `replace_server_name` context manager temporarily alters the server name used in TLS requests. The test then attempts to make a GET request to the `/sni` endpoint with SSL parameters that do not match the expected server name, expecting an exception to be raised.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Manager**: The `replace_server_name` context manager is used to temporarily modify the server name for the duration of the test, allowing for controlled testing of SSL behavior.\n- **Exception Assertion**: The test uses `pytest.raises` to assert that an exception is raised during the request, which is a common pattern in unit testing to verify error handling.\n- **Parameterized Testing**: The test is marked with `@pytest.mark.xfail`, indicating that it is expected to fail under certain conditions, which is useful for documenting known issues or for tests that are in development."
    },
    {
      "name": "test_wildcards",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 318,
      "end_line_number": 348,
      "source_code": "def test_wildcards(app):\n    ssl_list = [None, localhost_dir, sanic_dir]\n\n    @app.get(\"/sni\")\n    async def handler(request):\n        return text(request.conn_info.server_name)\n\n    port = app.test_client.port\n\n    with replace_server_name(\"foo.sanic.test\"):\n        _, response = app.test_client.get(\n            f\"https://127.0.0.1:{port}/sni\",\n            server_kwargs={\"ssl\": ssl_list},\n        )\n        assert response.status == 200\n        assert response.text == \"foo.sanic.test\"\n\n    with replace_server_name(\"sanic.test\"):\n        with pytest.raises(Exception) as exc:\n            _, response = app.test_client.get(\n                f\"https://127.0.0.1:{port}/sni\",\n                server_kwargs={\"ssl\": ssl_list},\n            )\n        assert \"Request and response object expected\" in str(exc.value)\n    with replace_server_name(\"sub.foo.sanic.test\"):\n        with pytest.raises(Exception) as exc:\n            _, response = app.test_client.get(\n                f\"https://127.0.0.1:{port}/sni\",\n                server_kwargs={\"ssl\": ssl_list},\n            )\n        assert \"Request and response object expected\" in str(exc.value)",
      "docstring": null,
      "decorators": [
        "pytest.mark.xfail"
      ],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'foo.sanic.test'",
        "assert 'Request and response object expected' in str(exc.value)",
        "assert 'Request and response object expected' in str(exc.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "replace_server_name",
          "body": "@contextmanager\ndef replace_server_name(hostname):\n    \"\"\"Temporarily replace the server name sent with all TLS requests with\n    a fake hostname.\"\"\"\n\n    def hack_wrap_bio(self, incoming, outgoing, server_side=False, server_hostname=None, session=None):\n        return orig_wrap_bio(self, incoming, outgoing, server_side, hostname, session)\n    (orig_wrap_bio, ssl.SSLContext.wrap_bio) = (ssl.SSLContext.wrap_bio, hack_wrap_bio)\n    try:\n        yield\n    finally:\n        ssl.SSLContext.wrap_bio = orig_wrap_bio"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "replace_server_name",
          "body": "@contextmanager\ndef replace_server_name(hostname):\n    \"\"\"Temporarily replace the server name sent with all TLS requests with\n    a fake hostname.\"\"\"\n\n    def hack_wrap_bio(self, incoming, outgoing, server_side=False, server_hostname=None, session=None):\n        return orig_wrap_bio(self, incoming, outgoing, server_side, hostname, session)\n    (orig_wrap_bio, ssl.SSLContext.wrap_bio) = (ssl.SSLContext.wrap_bio, hack_wrap_bio)\n    try:\n        yield\n    finally:\n        ssl.SSLContext.wrap_bio = orig_wrap_bio"
        },
        {
          "name": "replace_server_name",
          "body": "@contextmanager\ndef replace_server_name(hostname):\n    \"\"\"Temporarily replace the server name sent with all TLS requests with\n    a fake hostname.\"\"\"\n\n    def hack_wrap_bio(self, incoming, outgoing, server_side=False, server_hostname=None, session=None):\n        return orig_wrap_bio(self, incoming, outgoing, server_side, hostname, session)\n    (orig_wrap_bio, ssl.SSLContext.wrap_bio) = (ssl.SSLContext.wrap_bio, hack_wrap_bio)\n    try:\n        yield\n    finally:\n        ssl.SSLContext.wrap_bio = orig_wrap_bio"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_wildcards` function is designed to verify the behavior of the Sanic application when handling Server Name Indication (SNI) with different hostnames. It checks that the application correctly identifies and responds with the expected server name when a valid hostname is provided, and raises appropriate exceptions for invalid hostnames.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically verifies two main behaviors:\n1. When a valid hostname (`foo.sanic.test`) is used, the application should return a successful response (HTTP status 200) with the correct server name in the response body.\n2. When invalid hostnames (`sanic.test` and `sub.foo.sanic.test`) are used, the application should raise an exception indicating that a request and response object are expected, thus ensuring that the application correctly handles SNI validation.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes:\n- The `handler` function defined within the test, which responds with the server name from the request's connection information.\n- The `replace_server_name` context manager, which temporarily alters the server name used in TLS requests.\n- The `app.test_client.get` method, which simulates HTTP GET requests to the application.\n\nThe test first sets up a valid server name and checks the response. It then tests two invalid server names, expecting exceptions to be raised, thus validating the application's error handling.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Manager**: The use of `replace_server_name` as a context manager allows for temporary modification of the server name during the test, ensuring that changes are reverted after the test completes.\n- **Exception Testing**: The test employs `pytest.raises` to assert that specific exceptions are raised under certain conditions, which is a common pattern for testing error handling in unit tests.\n- **Assertions**: The test uses assertions to verify both the response status and content, as well as the presence of specific error messages, ensuring comprehensive validation of the application's behavior."
    },
    {
      "name": "test_invalid_ssl_dict",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 351,
      "end_line_number": 361,
      "source_code": "def test_invalid_ssl_dict(app):\n    @app.get(\"/test\")\n    async def handler(request):\n        return text(\"ssl test\")\n\n    ssl_dict = {\"cert\": None, \"key\": None}\n\n    with pytest.raises(ValueError) as excinfo:\n        app.test_client.get(\"/test\", server_kwargs={\"ssl\": ssl_dict})\n\n    assert str(excinfo.value) == \"SSL dict needs filenames for cert and key.\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(excinfo.value) == 'SSL dict needs filenames for cert and key.'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_invalid_ssl_dict` unit test is designed to verify that the Sanic application correctly raises a `ValueError` when an invalid SSL dictionary is provided to the test client. Specifically, it checks that both the certificate and key fields in the SSL dictionary are `None`, which is not acceptable for establishing a secure connection.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the application enforces the requirement for valid SSL certificate and key file paths. It verifies that when the SSL dictionary contains `None` values for both the `cert` and `key`, the application raises a `ValueError` with a specific error message: \"SSL dict needs filenames for cert and key.\"\n\n**Code Being Tested and How It Works**:  \nThe test defines a simple route (`/test`) that returns a text response. It then creates an SSL dictionary with both `cert` and `key` set to `None`. The test client attempts to make a GET request to the `/test` endpoint while passing the invalid SSL dictionary in the `server_kwargs`. The expected behavior is that the application raises a `ValueError`, which is captured in the `excinfo` context manager.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that a specific exception is raised during the execution of the code block. This pattern is effective for testing error handling in code. Additionally, the test includes an assertion to check the exact error message, ensuring that the application not only raises an error but also provides a meaningful message that aids in debugging. This combination of exception handling and message verification is a common and useful technique in unit testing."
    },
    {
      "name": "test_invalid_ssl_type",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 364,
      "end_line_number": 372,
      "source_code": "def test_invalid_ssl_type(app):\n    @app.get(\"/test\")\n    async def handler(request):\n        return text(\"ssl test\")\n\n    with pytest.raises(ValueError) as excinfo:\n        app.test_client.get(\"/test\", server_kwargs={\"ssl\": False})\n\n    assert \"Invalid ssl argument\" in str(excinfo.value)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'Invalid ssl argument' in str(excinfo.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_invalid_ssl_type` test is designed to verify that the Sanic application correctly raises a `ValueError` when an invalid SSL argument (specifically, `False`) is provided to the `app.test_client.get` method. This ensures that the application enforces proper SSL configurations.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when the SSL argument is set to `False`, the application raises a `ValueError` with the message \"Invalid ssl argument\". This behavior is crucial for maintaining the security and integrity of the application by ensuring that only valid SSL configurations are accepted.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `app.get` method, which defines a simple route that returns a text response, and the `app.test_client.get` method, which simulates a GET request to that route. The test client is invoked with `server_kwargs` containing an invalid SSL configuration. The expected behavior is that the application raises a `ValueError` when it encounters the invalid SSL argument.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that a specific exception is raised during the execution of the code block. This pattern is effective for testing error handling in code. Additionally, the use of assertions to check the exception message ensures that not only is the correct type of exception raised, but also that it conveys the appropriate error message, providing clarity on the nature of the failure."
    },
    {
      "name": "test_cert_file_on_pathlist",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 375,
      "end_line_number": 386,
      "source_code": "def test_cert_file_on_pathlist(app):\n    @app.get(\"/test\")\n    async def handler(request):\n        return text(\"ssl test\")\n\n    ssl_list = [sanic_cert]\n\n    with pytest.raises(ValueError) as excinfo:\n        app.test_client.get(\"/test\", server_kwargs={\"ssl\": ssl_list})\n\n    assert \"folder expected\" in str(excinfo.value)\n    assert sanic_cert in str(excinfo.value)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'folder expected' in str(excinfo.value)",
        "assert sanic_cert in str(excinfo.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_cert_file_on_pathlist` test is designed to verify that the Sanic application correctly raises a `ValueError` when an invalid SSL certificate path is provided. Specifically, it checks that the application expects a folder for the SSL certificate rather than a file.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when the application is configured to use SSL with a list of certificates, it raises an appropriate error message if the provided certificate is not in the expected format (i.e., a directory instead of a file). The test asserts that the error message contains specific phrases indicating the nature of the problem.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `app.get` method to define a simple route and then uses `app.test_client.get` to simulate a GET request to that route while passing SSL configuration through `server_kwargs`. The `ssl_list` variable contains the `sanic_cert`, which is expected to be a file but is treated as a path. The test checks that a `ValueError` is raised, and the error message is validated to ensure it contains the expected strings.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The use of `with pytest.raises(ValueError) as excinfo:` captures the exception raised during the test, allowing for easy assertion on the exception's message.\n- **Assertions on Exception Messages**: The test checks the content of the exception message to ensure it provides meaningful feedback about the error, which is a good practice for validating error handling in code.\n- **Route Definition**: The test defines a route within the test function, demonstrating how to set up a minimal application context for testing specific behaviors without needing a full application setup."
    },
    {
      "name": "test_missing_cert_path",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 389,
      "end_line_number": 400,
      "source_code": "def test_missing_cert_path(app):\n    @app.get(\"/test\")\n    async def handler(request):\n        return text(\"ssl test\")\n\n    ssl_list = [invalid_dir]\n\n    with pytest.raises(ValueError) as excinfo:\n        app.test_client.get(\"/test\", server_kwargs={\"ssl\": ssl_list})\n\n    assert \"not found\" in str(excinfo.value)\n    assert invalid_dir + \"/privkey.pem\" in str(excinfo.value)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'not found' in str(excinfo.value)",
        "assert invalid_dir + '/privkey.pem' in str(excinfo.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_missing_cert_path` unit test is designed to verify that the application correctly raises a `ValueError` when an invalid SSL certificate directory is provided to the server. This ensures that the application handles SSL configuration errors gracefully and provides informative error messages.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that when an invalid directory (represented by `invalid_dir`) is passed as part of the SSL configuration, the application raises a `ValueError`. It also verifies that the error message contains specific phrases indicating the nature of the error, such as \"not found\" and the expected path to the private key file.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `app.test_client.get` method, which simulates an HTTP GET request to the `/test` endpoint. The `server_kwargs` parameter is used to pass the SSL configuration. The test sets up a route handler that simply returns a text response. When the invalid SSL path is provided, the test expects a `ValueError` to be raised, which is captured in the `excinfo` context manager. The assertions then check the content of the exception message.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that a specific exception is raised during the execution of the code block. This is a common pattern in unit testing to ensure that error conditions are handled as expected. Additionally, the use of assertions to check the content of the exception message demonstrates a focus on validating not just the occurrence of an error, but also the correctness and clarity of the error reporting."
    },
    {
      "name": "test_missing_cert_file",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 403,
      "end_line_number": 415,
      "source_code": "def test_missing_cert_file(app):\n    @app.get(\"/test\")\n    async def handler(request):\n        return text(\"ssl test\")\n\n    invalid2 = invalid_dir.replace(\"nonexist\", \"certmissing\")\n    ssl_list = [invalid2]\n\n    with pytest.raises(ValueError) as excinfo:\n        app.test_client.get(\"/test\", server_kwargs={\"ssl\": ssl_list})\n\n    assert \"not found\" in str(excinfo.value)\n    assert invalid2 + \"/fullchain.pem\" in str(excinfo.value)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'not found' in str(excinfo.value)",
        "assert invalid2 + '/fullchain.pem' in str(excinfo.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_missing_cert_file` unit test is designed to verify that the Sanic application correctly raises a `ValueError` when an SSL certificate file is missing from the specified path. This ensures that the application handles SSL configuration errors gracefully and provides informative error messages.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that when an invalid SSL certificate path is provided (where the expected certificate file does not exist), the application raises a `ValueError`. It also verifies that the error message contains specific phrases indicating the nature of the problem, such as \"not found\" and the expected path of the missing certificate file.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `app.get` method, which registers a route handler, and the `app.test_client.get` method, which simulates a GET request to that route with SSL parameters. The test sets up an invalid SSL path (`invalid2`) and attempts to access the `/test` endpoint with this path. The application is expected to check for the existence of the SSL certificate files and raise an error if they are not found.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that a specific exception (`ValueError`) is raised during the execution of the code block. This is a common pattern in unit testing to verify that error handling works as intended. Additionally, the test uses assertions to check the content of the exception message, ensuring that it provides meaningful feedback about the error encountered. This approach enhances the robustness of the test by not only checking for the occurrence of an error but also validating the accuracy of the error message."
    },
    {
      "name": "test_no_certs_on_list",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 418,
      "end_line_number": 428,
      "source_code": "def test_no_certs_on_list(app):\n    @app.get(\"/test\")\n    async def handler(request):\n        return text(\"ssl test\")\n\n    ssl_list = [None]\n\n    with pytest.raises(ValueError) as excinfo:\n        app.test_client.get(\"/test\", server_kwargs={\"ssl\": ssl_list})\n\n    assert \"No certificates\" in str(excinfo.value)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'No certificates' in str(excinfo.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_no_certs_on_list` unit test is designed to verify that the application correctly raises a `ValueError` when an invalid SSL configuration is provided, specifically when the SSL certificate list contains `None`. This ensures that the application enforces the requirement for valid SSL certificates.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when the SSL list is set to `[None]`, the application raises a `ValueError` with a message indicating that no certificates are provided. This behavior is crucial for maintaining secure connections and preventing misconfigurations that could lead to insecure server operations.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `app.test_client.get` method, which simulates an HTTP GET request to the `/test` endpoint. The `server_kwargs` parameter is used to pass the SSL configuration. The test expects that the application will raise a `ValueError` when it detects that the SSL list does not contain valid certificate paths.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The test uses a context manager (`with pytest.raises(ValueError) as excinfo`) to assert that a specific exception is raised during the execution of the code block. This pattern is effective for testing error handling.\n- **Assertion on Exception Message**: The test checks the content of the exception message to ensure it provides the correct feedback about the error, which is a good practice for validating that the application communicates issues clearly to the user.\n- **Asynchronous Testing**: Although this specific test is synchronous, it is part of a suite that includes asynchronous tests, indicating a broader testing strategy that accommodates both synchronous and asynchronous request handling in the application."
    },
    {
      "name": "test_custom_cert_loader",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 431,
      "end_line_number": 451,
      "source_code": "def test_custom_cert_loader():\n    class MyCertLoader(CertLoader):\n        def load(self, app: Sanic):\n            self._ssl_data = {\n                \"key\": localhost_key,\n                \"cert\": localhost_cert,\n            }\n            return super().load(app)\n\n    app = Sanic(\"custom\", certloader_class=MyCertLoader)\n\n    @app.get(\"/test\")\n    async def handler(request):\n        return text(\"ssl test\")\n\n    client = SanicTestClient(app, port=44556)\n\n    request, response = client.get(\"https://localhost:44556/test\")\n    assert request.scheme == \"https\"\n    assert response.status_code == 200\n    assert response.text == \"ssl test\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.scheme == 'https'",
        "assert response.status_code == 200",
        "assert response.text == 'ssl test'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_custom_cert_loader` unit test is designed to verify that a custom SSL certificate loader can be successfully integrated into a Sanic application and that the application can handle HTTPS requests correctly.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when a request is made to the `/test` endpoint over HTTPS, the request scheme is `https`, the response status code is `200`, and the response body contains the expected text \"ssl test\". This ensures that the custom certificate loader is functioning as intended and that the application is correctly serving HTTPS traffic.\n\n**Code Being Tested and How It Works**:  \nThe test defines a subclass `MyCertLoader` of `CertLoader`, which overrides the `load` method to provide custom SSL key and certificate data. An instance of `Sanic` is created with this custom loader. The test then sets up a route that returns a simple text response. A `SanicTestClient` is used to simulate an HTTPS request to the application, and the assertions validate the response and request properties.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of a custom class to extend functionality (`MyCertLoader`), which is a common pattern in unit testing to isolate and test specific behaviors. It also utilizes assertions to verify multiple aspects of the response, ensuring comprehensive coverage of the expected behavior. The use of `SanicTestClient` allows for easy simulation of requests in a controlled environment, which is a standard practice in testing web applications."
    },
    {
      "name": "test_logger_vhosts",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 454,
      "end_line_number": 479,
      "source_code": "def test_logger_vhosts(caplog):\n    app = Sanic(name=\"test_logger_vhosts\")\n\n    @app.after_server_start\n    def stop(*args):\n        app.stop()\n\n    with caplog.at_level(logging.INFO):\n        app.run(\n            host=\"127.0.0.1\",\n            port=42102,\n            ssl=[localhost_dir, sanic_dir],\n            single_process=True,\n        )\n\n    logmsg = [\n        msg\n        for name, levelno, msg in caplog.record_tuples\n        if (msg.startswith(\"Certificate\"))\n    ][0]\n\n    assert logmsg == (\n        \"Certificate vhosts: localhost, 127.0.0.1, 0:0:0:0:0:0:0:1, \"\n        \"sanic.example, www.sanic.example, *.sanic.test, \"\n        \"2001:DB8:0:0:0:0:0:541C\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "caplog"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert logmsg == 'Certificate vhosts: localhost, 127.0.0.1, 0:0:0:0:0:0:0:1, sanic.example, www.sanic.example, *.sanic.test, 2001:DB8:0:0:0:0:0:541C'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        },
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_logger_vhosts` unit test is designed to verify that the Sanic application correctly logs the expected virtual host certificate information when it starts up with SSL enabled. This ensures that the application is configured to handle multiple hostnames securely.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the log message generated during the server startup contains the correct string indicating the virtual hosts associated with the SSL certificate. It specifically looks for a log message that starts with \"Certificate\" and asserts that it matches a predefined expected string.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `app.run()` method of the Sanic application, which starts the server and initializes SSL with the provided certificate directories. The `@app.after_server_start` decorator is used to define a callback that stops the application after it has started, ensuring that the test does not hang indefinitely. The `caplog` fixture captures log messages emitted during the execution of the test, allowing for verification of the log output.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The test utilizes the `caplog` fixture from pytest to capture log messages at a specified logging level (INFO in this case).\n- **Log Message Filtering**: It filters the captured log messages to find the specific message that starts with \"Certificate\", demonstrating a targeted approach to verifying log output.\n- **Assertion**: The test employs a straightforward assertion to compare the actual log message against the expected string, ensuring that the logging behavior is correct and consistent with the application's configuration."
    },
    {
      "name": "test_mk_cert_creator_default",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 482,
      "end_line_number": 485,
      "source_code": "def test_mk_cert_creator_default(app: Sanic):\n    cert_creator = MkcertCreator(app, _default, _default)\n    assert isinstance(cert_creator.tmpdir, Path)\n    assert cert_creator.tmpdir.exists()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(cert_creator.tmpdir, Path)",
        "assert cert_creator.tmpdir.exists()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_mk_cert_creator_default` test is designed to verify the initialization of the `MkcertCreator` class, specifically checking that the temporary directory (`tmpdir`) is correctly set up as a `Path` object and that it exists in the filesystem.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when an instance of `MkcertCreator` is created with default parameters, the `tmpdir` attribute is not only of the correct type (`Path`) but also that it points to a valid directory that exists. This is crucial for the functionality of the `MkcertCreator`, as it relies on this directory for storing temporary files related to certificate generation.\n\n**Code Being Tested and How It Works**:  \nThe test instantiates the `MkcertCreator` class with the `app` and two `_default` parameters. The `MkcertCreator` constructor is expected to initialize the `tmpdir` attribute, which is presumably set to a temporary directory path. The assertions check that `tmpdir` is an instance of `Path` (from the `pathlib` module) and that it exists on the filesystem, indicating that the directory was created successfully during initialization.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs straightforward assertions to validate the state of the `cert_creator` object after its creation. It uses the `isinstance` function to check the type of `tmpdir`, which is a common practice in unit tests to ensure that objects are of expected types. The use of `assert` statements is a fundamental pattern in unit testing, providing a clear and direct way to verify conditions that must hold true for the test to pass. Additionally, the test is structured to be simple and focused, which is a hallmark of effective unit tests."
    },
    {
      "name": "test_mk_cert_creator_is_supported",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 488,
      "end_line_number": 497,
      "source_code": "def test_mk_cert_creator_is_supported(app):\n    cert_creator = MkcertCreator(app, _default, _default)\n    with patch(\"subprocess.run\") as run:\n        cert_creator.check_supported()\n        run.assert_called_once_with(\n            [\"mkcert\", \"-help\"],\n            check=True,\n            stderr=subprocess.DEVNULL,\n            stdout=subprocess.DEVNULL,\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "cert_creator.check_supported",
          "body": "def check_supported(self):\n    if not self.SUPPORTED:\n        raise SanicException('Nope')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_mk_cert_creator_is_supported` verifies that the `MkcertCreator` class correctly checks for the support of the `mkcert` tool by attempting to run a command that checks its availability. This ensures that the application can gracefully handle the absence of the required tool.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that when the `check_supported` method is called, it invokes the `subprocess.run` function with the expected arguments to check if `mkcert` is installed. It asserts that this command is called exactly once, confirming that the method behaves as intended when the tool is supported.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `check_supported` method of the `MkcertCreator` class. This method attempts to execute the command `[\"mkcert\", \"-help\"]` using `subprocess.run`. If `mkcert` is not installed, an exception is raised, which is caught and transformed into a `SanicException` with a descriptive error message. The test ensures that this command is executed correctly and that the method does not raise an exception when `mkcert` is available.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `patch` decorator from the `unittest.mock` module to replace the `subprocess.run` function with a mock during the test execution. This allows the test to verify that the method under test calls `subprocess.run` with the correct parameters without actually executing any external commands. This technique isolates the test from external dependencies, making it faster and more reliable. Additionally, the use of assertions to check the call count and parameters of the mock is a common pattern in unit testing to validate interactions with dependencies."
    },
    {
      "name": "test_mk_cert_creator_is_not_supported",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 500,
      "end_line_number": 507,
      "source_code": "def test_mk_cert_creator_is_not_supported(app):\n    cert_creator = MkcertCreator(app, _default, _default)\n    with patch(\"subprocess.run\") as run:\n        run.side_effect = Exception(\"\")\n        with pytest.raises(\n            SanicException, match=\"Sanic is attempting to use mkcert\"\n        ):\n            cert_creator.check_supported()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "cert_creator.check_supported",
          "body": "def check_supported(self):\n    if not self.SUPPORTED:\n        raise SanicException('Nope')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_mk_cert_creator_is_not_supported` aims to verify that the `MkcertCreator` class correctly raises a `SanicException` when the underlying `mkcert` command is not supported or fails to execute. This is crucial for ensuring that the application handles the absence of the `mkcert` tool gracefully.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that when the `check_supported` method of `MkcertCreator` is called, it raises a `SanicException` with a specific error message if the `subprocess.run` call fails (simulated by raising an `Exception`). This behavior ensures that the application can inform the user about the missing dependency.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `check_supported` method of the `MkcertCreator` class. This method attempts to run the `mkcert -help` command using `subprocess.run`. If this command fails (e.g., if `mkcert` is not installed), it raises a `SanicException` with a detailed message explaining the issue and suggesting alternatives. The test simulates this failure by patching `subprocess.run` to raise an `Exception`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `unittest.mock.patch` technique to replace the `subprocess.run` function with a mock that raises an exception. This allows the test to simulate the failure scenario without actually invoking the command. Additionally, it uses `pytest.raises` to assert that the expected exception is raised, along with a specific message, which is a common pattern for testing error handling in Python."
    },
    {
      "name": "test_mk_cert_creator_generate_cert_default",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 510,
      "end_line_number": 518,
      "source_code": "def test_mk_cert_creator_generate_cert_default(app):\n    cert_creator = MkcertCreator(app, _default, _default)\n    with patch(\"subprocess.run\") as run:\n        with patch(\"sanic.http.tls.creators.CertSimple\"):\n            retval = Mock()\n            retval.stdout = \"foo\"\n            run.return_value = retval\n            cert_creator.generate_cert(\"localhost\")\n            run.assert_called_once()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_mk_cert_creator_generate_cert_default` test is to verify that the `generate_cert` method of the `MkcertCreator` class correctly invokes the `subprocess.run` function to generate a certificate for a specified hostname, in this case, \"localhost\".\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `subprocess.run` function is called exactly once when the `generate_cert` method is executed. It ensures that the method behaves as expected when generating a certificate, confirming that the subprocess call is made without any errors.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `generate_cert` method of the `MkcertCreator` class. The test creates an instance of `MkcertCreator` with default parameters and then mocks the `subprocess.run` function to prevent actual execution of subprocesses. The mock is set up to return a predefined output (`retval.stdout = \"foo\"`), simulating a successful certificate generation. After calling `generate_cert(\"localhost\")`, the test asserts that `subprocess.run` was called exactly once, indicating that the method attempted to generate a certificate.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `unittest.mock.patch` technique to replace the `subprocess.run` function with a mock object, allowing for controlled testing without side effects. Additionally, it uses the `Mock` class to create a mock return value for the subprocess call, which helps in verifying the interaction with the mocked function. This approach isolates the test from external dependencies and focuses on the behavior of the `generate_cert` method."
    },
    {
      "name": "test_mk_cert_creator_generate_cert_localhost",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 521,
      "end_line_number": 526,
      "source_code": "def test_mk_cert_creator_generate_cert_localhost(app):\n    cert_creator = MkcertCreator(app, localhost_key, localhost_cert)\n    with patch(\"subprocess.run\") as run:\n        with patch(\"sanic.http.tls.creators.CertSimple\"):\n            cert_creator.generate_cert(\"localhost\")\n            run.assert_not_called()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_mk_cert_creator_generate_cert_localhost` aims to verify that the `generate_cert` method of the `MkcertCreator` class does not invoke the `subprocess.run` command when generating a certificate for \"localhost\" under certain conditions, specifically when the certificate already exists.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the `generate_cert` method behaves correctly by ensuring that it does not attempt to run an external command (in this case, `mkcert`) if the certificate file already exists. This is important for preventing unnecessary operations and ensuring that the application behaves as expected when the required certificate is already available.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `generate_cert` method of the `MkcertCreator` class. This method is responsible for generating a TLS certificate using the `mkcert` tool. It first checks if the certificate file exists; if it does not, it constructs a command to run `mkcert` with the appropriate arguments. The test specifically checks the scenario where the certificate already exists, thus the `subprocess.run` command should not be called.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `unittest.mock.patch` technique to replace the `subprocess.run` function with a mock object. This allows the test to assert that `subprocess.run` is not called without actually executing any external commands. Additionally, the test uses a context manager to patch `sanic.http.tls.creators.CertSimple`, which is likely involved in the certificate creation process, ensuring that the test environment is isolated and does not affect other tests or the system state. The use of assertions (`run.assert_not_called()`) is a key pattern in unit testing to verify that specific interactions with mocked objects occur as expected."
    },
    {
      "name": "test_trustme_creator_default",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 529,
      "end_line_number": 532,
      "source_code": "def test_trustme_creator_default(app: Sanic):\n    cert_creator = TrustmeCreator(app, _default, _default)\n    assert isinstance(cert_creator.tmpdir, Path)\n    assert cert_creator.tmpdir.exists()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(cert_creator.tmpdir, Path)",
        "assert cert_creator.tmpdir.exists()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_trustme_creator_default` test is designed to verify the initialization of the `TrustmeCreator` class, specifically checking that the temporary directory (`tmpdir`) is correctly set up as a `Path` object and that it exists in the filesystem.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when an instance of `TrustmeCreator` is created with default parameters, the `tmpdir` attribute is not only of the correct type (`Path`) but also that it points to a valid directory that exists. This is crucial for the functionality of the `TrustmeCreator`, as it likely relies on this temporary directory for storing certificates or related files.\n\n**Code Being Tested and How It Works**:  \nThe test instantiates the `TrustmeCreator` class with the `app` object and two default parameters (`_default`). It then checks two assertions: \n1. `isinstance(cert_creator.tmpdir, Path)` confirms that `tmpdir` is a `Path` object.\n2. `cert_creator.tmpdir.exists()` checks that the directory represented by `tmpdir` actually exists on the filesystem. The `TrustmeCreator` class is expected to handle the creation and management of this directory internally.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs straightforward assertions to validate the state of the `TrustmeCreator` instance. It uses the `assert` statement, which is a common pattern in unit testing for verifying conditions. The test does not mock any dependencies or external interactions, focusing solely on the internal state of the `TrustmeCreator` instance, which is a good practice for unit tests as it isolates the functionality being tested."
    },
    {
      "name": "test_trustme_creator_is_supported",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 535,
      "end_line_number": 538,
      "source_code": "def test_trustme_creator_is_supported(app, monkeypatch):\n    monkeypatch.setattr(sanic.http.tls.creators, \"TRUSTME_INSTALLED\", True)\n    cert_creator = TrustmeCreator(app, _default, _default)\n    cert_creator.check_supported()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "monkeypatch"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "cert_creator.check_supported",
          "body": "def check_supported(self):\n    if not self.SUPPORTED:\n        raise SanicException('Nope')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_trustme_creator_is_supported` aims to verify that the `TrustmeCreator` class correctly identifies when it is supported for use in the Sanic application. Specifically, it checks that the `check_supported` method does not raise an exception when the `TRUSTME_INSTALLED` attribute is set to `True`.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the `check_supported` method of the `TrustmeCreator` class behaves as expected when the necessary conditions for support are met. If `TRUSTME_INSTALLED` is `True`, the method should complete without raising a `SanicException`, indicating that the Trustme certificate creator is available for use.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `check_supported` method within the `TrustmeCreator` class. This method checks the `SUPPORTED` attribute (which is presumably set based on the `TRUSTME_INSTALLED` status). If `SUPPORTED` is `False`, it raises a `SanicException` with the message 'Nope'. The test uses the `monkeypatch` fixture to modify the `TRUSTME_INSTALLED` attribute to `True`, simulating an environment where Trustme is available.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `monkeypatch` technique from the pytest framework, which allows for dynamic modification of attributes during the test execution. This is a common pattern in unit testing to isolate the code under test from its dependencies and control the environment in which it runs. Additionally, the test does not include explicit assertions, relying on the absence of exceptions to indicate success, which is a valid approach in testing methods that are expected to complete without errors."
    },
    {
      "name": "test_trustme_creator_is_not_supported",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 541,
      "end_line_number": 547,
      "source_code": "def test_trustme_creator_is_not_supported(app, monkeypatch):\n    monkeypatch.setattr(sanic.http.tls.creators, \"TRUSTME_INSTALLED\", False)\n    cert_creator = TrustmeCreator(app, _default, _default)\n    with pytest.raises(\n        SanicException, match=\"Sanic is attempting to use trustme\"\n    ):\n        cert_creator.check_supported()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "monkeypatch"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "cert_creator.check_supported",
          "body": "def check_supported(self):\n    if not self.SUPPORTED:\n        raise SanicException('Nope')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_trustme_creator_is_not_supported` test is to verify that the `TrustmeCreator` class correctly raises a `SanicException` when the `TRUSTME_INSTALLED` flag is set to `False`. This simulates a scenario where the required `trustme` library is not available, ensuring that the application handles this situation gracefully by preventing further execution.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks the behavior of the `check_supported` method within the `TrustmeCreator` class. It ensures that when `TRUSTME_INSTALLED` is `False`, the method raises a `SanicException` with a specific error message indicating that `trustme` is not installed and that the application cannot proceed without it.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `check_supported` method of the `TrustmeCreator` class. This method checks the value of the `TRUSTME_INSTALLED` variable. If it is `False`, the method raises a `SanicException` with a detailed message explaining the implications of not having `trustme` installed. The test uses the `monkeypatch` fixture to temporarily set `TRUSTME_INSTALLED` to `False`, simulating the absence of the `trustme` library.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `monkeypatch` technique from the `pytest` framework to modify the behavior of the `TRUSTME_INSTALLED` variable at runtime. This allows for isolated testing of the `check_supported` method without requiring changes to the actual codebase. Additionally, the use of `pytest.raises` is a common pattern in unit testing to assert that specific exceptions are raised under certain conditions, ensuring that error handling is functioning as expected."
    },
    {
      "name": "test_trustme_creator_generate_cert_default",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 550,
      "end_line_number": 564,
      "source_code": "def test_trustme_creator_generate_cert_default(\n    app, monkeypatch, trustme, issue_cert, server_cert, ca\n):\n    monkeypatch.setattr(sanic.http.tls.creators, \"trustme\", trustme)\n    cert_creator = TrustmeCreator(app, _default, _default)\n    cert = cert_creator.generate_cert(\"localhost\")\n\n    assert isinstance(cert, SanicSSLContext)\n    trustme.CA.assert_called_once_with()\n    issue_cert.assert_called_once_with(\"localhost\")\n    server_cert.configure_cert.assert_called_once()\n    ca.configure_trust.assert_called_once()\n    ca.cert_pem.write_to_path.assert_called_once_with(str(cert.sanic[\"cert\"]))\n    write_to_path = server_cert.private_key_and_cert_chain_pem.write_to_path\n    write_to_path.assert_called_once_with(str(cert.sanic[\"key\"]))",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "monkeypatch",
        "trustme",
        "issue_cert",
        "server_cert",
        "ca"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(cert, SanicSSLContext)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_trustme_creator_generate_cert_default` is designed to verify the functionality of the `TrustmeCreator` class's `generate_cert` method when generating a certificate for the hostname \"localhost\". It ensures that the certificate generation process interacts correctly with various components and that the expected calls are made.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the generated certificate is an instance of `SanicSSLContext`, and it verifies that several methods are called exactly once during the certificate generation process. This includes calls to create a Certificate Authority (CA), issue the certificate, configure the server certificate, and write the certificate and key to the specified paths.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `TrustmeCreator` class, which is responsible for generating SSL certificates using the `trustme` library. The `generate_cert` method is invoked with \"localhost\" as an argument, which triggers a series of operations to create and configure the SSL context. The test uses `monkeypatch` to replace the `trustme` module with a mock, allowing for controlled testing without relying on the actual implementation.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test employs mocking to replace dependencies (like `trustme` and its methods) with mock objects, allowing the test to focus on the behavior of the `TrustmeCreator` without external side effects.\n- **Assertions**: It uses assertions to verify that the expected interactions with the mocked objects occur, ensuring that the correct methods are called with the expected arguments.\n- **Dependency Injection**: The test leverages dependency injection through the use of fixtures (`app`, `monkeypatch`, `trustme`, etc.), which provides the necessary context and dependencies for the test to run effectively."
    },
    {
      "name": "test_trustme_creator_generate_cert_localhost",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 567,
      "end_line_number": 576,
      "source_code": "def test_trustme_creator_generate_cert_localhost(\n    app, monkeypatch, trustme, server_cert, ca\n):\n    monkeypatch.setattr(sanic.http.tls.creators, \"trustme\", trustme)\n    cert_creator = TrustmeCreator(app, localhost_key, localhost_cert)\n    cert_creator.generate_cert(\"localhost\")\n\n    ca.cert_pem.write_to_path.assert_called_once_with(localhost_cert)\n    write_to_path = server_cert.private_key_and_cert_chain_pem.write_to_path\n    write_to_path.assert_called_once_with(localhost_key)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "monkeypatch",
        "trustme",
        "server_cert",
        "ca"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_trustme_creator_generate_cert_localhost` test is to verify that the `TrustmeCreator` class correctly generates and saves a TLS certificate for the \"localhost\" domain using the `trustme` library. It ensures that the expected methods are called with the correct arguments during the certificate generation process.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `generate_cert` method of the `TrustmeCreator` class invokes the appropriate methods to write the generated certificate and private key to the specified paths. It asserts that the `write_to_path` methods of the certificate authority (CA) and server certificate are called exactly once with the expected file paths.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `generate_cert` method of the `TrustmeCreator` class, which is responsible for creating a new SSL certificate for a given hostname (in this case, \"localhost\"). The method uses the `trustme` library to create a CA, issue a certificate, configure it, and write the certificate and private key to specified file paths. The test sets up the necessary environment by using `monkeypatch` to replace the `trustme` reference in the `sanic.http.tls.creators` module with a mock object.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `monkeypatch` fixture from pytest to modify the behavior of the `trustme` library during the test, allowing for isolation and control over the dependencies. It also uses assertions to verify that specific methods are called with the expected arguments, which is a common practice in unit testing to ensure that the code behaves as intended. The use of mocks allows the test to focus on the interactions and outcomes without relying on the actual implementation of the `trustme` library."
    },
    {
      "name": "test_get_ssl_context_with_ssl_context",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 579,
      "end_line_number": 582,
      "source_code": "def test_get_ssl_context_with_ssl_context(app):\n    mock_context = Mock()\n    context = get_ssl_context(app, mock_context)\n    assert context is mock_context",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert context is mock_context"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_get_ssl_context_with_ssl_context` is designed to verify that the `get_ssl_context` function correctly returns a provided SSL context when one is explicitly passed to it. This ensures that the function behaves as expected when a user wants to use a custom SSL context.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the context returned by `get_ssl_context` is the same as the `mock_context` that was passed in. This confirms that the function does not alter or create a new context when an existing one is provided, thereby maintaining the integrity of the input.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `get_ssl_context` function, which is expected to accept an application instance (`app`) and an optional SSL context. In this test, `mock_context` is created as a mock object, and the function is called with this mock context. The assertion `assert context is mock_context` checks that the returned context is indeed the same object as `mock_context`, indicating that the function is functioning correctly in this scenario.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of mocking through the `Mock` class from the `unittest.mock` module, which allows for the creation of a mock object that simulates the behavior of a real SSL context without needing to create an actual SSL context. This is a common pattern in unit testing to isolate the functionality being tested and avoid dependencies on external systems or complex objects. The test also uses a straightforward assertion to validate the expected outcome, which is a clear and effective way to verify functionality in unit tests."
    },
    {
      "name": "test_get_ssl_context_in_production",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 585,
      "end_line_number": 591,
      "source_code": "def test_get_ssl_context_in_production(app):\n    app.state.mode = Mode.PRODUCTION\n    with pytest.raises(\n        SanicException,\n        match=\"Cannot run Sanic as an HTTPS server in PRODUCTION mode\",\n    ):\n        get_ssl_context(app, None)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_get_ssl_context_in_production` is designed to verify that the `get_ssl_context` function correctly raises a `SanicException` when the Sanic application is set to `PRODUCTION` mode and no SSL context is provided. This ensures that the application does not run as an HTTPS server in a production environment without a valid TLS certificate.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks for the enforcement of security measures in production mode by confirming that an exception is raised with the appropriate error message when attempting to obtain an SSL context without providing a certificate. This behavior is crucial for preventing misconfigurations that could lead to security vulnerabilities.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `get_ssl_context` function, which takes a `Sanic` application instance and an optional SSL context. If the SSL context is not provided and the application is in `PRODUCTION` mode, the function raises a `SanicException` with a specific error message. The test sets the application mode to `PRODUCTION` and then calls `get_ssl_context` with `None` as the SSL context, expecting the exception to be raised.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that an exception is raised during the execution of the code block. It also uses the `match` parameter to verify that the exception message matches the expected string, ensuring that not only is an exception raised, but it is the correct one with the appropriate message. This pattern is effective for testing error handling and validating that the application behaves as expected under erroneous conditions."
    },
    {
      "name": "test_get_ssl_context_only_mkcert",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 618,
      "end_line_number": 654,
      "source_code": "def test_get_ssl_context_only_mkcert(\n    app,\n    monkeypatch,\n    MockMkcertCreator,\n    MockTrustmeCreator,\n    requirement,\n    mk_supported,\n    trustme_supported,\n    mk_called,\n    trustme_called,\n    err,\n):\n    app.state.mode = Mode.DEBUG\n    app.config.LOCAL_CERT_CREATOR = requirement\n    monkeypatch.setattr(\n        sanic.http.tls.creators, \"MkcertCreator\", MockMkcertCreator\n    )\n    monkeypatch.setattr(\n        sanic.http.tls.creators, \"TrustmeCreator\", MockTrustmeCreator\n    )\n    MockMkcertCreator.SUPPORTED = mk_supported\n    MockTrustmeCreator.SUPPORTED = trustme_supported\n\n    if err:\n        with pytest.raises(SanicException, match=err):\n            get_ssl_context(app, None)\n    else:\n        get_ssl_context(app, None)\n\n    if mk_called:\n        MockMkcertCreator.generate_cert.assert_called_once_with(\"localhost\")\n    else:\n        MockMkcertCreator.generate_cert.assert_not_called()\n    if trustme_called:\n        MockTrustmeCreator.generate_cert.assert_called_once_with(\"localhost\")\n    else:\n        MockTrustmeCreator.generate_cert.assert_not_called()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('requirement,mk_supported,trustme_supported,mk_called,trustme_called,err', ((LocalCertCreator.AUTO, True, False, True, False, None), (LocalCertCreator.AUTO, True, True, True, False, None), (LocalCertCreator.AUTO, False, True, False, True, None), (LocalCertCreator.AUTO, False, False, False, False, 'Sanic could not find package to create a TLS certificate'), (LocalCertCreator.MKCERT, True, False, True, False, None), (LocalCertCreator.MKCERT, True, True, True, False, None), (LocalCertCreator.MKCERT, False, True, False, False, 'Nope'), (LocalCertCreator.MKCERT, False, False, False, False, 'Nope'), (LocalCertCreator.TRUSTME, True, False, False, False, 'Nope'), (LocalCertCreator.TRUSTME, True, True, False, True, None), (LocalCertCreator.TRUSTME, False, True, False, True, None), (LocalCertCreator.TRUSTME, False, False, False, False, 'Nope')))"
      ],
      "arguments": [
        "app",
        "monkeypatch",
        "MockMkcertCreator",
        "MockTrustmeCreator",
        "requirement",
        "mk_supported",
        "trustme_supported",
        "mk_called",
        "trustme_called",
        "err"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_get_ssl_context_only_mkcert` function is designed to verify the behavior of the `get_ssl_context` function in the Sanic framework when the local certificate creator is set to use `mkcert`. It checks how the application handles different configurations of certificate creators and whether it raises appropriate exceptions when required.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically verifies that:\n1. The correct certificate creator is used based on the configuration.\n2. The `generate_cert` method of the `MkcertCreator` or `TrustmeCreator` is called or not called as expected, depending on the support status of each creator.\n3. The test also checks that the appropriate exceptions are raised when there are issues with the certificate creation process.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `get_ssl_context` function, which is responsible for creating an SSL context based on the specified local certificate creator. The test sets up the application state and configuration, mocks the behavior of the `MkcertCreator` and `TrustmeCreator`, and then calls `get_ssl_context`. It checks if the correct methods are invoked based on the support status of the creators and whether the expected exceptions are raised when errors are indicated.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses pytest's parameterization feature to run multiple scenarios with different configurations of the local certificate creator, allowing for comprehensive coverage of various cases.\n- **Monkeypatching**: The `monkeypatch` fixture is used to replace the actual `MkcertCreator` and `TrustmeCreator` classes with mock versions, enabling controlled testing without side effects.\n- **Assertions on Mock Objects**: The test asserts that the `generate_cert` method is called or not called using mock assertions, which helps verify that the code interacts with the mocked classes as expected."
    },
    {
      "name": "test_sanic_ssl_context_create",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 677,
      "end_line_number": 682,
      "source_code": "def test_sanic_ssl_context_create():\n    context = ssl.SSLContext()\n    sanic_context = SanicSSLContext.create_from_ssl_context(context)\n\n    assert sanic_context is context\n    assert isinstance(sanic_context, SanicSSLContext)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert sanic_context is context",
        "assert isinstance(sanic_context, SanicSSLContext)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_sanic_ssl_context_create` test is to verify the functionality of the `create_from_ssl_context` class method in the `SanicSSLContext` class. It ensures that this method correctly creates an instance of `SanicSSLContext` from an existing `ssl.SSLContext` object.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two key behaviors: \n1. It confirms that the `sanic_context` returned by `create_from_ssl_context` is the same object as the original `context` passed to it, ensuring that the method does not create a new instance but rather modifies the existing one.\n2. It verifies that the `sanic_context` is indeed an instance of `SanicSSLContext`, ensuring that the type of the object is correct after the transformation.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `create_from_ssl_context` method within the `SanicSSLContext` class. This method takes an `ssl.SSLContext` object as an argument, changes its class to `SanicSSLContext`, and returns it. The method works by directly modifying the `__class__` attribute of the passed context, which is a somewhat unconventional approach but allows for the reuse of the existing SSL context object.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs direct assertions to validate the outcomes, which is a straightforward and effective testing pattern. It uses `assert` statements to check both the identity of the objects (`is`) and the type of the object (`isinstance`). This approach is simple yet powerful, as it provides clear and immediate feedback on the correctness of the method being tested. Additionally, the test is self-contained and does not rely on external dependencies, making it easy to run in isolation."
    },
    {
      "name": "test_ssl_in_multiprocess_mode",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 689,
      "end_line_number": 712,
      "source_code": "def test_ssl_in_multiprocess_mode(app: Sanic, caplog):\n    ssl_dict = {\"cert\": localhost_cert, \"key\": localhost_key}\n    event = Event()\n\n    @app.main_process_start\n    async def main_start(app: Sanic):\n        app.shared_ctx.event = event\n\n    @app.after_server_start\n    async def shutdown(app):\n        app.shared_ctx.event.set()\n        app.stop()\n\n    assert not event.is_set()\n    with use_context(\"fork\"):\n        with caplog.at_level(logging.INFO):\n            app.run(ssl=ssl_dict)\n    assert event.is_set()\n\n    assert (\n        \"sanic.root\",\n        logging.INFO,\n        \"Goin' Fast @ https://127.0.0.1:8000\",\n    ) in caplog.record_tuples",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(sys.platform not in ('linux', 'darwin'), reason='This test requires fork context')"
      ],
      "arguments": [
        "app",
        "caplog"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert not event.is_set()",
        "assert event.is_set()",
        "assert ('sanic.root', logging.INFO, \"Goin' Fast @ https://127.0.0.1:8000\") in caplog.record_tuples"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        },
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_ssl_in_multiprocess_mode` test is designed to verify that a Sanic application can successfully start in SSL mode while operating in a multiprocess context. It ensures that the application correctly handles SSL certificates and keys, and that the server starts and stops as expected.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the event signaling the server's readiness is set after the server starts, indicating that the application has transitioned to a running state. It also verifies that the appropriate log message is generated, confirming that the server is running with SSL enabled.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `app.run` method, which starts the Sanic server with the provided SSL configuration (`ssl_dict`). The `main_process_start` and `after_server_start` hooks are used to manage the event signaling. The `main_start` function sets the event in the shared context when the main process starts, while the `shutdown` function sets the event and stops the application after the server has started.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Event Handling**: The use of an `Event` object to signal the server's state is a common pattern in asynchronous programming, allowing the test to wait for specific conditions.\n- **Context Management**: The `use_context(\"fork\")` context manager is employed to ensure that the test runs in a forked process, which is necessary for testing multiprocess behavior.\n- **Logging Capture**: The `caplog` fixture is utilized to capture log messages generated during the test, allowing for assertions on the log output to confirm that the server started correctly with SSL.\n- **Assertions**: The test includes assertions to validate the state of the event and the presence of specific log messages, ensuring that the expected behavior occurs during the test execution."
    },
    {
      "name": "test_ssl_in_multiprocess_mode_password",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 719,
      "end_line_number": 743,
      "source_code": "def test_ssl_in_multiprocess_mode_password(\n    app: Sanic, caplog: pytest.LogCaptureFixture\n):\n    event = Event()\n\n    @app.main_process_start\n    async def main_start(app: Sanic):\n        app.shared_ctx.event = event\n\n    @app.after_server_start\n    async def shutdown(app):\n        app.shared_ctx.event.set()\n        app.stop()\n\n    assert not event.is_set()\n    with use_context(\"fork\"):\n        with caplog.at_level(logging.INFO):\n            app.run(ssl=password_dict)\n    assert event.is_set()\n\n    assert (\n        \"sanic.root\",\n        logging.INFO,\n        \"Goin' Fast @ https://127.0.0.1:8000\",\n    ) in caplog.record_tuples",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(sys.platform not in ('linux', 'darwin'), reason='This test requires fork context')"
      ],
      "arguments": [
        "app",
        "caplog"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert not event.is_set()",
        "assert event.is_set()",
        "assert ('sanic.root', logging.INFO, \"Goin' Fast @ https://127.0.0.1:8000\") in caplog.record_tuples"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        },
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_ssl_in_multiprocess_mode_password` is designed to verify that a Sanic application can successfully start in SSL mode with a password-protected certificate while operating in a multiprocess environment. It ensures that the application correctly handles the SSL configuration and logs the expected output.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main behaviors: \n1. It verifies that the event signaling the server's readiness is not set before the server starts, indicating that the server is not yet running.\n2. It confirms that the event is set after the server starts, indicating that the server has successfully initialized and is ready to accept connections. Additionally, it checks that the appropriate log message indicating the server is running with SSL is present in the captured logs.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `app.run()` method, which starts the Sanic application with SSL enabled using the provided `password_dict`. The test sets up event listeners for the application lifecycle:\n- `main_process_start`: This listener sets the shared context's event to signal when the main process starts.\n- `after_server_start`: This listener sets the event when the server has started and then stops the application.\n\nThe assertions check the state of the event before and after the server starts, as well as the presence of a specific log message in the captured logs.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Event Handling**: The test uses an `Event` object to manage the state of the server's readiness, which is a common pattern in asynchronous programming to signal state changes.\n- **Context Management**: The `use_context(\"fork\")` context manager is employed to ensure that the test runs in a forked process, which is necessary for testing multiprocess behavior.\n- **Log Capture**: The `caplog` fixture from pytest is utilized to capture log messages generated during the test, allowing for verification of logging behavior.\n- **Assertions**: The test employs assertions to validate the expected state of the event and the presence of specific log messages, which is a standard practice in unit testing to ensure correctness."
    },
    {
      "name": "test_should_return_html_valid_setting",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 85,
      "end_line_number": 108,
      "source_code": "def test_should_return_html_valid_setting(\n    fake_request, fallback, content_type, exception, status\n):\n    # Note: if fallback is None or \"auto\", prior to PR #2668 base was returned\n    # and after that a text response is given because it matches */*. Changed\n    # base to TextRenderer in this test, like it is in Sanic itself, so the\n    # test passes with either version but still covers everything that it did.\n    if fallback:\n        fake_request.app.config.FALLBACK_ERROR_FORMAT = fallback\n\n    try:\n        raise exception(\"bad stuff\")\n    except Exception as e:\n        response = exception_response(\n            fake_request,\n            e,\n            True,\n            base=TextRenderer,\n            fallback=fake_request.app.config.FALLBACK_ERROR_FORMAT,\n        )\n\n    assert isinstance(response, HTTPResponse)\n    assert response.status == status\n    assert response.content_type == content_type",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('fallback,content_type, exception, status', ((None, 'text/plain; charset=utf-8', Exception, 500), ('html', 'text/html; charset=utf-8', Exception, 500), ('auto', 'text/plain; charset=utf-8', Exception, 500), ('text', 'text/plain; charset=utf-8', Exception, 500), ('json', 'application/json', Exception, 500), (None, 'text/plain; charset=utf-8', NotFound, 404), ('html', 'text/html; charset=utf-8', NotFound, 404), ('auto', 'text/plain; charset=utf-8', NotFound, 404), ('text', 'text/plain; charset=utf-8', NotFound, 404), ('json', 'application/json', NotFound, 404)))"
      ],
      "arguments": [
        "fake_request",
        "fallback",
        "content_type",
        "exception",
        "status"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(response, HTTPResponse)",
        "assert response.status == status",
        "assert response.content_type == content_type"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception",
          "body": "@app.route('/')\ndef exception(request):\n    raise SanicExceptionTestException(\"You won't see me\")"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_should_return_html_valid_setting` is designed to verify that the Sanic application correctly handles exceptions and returns the appropriate HTTP response based on the configured fallback error format. It ensures that the response's status and content type match the expected values for various scenarios involving different types of exceptions.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when an exception is raised, the application responds with an `HTTPResponse` object that has the correct status code and content type. It validates the behavior of the error handling mechanism in the Sanic framework, particularly how it formats error responses based on the `FALLBACK_ERROR_FORMAT` configuration.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `exception_response` function, which is responsible for generating the HTTP response when an exception occurs. The test simulates raising different exceptions (like `Exception` and `NotFound`) and checks the response generated by this function. The `fake_request` fixture creates a mock request object that mimics a real HTTP request, allowing the test to simulate various scenarios without needing an actual server.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses `pytest.mark.parametrize` to run multiple scenarios with different combinations of fallback settings, content types, exceptions, and expected statuses. This approach enhances test coverage and reduces code duplication.\n- **Exception Handling**: The test explicitly raises exceptions within a try-except block to simulate error conditions, allowing the verification of the error handling logic.\n- **Assertions**: The test employs assertions to validate the type and properties of the response, ensuring that the application behaves as expected under various configurations."
    },
    {
      "name": "test_auto_fallback_with_data",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 111,
      "end_line_number": 124,
      "source_code": "def test_auto_fallback_with_data(app):\n    app.config.FALLBACK_ERROR_FORMAT = \"auto\"\n\n    _, response = app.test_client.get(\"/error\")\n    assert response.status == 500\n    assert response.content_type == \"text/plain; charset=utf-8\"\n\n    _, response = app.test_client.post(\"/error\", json={\"foo\": \"bar\"})\n    assert response.status == 500\n    assert response.content_type == \"application/json\"\n\n    _, response = app.test_client.post(\"/error\", data={\"foo\": \"bar\"})\n    assert response.status == 500\n    assert response.content_type == \"text/plain; charset=utf-8\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert response.content_type == 'text/plain; charset=utf-8'",
        "assert response.status == 500",
        "assert response.content_type == 'application/json'",
        "assert response.status == 500",
        "assert response.content_type == 'text/plain; charset=utf-8'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_auto_fallback_with_data` test is designed to verify the behavior of the Sanic application when an error occurs, specifically checking how the application responds to different types of requests (GET and POST) when the `FALLBACK_ERROR_FORMAT` configuration is set to \"auto\". It ensures that the application correctly returns the expected HTTP status codes and content types for error responses.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the application returns a 500 Internal Server Error status for requests made to the `/error` endpoint, regardless of whether the request is a GET or POST, and whether the POST request includes JSON data or form data. It also verifies that the content type of the response matches the expected format based on the request type.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `app.test_client` to simulate HTTP requests to the `/error` endpoint. The first request is a GET request, which is expected to return a 500 status with a content type of \"text/plain; charset=utf-8\". The second request is a POST request with JSON data, which should return a 500 status with a content type of \"application/json\". The third request is a POST request with form data, which is expected to return a 500 status with a content type of \"text/plain; charset=utf-8\". The underlying code that handles these requests is not shown, but it is implied that the application is set up to handle errors and format responses based on the `FALLBACK_ERROR_FORMAT` configuration.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the response status and content type, which is a common pattern in unit testing to ensure that the application behaves as expected under various conditions. It also demonstrates the use of configuration settings to influence application behavior, showcasing how different request types can lead to different response formats. The test is structured to cover multiple scenarios in a single function, which is efficient for verifying related behaviors in one go."
    },
    {
      "name": "test_auto_fallback_with_content_type",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 127,
      "end_line_number": 140,
      "source_code": "def test_auto_fallback_with_content_type(app):\n    app.config.FALLBACK_ERROR_FORMAT = \"auto\"\n\n    _, response = app.test_client.get(\n        \"/error\", headers={\"content-type\": \"application/json\", \"accept\": \"*/*\"}\n    )\n    assert response.status == 500\n    assert response.content_type == \"application/json\"\n\n    _, response = app.test_client.get(\n        \"/error\", headers={\"content-type\": \"foo/bar\", \"accept\": \"*/*\"}\n    )\n    assert response.status == 500\n    assert response.content_type == \"text/plain; charset=utf-8\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert response.content_type == 'application/json'",
        "assert response.status == 500",
        "assert response.content_type == 'text/plain; charset=utf-8'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_auto_fallback_with_content_type` test is designed to verify the behavior of the Sanic application when handling error responses with different `Content-Type` headers. Specifically, it checks how the application responds to requests that trigger an error, ensuring that the correct content type is returned based on the specified headers.\n\n**Specific Functionality or Behavior Verified**:  \nThis test verifies that when the `FALLBACK_ERROR_FORMAT` is set to \"auto\", the application correctly returns a JSON response when the `Content-Type` is set to `application/json`. Conversely, it checks that a plain text response is returned when the `Content-Type` is set to an unrecognized type (in this case, `foo/bar`). Both scenarios should result in a 500 Internal Server Error status.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `app.test_client.get` method to simulate HTTP GET requests to the `/error` endpoint. The first request specifies a `Content-Type` of `application/json`, and the expected response is a 500 status with a `Content-Type` of `application/json`. The second request uses an invalid `Content-Type` (`foo/bar`), and the expected response is a 500 status with a `Content-Type` of `text/plain; charset=utf-8`. The application logic is expected to handle these requests and return the appropriate error format based on the headers provided.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the response status and content type, which is a common pattern in unit testing to ensure that the application behaves as expected. Additionally, it utilizes the Sanic testing client to simulate requests, allowing for isolated testing of the application's error handling without needing to run a full server. The test also demonstrates the use of configuration settings (`FALLBACK_ERROR_FORMAT`) to control application behavior, showcasing how different configurations can lead to different outcomes in error handling."
    },
    {
      "name": "test_route_error_format_set_on_auto",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 143,
      "end_line_number": 163,
      "source_code": "def test_route_error_format_set_on_auto(app):\n    @app.get(\"/text\")\n    def text_response(request):\n        return text(request.route.extra.error_format)\n\n    @app.get(\"/json\")\n    def json_response(request):\n        return json({\"format\": request.route.extra.error_format})\n\n    @app.get(\"/html\")\n    def html_response(request):\n        return html(request.route.extra.error_format)\n\n    _, response = app.test_client.get(\"/text\")\n    assert response.text == \"text\"\n\n    _, response = app.test_client.get(\"/json\")\n    assert response.json[\"format\"] == \"json\"\n\n    _, response = app.test_client.get(\"/html\")\n    assert response.text == \"html\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'text'",
        "assert response.json['format'] == 'json'",
        "assert response.text == 'html'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_route_error_format_set_on_auto` is designed to verify that the Sanic application correctly sets and returns the error format for different response types (text, JSON, and HTML) when an error occurs in the route handling.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the `error_format` attribute of the route is properly utilized to determine the response format when the route is accessed. It ensures that the expected formats are returned for each route when accessed via the test client.\n\n**Code Being Tested and How It Works**:  \nThe test defines three routes (`/text`, `/json`, and `/html`) within the Sanic application. Each route is expected to return a response that reflects the `error_format` set in the route's metadata. The test client then makes GET requests to each of these routes, and assertions are made to confirm that the responses match the expected formats:\n- For `/text`, it checks that the response text is \"text\".\n- For `/json`, it verifies that the JSON response contains the key \"format\" with the value \"json\".\n- For `/html`, it asserts that the response text is \"html\".\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the output of the application against expected values, which is a common practice in unit testing. It also utilizes the Sanic test client to simulate HTTP requests, allowing for the verification of route behavior in a controlled environment. The test is structured to be clear and straightforward, focusing on specific expected outcomes for each route, which enhances readability and maintainability."
    },
    {
      "name": "test_route_error_response_from_auto_route",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 166,
      "end_line_number": 189,
      "source_code": "def test_route_error_response_from_auto_route(app):\n    @app.get(\"/text\")\n    def text_response(request):\n        raise Exception(\"oops\")\n        return text(\"Never gonna see this\")\n\n    @app.get(\"/json\")\n    def json_response(request):\n        raise Exception(\"oops\")\n        return json({\"message\": \"Never gonna see this\"})\n\n    @app.get(\"/html\")\n    def html_response(request):\n        raise Exception(\"oops\")\n        return html(\"<h1>Never gonna see this</h1>\")\n\n    _, response = app.test_client.get(\"/text\")\n    assert response.content_type == \"text/plain; charset=utf-8\"\n\n    _, response = app.test_client.get(\"/json\")\n    assert response.content_type == \"application/json\"\n\n    _, response = app.test_client.get(\"/html\")\n    assert response.content_type == \"text/html; charset=utf-8\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.content_type == 'text/plain; charset=utf-8'",
        "assert response.content_type == 'application/json'",
        "assert response.content_type == 'text/html; charset=utf-8'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_route_error_response_from_auto_route` is designed to verify that the Sanic application correctly handles exceptions raised in route handlers and returns the appropriate error response format based on the content type expected by the client.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when an exception is raised in the route handlers for different content types (text, JSON, and HTML), the application responds with the correct content type for each route. Specifically, it ensures that the response content type matches the expected types: `text/plain`, `application/json`, and `text/html`.\n\n**Code Being Tested and How It Works**:  \nThe test defines three route handlers (`text_response`, `json_response`, and `html_response`) that all raise an exception when invoked. The test then makes GET requests to each of these routes using the `app.test_client.get()` method. After each request, it asserts that the `response.content_type` matches the expected content type for the respective route. The routes are defined with the expectation that they will return a specific content type even when an error occurs.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Exception Handling**: The test leverages exception handling to simulate error conditions in the route handlers, allowing verification of the application's error response behavior.\n- **Assertions**: It uses assertions to validate that the content type of the response matches the expected values, ensuring that the application behaves correctly under error conditions.\n- **Route Definition**: The test dynamically defines routes within the test function, showcasing the flexibility of the Sanic framework in handling routes and middleware during testing."
    },
    {
      "name": "test_route_error_response_from_explicit_format",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 192,
      "end_line_number": 207,
      "source_code": "def test_route_error_response_from_explicit_format(app):\n    @app.get(\"/text\", error_format=\"json\")\n    def text_response(request):\n        raise Exception(\"oops\")\n        return text(\"Never gonna see this\")\n\n    @app.get(\"/json\", error_format=\"text\")\n    def json_response(request):\n        raise Exception(\"oops\")\n        return json({\"message\": \"Never gonna see this\"})\n\n    _, response = app.test_client.get(\"/text\")\n    assert response.content_type == \"application/json\"\n\n    _, response = app.test_client.get(\"/json\")\n    assert response.content_type == \"text/plain; charset=utf-8\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.content_type == 'application/json'",
        "assert response.content_type == 'text/plain; charset=utf-8'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_route_error_response_from_explicit_format` is designed to verify that the Sanic application correctly handles errors by returning responses in the specified formats when exceptions are raised in route handlers. Specifically, it checks that the content type of the response matches the expected format based on the `error_format` parameter.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when an exception occurs in the `/text` route (which is set to return errors in JSON format) and the `/json` route (which is set to return errors in text format), the application responds with the correct content type. It asserts that the response for the `/text` route is `application/json` and for the `/json` route is `text/plain; charset=utf-8`.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes two route handlers defined within the Sanic application:\n1. `text_response`: This route is set to return errors in JSON format. When an exception is raised, the expected response should have a content type of `application/json`.\n2. `json_response`: This route is set to return errors in text format. When an exception is raised, the expected response should have a content type of `text/plain; charset=utf-8`.\n\nThe test uses the `app.test_client.get` method to simulate GET requests to these routes and checks the `content_type` of the responses.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The test uses a fixture (`app`) to provide a configured instance of the Sanic application, allowing for isolated testing of routes.\n- **Error Handling Verification**: The test specifically checks how the application handles exceptions and formats error responses, which is crucial for robust API design.\n- **Assertions**: The test employs assertions to validate the content type of the responses, ensuring that the application behaves as expected under error conditions. This is a common practice in unit testing to confirm that the output matches the expected results."
    },
    {
      "name": "test_blueprint_error_response_from_explicit_format",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 210,
      "end_line_number": 228,
      "source_code": "def test_blueprint_error_response_from_explicit_format(app):\n    bp = sanic.Blueprint(\"MyBlueprint\")\n\n    @bp.get(\"/text\", error_format=\"json\")\n    def text_response(request):\n        raise Exception(\"oops\")\n        return text(\"Never gonna see this\")\n\n    @bp.get(\"/json\", error_format=\"text\")\n    def json_response(request):\n        raise Exception(\"oops\")\n        return json({\"message\": \"Never gonna see this\"})\n\n    app.blueprint(bp)\n    _, response = app.test_client.get(\"/text\")\n    assert response.content_type == \"application/json\"\n\n    _, response = app.test_client.get(\"/json\")\n    assert response.content_type == \"text/plain; charset=utf-8\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.content_type == 'application/json'",
        "assert response.content_type == 'text/plain; charset=utf-8'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "bp.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the test `test_blueprint_error_response_from_explicit_format` is to verify that the Sanic application correctly handles error responses based on the specified `error_format` for different routes defined in a blueprint. It ensures that when an exception is raised in a route, the response format adheres to the explicitly set error format.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that when an exception occurs in the `/text` route, the response is returned in JSON format, and when an exception occurs in the `/json` route, the response is returned in plain text format. This behavior is validated by asserting the `content_type` of the responses.\n\n**Code Being Tested and How It Works**:  \nThe code being tested includes two route handlers within a Sanic blueprint: `text_response` and `json_response`. Both handlers raise an exception intentionally. The `error_format` parameter in the route decorators specifies the desired format for error responses. The test then makes GET requests to these routes using the `app.test_client` and checks the `content_type` of the responses to ensure they match the expected formats (`application/json` for the `/text` route and `text/plain; charset=utf-8` for the `/json` route).\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the response content type, which is a common pattern in unit testing to ensure that the application behaves as expected under error conditions. Additionally, it utilizes the Sanic testing client to simulate HTTP requests, allowing for the verification of route behavior in a controlled environment. The use of blueprints to organize routes and their error handling is also a notable design pattern in the Sanic framework, promoting modularity and reusability of code."
    },
    {
      "name": "test_unknown_fallback_format",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 231,
      "end_line_number": 233,
      "source_code": "def test_unknown_fallback_format(app):\n    with pytest.raises(SanicException, match=\"Unknown format: bad\"):\n        app.config.FALLBACK_ERROR_FORMAT = \"bad\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_unknown_fallback_format` is designed to verify that the application correctly raises a `SanicException` when an invalid format is assigned to the `FALLBACK_ERROR_FORMAT` configuration. This ensures that the application handles erroneous configurations gracefully by providing appropriate error messages.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks the behavior of the application when an unknown format string (in this case, \"bad\") is set as the fallback error format. It asserts that the application raises a `SanicException` with a message indicating the nature of the error, which is crucial for debugging and maintaining the application.\n\n**Code Being Tested and How It Works**:  \nThe relevant code being tested is the assignment of a bad value to `app.config.FALLBACK_ERROR_FORMAT`. When this assignment occurs, the application is expected to validate the format and, upon detecting that \"bad\" is not a recognized format, it raises a `SanicException`. The test uses the `pytest.raises` context manager to assert that the exception is raised and that the error message matches the expected output.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager, which is a common pattern in unit testing for asserting that specific exceptions are raised during the execution of a block of code. Additionally, the use of the `match` parameter allows for checking that the exception message contains the expected string, ensuring that not only is an exception raised, but it is also the correct one with the appropriate message. This enhances the robustness of the test by verifying both the occurrence of the error and its context."
    },
    {
      "name": "test_route_error_format_unknown",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 236,
      "end_line_number": 240,
      "source_code": "def test_route_error_format_unknown(app):\n    with pytest.raises(SanicException, match=\"Unknown format: bad\"):\n\n        @app.get(\"/text\", error_format=\"bad\")\n        def handler(request): ...",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_route_error_format_unknown` test is designed to verify that the Sanic application raises a `SanicException` when an invalid error format is specified in a route handler. Specifically, it checks that the application correctly identifies and responds to an unknown error format.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a route is defined with an invalid `error_format` (in this case, \"bad\"), the application raises a `SanicException` with a message indicating that the format is unknown. This behavior is crucial for maintaining robustness and providing clear feedback to developers when misconfigurations occur.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `app.get` method, which is used to define a route in the Sanic application. The route is set up with an invalid `error_format` parameter. When the route is accessed, the application should check the validity of the specified error format. If the format is not recognized, it raises a `SanicException`. The test uses a context manager (`with pytest.raises(...)`) to assert that the exception is raised as expected.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that an exception is raised during the execution of the code block. This is a common pattern in unit testing for verifying that specific error conditions are handled correctly. Additionally, the use of a match argument in `pytest.raises` allows for checking that the exception message contains the expected text, ensuring that not only is the exception raised, but it also conveys the correct information about the error."
    },
    {
      "name": "test_fallback_with_content_type_html",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 243,
      "end_line_number": 251,
      "source_code": "def test_fallback_with_content_type_html(app):\n    app.config.FALLBACK_ERROR_FORMAT = \"auto\"\n\n    _, response = app.test_client.get(\n        \"/error\",\n        headers={\"content-type\": \"application/json\", \"accept\": \"text/html\"},\n    )\n    assert response.status == 500\n    assert response.content_type == \"text/html; charset=utf-8\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert response.content_type == 'text/html; charset=utf-8'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_fallback_with_content_type_html` is designed to verify the behavior of the Sanic application when an error occurs, specifically checking that the response format is correctly set to HTML when the request's `Accept` header indicates a preference for HTML content.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a request is made to an endpoint that triggers an error (in this case, `/error`), the application responds with a 500 status code and a content type of `text/html; charset=utf-8`, despite the request's `Content-Type` being set to `application/json`. This ensures that the application correctly falls back to the HTML format for error responses when specified.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the Sanic application's error handling mechanism. The `app.test_client.get` method simulates a GET request to the `/error` endpoint with specific headers. The application is expected to handle the error gracefully and return an appropriate HTTP response. The `FALLBACK_ERROR_FORMAT` configuration is set to \"auto\", which influences the response format based on the `Accept` header of the request.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the response status and content type, which is a common practice in unit testing to ensure that the application behaves as expected under specific conditions. Additionally, it utilizes the Sanic testing client to simulate HTTP requests, allowing for isolated testing of the application's behavior without needing to run a full server. The test also demonstrates the use of configuration settings to control application behavior, showcasing how different error formats can be tested based on varying request headers."
    },
    {
      "name": "test_fallback_with_content_type_mismatch_accept",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 254,
      "end_line_number": 321,
      "source_code": "def test_fallback_with_content_type_mismatch_accept(app):\n    app.config.FALLBACK_ERROR_FORMAT = \"auto\"\n\n    _, response = app.test_client.get(\n        \"/error\",\n        headers={\"content-type\": \"application/json\", \"accept\": \"text/plain\"},\n    )\n    assert response.status == 500\n    assert response.content_type == \"text/plain; charset=utf-8\"\n\n    _, response = app.test_client.get(\n        \"/error\",\n        headers={\"content-type\": \"text/html\", \"accept\": \"foo/bar\"},\n    )\n    assert response.status == 500\n    assert response.content_type == \"text/plain; charset=utf-8\"\n\n    app.router.reset()\n\n    @app.route(\"/alt1\", name=\"alt1\")\n    @app.route(\"/alt2\", error_format=\"text\", name=\"alt2\")\n    @app.route(\"/alt3\", error_format=\"html\", name=\"alt3\")\n    def handler(_):\n        raise Exception(\"problem here\")\n        # Yes, we know this return value is unreachable. This is on purpose.\n        return json({})\n\n    app.router.finalize()\n\n    _, response = app.test_client.get(\n        \"/alt1\",\n        headers={\"accept\": \"foo/bar\"},\n    )\n    assert response.status == 500\n    assert response.content_type == \"text/plain; charset=utf-8\"\n    _, response = app.test_client.get(\n        \"/alt1\",\n        headers={\"accept\": \"foo/bar,*/*\"},\n    )\n    assert response.status == 500\n    assert response.content_type == \"application/json\"\n\n    _, response = app.test_client.get(\n        \"/alt2\",\n        headers={\"accept\": \"foo/bar\"},\n    )\n    assert response.status == 500\n    assert response.content_type == \"text/plain; charset=utf-8\"\n    _, response = app.test_client.get(\n        \"/alt2\",\n        headers={\"accept\": \"foo/bar,*/*\"},\n    )\n    assert response.status == 500\n    assert response.content_type == \"text/plain; charset=utf-8\"\n\n    _, response = app.test_client.get(\n        \"/alt3\",\n        headers={\"accept\": \"foo/bar\"},\n    )\n    assert response.status == 500\n    assert response.content_type == \"text/plain; charset=utf-8\"\n\n    _, response = app.test_client.get(\n        \"/alt3\",\n        headers={\"accept\": \"foo/bar,text/html\"},\n    )\n    assert response.status == 500\n    assert response.content_type == \"text/html; charset=utf-8\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert response.content_type == 'text/plain; charset=utf-8'",
        "assert response.status == 500",
        "assert response.content_type == 'text/plain; charset=utf-8'",
        "assert response.status == 500",
        "assert response.content_type == 'text/plain; charset=utf-8'",
        "assert response.status == 500",
        "assert response.content_type == 'application/json'",
        "assert response.status == 500",
        "assert response.content_type == 'text/plain; charset=utf-8'",
        "assert response.status == 500",
        "assert response.content_type == 'text/plain; charset=utf-8'",
        "assert response.status == 500",
        "assert response.content_type == 'text/plain; charset=utf-8'",
        "assert response.status == 500",
        "assert response.content_type == 'text/html; charset=utf-8'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.router.reset",
          "body": "@pytest.fixture(autouse=True)\ndef reset():\n    try:\n        del os.environ['SANIC_MOTD_OUTPUT']\n    except KeyError:\n        ..."
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_fallback_with_content_type_mismatch_accept` test is to verify that the Sanic application correctly handles requests with mismatched `Content-Type` and `Accept` headers, ensuring that it returns appropriate error responses when the requested content type cannot be fulfilled.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when an error occurs (simulated by raising an exception in the route handlers), the application responds with a 500 Internal Server Error status. It also verifies that the `Content-Type` of the response is set correctly based on the `Accept` header provided in the request. Specifically, it ensures that when the `Accept` header does not match any available formats, the response defaults to `text/plain` or `application/json` as specified by the error format configuration.\n\n**Code Being Tested and How It Works**:  \nThe code being tested includes the Sanic application's routing and error handling mechanisms. The test sets up routes (`/alt1`, `/alt2`, `/alt3`) that intentionally raise exceptions to trigger error responses. The `app.test_client.get` method simulates HTTP GET requests to these routes with various `Accept` headers. The application is expected to return a 500 status code and a `Content-Type` that reflects the fallback behavior defined in the application configuration.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Parameterized Testing**: The use of multiple assertions with different headers allows for comprehensive coverage of various scenarios without duplicating code.\n- **Setup and Teardown**: The test resets the router state before defining new routes, ensuring that each test runs in a clean environment.\n- **Assertions**: The test uses assertions to validate both the status code and the `Content-Type` of the response, ensuring that the application behaves as expected under different conditions."
    },
    {
      "name": "test_combinations_for_auto",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 340,
      "end_line_number": 360,
      "source_code": "def test_combinations_for_auto(fake_request, accept, content_type, expected):\n    if accept:\n        fake_request.headers[\"accept\"] = accept\n    else:\n        del fake_request.headers[\"accept\"]\n\n    if content_type:\n        fake_request.headers[\"content-type\"] = content_type\n\n    try:\n        raise Exception(\"bad stuff\")\n    except Exception as e:\n        response = exception_response(\n            fake_request,\n            e,\n            True,\n            base=TextRenderer,\n            fallback=\"auto\",\n        )\n\n    assert response.content_type == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('accept,content_type,expected', ((None, None, 'text/plain; charset=utf-8'), ('foo/bar', None, 'text/plain; charset=utf-8'), ('application/json', None, 'application/json'), ('application/json,text/plain', None, 'application/json'), ('text/plain,application/json', None, 'application/json'), ('text/plain,foo/bar', None, 'text/plain; charset=utf-8'), ('text/plain,text/html', None, 'text/plain; charset=utf-8'), ('*/*', 'foo/bar', 'text/plain; charset=utf-8'), ('*/*', 'application/json', 'application/json'), ('text/*,*/plain', None, 'text/plain; charset=utf-8')))"
      ],
      "arguments": [
        "fake_request",
        "accept",
        "content_type",
        "expected"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.content_type == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_combinations_for_auto` function is designed to verify the behavior of the `exception_response` function in handling different combinations of HTTP request headers, specifically the `accept` and `content-type` headers, when an exception is raised. It ensures that the response's content type matches the expected value based on the provided headers.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the content type of the response generated by `exception_response` aligns with the expected content type when an exception occurs. It validates that the system correctly interprets the `accept` and `content-type` headers to determine the appropriate response format.\n\n**Code Being Tested and How It Works**:  \nThe test simulates a request using a `fake_request` object, which is modified to include or exclude the `accept` and `content-type` headers based on the test parameters. An exception is raised intentionally, and the `exception_response` function is called to generate a response. The test then asserts that the `response.content_type` matches the `expected` value, which is passed as a parameter to the test.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test is likely part of a parameterized test suite, allowing it to run multiple scenarios with different combinations of `accept`, `content_type`, and `expected` values. This approach enhances test coverage and reduces code duplication.\n- **Exception Handling**: The test explicitly raises an exception to simulate error conditions, allowing the verification of error handling logic in the application.\n- **Assertions**: The use of assertions to validate the response's content type ensures that the test fails if the actual behavior does not match the expected outcome, providing clear feedback on the system's correctness."
    },
    {
      "name": "test_allow_fallback_error_format_set_main_process_start",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 363,
      "end_line_number": 370,
      "source_code": "def test_allow_fallback_error_format_set_main_process_start(app):\n    @app.main_process_start\n    async def start(app, _):\n        app.config.FALLBACK_ERROR_FORMAT = \"text\"\n\n    _, response = app.test_client.get(\"/error\")\n    assert response.status == 500\n    assert response.content_type == \"text/plain; charset=utf-8\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert response.content_type == 'text/plain; charset=utf-8'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_allow_fallback_error_format_set_main_process_start` is designed to verify that the Sanic application correctly applies a fallback error format when an error occurs during the handling of a request. Specifically, it checks that the application returns a 500 Internal Server Error with the appropriate content type when the fallback error format is set to \"text\".\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when the application encounters an error (in this case, when accessing the `/error` endpoint), it responds with a status code of 500 and a content type of \"text/plain; charset=utf-8\". This behavior is expected when the `FALLBACK_ERROR_FORMAT` configuration is set to \"text\".\n\n**Code Being Tested and How It Works**:  \nThe test sets up an asynchronous function `start` that is registered to run when the main process of the app starts. This function modifies the app's configuration to set `FALLBACK_ERROR_FORMAT` to \"text\". After this setup, the test simulates a GET request to the `/error` endpoint using `app.test_client.get(\"/error\")`. The response is then checked to ensure it has the correct status and content type.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test utilizes asynchronous functions to handle the app's startup process and request handling, which is common in frameworks like Sanic that support async operations.\n- **Configuration Testing**: It verifies that changes to the application configuration are correctly applied and affect the behavior of the application as expected.\n- **Response Assertions**: The test includes assertions to validate the response status and content type, ensuring that the application behaves correctly under the specified conditions."
    },
    {
      "name": "test_setting_fallback_on_config_changes_as_expected",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 373,
      "end_line_number": 385,
      "source_code": "def test_setting_fallback_on_config_changes_as_expected(app):\n    app.error_handler = ErrorHandler()\n\n    _, response = app.test_client.get(\"/error\")\n    assert response.content_type == \"text/plain; charset=utf-8\"\n\n    app.config.FALLBACK_ERROR_FORMAT = \"html\"\n    _, response = app.test_client.get(\"/error\")\n    assert response.content_type == \"text/html; charset=utf-8\"\n\n    app.config.FALLBACK_ERROR_FORMAT = \"text\"\n    _, response = app.test_client.get(\"/error\")\n    assert response.content_type == \"text/plain; charset=utf-8\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.content_type == 'text/plain; charset=utf-8'",
        "assert response.content_type == 'text/html; charset=utf-8'",
        "assert response.content_type == 'text/plain; charset=utf-8'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_setting_fallback_on_config_changes_as_expected` is designed to verify that the Sanic application correctly adjusts its error response format based on changes to the `FALLBACK_ERROR_FORMAT` configuration. It ensures that the application responds with the expected content type when an error occurs, reflecting the current configuration.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks the behavior of the application when the `FALLBACK_ERROR_FORMAT` is modified. It verifies that:\n1. The default error response format is \"text/plain\".\n2. Changing the format to \"html\" results in an HTML response.\n3. Reverting back to \"text\" returns to the original text response format.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the Sanic application's error handling mechanism. The `app.test_client.get(\"/error\")` simulates a request to an endpoint that triggers an error. The response's content type is asserted against expected values based on the current configuration of `FALLBACK_ERROR_FORMAT`. The `ErrorHandler` is set up to manage error responses, and the test checks if it respects the configuration changes made during the test.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **State Verification**: The test modifies the application state (the configuration) and verifies the output based on that state, which is a common pattern in unit testing.\n- **Sequential Testing**: The test performs a series of assertions in a sequence that reflects the changes made to the configuration, ensuring that each change produces the expected outcome.\n- **Use of Assertions**: The test employs assertions to validate the content type of the response, which is crucial for confirming that the application behaves as intended under different configurations."
    },
    {
      "name": "test_allow_fallback_error_format_in_config_injection",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 388,
      "end_line_number": 400,
      "source_code": "def test_allow_fallback_error_format_in_config_injection():\n    class MyConfig(Config):\n        FALLBACK_ERROR_FORMAT = \"text\"\n\n    app = Sanic(\"test\", config=MyConfig())\n\n    @app.route(\"/error\", methods=[\"GET\", \"POST\"])\n    def err(request):\n        raise Exception(\"something went wrong\")\n\n    request, response = app.test_client.get(\"/error\")\n    assert response.status == 500\n    assert response.content_type == \"text/plain; charset=utf-8\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert response.content_type == 'text/plain; charset=utf-8'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_allow_fallback_error_format_in_config_injection` is designed to verify that the Sanic application correctly uses a specified fallback error format when an error occurs during request handling. Specifically, it checks that the application returns a 500 status code and the appropriate content type when an exception is raised.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when an exception is raised in the route handler, the application responds with a 500 Internal Server Error status and that the response's content type matches the configured fallback error format, which in this case is set to \"text\". This behavior is crucial for consistent error handling and user experience.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves a Sanic application configured with a custom `MyConfig` class that sets `FALLBACK_ERROR_FORMAT` to \"text\". The route `/error` is defined to raise an exception when accessed. The test simulates a GET request to this route using `app.test_client.get(\"/error\")`, and then it asserts that the response status is 500 and the content type is \"text/plain; charset=utf-8\". This confirms that the application is correctly applying the fallback error format in response to the error.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of a custom configuration class (`MyConfig`) to inject specific settings into the Sanic application, demonstrating dependency injection. It also utilizes assertions to validate the response's status and content type, which is a common practice in unit testing to ensure that the application behaves as expected under error conditions. The test is structured to be clear and straightforward, focusing on a single aspect of functionality, which is a hallmark of effective unit tests."
    },
    {
      "name": "test_allow_fallback_error_format_in_config_replacement",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 403,
      "end_line_number": 411,
      "source_code": "def test_allow_fallback_error_format_in_config_replacement(app):\n    class MyConfig(Config):\n        FALLBACK_ERROR_FORMAT = \"text\"\n\n    app.config = MyConfig()\n\n    request, response = app.test_client.get(\"/error\")\n    assert response.status == 500\n    assert response.content_type == \"text/plain; charset=utf-8\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert response.content_type == 'text/plain; charset=utf-8'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_allow_fallback_error_format_in_config_replacement` is designed to verify that the Sanic application correctly utilizes a fallback error format specified in the configuration when an error occurs. Specifically, it checks that the application returns a 500 Internal Server Error with the appropriate content type when an error is triggered.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when the application encounters an error (in this case, a request to the `/error` endpoint), it responds with a status code of 500 and a content type of `text/plain; charset=utf-8`. This behavior is expected when the `FALLBACK_ERROR_FORMAT` is set to \"text\" in the application's configuration.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the Sanic application\u2019s error handling mechanism. The test creates a custom configuration class `MyConfig` that sets `FALLBACK_ERROR_FORMAT` to \"text\". The test then simulates a GET request to the `/error` endpoint using `app.test_client.get(\"/error\")`. The response is checked to ensure that it has the correct status and content type, indicating that the application is correctly handling errors according to the specified configuration.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of a custom configuration class to isolate the configuration settings for the test. It also utilizes assertions to validate the response's status and content type, which is a common practice in unit testing to ensure that the application behaves as expected under specific conditions. The use of a test client to simulate requests is a standard technique in testing web applications, allowing for the verification of endpoint behavior without needing to run a full server."
    },
    {
      "name": "test_config_fallback_before_and_after_startup",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 414,
      "end_line_number": 423,
      "source_code": "def test_config_fallback_before_and_after_startup(app):\n    app.config.FALLBACK_ERROR_FORMAT = \"json\"\n\n    @app.main_process_start\n    async def start(app, _):\n        app.config.FALLBACK_ERROR_FORMAT = \"text\"\n\n    _, response = app.test_client.get(\"/error\")\n    assert response.status == 500\n    assert response.content_type == \"application/json\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert response.content_type == 'application/json'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_config_fallback_before_and_after_startup` is designed to verify that the Sanic application correctly handles fallback error formats before and after the application startup process. It ensures that the error response format can be dynamically changed and that the application respects this configuration during error handling.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when an error occurs (simulated by accessing the `/error` endpoint), the application returns a 500 status code with a JSON content type before the application startup modifies the fallback error format. It confirms that the initial configuration is respected and that the application behaves as expected under error conditions.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the Sanic application\u2019s configuration management and error handling. The test sets the `FALLBACK_ERROR_FORMAT` to \"json\" before defining an asynchronous startup function that changes this format to \"text\". When the test client makes a GET request to the `/error` endpoint, it expects a 500 status response with a content type of \"application/json\". This behavior is validated by the assertions that check the response status and content type.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of decorators to register an asynchronous function (`@app.main_process_start`) that modifies the application\u2019s configuration. This pattern allows for testing the application\u2019s behavior in a stateful manner, simulating real-world scenarios where configurations may change during the application lifecycle. Additionally, the test uses assertions to validate the expected outcomes, which is a common practice in unit testing to ensure that the code behaves as intended."
    },
    {
      "name": "test_config_fallback_using_update_dict",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 426,
      "end_line_number": 431,
      "source_code": "def test_config_fallback_using_update_dict(app):\n    app.config.update({\"FALLBACK_ERROR_FORMAT\": \"text\"})\n\n    _, response = app.test_client.get(\"/error\")\n    assert response.status == 500\n    assert response.content_type == \"text/plain; charset=utf-8\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert response.content_type == 'text/plain; charset=utf-8'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_config_fallback_using_update_dict` is designed to verify that the application correctly updates its configuration to use a fallback error format when specified. Specifically, it checks that the application responds with the expected error format when an error occurs.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when the configuration is updated to set `FALLBACK_ERROR_FORMAT` to \"text\", the application returns a 500 Internal Server Error response with the content type set to \"text/plain; charset=utf-8\". This behavior is crucial for ensuring that error responses are formatted correctly based on the application's configuration.\n\n**Code Being Tested and How It Works**:  \nThe code being tested involves the `app.test_client.get(\"/error\")` method, which simulates a GET request to the \"/error\" endpoint. The test first updates the application's configuration using `app.config.update({\"FALLBACK_ERROR_FORMAT\": \"text\"})`. When the endpoint is accessed, it is expected to trigger an error, leading to a response that should match the specified status and content type. The assertions check that the response status is 500 and that the content type is as expected.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the response's status and content type, which is a common pattern in unit testing to ensure that the application behaves as expected under certain conditions. Additionally, it utilizes the `update` method of the configuration object, demonstrating a flexible way to modify application settings dynamically. The test is structured to be clear and straightforward, focusing on a single aspect of functionality, which is a best practice in unit testing to isolate and verify specific behaviors."
    },
    {
      "name": "test_config_fallback_using_update_kwarg",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 434,
      "end_line_number": 439,
      "source_code": "def test_config_fallback_using_update_kwarg(app):\n    app.config.update(FALLBACK_ERROR_FORMAT=\"text\")\n\n    _, response = app.test_client.get(\"/error\")\n    assert response.status == 500\n    assert response.content_type == \"text/plain; charset=utf-8\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert response.content_type == 'text/plain; charset=utf-8'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_config_fallback_using_update_kwarg` is designed to verify that the Sanic application correctly handles configuration updates using keyword arguments, specifically for the `FALLBACK_ERROR_FORMAT` setting. It ensures that when this configuration is set to \"text\", the application responds with the appropriate error format when an error occurs.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a request is made to the `/error` endpoint, the application returns a 500 Internal Server Error status and that the content type of the response is `text/plain; charset=utf-8`. This indicates that the application is correctly using the specified fallback error format in its response.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `app.config.update` method, which updates the application's configuration settings. In this case, it updates the `FALLBACK_ERROR_FORMAT` to \"text\". The subsequent call to `app.test_client.get(\"/error\")` simulates a request to an endpoint that triggers an error, allowing the test to assert the expected response status and content type. The `get` method is expected to return a response that reflects the updated configuration.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the Arrange-Act-Assert (AAA) pattern, where:\n- **Arrange**: The configuration is set up with `app.config.update(FALLBACK_ERROR_FORMAT=\"text\")`.\n- **Act**: A GET request is made to the `/error` endpoint.\n- **Assert**: The test checks the response status and content type to ensure they match the expected values. This pattern helps maintain clarity and structure in the test, making it easier to understand the purpose and flow of the test case."
    },
    {
      "name": "test_config_fallback_bad_value",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 442,
      "end_line_number": 445,
      "source_code": "def test_config_fallback_bad_value(app):\n    message = \"Unknown format: fake\"\n    with pytest.raises(SanicException, match=message):\n        app.config.FALLBACK_ERROR_FORMAT = \"fake\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_config_fallback_bad_value` test is to verify that the Sanic application raises a `SanicException` when an invalid value is assigned to the `FALLBACK_ERROR_FORMAT` configuration option. This ensures that the application correctly handles erroneous configurations and provides appropriate feedback to the developer.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when the `FALLBACK_ERROR_FORMAT` is set to an invalid string (\"fake\"), the application raises a `SanicException` with a specific error message (\"Unknown format: fake\"). This behavior is crucial for maintaining the integrity of the application's configuration and preventing misconfigurations from going unnoticed.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the assignment of a configuration value within the Sanic application instance (`app.config.FALLBACK_ERROR_FORMAT = \"fake\"`). The Sanic framework is expected to validate the value being assigned to this configuration option. If the value does not match any of the accepted formats, it raises a `SanicException`, which is caught by the `pytest.raises` context manager, allowing the test to confirm that the exception is raised as expected.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager, which is a common pattern in unit testing for asserting that specific exceptions are raised during the execution of a block of code. Additionally, the use of the `match` parameter allows for checking that the exception message matches the expected output, ensuring that not only is an exception raised, but it is also the correct exception with the appropriate message. This enhances the robustness of the test by verifying both the occurrence and the correctness of the exception."
    },
    {
      "name": "test_guess_mime_logging",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 523,
      "end_line_number": 552,
      "source_code": "def test_guess_mime_logging(\n    caplog, fake_request, route_format, fallback, accept, expected\n):\n    class FakeObject:\n        pass\n\n    fake_request.route = FakeObject()\n    fake_request.route.name = \"fakeroute\"\n    fake_request.route.extra = FakeObject()\n    fake_request.route.extra.error_format = route_format\n    if accept is None:\n        del fake_request.headers[\"accept\"]\n    else:\n        fake_request.headers[\"accept\"] = accept\n\n    if \"content-type\" in expected:\n        fake_request.headers[\"content-type\"] = \"application/json\"\n\n    # Fake JSON content (DEPRECATED: remove in 24.3)\n    if \"request.json\" in expected:\n        fake_request.parsed_json = {\"foo\": \"bar\"}\n\n    with caplog.at_level(logging.DEBUG, logger=\"sanic.root\"):\n        guess_mime(fake_request, fallback)\n\n    (logmsg,) = [\n        r.message for r in caplog.records if r.funcName == \"guess_mime\"\n    ]\n\n    assert logmsg == f\"Error Page: {expected}\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('route_format,fallback,accept,expected', (('json', 'html', '*/*', \"The client accepts */*, using 'json' from fakeroute\"), ('json', 'auto', 'text/html,*/*;q=0.8', \"The client accepts text/html, using 'html' from any\"), ('json', 'json', 'text/html,*/*;q=0.8', \"The client accepts */*;q=0.8, using 'json' from fakeroute\"), ('', 'html', 'text/*,*/plain', \"The client accepts text/*, using 'html' from FALLBACK_ERROR_FORMAT\"), ('', 'json', 'text/*,*/*', \"The client accepts */*, using 'json' from FALLBACK_ERROR_FORMAT\"), ('', 'auto', '*/*,application/json;q=0.5', \"The client accepts */*, using 'json' from request.accept\"), ('', 'auto', '*/*', \"The client accepts */*, using 'json' from content-type\"), ('', 'auto', 'text/html,text/plain', \"The client accepts text/plain, using 'text' from any\"), ('', 'auto', 'text/html,text/plain;q=0.9', \"The client accepts text/html, using 'html' from any\"), ('html', 'json', 'application/xml', 'No format found, the client accepts [application/xml]'), ('', 'auto', '*/*', \"The client accepts */*, using 'text' from any\"), ('', '', '*/*', 'No format found, the client accepts [*/*]'), ('', 'auto', '*/*', \"The client accepts */*, using 'json' from request.json\")))"
      ],
      "arguments": [
        "caplog",
        "fake_request",
        "route_format",
        "fallback",
        "accept",
        "expected"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert logmsg == f'Error Page: {expected}'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_guess_mime_logging` function is designed to verify that the `guess_mime` function correctly logs the expected error page message when handling a request with specific parameters. It ensures that the logging behavior aligns with the expected output based on the request's attributes and the fallback format.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the log message generated by the `guess_mime` function matches the expected error page format. It specifically verifies that the logging captures the correct error format based on the request's route and headers, including handling cases where certain headers may be absent.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `guess_mime` function, which determines the appropriate MIME type for a response based on the incoming request. It inspects the request's route, headers, and any fallback formats to decide the MIME type. The test sets up a fake request with various attributes (like route name and error format) and simulates the logging behavior by invoking `guess_mime`. It then checks the log output to ensure it matches the expected error message format.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The test utilizes `caplog` to capture log messages during the execution of the `guess_mime` function, allowing for verification of logging behavior.\n- **Parameterization**: The test is likely part of a parameterized test suite (though not shown in the provided snippet), which allows it to run multiple scenarios with different inputs and expected outputs, enhancing coverage and robustness.\n- **Mocking**: The test creates a `FakeObject` to simulate the request's route and its attributes, isolating the test from the actual implementation and focusing on the logging behavior."
    },
    {
      "name": "test_exception_header_on_renderers",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 563,
      "end_line_number": 575,
      "source_code": "def test_exception_header_on_renderers(app: Sanic, format, expected):\n    app.config.FALLBACK_ERROR_FORMAT = format\n\n    @app.get(\"/test\")\n    def test(request):\n        raise SanicException(\n            \"test\", status_code=400, headers={\"exception\": \"test\"}\n        )\n\n    _, response = app.test_client.get(\"/test\")\n    assert response.status == 400\n    assert response.headers.get(\"exception\") == \"test\"\n    assert response.content_type == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('format,expected', (('html', 'text/html; charset=utf-8'), ('text', 'text/plain; charset=utf-8'), ('json', 'application/json')))"
      ],
      "arguments": [
        "app",
        "format",
        "expected"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 400",
        "assert response.headers.get('exception') == 'test'",
        "assert response.content_type == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response.headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_exception_header_on_renderers` test is to verify that when a `SanicException` is raised within a route handler, the application correctly returns the specified HTTP status code, includes the appropriate headers, and sets the correct content type in the response.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that:\n1. The HTTP response status is set to 400 when a `SanicException` is raised.\n2. The response headers include a custom header (`exception`) with the value \"test\".\n3. The content type of the response matches the expected format provided in the test parameters.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes:\n- The route handler defined by `@app.get(\"/test\")`, which raises a `SanicException` with a status code of 400 and a custom header.\n- The `app.test_client.get(\"/test\")` method, which simulates a GET request to the `/test` endpoint and captures the response.\n- The assertions that check the response's status, headers, and content type.\n\nThe `SanicException` class is designed to generate an HTTP response when raised, allowing the application to handle errors gracefully and provide meaningful feedback to the client.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses parameters (`format` and `expected`) to allow for multiple test cases with different content types, enhancing test coverage without duplicating code.\n- **Assertion Checks**: The test employs assertions to validate the response's status, headers, and content type, ensuring that the application behaves as expected under error conditions.\n- **Exception Handling**: The test effectively demonstrates how the application handles exceptions raised during request processing, ensuring that the correct error information is communicated back to the client."
    },
    {
      "name": "test_catch_exception_list",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions.py",
      "line_number": 118,
      "end_line_number": 131,
      "source_code": "def test_catch_exception_list(app):\n    @app.exception([SanicExceptionTestException, NotFound])\n    def exception_list(request, exception):\n        return text(\"ok\")\n\n    @app.route(\"/\")\n    def exception(request):\n        raise SanicExceptionTestException(\"You won't see me\")\n\n    request, response = app.test_client.get(\"/random\")\n    assert response.text == \"ok\"\n\n    request, response = app.test_client.get(\"/\")\n    assert response.text == \"ok\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "itertools.count",
        "pytest",
        "bs4.BeautifulSoup",
        "sanic.Sanic",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ContentRangeError",
        "sanic.exceptions.ExpectationFailed",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.HeaderExpectationFailed",
        "sanic.exceptions.InvalidUsage",
        "sanic.exceptions.MethodNotAllowed",
        "sanic.exceptions.MethodNotSupported",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.RangeNotSatisfiable",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.exceptions.Unauthorized",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'ok'",
        "assert response.text == 'ok'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.exception",
          "body": "@app.route('/')\ndef exception(request):\n    raise SanicExceptionTestException(\"You won't see me\")"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_catch_exception_list` test is to verify that the Sanic application correctly handles exceptions raised by specific routes and returns a predefined response when those exceptions occur. It ensures that the application can gracefully manage errors without crashing and provides a consistent response format.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a `SanicExceptionTestException` is raised in the route handler, the application catches this exception and returns the response \"ok\" as defined in the `exception_list` function. It also verifies that a request to a non-existent route (\"/random\") also returns \"ok\", demonstrating that the exception handling is correctly applied to multiple exceptions.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes:\n- The `@app.exception` decorator, which registers a handler for specified exceptions (`SanicExceptionTestException` and `NotFound`). When these exceptions are raised, the `exception_list` function is invoked, returning a response with the text \"ok\".\n- The route defined by `@app.route(\"/\")`, which raises a `SanicExceptionTestException` when accessed. This simulates an error scenario to test the exception handling mechanism.\n- The `app.test_client.get` method is used to simulate HTTP GET requests to the application, allowing the test to check the responses returned by the application.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Exception Handling Testing**: It explicitly tests the application's behavior when exceptions are raised, ensuring that the application can handle errors gracefully.\n- **Route Testing**: By defining routes and simulating requests, the test verifies that the routing and exception handling mechanisms work as intended.\n- **Assertions**: The use of assertions (`assert response.text == \"ok\"`) checks the correctness of the output, ensuring that the expected behavior matches the actual behavior of the application.\n- **Isolation of Tests**: Each test case is independent, allowing for focused testing of specific functionalities without interference from other tests."
    },
    {
      "name": "test_no_exception",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions.py",
      "line_number": 134,
      "end_line_number": 138,
      "source_code": "def test_no_exception(exception_app):\n    \"\"\"Test that a route works without an exception\"\"\"\n    request, response = exception_app.test_client.get(\"/\")\n    assert response.status == 200\n    assert response.text == \"OK\"",
      "docstring": "Test that a route works without an exception",
      "decorators": [],
      "arguments": [
        "exception_app"
      ],
      "imports": [
        "logging",
        "itertools.count",
        "pytest",
        "bs4.BeautifulSoup",
        "sanic.Sanic",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ContentRangeError",
        "sanic.exceptions.ExpectationFailed",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.HeaderExpectationFailed",
        "sanic.exceptions.InvalidUsage",
        "sanic.exceptions.MethodNotAllowed",
        "sanic.exceptions.MethodNotSupported",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.RangeNotSatisfiable",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.exceptions.Unauthorized",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_no_exception` unit test is designed to verify that a specific route in the Sanic application can be accessed successfully without raising any exceptions. It ensures that the application behaves as expected under normal conditions.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a GET request is made to the root route (\"/\"), the response status is 200 (indicating success) and the response body contains the text \"OK\". This confirms that the route is functioning correctly and returning the expected output.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `exception_app.test_client.get(\"/\")` method, which simulates a GET request to the root route of the application. The expected behavior is defined in the route handler, which should return a response with a status of 200 and the text \"OK\". The test asserts that these conditions are met, thereby validating the route's implementation.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the Arrange-Act-Assert (AAA) pattern:\n- **Arrange**: The test sets up the necessary context by using the `exception_app` fixture.\n- **Act**: It performs the action of sending a GET request to the root route.\n- **Assert**: Finally, it checks the response status and content to ensure they match the expected values. This structured approach enhances readability and maintainability of the test."
    },
    {
      "name": "test_server_error_exception",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions.py",
      "line_number": 141,
      "end_line_number": 144,
      "source_code": "def test_server_error_exception(exception_app):\n    \"\"\"Test the built-in ServerError exception works\"\"\"\n    request, response = exception_app.test_client.get(\"/error\")\n    assert response.status == 500",
      "docstring": "Test the built-in ServerError exception works",
      "decorators": [],
      "arguments": [
        "exception_app"
      ],
      "imports": [
        "logging",
        "itertools.count",
        "pytest",
        "bs4.BeautifulSoup",
        "sanic.Sanic",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ContentRangeError",
        "sanic.exceptions.ExpectationFailed",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.HeaderExpectationFailed",
        "sanic.exceptions.InvalidUsage",
        "sanic.exceptions.MethodNotAllowed",
        "sanic.exceptions.MethodNotSupported",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.RangeNotSatisfiable",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.exceptions.Unauthorized",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_server_error_exception` unit test is designed to verify that the built-in `ServerError` exception in the Sanic framework correctly returns a 500 Internal Server Error status when an error occurs during the handling of a request.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a request is made to the `/error` endpoint, the response status is 500, indicating that a server-side error has occurred. This confirms that the application is properly handling server errors and returning the appropriate HTTP status code.\n\n**Code Being Tested and How It Works**:  \nThe code being tested involves the `exception_app.test_client.get` method, which simulates an HTTP GET request to the `/error` endpoint. The expected behavior is that this endpoint triggers a `ServerError`, which is a subclass of `HTTPException` with a status code of 500. The test asserts that the response status matches this expected value.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern, where the response status is directly compared to the expected value (500). It utilizes the `exception_app` fixture, which likely sets up a test instance of the Sanic application configured to trigger the `ServerError` when the `/error` endpoint is accessed. This pattern of using fixtures to provide context or setup for tests is common in unit testing, allowing for clean and isolated test cases."
    },
    {
      "name": "test_invalid_usage_exception",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions.py",
      "line_number": 147,
      "end_line_number": 150,
      "source_code": "def test_invalid_usage_exception(exception_app):\n    \"\"\"Test the built-in BadRequest exception works\"\"\"\n    request, response = exception_app.test_client.get(\"/invalid\")\n    assert response.status == 400",
      "docstring": "Test the built-in BadRequest exception works",
      "decorators": [],
      "arguments": [
        "exception_app"
      ],
      "imports": [
        "logging",
        "itertools.count",
        "pytest",
        "bs4.BeautifulSoup",
        "sanic.Sanic",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ContentRangeError",
        "sanic.exceptions.ExpectationFailed",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.HeaderExpectationFailed",
        "sanic.exceptions.InvalidUsage",
        "sanic.exceptions.MethodNotAllowed",
        "sanic.exceptions.MethodNotSupported",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.RangeNotSatisfiable",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.exceptions.Unauthorized",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 400"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_invalid_usage_exception` unit test is designed to verify that the application correctly handles invalid requests by returning a `400 Bad Request` status code when a specific endpoint (`/invalid`) is accessed.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks the behavior of the application when it encounters a situation that should trigger a `BadRequest` exception. It ensures that the application responds appropriately to invalid usage by returning the correct HTTP status code, which is a fundamental aspect of RESTful API design.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `exception_app.test_client.get(\"/invalid\")` method call, which simulates an HTTP GET request to the `/invalid` endpoint. The expected behavior is that this endpoint will raise a `BadRequest` exception, leading to a response with a status code of `400`. The assertion `assert response.status == 400` checks that the actual response status matches the expected status.\n\n**Notable Testing Patterns or Techniques Used**:  \nThis test employs the Arrange-Act-Assert (AAA) pattern, where:\n- **Arrange**: The test sets up the necessary context by using the `exception_app` fixture.\n- **Act**: It performs the action of sending a GET request to the `/invalid` endpoint.\n- **Assert**: Finally, it asserts that the response status is `400`, confirming that the application behaves as expected in the face of invalid input. This pattern helps in maintaining clarity and structure in the test code."
    },
    {
      "name": "test_not_found_exception",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions.py",
      "line_number": 153,
      "end_line_number": 156,
      "source_code": "def test_not_found_exception(exception_app):\n    \"\"\"Test the built-in NotFound exception works\"\"\"\n    request, response = exception_app.test_client.get(\"/404\")\n    assert response.status == 404",
      "docstring": "Test the built-in NotFound exception works",
      "decorators": [],
      "arguments": [
        "exception_app"
      ],
      "imports": [
        "logging",
        "itertools.count",
        "pytest",
        "bs4.BeautifulSoup",
        "sanic.Sanic",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ContentRangeError",
        "sanic.exceptions.ExpectationFailed",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.HeaderExpectationFailed",
        "sanic.exceptions.InvalidUsage",
        "sanic.exceptions.MethodNotAllowed",
        "sanic.exceptions.MethodNotSupported",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.RangeNotSatisfiable",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.exceptions.Unauthorized",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_not_found_exception` unit test is designed to verify that the built-in `NotFound` exception in the Sanic web framework correctly returns a 404 HTTP status code when a non-existent route is accessed.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a GET request is made to the `/404` endpoint, the response status is 404, indicating that the requested resource was not found. This confirms that the framework's error handling for missing routes is functioning as expected.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `exception_app.test_client.get(\"/404\")` method call, which simulates an HTTP GET request to the `/404` route. The `exception_app` is an instance of a Sanic application configured to handle exceptions. The expected behavior is that the application will raise a `NotFound` exception when the `/404` route is accessed, leading to a response with a status code of 404.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern, where the response status is directly compared to the expected value (404). This is a common practice in unit testing to ensure that the output of a function or method matches the expected outcome. Additionally, the use of a test client to simulate HTTP requests is a standard technique in testing web applications, allowing for the verification of route handling and error responses without needing to run a live server."
    },
    {
      "name": "test_forbidden_exception",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions.py",
      "line_number": 159,
      "end_line_number": 162,
      "source_code": "def test_forbidden_exception(exception_app):\n    \"\"\"Test the built-in Forbidden exception\"\"\"\n    request, response = exception_app.test_client.get(\"/403\")\n    assert response.status == 403",
      "docstring": "Test the built-in Forbidden exception",
      "decorators": [],
      "arguments": [
        "exception_app"
      ],
      "imports": [
        "logging",
        "itertools.count",
        "pytest",
        "bs4.BeautifulSoup",
        "sanic.Sanic",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ContentRangeError",
        "sanic.exceptions.ExpectationFailed",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.HeaderExpectationFailed",
        "sanic.exceptions.InvalidUsage",
        "sanic.exceptions.MethodNotAllowed",
        "sanic.exceptions.MethodNotSupported",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.RangeNotSatisfiable",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.exceptions.Unauthorized",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 403"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_forbidden_exception` unit test is designed to verify that the application correctly raises a \"Forbidden\" HTTP status (403) when a specific endpoint (\"/403\") is accessed. This ensures that the application enforces access control as intended.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when a request is made to the \"/403\" endpoint, the response status code is 403. This indicates that the server is correctly handling forbidden access scenarios, which is a critical aspect of web application security.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the `exception_app` fixture, which is presumably a Sanic application instance configured for testing. The line `request, response = exception_app.test_client.get(\"/403\")` sends a GET request to the \"/403\" endpoint. The assertion `assert response.status == 403` then verifies that the response status matches the expected forbidden status code.\n\n**Notable Testing Patterns or Techniques Used**:  \nThis test employs a straightforward assertion pattern to validate the response status. It uses the `test_client` provided by the Sanic framework, which simulates HTTP requests to the application. The test is concise and focuses solely on the expected outcome, making it easy to understand and maintain. Additionally, the use of a fixture (`exception_app`) promotes reusability and isolation in testing, allowing for a clean setup of the application context."
    },
    {
      "name": "test_unauthorized_exception",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions.py",
      "line_number": 165,
      "end_line_number": 188,
      "source_code": "def test_unauthorized_exception(exception_app):\n    \"\"\"Test the built-in Unauthorized exception\"\"\"\n    request, response = exception_app.test_client.get(\"/401\")\n    assert response.status == 401\n\n    request, response = exception_app.test_client.get(\"/401/basic\")\n    assert response.status == 401\n    assert response.headers.get(\"WWW-Authenticate\") is not None\n    assert response.headers.get(\"WWW-Authenticate\") == 'Basic realm=\"Sanic\"'\n\n    request, response = exception_app.test_client.get(\"/401/digest\")\n    assert response.status == 401\n\n    auth_header = response.headers.get(\"WWW-Authenticate\")\n    assert auth_header is not None\n    assert auth_header.startswith(\"Digest\")\n    assert 'qop=\"auth, auth-int\"' in auth_header\n    assert 'algorithm=\"MD5\"' in auth_header\n    assert 'nonce=\"abcdef\"' in auth_header\n    assert 'opaque=\"zyxwvu\"' in auth_header\n\n    request, response = exception_app.test_client.get(\"/401/bearer\")\n    assert response.status == 401\n    assert response.headers.get(\"WWW-Authenticate\") == \"Bearer\"",
      "docstring": "Test the built-in Unauthorized exception",
      "decorators": [],
      "arguments": [
        "exception_app"
      ],
      "imports": [
        "logging",
        "itertools.count",
        "pytest",
        "bs4.BeautifulSoup",
        "sanic.Sanic",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ContentRangeError",
        "sanic.exceptions.ExpectationFailed",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.HeaderExpectationFailed",
        "sanic.exceptions.InvalidUsage",
        "sanic.exceptions.MethodNotAllowed",
        "sanic.exceptions.MethodNotSupported",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.RangeNotSatisfiable",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.exceptions.Unauthorized",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 401",
        "assert response.status == 401",
        "assert response.headers.get('WWW-Authenticate') is not None",
        "assert response.headers.get('WWW-Authenticate') == 'Basic realm=\"Sanic\"'",
        "assert response.status == 401",
        "assert auth_header is not None",
        "assert auth_header.startswith('Digest')",
        "assert 'qop=\"auth, auth-int\"' in auth_header",
        "assert 'algorithm=\"MD5\"' in auth_header",
        "assert 'nonce=\"abcdef\"' in auth_header",
        "assert 'opaque=\"zyxwvu\"' in auth_header",
        "assert response.status == 401",
        "assert response.headers.get('WWW-Authenticate') == 'Bearer'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "exception_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "exception_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response.headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "exception_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response.headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response.headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response.headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_unauthorized_exception` unit test is designed to verify the behavior of the Sanic web framework when handling unauthorized access attempts. Specifically, it checks that the application correctly responds with a 401 Unauthorized status code and provides appropriate WWW-Authenticate headers for different authentication schemes.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies that:\n1. Accessing a route that requires authentication returns a 401 status code.\n2. The response includes the correct WWW-Authenticate header for Basic authentication.\n3. The response includes the correct WWW-Authenticate header for Digest authentication, including specific parameters.\n4. The response includes the correct WWW-Authenticate header for Bearer authentication.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `exception_app` instance, which is a Sanic application. It uses the `test_client.get` method to simulate HTTP GET requests to various endpoints (e.g., `/401`, `/401/basic`, `/401/digest`, `/401/bearer`). The responses are then checked for the correct status code and headers. The `response` object contains the HTTP status and headers returned by the application, which are asserted against expected values to ensure the application behaves as intended.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertion-Based Testing**: The test uses assertions to validate the response status and headers, ensuring that the application behaves correctly under unauthorized access conditions.\n- **Parameterized Testing**: Although not explicitly shown in this test, the surrounding context suggests that similar tests may use parameterization to cover multiple scenarios efficiently.\n- **Integration Testing**: This test acts as an integration test by verifying the interaction between the HTTP client and the Sanic application, ensuring that the routing and middleware for handling unauthorized access are functioning correctly."
    },
    {
      "name": "test_handled_unhandled_exception",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions.py",
      "line_number": 191,
      "end_line_number": 199,
      "source_code": "def test_handled_unhandled_exception(exception_app):\n    \"\"\"Test that an exception not built into sanic is handled\"\"\"\n    request, response = exception_app.test_client.get(\"/divide_by_zero\")\n    assert response.status == 500\n    soup = BeautifulSoup(response.body, \"html.parser\")\n    assert \"Internal Server Error\" in soup.h1.text\n\n    message = \" \".join(soup.p.text.split())\n    assert \"The application encountered an unexpected error\" in message",
      "docstring": "Test that an exception not built into sanic is handled",
      "decorators": [],
      "arguments": [
        "exception_app"
      ],
      "imports": [
        "logging",
        "itertools.count",
        "pytest",
        "bs4.BeautifulSoup",
        "sanic.Sanic",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ContentRangeError",
        "sanic.exceptions.ExpectationFailed",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.HeaderExpectationFailed",
        "sanic.exceptions.InvalidUsage",
        "sanic.exceptions.MethodNotAllowed",
        "sanic.exceptions.MethodNotSupported",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.RangeNotSatisfiable",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.exceptions.Unauthorized",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert 'Internal Server Error' in soup.h1.text",
        "assert 'The application encountered an unexpected error' in message"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_handled_unhandled_exception` test is designed to verify that the Sanic application correctly handles exceptions that are not built into the framework. Specifically, it checks that when a division by zero occurs, the application responds with a 500 Internal Server Error status and provides an appropriate error message in the response body.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the application gracefully handles unexpected errors by returning a standardized error response. It verifies that the HTTP status code is 500 and that the response body contains specific text indicating that an unexpected error occurred, which is crucial for debugging and user experience.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `exception_app` instance of the Sanic application, which is expected to have a route defined for `/divide_by_zero` that triggers a division by zero error. The `test_client.get` method simulates an HTTP GET request to this endpoint. The response is then checked for a status code of 500 and the presence of specific error messages in the HTML response body, which is parsed using BeautifulSoup.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Integration Testing**: The test checks the interaction between the HTTP client and the Sanic application, ensuring that the entire request-response cycle behaves as expected under error conditions.\n- **Assertion of Response Content**: The test uses assertions to validate both the HTTP status code and the content of the response body, ensuring that the application not only fails correctly but also provides meaningful feedback to the user.\n- **HTML Parsing**: The use of BeautifulSoup to parse the HTML response allows for more granular checks of the response content, demonstrating a technique for validating structured data in web responses."
    },
    {
      "name": "test_exception_in_exception_handler",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions.py",
      "line_number": 202,
      "end_line_number": 208,
      "source_code": "def test_exception_in_exception_handler(exception_app):\n    \"\"\"Test that an exception thrown in an error handler is handled\"\"\"\n    request, response = exception_app.test_client.get(\n        \"/error_in_error_handler_handler\"\n    )\n    assert response.status == 500\n    assert response.body == b\"An error occurred while handling an error\"",
      "docstring": "Test that an exception thrown in an error handler is handled",
      "decorators": [],
      "arguments": [
        "exception_app"
      ],
      "imports": [
        "logging",
        "itertools.count",
        "pytest",
        "bs4.BeautifulSoup",
        "sanic.Sanic",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ContentRangeError",
        "sanic.exceptions.ExpectationFailed",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.HeaderExpectationFailed",
        "sanic.exceptions.InvalidUsage",
        "sanic.exceptions.MethodNotAllowed",
        "sanic.exceptions.MethodNotSupported",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.RangeNotSatisfiable",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.exceptions.Unauthorized",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert response.body == b'An error occurred while handling an error'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_exception_in_exception_handler` test is to verify that when an exception occurs within an error handler in a Sanic application, it is properly caught and results in a 500 Internal Server Error response, along with a specific error message.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the application responds with a status code of 500 and returns a predefined error message (\"An error occurred while handling an error\") when an error is raised in the error handling logic. This ensures that the application can gracefully handle exceptions that occur during error processing.\n\n**Code Being Tested and How It Works**:  \nThe code being tested involves the `exception_app.test_client.get` method, which simulates an HTTP GET request to the endpoint `/error_in_error_handler_handler`. The expectation is that this endpoint triggers an error in the error handler, leading to the specified response. The test checks the response's status and body to confirm that the error handling mechanism is functioning as intended.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the response status and body, which is a common pattern in unit testing to ensure that the actual output matches the expected output. Additionally, the test is structured to be clear and concise, focusing on a single aspect of functionality, which is a best practice in unit testing to isolate behaviors and make tests easier to understand and maintain."
    },
    {
      "name": "test_exception_in_exception_handler_debug_off",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions.py",
      "line_number": 211,
      "end_line_number": 217,
      "source_code": "def test_exception_in_exception_handler_debug_off(exception_app):\n    \"\"\"Test that an exception thrown in an error handler is handled\"\"\"\n    request, response = exception_app.test_client.get(\n        \"/error_in_error_handler_handler\", debug=False\n    )\n    assert response.status == 500\n    assert response.body == b\"An error occurred while handling an error\"",
      "docstring": "Test that an exception thrown in an error handler is handled",
      "decorators": [],
      "arguments": [
        "exception_app"
      ],
      "imports": [
        "logging",
        "itertools.count",
        "pytest",
        "bs4.BeautifulSoup",
        "sanic.Sanic",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ContentRangeError",
        "sanic.exceptions.ExpectationFailed",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.HeaderExpectationFailed",
        "sanic.exceptions.InvalidUsage",
        "sanic.exceptions.MethodNotAllowed",
        "sanic.exceptions.MethodNotSupported",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.RangeNotSatisfiable",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.exceptions.Unauthorized",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert response.body == b'An error occurred while handling an error'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_exception_in_exception_handler_debug_off` is designed to verify that when an exception occurs within an error handler in a Sanic application, it is properly managed and results in a 500 Internal Server Error response, even when the debug mode is turned off.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the application responds with a status code of 500 and a predefined error message when an error occurs in the error handling process. It ensures that the application does not expose sensitive debugging information to the client when debug mode is disabled.\n\n**Code Being Tested and How It Works**:  \nThe test invokes the `get` method of the `exception_app`'s test client, targeting the endpoint `/error_in_error_handler_handler` with `debug=False`. The expected behavior is that the application will catch the exception raised in the error handler and return a response with a status code of 500 and a body containing the message \"An error occurred while handling an error\". This is indicative of proper error handling within the application.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the response status and body, which is a common pattern in unit testing to ensure that the actual output matches the expected output. Additionally, it utilizes a test client to simulate HTTP requests, allowing for the testing of application behavior in a controlled environment. The separation of tests for different debug states (debug on/off) demonstrates a parameterized approach to testing various configurations of the application."
    },
    {
      "name": "test_exception_in_exception_handler_debug_on",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions.py",
      "line_number": 220,
      "end_line_number": 226,
      "source_code": "def test_exception_in_exception_handler_debug_on(exception_app):\n    \"\"\"Test that an exception thrown in an error handler is handled\"\"\"\n    request, response = exception_app.test_client.get(\n        \"/error_in_error_handler_handler\", debug=True\n    )\n    assert response.status == 500\n    assert response.body.startswith(b\"Exception raised in exception \")",
      "docstring": "Test that an exception thrown in an error handler is handled",
      "decorators": [],
      "arguments": [
        "exception_app"
      ],
      "imports": [
        "logging",
        "itertools.count",
        "pytest",
        "bs4.BeautifulSoup",
        "sanic.Sanic",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ContentRangeError",
        "sanic.exceptions.ExpectationFailed",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.HeaderExpectationFailed",
        "sanic.exceptions.InvalidUsage",
        "sanic.exceptions.MethodNotAllowed",
        "sanic.exceptions.MethodNotSupported",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.RangeNotSatisfiable",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.exceptions.Unauthorized",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert response.body.startswith(b'Exception raised in exception ')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_exception_in_exception_handler_debug_on` is designed to verify that when an exception occurs within an error handler while the application is in debug mode, the response correctly reflects the nature of the exception. Specifically, it checks that the response status is 500 (Internal Server Error) and that the response body indicates an exception was raised.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the application properly handles exceptions that are thrown during the execution of an error handler. It verifies that the application does not crash and instead returns a meaningful error response, which is crucial for debugging and understanding issues in production environments.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `exception_app` instance, which is a Sanic application configured to simulate error scenarios. The test client makes a GET request to the endpoint `/error_in_error_handler_handler` with the `debug` flag set to `True`. The expected behavior is that the application will raise an exception in the error handler, resulting in a response with a status code of 500 and a body that starts with the string \"Exception raised in exception\".\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertion Checks**: The test uses assertions to validate the response status and body, ensuring that the application behaves as expected under error conditions.\n- **Debug Mode Testing**: By setting the `debug` parameter to `True`, the test specifically checks the application's behavior in a development context, which is important for developers to see detailed error messages.\n- **Isolation of Test Cases**: This test is part of a suite that includes other tests for different scenarios (e.g., debug off, normal error handling), allowing for comprehensive coverage of error handling behavior in the application."
    },
    {
      "name": "test_sanic_exception",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions.py",
      "line_number": 229,
      "end_line_number": 241,
      "source_code": "def test_sanic_exception(exception_app):\n    \"\"\"Test sanic exceptions are handled\"\"\"\n    request, response = exception_app.test_client.get(\"/abort/401\")\n    assert response.status == 401\n\n    request, response = exception_app.test_client.get(\"/abort\")\n    assert response.status == 500\n    # check fallback message\n    assert \"Internal Server Error\" in response.text\n\n    request, response = exception_app.test_client.get(\"/abort/message\")\n    assert response.status == 500\n    assert \"Custom Message\" in response.text",
      "docstring": "Test sanic exceptions are handled",
      "decorators": [],
      "arguments": [
        "exception_app"
      ],
      "imports": [
        "logging",
        "itertools.count",
        "pytest",
        "bs4.BeautifulSoup",
        "sanic.Sanic",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ContentRangeError",
        "sanic.exceptions.ExpectationFailed",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.HeaderExpectationFailed",
        "sanic.exceptions.InvalidUsage",
        "sanic.exceptions.MethodNotAllowed",
        "sanic.exceptions.MethodNotSupported",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.RangeNotSatisfiable",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.exceptions.Unauthorized",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 401",
        "assert response.status == 500",
        "assert 'Internal Server Error' in response.text",
        "assert response.status == 500",
        "assert 'Custom Message' in response.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "exception_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "exception_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_sanic_exception` function is designed to verify that the Sanic web framework correctly handles exceptions raised during HTTP requests. Specifically, it checks that the application returns the appropriate HTTP status codes and messages when specific routes are accessed that trigger exceptions.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies three scenarios:\n1. When a request is made to the `/abort/401` route, it expects a 401 Unauthorized status.\n2. When a request is made to the `/abort` route, it expects a 500 Internal Server Error status and checks for the presence of the \"Internal Server Error\" message in the response.\n3. When a request is made to the `/abort/message` route, it expects a 500 Internal Server Error status and checks for a custom error message \"Custom Message\" in the response.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is part of a Sanic application defined in the `exception_app` function. This application includes routes that intentionally raise `SanicException` with different status codes and messages. The `test_client.get` method simulates HTTP GET requests to these routes, allowing the test to assert the expected behavior based on the exceptions raised.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the following patterns:\n- **Assertion-Based Testing**: It uses assertions to validate the response status and content, ensuring that the application behaves as expected under error conditions.\n- **Route Testing**: It directly tests specific routes that are designed to trigger exceptions, allowing for focused testing of error handling.\n- **Separation of Concerns**: The test is isolated from the application logic, focusing solely on the behavior of the HTTP responses, which is a good practice in unit testing."
    },
    {
      "name": "test_custom_exception_default_message",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions.py",
      "line_number": 244,
      "end_line_number": 257,
      "source_code": "def test_custom_exception_default_message(exception_app):\n    class TeaError(SanicException):\n        message = \"Tempest in a teapot\"\n        status_code = 418\n\n    exception_app.router.reset()\n\n    @exception_app.get(\"/tempest\")\n    def tempest(_):\n        raise TeaError\n\n    _, response = exception_app.test_client.get(\"/tempest\", debug=True)\n    assert response.status == 418\n    assert b\"Tempest in a teapot\" in response.body",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "exception_app"
      ],
      "imports": [
        "logging",
        "itertools.count",
        "pytest",
        "bs4.BeautifulSoup",
        "sanic.Sanic",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ContentRangeError",
        "sanic.exceptions.ExpectationFailed",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.HeaderExpectationFailed",
        "sanic.exceptions.InvalidUsage",
        "sanic.exceptions.MethodNotAllowed",
        "sanic.exceptions.MethodNotSupported",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.RangeNotSatisfiable",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.exceptions.Unauthorized",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 418",
        "assert b'Tempest in a teapot' in response.body"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_app.router.reset",
          "body": "@pytest.fixture(autouse=True)\ndef reset():\n    try:\n        del os.environ['SANIC_MOTD_OUTPUT']\n    except KeyError:\n        ..."
        },
        {
          "name": "exception_app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "exception_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_custom_exception_default_message` test is to verify that a custom exception (`TeaError`) correctly returns the expected HTTP status code and message when raised in a Sanic application route.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when the `TeaError` exception is raised in response to a GET request to the `/tempest` endpoint, the response has a status code of 418 and contains the message \"Tempest in a teapot\" in its body.\n\n**Code Being Tested and How It Works**:  \nThe code being tested includes the `TeaError` class, which inherits from `SanicException`, and the route handler for `/tempest`. When a GET request is made to this endpoint, the `tempest` function raises the `TeaError`. The test then uses the `exception_app.test_client.get` method to simulate the request and capture the response. The assertions check that the response status and body match the expected values.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of a fixture (`exception_app`) to set up the application context, ensuring that the router is reset before defining the route. It also uses assertions to validate the response, which is a common practice in unit testing to confirm that the actual output matches the expected output. The test is structured to be clear and concise, focusing on a single behavior, which is a good practice in unit testing."
    },
    {
      "name": "test_exception_in_ws_logged",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions.py",
      "line_number": 260,
      "end_line_number": 276,
      "source_code": "def test_exception_in_ws_logged(caplog):\n    app = Sanic(\"Test\")\n\n    @app.websocket(\"/feed\")\n    async def feed(request, ws):\n        raise Exception(\"...\")\n\n    with caplog.at_level(logging.INFO):\n        app.test_client.websocket(\"/feed\")\n\n    for record in caplog.record_tuples:\n        if record[2].startswith(\"Exception occurred\"):\n            break\n\n    assert record[0] == \"sanic.error\"\n    assert record[1] == logging.ERROR\n    assert \"Exception occurred while handling uri:\" in record[2]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "caplog"
      ],
      "imports": [
        "logging",
        "itertools.count",
        "pytest",
        "bs4.BeautifulSoup",
        "sanic.Sanic",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ContentRangeError",
        "sanic.exceptions.ExpectationFailed",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.HeaderExpectationFailed",
        "sanic.exceptions.InvalidUsage",
        "sanic.exceptions.MethodNotAllowed",
        "sanic.exceptions.MethodNotSupported",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.RangeNotSatisfiable",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.exceptions.Unauthorized",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert record[0] == 'sanic.error'",
        "assert record[1] == logging.ERROR",
        "assert 'Exception occurred while handling uri:' in record[2]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_exception_in_ws_logged` test is to verify that exceptions raised during the handling of WebSocket connections in a Sanic application are properly logged at the error level. This ensures that any issues during WebSocket communication are captured in the logs for debugging and monitoring purposes.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that when an exception is raised in the WebSocket handler, it is logged with the correct logger name (`sanic.error`), the appropriate logging level (`logging.ERROR`), and that the log message contains the phrase \"Exception occurred while handling uri:\". This confirms that the logging mechanism is functioning as expected in the context of WebSocket errors.\n\n**Code Being Tested and How It Works**:  \nThe code being tested involves a Sanic application with a WebSocket route defined at `/feed`. Inside the WebSocket handler, an exception is intentionally raised. The test uses the `caplog` fixture to capture log messages generated during the execution of the WebSocket client request. After invoking the WebSocket endpoint, the test iterates through the captured log records to assert that the expected error logging behavior occurred.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the following notable patterns and techniques:\n- **Fixture Usage**: It utilizes the `caplog` fixture from pytest to capture log messages during the test execution, allowing for assertions on the log output.\n- **Context Management**: The `with caplog.at_level(logging.INFO)` context manager is used to set the logging level for the duration of the test, ensuring that only relevant log messages are captured.\n- **Error Handling Simulation**: By raising an exception in the WebSocket handler, the test simulates an error scenario, which is crucial for verifying the logging behavior under failure conditions."
    },
    {
      "name": "test_contextual_exception_context",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions.py",
      "line_number": 280,
      "end_line_number": 317,
      "source_code": "def test_contextual_exception_context(debug):\n    app = Sanic(\"Test\")\n\n    class TeapotError(SanicException):\n        status_code = 418\n        message = \"Sorry, I cannot brew coffee\"\n\n    def fail():\n        raise TeapotError(context={\"foo\": \"bar\"})\n\n    app.post(\"/coffee/json\", error_format=\"json\", name=\"json\")(\n        lambda _: fail()\n    )\n    app.post(\"/coffee/html\", error_format=\"html\", name=\"html\")(\n        lambda _: fail()\n    )\n    app.post(\"/coffee/text\", error_format=\"text\", name=\"text\")(\n        lambda _: fail()\n    )\n\n    _, response = app.test_client.post(\"/coffee/json\", debug=debug)\n    assert response.status == 418\n    assert response.json[\"message\"] == \"Sorry, I cannot brew coffee\"\n    assert response.json[\"context\"] == {\"foo\": \"bar\"}\n\n    _, response = app.test_client.post(\"/coffee/html\", debug=debug)\n    soup = BeautifulSoup(response.body, \"html.parser\")\n    dl = dl_to_dict(soup, \"exception-context\")\n    assert response.status == 418\n    assert \"Sorry, I cannot brew coffee\" in soup.find(\"p\").text\n    assert dl == {\"foo\": \"bar\"}\n\n    _, response = app.test_client.post(\"/coffee/text\", debug=debug)\n    lines = list(map(lambda x: x.decode(), response.body.split(b\"\\n\")))\n    idx = lines.index(\"Context\") + 1\n    assert response.status == 418\n    assert lines[2] == \"Sorry, I cannot brew coffee\"\n    assert lines[idx] == '    foo: \"bar\"'",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('debug', (True, False))"
      ],
      "arguments": [
        "debug"
      ],
      "imports": [
        "logging",
        "itertools.count",
        "pytest",
        "bs4.BeautifulSoup",
        "sanic.Sanic",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ContentRangeError",
        "sanic.exceptions.ExpectationFailed",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.HeaderExpectationFailed",
        "sanic.exceptions.InvalidUsage",
        "sanic.exceptions.MethodNotAllowed",
        "sanic.exceptions.MethodNotSupported",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.RangeNotSatisfiable",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.exceptions.Unauthorized",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 418",
        "assert response.json['message'] == 'Sorry, I cannot brew coffee'",
        "assert response.json['context'] == {'foo': 'bar'}",
        "assert response.status == 418",
        "assert 'Sorry, I cannot brew coffee' in soup.find('p').text",
        "assert dl == {'foo': 'bar'}",
        "assert response.status == 418",
        "assert lines[2] == 'Sorry, I cannot brew coffee'",
        "assert lines[idx] == '    foo: \"bar\"'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "dl_to_dict",
          "body": "def dl_to_dict(soup, dl_id):\n    (keys, values) = ([], [])\n    for dl in soup.find_all('dl', {'id': dl_id}):\n        for dt in dl.find_all('dt'):\n            keys.append(dt.text.split(':', 1)[0])\n        for dd in dl.find_all('dd'):\n            values.append(dd.text.strip())\n    return dict(zip(keys, values))"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "lines.index",
          "body": "@app.route('/', name='hostindex', host='example.com')\n@app.route('/path', name='hostpath', host='path.example.com')\ndef index(request):\n    pass"
        },
        {
          "name": "fail",
          "body": "@app.route('/fail')\ndef fail(request):\n    return text('this should fail')"
        },
        {
          "name": "fail",
          "body": "@app.route('/fail')\ndef fail(request):\n    return text('this should fail')"
        },
        {
          "name": "fail",
          "body": "@app.route('/fail')\ndef fail(request):\n    return text('this should fail')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_contextual_exception_context` test is to verify that the Sanic application correctly handles and formats exceptions raised within its routes, specifically ensuring that contextual information is included in the response for different error formats (JSON, HTML, and plain text).\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a `TeapotError` exception is raised, the application responds with the correct HTTP status code (418) and includes the appropriate error message and context in the response. It verifies that the response format matches the expected structure for JSON, HTML, and text outputs.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the Sanic application setup, where three POST routes (`/coffee/json`, `/coffee/html`, and `/coffee/text`) are defined. Each route invokes a `fail` function that raises a `TeapotError`, which is a custom exception with a status code of 418 and a message. The test then simulates POST requests to these routes using the `app.test_client.post` method and checks the responses for the correct status code, message, and context data.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable techniques:\n- **Parameterized Testing**: The test is designed to run with different `debug` configurations, allowing it to verify behavior under both debug and non-debug modes.\n- **Response Validation**: It asserts the structure and content of the response for different formats, ensuring that the application behaves consistently across various output types.\n- **HTML Parsing**: For the HTML response, it uses BeautifulSoup to parse the response body and extract the relevant information, demonstrating the ability to handle and validate complex response formats.\n- **Contextual Error Handling**: The test specifically checks for contextual information in the error response, showcasing the application's capability to provide detailed error information to the client."
    },
    {
      "name": "test_contextual_exception_extra",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions.py",
      "line_number": 321,
      "end_line_number": 370,
      "source_code": "def test_contextual_exception_extra(debug):\n    app = Sanic(\"Test\")\n\n    class TeapotError(SanicException):\n        status_code = 418\n\n        @property\n        def message(self):\n            return f\"Found {self.extra['foo']}\"\n\n    def fail():\n        raise TeapotError(extra={\"foo\": \"bar\"})\n\n    app.post(\"/coffee/json\", error_format=\"json\", name=\"json\")(\n        lambda _: fail()\n    )\n    app.post(\"/coffee/html\", error_format=\"html\", name=\"html\")(\n        lambda _: fail()\n    )\n    app.post(\"/coffee/text\", error_format=\"text\", name=\"text\")(\n        lambda _: fail()\n    )\n\n    _, response = app.test_client.post(\"/coffee/json\", debug=debug)\n    assert response.status == 418\n    assert response.json[\"message\"] == \"Found bar\"\n    if debug:\n        assert response.json[\"extra\"] == {\"foo\": \"bar\"}\n    else:\n        assert \"extra\" not in response.json\n\n    _, response = app.test_client.post(\"/coffee/html\", debug=debug)\n    soup = BeautifulSoup(response.body, \"html.parser\")\n    dl = dl_to_dict(soup, \"exception-extra\")\n    assert response.status == 418\n    assert \"Found bar\" in soup.find(\"p\").text\n    if debug:\n        assert dl == {\"foo\": \"bar\"}\n    else:\n        assert not dl\n\n    _, response = app.test_client.post(\"/coffee/text\", debug=debug)\n    lines = list(map(lambda x: x.decode(), response.body.split(b\"\\n\")))\n    assert response.status == 418\n    assert lines[2] == \"Found bar\"\n    if debug:\n        idx = lines.index(\"Extra\") + 1\n        assert lines[idx] == '    foo: \"bar\"'\n    else:\n        assert \"Extra\" not in lines",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('debug', (True, False))"
      ],
      "arguments": [
        "debug"
      ],
      "imports": [
        "logging",
        "itertools.count",
        "pytest",
        "bs4.BeautifulSoup",
        "sanic.Sanic",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ContentRangeError",
        "sanic.exceptions.ExpectationFailed",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.HeaderExpectationFailed",
        "sanic.exceptions.InvalidUsage",
        "sanic.exceptions.MethodNotAllowed",
        "sanic.exceptions.MethodNotSupported",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.RangeNotSatisfiable",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.exceptions.Unauthorized",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 418",
        "assert response.json['message'] == 'Found bar'",
        "assert response.status == 418",
        "assert 'Found bar' in soup.find('p').text",
        "assert response.status == 418",
        "assert lines[2] == 'Found bar'",
        "assert response.json['extra'] == {'foo': 'bar'}",
        "assert 'extra' not in response.json",
        "assert dl == {'foo': 'bar'}",
        "assert not dl",
        "assert lines[idx] == '    foo: \"bar\"'",
        "assert 'Extra' not in lines"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "dl_to_dict",
          "body": "def dl_to_dict(soup, dl_id):\n    (keys, values) = ([], [])\n    for dl in soup.find_all('dl', {'id': dl_id}):\n        for dt in dl.find_all('dt'):\n            keys.append(dt.text.split(':', 1)[0])\n        for dd in dl.find_all('dd'):\n            values.append(dd.text.strip())\n    return dict(zip(keys, values))"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "fail",
          "body": "@app.route('/fail')\ndef fail(request):\n    return text('this should fail')"
        },
        {
          "name": "fail",
          "body": "@app.route('/fail')\ndef fail(request):\n    return text('this should fail')"
        },
        {
          "name": "fail",
          "body": "@app.route('/fail')\ndef fail(request):\n    return text('this should fail')"
        },
        {
          "name": "lines.index",
          "body": "@app.route('/', name='hostindex', host='example.com')\n@app.route('/path', name='hostpath', host='path.example.com')\ndef index(request):\n    pass"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_contextual_exception_extra` function is designed to verify the behavior of the Sanic application when a custom exception (`TeapotError`) is raised during request handling. It specifically checks how the application formats and returns error responses in different formats (JSON, HTML, and plain text) based on the error raised.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies that when the `TeapotError` is raised, the application correctly returns a 418 status code along with an appropriate error message. It also checks that additional contextual information (the `extra` dictionary) is included in the response when the application is in debug mode, and that this information is omitted in non-debug mode.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Sanic application with three POST routes (`/coffee/json`, `/coffee/html`, and `/coffee/text`) that all invoke a `fail` function, which raises the `TeapotError`. The test then simulates requests to these routes using the `app.test_client.post` method. The responses are checked for the correct status code, message content, and the presence or absence of extra contextual data based on the `debug` flag.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterized Testing**: The test uses the `debug` parameter to run assertions under different configurations, allowing for comprehensive coverage of both debug and non-debug scenarios.\n- **Response Validation**: The test checks the response status and content in multiple formats (JSON, HTML, text), ensuring that the application behaves correctly across different content types.\n- **Custom Exception Handling**: The test demonstrates how to define and raise custom exceptions in a web application context, and how to handle them gracefully to provide meaningful error messages to the client."
    },
    {
      "name": "test_contextual_exception_functional_message",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions.py",
      "line_number": 374,
      "end_line_number": 395,
      "source_code": "def test_contextual_exception_functional_message(override):\n    app = Sanic(\"Test\")\n\n    class TeapotError(SanicException):\n        status_code = 418\n\n        @property\n        def message(self):\n            return f\"Received foo={self.context['foo']}\"\n\n    @app.post(\"/coffee\", error_format=\"json\")\n    async def make_coffee(_):\n        error_args = {\"context\": {\"foo\": \"bar\"}}\n        if override:\n            error_args[\"message\"] = \"override\"\n        raise TeapotError(**error_args)\n\n    _, response = app.test_client.post(\"/coffee\", debug=True)\n    error_message = \"override\" if override else \"Received foo=bar\"\n    assert response.status == 418\n    assert response.json[\"message\"] == error_message\n    assert response.json[\"context\"] == {\"foo\": \"bar\"}",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('override', (True, False))"
      ],
      "arguments": [
        "override"
      ],
      "imports": [
        "logging",
        "itertools.count",
        "pytest",
        "bs4.BeautifulSoup",
        "sanic.Sanic",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ContentRangeError",
        "sanic.exceptions.ExpectationFailed",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.HeaderExpectationFailed",
        "sanic.exceptions.InvalidUsage",
        "sanic.exceptions.MethodNotAllowed",
        "sanic.exceptions.MethodNotSupported",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.RangeNotSatisfiable",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.exceptions.Unauthorized",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 418",
        "assert response.json['message'] == error_message",
        "assert response.json['context'] == {'foo': 'bar'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_contextual_exception_functional_message` test is to verify that the Sanic application correctly handles exceptions raised within a route handler, specifically ensuring that the error response includes the appropriate status code, message, and context information.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a `TeapotError` exception is raised, the application responds with a 418 status code (indicating \"I'm a teapot\"), and that the response message and context are correctly formatted based on whether an override condition is applied.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a Sanic application with a POST route at `/coffee`. When this route is accessed, it raises a `TeapotError` with a context containing a key-value pair (`{\"foo\": \"bar\"}`). The `TeapotError` class has a custom message property that formats the message based on the context. The test simulates a POST request to this route and checks the response for the correct status code, message, and context.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs parameterization (via the `override` argument) to test different scenarios (with and without message overriding). It also uses assertions to validate the response's status and JSON content, ensuring that the application behaves as expected under different conditions. The use of a custom exception class (`TeapotError`) demonstrates how to encapsulate error handling logic within the application."
    },
    {
      "name": "test_exception_aliases",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions.py",
      "line_number": 398,
      "end_line_number": 402,
      "source_code": "def test_exception_aliases():\n    assert InvalidUsage is BadRequest\n    assert MethodNotSupported is MethodNotAllowed\n    assert ContentRangeError is RangeNotSatisfiable\n    assert HeaderExpectationFailed is ExpectationFailed",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "itertools.count",
        "pytest",
        "bs4.BeautifulSoup",
        "sanic.Sanic",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ContentRangeError",
        "sanic.exceptions.ExpectationFailed",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.HeaderExpectationFailed",
        "sanic.exceptions.InvalidUsage",
        "sanic.exceptions.MethodNotAllowed",
        "sanic.exceptions.MethodNotSupported",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.RangeNotSatisfiable",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.exceptions.Unauthorized",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert InvalidUsage is BadRequest",
        "assert MethodNotSupported is MethodNotAllowed",
        "assert ContentRangeError is RangeNotSatisfiable",
        "assert HeaderExpectationFailed is ExpectationFailed"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_exception_aliases` function verifies that certain exception classes in the Sanic framework are correctly aliased to one another. This ensures that the framework maintains consistent behavior and that developers can use these exceptions interchangeably without unexpected issues.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that specific exception classes are equivalent, meaning they should behave the same way in the context of the application. For instance, `InvalidUsage` is expected to be the same as `BadRequest`, indicating that both should trigger the same response when raised.\n\n**Code Being Tested and How It Works**:  \nThe test does not directly invoke any methods or functions from the codebase; instead, it uses assertions to compare the identities of the exception classes. The `is` operator checks if the two exceptions refer to the same object in memory, confirming that they are indeed aliases.\n\n**Notable Testing Patterns or Techniques Used**:  \nThis test employs a straightforward assertion pattern, focusing on identity checks rather than functional behavior. It uses the `assert` statement to validate conditions, which is a common practice in unit testing to ensure that expected outcomes are met. The simplicity of the test reflects a common pattern in verifying constants or configurations within a codebase."
    },
    {
      "name": "test_exception_message_attribute",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions.py",
      "line_number": 405,
      "end_line_number": 417,
      "source_code": "def test_exception_message_attribute():\n    assert ServerError(\"it failed\").message == \"it failed\"\n    assert ServerError(b\"it failed\").message == \"it failed\"\n    assert (\n        ServerError().message == str(ServerError()) == \"Internal Server Error\"\n    )\n\n    class CustomError(SanicException):\n        message = \"Something bad happened\"\n\n    assert CustomError().message == CustomError.message == str(CustomError())\n    assert SanicException().message != \"\"\n    assert SanicException(\"\").message == \"\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "itertools.count",
        "pytest",
        "bs4.BeautifulSoup",
        "sanic.Sanic",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ContentRangeError",
        "sanic.exceptions.ExpectationFailed",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.HeaderExpectationFailed",
        "sanic.exceptions.InvalidUsage",
        "sanic.exceptions.MethodNotAllowed",
        "sanic.exceptions.MethodNotSupported",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.RangeNotSatisfiable",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.exceptions.Unauthorized",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert ServerError('it failed').message == 'it failed'",
        "assert ServerError(b'it failed').message == 'it failed'",
        "assert ServerError().message == str(ServerError()) == 'Internal Server Error'",
        "assert CustomError().message == CustomError.message == str(CustomError())",
        "assert SanicException().message != ''",
        "assert SanicException('').message == ''"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_exception_message_attribute` unit test is designed to verify the behavior and correctness of the `message` attribute in various exception classes within the Sanic framework. It ensures that the exceptions return the expected messages when instantiated with different inputs.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. The `ServerError` exception correctly returns the message passed during instantiation, whether it's a string or bytes.\n2. The default message for an uninitialized `ServerError` is \"Internal Server Error\".\n3. A custom exception (`CustomError`) derived from `SanicException` returns its predefined message.\n4. The `SanicException` behaves correctly when instantiated with and without a message.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the following classes:\n- `ServerError`: A specific exception that inherits from `SanicException`. It is expected to return a custom message if provided, or a default message otherwise.\n- `CustomError`: A user-defined exception that overrides the `message` attribute to return a specific string.\n- `SanicException`: The base class for exceptions in Sanic, which handles messages and other attributes.\n\nThe assertions in the test confirm that the `message` attribute behaves as expected for each of these classes, ensuring that the correct messages are returned based on the input provided during instantiation.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Direct Assertions**: The test uses direct assertions to validate the expected outcomes, which is a straightforward approach to unit testing.\n- **Class Inheritance**: The test demonstrates the use of class inheritance by creating a custom exception (`CustomError`) to verify that inherited attributes work as intended.\n- **Multiple Input Types**: The test checks the handling of different input types (string and bytes) for the `ServerError`, showcasing robustness in handling various data types.\n- **Default Behavior Verification**: It verifies the default behavior of exceptions when no message is provided, ensuring that the framework adheres to expected standards for error handling."
    },
    {
      "name": "test_request_middleware_exception_on_404",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions.py",
      "line_number": 420,
      "end_line_number": 435,
      "source_code": "def test_request_middleware_exception_on_404(app: Sanic):\n    \"\"\"See https://github.com/sanic-org/sanic/issues/2950\"\"\"\n    counter = count()\n\n    @app.on_request\n    def request_middleware(request):\n        next(counter)\n        raise Exception\n\n    @app.route(\"/\")\n    async def handler(request): ...\n\n    _, response = app.test_client.get(\"/not-found\")\n\n    assert response.status == 500\n    assert next(counter) == 1",
      "docstring": "See https://github.com/sanic-org/sanic/issues/2950",
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "itertools.count",
        "pytest",
        "bs4.BeautifulSoup",
        "sanic.Sanic",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ContentRangeError",
        "sanic.exceptions.ExpectationFailed",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.HeaderExpectationFailed",
        "sanic.exceptions.InvalidUsage",
        "sanic.exceptions.MethodNotAllowed",
        "sanic.exceptions.MethodNotSupported",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.RangeNotSatisfiable",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.exceptions.Unauthorized",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert next(counter) == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_request_middleware_exception_on_404` test is to verify that when an exception is raised in the request middleware of a Sanic application, the server responds with a 500 Internal Server Error status code, even when the requested route does not exist (404 Not Found).\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the middleware correctly handles exceptions by ensuring that the response status is 500 and that the middleware was invoked exactly once (indicating that the exception was raised during the request processing).\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Sanic application with a request middleware that raises an exception whenever a request is received. It then makes a GET request to a non-existent route (\"/not-found\"). The middleware is expected to increment a counter and raise an exception, which should lead to a 500 status code in the response. The assertions confirm that the response status is indeed 500 and that the counter reflects that the middleware was executed once.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Middleware Testing**: The test effectively demonstrates how to test middleware behavior by simulating an exception scenario.\n- **Counter for Invocation Tracking**: The use of a counter to track how many times the middleware was invoked is a useful technique for verifying that the middleware logic is executed as expected.\n- **Integration Testing**: This test integrates multiple components (middleware and routing) to ensure they work together correctly under exceptional conditions."
    },
    {
      "name": "test_log",
      "module": "test_logging",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_logging.py",
      "line_number": 36,
      "end_line_number": 54,
      "source_code": "def test_log(app):\n    log_stream = StringIO()\n    for handler in logging.root.handlers[:]:\n        logging.root.removeHandler(handler)\n    logging.basicConfig(\n        format=logging_format, level=logging.DEBUG, stream=log_stream\n    )\n    logging.getLogger(\"asyncio\").setLevel(logging.WARNING)\n    log = logging.getLogger()\n    rand_string = str(uuid.uuid4())\n\n    @app.route(\"/\")\n    def handler(request):\n        log.info(rand_string)\n        return text(\"hello\")\n\n    request, response = app.test_client.get(\"/\")\n    log_text = log_stream.getvalue()\n    assert rand_string in log_text",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "sys",
        "uuid",
        "importlib.reload",
        "io.StringIO",
        "unittest.mock.ANY",
        "unittest.mock.Mock",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.log.Colors",
        "sanic.log.logger",
        "sanic.logging.formatter.AutoFormatter",
        "sanic.logging.formatter.DebugAccessFormatter",
        "sanic.logging.formatter.DebugFormatter",
        "sanic.logging.formatter.ProdAccessFormatter",
        "sanic.logging.formatter.ProdFormatter",
        "sanic.logging.setup.setup_logging",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert rand_string in log_text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_log` function is to verify that the logging mechanism in the Sanic application correctly captures log messages generated during a request. Specifically, it checks that a randomly generated string is logged when a specific route is accessed.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the logging configuration is set up correctly and that log messages are emitted as expected when the application handles a request. It verifies that the log output contains the expected log message, which is crucial for debugging and monitoring the application.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Sanic application with a single route (`\"/\"`) that logs a randomly generated UUID string when accessed. The logging configuration is modified to direct log output to a `StringIO` stream instead of the default console. After making a GET request to the route, the test retrieves the log output from the `StringIO` stream and asserts that the UUID string is present in the log text, confirming that the logging functionality is working as intended.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Isolation of Logging**: The test removes existing logging handlers and sets up a new logging configuration to isolate the test's logging output, ensuring that it does not interfere with other tests.\n- **Use of `StringIO`**: This technique captures log output in memory, allowing for easy verification of log messages without writing to files or the console.\n- **UUID Generation**: The use of `uuid.uuid4()` ensures that the log message is unique for each test run, preventing false positives in the assertion.\n- **Direct Assertion**: The test directly asserts the presence of the expected log message in the captured log output, providing a clear and straightforward verification of functionality."
    },
    {
      "name": "test_logging_defaults",
      "module": "test_logging",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_logging.py",
      "line_number": 58,
      "end_line_number": 81,
      "source_code": "def test_logging_defaults(debug):\n    AutoFormatter.ATTY = False\n    AutoFormatter.SETUP = False\n    Sanic(\"test_logging\")\n    setup_logging(debug)\n    std_formatter = (DebugFormatter if debug else ProdFormatter)()\n    access_formatter = (\n        DebugAccessFormatter if debug else ProdAccessFormatter\n    )()\n\n    for logger_name, formatter in [\n        (\"sanic.root\", std_formatter),\n        (\"sanic.error\", std_formatter),\n        (\"sanic.access\", access_formatter),\n        (\"sanic.server\", std_formatter),\n        (\"sanic.websockets\", std_formatter),\n    ]:\n        print(\"....\", logger_name)\n        for fmt in [\n            h.formatter for h in logging.getLogger(logger_name).handlers\n        ]:\n            print(f\"{logger_name} logger_formatter: \", fmt._fmt)\n            print(f\"{logger_name}        formatter: \", formatter._fmt)\n            assert fmt._fmt == formatter._fmt",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('debug', (True, False))"
      ],
      "arguments": [
        "debug"
      ],
      "imports": [
        "logging",
        "sys",
        "uuid",
        "importlib.reload",
        "io.StringIO",
        "unittest.mock.ANY",
        "unittest.mock.Mock",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.log.Colors",
        "sanic.log.logger",
        "sanic.logging.formatter.AutoFormatter",
        "sanic.logging.formatter.DebugAccessFormatter",
        "sanic.logging.formatter.DebugFormatter",
        "sanic.logging.formatter.ProdAccessFormatter",
        "sanic.logging.formatter.ProdFormatter",
        "sanic.logging.setup.setup_logging",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert fmt._fmt == formatter._fmt"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_logging_defaults` function is designed to verify that the logging formatters for various Sanic loggers are correctly set up based on the application's debug mode. It ensures that the appropriate formatter (either `DebugFormatter` or `ProdFormatter`) is applied to the loggers depending on whether the application is running in debug mode.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the format of the log messages produced by the Sanic application matches the expected format defined by the chosen formatter. It asserts that each logger's formatter is correctly configured to either the standard or access formatter based on the `debug` argument.\n\n**Code Being Tested and How It Works**:  \nThe test initializes a Sanic application and calls the `setup_logging` function with the `debug` parameter. It then creates instances of the appropriate formatters (`std_formatter` and `access_formatter`) based on the debug state. The test iterates over a predefined list of logger names and their expected formatters, retrieving the actual formatter from each logger's handlers and comparing its format string (`_fmt`) to the expected format string. If they do not match, the test will fail.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterized Testing**: The test uses the `debug` parameter to switch between different formatter types, allowing for a clear distinction between debug and production logging formats.\n- **Assertions**: The test employs assertions to validate that the actual formatter's format matches the expected format, which is a common practice in unit testing to ensure correctness.\n- **Logger Inspection**: The test inspects the logging configuration by accessing the logger's handlers, demonstrating a technique for verifying internal state and behavior of logging components."
    },
    {
      "name": "test_logging_pass_customer_logconfig",
      "module": "test_logging",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_logging.py",
      "line_number": 84,
      "end_line_number": 108,
      "source_code": "def test_logging_pass_customer_logconfig():\n    # reset_logging()\n\n    modified_config = LOGGING_CONFIG_DEFAULTS\n    modified_config[\"formatters\"][\"generic\"][\"format\"] = (\n        \"%(asctime)s - (%(name)s)[%(levelname)s]: %(message)s\"\n    )\n    modified_config[\"formatters\"][\"access\"][\"format\"] = (\n        \"%(asctime)s - (%(name)s)[%(levelname)s]: %(message)s\"\n    )\n\n    Sanic(\"test_logging\", log_config=modified_config)\n\n    for fmt in [h.formatter for h in logging.getLogger(\"sanic.root\").handlers]:\n        assert fmt._fmt == modified_config[\"formatters\"][\"generic\"][\"format\"]\n\n    for fmt in [\n        h.formatter for h in logging.getLogger(\"sanic.error\").handlers\n    ]:\n        assert fmt._fmt == modified_config[\"formatters\"][\"generic\"][\"format\"]\n\n    for fmt in [\n        h.formatter for h in logging.getLogger(\"sanic.access\").handlers\n    ]:\n        assert fmt._fmt == modified_config[\"formatters\"][\"access\"][\"format\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "sys",
        "uuid",
        "importlib.reload",
        "io.StringIO",
        "unittest.mock.ANY",
        "unittest.mock.Mock",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.log.Colors",
        "sanic.log.logger",
        "sanic.logging.formatter.AutoFormatter",
        "sanic.logging.formatter.DebugAccessFormatter",
        "sanic.logging.formatter.DebugFormatter",
        "sanic.logging.formatter.ProdAccessFormatter",
        "sanic.logging.formatter.ProdFormatter",
        "sanic.logging.setup.setup_logging",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert fmt._fmt == modified_config['formatters']['generic']['format']",
        "assert fmt._fmt == modified_config['formatters']['generic']['format']",
        "assert fmt._fmt == modified_config['formatters']['access']['format']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_logging_pass_customer_logconfig` test is to verify that the logging configuration for the Sanic application can be successfully modified and that the log formatters are set correctly according to the provided custom configuration.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the log format for the root logger and the access logger matches the expected format defined in the modified logging configuration. It ensures that the application correctly applies the custom log format settings when instantiated with a specific logging configuration.\n\n**Code Being Tested and How It Works**:  \nThe test modifies the default logging configuration (`LOGGING_CONFIG_DEFAULTS`) by changing the format for both the generic and access formatters. It then creates a new Sanic application instance with this modified configuration. The test subsequently retrieves the formatters from the loggers (`sanic.root`, `sanic.error`, and `sanic.access`) and asserts that their formats match the expected values defined in `modified_config`. This ensures that the logging system is correctly configured to use the specified formats.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Direct Assertions**: The test uses direct assertions to compare the actual formatter formats against the expected formats, which is a straightforward and effective way to validate behavior.\n- **Configuration Testing**: The test exemplifies configuration testing by modifying and verifying the behavior of the logging system based on different configurations.\n- **Isolation of Tests**: Although the `reset_logging()` function is commented out, it suggests an intention to isolate the test environment, ensuring that previous tests do not affect the logging configuration during this test's execution. This is a common practice in unit testing to maintain test independence."
    },
    {
      "name": "test_logging_modified_root_logger_config",
      "module": "test_logging",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_logging.py",
      "line_number": 129,
      "end_line_number": 137,
      "source_code": "def test_logging_modified_root_logger_config():\n    # reset_logging()\n\n    modified_config = LOGGING_CONFIG_DEFAULTS\n    modified_config[\"loggers\"][\"sanic.root\"][\"level\"] = \"DEBUG\"\n\n    Sanic(\"test_logging\", log_config=modified_config)\n\n    assert logging.getLogger(\"sanic.root\").getEffectiveLevel() == logging.DEBUG",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "sys",
        "uuid",
        "importlib.reload",
        "io.StringIO",
        "unittest.mock.ANY",
        "unittest.mock.Mock",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.log.Colors",
        "sanic.log.logger",
        "sanic.logging.formatter.AutoFormatter",
        "sanic.logging.formatter.DebugAccessFormatter",
        "sanic.logging.formatter.DebugFormatter",
        "sanic.logging.formatter.ProdAccessFormatter",
        "sanic.logging.formatter.ProdFormatter",
        "sanic.logging.setup.setup_logging",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert logging.getLogger('sanic.root').getEffectiveLevel() == logging.DEBUG"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_logging_modified_root_logger_config` test is to verify that the logging configuration for the `sanic.root` logger can be successfully modified and that the logger's effective logging level is set to `DEBUG` as intended.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a modified logging configuration is applied to the Sanic application, the effective logging level of the `sanic.root` logger reflects this change. It asserts that the logger's level is set to `DEBUG`, which is crucial for ensuring that debug-level logs are captured and displayed.\n\n**Code Being Tested and How It Works**:  \nThe code being tested involves the initialization of a Sanic application with a custom logging configuration. The test modifies the default logging configuration (`LOGGING_CONFIG_DEFAULTS`) by setting the `level` of the `sanic.root` logger to `DEBUG`. After creating the Sanic application with this modified configuration, the test retrieves the effective logging level of the `sanic.root` logger using `logging.getLogger(\"sanic.root\").getEffectiveLevel()` and asserts that it equals `logging.DEBUG`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern to validate the logger's configuration. It uses the `assert` statement to compare the expected value (`logging.DEBUG`) with the actual value obtained from the logger. This direct approach is effective for unit tests, as it clearly indicates whether the specific behavior (logger level configuration) is functioning as expected. Additionally, the test is designed to be isolated, focusing solely on the logging configuration without dependencies on other parts of the application, which is a common best practice in unit testing."
    },
    {
      "name": "test_access_log_client_ip_remote_addr",
      "module": "test_logging",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_logging.py",
      "line_number": 140,
      "end_line_number": 166,
      "source_code": "def test_access_log_client_ip_remote_addr(monkeypatch):\n    access = Mock()\n    monkeypatch.setattr(sanic.http.http1, \"access_logger\", access)\n\n    app = Sanic(\"test_logging\")\n    app.config.ACCESS_LOG = True\n    app.config.PROXIES_COUNT = 2\n\n    @app.route(\"/\")\n    async def handler(request):\n        return text(request.remote_addr)\n\n    headers = {\"X-Forwarded-For\": \"1.1.1.1, 2.2.2.2\"}\n\n    request, response = app.test_client.get(\"/\", headers=headers)\n\n    assert request.remote_addr == \"1.1.1.1\"\n    access.info.assert_called_with(\n        \"\",\n        extra={\n            \"status\": 200,\n            \"byte\": len(response.content),\n            \"host\": f\"{request.remote_addr}:{request.port}\",\n            \"request\": f\"GET {request.scheme}://{request.host}/\",\n            \"duration\": ANY,\n        },\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "logging",
        "sys",
        "uuid",
        "importlib.reload",
        "io.StringIO",
        "unittest.mock.ANY",
        "unittest.mock.Mock",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.log.Colors",
        "sanic.log.logger",
        "sanic.logging.formatter.AutoFormatter",
        "sanic.logging.formatter.DebugAccessFormatter",
        "sanic.logging.formatter.DebugFormatter",
        "sanic.logging.formatter.ProdAccessFormatter",
        "sanic.logging.formatter.ProdFormatter",
        "sanic.logging.setup.setup_logging",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.remote_addr == '1.1.1.1'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_access_log_client_ip_remote_addr` test is to verify that the Sanic application correctly logs the client's IP address when the request is forwarded through proxies. It ensures that the application extracts the correct IP address from the `X-Forwarded-For` header and that the access logger is called with the expected parameters.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `request.remote_addr` is set to the first IP address in the `X-Forwarded-For` header (in this case, \"1.1.1.1\"). It also verifies that the access logger records the correct information, including the status code, response size, host, request method, and duration of the request.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the Sanic application setup, route definition, and the handling of incoming requests. The `app.test_client.get` method simulates a GET request to the root endpoint (\"/\") with custom headers. The handler function returns the `request.remote_addr`, which should reflect the first IP in the `X-Forwarded-For` header due to the configuration of `PROXIES_COUNT`. The access logger is mocked to verify that it is called with the expected parameters after the request is processed.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Monkeypatching**: The test uses `monkeypatch` to replace the actual access logger with a mock object, allowing the test to verify that logging occurs without relying on the real logging implementation.\n- **Mocking**: The `Mock` class is used to create a mock access logger, enabling assertions on how it was called.\n- **Assertions**: The test employs assertions to check both the value of `request.remote_addr` and the parameters passed to the access logger, ensuring that both the application logic and logging behavior are correct.\n- **Header Manipulation**: The test demonstrates how to manipulate HTTP headers to simulate real-world scenarios involving proxies and forwarded requests."
    },
    {
      "name": "test_access_log_client_ip_reqip",
      "module": "test_logging",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_logging.py",
      "line_number": 169,
      "end_line_number": 191,
      "source_code": "def test_access_log_client_ip_reqip(monkeypatch):\n    access = Mock()\n    monkeypatch.setattr(sanic.http.http1, \"access_logger\", access)\n\n    app = Sanic(\"test_logging\")\n    app.config.ACCESS_LOG = True\n\n    @app.route(\"/\")\n    async def handler(request):\n        return text(request.ip)\n\n    request, response = app.test_client.get(\"/\")\n\n    access.info.assert_called_with(\n        \"\",\n        extra={\n            \"status\": 200,\n            \"byte\": len(response.content),\n            \"host\": f\"{request.ip}:{request.port}\",\n            \"request\": f\"GET {request.scheme}://{request.host}/\",\n            \"duration\": ANY,\n        },\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "logging",
        "sys",
        "uuid",
        "importlib.reload",
        "io.StringIO",
        "unittest.mock.ANY",
        "unittest.mock.Mock",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.log.Colors",
        "sanic.log.logger",
        "sanic.logging.formatter.AutoFormatter",
        "sanic.logging.formatter.DebugAccessFormatter",
        "sanic.logging.formatter.DebugFormatter",
        "sanic.logging.formatter.ProdAccessFormatter",
        "sanic.logging.formatter.ProdFormatter",
        "sanic.logging.setup.setup_logging",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_access_log_client_ip_reqip` test is to verify that the Sanic application correctly logs access information, specifically the client's IP address, when a request is made to the server. This ensures that the logging mechanism captures the expected details about the request.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a GET request is made to the root endpoint (\"/\"), the access logger is called with the correct parameters, including the client's IP address, response status, response size, request method, and duration of the request. It ensures that the logging behavior is consistent with the application's configuration for access logging.\n\n**Code Being Tested and How It Works**:  \nThe code being tested involves the Sanic application setup and the route handler. The test creates a mock access logger and sets it in place of the actual logger using `monkeypatch`. It then defines a route that returns the client's IP address. When a GET request is made to this route, the test checks that the mock logger's `info` method is called with the expected parameters, which include the request's IP address and other relevant details. The `request.ip` is expected to reflect the client's IP address as captured by the Sanic framework.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `monkeypatch` technique to replace the access logger with a mock object, allowing for verification of logging behavior without relying on the actual logging implementation. It also uses assertions to confirm that the logger was called with the correct parameters, leveraging the `assert_called_with` method from the `unittest.mock` library. This pattern is common in unit tests to isolate the unit of work and verify interactions with dependencies. Additionally, the use of `ANY` in the assertions allows for flexibility in matching the duration value, which is expected to vary with each request."
    },
    {
      "name": "test_verbosity",
      "module": "test_logging",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_logging.py",
      "line_number": 208,
      "end_line_number": 230,
      "source_code": "def test_verbosity(app, caplog, app_verbosity, log_verbosity, exists):\n    rand_string = str(uuid.uuid4())\n\n    @app.get(\"/\")\n    def log_info(request):\n        logger.info(\"DEFAULT\")\n        logger.info(rand_string, extra={\"verbosity\": log_verbosity})\n        return text(\"hello\")\n\n    with caplog.at_level(logging.INFO):\n        _ = app.test_client.get(\n            \"/\", server_kwargs={\"verbosity\": app_verbosity}\n        )\n\n    record = (\"sanic.root\", logging.INFO, rand_string)\n\n    if exists:\n        assert record in caplog.record_tuples\n    else:\n        assert record not in caplog.record_tuples\n\n    if app_verbosity == 0:\n        assert (\"sanic.root\", logging.INFO, \"DEFAULT\") in caplog.record_tuples",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('app_verbosity,log_verbosity,exists', ((0, 0, True), (0, 1, False), (0, 2, False), (1, 0, True), (1, 1, True), (1, 2, False), (2, 0, True), (2, 1, True), (2, 2, True)))"
      ],
      "arguments": [
        "app",
        "caplog",
        "app_verbosity",
        "log_verbosity",
        "exists"
      ],
      "imports": [
        "logging",
        "sys",
        "uuid",
        "importlib.reload",
        "io.StringIO",
        "unittest.mock.ANY",
        "unittest.mock.Mock",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.log.Colors",
        "sanic.log.logger",
        "sanic.logging.formatter.AutoFormatter",
        "sanic.logging.formatter.DebugAccessFormatter",
        "sanic.logging.formatter.DebugFormatter",
        "sanic.logging.formatter.ProdAccessFormatter",
        "sanic.logging.formatter.ProdFormatter",
        "sanic.logging.setup.setup_logging",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert record in caplog.record_tuples",
        "assert record not in caplog.record_tuples",
        "assert ('sanic.root', logging.INFO, 'DEFAULT') in caplog.record_tuples"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_verbosity` function is designed to verify the logging behavior of a Sanic application based on different verbosity levels. It checks whether specific log messages are recorded when the application is accessed, depending on the configured verbosity settings.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies that:\n1. A unique log message (generated by `rand_string`) is recorded when the log verbosity is set appropriately.\n2. The default log message (\"DEFAULT\") is recorded only when the application verbosity is set to 0.\n3. The presence or absence of log records is contingent on the `exists` parameter, which indicates whether the specific log message should be found in the captured logs.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Sanic application with a single route (`\"/\"`) that logs two messages when accessed. The first message is a static string (\"DEFAULT\"), and the second is a dynamic string (`rand_string`) that includes additional verbosity information. The test client simulates a GET request to this route, and the logging output is captured using the `caplog` fixture. The assertions check if the expected log records are present in the captured logs based on the verbosity settings.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses parameters (`app_verbosity`, `log_verbosity`, `exists`) to cover multiple scenarios, allowing for a comprehensive check of different verbosity configurations.\n- **Context Management**: The `with caplog.at_level(logging.INFO)` context manager is used to temporarily set the logging level, ensuring that only relevant log messages are captured during the test.\n- **Assertions**: The test employs assertions to validate the presence or absence of specific log records, which is a common practice in unit testing to ensure expected outcomes."
    },
    {
      "name": "test_colors_enum_format",
      "module": "test_logging",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_logging.py",
      "line_number": 233,
      "end_line_number": 241,
      "source_code": "def test_colors_enum_format():\n    assert f\"{Colors.END}\" == Colors.END.value\n    assert f\"{Colors.BOLD}\" == Colors.BOLD.value\n    assert f\"{Colors.BLUE}\" == Colors.BLUE.value\n    assert f\"{Colors.GREEN}\" == Colors.GREEN.value\n    assert f\"{Colors.PURPLE}\" == Colors.PURPLE.value\n    assert f\"{Colors.RED}\" == Colors.RED.value\n    assert f\"{Colors.SANIC}\" == Colors.SANIC.value\n    assert f\"{Colors.YELLOW}\" == Colors.YELLOW.value",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "sys",
        "uuid",
        "importlib.reload",
        "io.StringIO",
        "unittest.mock.ANY",
        "unittest.mock.Mock",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.log.Colors",
        "sanic.log.logger",
        "sanic.logging.formatter.AutoFormatter",
        "sanic.logging.formatter.DebugAccessFormatter",
        "sanic.logging.formatter.DebugFormatter",
        "sanic.logging.formatter.ProdAccessFormatter",
        "sanic.logging.formatter.ProdFormatter",
        "sanic.logging.setup.setup_logging",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert f'{Colors.END}' == Colors.END.value",
        "assert f'{Colors.BOLD}' == Colors.BOLD.value",
        "assert f'{Colors.BLUE}' == Colors.BLUE.value",
        "assert f'{Colors.GREEN}' == Colors.GREEN.value",
        "assert f'{Colors.PURPLE}' == Colors.PURPLE.value",
        "assert f'{Colors.RED}' == Colors.RED.value",
        "assert f'{Colors.SANIC}' == Colors.SANIC.value",
        "assert f'{Colors.YELLOW}' == Colors.YELLOW.value"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_colors_enum_format` unit test is designed to verify that the string representation of each member of the `Colors` enumeration correctly matches its associated value. This ensures that the formatting of color codes for logging messages is consistent and accurate.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when each `Colors` enum member is converted to a string (using an f-string), it produces the expected ANSI escape code for that color. This is crucial for ensuring that log messages are displayed in the intended colors when output to a terminal that supports ANSI color codes.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `Colors` enum, which defines various color codes as string values. Each member of the `Colors` enum (e.g., `Colors.RED`, `Colors.GREEN`) is expected to return a specific ANSI escape sequence when formatted as a string. The test asserts that the formatted string representation of each color matches the value defined in the enum, ensuring that the color codes are correctly implemented.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs straightforward assertions to compare the formatted string output with the expected values. It uses a series of assert statements to validate each color individually, which is a common pattern in unit testing to ensure that each aspect of the functionality is tested in isolation. The test is simple and direct, focusing solely on the correctness of the enum's string representation without any dependencies on external systems or complex setups."
    },
    {
      "name": "test_debug_formatter_formatException",
      "module": "test_logging",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_logging.py",
      "line_number": 254,
      "end_line_number": 286,
      "source_code": "def test_debug_formatter_formatException(atty, no_color, expected):\n    formatter = DebugFormatter()\n    formatter.ATTY = atty\n    formatter.NO_COLOR = no_color\n\n    try:\n        1 / 0\n    except Exception as e:\n        exc_info = (type(e), e, e.__traceback__)\n\n    output = formatter.formatException(exc_info)\n    lines = output.splitlines()\n\n    assert len(lines) == 5 if sys.version_info >= (3, 11) else 4\n    assert (\"\\033\" in output) is expected\n    assert (\"\\033[36m\\033[1m\" in lines[1]) is expected\n    assert (\n        lines[1].endswith(\n            \"\\033[34m\\033[1mtest_debug_formatter_formatException\\033[0m\"\n        )\n        is expected\n    )\n    assert (\n        lines[1].endswith(\"test_debug_formatter_formatException\")\n        is not expected\n    )\n    assert (lines[2] == \"\\033[33m    1 / 0\\033[0m\") is expected\n    assert (lines[2] == \"    1 / 0\") is not expected\n    assert (\n        lines[-1] == \"\\033[38;2;255;13;104m\\033[1mZeroDivisionError\\033[0m: \"\n        \"\\033[1mdivision by zero\\033[0m\"\n    ) is expected\n    assert (lines[-1] == \"ZeroDivisionError: division by zero\") is not expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('atty,no_color,expected', [(True, False, True), (False, False, False), (True, True, False), (False, True, False)])",
        "pytest.mark.xfail(reason='Runs on local but fails on CI, not highly critical')"
      ],
      "arguments": [
        "atty",
        "no_color",
        "expected"
      ],
      "imports": [
        "logging",
        "sys",
        "uuid",
        "importlib.reload",
        "io.StringIO",
        "unittest.mock.ANY",
        "unittest.mock.Mock",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.log.Colors",
        "sanic.log.logger",
        "sanic.logging.formatter.AutoFormatter",
        "sanic.logging.formatter.DebugAccessFormatter",
        "sanic.logging.formatter.DebugFormatter",
        "sanic.logging.formatter.ProdAccessFormatter",
        "sanic.logging.formatter.ProdFormatter",
        "sanic.logging.setup.setup_logging",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(lines) == 5 if sys.version_info >= (3, 11) else 4",
        "assert ('\\x1b' in output) is expected",
        "assert ('\\x1b[36m\\x1b[1m' in lines[1]) is expected",
        "assert lines[1].endswith('\\x1b[34m\\x1b[1mtest_debug_formatter_formatException\\x1b[0m') is expected",
        "assert lines[1].endswith('test_debug_formatter_formatException') is not expected",
        "assert (lines[2] == '\\x1b[33m    1 / 0\\x1b[0m') is expected",
        "assert (lines[2] == '    1 / 0') is not expected",
        "assert (lines[-1] == '\\x1b[38;2;255;13;104m\\x1b[1mZeroDivisionError\\x1b[0m: \\x1b[1mdivision by zero\\x1b[0m') is expected",
        "assert (lines[-1] == 'ZeroDivisionError: division by zero') is not expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_debug_formatter_formatException` unit test is designed to verify the behavior of the `DebugFormatter` class's `formatException` method when formatting exception tracebacks. It specifically checks how the output is colored and structured based on the presence of a TTY (terminal) and whether color output is enabled.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the formatted output of an exception (in this case, a `ZeroDivisionError`) contains the expected number of lines and that specific lines include the correct ANSI color codes. It also verifies that the output differs when color is enabled versus when it is not, ensuring that the formatter behaves correctly under different configurations.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `formatException` method of the `DebugFormatter` class, which inherits from `AutoFormatter`. This method takes an exception's information (type, value, and traceback) and formats it into a human-readable string, applying color codes if the output is directed to a TTY and color is not disabled. The method processes the traceback lines, applying different color formatting based on the line type (file lines, code lines, and exception lines).\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable techniques:\n- **Parameterized Testing**: The test uses parameters (`atty`, `no_color`, `expected`) to cover different scenarios for the formatter's behavior, allowing for comprehensive coverage of the method's functionality.\n- **Assertions**: Multiple assertions are used to validate the output, including checks for line counts, specific content, and the presence of ANSI escape sequences, ensuring that the output meets the expected format.\n- **Exception Handling**: The test intentionally raises a `ZeroDivisionError` to simulate an error scenario, allowing the formatter to be tested in a realistic context."
    },
    {
      "name": "test_server_run",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cli.py",
      "line_number": 62,
      "end_line_number": 70,
      "source_code": "def test_server_run(\n    appname: str, extra: Optional[str], caplog: pytest.LogCaptureFixture, port\n):\n    command = [appname, f\"-p={port}\"]\n    if extra:\n        command.append(extra)\n    lines = capture(command, caplog)\n\n    assert f\"Goin' Fast @ http://127.0.0.1:{port}\" in lines",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('appname,extra', (('fake.server.app', None), ('fake.server', None), ('fake.server:create_app', '--factory'), ('fake.server.create_app()', None), ('fake.server.create_app', None)))"
      ],
      "arguments": [
        "appname",
        "extra",
        "caplog",
        "port"
      ],
      "imports": [
        "json",
        "os",
        "sys",
        "pathlib.Path",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock.patch",
        "pytest",
        "sanic_routing.__version__",
        "sanic.__version__",
        "sanic.__main__.main",
        "sanic.cli.inspector_client.InspectorClient",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert f\"Goin' Fast @ http://127.0.0.1:{port}\" in lines"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "capture",
          "body": "def capture(command: List[str], caplog=None, capsys=None):\n    if capsys:\n        capsys.readouterr()\n    if caplog:\n        caplog.clear()\n    os.chdir(Path(__file__).parent)\n    try:\n        main(command)\n    except SystemExit:\n        ...\n    if capsys:\n        captured_err = capsys.readouterr()\n        return captured_err\n    if caplog:\n        return [record.message for record in caplog.records]\n    return None"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_server_run` function is designed to verify that the Sanic server starts correctly and logs the expected startup message, indicating that it is running and accessible at the specified port.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when the server is started with a given application name and port, the log output contains the message \"Goin' Fast @ http://127.0.0.1:{port}\". This confirms that the server is operational and listening on the expected address.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the `capture` function, which executes the `main` function with the provided command (including the application name and port). The `main` function is expected to start the server and log the startup message. The `capture` function also handles log capturing through the `caplog` fixture, allowing the test to assert that the correct log message is present in the output.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test can be run with different values for `appname`, `extra`, and `port`, allowing for flexible testing of various configurations.\n- **Log Capture**: The use of `caplog` allows for effective verification of log messages generated during the execution of the server, which is crucial for confirming that the server behaves as expected.\n- **Command Execution**: The test constructs a command list to simulate starting the server, which is a common pattern in testing command-line applications."
    },
    {
      "name": "test_server_run_factory_with_args",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cli.py",
      "line_number": 80,
      "end_line_number": 84,
      "source_code": "def test_server_run_factory_with_args(caplog, command, port):\n    command.append(f\"-p={port}\")\n    lines = capture(command, caplog)\n\n    assert \"target=fake.server.create_app_with_args\" in lines",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('command', (['fake.server.create_app_with_args', '--factory'], ['fake.server.create_app_with_args']))"
      ],
      "arguments": [
        "caplog",
        "command",
        "port"
      ],
      "imports": [
        "json",
        "os",
        "sys",
        "pathlib.Path",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock.patch",
        "pytest",
        "sanic_routing.__version__",
        "sanic.__version__",
        "sanic.__main__.main",
        "sanic.cli.inspector_client.InspectorClient",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'target=fake.server.create_app_with_args' in lines"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "capture",
          "body": "def capture(command: List[str], caplog=None, capsys=None):\n    if capsys:\n        capsys.readouterr()\n    if caplog:\n        caplog.clear()\n    os.chdir(Path(__file__).parent)\n    try:\n        main(command)\n    except SystemExit:\n        ...\n    if capsys:\n        captured_err = capsys.readouterr()\n        return captured_err\n    if caplog:\n        return [record.message for record in caplog.records]\n    return None"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_server_run_factory_with_args` test is designed to verify that the server's command-line interface correctly processes arguments and that the expected application creation function is invoked when the server is run with specific parameters.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a command is constructed with a specific port argument and passed to the `capture` function, the output contains a specific log message indicating that the application is being created with the expected function (`fake.server.create_app_with_args`). This ensures that the server is configured correctly based on the provided command-line arguments.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `capture` function, which executes the `main` function with the provided command. The `main` function is expected to handle the command-line arguments and start the server. The `capture` function also manages logging and output capturing, allowing the test to assert that the correct log messages are generated. The `command` list is modified to include the port, and the output is checked for the presence of the expected log message.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test likely uses parameterized inputs (`command` and `port`), allowing it to run multiple scenarios with different configurations.\n- **Logging Capture**: The use of `caplog` to capture log messages during the test execution is a common pattern in testing to verify that the correct logging behavior occurs.\n- **Assertion**: The test employs a straightforward assertion to check for the presence of a specific string in the captured output, which is a fundamental aspect of unit testing to validate expected outcomes."
    },
    {
      "name": "test_server_run_factory_with_args_arbitrary",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cli.py",
      "line_number": 87,
      "end_line_number": 96,
      "source_code": "def test_server_run_factory_with_args_arbitrary(caplog, port):\n    command = [\n        \"fake.server.create_app_with_args\",\n        \"--factory\",\n        \"--foo=bar\",\n        f\"-p={port}\",\n    ]\n    lines = capture(command, caplog)\n\n    assert \"foo=bar\" in lines",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "caplog",
        "port"
      ],
      "imports": [
        "json",
        "os",
        "sys",
        "pathlib.Path",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock.patch",
        "pytest",
        "sanic_routing.__version__",
        "sanic.__version__",
        "sanic.__main__.main",
        "sanic.cli.inspector_client.InspectorClient",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'foo=bar' in lines"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "capture",
          "body": "def capture(command: List[str], caplog=None, capsys=None):\n    if capsys:\n        capsys.readouterr()\n    if caplog:\n        caplog.clear()\n    os.chdir(Path(__file__).parent)\n    try:\n        main(command)\n    except SystemExit:\n        ...\n    if capsys:\n        captured_err = capsys.readouterr()\n        return captured_err\n    if caplog:\n        return [record.message for record in caplog.records]\n    return None"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_server_run_factory_with_args_arbitrary` is designed to verify that the server can be started with arbitrary command-line arguments, specifically checking that the argument `--foo=bar` is correctly processed and logged.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when the server is run with the specified command-line arguments, the log output contains the string \"foo=bar\". This ensures that the application correctly recognizes and handles the `--foo` argument.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the `capture` function to simulate running the server with a command that includes a factory option and additional arguments. The `capture` function executes the `main` function with the provided command, capturing any log messages generated during execution. The `main` function is expected to handle the command-line arguments and log the relevant information.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Use of Fixtures**: The test uses `caplog`, a pytest fixture that captures log messages, allowing for easy verification of logging behavior.\n- **Command Simulation**: The test constructs a command list that mimics command-line input, enabling the testing of command-line argument handling without needing to run an actual server.\n- **Assertion on Log Output**: The test asserts that specific log messages are present in the captured output, which is a common pattern in testing logging behavior in applications."
    },
    {
      "name": "test_tls_options",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cli.py",
      "line_number": 117,
      "end_line_number": 126,
      "source_code": "def test_tls_options(cmd: Tuple[str, ...], caplog, port):\n    command = [\n        \"fake.server.app\",\n        *cmd,\n        f\"--port={port}\",\n        \"--debug\",\n        \"--single-process\",\n    ]\n    lines = capture(command, caplog)\n    assert f\"Goin' Fast @ https://127.0.0.1:{port}\" in lines",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('cmd', (('--cert=certs/sanic.example/fullchain.pem', '--key=certs/sanic.example/privkey.pem'), ('--tls=certs/sanic.example/', '--tls=certs/localhost/'), ('--tls=certs/sanic.example/', '--tls=certs/localhost/', '--tls-strict-host')))"
      ],
      "arguments": [
        "cmd",
        "caplog",
        "port"
      ],
      "imports": [
        "json",
        "os",
        "sys",
        "pathlib.Path",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock.patch",
        "pytest",
        "sanic_routing.__version__",
        "sanic.__version__",
        "sanic.__main__.main",
        "sanic.cli.inspector_client.InspectorClient",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert f\"Goin' Fast @ https://127.0.0.1:{port}\" in lines"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "capture",
          "body": "def capture(command: List[str], caplog=None, capsys=None):\n    if capsys:\n        capsys.readouterr()\n    if caplog:\n        caplog.clear()\n    os.chdir(Path(__file__).parent)\n    try:\n        main(command)\n    except SystemExit:\n        ...\n    if capsys:\n        captured_err = capsys.readouterr()\n        return captured_err\n    if caplog:\n        return [record.message for record in caplog.records]\n    return None"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_tls_options` function is designed to verify that the Sanic application correctly starts with TLS (Transport Layer Security) enabled and logs the appropriate message indicating the server is running securely over HTTPS.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when the application is launched with specific command-line arguments (including TLS options), the output contains a message confirming that the server is running at the expected HTTPS address, specifically `https://127.0.0.1:{port}`.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the `capture` function to execute the `main` function of the Sanic application with a constructed command that includes the application name, TLS options, and other parameters. The `main` function is responsible for starting the server and logging the output. The test then asserts that the expected log message is present in the captured output, confirming that the server has started correctly with the specified TLS settings.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test likely uses parameterized inputs (though not explicitly shown in the provided snippet) to allow for different command-line arguments to be tested, enhancing coverage and flexibility.\n- **Log Capture**: The use of `caplog` allows the test to capture log messages generated during the execution of the application, which is essential for verifying the output without needing to modify the application code.\n- **Assertion**: The test employs a straightforward assertion to check for the presence of a specific string in the captured output, which is a common practice in unit testing to validate expected behavior."
    },
    {
      "name": "test_tls_wrong_options",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cli.py",
      "line_number": 141,
      "end_line_number": 149,
      "source_code": "def test_tls_wrong_options(cmd: Tuple[str, ...], caplog, port):\n    command = [\"fake.server.app\", *cmd, f\"-p={port}\", \"--debug\"]\n    lines = capture(command, caplog)\n\n    assert (\n        \"TLS certificates must be specified by either of:\\n  \"\n        \"--cert certdir/fullchain.pem --key certdir/privkey.pem\\n  \"\n        \"--tls certdir  (equivalent to the above)\"\n    ) in lines",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('cmd', (('--cert=certs/sanic.example/fullchain.pem',), ('--cert=certs/sanic.example/fullchain.pem', '--key=certs/sanic.example/privkey.pem', '--tls=certs/localhost/'), ('--tls-strict-host',)))"
      ],
      "arguments": [
        "cmd",
        "caplog",
        "port"
      ],
      "imports": [
        "json",
        "os",
        "sys",
        "pathlib.Path",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock.patch",
        "pytest",
        "sanic_routing.__version__",
        "sanic.__version__",
        "sanic.__main__.main",
        "sanic.cli.inspector_client.InspectorClient",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'TLS certificates must be specified by either of:\\n  --cert certdir/fullchain.pem --key certdir/privkey.pem\\n  --tls certdir  (equivalent to the above)' in lines"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "capture",
          "body": "def capture(command: List[str], caplog=None, capsys=None):\n    if capsys:\n        capsys.readouterr()\n    if caplog:\n        caplog.clear()\n    os.chdir(Path(__file__).parent)\n    try:\n        main(command)\n    except SystemExit:\n        ...\n    if capsys:\n        captured_err = capsys.readouterr()\n        return captured_err\n    if caplog:\n        return [record.message for record in caplog.records]\n    return None"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_tls_wrong_options` unit test is designed to verify that the application correctly handles scenarios where TLS (Transport Layer Security) options are improperly specified. Specifically, it checks that the application provides an appropriate error message when required TLS certificate options are missing.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when the application is started with incorrect or incomplete TLS options, it logs a specific error message indicating the correct way to specify TLS certificates. The test asserts that this error message is present in the captured output.\n\n**Code Being Tested and How It Works**:  \nThe test invokes the `capture` function with a command that simulates starting the application (`fake.server.app`) with TLS-related command-line arguments (`cmd`), a specified port, and a debug flag. The `capture` function executes the command and captures any output or log messages generated during the execution. The test then checks if the expected error message about TLS certificate requirements is included in the captured output.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test utilizes parameterization (though not directly shown in this specific test) to allow for multiple command variations to be tested, enhancing coverage without duplicating code.\n- **Output Capture**: The use of the `caplog` fixture allows the test to capture log messages generated during the execution of the command, which is essential for verifying the presence of the expected error message.\n- **Assertion**: The test employs a straightforward assertion to confirm that the expected error message is present in the output, which is a common practice in unit testing to validate behavior."
    },
    {
      "name": "test_host_port_localhost",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cli.py",
      "line_number": 159,
      "end_line_number": 165,
      "source_code": "def test_host_port_localhost(cmd: Tuple[str, ...], caplog, port):\n    cmd = [c.format(port=str(port)) for c in cmd]\n    command = [\"fake.server.app\", *cmd]\n    lines = capture(command, caplog)\n    expected = f\"Goin' Fast @ http://localhost:{port}\"\n\n    assert expected in lines",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('cmd', (('--host=localhost', '--port={port}'), ('-H', 'localhost', '-p', '{port}')))"
      ],
      "arguments": [
        "cmd",
        "caplog",
        "port"
      ],
      "imports": [
        "json",
        "os",
        "sys",
        "pathlib.Path",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock.patch",
        "pytest",
        "sanic_routing.__version__",
        "sanic.__version__",
        "sanic.__main__.main",
        "sanic.cli.inspector_client.InspectorClient",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert expected in lines"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "capture",
          "body": "def capture(command: List[str], caplog=None, capsys=None):\n    if capsys:\n        capsys.readouterr()\n    if caplog:\n        caplog.clear()\n    os.chdir(Path(__file__).parent)\n    try:\n        main(command)\n    except SystemExit:\n        ...\n    if capsys:\n        captured_err = capsys.readouterr()\n        return captured_err\n    if caplog:\n        return [record.message for record in caplog.records]\n    return None"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_host_port_localhost` unit test is designed to verify that the server application correctly logs the expected startup message when it is run on the localhost with a specified port. This ensures that the application is configured to listen on the correct host and port, which is crucial for its accessibility.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the output log contains the message indicating the server is running at the expected URL format, specifically `http://localhost:{port}`. This confirms that the server's startup behavior is functioning as intended and that it is correctly reporting its operational status.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the `capture` function to execute the server command with the specified parameters, including the port. The command is constructed by formatting the `cmd` argument with the port number. The `capture` function runs the command and captures the output logs. The expected log message is then checked against the captured output to ensure it contains the correct URL.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test leverages parameterization (though not explicitly shown in this specific test) to allow for different command inputs, which can enhance test coverage by running the same test logic with various configurations.\n- **Log Capture**: The use of `caplog` to capture log messages during the test execution is a notable technique that allows for verification of logging behavior without needing to inspect the console output directly.\n- **Assertion**: The test employs a simple assertion to check for the presence of the expected log message in the captured output, which is a common practice in unit testing to validate outcomes."
    },
    {
      "name": "test_host_port",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cli.py",
      "line_number": 193,
      "end_line_number": 199,
      "source_code": "def test_host_port(cmd: Tuple[str, ...], expected: str, caplog, port):\n    cmd = [c.format(port=str(port)) for c in cmd]\n    expected = expected.format(port=str(port))\n    command = [\"fake.server.app\", *cmd]\n    lines = capture(command, caplog)\n\n    assert expected in lines",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('cmd,expected', ((('--host=localhost', '--port={port}'), \"Goin' Fast @ http://localhost:{port}\"), (('-H', 'localhost', '-p', '{port}'), \"Goin' Fast @ http://localhost:{port}\"), (('--host=127.0.0.1', '--port={port}'), \"Goin' Fast @ http://127.0.0.1:{port}\"), (('-H', '127.0.0.1', '-p', '{port}'), \"Goin' Fast @ http://127.0.0.1:{port}\"), (('--host=::', '--port={port}'), \"Goin' Fast @ http://[::]:{port}\"), (('-H', '::', '-p', '{port}'), \"Goin' Fast @ http://[::]:{port}\"), (('--host=::1', '--port={port}'), \"Goin' Fast @ http://[::1]:{port}\"), (('-H', '::1', '-p', '{port}'), \"Goin' Fast @ http://[::1]:{port}\")))"
      ],
      "arguments": [
        "cmd",
        "expected",
        "caplog",
        "port"
      ],
      "imports": [
        "json",
        "os",
        "sys",
        "pathlib.Path",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock.patch",
        "pytest",
        "sanic_routing.__version__",
        "sanic.__version__",
        "sanic.__main__.main",
        "sanic.cli.inspector_client.InspectorClient",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert expected in lines"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "capture",
          "body": "def capture(command: List[str], caplog=None, capsys=None):\n    if capsys:\n        capsys.readouterr()\n    if caplog:\n        caplog.clear()\n    os.chdir(Path(__file__).parent)\n    try:\n        main(command)\n    except SystemExit:\n        ...\n    if capsys:\n        captured_err = capsys.readouterr()\n        return captured_err\n    if caplog:\n        return [record.message for record in caplog.records]\n    return None"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_host_port` function is designed to verify that the command-line interface (CLI) of the Sanic application correctly handles and formats the host and port parameters when executing a command. It ensures that the expected output includes the correct port number.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the output generated by the command execution contains the expected string, which is formatted to include the specified port. It validates that the application responds correctly to the command with the given port, ensuring that the CLI behaves as intended.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the `capture` function to execute a command that simulates running the Sanic application with specific command-line arguments. The command is constructed by formatting the `cmd` list with the provided `port`. The `capture` function runs the command and captures any log messages or output generated during execution. The test then asserts that the expected output (also formatted with the port) is present in the captured lines.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test likely uses parameterization (though not shown in the snippet) to run multiple scenarios with different command inputs and expected outputs, enhancing test coverage.\n- **Output Capture**: The use of the `caplog` fixture allows the test to capture log messages generated during the command execution, which is essential for verifying the application's behavior in response to the command.\n- **String Formatting**: The test employs string formatting to dynamically insert the port into both the command and the expected output, making it adaptable to different test cases without hardcoding values."
    },
    {
      "name": "test_num_workers",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cli.py",
      "line_number": 213,
      "end_line_number": 222,
      "source_code": "def test_num_workers(num: int, cmd: Tuple[str, ...], caplog, port):\n    command = [\"fake.server.app\", *cmd, f\"-p={port}\"]\n    lines = capture(command, caplog)\n\n    if num == 1:\n        expected = \"mode: production, single worker\"\n    else:\n        expected = f\"mode: production, w/ {num} workers\"\n\n    assert expected in lines",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('num,cmd', ((1, (f'--workers={1}',)), (2, (f'--workers={2}',)), (4, (f'--workers={4}',)), (1, ('-w', '1')), (2, ('-w', '2')), (4, ('-w', '4'))))"
      ],
      "arguments": [
        "num",
        "cmd",
        "caplog",
        "port"
      ],
      "imports": [
        "json",
        "os",
        "sys",
        "pathlib.Path",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock.patch",
        "pytest",
        "sanic_routing.__version__",
        "sanic.__version__",
        "sanic.__main__.main",
        "sanic.cli.inspector_client.InspectorClient",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert expected in lines"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "capture",
          "body": "def capture(command: List[str], caplog=None, capsys=None):\n    if capsys:\n        capsys.readouterr()\n    if caplog:\n        caplog.clear()\n    os.chdir(Path(__file__).parent)\n    try:\n        main(command)\n    except SystemExit:\n        ...\n    if capsys:\n        captured_err = capsys.readouterr()\n        return captured_err\n    if caplog:\n        return [record.message for record in caplog.records]\n    return None"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_num_workers` function is designed to verify that the application correctly logs the number of workers it is configured to run. It checks whether the expected log message indicating the mode of operation (single worker or multiple workers) is present in the captured output.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically verifies that when the application is started with a specified number of workers, the log output reflects this configuration accurately. It distinguishes between a single worker and multiple workers, ensuring that the correct message is logged based on the `num` parameter.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `capture` function, which executes a command to start the application and captures its output. The command is constructed using the `num` parameter to determine the number of workers and includes additional command-line arguments from `cmd` and the specified `port`. The output is then checked to see if it contains the expected log message, which varies depending on whether `num` is 1 or greater.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.mark.parametrize` decorator to run the same test logic with multiple sets of input parameters, allowing for efficient testing of different worker configurations. This approach enhances test coverage and ensures that various scenarios are validated without duplicating code. Additionally, the use of `caplog` allows for capturing and asserting log messages, which is a common technique in testing logging behavior in applications."
    },
    {
      "name": "test_debug",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cli.py",
      "line_number": 226,
      "end_line_number": 232,
      "source_code": "def test_debug(cmd: str, caplog, port):\n    command = [\"fake.server.app\", cmd, f\"-p={port}\"]\n    lines = capture(command, caplog)\n    info = read_app_info(lines)\n\n    assert info[\"debug\"] is True\n    assert info[\"auto_reload\"] is False",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('cmd', ('--debug',))"
      ],
      "arguments": [
        "cmd",
        "caplog",
        "port"
      ],
      "imports": [
        "json",
        "os",
        "sys",
        "pathlib.Path",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock.patch",
        "pytest",
        "sanic_routing.__version__",
        "sanic.__version__",
        "sanic.__main__.main",
        "sanic.cli.inspector_client.InspectorClient",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert info['debug'] is True",
        "assert info['auto_reload'] is False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "capture",
          "body": "def capture(command: List[str], caplog=None, capsys=None):\n    if capsys:\n        capsys.readouterr()\n    if caplog:\n        caplog.clear()\n    os.chdir(Path(__file__).parent)\n    try:\n        main(command)\n    except SystemExit:\n        ...\n    if capsys:\n        captured_err = capsys.readouterr()\n        return captured_err\n    if caplog:\n        return [record.message for record in caplog.records]\n    return None"
        },
        {
          "name": "read_app_info",
          "body": "def read_app_info(lines: List[str]):\n    for line in lines:\n        if line.startswith('{') and line.endswith('}'):\n            return json.loads(line)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_debug` function is designed to verify the behavior of a Sanic application when it is run in debug mode. Specifically, it checks that the application is correctly configured to enable debugging and to disable auto-reloading.\n\n**Specific Functionality or Behavior Verified**:  \nThe test asserts that the `debug` setting is `True` and the `auto_reload` setting is `False` in the application's configuration. This ensures that when the application is started with the appropriate command, it behaves as expected in a development environment.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes two helper functions: `capture` and `read_app_info`. The `capture` function executes the command to start the application and captures the output or logs generated during its execution. The `read_app_info` function processes the captured output to extract relevant configuration information, specifically looking for a JSON-formatted string that contains the `debug` and `auto_reload` settings. The assertions then validate that these settings are correctly set.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test is likely part of a parameterized test suite, allowing it to run with different command inputs (though the specific parameterization is not shown in the provided snippet).\n- **Log Capture**: The use of `caplog` allows the test to capture logging output, which is essential for verifying the application's behavior without needing to modify the application code.\n- **Assertions**: The test employs assertions to validate the expected state of the application, ensuring that any changes to the codebase can be quickly identified if the assertions fail."
    },
    {
      "name": "test_dev",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cli.py",
      "line_number": 236,
      "end_line_number": 242,
      "source_code": "def test_dev(cmd: str, caplog, port):\n    command = [\"fake.server.app\", cmd, f\"-p={port}\"]\n    lines = capture(command, caplog)\n    info = read_app_info(lines)\n\n    assert info[\"debug\"] is True\n    assert info[\"auto_reload\"] is True",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('cmd', ('--dev', '-d'))"
      ],
      "arguments": [
        "cmd",
        "caplog",
        "port"
      ],
      "imports": [
        "json",
        "os",
        "sys",
        "pathlib.Path",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock.patch",
        "pytest",
        "sanic_routing.__version__",
        "sanic.__version__",
        "sanic.__main__.main",
        "sanic.cli.inspector_client.InspectorClient",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert info['debug'] is True",
        "assert info['auto_reload'] is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "capture",
          "body": "def capture(command: List[str], caplog=None, capsys=None):\n    if capsys:\n        capsys.readouterr()\n    if caplog:\n        caplog.clear()\n    os.chdir(Path(__file__).parent)\n    try:\n        main(command)\n    except SystemExit:\n        ...\n    if capsys:\n        captured_err = capsys.readouterr()\n        return captured_err\n    if caplog:\n        return [record.message for record in caplog.records]\n    return None"
        },
        {
          "name": "read_app_info",
          "body": "def read_app_info(lines: List[str]):\n    for line in lines:\n        if line.startswith('{') and line.endswith('}'):\n            return json.loads(line)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_dev` function is designed to verify that the Sanic application is correctly configured for development mode, specifically checking that both the `debug` and `auto_reload` settings are enabled.\n\n**Specific Functionality or Behavior Verified**:  \nThis test asserts that when the application is started with a specific command (passed as `cmd`), it correctly sets the `debug` and `auto_reload` flags to `True`. This is crucial for development environments where developers need immediate feedback on code changes and detailed error messages.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the `capture` function to execute a command that starts the Sanic application with the specified parameters. The output of this command is then processed by the `read_app_info` function, which extracts relevant JSON-formatted information from the output lines. The test checks the values of `info[\"debug\"]` and `info[\"auto_reload\"]` to ensure they are both `True`, indicating that the application is running in the expected development mode.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test is likely part of a larger suite where different commands can be tested, allowing for flexibility in testing various configurations without duplicating code.\n- **Logging Capture**: The use of `caplog` allows the test to capture log messages generated during the execution of the command, which is essential for verifying the application's behavior without needing to modify the application code.\n- **Separation of Concerns**: The test cleanly separates the concerns of capturing output and verifying application state, making it easier to maintain and understand."
    },
    {
      "name": "test_auto_reload",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cli.py",
      "line_number": 246,
      "end_line_number": 254,
      "source_code": "def test_auto_reload(cmd: str, caplog, port):\n    command = [\"fake.server.app\", cmd, f\"-p={port}\"]\n    lines = capture(command, caplog)\n    info = read_app_info(lines)\n\n    assert info[\"debug\"] is False, f\"Unexpected value of debug {info}\"\n    assert (\n        info[\"auto_reload\"] is True\n    ), f\"Unexpected value of auto reload {info}\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('cmd', ('--auto-reload', '-r'))"
      ],
      "arguments": [
        "cmd",
        "caplog",
        "port"
      ],
      "imports": [
        "json",
        "os",
        "sys",
        "pathlib.Path",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock.patch",
        "pytest",
        "sanic_routing.__version__",
        "sanic.__version__",
        "sanic.__main__.main",
        "sanic.cli.inspector_client.InspectorClient",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert info['debug'] is False, f'Unexpected value of debug {info}'",
        "assert info['auto_reload'] is True, f'Unexpected value of auto reload {info}'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "capture",
          "body": "def capture(command: List[str], caplog=None, capsys=None):\n    if capsys:\n        capsys.readouterr()\n    if caplog:\n        caplog.clear()\n    os.chdir(Path(__file__).parent)\n    try:\n        main(command)\n    except SystemExit:\n        ...\n    if capsys:\n        captured_err = capsys.readouterr()\n        return captured_err\n    if caplog:\n        return [record.message for record in caplog.records]\n    return None"
        },
        {
          "name": "read_app_info",
          "body": "def read_app_info(lines: List[str]):\n    for line in lines:\n        if line.startswith('{') and line.endswith('}'):\n            return json.loads(line)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_auto_reload` function is designed to verify that the application correctly sets the `auto_reload` feature to `True` when it is enabled, and that the `debug` mode is set to `False`. This is crucial for ensuring that the application behaves as expected during development, particularly in environments where automatic reloading of the server is desired.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two specific configurations of the application: it asserts that the `debug` mode is `False` and that the `auto_reload` feature is `True`. These assertions ensure that the application is not running in debug mode while still allowing for automatic reloading, which is a common requirement for production-like environments.\n\n**Code Being Tested and How It Works**:  \nThe test invokes the `capture` function with a command that simulates starting the application with specific parameters (including the `cmd` and `port`). The `capture` function executes the application and captures its output or logs. The `read_app_info` function then processes this output to extract the relevant configuration settings (in this case, `debug` and `auto_reload`). The assertions at the end of the test validate that these settings match the expected values.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses parameters (`cmd`, `caplog`, `port`) to allow for flexible testing of different command-line arguments, which enhances test coverage without duplicating code.\n- **Output Capture**: The use of `caplog` and `capsys` allows the test to capture log messages and standard output, enabling verification of the application's behavior without modifying its code.\n- **Assertions with Contextual Messages**: The assertions include detailed error messages that provide context in case of failure, which aids in debugging by indicating the expected versus actual values."
    },
    {
      "name": "test_access_logs",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cli.py",
      "line_number": 266,
      "end_line_number": 277,
      "source_code": "def test_access_logs(cmd: str, expected: bool, caplog, port):\n    command = [\"fake.server.app\", f\"-p={port}\"]\n    if cmd:\n        command.append(cmd)\n    lines = capture(command, caplog)\n    print(lines)\n    info = read_app_info(lines)\n    if info[\"access_log\"] != expected:\n        print(lines)\n    assert (\n        info[\"access_log\"] is expected\n    ), f\"Expected: {expected}. Received: {info}. Lines: {lines}\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('cmd,expected', (('', False), ('--debug', True), ('--access-log', True), ('--no-access-log', False)))"
      ],
      "arguments": [
        "cmd",
        "expected",
        "caplog",
        "port"
      ],
      "imports": [
        "json",
        "os",
        "sys",
        "pathlib.Path",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock.patch",
        "pytest",
        "sanic_routing.__version__",
        "sanic.__version__",
        "sanic.__main__.main",
        "sanic.cli.inspector_client.InspectorClient",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert info['access_log'] is expected, f'Expected: {expected}. Received: {info}. Lines: {lines}'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "capture",
          "body": "def capture(command: List[str], caplog=None, capsys=None):\n    if capsys:\n        capsys.readouterr()\n    if caplog:\n        caplog.clear()\n    os.chdir(Path(__file__).parent)\n    try:\n        main(command)\n    except SystemExit:\n        ...\n    if capsys:\n        captured_err = capsys.readouterr()\n        return captured_err\n    if caplog:\n        return [record.message for record in caplog.records]\n    return None"
        },
        {
          "name": "read_app_info",
          "body": "def read_app_info(lines: List[str]):\n    for line in lines:\n        if line.startswith('{') and line.endswith('}'):\n            return json.loads(line)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_access_logs` function is designed to verify that the access logging behavior of a Sanic application is correctly configured based on the command-line arguments provided. It checks whether the application's access log setting matches the expected boolean value.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically verifies that the `access_log` property of the application, as determined from the output of the application when run with specific command-line arguments, matches the expected value (`True` or `False`). It ensures that the application behaves correctly in terms of logging access requests based on the provided command.\n\n**Code Being Tested and How It Works**:  \nThe test invokes the `capture` function with a command that includes the application name and port, along with any additional command-line arguments (`cmd`). The `capture` function executes the application and captures its output, which is then processed by the `read_app_info` function to extract relevant information, specifically the `access_log` setting. The test asserts that this setting matches the expected value, providing feedback if it does not.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test is likely part of a parameterized test suite, allowing it to run multiple scenarios with different command-line arguments and expected outcomes. This is indicated by the use of parameters (`cmd` and `expected`).\n- **Output Capture**: The use of `caplog` and `capsys` allows the test to capture log messages and standard output, which is essential for verifying the application's behavior without requiring manual inspection of console output.\n- **Assertions with Context**: The assertion includes a detailed error message that provides context about the expected versus actual results, which aids in debugging when the test fails."
    },
    {
      "name": "test_version",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cli.py",
      "line_number": 281,
      "end_line_number": 286,
      "source_code": "def test_version(cmd: str, caplog, capsys):\n    command = [cmd]\n    capture(command, caplog)\n    version_string = f\"Sanic {__version__}; Routing {__routing_version__}\\n\"\n    out, _ = capsys.readouterr()\n    assert version_string == out",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('cmd', ('--version', '-v'))"
      ],
      "arguments": [
        "cmd",
        "caplog",
        "capsys"
      ],
      "imports": [
        "json",
        "os",
        "sys",
        "pathlib.Path",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock.patch",
        "pytest",
        "sanic_routing.__version__",
        "sanic.__version__",
        "sanic.__main__.main",
        "sanic.cli.inspector_client.InspectorClient",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert version_string == out"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "capture",
          "body": "def capture(command: List[str], caplog=None, capsys=None):\n    if capsys:\n        capsys.readouterr()\n    if caplog:\n        caplog.clear()\n    os.chdir(Path(__file__).parent)\n    try:\n        main(command)\n    except SystemExit:\n        ...\n    if capsys:\n        captured_err = capsys.readouterr()\n        return captured_err\n    if caplog:\n        return [record.message for record in caplog.records]\n    return None"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_version` function is designed to verify that the command-line interface (CLI) of the Sanic application correctly outputs the version information when invoked with version-related commands (`--version` or `-v`). This ensures that users can retrieve the current version of the application as expected.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the output string produced by the CLI matches the expected version string format, which includes the Sanic version and the routing version. It asserts that the output from the command matches the constructed `version_string`, ensuring that the version information is accurate and correctly formatted.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `capture` function, which executes the command passed to it (in this case, the version command) and captures any output generated. The `main` function is called within `capture`, which is responsible for handling the command-line arguments and producing the output. The test then reads the captured output using `capsys.readouterr()` and compares it to the expected `version_string`, which is formatted using the `__version__` and `__routing_version__` variables.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses `@pytest.mark.parametrize` to run the same test logic for multiple command inputs (`--version` and `-v`), promoting code reuse and reducing redundancy.\n- **Output Capture**: The test leverages `capsys` to capture standard output and error streams, allowing for verification of command output without modifying the actual output behavior of the application.\n- **Assertion**: The test employs a straightforward assertion to compare the expected output with the actual output, providing a clear pass/fail result based on the correctness of the version information displayed."
    },
    {
      "name": "test_noisy_exceptions",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cli.py",
      "line_number": 296,
      "end_line_number": 301,
      "source_code": "def test_noisy_exceptions(cmd: str, expected: bool, caplog, port):\n    command = [\"fake.server.app\", cmd, f\"-p={port}\"]\n    lines = capture(command, caplog)\n    info = read_app_info(lines)\n\n    assert info[\"noisy_exceptions\"] is expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('cmd,expected', (('--noisy-exceptions', True), ('--no-noisy-exceptions', False)))"
      ],
      "arguments": [
        "cmd",
        "expected",
        "caplog",
        "port"
      ],
      "imports": [
        "json",
        "os",
        "sys",
        "pathlib.Path",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock.patch",
        "pytest",
        "sanic_routing.__version__",
        "sanic.__version__",
        "sanic.__main__.main",
        "sanic.cli.inspector_client.InspectorClient",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert info['noisy_exceptions'] is expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "capture",
          "body": "def capture(command: List[str], caplog=None, capsys=None):\n    if capsys:\n        capsys.readouterr()\n    if caplog:\n        caplog.clear()\n    os.chdir(Path(__file__).parent)\n    try:\n        main(command)\n    except SystemExit:\n        ...\n    if capsys:\n        captured_err = capsys.readouterr()\n        return captured_err\n    if caplog:\n        return [record.message for record in caplog.records]\n    return None"
        },
        {
          "name": "read_app_info",
          "body": "def read_app_info(lines: List[str]):\n    for line in lines:\n        if line.startswith('{') and line.endswith('}'):\n            return json.loads(line)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_noisy_exceptions` unit test is designed to verify the behavior of the Sanic application regarding the handling of noisy exceptions. Specifically, it checks whether the application correctly interprets command-line arguments that enable or disable noisy exception logging.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when the command-line argument `--noisy-exceptions` is provided, the application sets the `noisy_exceptions` configuration to `True`, and when `--no-noisy-exceptions` is provided, it sets it to `False`. The expected behavior is that the application should reflect these settings accurately in its configuration.\n\n**Code Being Tested and How It Works**:  \nThe test invokes the `capture` function with a command that includes the specified argument and a port number. The `capture` function executes the command, capturing any output or logs generated during the execution. It then calls `read_app_info`, which processes the captured output to extract the application's configuration information, specifically looking for the `noisy_exceptions` key. The test asserts that the value of `noisy_exceptions` matches the expected boolean value.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses `pytest.mark.parametrize` to run the same test logic with different command-line arguments and expected outcomes, promoting code reuse and clarity.\n- **Log Capture**: The `caplog` fixture is utilized to capture log messages generated during the test, allowing for verification of logging behavior without cluttering the test output.\n- **Separation of Concerns**: The test cleanly separates the logic of capturing command output and reading application information, making it easier to understand and maintain."
    },
    {
      "name": "test_inspector_inspect",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cli.py",
      "line_number": 304,
      "end_line_number": 323,
      "source_code": "def test_inspector_inspect(urlopen, caplog, capsys):\n    urlopen.read.return_value = json.dumps(\n        {\n            \"result\": {\n                \"info\": {\n                    \"packages\": [\"foo\"],\n                },\n                \"extra\": {\n                    \"more\": \"data\",\n                },\n                \"workers\": {\"Worker-Name\": {\"some\": \"state\"}},\n            }\n        }\n    ).encode()\n    with patch(\"sys.argv\", [\"sanic\", \"inspect\"]):\n        capture([\"inspect\"], caplog)\n    captured = capsys.readouterr()\n    assert \"Inspecting @ http://localhost:6457\" in captured.out\n    assert \"Worker-Name\" in captured.out\n    assert captured.err == \"\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "urlopen",
        "caplog",
        "capsys"
      ],
      "imports": [
        "json",
        "os",
        "sys",
        "pathlib.Path",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock.patch",
        "pytest",
        "sanic_routing.__version__",
        "sanic.__version__",
        "sanic.__main__.main",
        "sanic.cli.inspector_client.InspectorClient",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'Inspecting @ http://localhost:6457' in captured.out",
        "assert 'Worker-Name' in captured.out",
        "assert captured.err == ''"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "capture",
          "body": "def capture(command: List[str], caplog=None, capsys=None):\n    if capsys:\n        capsys.readouterr()\n    if caplog:\n        caplog.clear()\n    os.chdir(Path(__file__).parent)\n    try:\n        main(command)\n    except SystemExit:\n        ...\n    if capsys:\n        captured_err = capsys.readouterr()\n        return captured_err\n    if caplog:\n        return [record.message for record in caplog.records]\n    return None"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_inspector_inspect` function is to verify the behavior of the Sanic application's inspector command when invoked. It ensures that the command correctly processes the response from a mocked URL and outputs the expected log messages to the console.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when the inspector command is executed, it logs the correct inspection message and includes specific worker information in the output. It also verifies that no error messages are produced during the command execution.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `capture` function, which simulates running the command-line interface (CLI) of the Sanic application. It uses a mocked `urlopen` to return a predefined JSON response that mimics the expected structure from an actual inspector request. The test then checks the captured standard output and error streams to assert that the expected messages are present and that no errors occurred.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The `urlopen` object is mocked to control the response returned during the test, allowing for isolated testing without external dependencies.\n- **Context Management**: The `patch` function is used to temporarily modify `sys.argv`, simulating command-line arguments for the test.\n- **Output Capture**: The `capsys` fixture is employed to capture standard output and error streams, enabling assertions on what the application outputs during the test execution.\n- **Assertions**: The test uses assertions to validate that the expected output is present and that no errors were logged, ensuring the command behaves as intended."
    },
    {
      "name": "test_inspector_command",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cli.py",
      "line_number": 343,
      "end_line_number": 348,
      "source_code": "def test_inspector_command(command, params):\n    with patch.object(InspectorClient, \"request\") as client:\n        with patch(\"sys.argv\", [\"sanic\", \"inspect\", *command]):\n            main()\n\n    client.assert_called_once_with(command[0], **params)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('command,params', ((['reload'], {'zero_downtime': False}), (['reload', '--zero-downtime'], {'zero_downtime': True}), (['shutdown'], {}), (['scale', '9'], {'replicas': 9}), (['foo', '--bar=something'], {'bar': 'something'}), (['foo', '--bar'], {'bar': True}), (['foo', '--no-bar'], {'bar': False}), (['foo', 'positional'], {'args': ['positional']}), (['foo', 'positional', '--bar=something'], {'args': ['positional'], 'bar': 'something'})))"
      ],
      "arguments": [
        "command",
        "params"
      ],
      "imports": [
        "json",
        "os",
        "sys",
        "pathlib.Path",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock.patch",
        "pytest",
        "sanic_routing.__version__",
        "sanic.__version__",
        "sanic.__main__.main",
        "sanic.cli.inspector_client.InspectorClient",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_inspector_command` function is designed to verify that the `InspectorClient` correctly processes a command passed to it via the command line interface (CLI) and that it makes the expected request with the appropriate parameters.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when the `main()` function is executed with a specific command and parameters, the `request` method of the `InspectorClient` is called exactly once with the expected command and parameters. This ensures that the command-line interface behaves as intended when invoked.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `InspectorClient` class, specifically its `request` method. The test uses the `patch` function from the `unittest.mock` module to replace the `request` method with a mock object, allowing the test to assert that it was called correctly. The `sys.argv` is also patched to simulate command-line arguments, which are passed to the `main()` function. The `main()` function is expected to parse these arguments and invoke the `request` method of `InspectorClient` with the correct command and parameters.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test uses `patch.object` to mock the `request` method of `InspectorClient`, allowing for verification of its call without executing the actual method.\n- **Parameterization**: The test is designed to be parameterized, which allows it to be run with different command and parameter combinations, although the specific parameterization is not shown in the provided snippet.\n- **Isolation**: By mocking external dependencies (like `sys.argv` and the `request` method), the test isolates the functionality being tested, ensuring that it does not depend on the actual implementation of those components. This leads to more reliable and faster tests."
    },
    {
      "name": "test_server_run_with_repl",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cli.py",
      "line_number": 351,
      "end_line_number": 371,
      "source_code": "def test_server_run_with_repl(caplog, capsys):\n    record = (\n        \"sanic.error\",\n        40,\n        \"Can't start REPL in non-interactive mode. \"\n        \"You can only run with --repl in a TTY.\",\n    )\n\n    def run():\n        command = [\"fake.server.app\", \"--repl\", f\"-p={get_port()}\"]\n        return capture(command, capsys=capsys)\n\n    with patch(\"sanic.cli.app.is_atty\", return_value=True):\n        result = run()\n\n    assert record not in caplog.record_tuples\n    assert \"Welcome to the Sanic interactive console\" in result.err\n    assert \">>> \" in result.out\n\n    run()\n    assert record in caplog.record_tuples",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "caplog",
        "capsys"
      ],
      "imports": [
        "json",
        "os",
        "sys",
        "pathlib.Path",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock.patch",
        "pytest",
        "sanic_routing.__version__",
        "sanic.__version__",
        "sanic.__main__.main",
        "sanic.cli.inspector_client.InspectorClient",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert record not in caplog.record_tuples",
        "assert 'Welcome to the Sanic interactive console' in result.err",
        "assert '>>> ' in result.out",
        "assert record in caplog.record_tuples"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "capture",
          "body": "def capture(command: List[str], caplog=None, capsys=None):\n    if capsys:\n        capsys.readouterr()\n    if caplog:\n        caplog.clear()\n    os.chdir(Path(__file__).parent)\n    try:\n        main(command)\n    except SystemExit:\n        ...\n    if capsys:\n        captured_err = capsys.readouterr()\n        return captured_err\n    if caplog:\n        return [record.message for record in caplog.records]\n    return None"
        },
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "get_port",
          "body": "def get_port():\n    sock = socket.socket()\n    sock.bind(('', 0))\n    return sock.getsockname()[1]"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_server_run_with_repl` unit test is designed to verify the behavior of the Sanic server when attempting to start in REPL (Read-Eval-Print Loop) mode. It checks that the server correctly handles both interactive and non-interactive environments, ensuring that appropriate logging occurs and that the expected output is produced.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies two main scenarios: \n1. When the server is run in an interactive mode (simulated by patching `is_atty` to return `True`), it should not log an error and should display a welcome message and prompt.\n2. When the server is run in a non-interactive mode (by calling `run()` again without the patch), it should log an error indicating that REPL cannot start in non-interactive mode.\n\n**Code Being Tested and How It Works**:  \nThe test defines a nested function `run()` that constructs a command to start the server with the `--repl` flag and captures its output using the `capture` function. The `capture` function executes the command, handling output and logging. The test uses the `patch` function to simulate an interactive terminal environment, allowing the first call to `run()` to succeed without logging an error. The second call to `run()` tests the non-interactive scenario, where it expects an error log entry to be recorded.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test uses `patch` to mock the `is_atty` function, allowing control over the environment in which the server runs.\n- **Capturing Output**: The `capture` function is employed to gather both standard output and error messages, facilitating assertions on the server's behavior.\n- **Assertions**: The test includes assertions to verify that the expected log entries are present or absent, ensuring that the server behaves correctly under different conditions."
    },
    {
      "name": "test_late_route",
      "module": "test_late_adds",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_late_adds.py",
      "line_number": 13,
      "end_line_number": 22,
      "source_code": "def test_late_route(late_app: Sanic):\n    @late_app.before_server_start\n    async def late(app: Sanic):\n        @app.get(\"/late\")\n        def handler(_):\n            return text(\"late\")\n\n    _, response = late_app.test_client.get(\"/late\")\n    assert response.status_code == 200\n    assert response.text == \"late\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "late_app"
      ],
      "imports": [
        "pytest",
        "sanic.Sanic",
        "sanic.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.text == 'late'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "late_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_late_route` function is designed to verify that a route can be successfully added to a Sanic application after the server has started. Specifically, it checks that the application can handle requests to the `/late` endpoint and return the expected response.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the route defined within the `before_server_start` hook is correctly registered and accessible. It verifies that when a GET request is made to the `/late` endpoint, the server responds with a status code of 200 and the text \"late\".\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the `late_app` fixture, which sets up a Sanic application instance. Inside the test, a route handler for the `/late` endpoint is defined within the `before_server_start` event. The handler returns the text \"late\". The test then simulates a GET request to this endpoint using `late_app.test_client.get(\"/late\")`, capturing the response to assert that the status code is 200 and the response text matches the expected output.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The test leverages a pytest fixture (`late_app`) to create a reusable application instance, promoting code reuse and clarity.\n- **Asynchronous Testing**: The test is structured to accommodate asynchronous route handlers, which is a common pattern in modern web frameworks like Sanic.\n- **Event Hook Registration**: The test demonstrates the use of Sanic's lifecycle hooks (`before_server_start`) to register routes dynamically, showcasing the framework's flexibility in handling route definitions."
    },
    {
      "name": "test_late_middleware",
      "module": "test_late_adds",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_late_adds.py",
      "line_number": 25,
      "end_line_number": 38,
      "source_code": "def test_late_middleware(late_app: Sanic):\n    @late_app.get(\"/late\")\n    def handler(request):\n        return text(request.ctx.late)\n\n    @late_app.before_server_start\n    async def late(app: Sanic):\n        @app.on_request\n        def handler(request):\n            request.ctx.late = \"late\"\n\n    _, response = late_app.test_client.get(\"/late\")\n    assert response.status_code == 200\n    assert response.text == \"late\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "late_app"
      ],
      "imports": [
        "pytest",
        "sanic.Sanic",
        "sanic.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.text == 'late'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "late_app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "late_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_late_middleware` function is designed to verify that a middleware function correctly modifies the request context before the request is processed by the route handler. Specifically, it checks that the middleware sets a value in the request context that can be accessed by the handler.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a GET request is made to the `/late` endpoint, the response contains the expected text \"late\". It verifies that the middleware, which runs before the server starts, successfully sets the `request.ctx.late` attribute, which is then returned by the handler.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes:\n- The route handler defined by `@late_app.get(\"/late\")`, which returns the value of `request.ctx.late`.\n- The middleware function defined in `@late_app.before_server_start`, which attaches an `on_request` handler that sets `request.ctx.late` to \"late\". This middleware is executed before the request reaches the handler.\n\nWhen the test client makes a GET request to `/late`, the middleware runs first, setting the context variable, and then the handler retrieves this value to form the response.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The test utilizes a fixture (`late_app`) to set up the Sanic application instance, ensuring a clean and isolated environment for each test.\n- **Middleware Testing**: The test specifically checks the interaction between middleware and route handlers, a common pattern in web frameworks to modify request/response objects.\n- **Assertion Checks**: It employs assertions to validate both the HTTP status code and the response body, ensuring that the middleware's effect is correctly reflected in the output."
    },
    {
      "name": "test_late_signal",
      "module": "test_late_adds",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_late_adds.py",
      "line_number": 41,
      "end_line_number": 54,
      "source_code": "def test_late_signal(late_app: Sanic):\n    @late_app.get(\"/late\")\n    def handler(request):\n        return text(request.ctx.late)\n\n    @late_app.before_server_start\n    async def late(app: Sanic):\n        @app.signal(\"http.lifecycle.request\")\n        def handler(request):\n            request.ctx.late = \"late\"\n\n    _, response = late_app.test_client.get(\"/late\")\n    assert response.status_code == 200\n    assert response.text == \"late\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "late_app"
      ],
      "imports": [
        "pytest",
        "sanic.Sanic",
        "sanic.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.text == 'late'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "late_app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "late_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_late_signal` function is designed to verify that a Sanic application correctly sets a context variable (`request.ctx.late`) during the request lifecycle using a signal handler. This ensures that the application can dynamically modify request context data before the request is processed.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when a GET request is made to the `/late` endpoint, the response contains the expected text \"late\". This confirms that the signal handler, which assigns the value \"late\" to `request.ctx.late`, is executed properly before the request handler processes the request.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route `/late` that returns the value of `request.ctx.late`. It also sets up a signal handler for the `http.lifecycle.request` signal, which is triggered before the request is processed. In this handler, the `request.ctx.late` variable is assigned the string \"late\". When the test client makes a GET request to `/late`, it expects a 200 status code and the response text to be \"late\", indicating that the signal handler executed successfully and set the context variable as intended.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The test utilizes a fixture (`late_app`) to set up the Sanic application context, ensuring a clean and isolated environment for each test.\n- **Signal Handling**: The test demonstrates the use of Sanic's signal mechanism to modify request context, showcasing how to extend the framework's behavior dynamically.\n- **Assertions**: The test employs assertions to validate the response status and content, which is a standard practice in unit testing to ensure expected outcomes."
    },
    {
      "name": "test_server_error_response_timeout",
      "module": "test_response_timeout",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response_timeout.py",
      "line_number": 67,
      "end_line_number": 70,
      "source_code": "def test_server_error_response_timeout(response_timeout_app):\n    request, response = response_timeout_app.test_client.get(\"/1\")\n    assert response.status == 503\n    assert response.text == \"Response Timeout from error_handler.\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "response_timeout_app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "time.sleep",
        "pytest",
        "sanic.Sanic",
        "sanic.exceptions.ServiceUnavailable",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 503",
        "assert response.text == 'Response Timeout from error_handler.'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "response_timeout_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_server_error_response_timeout` unit test is designed to verify that the application correctly handles a timeout scenario by returning a specific HTTP status code (503) and a predefined error message when a request exceeds the allowed response time.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a request is made to the `/1` endpoint, the server responds with a 503 Service Unavailable status and the message \"Response Timeout from error_handler.\" This indicates that the server is correctly implementing error handling for timeout situations.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `response_timeout_app` which is presumably configured to simulate a timeout condition. The `response_timeout_app.test_client.get(\"/1\")` method is called to initiate a GET request to the specified endpoint. The expected behavior is that the application will trigger its error handling mechanism due to a timeout, resulting in the specified status and message being returned in the response.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertion**: The test uses assertions to validate the response's status and body, ensuring that the application behaves as expected under timeout conditions.\n- **Isolation**: The test is likely run in isolation from other tests, focusing solely on the timeout behavior, which is a common practice in unit testing to ensure that tests do not interfere with each other.\n- **Use of Fixtures**: The `response_timeout_app` is likely a fixture that sets up the necessary application context and configuration for the test, allowing for clean and reusable test setups."
    },
    {
      "name": "test_default_server_error_response_timeout",
      "module": "test_response_timeout",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response_timeout.py",
      "line_number": 73,
      "end_line_number": 76,
      "source_code": "def test_default_server_error_response_timeout(response_timeout_default_app):\n    request, response = response_timeout_default_app.test_client.get(\"/1\")\n    assert response.status == 503\n    assert \"Response Timeout\" in response.text",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "response_timeout_default_app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "time.sleep",
        "pytest",
        "sanic.Sanic",
        "sanic.exceptions.ServiceUnavailable",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 503",
        "assert 'Response Timeout' in response.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "response_timeout_default_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_default_server_error_response_timeout` is designed to verify that the application correctly handles a response timeout scenario by returning a 503 Service Unavailable status code along with an appropriate error message.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a request is made to the application (in this case, to the endpoint `/1`), the response indicates a service unavailability due to a timeout. It asserts that the response status is 503 and that the response body contains the string \"Response Timeout\".\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `get` method of the `response_timeout_default_app`'s test client. This method simulates an HTTP GET request to the specified endpoint. The expected behavior is that if a timeout occurs, the application should return a 503 status code and a message indicating the timeout. The relevant part of the application logic that handles timeouts is likely implemented in the middleware or request handling logic, which is not shown in the provided code but is implied by the test's assertions.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern, where it checks the response's status and content directly after making a request. It uses the `assert` statement to validate the expected outcomes, which is a common practice in unit testing for ensuring that the actual results match the expected results. Additionally, the test is structured to be clear and concise, focusing on a single behavior (timeout handling), which is a good practice in unit testing to maintain clarity and purpose."
    },
    {
      "name": "test_response_handler_cancelled",
      "module": "test_response_timeout",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response_timeout.py",
      "line_number": 79,
      "end_line_number": 83,
      "source_code": "def test_response_handler_cancelled(response_handler_cancelled_app):\n    request, response = response_handler_cancelled_app.test_client.get(\"/1\")\n    assert response.status == 503\n    assert \"Response Timeout\" in response.text\n    assert response_handler_cancelled_app.ctx.flag is False",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "response_handler_cancelled_app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "time.sleep",
        "pytest",
        "sanic.Sanic",
        "sanic.exceptions.ServiceUnavailable",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 503",
        "assert 'Response Timeout' in response.text",
        "assert response_handler_cancelled_app.ctx.flag is False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "response_handler_cancelled_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_response_handler_cancelled` unit test is designed to verify the behavior of the application when a response handling process is cancelled, ensuring that the application correctly returns a service unavailable status and appropriate message.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a request is made to the application, the response status is 503 (Service Unavailable), the response text contains the phrase \"Response Timeout\", and a specific flag in the application context (`response_handler_cancelled_app.ctx.flag`) is set to `False`, indicating that the cancellation was handled properly.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `response_handler_cancelled_app` instance, which is presumably a Sanic application configured to simulate a cancelled response scenario. The `test_client.get(\"/1\")` method is called to initiate a GET request to the endpoint `/1`. The expected behavior is that the application will handle the cancellation and return a 503 status code along with a timeout message in the response body.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertion Checks**: The test employs assertions to validate the response status, content, and application state, which is a common practice in unit testing to ensure that the code behaves as expected.\n- **Integration Testing**: This test acts as an integration test by verifying the interaction between the request handling and the response generation in the context of the Sanic framework.\n- **Contextual State Verification**: The test checks the state of the application context (`ctx.flag`), which is a useful technique to ensure that the application maintains the correct state throughout the request lifecycle."
    },
    {
      "name": "test_response_timeout_not_applied",
      "module": "test_response_timeout",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response_timeout.py",
      "line_number": 86,
      "end_line_number": 107,
      "source_code": "def test_response_timeout_not_applied(caplog):\n    modified_config = LOGGING_CONFIG_DEFAULTS\n    modified_config[\"loggers\"][\"sanic.websockets\"][\"level\"] = \"DEBUG\"\n\n    app = Sanic(\"test_logging\", log_config=modified_config)\n    app.config.RESPONSE_TIMEOUT = 1\n    app.ctx.event = asyncio.Event()\n\n    @app.websocket(\"/ws\")\n    async def ws_handler(request, ws):\n        sleep(2)\n        await asyncio.sleep(0)\n        request.app.ctx.event.set()\n\n    with caplog.at_level(logging.DEBUG):\n        _ = app.test_client.websocket(\"/ws\")\n    assert app.ctx.event.is_set()\n    assert (\n        \"sanic.websockets\",\n        10,\n        \"Handling websocket. Timeouts disabled.\",\n    ) in caplog.record_tuples",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "caplog"
      ],
      "imports": [
        "asyncio",
        "logging",
        "time.sleep",
        "pytest",
        "sanic.Sanic",
        "sanic.exceptions.ServiceUnavailable",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.ctx.event.is_set()",
        "assert ('sanic.websockets', 10, 'Handling websocket. Timeouts disabled.') in caplog.record_tuples"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_response_timeout_not_applied` is designed to verify that the response timeout configuration does not apply to WebSocket connections in the Sanic framework. Specifically, it checks that a WebSocket handler can run longer than the specified timeout without being interrupted.\n\n**Specific Functionality or Behavior Verified**:  \nThe test ensures that when a WebSocket connection is established, the timeout settings do not affect the handling of the WebSocket request. It confirms that the event indicating the completion of the WebSocket handler is set, and that a specific debug log message is generated, indicating that timeouts are disabled for WebSocket handling.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves a WebSocket handler defined in the Sanic application. The handler simulates a long-running operation by sleeping for 2 seconds. The test sets up a Sanic application with a modified logging configuration and a response timeout of 1 second. When the WebSocket client connects to the handler, the test checks if the event (`app.ctx.event`) is set after the handler completes, indicating that the handler was not interrupted by the timeout. Additionally, it verifies that the log message \"Handling websocket. Timeouts disabled.\" is present in the captured logs, confirming the expected behavior.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `caplog` fixture from pytest to capture log messages at the DEBUG level during the execution of the WebSocket handler. This allows for verification of logging output alongside the functional behavior of the application. The use of an asynchronous WebSocket handler and the asyncio event mechanism demonstrates effective handling of concurrency in the test. The test also utilizes assertions to validate both the state of the application (event being set) and the correctness of the logging output, ensuring comprehensive coverage of the expected behavior."
    },
    {
      "name": "test_bp_copy",
      "module": "test_blueprint_copy",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprint_copy.py",
      "line_number": 9,
      "end_line_number": 80,
      "source_code": "def test_bp_copy(app: Sanic):\n    bp1 = Blueprint(\"test_bp1\", version=1)\n    bp1.ctx.test = 1\n    assert hasattr(bp1.ctx, \"test\")\n\n    @bp1.route(\"/page\")\n    def handle_request(request):\n        return text(\"Hello world!\")\n\n    bp2 = bp1.copy(name=\"test_bp2\", version=2)\n    assert id(bp1) != id(bp2)\n    assert bp1._apps == bp2._apps == set()\n    assert not hasattr(bp2.ctx, \"test\")\n    assert len(bp2._future_exceptions) == len(bp1._future_exceptions)\n    assert len(bp2._future_listeners) == len(bp1._future_listeners)\n    assert len(bp2._future_middleware) == len(bp1._future_middleware)\n    assert len(bp2._future_routes) == len(bp1._future_routes)\n    assert len(bp2._future_signals) == len(bp1._future_signals)\n\n    app.blueprint(bp1)\n    app.blueprint(bp2)\n\n    bp3 = bp1.copy(name=\"test_bp3\", version=3, with_registration=True)\n    assert id(bp1) != id(bp3)\n    assert bp1._apps == bp3._apps and bp3._apps\n    assert not hasattr(bp3.ctx, \"test\")\n\n    bp4 = bp1.copy(name=\"test_bp4\", version=4, with_ctx=True)\n    assert id(bp1) != id(bp4)\n    assert bp4.ctx.test == 1\n\n    bp5 = bp1.copy(name=\"test_bp5\", version=5, with_registration=False)\n    assert id(bp1) != id(bp5)\n    assert not bp5._apps\n    assert bp1._apps != set()\n\n    app.blueprint(bp5)\n\n    bp6 = bp1.copy(\n        name=\"test_bp6\",\n        version=6,\n        with_registration=True,\n        version_prefix=\"/version\",\n    )\n    assert bp6._apps\n    assert bp6.version_prefix == \"/version\"\n\n    _, response = app.test_client.get(\"/v1/page\")\n    assert \"Hello world!\" in response.text\n\n    _, response = app.test_client.get(\"/v2/page\")\n    assert \"Hello world!\" in response.text\n\n    _, response = app.test_client.get(\"/v3/page\")\n    assert \"Hello world!\" in response.text\n\n    _, response = app.test_client.get(\"/v4/page\")\n    assert \"Hello world!\" in response.text\n\n    _, response = app.test_client.get(\"/v5/page\")\n    assert \"Hello world!\" in response.text\n\n    _, response = app.test_client.get(\"/version6/page\")\n    assert \"Hello world!\" in response.text\n\n    route_names = [route.name for route in app.router.routes]\n    assert \"test_bp_copy.test_bp1.handle_request\" in route_names\n    assert \"test_bp_copy.test_bp2.handle_request\" in route_names\n    assert \"test_bp_copy.test_bp3.handle_request\" in route_names\n    assert \"test_bp_copy.test_bp4.handle_request\" in route_names\n    assert \"test_bp_copy.test_bp5.handle_request\" in route_names\n    assert \"test_bp_copy.test_bp6.handle_request\" in route_names",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic_routing.exceptions.RouteExists",
        "sanic.Blueprint",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert hasattr(bp1.ctx, 'test')",
        "assert id(bp1) != id(bp2)",
        "assert bp1._apps == bp2._apps == set()",
        "assert not hasattr(bp2.ctx, 'test')",
        "assert len(bp2._future_exceptions) == len(bp1._future_exceptions)",
        "assert len(bp2._future_listeners) == len(bp1._future_listeners)",
        "assert len(bp2._future_middleware) == len(bp1._future_middleware)",
        "assert len(bp2._future_routes) == len(bp1._future_routes)",
        "assert len(bp2._future_signals) == len(bp1._future_signals)",
        "assert id(bp1) != id(bp3)",
        "assert bp1._apps == bp3._apps and bp3._apps",
        "assert not hasattr(bp3.ctx, 'test')",
        "assert id(bp1) != id(bp4)",
        "assert bp4.ctx.test == 1",
        "assert id(bp1) != id(bp5)",
        "assert not bp5._apps",
        "assert bp1._apps != set()",
        "assert bp6._apps",
        "assert bp6.version_prefix == '/version'",
        "assert 'Hello world!' in response.text",
        "assert 'Hello world!' in response.text",
        "assert 'Hello world!' in response.text",
        "assert 'Hello world!' in response.text",
        "assert 'Hello world!' in response.text",
        "assert 'Hello world!' in response.text",
        "assert 'test_bp_copy.test_bp1.handle_request' in route_names",
        "assert 'test_bp_copy.test_bp2.handle_request' in route_names",
        "assert 'test_bp_copy.test_bp3.handle_request' in route_names",
        "assert 'test_bp_copy.test_bp4.handle_request' in route_names",
        "assert 'test_bp_copy.test_bp5.handle_request' in route_names",
        "assert 'test_bp_copy.test_bp6.handle_request' in route_names"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_bp_copy` function is designed to verify the behavior of the `Blueprint.copy` method in the Sanic framework. It ensures that when a blueprint is copied, the new instance behaves correctly in terms of context, registration, and route handling.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks several aspects of the blueprint copying process:\n1. It confirms that the copied blueprint (`bp2`, `bp3`, etc.) is a distinct object from the original (`bp1`), ensuring that their IDs are different.\n2. It verifies that the context (`ctx`) of the copied blueprints does not carry over certain attributes unless explicitly specified (e.g., `with_ctx=True`).\n3. It checks that the routes and middleware of the original blueprint are not duplicated in the copied blueprints unless allowed.\n4. It tests the registration of blueprints with the main application and ensures that routes are accessible via the expected URLs.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `Blueprint` class and its `copy` method. The `Blueprint` class is a part of the Sanic framework, which allows developers to organize routes and middleware. The `copy` method creates a new instance of a blueprint with the option to carry over certain properties (like context and registration). The test sets up various blueprints, copies them with different parameters, and then asserts the expected behavior regarding their properties and registered routes.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertions**: The test employs multiple assertions to validate the state and behavior of the blueprints after copying, ensuring that each aspect is thoroughly checked.\n- **Setup and Teardown**: The test uses the Sanic application context to register blueprints and test routes, demonstrating a common pattern in integration testing where the application state is manipulated and verified.\n- **Parameterized Testing**: The test checks different configurations of the `copy` method (e.g., with and without registration, with context) to ensure comprehensive coverage of the method's functionality."
    },
    {
      "name": "test_bp_copy_without_route_overwriting",
      "module": "test_blueprint_copy",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprint_copy.py",
      "line_number": 83,
      "end_line_number": 114,
      "source_code": "def test_bp_copy_without_route_overwriting(app: Sanic):\n    bpv1 = Blueprint(\"bp_v1\", version=1, url_prefix=\"my_api\")\n\n    @bpv1.route(\"/\")\n    async def handler_v1(request: Request):\n        return text(\"v1\")\n\n    app.blueprint(bpv1)\n\n    bpv2 = bpv1.copy(\"bp_v2\", version=2, allow_route_overwrite=False)\n    bpv3 = bpv1.copy(\n        \"bp_v3\",\n        version=3,\n        allow_route_overwrite=False,\n        with_registration=False,\n    )\n\n    with pytest.raises(RouteExists, match=\"Route already registered*\"):\n\n        @bpv2.route(\"/\")\n        async def handler_v2(request: Request):\n            return text(\"v2\")\n\n        app.blueprint(bpv2)\n\n    with pytest.raises(RouteExists, match=\"Route already registered*\"):\n\n        @bpv3.route(\"/\")\n        async def handler_v3(request: Request):\n            return text(\"v3\")\n\n        app.blueprint(bpv3)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic_routing.exceptions.RouteExists",
        "sanic.Blueprint",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_bp_copy_without_route_overwriting` is designed to verify that when a blueprint is copied with the `allow_route_overwrite` parameter set to `False`, any attempt to register a route that already exists in the original blueprint raises a `RouteExists` exception. This ensures that the integrity of route definitions is maintained when creating copies of blueprints.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that the copied blueprints (`bpv2` and `bpv3`) do not allow the registration of routes that have already been defined in the original blueprint (`bpv1`). It confirms that the application correctly raises an exception when trying to register a duplicate route.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `Blueprint` class from the Sanic framework. The test first creates a blueprint (`bpv1`) with a route defined at the root path (`\"/\"`). It then creates two copies of this blueprint (`bpv2` and `bpv3`) with `allow_route_overwrite` set to `False`. When the test attempts to register a new route on these copies that conflicts with the existing route in `bpv1`, it expects a `RouteExists` exception to be raised, which is validated using `pytest.raises`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the context manager `pytest.raises` to assert that specific exceptions are raised during the execution of code blocks. This is a common pattern in unit testing to ensure that error handling behaves as expected. Additionally, the test uses asynchronous route handlers, showcasing the ability to test asynchronous code in a web framework context. The use of blueprint copying and route registration highlights the modular design of the Sanic framework, allowing for organized and reusable route definitions."
    },
    {
      "name": "test_bp_copy_with_route_overwriting",
      "module": "test_blueprint_copy",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprint_copy.py",
      "line_number": 117,
      "end_line_number": 153,
      "source_code": "def test_bp_copy_with_route_overwriting(app: Sanic):\n    bpv1 = Blueprint(\"bp_v1\", version=1, url_prefix=\"my_api\")\n\n    @bpv1.route(\"/\")\n    async def handler_v1(request: Request):\n        return text(\"v1\")\n\n    app.blueprint(bpv1)\n\n    bpv2 = bpv1.copy(\"bp_v2\", version=2, allow_route_overwrite=True)\n    bpv3 = bpv1.copy(\n        \"bp_v3\", version=3, allow_route_overwrite=True, with_registration=False\n    )\n\n    @bpv2.route(\"/\")\n    async def handler_v2(request: Request):\n        return text(\"v2\")\n\n    app.blueprint(bpv2)\n\n    @bpv3.route(\"/\")\n    async def handler_v3(request: Request):\n        return text(\"v3\")\n\n    app.blueprint(bpv3)\n\n    _, response = app.test_client.get(\"/v1/my_api\")\n    assert response.status == 200\n    assert response.text == \"v1\"\n\n    _, response = app.test_client.get(\"/v2/my_api\")\n    assert response.status == 200\n    assert response.text == \"v2\"\n\n    _, response = app.test_client.get(\"/v3/my_api\")\n    assert response.status == 200\n    assert response.text == \"v3\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic_routing.exceptions.RouteExists",
        "sanic.Blueprint",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'v1'",
        "assert response.status == 200",
        "assert response.text == 'v2'",
        "assert response.status == 200",
        "assert response.text == 'v3'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_bp_copy_with_route_overwriting` test is to verify that the Sanic framework correctly handles the copying of blueprints with the option to overwrite existing routes. It ensures that when a blueprint is copied with `allow_route_overwrite=True`, the new route can successfully replace the existing one.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that:\n1. The original blueprint (`bpv1`) correctly responds to requests at its route.\n2. The copied blueprint (`bpv2`) can overwrite the route of `bpv1` and respond correctly to requests.\n3. A second copy (`bpv3`) can be created without overwriting the route of `bpv1`, and it also responds correctly.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the Sanic application and its blueprint functionality. The test creates an initial blueprint (`bpv1`) with a route that returns \"v1\". It then creates two copies of this blueprint:\n- `bpv2`, which allows route overwriting, and defines a new handler that returns \"v2\".\n- `bpv3`, which does not overwrite the route and defines a handler that returns \"v3\".\n\nThe test then makes GET requests to the respective routes (`/v1/my_api`, `/v2/my_api`, and `/v3/my_api`) and asserts that the responses are as expected (status 200 and the correct text).\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Blueprint Copying**: The test demonstrates the use of blueprint copying in Sanic, showcasing how to manage route versions and overwriting.\n- **Asynchronous Testing**: The test uses asynchronous route handlers, which is a common pattern in web frameworks to handle I/O-bound operations efficiently.\n- **Assertions**: The test employs assertions to validate the response status and content, ensuring that the application behaves as intended under different configurations of the blueprints.\n- **Isolation of Tests**: Each blueprint is registered independently, allowing for clear separation of concerns and ensuring that the test results are not affected by other tests."
    },
    {
      "name": "test_reload_listeners",
      "module": "test_reloader",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_reloader.py",
      "line_number": 219,
      "end_line_number": 243,
      "source_code": "def test_reload_listeners():\n    with TemporaryDirectory() as tmpdir:\n        filename = os.path.join(tmpdir, \"reloader.py\")\n        start_text, stop_text = write_listener_app(\n            filename, port=42305, auto_reload=True\n        )\n\n        proc = Popen(\n            argv[\"script\"], cwd=tmpdir, stdout=PIPE, creationflags=flags\n        )\n        try:\n            timeout = Timer(TIMER_DELAY, terminate, [proc])\n            timeout.start()\n            # Python apparently keeps using the old source sometimes if\n            # we don't sleep before rewrite (pycache timestamp problem?)\n            sleep(1)\n            line = scanner(proc, \"reload_start\")\n            assert start_text in next(line)\n            line = scanner(proc, \"reload_stop\")\n            assert stop_text in next(line)\n        finally:\n            timeout.cancel()\n            terminate(proc)\n            with suppress(TimeoutExpired):\n                proc.wait(timeout=3)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "os",
        "secrets",
        "sys",
        "contextlib.suppress",
        "subprocess.PIPE",
        "subprocess.Popen",
        "subprocess.TimeoutExpired",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "threading.Timer",
        "time.sleep",
        "pytest",
        "signal.CTRL_BREAK_EVENT",
        "subprocess.CREATE_NEW_PROCESS_GROUP"
      ],
      "fixtures": [],
      "assertions": [
        "assert start_text in next(line)",
        "assert stop_text in next(line)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "write_listener_app",
          "body": "def write_listener_app(filename, **runargs):\n    start_text = secrets.token_urlsafe()\n    stop_text = secrets.token_urlsafe()\n    with open(filename, 'w') as f:\n        f.write(dedent(f'            import os\\n            from sanic import Sanic\\n\\n            app = Sanic(__name__)\\n\\n            app.route(\"/\")(lambda x: x)\\n\\n            @app.reload_process_start\\n            async def reload_start(*_):\\n                print(\"reload_start\", os.getpid(), {start_text!r})\\n\\n            @app.reload_process_stop\\n            async def reload_stop(*_):\\n                print(\"reload_stop\", os.getpid(), {stop_text!r})\\n\\n            if __name__ == \"__main__\":\\n                app.run(**{runargs!r})\\n            '))\n    return (start_text, stop_text)"
        },
        {
          "name": "timeout.start",
          "body": "def start(self):\n    worker_process.set_state(ProcessState.ACKED)\n    self._target()"
        },
        {
          "name": "scanner",
          "body": "def scanner(proc, trigger='complete'):\n    for line in proc.stdout:\n        line = line.decode().strip()\n        if line.startswith(trigger):\n            yield line"
        },
        {
          "name": "scanner",
          "body": "def scanner(proc, trigger='complete'):\n    for line in proc.stdout:\n        line = line.decode().strip()\n        if line.startswith(trigger):\n            yield line"
        },
        {
          "name": "terminate",
          "body": "def terminate(proc):\n    if flags:\n        proc.send_signal(CTRL_BREAK_EVENT)\n    else:\n        proc.terminate()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_reload_listeners` function is to verify that the Sanic application correctly triggers and handles the `reload_process_start` and `reload_process_stop` events when the application is reloaded. This ensures that the application behaves as expected during the reload process, specifically that the appropriate messages are printed to the standard output.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the output from the Sanic application includes specific text (`start_text` and `stop_text`) that indicates the successful execution of the `reload_process_start` and `reload_process_stop` listeners. This confirms that the application is correctly invoking these listeners during the reload process.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `write_listener_app` function, which generates a Python script that defines a Sanic application with two listeners: one for the start of the reload process and another for its stop. The `Popen` function is used to run this script in a separate process, allowing the test to capture its output. The `scanner` function reads the output from the process, looking for lines that start with \"reload_start\" and \"reload_stop\". The test asserts that the generated `start_text` and `stop_text` are present in the output, indicating that the listeners were triggered correctly.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Temporary Directory**: The use of `TemporaryDirectory` ensures that the test does not interfere with the filesystem, creating a clean environment for the test to run.\n- **Process Management**: The test employs `Popen` to run the Sanic application in a separate process, allowing for isolation and capturing of output.\n- **Timeout Handling**: A `Timer` is used to ensure that the test does not hang indefinitely if the process does not terminate as expected. This is a common pattern in tests involving external processes.\n- **Assertions**: The test uses assertions to validate that the expected output is produced, which is a fundamental aspect of unit testing to ensure correctness.\n- **Graceful Cleanup**: The `finally` block ensures that resources are cleaned up properly, regardless of whether the test passes or fails, which is crucial for maintaining a stable testing environment."
    },
    {
      "name": "test_touchup_methods",
      "module": "test_touchup",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_touchup.py",
      "line_number": 11,
      "end_line_number": 12,
      "source_code": "def test_touchup_methods(app):\n    assert len(TouchUp._registry) == 9",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic_routing.exceptions.NotFound",
        "sanic.signals.RESERVED_NAMESPACES",
        "sanic.touchup.TouchUp"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(TouchUp._registry) == 9"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_touchup_methods` test is to verify that the `TouchUp` class's `_registry` attribute contains exactly 9 entries at the time the test is executed. This ensures that the registration mechanism for touch-up methods is functioning correctly and that the expected number of methods have been registered.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks the integrity of the `_registry` set within the `TouchUp` class. It asserts that the number of registered methods (or targets) is equal to 9, which implies that the registration process has been executed correctly and that no methods have been inadvertently added or removed.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `TouchUp` class, specifically its `_registry` attribute, which is a set that holds tuples of target classes and their corresponding method names. The `register` class method is responsible for adding entries to this registry. The test does not directly invoke any methods of the `TouchUp` class but relies on the state of `_registry` to confirm that the expected number of methods has been registered.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a simple assertion to validate the state of the `_registry`. It uses the `assert` statement to check the length of the set, which is a straightforward and effective way to verify expected outcomes in unit tests. The absence of setup or teardown methods indicates that the test assumes a specific state of the application or environment prior to execution, which is common in unit tests that focus on static attributes or configurations."
    },
    {
      "name": "test_raises_warning_if_os_is_windows",
      "module": "test_server_loop",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_server_loop.py",
      "line_number": 15,
      "end_line_number": 29,
      "source_code": "def test_raises_warning_if_os_is_windows(caplog):\n    with caplog.at_level(logging.WARNING):\n        loop.try_use_uvloop()\n\n    for record in caplog.records:\n        if record.message.startswith(\"You are trying to use\"):\n            break\n\n    assert record.message == (\n        \"You are trying to use uvloop, but uvloop is not compatible \"\n        \"with your system. You can disable uvloop completely by setting \"\n        \"the 'USE_UVLOOP' configuration value to false, or simply not \"\n        \"defining it and letting Sanic handle it for you. Sanic will now \"\n        \"continue to run using the default event loop.\"\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(not OS_IS_WINDOWS, reason='Not testable with current client')"
      ],
      "arguments": [
        "caplog"
      ],
      "imports": [
        "logging",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.compat.UVLOOP_INSTALLED",
        "sanic.server.loop",
        "uvloop"
      ],
      "fixtures": [],
      "assertions": [
        "assert record.message == \"You are trying to use uvloop, but uvloop is not compatible with your system. You can disable uvloop completely by setting the 'USE_UVLOOP' configuration value to false, or simply not defining it and letting Sanic handle it for you. Sanic will now continue to run using the default event loop.\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_raises_warning_if_os_is_windows` is designed to verify that when the Sanic application attempts to use the `uvloop` event loop on a Windows operating system, it correctly raises a warning indicating that `uvloop` is not compatible with the system. This ensures that users are informed about the limitations of using `uvloop` on Windows.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that a specific warning message is logged when the `try_use_uvloop` function is called under the condition that the operating system is Windows. It confirms that the warning message accurately describes the situation and provides guidance on how to proceed (i.e., disabling `uvloop`).\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `try_use_uvloop` function, which checks if the operating system is Windows using the `OS_IS_WINDOWS` constant. If it is, the function logs a warning message indicating that `uvloop` cannot be used and suggests configuration options for the user. The test uses the `caplog` fixture from `pytest` to capture log messages at the WARNING level during the execution of `try_use_uvloop`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `caplog` fixture to capture log output, allowing for verification of logged messages without altering the actual logging configuration. It also uses the `@pytest.mark.skipif` decorator to conditionally skip the test if the operating system is not Windows, ensuring that the test only runs in the appropriate environment. This pattern helps maintain test relevance and efficiency by avoiding unnecessary test executions in unsupported environments."
    },
    {
      "name": "test_raises_warning_if_uvloop_not_installed",
      "module": "test_server_loop",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_server_loop.py",
      "line_number": 36,
      "end_line_number": 51,
      "source_code": "def test_raises_warning_if_uvloop_not_installed(caplog):\n    with caplog.at_level(logging.WARNING):\n        loop.try_use_uvloop()\n\n    for record in caplog.records:\n        if record.message.startswith(\"You are trying to use\"):\n            break\n\n    assert record.message == (\n        \"You are trying to use uvloop, but uvloop is not \"\n        \"installed in your system. In order to use uvloop \"\n        \"you must first install it. Otherwise, you can disable \"\n        \"uvloop completely by setting the 'USE_UVLOOP' \"\n        \"configuration value to false. Sanic will now continue \"\n        \"to run with the default event loop.\"\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(OS_IS_WINDOWS or UVLOOP_INSTALLED, reason='Not testable with current client')"
      ],
      "arguments": [
        "caplog"
      ],
      "imports": [
        "logging",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.compat.UVLOOP_INSTALLED",
        "sanic.server.loop",
        "uvloop"
      ],
      "fixtures": [],
      "assertions": [
        "assert record.message == \"You are trying to use uvloop, but uvloop is not installed in your system. In order to use uvloop you must first install it. Otherwise, you can disable uvloop completely by setting the 'USE_UVLOOP' configuration value to false. Sanic will now continue to run with the default event loop.\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_raises_warning_if_uvloop_not_installed` is designed to verify that a specific warning message is logged when the `uvloop` library is not installed on the system, and an attempt is made to use it within the Sanic framework.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when `loop.try_use_uvloop()` is called, and `uvloop` is not available, the appropriate warning message is generated. The warning informs the user that `uvloop` is not installed and provides guidance on how to either install it or disable its usage in the Sanic configuration.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `try_use_uvloop` function from the `sanic.server.loop` module. This function attempts to import the `uvloop` library. If the import fails (due to `uvloop` not being installed), it logs a warning message using the `error_logger`. The test captures log messages at the WARNING level using the `caplog` fixture from pytest, allowing it to assert that the expected warning message is present in the logs.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Log Capture**: The test utilizes the `caplog` fixture to capture log messages generated during the execution of the code under test. This is a common technique in testing to verify that the correct logging behavior occurs.\n- **Assertion on Log Content**: The test iterates through the captured log records to find a specific message, ensuring that the warning is not only logged but also contains the expected content.\n- **Conditional Skipping**: The test is marked with `@pytest.mark.skipif`, which conditionally skips the test based on the environment (e.g., if `uvloop` is installed or if the OS is Windows), ensuring that the test only runs in appropriate conditions."
    },
    {
      "name": "test_logs_when_install_and_runtime_config_mismatch",
      "module": "test_server_loop",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_server_loop.py",
      "line_number": 58,
      "end_line_number": 85,
      "source_code": "def test_logs_when_install_and_runtime_config_mismatch(caplog, monkeypatch):\n    getenv = Mock(return_value=\"no\")\n    monkeypatch.setattr(loop, \"getenv\", getenv)\n\n    with caplog.at_level(logging.INFO):\n        loop.try_use_uvloop()\n\n    getenv.assert_called_once_with(\"SANIC_NO_UVLOOP\", \"no\")\n    assert caplog.record_tuples == []\n\n    getenv = Mock(return_value=\"yes\")\n    monkeypatch.setattr(loop, \"getenv\", getenv)\n    with caplog.at_level(logging.INFO):\n        loop.try_use_uvloop()\n\n    getenv.assert_called_once_with(\"SANIC_NO_UVLOOP\", \"no\")\n    for record in caplog.records:\n        if record.message.startswith(\"You are requesting to run\"):\n            break\n\n    assert record.message == (\n        \"You are requesting to run Sanic using uvloop, but the \"\n        \"install-time 'SANIC_NO_UVLOOP' environment variable (used to \"\n        \"opt-out of installing uvloop with Sanic) is set to true. If \"\n        \"you want to prevent Sanic from overriding the event loop policy \"\n        \"during runtime, set the 'USE_UVLOOP' configuration value to \"\n        \"false.\"\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(OS_IS_WINDOWS or not UVLOOP_INSTALLED, reason='Not testable with current client')"
      ],
      "arguments": [
        "caplog",
        "monkeypatch"
      ],
      "imports": [
        "logging",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.compat.UVLOOP_INSTALLED",
        "sanic.server.loop",
        "uvloop"
      ],
      "fixtures": [],
      "assertions": [
        "assert caplog.record_tuples == []",
        "assert record.message == \"You are requesting to run Sanic using uvloop, but the install-time 'SANIC_NO_UVLOOP' environment variable (used to opt-out of installing uvloop with Sanic) is set to true. If you want to prevent Sanic from overriding the event loop policy during runtime, set the 'USE_UVLOOP' configuration value to false.\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_logs_when_install_and_runtime_config_mismatch` verifies that the Sanic application correctly logs a warning message when there is a mismatch between the install-time configuration (indicated by the `SANIC_NO_UVLOOP` environment variable) and the runtime configuration regarding the use of `uvloop`.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two scenarios: \n1. When the `SANIC_NO_UVLOOP` environment variable is set to \"no\", it ensures that no log messages are generated.\n2. When the variable is set to \"yes\", it verifies that a specific warning message is logged, indicating that the application is attempting to use `uvloop` despite the install-time configuration suggesting otherwise.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `try_use_uvloop` function from the `loop` module. This function checks the value of the `SANIC_NO_UVLOOP` environment variable to determine whether to use `uvloop`. The test uses `monkeypatch` to mock the `getenv` function, simulating different return values for the environment variable. The `caplog` fixture captures log messages generated during the execution of `try_use_uvloop`, allowing assertions on the logged output.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test uses `Mock` to simulate the behavior of the `getenv` function, allowing control over the environment variable's return value.\n- **Monkeypatching**: The `monkeypatch` fixture is employed to replace the actual `getenv` function with the mock, enabling isolated testing of the logging behavior.\n- **Log Capture**: The `caplog` fixture captures log messages at a specified logging level, facilitating assertions on the content and presence of log entries.\n- **Assertions**: The test includes assertions to verify that the expected log messages are generated (or not generated) based on the mocked environment variable values."
    },
    {
      "name": "test_sets_loop_policy_only_when_not_already_set",
      "module": "test_server_loop",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_server_loop.py",
      "line_number": 92,
      "end_line_number": 116,
      "source_code": "def test_sets_loop_policy_only_when_not_already_set(monkeypatch):\n    import uvloop  # type: ignore\n\n    # Existing policy is not uvloop.EventLoopPolicy\n    get_event_loop_policy = Mock(return_value=None)\n    monkeypatch.setattr(\n        loop.asyncio, \"get_event_loop_policy\", get_event_loop_policy\n    )\n\n    with patch(\"asyncio.set_event_loop_policy\") as set_event_loop_policy:\n        loop.try_use_uvloop()\n        set_event_loop_policy.assert_called_once()\n        args, _ = set_event_loop_policy.call_args\n        policy = args[0]\n        assert isinstance(policy, uvloop.EventLoopPolicy)\n\n    # Existing policy is uvloop.EventLoopPolicy\n    get_event_loop_policy = Mock(return_value=policy)\n    monkeypatch.setattr(\n        loop.asyncio, \"get_event_loop_policy\", get_event_loop_policy\n    )\n\n    with patch(\"asyncio.set_event_loop_policy\") as set_event_loop_policy:\n        loop.try_use_uvloop()\n        set_event_loop_policy.assert_not_called()",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(OS_IS_WINDOWS or not UVLOOP_INSTALLED, reason='Not testable with current client')"
      ],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "logging",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.compat.UVLOOP_INSTALLED",
        "sanic.server.loop",
        "uvloop"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(policy, uvloop.EventLoopPolicy)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_sets_loop_policy_only_when_not_already_set` aims to verify the behavior of the `try_use_uvloop` function in the context of setting the event loop policy. It checks that the `uvloop.EventLoopPolicy` is set only when there is no existing event loop policy already in place.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically verifies two scenarios: \n1. When there is no existing event loop policy, it ensures that `asyncio.set_event_loop_policy` is called with an instance of `uvloop.EventLoopPolicy`.\n2. When the existing event loop policy is already set to `uvloop.EventLoopPolicy`, it confirms that `asyncio.set_event_loop_policy` is not called, indicating that the policy should not be changed.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `try_use_uvloop` function, which is expected to interact with the asyncio event loop. The test uses `monkeypatch` to mock the behavior of `asyncio.get_event_loop_policy` to simulate different scenarios regarding the current event loop policy. It then uses `patch` to monitor calls to `asyncio.set_event_loop_policy` to assert whether it was called or not, and with what arguments.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable testing techniques:\n- **Mocking**: It uses `Mock` to simulate the return values of `get_event_loop_policy`, allowing the test to control the environment without needing a real event loop.\n- **Monkeypatching**: The `monkeypatch` fixture is used to replace the actual `get_event_loop_policy` method with a mock, enabling the test to manipulate the behavior of the asyncio library.\n- **Assertions**: The test includes assertions to verify that the correct policy is set or that no action is taken when the policy is already set, ensuring that the function behaves as expected under different conditions."
    },
    {
      "name": "test_request_stream_method_view",
      "module": "test_request_stream",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request_stream.py",
      "line_number": 15,
      "end_line_number": 38,
      "source_code": "def test_request_stream_method_view(app):\n    class SimpleView(HTTPMethodView):\n        def get(self, request):\n            return text(\"OK\")\n\n        @stream_decorator\n        async def post(self, request):\n            result = b\"\"\n            while True:\n                body = await request.stream.read()\n                if body is None:\n                    break\n                result += body\n            return text(result.decode())\n\n    app.add_route(SimpleView.as_view(), \"/method_view\")\n\n    request, response = app.test_client.get(\"/method_view\")\n    assert response.status == 200\n    assert response.text == \"OK\"\n\n    request, response = app.test_client.post(\"/method_view\", data=data)\n    assert response.status == 200\n    assert response.text == data",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.views.HTTPMethodView",
        "sanic.views.stream"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'OK'",
        "assert response.status == 200",
        "assert response.text == data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_request_stream_method_view` is to verify the behavior of a Sanic application when handling HTTP requests using a method view that supports streaming. It specifically tests the `GET` and `POST` methods of a view to ensure they return the expected responses.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the `GET` request to the `/method_view` endpoint returns a status code of 200 and the text \"OK\". It also verifies that a `POST` request to the same endpoint correctly reads streamed data and returns it as a response, confirming that the streaming functionality works as intended.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a `SimpleView` class that inherits from `HTTPMethodView`. It defines two methods: `get`, which returns a static response of \"OK\", and `post`, which reads data from the request stream in chunks until no more data is available, concatenates it, and returns the result as text. The test client simulates HTTP requests to the application, allowing the test to assert the correctness of the responses.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of a test client provided by the Sanic framework to simulate HTTP requests and capture responses. It uses assertions to validate the status codes and response content, ensuring that the application behaves as expected under different request methods. The use of a streaming decorator (`@stream_decorator`) is also notable, as it allows the `post` method to handle incoming data in a non-blocking manner, which is essential for efficient handling of large payloads."
    },
    {
      "name": "test_request_stream_100_continue",
      "module": "test_request_stream",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request_stream.py",
      "line_number": 51,
      "end_line_number": 75,
      "source_code": "def test_request_stream_100_continue(app, headers, expect_raise_exception):\n    class SimpleView(HTTPMethodView):\n        @stream_decorator\n        async def post(self, request):\n            result = \"\"\n            while True:\n                body = await request.stream.read()\n                if body is None:\n                    break\n                result += body.decode(\"utf-8\")\n            return text(result)\n\n    app.add_route(SimpleView.as_view(), \"/method_view\")\n\n    if not expect_raise_exception:\n        request, response = app.test_client.post(\n            \"/method_view\", data=data, headers=headers\n        )\n        assert response.status == 200\n        assert response.text == data\n    else:\n        request, response = app.test_client.post(\n            \"/method_view\", data=data, headers=headers\n        )\n        assert response.status == 417",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('headers, expect_raise_exception', [({'EXPECT': '100-continue'}, False)])"
      ],
      "arguments": [
        "app",
        "headers",
        "expect_raise_exception"
      ],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.views.HTTPMethodView",
        "sanic.views.stream"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == data",
        "assert response.status == 417"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_request_stream_100_continue` function is designed to verify the behavior of a Sanic application when handling HTTP POST requests with a streaming body. Specifically, it tests how the application responds to requests that may or may not trigger a 100 Continue response, depending on the provided headers and the expectation of whether an exception should be raised.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two scenarios based on the `expect_raise_exception` flag:\n1. If `expect_raise_exception` is `False`, it verifies that a valid POST request to the `/method_view` endpoint returns a 200 status code and the correct response body.\n2. If `expect_raise_exception` is `True`, it ensures that the application responds with a 417 status code, indicating that the expectation of the client was not met (typically related to the 100 Continue behavior).\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a `SimpleView` class that defines an asynchronous POST method decorated with `@stream_decorator`. This method reads the request body in a streaming fashion until no more data is available, concatenating the received chunks into a single string. The response is then returned as plain text. The test adds this view to the Sanic app and simulates POST requests to it, checking the response status and body based on the input conditions.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterized Testing**: The test uses the `expect_raise_exception` parameter to control the flow of the test, allowing it to validate multiple outcomes based on a single test function.\n- **Asynchronous Testing**: The test leverages asynchronous programming patterns, which are essential for handling I/O-bound operations like streaming data in web applications.\n- **Assertions**: The test employs assertions to validate the expected outcomes, ensuring that the application behaves correctly under different scenarios."
    },
    {
      "name": "test_request_stream_app",
      "module": "test_request_stream",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request_stream.py",
      "line_number": 78,
      "end_line_number": 175,
      "source_code": "def test_request_stream_app(app):\n    @app.get(\"/get\")\n    async def get(request):\n        return text(\"GET\")\n\n    @app.head(\"/head\")\n    async def head(request):\n        return text(\"HEAD\")\n\n    @app.delete(\"/delete\")\n    async def delete(request):\n        return text(\"DELETE\")\n\n    @app.options(\"/options\")\n    async def options(request):\n        return text(\"OPTIONS\")\n\n    @app.post(\"/_post/<id>\")\n    async def _post(request, id):\n        return text(\"_POST\")\n\n    @app.post(\"/post/<id>\", stream=True)\n    async def post(request, id):\n        result = \"\"\n        while True:\n            body = await request.stream.read()\n            if body is None:\n                break\n            result += body.decode(\"utf-8\")\n        return text(result)\n\n    @app.put(\"/_put\")\n    async def _put(request):\n        return text(\"_PUT\")\n\n    @app.put(\"/put\", stream=True)\n    async def put(request):\n        result = \"\"\n        while True:\n            body = await request.stream.read()\n            if body is None:\n                break\n            result += body.decode(\"utf-8\")\n        return text(result)\n\n    @app.patch(\"/_patch\")\n    async def _patch(request):\n        return text(\"_PATCH\")\n\n    @app.patch(\"/patch\", stream=True)\n    async def patch(request):\n        result = \"\"\n        while True:\n            body = await request.stream.read()\n            if body is None:\n                break\n            result += body.decode(\"utf-8\")\n        return text(result)\n\n    request, response = app.test_client.get(\"/get\")\n    assert response.status == 200\n    assert response.text == \"GET\"\n\n    request, response = app.test_client.head(\"/head\")\n    assert response.status == 200\n    assert response.text == \"\"\n\n    request, response = app.test_client.delete(\"/delete\")\n    assert response.status == 200\n    assert response.text == \"DELETE\"\n\n    request, response = app.test_client.options(\"/options\")\n    assert response.status == 200\n    assert response.text == \"OPTIONS\"\n\n    request, response = app.test_client.post(\"/_post/1\", data=data)\n    assert response.status == 200\n    assert response.text == \"_POST\"\n\n    request, response = app.test_client.post(\"/post/1\", data=data)\n    assert response.status == 200\n    assert response.text == data\n\n    request, response = app.test_client.put(\"/_put\", data=data)\n    assert response.status == 200\n    assert response.text == \"_PUT\"\n\n    request, response = app.test_client.put(\"/put\", data=data)\n    assert response.status == 200\n    assert response.text == data\n\n    request, response = app.test_client.patch(\"/_patch\", data=data)\n    assert response.status == 200\n    assert response.text == \"_PATCH\"\n\n    request, response = app.test_client.patch(\"/patch\", data=data)\n    assert response.status == 200\n    assert response.text == data",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.views.HTTPMethodView",
        "sanic.views.stream"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'GET'",
        "assert response.status == 200",
        "assert response.text == ''",
        "assert response.status == 200",
        "assert response.text == 'DELETE'",
        "assert response.status == 200",
        "assert response.text == 'OPTIONS'",
        "assert response.status == 200",
        "assert response.text == '_POST'",
        "assert response.status == 200",
        "assert response.text == data",
        "assert response.status == 200",
        "assert response.text == '_PUT'",
        "assert response.status == 200",
        "assert response.text == data",
        "assert response.status == 200",
        "assert response.text == '_PATCH'",
        "assert response.status == 200",
        "assert response.text == data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "app.patch('/_patch')",
        "app.patch('/patch', stream=True)",
        "app.test_client.patch('/_patch', data=data)",
        "app.test_client.patch('/patch', data=data)"
      ],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.head",
          "body": "def head(self, request):\n    return text('', headers={'method': 'HEAD'})"
        },
        {
          "name": "app.delete",
          "body": "def delete(self, request):\n    return text('I am delete method')"
        },
        {
          "name": "app.options",
          "body": "def options(self, request):\n    return text('', headers={'method': 'OPTIONS'})"
        },
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "app.patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.head",
          "body": "def head(self, request):\n    return text('', headers={'method': 'HEAD'})"
        },
        {
          "name": "app.test_client.delete",
          "body": "def delete(self, request):\n    return text('I am delete method')"
        },
        {
          "name": "app.test_client.options",
          "body": "def options(self, request):\n    return text('', headers={'method': 'OPTIONS'})"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.test_client.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.test_client.patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "app.test_client.patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_request_stream_app` is to verify the correct behavior of various HTTP methods (GET, HEAD, DELETE, OPTIONS, POST, PUT, PATCH) in a Sanic web application, particularly focusing on both standard and streaming request handling.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that each HTTP method returns the expected status code (200) and response body. It specifically verifies that the application can handle streaming data for POST, PUT, and PATCH requests, ensuring that the data sent in the request body is correctly processed and returned.\n\n**Code Being Tested and How It Works**:  \nThe code defines several asynchronous route handlers for different HTTP methods using the Sanic framework. Each handler returns a simple text response based on the method invoked. For POST, PUT, and PATCH methods with `stream=True`, the handlers read the request body in chunks until no more data is available, concatenating the received data and returning it as the response. The test client simulates requests to these endpoints and asserts the correctness of the responses.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the response status and body, ensuring that the application behaves as expected under various conditions. It also utilizes asynchronous programming patterns, leveraging `async` and `await` to handle non-blocking I/O operations, which is crucial for testing web applications that may handle multiple requests concurrently. The use of a test client to simulate HTTP requests is a common pattern in testing web applications, allowing for comprehensive coverage of the application's endpoints."
    },
    {
      "name": "test_request_stream_handle_exception",
      "module": "test_request_stream",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request_stream.py",
      "line_number": 279,
      "end_line_number": 300,
      "source_code": "def test_request_stream_handle_exception(app):\n    \"\"\"for handling exceptions properly\"\"\"\n\n    @app.post(\"/post/<id>\", stream=True)\n    async def post(request, id):\n        result = b\"\"\n        while True:\n            body = await request.stream.read()\n            if body is None:\n                break\n            result += body\n        return text(result.decode())\n\n    # 404\n    request, response = app.test_client.post(\"/in_valid_post\", data=data)\n    assert response.status == 404\n    assert \"Requested URL /in_valid_post not found\" in response.text\n\n    # 405\n    request, response = app.test_client.get(\"/post/random_id\")\n    assert response.status == 405\n    assert \"Method GET not allowed for URL /post/random_id\" in response.text",
      "docstring": "for handling exceptions properly",
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.views.HTTPMethodView",
        "sanic.views.stream"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 404",
        "assert 'Requested URL /in_valid_post not found' in response.text",
        "assert response.status == 405",
        "assert 'Method GET not allowed for URL /post/random_id' in response.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_request_stream_handle_exception` test is to verify that the Sanic application correctly handles HTTP request errors, specifically returning appropriate status codes and error messages for invalid routes and methods.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks two specific scenarios: \n1. It verifies that a POST request to an invalid URL (`/in_valid_post`) returns a 404 Not Found status, along with a relevant error message.\n2. It checks that a GET request to a valid POST route (`/post/random_id`) returns a 405 Method Not Allowed status, confirming that the method is not permitted for that endpoint.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the route handler defined for POST requests at `/post/<id>`, which reads data from the request stream. The test client simulates HTTP requests to this route and an invalid route. The application is expected to return appropriate HTTP status codes and messages based on the request type and URL validity. The `app.test_client.post` and `app.test_client.get` methods are used to send requests and receive responses.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the response status and content, which is a common pattern in unit testing. It also utilizes the Sanic testing client to simulate HTTP requests, allowing for the verification of route behavior without needing to run a live server. The test is structured to clearly separate different scenarios (404 and 405 errors), making it easy to understand the expected outcomes for each case."
    },
    {
      "name": "test_request_stream_blueprint",
      "module": "test_request_stream",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request_stream.py",
      "line_number": 303,
      "end_line_number": 420,
      "source_code": "def test_request_stream_blueprint(app):\n    bp = Blueprint(\"test_blueprint_request_stream_blueprint\")\n\n    @app.get(\"/get\")\n    async def get(request):\n        return text(\"GET\")\n\n    @bp.head(\"/head\")\n    async def head(request):\n        return text(\"HEAD\")\n\n    @bp.delete(\"/delete\")\n    async def delete(request):\n        return text(\"DELETE\")\n\n    @bp.options(\"/options\")\n    async def options(request):\n        return text(\"OPTIONS\")\n\n    @bp.post(\"/_post/<id>\")\n    async def _post(request, id):\n        return text(\"_POST\")\n\n    @bp.post(\"/post/<id>\", stream=True)\n    async def post(request, id):\n        result = \"\"\n        while True:\n            body = await request.stream.read()\n            if body is None:\n                break\n            result += body.decode(\"utf-8\")\n        return text(result)\n\n    @bp.put(\"/_put\")\n    async def _put(request):\n        return text(\"_PUT\")\n\n    @bp.put(\"/put\", stream=True)\n    async def put(request):\n        result = \"\"\n        while True:\n            body = await request.stream.read()\n            if body is None:\n                break\n            result += body.decode(\"utf-8\")\n        return text(result)\n\n    @bp.patch(\"/_patch\")\n    async def _patch(request):\n        return text(\"_PATCH\")\n\n    @bp.patch(\"/patch\", stream=True)\n    async def patch(request):\n        result = \"\"\n        while True:\n            body = await request.stream.read()\n            if body is None:\n                break\n            result += body.decode(\"utf-8\")\n        return text(result)\n\n    async def post_add_route(request):\n        result = \"\"\n        while True:\n            body = await request.stream.read()\n            if body is None:\n                break\n            result += body.decode(\"utf-8\")\n        return text(result)\n\n    bp.add_route(\n        post_add_route, \"/post/add_route\", methods=[\"POST\"], stream=True\n    )\n    app.blueprint(bp)\n\n    request, response = app.test_client.get(\"/get\")\n    assert response.status == 200\n    assert response.text == \"GET\"\n\n    request, response = app.test_client.head(\"/head\")\n    assert response.status == 200\n    assert response.text == \"\"\n\n    request, response = app.test_client.delete(\"/delete\")\n    assert response.status == 200\n    assert response.text == \"DELETE\"\n\n    request, response = app.test_client.options(\"/options\")\n    assert response.status == 200\n    assert response.text == \"OPTIONS\"\n\n    request, response = app.test_client.post(\"/_post/1\", data=data)\n    assert response.status == 200\n    assert response.text == \"_POST\"\n\n    request, response = app.test_client.post(\"/post/1\", data=data)\n    assert response.status == 200\n    assert response.text == data\n\n    request, response = app.test_client.put(\"/_put\", data=data)\n    assert response.status == 200\n    assert response.text == \"_PUT\"\n\n    request, response = app.test_client.put(\"/put\", data=data)\n    assert response.status == 200\n    assert response.text == data\n\n    request, response = app.test_client.patch(\"/_patch\", data=data)\n    assert response.status == 200\n    assert response.text == \"_PATCH\"\n\n    request, response = app.test_client.patch(\"/patch\", data=data)\n    assert response.status == 200\n    assert response.text == data\n\n    request, response = app.test_client.post(\"/post/add_route\", data=data)\n    assert response.status == 200\n    assert response.text == data",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.views.HTTPMethodView",
        "sanic.views.stream"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'GET'",
        "assert response.status == 200",
        "assert response.text == ''",
        "assert response.status == 200",
        "assert response.text == 'DELETE'",
        "assert response.status == 200",
        "assert response.text == 'OPTIONS'",
        "assert response.status == 200",
        "assert response.text == '_POST'",
        "assert response.status == 200",
        "assert response.text == data",
        "assert response.status == 200",
        "assert response.text == '_PUT'",
        "assert response.status == 200",
        "assert response.text == data",
        "assert response.status == 200",
        "assert response.text == '_PATCH'",
        "assert response.status == 200",
        "assert response.text == data",
        "assert response.status == 200",
        "assert response.text == data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "bp.patch('/_patch')",
        "bp.patch('/patch', stream=True)",
        "app.test_client.patch('/_patch', data=data)",
        "app.test_client.patch('/patch', data=data)"
      ],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp.head",
          "body": "def head(self, request):\n    return text('', headers={'method': 'HEAD'})"
        },
        {
          "name": "bp.delete",
          "body": "def delete(self, request):\n    return text('I am delete method')"
        },
        {
          "name": "bp.options",
          "body": "def options(self, request):\n    return text('', headers={'method': 'OPTIONS'})"
        },
        {
          "name": "bp.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "bp.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "bp.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "bp.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "bp.patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "bp.patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.head",
          "body": "def head(self, request):\n    return text('', headers={'method': 'HEAD'})"
        },
        {
          "name": "app.test_client.delete",
          "body": "def delete(self, request):\n    return text('I am delete method')"
        },
        {
          "name": "app.test_client.options",
          "body": "def options(self, request):\n    return text('', headers={'method': 'OPTIONS'})"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.test_client.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.test_client.patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "app.test_client.patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_request_stream_blueprint` test is to verify the correct behavior of various HTTP methods (GET, HEAD, DELETE, OPTIONS, POST, PUT, PATCH) when interacting with a Sanic application that utilizes a blueprint for routing. It ensures that the application correctly handles requests and responses, particularly focusing on streaming data for POST, PUT, and PATCH methods.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that each defined route responds with the expected status code and response body. It verifies that the application can handle both standard and streaming requests, ensuring that data sent in the body of POST, PUT, and PATCH requests is correctly read and returned. The test also confirms that the application can handle different HTTP methods appropriately.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes a Sanic application with a blueprint that defines several routes. Each route is associated with an HTTP method and returns a specific response. For example, the GET route returns \"GET\", while the POST route reads streamed data from the request body and returns it. The test client simulates requests to these routes, checking the status and response content to ensure they match expected values.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the response status and body for each request, ensuring that the application behaves as intended. It also utilizes asynchronous programming patterns, as indicated by the use of `async def` for route handlers and the `await` keyword for reading streamed data. This reflects a common pattern in modern web applications that handle I/O-bound operations efficiently. Additionally, the test leverages the Sanic test client to simulate HTTP requests, which is a standard technique for testing web applications."
    },
    {
      "name": "test_request_stream",
      "module": "test_request_stream",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request_stream.py",
      "line_number": 423,
      "end_line_number": 507,
      "source_code": "def test_request_stream(app):\n    \"\"\"test for complex application\"\"\"\n    bp = Blueprint(\"test_blueprint_request_stream\")\n\n    class SimpleView(HTTPMethodView):\n        def get(self, request):\n            return text(\"OK\")\n\n        @stream_decorator\n        async def post(self, request):\n            result = \"\"\n            while True:\n                body = await request.stream.read()\n                if body is None:\n                    break\n                result += body.decode(\"utf-8\")\n            return text(result)\n\n    @app.post(\"/stream\", stream=True)\n    async def handler(request):\n        result = \"\"\n        while True:\n            body = await request.stream.read()\n            if body is None:\n                break\n            result += body.decode(\"utf-8\")\n        return text(result)\n\n    @app.get(\"/get\")\n    async def get(request):\n        return text(\"OK\")\n\n    @bp.post(\"/bp_stream\", stream=True)\n    async def bp_stream(request):\n        result = \"\"\n        while True:\n            body = await request.stream.read()\n            if body is None:\n                break\n            result += body.decode(\"utf-8\")\n        return text(result)\n\n    @bp.get(\"/bp_get\")\n    async def bp_get(request):\n        return text(\"OK\")\n\n    def get_handler(request):\n        return text(\"OK\")\n\n    async def post_handler(request):\n        result = \"\"\n        while True:\n            body = await request.stream.read()\n            if body is None:\n                break\n            result += body.decode(\"utf-8\")\n        return text(result)\n\n    app.add_route(SimpleView.as_view(), \"/method_view\")\n\n    app.blueprint(bp)\n\n    request, response = app.test_client.get(\"/method_view\")\n    assert response.status == 200\n    assert response.text == \"OK\"\n\n    request, response = app.test_client.post(\"/method_view\", data=data)\n    assert response.status == 200\n    assert response.text == data\n\n    request, response = app.test_client.get(\"/get\")\n    assert response.status == 200\n    assert response.text == \"OK\"\n\n    request, response = app.test_client.post(\"/stream\", data=data)\n    assert response.status == 200\n    assert response.text == data\n\n    request, response = app.test_client.get(\"/bp_get\")\n    assert response.status == 200\n    assert response.text == \"OK\"\n\n    request, response = app.test_client.post(\"/bp_stream\", data=data)\n    assert response.status == 200\n    assert response.text == data",
      "docstring": "test for complex application",
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.views.HTTPMethodView",
        "sanic.views.stream"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'OK'",
        "assert response.status == 200",
        "assert response.text == data",
        "assert response.status == 200",
        "assert response.text == 'OK'",
        "assert response.status == 200",
        "assert response.text == data",
        "assert response.status == 200",
        "assert response.text == 'OK'",
        "assert response.status == 200",
        "assert response.text == data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "bp.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_request_stream` function is designed to verify the behavior of a Sanic web application that handles streaming requests. It tests various endpoints to ensure they correctly process both GET and POST requests, particularly focusing on the handling of streamed data.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the application can successfully handle streaming data in POST requests, returning the expected results. It verifies that the application responds correctly to both standard and blueprint routes, ensuring that the data sent in the request body is accurately received and processed.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes several route handlers defined for the Sanic application. Each handler processes incoming requests, particularly focusing on the `post` methods that read from the request stream. The test sends requests to various endpoints (e.g., `/method_view`, `/stream`, `/bp_stream`) and asserts that the response status is 200 and that the response text matches the data sent. The `stream_decorator` is used to indicate that the handler should expect streamed data.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test leverages asynchronous programming patterns, using `async def` for route handlers and `await` for reading from the request stream, which is essential for handling I/O-bound operations in a non-blocking manner.\n- **Blueprints**: The use of blueprints allows for modular organization of routes, which is tested by asserting the functionality of both the main app routes and those defined in the blueprint.\n- **Assertions**: The test employs assertions to validate the response status and content, ensuring that the application behaves as expected under various scenarios.\n- **Data Streaming**: The test specifically focuses on the streaming capabilities of the application, ensuring that data can be read in chunks and that the application can handle continuous data input until the stream is closed."
    },
    {
      "name": "test_streaming_new_api",
      "module": "test_request_stream",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request_stream.py",
      "line_number": 510,
      "end_line_number": 547,
      "source_code": "def test_streaming_new_api(app):\n    @app.post(\"/non-stream\")\n    async def handler1(request):\n        assert request.body == b\"x\"\n        await request.receive_body()  # This should do nothing\n        assert request.body == b\"x\"\n        return text(\"OK\")\n\n    @app.post(\"/1\", stream=True)\n    async def handler2(request):\n        assert request.stream\n        assert not request.body\n        await request.receive_body()\n        return text(request.body.decode().upper())\n\n    @app.post(\"/2\", stream=True)\n    async def handler(request):\n        ret = []\n        async for data in request.stream:\n            # We should have no b\"\" or None, just proper chunks\n            assert data\n            assert isinstance(data, bytes)\n            ret.append(data.decode(\"ASCII\"))\n        return json(ret)\n\n    request, response = app.test_client.post(\"/non-stream\", data=\"x\")\n    assert response.status == 200\n\n    request, response = app.test_client.post(\"/1\", data=\"TEST data\")\n    assert request.body == b\"TEST data\"\n    assert response.status == 200\n    assert response.text == \"TEST DATA\"\n\n    request, response = app.test_client.post(\"/2\", data=data)\n    assert response.status == 200\n    res = response.json\n    assert isinstance(res, list)\n    assert \"\".join(res) == data",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.views.HTTPMethodView",
        "sanic.views.stream"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert request.body == b'TEST data'",
        "assert response.status == 200",
        "assert response.text == 'TEST DATA'",
        "assert response.status == 200",
        "assert isinstance(res, list)",
        "assert ''.join(res) == data",
        "assert request.body == b'x'",
        "assert request.body == b'x'",
        "assert request.stream",
        "assert not request.body",
        "assert data",
        "assert isinstance(data, bytes)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_streaming_new_api` function is designed to verify the behavior of various HTTP POST endpoints in a Sanic web application, specifically focusing on how the application handles streaming requests and the integrity of request body data.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. The `/non-stream` endpoint correctly handles a non-streaming request and retains the request body.\n2. The `/1` endpoint processes a streaming request, ensuring that the request body is empty after calling `receive_body()`, and returns the body in uppercase.\n3. The `/2` endpoint correctly streams data, ensuring that it receives proper chunks of data and returns them as a JSON list.\n\n**Code Being Tested and How It Works**:  \nThe test defines three asynchronous request handlers:\n- `handler1` for the `/non-stream` endpoint, which asserts that the request body remains unchanged after calling `receive_body()`.\n- `handler2` for the `/1` endpoint, which checks that the request is a stream and that the body is empty before processing.\n- `handler` for the `/2` endpoint, which reads from the request stream in chunks, asserting that each chunk is valid and appending it to a list, which is then returned as JSON.\n\nThe test then simulates POST requests to these endpoints using `app.test_client.post`, asserting the expected status codes and response contents.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test utilizes asynchronous functions to handle requests, which is essential for testing web applications that operate in an asynchronous environment.\n- **Assertions**: The test employs multiple assertions to validate the state of the request and response, ensuring that the application behaves as expected under different scenarios.\n- **Stream Handling**: The test specifically verifies the handling of streaming data, which is crucial for applications that need to process large amounts of data efficiently without loading everything into memory at once."
    },
    {
      "name": "test_streaming_echo",
      "module": "test_request_stream",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request_stream.py",
      "line_number": 550,
      "end_line_number": 623,
      "source_code": "def test_streaming_echo():\n    \"\"\"2-way streaming chat between server and client.\"\"\"\n    app = Sanic(name=\"Test\")\n\n    @app.post(\"/echo\", stream=True)\n    async def handler(request):\n        res = await request.respond(content_type=\"text/plain; charset=utf-8\")\n        # Send headers\n        await res.send(end_stream=False)\n        # Echo back data (case swapped)\n        async for data in request.stream:\n            await res.send(data.swapcase())\n        # Add EOF marker after successful operation\n        await res.send(b\"-\", end_stream=True)\n\n    @app.listener(\"after_server_start\")\n    async def client_task(app, loop):\n        try:\n            reader, writer = await asyncio.open_connection(\"localhost\", 8000)\n            await client(app, reader, writer)\n        finally:\n            writer.close()\n            app.stop()\n\n    async def client(app, reader, writer):\n        # httpx doesn't support 2-way streaming,so do it by hand.\n        host = \"host: localhost:8000\\r\\n\".encode()\n        writer.write(\n            b\"POST /echo HTTP/1.1\\r\\n\" + host + b\"content-length: 2\\r\\n\"\n            b\"content-type: text/plain; charset=utf-8\\r\\n\"\n            b\"\\r\\n\"\n        )\n        # Read response\n        res = b\"\"\n        while b\"\\r\\n\\r\\n\" not in res:\n            res += await reader.read(4096)\n        assert res.startswith(b\"HTTP/1.1 200 OK\\r\\n\")\n        assert res.endswith(b\"\\r\\n\\r\\n\")\n        buffer = b\"\"\n\n        async def read_chunk():\n            nonlocal buffer\n            while b\"\\r\\n\" not in buffer:\n                data = await reader.read(4096)\n                assert data\n                buffer += data\n            size, buffer = buffer.split(b\"\\r\\n\", 1)\n            size = int(size, 16)\n            if size == 0:\n                return None\n            while len(buffer) < size + 2:\n                data = await reader.read(4096)\n                assert data\n                buffer += data\n            assert buffer[size : size + 2] == b\"\\r\\n\"\n            ret, buffer = buffer[:size], buffer[size + 2 :]\n            return ret\n\n        # Chat with server\n        writer.write(b\"a\")\n        res = await read_chunk()\n        assert res == b\"A\"\n\n        writer.write(b\"b\")\n        res = await read_chunk()\n        assert res == b\"B\"\n\n        res = await read_chunk()\n        assert res == b\"-\"\n\n        res = await read_chunk()\n        assert res is None\n\n    app.run(access_log=False, single_process=True)",
      "docstring": "2-way streaming chat between server and client.",
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.views.HTTPMethodView",
        "sanic.views.stream"
      ],
      "fixtures": [],
      "assertions": [
        "assert res.startswith(b'HTTP/1.1 200 OK\\r\\n')",
        "assert res.endswith(b'\\r\\n\\r\\n')",
        "assert res == b'A'",
        "assert res == b'B'",
        "assert res == b'-'",
        "assert res is None",
        "assert buffer[size:size + 2] == b'\\r\\n'",
        "assert data",
        "assert data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "res.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "res.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        },
        {
          "name": "res.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "client",
          "body": "@pytest.fixture\ndef client(runner: ReusableClient):\n    client = namedtuple('Client', ('raw', 'send', 'recv'))\n    raw = RawClient(runner.host, runner.port)\n    runner._run(raw.connect())\n\n    def send(msg):\n        nonlocal runner\n        nonlocal raw\n        runner._run(raw.send(msg))\n\n    def recv(**kwargs):\n        nonlocal runner\n        nonlocal raw\n        method = raw.recv_until if 'until' in kwargs else raw.recv\n        return runner._run(method(**kwargs))\n    yield client(raw, send, recv)\n    runner._run(raw.close())"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_streaming_echo` function is designed to verify the functionality of a 2-way streaming chat between a Sanic server and a client. It ensures that the server correctly echoes back data sent by the client, with the case of the characters swapped, and that it properly handles the end of the stream.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when the client sends data to the server, the server responds with the swapped case of the input data. It also verifies that the server sends an end-of-file (EOF) marker after processing the input and that the client can correctly read and interpret the server's responses.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes an asynchronous Sanic application with a POST endpoint `/echo`. The handler for this endpoint reads data from the request stream, swaps the case of the received data, and sends it back to the client. The `client_task` function establishes a connection to the server and sends a POST request with data. The `client` function handles the reading of the server's response, ensuring that the data is processed correctly and that the expected responses are received.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Asynchronous Testing**: It uses `async` and `await` to handle asynchronous operations, which is crucial for testing I/O-bound applications like web servers.\n- **Direct Socket Communication**: Instead of using a higher-level HTTP client, the test manually constructs HTTP requests and reads responses, allowing for fine-grained control over the communication process.\n- **Assertions for Response Validation**: The test includes multiple assertions to validate the correctness of the responses received from the server, ensuring that the behavior matches expectations at each step of the interaction."
    },
    {
      "name": "test_can_raise_in_handler",
      "module": "test_cancellederror",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cancellederror.py",
      "line_number": 6,
      "end_line_number": 17,
      "source_code": "def test_can_raise_in_handler(app: Sanic):\n    @app.get(\"/\")\n    async def handler(request: Request):\n        raise CancelledError(\"STOP!!\")\n\n    @app.exception(CancelledError)\n    async def handle_cancel(request: Request, exc: CancelledError):\n        return json({\"message\": exc.args[0]}, status=418)\n\n    _, response = app.test_client.get(\"/\")\n    assert response.status == 418\n    assert response.json[\"message\"] == \"STOP!!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio.CancelledError",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 418",
        "assert response.json['message'] == 'STOP!!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.exception",
          "body": "@app.route('/')\ndef exception(request):\n    raise SanicExceptionTestException(\"You won't see me\")"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_can_raise_in_handler` test is to verify that the Sanic application correctly handles exceptions raised within route handlers. Specifically, it checks that a `CancelledError` raised in the handler is caught and processed by the defined exception handler, returning the appropriate HTTP response.\n\n**Specific Functionality or Behavior Verified**:  \nThis test confirms that when a `CancelledError` is raised, the application responds with a status code of 418 (I'm a teapot) and includes a JSON message containing the error message \"STOP!!\". This ensures that the exception handling mechanism is functioning as intended.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route handler for the root path (\"/\") that raises a `CancelledError`. It also defines an exception handler for `CancelledError` that returns a JSON response with a specific message and status code. The test then simulates a GET request to the root path using `app.test_client.get(\"/\")`, capturing the response. The assertions check that the response status is 418 and that the JSON message matches the expected output.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Exception Handling**: The test demonstrates the use of custom exception handling in a web framework, ensuring that specific exceptions can be caught and processed to provide meaningful responses.\n- **Asynchronous Testing**: The use of `async` functions indicates that the test is designed to work with asynchronous code, which is common in modern web frameworks like Sanic.\n- **Assertions**: The test employs assertions to validate the response's status code and content, ensuring that the application behaves correctly under error conditions."
    },
    {
      "name": "test_parse_headers",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 68,
      "end_line_number": 69,
      "source_code": "def test_parse_headers(input, expected):\n    assert headers.parse_content_header(input) == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('input, expected', [('text/plain', ('text/plain', {})), ('text/vnd.just.made.this.up ; ', ('text/vnd.just.made.this.up', {})), ('text/plain;charset=us-ascii', ('text/plain', {'charset': 'us-ascii'})), ('text/plain ; charset=\"us-ascii\"', ('text/plain', {'charset': 'us-ascii'})), ('text/plain ; charset=\"us-ascii\"; another=opt', ('text/plain', {'charset': 'us-ascii', 'another': 'opt'})), ('attachment; filename=\"silly.txt\"', ('attachment', {'filename': 'silly.txt'})), ('attachment; filename=\"strange;name\"', ('attachment', {'filename': 'strange;name'})), ('attachment; filename=\"strange;name\";size=123;', ('attachment', {'filename': 'strange;name', 'size': '123'})), ('form-data; name=\"foo\"; value=\"%22\\\\%0D%0A\"', ('form-data', {'name': 'foo', 'value': '\"\\\\\\n'})), ('form-data; name=\"foo%22;bar\\\\\"; filename=\"\ud83d\ude00\"', ('form-data', {'name': 'foo\";bar\\\\', 'filename': '\ud83d\ude00'}))])"
      ],
      "arguments": [
        "input",
        "expected"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [
        "assert headers.parse_content_header(input) == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_parse_headers` function is designed to verify the correctness of the `headers.parse_content_header` function, ensuring that it accurately parses content-type and content-disposition header values into a tuple containing the main type and a dictionary of options.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the `parse_content_header` function correctly interprets various input strings representing headers, returning the expected tuple format. It validates that the function can handle both simple and complex header values, including those with parameters.\n\n**Code Being Tested and How It Works**:  \nThe `parse_content_header` function takes a string input representing a header value. It looks for a semicolon to separate the main type from any parameters. If parameters are present, it uses a regular expression to extract key-value pairs, handling special characters like escaped quotes and newlines. The function returns a tuple where the first element is the main type (in lowercase) and the second element is a dictionary of parsed options.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs parameterization via `pytest.mark.parametrize`, allowing multiple input-output pairs to be tested in a single function call. This approach enhances test coverage and reduces code duplication. The use of assertions directly compares the output of the function under test with the expected results, providing a clear pass/fail outcome for each test case."
    },
    {
      "name": "test_raw_headers",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 150,
      "end_line_number": 166,
      "source_code": "def test_raw_headers(app):\n    app.route(\"/\")(lambda _: text(\"\"))\n    request, _ = app.test_client.get(\n        \"/\",\n        headers={\n            \"FOO\": \"bar\",\n            \"Host\": \"example.com\",\n            \"User-Agent\": \"Sanic-Testing\",\n        },\n    )\n\n    assert b\"Host: example.com\" in request.raw_headers\n    assert b\"Accept: */*\" in request.raw_headers\n    assert b\"Accept-Encoding: gzip, deflate\" in request.raw_headers\n    assert b\"Connection: keep-alive\" in request.raw_headers\n    assert b\"User-Agent: Sanic-Testing\" in request.raw_headers\n    assert b\"FOO: bar\" in request.raw_headers",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [
        "assert b'Host: example.com' in request.raw_headers",
        "assert b'Accept: */*' in request.raw_headers",
        "assert b'Accept-Encoding: gzip, deflate' in request.raw_headers",
        "assert b'Connection: keep-alive' in request.raw_headers",
        "assert b'User-Agent: Sanic-Testing' in request.raw_headers",
        "assert b'FOO: bar' in request.raw_headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_raw_headers` function is designed to verify that the Sanic application correctly captures and returns the raw HTTP headers sent in a request. This ensures that the application can handle and process headers as expected, which is crucial for proper request handling and response generation.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that specific headers, including custom headers (like \"FOO\") and standard headers (like \"Host\" and \"User-Agent\"), are present in the `request.raw_headers` attribute after making a GET request to the root endpoint. It also verifies that default headers such as \"Accept\" and \"Connection\" are included, ensuring that the application correctly processes and retains all relevant headers.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the Sanic framework's routing and request handling capabilities. The test sets up a route for the root path (\"/\") that returns an empty text response. It then simulates a GET request to this route with a set of headers. The `app.test_client.get` method is used to perform the request, and the resulting `request` object is checked for the presence of the specified headers in its `raw_headers` attribute. This attribute is expected to contain the raw HTTP headers as byte strings.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the following patterns and techniques:\n- **Direct Assertion**: It uses assertions to directly check the presence of specific byte strings in the `request.raw_headers`, which is a straightforward way to validate the expected outcome.\n- **Setup and Teardown**: The test sets up a route and simulates a request within the same function, which is a common practice in unit tests to isolate the test environment.\n- **Parameterization**: While not used in this specific test, the surrounding tests in the codebase utilize parameterization (e.g., `@pytest.mark.parametrize`) to run multiple scenarios with different inputs, showcasing a flexible testing approach."
    },
    {
      "name": "test_request_line",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 169,
      "end_line_number": 180,
      "source_code": "def test_request_line(app):\n    app.route(\"/\")(lambda _: text(\"\"))\n    request, _ = app.test_client.get(\n        \"/\",\n        headers={\n            \"FOO\": \"bar\",\n            \"Host\": \"example.com\",\n            \"User-Agent\": \"Sanic-Testing\",\n        },\n    )\n\n    assert request.request_line == b\"GET / HTTP/1.1\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.request_line == b'GET / HTTP/1.1'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_request_line` function is designed to verify that the request line of an HTTP GET request made to a Sanic application is correctly formatted. Specifically, it checks that the request line matches the expected format of \"GET / HTTP/1.1\".\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a GET request is made to the root endpoint (\"/\") of the application, the request line is constructed properly, reflecting the HTTP method, the requested path, and the HTTP version. The assertion checks that the request line is exactly `b\"GET / HTTP/1.1\"`.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `app.test_client.get` method, which simulates an HTTP GET request to the Sanic application. The `app.route(\"/\")` decorator defines a route for the root path that returns an empty text response. The test client then sends a GET request to this route with specific headers. The resulting `request` object contains the `request_line` attribute, which is what the test verifies against the expected value.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern to validate the expected output against the actual output. It uses the Sanic testing client to simulate requests, which is a common technique in unit testing web applications. The use of headers in the request also demonstrates how to test the behavior of the application under different conditions, although the headers themselves do not affect the request line in this specific test."
    },
    {
      "name": "test_parse_accept_ordered_okay",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 199,
      "end_line_number": 202,
      "source_code": "def test_parse_accept_ordered_okay(raw, expected_subtype):\n    ordered = headers.parse_accept(raw)\n    assert ordered[0].type == \"show\"\n    assert ordered[0].subtype == expected_subtype",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('raw,expected_subtype', (('show/first, show/second', 'first'), ('show/*, show/first', 'first'), ('*/*, show/first', 'first'), ('*/*, show/*', '*'), ('other/*; q=0.1, show/*; q=0.2', '*'), ('show/first; q=0.5, show/second; q=0.5', 'first'), ('show/first; foo=bar, show/second; foo=bar', 'first'), ('show/second, show/first; foo=bar', 'first'), ('show/second; q=0.5, show/first; foo=bar; q=0.5', 'first'), ('show/second; q=0.5, show/first; q=1.0', 'first'), ('show/first, show/second; q=1.0', 'second')))"
      ],
      "arguments": [
        "raw",
        "expected_subtype"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [
        "assert ordered[0].type == 'show'",
        "assert ordered[0].subtype == expected_subtype"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_parse_accept_ordered_okay` is designed to verify the correct parsing and ordering of media types from an HTTP `Accept` header. It ensures that the `parse_accept` function correctly identifies and orders media types based on their specified subtype.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a valid `Accept` header is parsed, the first media type in the resulting list has a type of \"show\" and matches the expected subtype provided as an argument. This confirms that the parsing logic correctly prioritizes and structures the media types according to the rules defined in the relevant RFC.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `parse_accept` function, which takes an `Accept` header string as input and returns an ordered list of `MediaType` objects. The function splits the input string by commas, parses each media type, and sorts them based on their quality values (q-values) and other parameters. If the input is invalid or empty, it handles these cases gracefully by returning default values or raising exceptions.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs parameterization (though not explicitly shown in the provided snippet) to allow for multiple input scenarios, enhancing test coverage without duplicating code. It uses assertions to validate the expected outcomes, ensuring that the test is both clear and effective in confirming the behavior of the `parse_accept` function. The use of specific attributes (like `type` and `subtype`) in assertions helps to pinpoint the exact behavior being tested."
    },
    {
      "name": "test_bad_accept",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 214,
      "end_line_number": 216,
      "source_code": "def test_bad_accept(raw):\n    with pytest.raises(InvalidHeader):\n        headers.parse_accept(raw)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('raw', ('missing', 'missing/', '/missing', '/'))"
      ],
      "arguments": [
        "raw"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_bad_accept` function is designed to verify that the `headers.parse_accept` method correctly raises an `InvalidHeader` exception when provided with invalid input in the `raw` parameter. This ensures that the method handles erroneous cases gracefully and adheres to expected behavior.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks the error handling capability of the `parse_accept` function. It confirms that when an invalid header value is passed, the function does not proceed with parsing but instead raises the appropriate exception, `InvalidHeader`. This is crucial for maintaining robustness in the application by preventing invalid data from being processed.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `headers.parse_accept(raw)` function, which is expected to parse the `raw` string input representing HTTP Accept headers. The test uses the `pytest.raises` context manager to assert that an `InvalidHeader` exception is raised when `parse_accept` is called with the invalid `raw` input. The `raw` parameter is likely a string that does not conform to the expected format of Accept headers.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager, a common pattern in unit testing that allows for the verification of exceptions. This technique is effective for testing error conditions, ensuring that the code behaves as expected when faced with invalid input. Additionally, the use of parameterization in other tests (not shown in this specific test) indicates a broader strategy in the test suite to cover multiple scenarios efficiently."
    },
    {
      "name": "test_empty_accept",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 219,
      "end_line_number": 222,
      "source_code": "def test_empty_accept():\n    a = headers.parse_accept(\"\")\n    assert a == []\n    assert not a.match(\"*/*\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [
        "assert a == []",
        "assert not a.match('*/*')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_empty_accept` function is designed to verify the behavior of the `headers.parse_accept` function when it receives an empty string as input. It ensures that the function correctly interprets an empty Accept header and returns an empty list, indicating that no media types are accepted.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two specific outcomes: \n1. When the input is an empty string, the output should be an empty list (`[]`).\n2. The `match` method of the returned object should return `False` when attempting to match any media type (in this case, `*/*`), confirming that no types are accepted.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `parse_accept` function, which is responsible for parsing the Accept header according to RFC 7231. When an empty string is passed, the function checks if the input is empty and returns an empty `AcceptList`, which signifies that no media types are accepted. The `match` method is expected to return `False` for any media type when the Accept list is empty.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs simple assertions to validate the expected outcomes. It uses direct comparisons to check the output of the `parse_accept` function and the behavior of the `match` method. This straightforward approach is effective for unit testing, as it clearly defines the expected state of the system under test and verifies it without additional complexity."
    },
    {
      "name": "test_wildcard_accept_set_ok",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 225,
      "end_line_number": 239,
      "source_code": "def test_wildcard_accept_set_ok():\n    accept = headers.parse_accept(\"*/*\")[0]\n    assert accept.type == \"*\"\n    assert accept.subtype == \"*\"\n    assert accept.has_wildcard\n\n    accept = headers.parse_accept(\"foo/*\")[0]\n    assert accept.type == \"foo\"\n    assert accept.subtype == \"*\"\n    assert accept.has_wildcard\n\n    accept = headers.parse_accept(\"foo/bar\")[0]\n    assert accept.type == \"foo\"\n    assert accept.subtype == \"bar\"\n    assert not accept.has_wildcard",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [
        "assert accept.type == '*'",
        "assert accept.subtype == '*'",
        "assert accept.has_wildcard",
        "assert accept.type == 'foo'",
        "assert accept.subtype == '*'",
        "assert accept.has_wildcard",
        "assert accept.type == 'foo'",
        "assert accept.subtype == 'bar'",
        "assert not accept.has_wildcard"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_wildcard_accept_set_ok` function is designed to verify the correct parsing and handling of media type accept headers, specifically focusing on wildcard types and their behavior in the `headers` module of the Sanic framework.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks three scenarios: \n1. Parsing the wildcard accept header `*/*` to ensure it correctly identifies both type and subtype as wildcards.\n2. Parsing a specific type with a wildcard subtype, `foo/*`, to confirm that the type is recognized as `foo` and the subtype as a wildcard.\n3. Parsing a specific media type `foo/bar` to ensure that both type and subtype are correctly identified without any wildcards.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `headers.parse_accept` function, which processes accept headers and returns a structured representation of the media types. The test asserts that the returned object has the expected `type`, `subtype`, and `has_wildcard` attributes, which indicate whether wildcards are present in the parsed media type.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs direct assertions to validate the state of the parsed accept headers. It uses a straightforward approach to check the attributes of the returned object, ensuring that the parsing logic correctly interprets various media type formats. This method of testing is effective for verifying the correctness of parsing functions, as it directly correlates input strings with expected object properties."
    },
    {
      "name": "test_accept_parsed_against_str",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 242,
      "end_line_number": 244,
      "source_code": "def test_accept_parsed_against_str():\n    accept = headers.Matched.parse(\"foo/bar\")\n    assert accept == \"foo/bar; q=0.1\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [
        "assert accept == 'foo/bar; q=0.1'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_accept_parsed_against_str` is designed to verify the correct parsing and representation of an \"Accept\" header value using the `headers.Matched.parse` method. It ensures that the method correctly formats the input string \"foo/bar\" into the expected output string \"foo/bar; q=0.1\".\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the parsing function appends the correct quality value (`q=0.1`) to the input string. It validates that the output matches the expected format, which is crucial for handling HTTP headers that dictate content negotiation.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `headers.Matched.parse` method, which takes a string representing a media type (in this case, \"foo/bar\") and returns a formatted string that includes a quality value. The expected behavior is that the method should append `; q=0.1` to the input string, indicating a default quality factor for the media type.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a simple assertion pattern, using `assert` to compare the actual output of the parsing function against the expected output. This straightforward approach is effective for unit tests, as it clearly indicates whether the function behaves as intended. The absence of setup or teardown methods suggests that this test is isolated and does not depend on external state, which is a good practice in unit testing."
    },
    {
      "name": "test_media_type_matching",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 247,
      "end_line_number": 251,
      "source_code": "def test_media_type_matching():\n    assert headers.MediaType(\"foo\", \"bar\").match(\n        headers.MediaType(\"foo\", \"bar\")\n    )\n    assert headers.MediaType(\"foo\", \"bar\").match(\"foo/bar\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [
        "assert headers.MediaType('foo', 'bar').match(headers.MediaType('foo', 'bar'))",
        "assert headers.MediaType('foo', 'bar').match('foo/bar')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_media_type_matching` function is designed to verify the behavior of the `match` method in the `MediaType` class, ensuring that it correctly identifies when two media types are compatible.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two scenarios: \n1. It asserts that a `MediaType` instance created with the type \"foo\" and subtype \"bar\" matches another instance with the same type and subtype.\n2. It verifies that the same `MediaType` instance matches a string representation of the media type \"foo/bar\".\n\n**Code Being Tested and How It Works**:  \nThe `match` method in the `MediaType` class compares the current instance's type and subtype against another `MediaType` instance or a string. It checks for exact matches, wildcard compatibility, and ensures that any parameters associated with the media types are also compatible. The method returns the current instance if they match or `None` if they do not.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs direct assertions to validate expected outcomes, which is a common pattern in unit testing. It uses simple equality checks to confirm that the `match` method behaves as intended for both `MediaType` instances and string inputs, ensuring that the method's logic for matching media types is robust and reliable."
    },
    {
      "name": "test_accept_matching",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 278,
      "end_line_number": 279,
      "source_code": "def test_accept_matching(value, other, outcome):\n    assert bool(headers.Matched.parse(value).match(other)) is outcome",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('value,other,outcome', (('foo/bar', 'foo/bar', True), ('foo/bar', headers.Matched.parse('foo/bar'), True), ('foo/bar', 'foo/*', True), ('foo/bar', headers.Matched.parse('foo/*'), True), ('foo/bar', '*/*', True), ('foo/bar', headers.Matched.parse('*/*'), True), ('foo/*', 'foo/bar', True), ('foo/*', headers.Matched.parse('foo/bar'), True), ('foo/*', 'foo/*', True), ('foo/*', headers.Matched.parse('foo/*'), True), ('foo/*', '*/*', True), ('foo/*', headers.Matched.parse('*/*'), True), ('*/*', 'foo/bar', True), ('*/*', headers.Matched.parse('foo/bar'), True), ('*/*', 'foo/*', True), ('*/*', headers.Matched.parse('foo/*'), True), ('*/*', '*/*', True), ('*/*', headers.Matched.parse('*/*'), True)))"
      ],
      "arguments": [
        "value",
        "other",
        "outcome"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [
        "assert bool(headers.Matched.parse(value).match(other)) is outcome"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_accept_matching` function is designed to verify the behavior of the `headers.Matched.parse(value).match(other)` method, ensuring that it correctly determines whether a given value matches another value based on specific criteria defined in the `Matched` class.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks if the result of the match operation (a boolean indicating whether the two values match) corresponds to the expected outcome (`outcome`). It uses parameterized inputs to test various combinations of `value`, `other`, and `outcome`, allowing for comprehensive coverage of matching scenarios.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `headers.Matched` class, specifically its `parse` method, which processes a string representation of headers and returns a `Matched` object. The `match` method of this object is then called with another value (`other`) to determine if it matches the parsed value. The assertion checks if the boolean result of this match operation aligns with the expected outcome.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.mark.parametrize` decorator, which allows for the execution of the same test logic with multiple sets of input data. This technique enhances test coverage and reduces code duplication by systematically testing various scenarios in a single test function. Additionally, the use of assertions ensures that the test fails if the actual behavior does not meet the expected results, providing immediate feedback on the correctness of the implementation."
    },
    {
      "name": "test_value_in_accept",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 283,
      "end_line_number": 287,
      "source_code": "def test_value_in_accept(value):\n    acceptable = headers.parse_accept(value)\n    assert acceptable.match(\"foo/bar\")\n    assert acceptable.match(\"foo/*\")\n    assert acceptable.match(\"*/*\")",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('value', ('foo/bar', 'foo/*', '*/*'))"
      ],
      "arguments": [
        "value"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [
        "assert acceptable.match('foo/bar')",
        "assert acceptable.match('foo/*')",
        "assert acceptable.match('*/*')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_value_in_accept` function is designed to verify that the `parse_accept` function correctly interprets various `Accept` header values and that the resulting `AcceptList` can successfully match specific media types.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the `AcceptList` generated from the `value` parameter (which can be \"foo/bar\", \"foo/*\", or \"*/*\") can match the media types \"foo/bar\", \"foo/*\", and \"*/*\". It ensures that the parsing logic correctly identifies these media types as acceptable based on the rules defined in the HTTP specification.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `parse_accept` function, which takes an `Accept` header string and returns an `AcceptList` of media types ordered by preference. The `AcceptList` is expected to support matching against specific media types, including wildcards. The test uses the `match` method of the `AcceptList` to assert that the parsed values can match the specified media types.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.mark.parametrize` decorator to run the same test logic with multiple input values, promoting code reuse and clarity. This approach allows for easy expansion of test cases by simply adding more parameters without duplicating the test logic. Additionally, the use of assertions directly checks the expected outcomes, ensuring that the behavior of the `parse_accept` function aligns with the expected media type matching rules."
    },
    {
      "name": "test_value_not_in_accept",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 291,
      "end_line_number": 296,
      "source_code": "def test_value_not_in_accept(value):\n    acceptable = headers.parse_accept(value)\n    assert not acceptable.match(\"no/match\")\n    assert not acceptable.match(\"no/*\")\n    assert \"*/*\" not in acceptable\n    assert \"*/bar\" not in acceptable",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('value', ('foo/bar', 'foo/*'))"
      ],
      "arguments": [
        "value"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [
        "assert not acceptable.match('no/match')",
        "assert not acceptable.match('no/*')",
        "assert '*/*' not in acceptable",
        "assert '*/bar' not in acceptable"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_value_not_in_accept` function is designed to verify that certain media types are not accepted when specific `Accept` header values are parsed. It ensures that the parsing logic correctly identifies and excludes media types that do not match the specified acceptable values.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the `acceptable` object, which is the result of parsing the `Accept` header, does not match certain non-acceptable media types. Specifically, it asserts that:\n- The media type \"no/match\" is not accepted.\n- The wildcard media type \"no/*\" is not accepted.\n- The generic wildcard \"*/*\" is not included in the acceptable list.\n- The media type \"*/bar\" is also not included in the acceptable list.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `headers.parse_accept(value)` function, which takes a string representing the `Accept` header and returns an `AcceptList` object. This object contains media types that are deemed acceptable based on the input value. The test uses various values for the `Accept` header (e.g., \"foo/bar\", \"foo/*\") to ensure that the parsing logic correctly excludes media types that do not match the specified patterns.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses `pytest.mark.parametrize` to run the same test logic with multiple input values, allowing for efficient testing of different scenarios without duplicating code.\n- **Assertions**: The test employs assertions to validate the expected outcomes, ensuring that the behavior of the `parse_accept` function aligns with the intended logic of media type matching as defined by the HTTP specification.\n- **Negative Testing**: The test focuses on negative cases, confirming that certain values are explicitly not accepted, which is crucial for robust input validation in web applications."
    },
    {
      "name": "test_browser_headers_general",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 315,
      "end_line_number": 317,
      "source_code": "def test_browser_headers_general(header, expected):\n    request = Request(b\"/\", {\"accept\": header}, \"1.1\", \"GET\", None, None)\n    assert [str(item) for item in request.accept] == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('header,expected', (('text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8', ['text/html', 'application/xhtml+xml', 'image/avif', 'image/webp', 'application/xml;q=0.9', '*/*;q=0.8']),))"
      ],
      "arguments": [
        "header",
        "expected"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [
        "assert [str(item) for item in request.accept] == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_browser_headers_general` function is designed to verify that the `Request` object correctly parses and represents the `Accept` header from an HTTP request. It ensures that the parsed `accept` values match the expected output.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the `accept` attribute of the `Request` object, which is derived from the `Accept` header, accurately reflects the expected MIME types. It validates that the string representation of each item in the `request.accept` list corresponds to the provided `expected` values.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `Request` class from the Sanic framework, specifically its handling of the `Accept` header. When a `Request` object is instantiated with a given `Accept` header, it processes this header to create a list of acceptable MIME types. The test constructs a `Request` object with a specific `header` and then asserts that the string representations of the parsed `accept` values match the `expected` list.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs parameterized testing, which allows it to run multiple scenarios with different inputs (`header` and `expected` values) without duplicating code. This is a common practice in unit testing to ensure comprehensive coverage of various input cases. The use of assertions to compare the actual output against expected results is a fundamental aspect of unit testing, ensuring that the code behaves as intended."
    },
    {
      "name": "test_browser_headers_specific",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 336,
      "end_line_number": 344,
      "source_code": "def test_browser_headers_specific(header, expected):\n    mimes = [e[0] for e in expected]\n    qs = [e[1] for e in expected]\n    request = Request(b\"/\", {\"accept\": header}, \"1.1\", \"GET\", None, None)\n    assert request.accept == mimes\n    for a, m, q in zip(request.accept, mimes, qs):\n        assert a == m\n        assert a.mime == m\n        assert a.q == q",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('header,expected', (('text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8', [('text/html', 1.0), ('application/xhtml+xml', 1.0), ('image/avif', 1.0), ('image/webp', 1.0), ('application/xml', 0.9), ('*/*', 0.8)]),))"
      ],
      "arguments": [
        "header",
        "expected"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.accept == mimes",
        "assert a == m",
        "assert a.mime == m",
        "assert a.q == q"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_browser_headers_specific` function is designed to verify that the `Request` object correctly parses and represents the `Accept` HTTP header. It ensures that the `accept` attribute of the `Request` object matches the expected MIME types and their associated quality values (q-values).\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the `Request` object accurately reflects the MIME types and their priorities as specified in the `Accept` header. It validates that the parsed `accept` list contains the correct MIME types and that each entry has the expected properties, including the MIME type and its q-value.\n\n**Code Being Tested and How It Works**:  \nThe test creates a `Request` object with a specified `Accept` header and then extracts the expected MIME types and q-values from the `expected` parameter. It asserts that the `request.accept` matches the expected MIME types. It further iterates through the parsed `accept` list to ensure that each entry's MIME type and q-value are as expected. The `Request` class is expected to handle the parsing of the `Accept` header correctly, which is crucial for content negotiation in HTTP.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test is likely part of a parameterized test suite, allowing it to run multiple scenarios with different `header` and `expected` values. This approach enhances test coverage and ensures that various input cases are validated without duplicating code.\n- **Assertions**: The test employs multiple assertions to verify different aspects of the `Request` object's behavior, ensuring that both the overall structure and individual components of the parsed `accept` list are correct.\n- **Data-Driven Testing**: By using the `expected` parameter, the test can validate against a variety of expected outcomes, making it flexible and robust against changes in the input data."
    },
    {
      "name": "test_accept_ordering",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 358,
      "end_line_number": 365,
      "source_code": "def test_accept_ordering(raw):\n    \"\"\"Should sort by q but also be stable.\"\"\"\n    accept = headers.parse_accept(raw)\n    assert accept[0].type == \"text\"\n    raw1 = \", \".join(str(a) for a in accept)\n    accept = headers.parse_accept(raw1)\n    raw2 = \", \".join(str(a) for a in accept)\n    assert raw1 == raw2",
      "docstring": "Should sort by q but also be stable.",
      "decorators": [
        "pytest.mark.parametrize('raw', ('text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8', 'application/xml;q=0.9, */*;q=0.8, text/html, application/xhtml+xml', 'foo/bar;q=0.9, */*;q=0.8, text/html=0.8, text/plain, application/xhtml+xml'))"
      ],
      "arguments": [
        "raw"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [
        "assert accept[0].type == 'text'",
        "assert raw1 == raw2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_accept_ordering` function is designed to verify that the `parse_accept` function correctly sorts media types based on their quality values (`q`), while also ensuring that the sorting is stable. This means that if two media types have the same `q` value, their original order in the input string should be preserved in the output.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main assertions: \n1. The first media type in the parsed list should be of type \"text\", indicating that it is prioritized based on the `q` values.\n2. The serialized representation of the parsed media types (after sorting) should match the original input string when parsed again, confirming that the parsing and serialization processes are consistent.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `parse_accept` function, which takes an `Accept` header string and returns a list of `MediaType` objects sorted by their `q` values. The function splits the input string by commas, parses each media type, and sorts them based on their `q` values. The test uses various input strings to ensure that the parsing and sorting logic behaves as expected.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterized Testing**: The test uses the `@pytest.mark.parametrize` decorator to run the same test logic with multiple input strings, allowing for efficient testing of different scenarios without duplicating code.\n- **Assertions**: The test employs assertions to validate the expected outcomes, ensuring that both the type of the first media type and the consistency of the serialized output are correct.\n- **Stability Check**: The test explicitly checks for stability in sorting, which is a critical aspect of the functionality being tested."
    },
    {
      "name": "test_not_accept_wildcard",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 368,
      "end_line_number": 380,
      "source_code": "def test_not_accept_wildcard():\n    accept = headers.parse_accept(\"*/*, foo/*, */bar, foo/bar;q=0.1\")\n    assert not accept.match(\n        \"text/html\", \"foo/foo\", \"bar/bar\", accept_wildcards=False\n    )\n    # Should ignore wildcards in accept but still matches them from mimes\n    m = accept.match(\"text/plain\", \"*/*\", accept_wildcards=False)\n    assert m.mime == \"*/*\"\n    assert m.match(\"*/*\")\n    assert m.header == \"foo/bar\"\n    assert not accept.match(\n        \"text/html\", \"foo/foo\", \"bar/bar\", accept_wildcards=False\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [
        "assert not accept.match('text/html', 'foo/foo', 'bar/bar', accept_wildcards=False)",
        "assert m.mime == '*/*'",
        "assert m.match('*/*')",
        "assert m.header == 'foo/bar'",
        "assert not accept.match('text/html', 'foo/foo', 'bar/bar', accept_wildcards=False)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_not_accept_wildcard` function is designed to verify the behavior of the `match` method in the context of MIME type acceptance, specifically ensuring that wildcards are not accepted when the `accept_wildcards` parameter is set to `False`. It checks that certain MIME types do not match when wildcards are involved.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. The `match` method correctly returns `False` for specific MIME types when wildcards are not accepted.\n2. The method can still match a specific MIME type against a wildcard MIME type when wildcards are ignored.\n3. The correct MIME type and header are returned when a match occurs.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `headers.parse_accept` function, which parses a string of MIME types into an object that can be used to match against incoming requests. The `match` method of the resulting object is then called with various MIME types and the `accept_wildcards` flag set to `False`. The test checks the outcomes of these matches to ensure they conform to the expected behavior regarding wildcards.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertions**: The test uses assertions to validate the expected outcomes of the `match` method, ensuring that the results align with the specified conditions.\n- **Negative Testing**: The test includes checks for negative cases (e.g., asserting that certain MIME types do not match), which is crucial for confirming that the implementation correctly handles cases where matches should not occur.\n- **Parameterization**: While not directly used in this specific test, the surrounding context shows the use of parameterization in other tests, indicating a broader testing strategy that could be applied to various input scenarios."
    },
    {
      "name": "test_accept_misc",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 383,
      "end_line_number": 428,
      "source_code": "def test_accept_misc():\n    header = (\n        \"foo/bar;q=0.0, */plain;param=123, text/plain, text/*, foo/bar;q=0.5\"\n    )\n    a = headers.parse_accept(header)\n    assert repr(a) == (\n        \"[*/plain;param=123, text/plain, text/*, \"\n        \"foo/bar;q=0.5, foo/bar;q=0.0]\"\n    )  # noqa: E501\n    assert str(a) == (\n        \"*/plain;param=123, text/plain, text/*, \"\n        \"foo/bar;q=0.5, foo/bar;q=0.0\"\n    )  # noqa: E501\n    # q=1 types don't match foo/bar but match the two others,\n    # text/* comes first and matches */plain because it\n    # comes first in the header\n    m = a.match(\"foo/bar\", \"text/*\", \"text/plain\")\n    assert repr(m) == \"<text/* matched */plain;param=123>\"\n    assert m == \"text/*\"\n    assert m.mime == \"text/*\"\n    assert m.header.mime == \"*/plain\"\n    assert m.header.type == \"*\"\n    assert m.header.subtype == \"plain\"\n    assert m.header.q == 1.0\n    assert m.header.params == dict(param=\"123\")\n    # Matches object against another Matched object (by mime and header)\n    assert m == a.match(\"text/*\")\n    # Against unsupported type falls back to object id matching\n    assert m != 123\n    # Matches the highest q value\n    m = a.match(\"foo/bar\")\n    assert repr(m) == \"<foo/bar matched foo/bar;q=0.5>\"\n    assert m == \"foo/bar\"\n    assert m == \"foo/bar;q=0.5\"\n    # Matching nothing special case\n    m = a.match()\n    assert m == \"\"\n    assert m.header is None\n    # No header means anything\n    a = headers.parse_accept(None)\n    assert a == [\"*/*\"]\n    assert a.match(\"foo/bar\")\n    # Empty header means nothing\n    a = headers.parse_accept(\"\")\n    assert a == []\n    assert not a.match(\"foo/bar\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(a) == '[*/plain;param=123, text/plain, text/*, foo/bar;q=0.5, foo/bar;q=0.0]'",
        "assert str(a) == '*/plain;param=123, text/plain, text/*, foo/bar;q=0.5, foo/bar;q=0.0'",
        "assert repr(m) == '<text/* matched */plain;param=123>'",
        "assert m == 'text/*'",
        "assert m.mime == 'text/*'",
        "assert m.header.mime == '*/plain'",
        "assert m.header.type == '*'",
        "assert m.header.subtype == 'plain'",
        "assert m.header.q == 1.0",
        "assert m.header.params == dict(param='123')",
        "assert m == a.match('text/*')",
        "assert m != 123",
        "assert repr(m) == '<foo/bar matched foo/bar;q=0.5>'",
        "assert m == 'foo/bar'",
        "assert m == 'foo/bar;q=0.5'",
        "assert m == ''",
        "assert m.header is None",
        "assert a == ['*/*']",
        "assert a.match('foo/bar')",
        "assert a == []",
        "assert not a.match('foo/bar')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_accept_misc` function is designed to verify the correct parsing and matching behavior of the `Accept` header in HTTP requests. It ensures that the `parse_accept` function correctly interprets various MIME types and their associated quality values (q-values), and that the matching logic behaves as expected when different MIME types are provided.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks several aspects:\n1. The correct representation and string conversion of the parsed `Accept` header.\n2. The matching logic for different MIME types, ensuring that the highest q-value is prioritized.\n3. The handling of special cases, such as matching against no types or when the header is absent or empty.\n4. The behavior of the matching function when provided with unsupported types.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `headers.parse_accept` function, which parses a given `Accept` header string into a structured format. The resulting object allows for matching against specific MIME types through its `match` method. The test verifies that:\n- The parsed output is correctly formatted and contains the expected MIME types.\n- The `match` method returns the correct MIME type based on the provided inputs, including handling of wildcards and q-values.\n- Edge cases, such as empty or `None` headers, are handled gracefully.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several effective testing techniques:\n- **Assertions**: It uses assertions to validate the expected outcomes against actual results, ensuring that the implementation meets the specified requirements.\n- **Edge Case Testing**: The test includes scenarios for empty headers and `None` values, which are critical for robust software.\n- **Parameterized Testing**: Although not directly in this test, the surrounding context shows the use of `pytest.mark.parametrize`, indicating a pattern of testing multiple input scenarios efficiently.\n- **Descriptive Comments**: The test includes comments that clarify the intent behind specific assertions, enhancing readability and maintainability."
    },
    {
      "name": "test_field_simple_accessor",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 439,
      "end_line_number": 441,
      "source_code": "def test_field_simple_accessor(headers, expected):\n    request = make_request(headers)\n    assert request.headers.foo == request.headers.foo_ == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('headers,expected', (({'foo': 'bar'}, 'bar'), ((('foo', 'bar'), ('foo', 'baz')), 'bar,baz'), ({}, '')))"
      ],
      "arguments": [
        "headers",
        "expected"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.headers.foo == request.headers.foo_ == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "def make_request(headers) -> Request:\n    return Request(b'/', headers, '1.1', 'GET', None, None)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_field_simple_accessor` unit test is designed to verify that the `make_request` function correctly processes HTTP headers and that the headers can be accessed using both the standard and underscore-prefixed attribute names.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the value of the header `foo-bar` can be accessed through two different attribute names: `request.headers.foo` and `request.headers.foo_`. It asserts that both attributes return the same expected value, ensuring consistency in header access methods.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `make_request` function, which creates a `Request` object with specified headers. The `Request` object is expected to have a `headers` attribute that allows access to HTTP headers. The test uses the `make_request` function to create a request with the provided headers and then checks if the values accessed through `foo` and `foo_` attributes match the expected value.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the expected behavior, specifically using the `assert` statement to compare the values. It also utilizes parameterization (as seen in the related `test_field_hyphenated_accessor` test) to run the test with different sets of headers and expected values, promoting code reusability and reducing redundancy in test cases."
    },
    {
      "name": "test_field_hyphenated_accessor",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 451,
      "end_line_number": 453,
      "source_code": "def test_field_hyphenated_accessor(headers, expected):\n    request = make_request(headers)\n    assert request.headers.foo_bar == request.headers.foo_bar_ == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('headers,expected', (({'foo-bar': 'bar'}, 'bar'), ((('foo-bar', 'bar'), ('foo-bar', 'baz')), 'bar,baz')))"
      ],
      "arguments": [
        "headers",
        "expected"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.headers.foo_bar == request.headers.foo_bar_ == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "def make_request(headers) -> Request:\n    return Request(b'/', headers, '1.1', 'GET', None, None)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_field_hyphenated_accessor` unit test is designed to verify that the `Request` object's header accessor correctly retrieves values from headers that contain hyphens. Specifically, it checks that both `foo_bar` and `foo_bar_` attributes return the expected value when the header is formatted with hyphens.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the header parsing logic in the `Request` class correctly translates hyphenated header names into Pythonic attribute names. It checks that the values retrieved from the headers are consistent and match the expected output, regardless of whether the header is accessed with or without the trailing underscore.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the `make_request` function to create a `Request` object with specified headers. The `Request` class is expected to handle headers by converting hyphenated names (like `foo-bar`) into attributes (like `foo_bar`). The assertion checks that both `request.headers.foo_bar` and `request.headers.foo_bar_` yield the same value as `expected`, which is derived from the input headers.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.mark.parametrize` decorator to run multiple scenarios with different header inputs and expected outputs. This parameterization allows for efficient testing of various cases without duplicating code, ensuring that the accessor behaves correctly across different header formats. The use of assertions to compare multiple attributes in a single line also enhances readability and conciseness."
    },
    {
      "name": "test_bad_accessor",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 456,
      "end_line_number": 460,
      "source_code": "def test_bad_accessor():\n    request = make_request({})\n    msg = \"'Header' object has no attribute '_foo'\"\n    with pytest.raises(AttributeError, match=msg):\n        request.headers._foo",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "def make_request(headers) -> Request:\n    return Request(b'/', headers, '1.1', 'GET', None, None)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_bad_accessor` unit test is designed to verify that accessing a non-existent attribute (`_foo`) on the `headers` object of a `Request` raises an `AttributeError`. This ensures that the code correctly handles attempts to access invalid attributes, maintaining robustness and preventing unexpected behavior.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks the behavior of the `Request.headers` object when an invalid attribute is accessed. It confirms that the appropriate exception (`AttributeError`) is raised, and that the error message matches the expected message, indicating that the attribute `_foo` does not exist.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `Request` class's `headers` attribute, which is expected to behave like a dictionary or an object with defined attributes. The `make_request` function creates a `Request` object with an empty headers dictionary. When the test attempts to access `request.headers._foo`, it triggers the error handling mechanism of Python, which raises an `AttributeError` since `_foo` is not a defined attribute of the `headers` object.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that an exception is raised during the execution of the code block. This is a common pattern in unit testing for verifying that specific errors are raised under certain conditions. Additionally, the use of the `match` parameter allows for checking that the error message is not only raised but also matches the expected string, providing a more thorough validation of the error handling."
    },
    {
      "name": "test_multiple_fields_accessor",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 463,
      "end_line_number": 471,
      "source_code": "def test_multiple_fields_accessor(app: Sanic):\n    @app.get(\"\")\n    async def handler(request: Request):\n        return json({\"field\": request.headers.example_field})\n\n    _, response = app.test_client.get(\n        \"/\", headers=((\"Example-Field\", \"Foo, Bar\"), (\"Example-Field\", \"Baz\"))\n    )\n    assert response.json[\"field\"] == \"Foo, Bar,Baz\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json['field'] == 'Foo, Bar,Baz'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_multiple_fields_accessor` unit test is designed to verify that the Sanic application correctly handles multiple HTTP headers with the same name and aggregates their values into a single response field.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when multiple `Example-Field` headers are sent in a request, the application correctly concatenates their values into a single string, which is then returned in the JSON response.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route handler for the root path (`\"/\"`) that accesses the `example_field` from the request headers. The handler returns a JSON response containing this field. The test then simulates a GET request to this endpoint with two `Example-Field` headers, one with the value `\"Foo, Bar\"` and another with `\"Baz\"`. The expected behavior is that the response's `field` key should contain the concatenated string `\"Foo, Bar,Baz\"`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization of Headers**: The test uses a tuple to pass multiple headers with the same name, demonstrating how to handle such scenarios in HTTP requests.\n- **Asynchronous Testing**: The test leverages Sanic's asynchronous capabilities, ensuring that the handler can process requests in a non-blocking manner.\n- **Assertion of JSON Response**: The test asserts the correctness of the JSON response by checking the value of the `field` key, ensuring that the application behaves as expected when handling multiple headers."
    },
    {
      "name": "test_static_file",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 82,
      "end_line_number": 89,
      "source_code": "def test_static_file(app, static_file_directory, file_name):\n    app.static(\n        \"/testing.file\", get_file_path(static_file_directory, file_name)\n    )\n\n    request, response = app.test_client.get(\"/testing.file\")\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, file_name)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt', 'python.png', 'symlink', 'hard_link'])"
      ],
      "arguments": [
        "app",
        "static_file_directory",
        "file_name"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, file_name)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_static_file` function is designed to verify that the Sanic application correctly serves static files. It ensures that when a static file is requested, the server responds with a status code of 200 and the correct content of the file.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks two main behaviors: \n1. The HTTP response status is 200, indicating a successful request.\n2. The body of the response matches the expected content of the static file being served, confirming that the file is correctly retrieved and returned by the server.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `app` object, which is an instance of a Sanic application. It sets up a static route for a file located at a specified path using the `app.static` method. The `get_file_path` function constructs the full path to the static file, while `get_file_content` reads the file's content. The test then simulates a GET request to the static file's URL using `app.test_client.get`, and it checks the response's status and body against expected values.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test is likely part of a larger suite that uses parameterization (as seen with `@pytest.mark.parametrize`) to run the same test logic with different file names, enhancing coverage and reducing code duplication.\n- **Assertions**: The use of assertions (`assert`) is crucial for validating the expected outcomes, ensuring that both the status code and the response body are as intended.\n- **Test Client**: The `app.test_client` is utilized to simulate HTTP requests, allowing for integration-like testing of the application's routing and response handling without needing to run a live server."
    },
    {
      "name": "test_static_file_pathlib",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 96,
      "end_line_number": 101,
      "source_code": "def test_static_file_pathlib(app, static_file_directory, file_name):\n    file_path = Path(get_file_path(static_file_directory, file_name))\n    app.static(\"/testing.file\", file_path)\n    request, response = app.test_client.get(\"/testing.file\")\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, file_name)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt', 'python.png', 'symlink', 'hard_link'])"
      ],
      "arguments": [
        "app",
        "static_file_directory",
        "file_name"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, file_name)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_static_file_pathlib` function is designed to verify that the Sanic application correctly serves static files from a specified directory using a `Path` object. It ensures that when a static file is requested, the server responds with a status code of 200 and the correct file content.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks the functionality of serving static files through the Sanic framework. It specifically verifies that the application can handle requests for static files and that the content returned matches the expected content of the file located in the static directory.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the `app.static` method to map a URL path (`/testing.file`) to a file path created using `get_file_path`, which combines the static file directory and the file name. The `app.test_client.get` method is then used to simulate a GET request to the specified URL. The response is checked for a status code of 200 and the body of the response is compared to the content retrieved by `get_file_content`, which reads the file from the filesystem.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Pathlib Usage**: The test employs the `Path` class from the `pathlib` module to handle file paths, promoting better path manipulation and cross-platform compatibility.\n- **Assertions**: It uses assertions to validate the response status and body, ensuring that the application behaves as expected.\n- **Test Client**: The use of `app.test_client` allows for simulating HTTP requests to the application, which is a common pattern in testing web applications.\n- **Separation of Concerns**: The test relies on helper functions (`get_file_path` and `get_file_content`) to abstract file path handling and content retrieval, promoting code reusability and clarity."
    },
    {
      "name": "test_static_file_pathlib_relative_path_traversal",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 114,
      "end_line_number": 126,
      "source_code": "def test_static_file_pathlib_relative_path_traversal(\n    app, static_file_directory, file_name\n):\n    \"\"\"Get the current working directory and check if it ends with \"sanic\" \"\"\"\n    cwd = Path.cwd()\n    if not str(cwd).endswith(\"sanic\"):\n        pytest.skip(\"Current working directory does not end with 'sanic'\")\n\n    file_path = \"./tests/static/../static/\"\n    app.static(\"/\", file_path)\n    _, response = app.test_client.get(f\"/{file_name}\")\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, file_name)",
      "docstring": "Get the current working directory and check if it ends with \"sanic\" ",
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt', 'python.png', 'symlink', 'hard_link'])"
      ],
      "arguments": [
        "app",
        "static_file_directory",
        "file_name"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, file_name)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_static_file_pathlib_relative_path_traversal` test is to verify that the Sanic application correctly serves static files from a specified directory while preventing directory traversal attacks. It ensures that the application can access files in the intended directory structure without exposing sensitive files outside of that structure.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a static file is requested via the application, the response status is 200 (OK) and that the content of the response matches the expected content of the file being requested. It also verifies that the current working directory is appropriate for the test to run, skipping the test if it does not end with \"sanic\".\n\n**Code Being Tested and How It Works**:  \nThe code being tested includes the `app.static()` method, which sets up a static file serving route, and the `app.test_client.get()` method, which simulates a GET request to the application. The `get_file_content()` function is used to read the expected content of the requested file from the static file directory. The test constructs a relative file path using `file_path` and checks if the file can be accessed correctly through the defined static route.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of `pytest.skip()` to conditionally skip the test based on the current working directory, ensuring that the test environment is correctly set up before proceeding. It also uses assertions to validate the response status and body, which are common practices in unit testing to confirm that the application behaves as expected. Additionally, the test utilizes parameterization (as seen in other tests) to run multiple scenarios with different file names, although this specific test does not include parameterization."
    },
    {
      "name": "test_static_file_bytes",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 133,
      "end_line_number": 138,
      "source_code": "def test_static_file_bytes(app, static_file_directory, file_name):\n    bsep = os.path.sep.encode(\"utf-8\")\n    file_path = static_file_directory.encode(\"utf-8\") + bsep + file_name\n    message = \"Static file or directory must be a path-like object or string\"\n    with pytest.raises(TypeError, match=message):\n        app.static(\"/testing.file\", file_path)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', [b'test.file', b'decode me.txt', b'python.png'])"
      ],
      "arguments": [
        "app",
        "static_file_directory",
        "file_name"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_static_file_bytes` unit test is designed to verify that the `app.static` method correctly raises a `TypeError` when provided with a file path that is a byte string instead of a valid path-like object or string. This ensures that the application properly handles invalid input types for static file paths.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks for the correct exception type (`TypeError`) and the associated error message when a byte string is passed as the file path to the `app.static` method. This behavior is crucial for maintaining the robustness of the application by ensuring that it does not accept invalid types that could lead to unexpected behavior or crashes.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `app.static` method, which is expected to register a static file route in the Sanic application. The test constructs a file path by concatenating the `static_file_directory` and `file_name`, both encoded as byte strings. When `app.static` is called with this byte string as the file path, the test anticipates a `TypeError` to be raised, indicating that the input is not a valid path-like object or string.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that a specific exception is raised during the execution of the code block. This is a common pattern in unit testing that allows for clean and readable assertions about expected exceptions. Additionally, the use of parameterization (`@pytest.mark.parametrize`) allows the test to run multiple scenarios with different byte string inputs, enhancing test coverage and ensuring that various invalid inputs are handled correctly."
    },
    {
      "name": "test_static_file_invalid_path",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 145,
      "end_line_number": 150,
      "source_code": "def test_static_file_invalid_path(app, static_file_directory, file_name):\n    app.route(\"/\")(lambda x: x)\n    with pytest.raises(ValueError):\n        app.static(\"/testing.file\", file_name)\n    request, response = app.test_client.get(\"/testing.file\")\n    assert response.status == 404",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', [{}, [], object()])"
      ],
      "arguments": [
        "app",
        "static_file_directory",
        "file_name"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_static_file_invalid_path` test is designed to verify that the application correctly handles invalid file paths when attempting to serve static files. Specifically, it checks that the application raises a `ValueError` when an invalid path is provided and that a subsequent request for the static file returns a 404 Not Found status.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the application does not accept invalid path-like objects for static file serving. It verifies that the application raises the appropriate exception (`ValueError`) when an invalid `file_name` is passed to the `app.static()` method. Additionally, it confirms that a request to access the static file results in a 404 response, indicating that the file is not found.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `app.static()` method, which is responsible for registering static file routes in the Sanic application. The test first sets up a route and then attempts to register a static file with an invalid `file_name`. The `app.test_client.get()` method is used to simulate a GET request to the static file's URL, and the response is checked for a 404 status. The `pytest.raises()` context manager is used to assert that a `ValueError` is raised when the invalid path is registered.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Exception Testing**: The use of `pytest.raises()` to assert that a specific exception is raised when invalid input is provided is a common pattern in unit testing, ensuring that the code behaves as expected under erroneous conditions.\n- **Parameterization**: The test is designed to be run with various invalid `file_name` inputs, which allows for comprehensive coverage of potential invalid cases without duplicating code.\n- **Assertions**: The test employs assertions to validate both the exception raised and the HTTP response status, ensuring that the application behaves correctly in both scenarios."
    },
    {
      "name": "test_static_file_content_type",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 154,
      "end_line_number": 164,
      "source_code": "def test_static_file_content_type(app, static_file_directory, file_name):\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        content_type=\"text/html; charset=utf-8\",\n    )\n\n    request, response = app.test_client.get(\"/testing.file\")\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, file_name)\n    assert response.headers[\"Content-Type\"] == \"text/html; charset=utf-8\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.html'])"
      ],
      "arguments": [
        "app",
        "static_file_directory",
        "file_name"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, file_name)",
        "assert response.headers['Content-Type'] == 'text/html; charset=utf-8'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_static_file_content_type` function is designed to verify that a static file served by the Sanic web framework returns the correct HTTP status, content, and content type when accessed via a specific URI.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks three key aspects of the static file response: \n1. The HTTP status code is `200`, indicating a successful request.\n2. The response body matches the actual content of the static file being served.\n3. The `Content-Type` header is correctly set to `\"text/html; charset=utf-8\"`.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a static route in the Sanic application using `app.static()`, which maps the URI `/testing.file` to a file located at the path returned by `get_file_path(static_file_directory, file_name)`. The `content_type` parameter explicitly specifies the expected MIME type. The test then simulates a GET request to this URI using `app.test_client.get()`, capturing the response. The assertions validate that the response status, body, and headers are as expected.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test utilizes parameterization (as seen in the related `test_static_file_content_type_guessed` function) to check different file names and their expected content types, promoting code reuse and reducing redundancy.\n- **Assertions**: The test employs assertions to validate the response, ensuring that the application behaves as expected under the defined conditions.\n- **Separation of Concerns**: The test isolates the functionality of serving static files, allowing for focused testing of this specific feature without interference from other parts of the application."
    },
    {
      "name": "test_static_file_content_type_guessed",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 175,
      "end_line_number": 186,
      "source_code": "def test_static_file_content_type_guessed(\n    app, static_file_directory, file_name, expected\n):\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n    )\n\n    request, response = app.test_client.get(\"/testing.file\")\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, file_name)\n    assert response.headers[\"Content-Type\"] == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name,expected', [('test.html', 'text/html; charset=utf-8'), ('decode me.txt', 'text/plain; charset=utf-8'), ('test.file', 'application/octet-stream')])"
      ],
      "arguments": [
        "app",
        "static_file_directory",
        "file_name",
        "expected"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, file_name)",
        "assert response.headers['Content-Type'] == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_static_file_content_type_guessed` test aims to verify that the Sanic application correctly serves static files with the appropriate content type based on the file extension. It checks that the response status is 200, the response body matches the file content, and the `Content-Type` header is set to the expected value.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically verifies that when a static file is requested, the server responds with the correct HTTP status code (200 OK), the body of the response contains the expected file content, and the `Content-Type` header matches the expected MIME type for the given file. The test uses parameterization to check multiple file types and their corresponding content types.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `app.static` method to register a static file route. It uses `get_file_path` to determine the file's path and `get_file_content` to read the file's content. The `app.test_client.get` method simulates an HTTP GET request to the static file endpoint. The assertions then validate the response's status, body, and headers against the expected values.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses `@pytest.mark.parametrize` to run the same test logic with different sets of input data (file names and expected content types), which enhances test coverage and reduces code duplication.\n- **Assertions**: The test employs multiple assertions to ensure that all aspects of the response (status, body, headers) are correct, providing a comprehensive check of the functionality.\n- **Separation of Concerns**: The test isolates the behavior of serving static files from other application logic, focusing solely on the static file handling mechanism."
    },
    {
      "name": "test_static_file_content_type_with_charset",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 189,
      "end_line_number": 198,
      "source_code": "def test_static_file_content_type_with_charset(app, static_file_directory):\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, \"decode me.txt\"),\n        content_type=\"text/plain;charset=ISO-8859-1\",\n    )\n\n    request, response = app.test_client.get(\"/testing.file\")\n    assert response.status == 200\n    assert response.headers[\"Content-Type\"] == \"text/plain;charset=ISO-8859-1\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "static_file_directory"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.headers['Content-Type'] == 'text/plain;charset=ISO-8859-1'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_static_file_content_type_with_charset` test is to verify that the Sanic application correctly serves a static file with the specified content type, including a character set. This ensures that the server responds with the appropriate headers when a client requests the file.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a static file is served, the HTTP response status is 200 (indicating success) and that the `Content-Type` header matches the expected value of `\"text/plain;charset=ISO-8859-1\"`. This confirms that the server is correctly handling the content type and charset for the static file.\n\n**Code Being Tested and How It Works**:  \nThe code being tested involves the `app.static` method, which registers a static file route in the Sanic application. The `get_file_path` function constructs the file path based on the provided `static_file_directory` and the filename. When the test client makes a GET request to `/testing.file`, the application should return the file with the specified content type. The assertions then check the response status and headers to ensure they match the expected values.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern, checking the response status and headers directly after making a request. It uses the `app.test_client.get` method to simulate a client request, which is a common technique in unit testing web applications. The test also demonstrates the use of explicit content type specification, which is crucial for validating that the server correctly handles different content types and charsets."
    },
    {
      "name": "test_static_directory",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 205,
      "end_line_number": 210,
      "source_code": "def test_static_directory(app, file_name, base_uri, static_file_directory):\n    app.static(base_uri, static_file_directory)\n\n    request, response = app.test_client.get(uri=f\"{base_uri}/{file_name}\")\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, file_name)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt', 'symlink', 'hard_link'])",
        "pytest.mark.parametrize('base_uri', ['/static', '', '/dir'])"
      ],
      "arguments": [
        "app",
        "file_name",
        "base_uri",
        "static_file_directory"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, file_name)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_static_directory` function is designed to verify that the Sanic application correctly serves static files from a specified directory when a GET request is made to a constructed URI. It ensures that the server responds with a 200 status code and the correct file content.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a static file is requested via the constructed URI, the response status is 200 (indicating success) and that the body of the response matches the expected content of the file located in the static file directory. This confirms both the routing and file serving capabilities of the Sanic application.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `app.static` method to set up a static file route, mapping a base URI to a directory containing static files. It then uses `app.test_client.get` to simulate a GET request to the constructed URI (which combines the base URI and the file name). The `get_file_content` function is called to read the expected content of the file from the static directory, which is then compared to the response body to ensure they match.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test is likely part of a parameterized test suite, as indicated by the use of `@pytest.mark.parametrize`, allowing it to run multiple times with different file names. This enhances test coverage without duplicating code.\n- **Assertions**: The test employs assertions to validate the response status and body, which are fundamental to unit testing, ensuring that the application behaves as expected.\n- **Test Client**: The use of `app.test_client` allows for simulating HTTP requests to the application, which is a common practice in testing web applications to verify their behavior in a controlled environment."
    },
    {
      "name": "test_static_head_request",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 214,
      "end_line_number": 227,
      "source_code": "def test_static_head_request(app, file_name, static_file_directory):\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n\n    request, response = app.test_client.head(\"/testing.file\")\n    assert response.status == 200\n    assert \"Accept-Ranges\" in response.headers\n    assert \"Content-Length\" in response.headers\n    assert int(response.headers[\"Content-Length\"]) == len(\n        get_file_content(static_file_directory, file_name)\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt'])"
      ],
      "arguments": [
        "app",
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert 'Accept-Ranges' in response.headers",
        "assert 'Content-Length' in response.headers",
        "assert int(response.headers['Content-Length']) == len(get_file_content(static_file_directory, file_name))"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.head",
          "body": "def head(self, request):\n    return text('', headers={'method': 'HEAD'})"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_static_head_request` function is designed to verify the behavior of the Sanic web framework when handling HTTP HEAD requests for static files. Specifically, it checks that the server correctly responds to a HEAD request with the appropriate status code and headers, including `Accept-Ranges` and `Content-Length`.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a HEAD request is made to a static file endpoint, the server responds with a 200 OK status, indicating that the file exists and can be accessed. It also verifies that the response includes the `Accept-Ranges` header, which indicates that the server supports range requests, and the `Content-Length` header, which specifies the size of the file being requested.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Sanic application with a static file route pointing to a specified file in a given directory. It uses the `app.test_client.head` method to simulate a HEAD request to the static file endpoint. The `get_file_path` function constructs the full path to the static file, while `get_file_content` retrieves the actual content of the file to compare its length against the `Content-Length` header in the response. The assertions check that the response status is 200 and that the necessary headers are present and correctly populated.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test is likely part of a parameterized test suite, as indicated by the use of `@pytest.mark.parametrize`, allowing it to run multiple times with different file names. This enhances test coverage by validating the behavior with various inputs.\n- **Assertions**: The test employs multiple assertions to validate different aspects of the response, ensuring comprehensive verification of the server's behavior.\n- **Setup and Teardown**: The test sets up the application context and static file route before executing the request, demonstrating a common pattern in unit tests where the environment is prepared for the test case."
    },
    {
      "name": "test_static_content_range_correct",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 231,
      "end_line_number": 247,
      "source_code": "def test_static_content_range_correct(app, file_name, static_file_directory):\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n\n    headers = {\"Range\": \"bytes=12-19\"}\n    request, response = app.test_client.get(\"/testing.file\", headers=headers)\n    assert response.status == 206\n    assert \"Content-Length\" in response.headers\n    assert \"Content-Range\" in response.headers\n    static_content = bytes(get_file_content(static_file_directory, file_name))[\n        12:20\n    ]\n    assert int(response.headers[\"Content-Length\"]) == len(static_content)\n    assert response.body == static_content",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt'])"
      ],
      "arguments": [
        "app",
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 206",
        "assert 'Content-Length' in response.headers",
        "assert 'Content-Range' in response.headers",
        "assert int(response.headers['Content-Length']) == len(static_content)",
        "assert response.body == static_content"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_static_content_range_correct` test verifies that the Sanic application correctly handles HTTP range requests for static files. Specifically, it checks that when a client requests a specific byte range of a file, the server responds with the appropriate status code and content.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that:\n- The server responds with a `206 Partial Content` status when a valid range request is made.\n- The response includes the `Content-Length` and `Content-Range` headers.\n- The body of the response contains the correct portion of the requested file, as specified by the range.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the Sanic application, which serves static files. The relevant code includes:\n- The `app.static` method, which sets up the static file serving with range support.\n- The `app.test_client.get` method, which simulates an HTTP GET request with a `Range` header indicating the desired byte range.\n- The `get_file_content` function, which reads the content of the specified file from the filesystem.\n\nThe test constructs a request for bytes 12 to 19 of the specified file and checks that the response matches the expected content.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterized Testing**: The test is designed to run with multiple file names, allowing for a broader coverage of different file types and names.\n- **Assertions**: Multiple assertions are used to validate the response status, headers, and body content, ensuring comprehensive verification of the server's behavior.\n- **Mocking and Dependency Injection**: The test uses a test client to simulate requests, allowing for isolated testing of the static file serving functionality without needing a live server."
    },
    {
      "name": "test_static_content_range_front",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 251,
      "end_line_number": 267,
      "source_code": "def test_static_content_range_front(app, file_name, static_file_directory):\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n\n    headers = {\"Range\": \"bytes=12-\"}\n    request, response = app.test_client.get(\"/testing.file\", headers=headers)\n    assert response.status == 206\n    assert \"Content-Length\" in response.headers\n    assert \"Content-Range\" in response.headers\n    static_content = bytes(get_file_content(static_file_directory, file_name))[\n        12:\n    ]\n    assert int(response.headers[\"Content-Length\"]) == len(static_content)\n    assert response.body == static_content",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt'])"
      ],
      "arguments": [
        "app",
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 206",
        "assert 'Content-Length' in response.headers",
        "assert 'Content-Range' in response.headers",
        "assert int(response.headers['Content-Length']) == len(static_content)",
        "assert response.body == static_content"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_static_content_range_front` test verifies that the Sanic application correctly handles HTTP range requests for static files. Specifically, it checks that when a range request is made, the server responds with the appropriate status code, headers, and body content corresponding to the requested byte range.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that:\n- The server responds with a `206 Partial Content` status when a valid range is requested.\n- The response includes the `Content-Length` and `Content-Range` headers.\n- The body of the response contains the correct portion of the file as specified by the range request.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a static file route in the Sanic application using the `app.static` method, which serves a file located at a specified path. The `get_file_path` function constructs the full path to the file, and `get_file_content` reads the file's content. The test then simulates a GET request with a `Range` header indicating the desired byte range. The response is checked to ensure it meets the expected criteria, including the correct status code and content.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterized Testing**: The test uses `pytest.mark.parametrize` to run the test with different file names, allowing for multiple scenarios to be tested without duplicating code.\n- **Assertions**: The test employs multiple assertions to validate various aspects of the response, ensuring comprehensive coverage of the expected behavior.\n- **Mocking HTTP Requests**: The use of `app.test_client.get` simulates HTTP requests, allowing for testing of the application\u2019s behavior in a controlled environment without needing a live server."
    },
    {
      "name": "test_static_content_range_back",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 271,
      "end_line_number": 287,
      "source_code": "def test_static_content_range_back(app, file_name, static_file_directory):\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n\n    headers = {\"Range\": \"bytes=-12\"}\n    request, response = app.test_client.get(\"/testing.file\", headers=headers)\n    assert response.status == 206\n    assert \"Content-Length\" in response.headers\n    assert \"Content-Range\" in response.headers\n    static_content = bytes(get_file_content(static_file_directory, file_name))[\n        -12:\n    ]\n    assert int(response.headers[\"Content-Length\"]) == len(static_content)\n    assert response.body == static_content",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt'])"
      ],
      "arguments": [
        "app",
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 206",
        "assert 'Content-Length' in response.headers",
        "assert 'Content-Range' in response.headers",
        "assert int(response.headers['Content-Length']) == len(static_content)",
        "assert response.body == static_content"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_static_content_range_back` test is designed to verify that the Sanic application correctly handles HTTP range requests for static files. Specifically, it checks that when a client requests a specific byte range from a static file, the server responds with the appropriate status code and content.\n\n**Specific Functionality or Behavior Verified**:  \nThis test verifies that:\n1. The server responds with a `206 Partial Content` status when a valid range request is made.\n2. The response includes the `Content-Length` and `Content-Range` headers.\n3. The body of the response contains the correct portion of the file as specified by the range request.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Sanic application with a static file route that supports range requests. It uses the `app.static` method to serve a file located at a specified path. The test then simulates a GET request with a `Range` header requesting the last 12 bytes of the file. The relevant methods being tested include:\n- `app.test_client.get`: This method simulates an HTTP GET request to the server.\n- `get_file_path`: This utility function constructs the full path to the static file.\n- `get_file_content`: This function reads the content of the specified file, which is used to validate the response.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterized Testing**: The test uses `pytest.mark.parametrize` to run the test with different file names, ensuring that the functionality is validated across multiple scenarios.\n- **Assertions**: The test employs multiple assertions to validate the response status, headers, and body content, ensuring comprehensive coverage of the expected behavior.\n- **Mocking and Isolation**: The test isolates the functionality of the static file serving by using a test client, allowing it to focus on the behavior of the application without external dependencies."
    },
    {
      "name": "test_static_content_range_empty",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 292,
      "end_line_number": 311,
      "source_code": "def test_static_content_range_empty(\n    app, file_name, static_file_directory, use_modified_since\n):\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n        use_modified_since=use_modified_since,\n    )\n\n    request, response = app.test_client.get(\"/testing.file\")\n    assert response.status == 200\n    assert \"Content-Length\" in response.headers\n    assert \"Content-Range\" not in response.headers\n    assert int(response.headers[\"Content-Length\"]) == len(\n        get_file_content(static_file_directory, file_name)\n    )\n    assert response.body == bytes(\n        get_file_content(static_file_directory, file_name)\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('use_modified_since', [True, False])",
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt'])"
      ],
      "arguments": [
        "app",
        "file_name",
        "static_file_directory",
        "use_modified_since"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert 'Content-Length' in response.headers",
        "assert 'Content-Range' not in response.headers",
        "assert int(response.headers['Content-Length']) == len(get_file_content(static_file_directory, file_name))",
        "assert response.body == bytes(get_file_content(static_file_directory, file_name))"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_static_content_range_empty` test is designed to verify the behavior of the Sanic application when serving static files with content range support enabled. Specifically, it checks that when a static file is requested without any range specified, the server responds correctly without including a `Content-Range` header.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that:\n1. The response status is `200 OK`, indicating a successful request.\n2. The `Content-Length` header is present, confirming that the server is providing the size of the file.\n3. The `Content-Range` header is absent, which is expected when the entire file is being served.\n4. The response body matches the actual content of the requested file, ensuring that the file is served correctly.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `app.static` method, which sets up a route to serve static files. The `get_file_path` function constructs the file path based on the provided directory and filename. The `app.test_client.get` method simulates an HTTP GET request to the static file endpoint. The assertions then validate the response's status, headers, and body against the expected values derived from the actual file content.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses parameters (`file_name`, `static_file_directory`, `use_modified_since`) to run the same test logic with different inputs, enhancing coverage and reducing code duplication.\n- **Assertions**: Multiple assertions are employed to validate different aspects of the response, ensuring comprehensive verification of the server's behavior.\n- **Mocking**: The test likely relies on a mock or test client to simulate requests to the Sanic application, allowing for isolated testing of the static file serving functionality without needing a live server."
    },
    {
      "name": "test_static_content_range_error",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 315,
      "end_line_number": 329,
      "source_code": "def test_static_content_range_error(app, file_name, static_file_directory):\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n\n    headers = {\"Range\": \"bytes=1-0\"}\n    request, response = app.test_client.get(\"/testing.file\", headers=headers)\n    assert response.status == 416\n    assert \"Content-Length\" in response.headers\n    assert \"Content-Range\" in response.headers\n    assert response.headers[\"Content-Range\"] == \"bytes */%s\" % (\n        len(get_file_content(static_file_directory, file_name)),\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt'])"
      ],
      "arguments": [
        "app",
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 416",
        "assert 'Content-Length' in response.headers",
        "assert 'Content-Range' in response.headers",
        "assert response.headers['Content-Range'] == 'bytes */%s' % (len(get_file_content(static_file_directory, file_name)),)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_static_content_range_error` test is designed to verify the behavior of the Sanic application when a client requests a range of bytes from a static file that is invalid. Specifically, it checks that the server correctly responds with a 416 (Range Not Satisfiable) status code when the requested byte range is malformed.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a client sends a request with a `Range` header that specifies an invalid range (in this case, \"bytes=1-0\"), the server responds appropriately. It also verifies that the response includes the `Content-Length` and `Content-Range` headers, confirming that the server acknowledges the request and provides information about the total size of the file.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `app.static` method, which sets up a static file route in the Sanic application. The `get_file_path` function is used to determine the file's location based on the provided directory and filename. The test client then makes a GET request to the static file endpoint with the invalid range header. The expected behavior is that the server responds with a 416 status code and includes the `Content-Length` and `Content-Range` headers in the response.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs parameterized testing using `pytest`, allowing it to run multiple scenarios with different filenames. It also uses assertions to validate the response status and headers, ensuring that the application behaves as expected under specific conditions. The use of a test client to simulate HTTP requests is a common pattern in testing web applications, enabling the verification of endpoint behavior in a controlled environment."
    },
    {
      "name": "test_static_content_range_invalid_unit",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 333,
      "end_line_number": 347,
      "source_code": "def test_static_content_range_invalid_unit(\n    app, file_name, static_file_directory\n):\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n\n    unit = \"bit\"\n    headers = {\"Range\": f\"{unit}=1-0\"}\n    request, response = app.test_client.get(\"/testing.file\", headers=headers)\n\n    assert response.status == 416\n    assert f\"{unit} is not a valid Range Type\" in response.text",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt'])"
      ],
      "arguments": [
        "app",
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 416",
        "assert f'{unit} is not a valid Range Type' in response.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_static_content_range_invalid_unit` test is designed to verify that the Sanic application correctly handles invalid `Range` headers in HTTP requests for static files. Specifically, it checks that when an invalid range unit is provided, the server responds with the appropriate HTTP status code and error message.\n\n**Specific Functionality or Behavior Verified**:  \nThis test verifies that when a request is made with an invalid range unit (in this case, \"bit\"), the server responds with a `416 Range Not Satisfiable` status code. Additionally, it checks that the response body contains a specific error message indicating that the provided range unit is not valid.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a static file route in the Sanic application using the `app.static` method, which serves files from a specified directory. The `get_file_path` function is used to construct the full path to the static file. The test then simulates an HTTP GET request to the static file endpoint with a `Range` header that specifies an invalid unit. The response is captured, and assertions are made to ensure the status code is `416` and that the error message is present in the response text.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Setup and Teardown**: The test sets up the application state by defining a static route before executing the request, ensuring a clean environment for each test run.\n- **Assertions**: The test uses assertions to validate both the status code and the content of the response, which is a common practice in unit testing to ensure that the application behaves as expected.\n- **Parameterization**: While this specific test is not parameterized, it is part of a broader suite of tests that include parameterized tests for different file names, demonstrating a strategy to cover multiple scenarios efficiently."
    },
    {
      "name": "test_static_content_range_invalid_start",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 351,
      "end_line_number": 365,
      "source_code": "def test_static_content_range_invalid_start(\n    app, file_name, static_file_directory\n):\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n\n    start = \"start\"\n    headers = {\"Range\": f\"bytes={start}-0\"}\n    request, response = app.test_client.get(\"/testing.file\", headers=headers)\n\n    assert response.status == 416\n    assert f\"'{start}' is invalid for Content Range\" in response.text",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt'])"
      ],
      "arguments": [
        "app",
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 416",
        "assert f\"'{start}' is invalid for Content Range\" in response.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_static_content_range_invalid_start` is designed to verify that the Sanic application correctly handles invalid range requests for static content. Specifically, it checks that when a malformed range header is provided (in this case, a non-numeric start value), the server responds with the appropriate HTTP status code and error message.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies that when the `Range` header is set to an invalid value (e.g., `bytes=start-0`), the server responds with a 416 status code, indicating \"Range Not Satisfiable.\" Additionally, it checks that the response body contains a specific error message indicating that the provided start value is invalid.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the Sanic application's static file serving functionality, specifically the handling of range requests. The `app.static` method is used to set up a route for serving a static file with content range support enabled. The test then simulates a GET request to this route with an invalid `Range` header. The `app.test_client.get` method is used to perform the request, and the response is checked for the expected status code and error message.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test utilizes the `app` fixture and parameters like `file_name` and `static_file_directory`, allowing it to be run with different static file configurations.\n- **Assertions**: The test employs assertions to validate the response status and content, ensuring that the application behaves as expected under invalid input conditions.\n- **Isolation**: The test is isolated from other tests, focusing solely on the behavior of the static file serving mechanism in response to invalid range requests, which helps in pinpointing issues related to this specific functionality."
    },
    {
      "name": "test_static_content_range_invalid_end",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 369,
      "end_line_number": 383,
      "source_code": "def test_static_content_range_invalid_end(\n    app, file_name, static_file_directory\n):\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n\n    end = \"end\"\n    headers = {\"Range\": f\"bytes=1-{end}\"}\n    request, response = app.test_client.get(\"/testing.file\", headers=headers)\n\n    assert response.status == 416\n    assert f\"'{end}' is invalid for Content Range\" in response.text",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt'])"
      ],
      "arguments": [
        "app",
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 416",
        "assert f\"'{end}' is invalid for Content Range\" in response.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_static_content_range_invalid_end` test is designed to verify that the Sanic application correctly handles invalid range requests for static file content. Specifically, it checks that when an invalid end value is provided in the `Range` header, the server responds with the appropriate HTTP status code and error message.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a client requests a byte range with an invalid end value (in this case, a non-numeric string \"end\"), the server responds with a 416 (Range Not Satisfiable) status code. Additionally, it verifies that the response body contains a specific error message indicating the invalidity of the provided end value.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `app.static` method, which sets up a static file route that supports content range requests. The `get_file_path` function is used to determine the file's path based on the provided directory and filename. The test then simulates a GET request to the static file endpoint with a `Range` header that includes the invalid end value. The response is checked for the correct status code and error message.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterized Testing**: The test uses `pytest.mark.parametrize` to run the same test logic for multiple file names, ensuring that the behavior is consistent across different static files.\n- **Assertions**: The test employs assertions to validate the response status and content, which is a common practice in unit testing to confirm that the application behaves as expected.\n- **Setup of Static Routes**: The test demonstrates the setup of static file routes within the Sanic application, showcasing how to configure the application for serving files with specific behaviors (like content range support)."
    },
    {
      "name": "test_static_content_range_invalid_parameters",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 387,
      "end_line_number": 400,
      "source_code": "def test_static_content_range_invalid_parameters(\n    app, file_name, static_file_directory\n):\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n\n    headers = {\"Range\": \"bytes=-\"}\n    request, response = app.test_client.get(\"/testing.file\", headers=headers)\n\n    assert response.status == 416\n    assert \"Invalid for Content Range parameters\" in response.text",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt'])"
      ],
      "arguments": [
        "app",
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 416",
        "assert 'Invalid for Content Range parameters' in response.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_static_content_range_invalid_parameters` is designed to verify that the Sanic application correctly handles invalid HTTP Range requests for static content. Specifically, it checks that the application returns a 416 status code when the Range header is malformed.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a client sends a Range request with invalid parameters (in this case, \"bytes=-\"), the server responds with a 416 status code, indicating that the requested range is not satisfiable. Additionally, it verifies that the response body contains a specific error message indicating the nature of the invalid request.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `app.test_client.get` method, which simulates an HTTP GET request to the static file endpoint. The `app.static` method is used to set up the static file serving with content range support. The `get_file_path` function constructs the file path based on the provided directory and filename. The test checks the response status and the content of the response body to ensure proper error handling.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test is part of a suite that uses parameterization (via `pytest.mark.parametrize`) to run the same test logic with different file names, enhancing test coverage without duplicating code.\n- **Assertions**: The test employs assertions to validate the response status and content, which is a standard practice in unit testing to ensure that the application behaves as expected under various conditions.\n- **Setup and Teardown**: The test sets up the static file route before making the request, ensuring that the environment is correctly configured for the test scenario."
    },
    {
      "name": "test_static_file_specified_host",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 406,
      "end_line_number": 418,
      "source_code": "def test_static_file_specified_host(app, static_file_directory, file_name):\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        host=\"www.example.com\",\n    )\n\n    headers = {\"Host\": \"www.example.com\"}\n    request, response = app.test_client.get(\"/testing.file\", headers=headers)\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, file_name)\n    request, response = app.test_client.get(\"/testing.file\")\n    assert response.status == 404",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt', 'python.png'])"
      ],
      "arguments": [
        "app",
        "static_file_directory",
        "file_name"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, file_name)",
        "assert response.status == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_static_file_specified_host` test is to verify that the Sanic application correctly serves a static file when accessed with a specified host in the request headers. It also checks that accessing the same file without the correct host results in a 404 Not Found response.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically verifies two behaviors: \n1. When a request is made to `/testing.file` with the `Host` header set to `www.example.com`, the server responds with a status code of 200 and returns the correct content of the specified static file.\n2. When a request is made to the same endpoint without the `Host` header, the server responds with a status code of 404, indicating that the file is not found.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `app.static` method, which registers a static file route in the Sanic application. The `get_file_path` function constructs the file path based on the provided directory and file name, while `get_file_content` reads the content of the file. The test uses `app.test_client.get` to simulate HTTP GET requests to the static file endpoint, checking the response status and body against expected values.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the response status and body, which is a common pattern in unit testing. It also utilizes header manipulation to simulate different request scenarios, demonstrating how to test behavior based on request context. The test is structured to be clear and concise, focusing on specific outcomes, which is a best practice in unit testing."
    },
    {
      "name": "test_static_stream_large_file",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 424,
      "end_line_number": 442,
      "source_code": "def test_static_stream_large_file(\n    app,\n    static_file_directory,\n    file_name,\n    use_modified_since,\n    stream_large_files,\n    large_file,\n):\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_modified_since=use_modified_since,\n        stream_large_files=stream_large_files,\n    )\n\n    request, response = app.test_client.get(\"/testing.file\")\n\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, file_name)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('use_modified_since', [True, False])",
        "pytest.mark.parametrize('stream_large_files', [True, 1024])",
        "pytest.mark.parametrize('file_name', ['test.file', 'large.file'])"
      ],
      "arguments": [
        "app",
        "static_file_directory",
        "file_name",
        "use_modified_since",
        "stream_large_files",
        "large_file"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, file_name)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_static_stream_large_file` unit test is designed to verify the functionality of serving large static files through a Sanic web application. It ensures that the application correctly handles requests for large files, returning the appropriate HTTP status and content.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a GET request is made to the endpoint serving a large static file, the response status is 200 (OK) and the response body matches the content of the specified file. It also tests the behavior of the application when different parameters related to file streaming and modification are used.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a static route in the Sanic application using the `app.static` method, which maps a URL path (`/testing.file`) to a file located in a specified directory. The `get_file_path` function constructs the full path to the file, while `get_file_content` reads the file's content. The test then simulates a GET request to the static file endpoint and asserts that the response status is 200 and that the response body matches the expected file content.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses `pytest.mark.parametrize` to run multiple scenarios with different combinations of `use_modified_since`, `stream_large_files`, and `file_name`, allowing for comprehensive coverage of various configurations.\n- **Assertions**: The test employs assertions to validate the response status and body, ensuring that the application behaves as expected under the defined conditions.\n- **Fixture Usage**: The test relies on fixtures (like `static_file_directory`) to provide necessary setup, promoting code reusability and clarity in test configuration."
    },
    {
      "name": "test_use_modified_since",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 448,
      "end_line_number": 464,
      "source_code": "def test_use_modified_since(app, static_file_directory, file_name):\n    file_stat = os.stat(get_file_path(static_file_directory, file_name))\n    modified_since = strftime(\n        \"%a, %d %b %Y %H:%M:%S GMT\", gmtime(file_stat.st_mtime)\n    )\n\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_modified_since=True,\n    )\n\n    request, response = app.test_client.get(\n        \"/testing.file\", headers={\"If-Modified-Since\": modified_since}\n    )\n\n    assert response.status == 304",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt', 'python.png'])"
      ],
      "arguments": [
        "app",
        "static_file_directory",
        "file_name"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 304"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_use_modified_since` test is to verify that the server correctly responds with a `304 Not Modified` status when a client requests a static file with an `If-Modified-Since` header that matches the last modified time of the file. This behavior is crucial for efficient caching and resource management in web applications.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks the functionality of the `use_modified_since` feature in the static file serving mechanism of the Sanic application. It ensures that when a client indicates it has a cached version of a file that has not changed since the last modification time, the server responds appropriately without sending the file content again, thus saving bandwidth.\n\n**Code Being Tested and How It Works**:  \nThe code being tested involves the static file serving functionality of the Sanic application. The test first retrieves the last modified time of a specified file and formats it into a string suitable for the `If-Modified-Since` HTTP header. The application is then set up to serve this file with the `use_modified_since` option enabled. When a GET request is made to the file's endpoint with the `If-Modified-Since` header, the server checks if the file has been modified since that time. If it has not, it returns a `304 Not Modified` response, confirming that the cached version can still be used by the client.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable testing patterns:\n- **Setup and Teardown**: The test prepares the environment by setting up the static file serving before executing the request, ensuring a clean state for each test run.\n- **Parameterized Testing**: The use of parameters (like `file_name`) allows the test to be run with multiple file scenarios, enhancing coverage and robustness.\n- **Assertions**: The test uses assertions to validate the response status, ensuring that the expected behavior (304 status) is met, which is a common practice in unit testing to confirm that the code behaves as intended."
    },
    {
      "name": "test_file_not_found",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 467,
      "end_line_number": 473,
      "source_code": "def test_file_not_found(app, static_file_directory):\n    app.static(\"/static\", static_file_directory)\n\n    request, response = app.test_client.get(\"/static/not_found\")\n\n    assert response.status == 404\n    assert \"File not found\" in response.text",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "static_file_directory"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 404",
        "assert 'File not found' in response.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_file_not_found` unit test is designed to verify that the application correctly handles requests for static files that do not exist. Specifically, it checks that the server responds with a 404 status code and an appropriate error message when a non-existent file is requested.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a client requests a static file located at `/static/not_found`, the application responds with a 404 Not Found status. Additionally, it verifies that the response body contains the text \"File not found,\" indicating that the application has correctly identified the absence of the requested file.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `app.static` method, which sets up a static file serving route for the application. The line `app.static(\"/static\", static_file_directory)` configures the application to serve files from the specified `static_file_directory`. The subsequent call to `app.test_client.get(\"/static/not_found\")` simulates a GET request to the non-existent file path. The response is then checked for the expected status code and message.\n\n**Notable Testing Patterns or Techniques Used**:  \nThis test employs the use of assertions to validate the response from the application. It uses the `assert` statement to check both the status code and the content of the response. The test is structured to be straightforward and focused, making it easy to understand the expected behavior of the application when handling requests for non-existent static files. Additionally, it utilizes the `app.test_client` to simulate HTTP requests, which is a common pattern in testing web applications."
    },
    {
      "name": "test_static_name",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 478,
      "end_line_number": 483,
      "source_code": "def test_static_name(app, static_file_directory, static_name, file_name):\n    app.static(\"/static\", static_file_directory, name=static_name)\n\n    request, response = app.test_client.get(f\"/static/{file_name}\")\n\n    assert response.status == 200",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('static_name', ['_static_name', 'static'])",
        "pytest.mark.parametrize('file_name', ['test.html'])"
      ],
      "arguments": [
        "app",
        "static_file_directory",
        "static_name",
        "file_name"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_static_name` function is designed to verify that the Sanic application correctly serves static files when a specific static name is defined. It ensures that the application can handle requests for static files and respond with a successful status code.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a static route is defined with a given name, the application can successfully retrieve and serve the corresponding static file. It asserts that the HTTP response status is 200, indicating that the file was found and served correctly.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a static route using `app.static(\"/static\", static_file_directory, name=static_name)`, where `static_file_directory` is the directory containing the static files, and `static_name` is the name assigned to this static route. It then simulates a GET request to the static file using `app.test_client.get(f\"/static/{file_name}\")`. The response is checked to ensure that the status code is 200, confirming that the file was served successfully.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs parameterization with `pytest.mark.parametrize`, allowing it to run multiple scenarios with different combinations of `static_name` and `file_name`. This technique enhances test coverage by verifying the behavior of the static file serving mechanism under various conditions without duplicating code. Additionally, the use of assertions to validate the response status is a common practice in unit testing to ensure that the expected outcomes are met."
    },
    {
      "name": "test_nested_dir",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 486,
      "end_line_number": 492,
      "source_code": "def test_nested_dir(app, static_file_directory):\n    app.static(\"/static\", static_file_directory)\n\n    request, response = app.test_client.get(\"/static/nested/dir/foo.txt\")\n\n    assert response.status == 200\n    assert response.text == \"foo\\n\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "static_file_directory"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'foo\\n'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_nested_dir` function is designed to verify that the Sanic application correctly serves static files from a nested directory structure. Specifically, it checks that a request for a specific file (`foo.txt`) located in a nested directory (`/static/nested/dir/`) returns a successful HTTP response.\n\n**Specific Functionality or Behavior Verified**:  \nThis test confirms that when a GET request is made to the endpoint `/static/nested/dir/foo.txt`, the server responds with a status code of 200 (indicating success) and that the content of the response matches the expected text `\"foo\\n\"`. This ensures that the static file serving mechanism is functioning as intended for nested directories.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `app.static` method, which is used to serve static files from a specified directory. The `static_file_directory` argument points to the location where the static files are stored. The `app.test_client.get` method simulates an HTTP GET request to the specified path. The response is then checked for the correct status and content. The expected behavior is that the server retrieves the file `foo.txt` from the nested directory and serves it correctly.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the response's status and content, which is a common practice in unit testing to ensure that the actual output matches the expected output. Additionally, the test leverages the Sanic framework's built-in testing capabilities (`app.test_client`) to simulate requests and capture responses, allowing for effective integration testing of the static file serving functionality. The use of a fixture (`static_file_directory`) suggests that the test is set up to run in a controlled environment, ensuring that the necessary files and directories are available for testing."
    },
    {
      "name": "test_handle_is_a_directory_error",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 495,
      "end_line_number": 508,
      "source_code": "def test_handle_is_a_directory_error(app, static_file_directory):\n    error_text = \"Is a directory. Access denied\"\n    app.static(\"/static\", static_file_directory)\n\n    @app.exception(Exception)\n    async def handleStaticDirError(request, exception):\n        if isinstance(exception, IsADirectoryError):\n            return text(error_text, status=403)\n        raise exception\n\n    request, response = app.test_client.get(\"/static/\")\n\n    assert response.status == 403\n    assert response.text == error_text",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "static_file_directory"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 403",
        "assert response.text == error_text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.exception",
          "body": "@app.route('/')\ndef exception(request):\n    raise SanicExceptionTestException(\"You won't see me\")"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_handle_is_a_directory_error` test is to verify that the application correctly handles requests to a static directory by returning a specific error message and HTTP status code when a `IsADirectoryError` is raised.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a request is made to a static directory (in this case, `/static/`), the application raises an `IsADirectoryError`, which is then caught by a custom exception handler. The handler should return a 403 Forbidden status along with a specific error message indicating that access to a directory is denied.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a static file route using `app.static(\"/static\", static_file_directory)`. It then defines an exception handler using `@app.exception(Exception)` that checks if the raised exception is an instance of `IsADirectoryError`. If it is, the handler returns a response with the error message and a 403 status. The test then simulates a GET request to the `/static/` endpoint and asserts that the response status is 403 and the response text matches the expected error message.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Custom Exception Handling**: The test demonstrates how to define a custom exception handler for specific error types, allowing for tailored responses based on the nature of the error.\n- **Asynchronous Testing**: The use of `async def` for the exception handler indicates that the application is likely using asynchronous programming, which is common in web frameworks like Sanic.\n- **Assertions**: The test employs assertions to validate the response status and content, ensuring that the application behaves as expected under error conditions."
    },
    {
      "name": "test_stack_trace_on_not_found",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 511,
      "end_line_number": 523,
      "source_code": "def test_stack_trace_on_not_found(app, static_file_directory, caplog):\n    app.static(\"/static\", static_file_directory)\n\n    with caplog.at_level(logging.INFO):\n        _, response = app.test_client.get(\"/static/non_existing_file.file\")\n\n    counter = Counter([(r[0], r[1]) for r in caplog.record_tuples])\n\n    assert response.status == 404\n    assert counter[(\"sanic.root\", logging.INFO)] == 10\n    assert counter[(\"sanic.root\", logging.ERROR)] == 0\n    assert counter[(\"sanic.error\", logging.ERROR)] == 0\n    assert counter[(\"sanic.server\", logging.INFO)] == 3",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "static_file_directory",
        "caplog"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 404",
        "assert counter['sanic.root', logging.INFO] == 10",
        "assert counter['sanic.root', logging.ERROR] == 0",
        "assert counter['sanic.error', logging.ERROR] == 0",
        "assert counter['sanic.server', logging.INFO] == 3"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_stack_trace_on_not_found` test is designed to verify that when a requested static file is not found, the application correctly returns a 404 status code and logs the appropriate information without generating error logs.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the application logs informational messages related to the request for a non-existing file while ensuring that no error logs are generated for this scenario. It specifically verifies the count of log messages at different severity levels to confirm that the logging behavior is as expected.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `app.test_client.get` method to simulate an HTTP GET request for a static file that does not exist. The `app.static` method is used to define the static file directory. The response is expected to have a status of 404, indicating that the file was not found. The `caplog` fixture captures log messages during the test execution, allowing the test to analyze the log output.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Log Capture**: The use of the `caplog` fixture allows for capturing log messages at a specified logging level, which is crucial for verifying logging behavior in the test.\n- **Counter for Log Messages**: The `Counter` from the `collections` module is employed to tally the occurrences of log messages, enabling precise assertions about the number of logs generated at different levels.\n- **Assertions**: The test includes multiple assertions to validate both the response status and the log message counts, ensuring comprehensive verification of the application's behavior in response to the missing file request."
    },
    {
      "name": "test_no_stack_trace_on_not_found",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 526,
      "end_line_number": 543,
      "source_code": "def test_no_stack_trace_on_not_found(app, static_file_directory, caplog):\n    app.static(\"/static\", static_file_directory)\n\n    @app.exception(FileNotFound)\n    async def file_not_found(request, exception):\n        return text(f\"No file: {request.path}\", status=404)\n\n    with caplog.at_level(logging.INFO):\n        _, response = app.test_client.get(\"/static/non_existing_file.file\")\n\n    counter = Counter([(r[0], r[1]) for r in caplog.record_tuples])\n\n    assert response.status == 404\n    assert counter[(\"sanic.root\", logging.INFO)] == 10\n    assert counter[(\"sanic.root\", logging.ERROR)] == 0\n    assert counter[(\"sanic.error\", logging.ERROR)] == 0\n    assert counter[(\"sanic.server\", logging.INFO)] == 3\n    assert response.text == \"No file: /static/non_existing_file.file\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "static_file_directory",
        "caplog"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 404",
        "assert counter['sanic.root', logging.INFO] == 10",
        "assert counter['sanic.root', logging.ERROR] == 0",
        "assert counter['sanic.error', logging.ERROR] == 0",
        "assert counter['sanic.server', logging.INFO] == 3",
        "assert response.text == 'No file: /static/non_existing_file.file'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.exception",
          "body": "@app.route('/')\ndef exception(request):\n    raise SanicExceptionTestException(\"You won't see me\")"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_no_stack_trace_on_not_found` test is to verify that when a requested static file is not found, the application responds with a 404 status code and a user-friendly error message, while ensuring that no stack trace is logged for this error.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the application correctly handles a `FileNotFound` exception by returning a 404 response with a message indicating that the requested file does not exist. It also verifies that the logging behavior is appropriate, ensuring that informational logs are generated while error logs for this specific case are not.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a Sanic application with a static file route and an exception handler for `FileNotFound`. When a GET request is made to a non-existing file, the `file_not_found` handler is invoked, which returns a 404 response with a message. The test then checks the response status and the content of the response, as well as the log entries generated during the request.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Logging Capture**: The test uses `caplog` to capture log messages at the INFO level, allowing verification of the number of log entries generated during the request.\n- **Counter for Log Assertions**: A `Counter` is employed to tally the log messages, making it easy to assert the expected counts of specific log levels and categories.\n- **Asynchronous Testing**: The test is designed to work with asynchronous code, which is common in web frameworks like Sanic, ensuring that the test can handle the async nature of the request and response cycle."
    },
    {
      "name": "test_multiple_statics",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 558,
      "end_line_number": 576,
      "source_code": "def test_multiple_statics(app, static_file_directory):\n    app.static(\n        \"/file\", get_file_path(static_file_directory, \"test.file\"), name=\"file\"\n    )\n    app.static(\n        \"/png\", get_file_path(static_file_directory, \"python.png\"), name=\"png\"\n    )\n\n    _, response = app.test_client.get(\"/file\")\n    assert response.status == 200\n    assert response.body == get_file_content(\n        static_file_directory, \"test.file\"\n    )\n\n    _, response = app.test_client.get(\"/png\")\n    assert response.status == 200\n    assert response.body == get_file_content(\n        static_file_directory, \"python.png\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "static_file_directory"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, 'test.file')",
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, 'python.png')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_multiple_statics` function is designed to verify that the Sanic application can serve multiple static files correctly. It ensures that requests to specific endpoints return the expected files with the correct HTTP status codes.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a GET request is made to the `/file` and `/png` endpoints, the server responds with a status code of 200 (indicating success) and that the response body matches the content of the corresponding static files (`test.file` and `python.png`). This confirms that the static file serving mechanism is functioning as intended.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `app.static` method, which registers static file routes in the Sanic application. The `get_file_path` function constructs the file path based on the provided directory and file name, while `get_file_content` reads the content of the specified file. The test uses `app.test_client.get` to simulate HTTP GET requests to the registered static file routes, checking the responses against the expected outcomes.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs direct assertions to validate the response status and body, which is a common pattern in unit testing. It also utilizes helper functions (`get_file_path` and `get_file_content`) to abstract file path construction and content retrieval, promoting code reusability and clarity. The use of the Sanic test client allows for effective simulation of HTTP requests, making it easier to test the application's behavior in a controlled environment."
    },
    {
      "name": "test_resource_type_default",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 592,
      "end_line_number": 605,
      "source_code": "def test_resource_type_default(app, static_file_directory):\n    app.static(\"/static\", static_file_directory, name=\"static\")\n    app.static(\n        \"/file\", get_file_path(static_file_directory, \"test.file\"), name=\"file\"\n    )\n\n    _, response = app.test_client.get(\"/static\")\n    assert response.status == 404\n\n    _, response = app.test_client.get(\"/file\")\n    assert response.status == 200\n    assert response.body == get_file_content(\n        static_file_directory, \"test.file\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "static_file_directory"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 404",
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, 'test.file')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_resource_type_default` test case is designed to verify the behavior of the Sanic application when serving static files. Specifically, it checks that a request to a static directory returns a 404 status when no file is found, while a request to a specific file returns a 200 status along with the correct file content.\n\n**Specific Functionality or Behavior Verified**:  \nThis test verifies two key behaviors: \n1. Accessing a static directory (\"/static\") should return a 404 status code, indicating that the directory itself does not serve a default file.\n2. Accessing a specific file (\"/file\") should return a 200 status code and the correct content of the file, confirming that the file is served correctly.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the Sanic application through its test client. It sets up static routes using `app.static()` to serve files from a specified directory. The `get_file_path` function constructs the path to the file, while `get_file_content` reads the file's content. The test then makes GET requests to the defined static routes and asserts the expected HTTP status codes and response body content.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Setup and Teardown**: The test sets up static routes before making requests, ensuring the application is in the correct state for testing.\n- **Assertions**: It uses assertions to validate the response status and body, which is a common practice in unit testing to ensure expected outcomes.\n- **Separation of Concerns**: The test focuses on specific routes and their expected behaviors, adhering to the principle of testing one aspect at a time, which enhances clarity and maintainability."
    },
    {
      "name": "test_resource_type_file",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 608,
      "end_line_number": 622,
      "source_code": "def test_resource_type_file(app, static_file_directory):\n    app.static(\n        \"/file\",\n        get_file_path(static_file_directory, \"test.file\"),\n        resource_type=\"file\",\n    )\n\n    _, response = app.test_client.get(\"/file\")\n    assert response.status == 200\n    assert response.body == get_file_content(\n        static_file_directory, \"test.file\"\n    )\n\n    with pytest.raises(TypeError):\n        app.static(\"/static\", static_file_directory, resource_type=\"file\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "static_file_directory"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, 'test.file')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_resource_type_file` unit test is designed to verify the functionality of serving static files in a Sanic web application. It specifically checks that a file can be correctly served from a specified path and that the application raises an appropriate error when an invalid resource type is used.\n\n**Specific Functionality or Behavior Verified**:  \nThe test ensures that when a static file is requested via the `/file` endpoint, the server responds with a status code of 200 (indicating success) and that the content of the response matches the expected content of the file being served. Additionally, it verifies that attempting to register a static resource with an invalid type raises a `TypeError`.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `app.static` method to register a static file resource. The `get_file_path` function constructs the full path to the file based on the provided directory and filename. The `app.test_client.get` method simulates an HTTP GET request to the `/file` endpoint, and the response is checked for the correct status and body content. The `get_file_content` function reads the actual content of the file to compare it against the response body.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertions**: The test uses assertions to validate the response status and body content, ensuring that the application behaves as expected.\n- **Exception Testing**: The test employs `pytest.raises` to check for the correct handling of exceptions, specifically verifying that a `TypeError` is raised when an invalid resource type is specified.\n- **Separation of Concerns**: The test is structured to focus on a single aspect of functionality (serving static files), which aligns with best practices in unit testing by ensuring that tests are clear and maintainable."
    },
    {
      "name": "test_resource_type_dir",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 625,
      "end_line_number": 639,
      "source_code": "def test_resource_type_dir(app, static_file_directory):\n    app.static(\"/static\", static_file_directory, resource_type=\"dir\")\n\n    _, response = app.test_client.get(\"/static/test.file\")\n    assert response.status == 200\n    assert response.body == get_file_content(\n        static_file_directory, \"test.file\"\n    )\n\n    with pytest.raises(TypeError):\n        app.static(\n            \"/file\",\n            get_file_path(static_file_directory, \"test.file\"),\n            resource_type=\"dir\",\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "static_file_directory"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, 'test.file')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_resource_type_dir` unit test is designed to verify the behavior of the Sanic application when serving static files from a directory. It ensures that the application correctly serves a file when accessed via a specified static route and checks that an appropriate error is raised when attempting to serve a file as a directory.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main functionalities: \n1. It verifies that a static file (`test.file`) can be successfully retrieved with a 200 status code and that the content matches the expected file content.\n2. It confirms that a `TypeError` is raised when trying to serve a file path as a directory, which is an invalid operation.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `app.static` method to set up a static file route. The `app.test_client.get` method is used to simulate an HTTP GET request to retrieve the static file. The `get_file_content` function reads the content of the specified file from the static directory, which is then compared to the response body to ensure they match. The `get_file_path` function is used to construct the file path for the invalid operation, which is expected to raise a `TypeError`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the response status and body, ensuring that the expected outcomes are met. It also utilizes the `pytest.raises` context manager to assert that a specific exception (`TypeError`) is raised during the invalid operation. This pattern is effective for testing error handling in the code, ensuring robustness against incorrect usage. Additionally, the test is structured to be clear and concise, focusing on specific behaviors without unnecessary complexity."
    },
    {
      "name": "test_resource_type_unknown",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 642,
      "end_line_number": 644,
      "source_code": "def test_resource_type_unknown(app, static_file_directory, caplog):\n    with pytest.raises(ValueError):\n        app.static(\"/static\", static_file_directory, resource_type=\"unknown\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "static_file_directory",
        "caplog"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_resource_type_unknown` unit test is designed to verify that the application correctly raises a `ValueError` when an invalid `resource_type` (\"unknown\") is provided to the `app.static()` method. This ensures that the application enforces valid configurations for serving static files.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks the error handling mechanism of the `app.static()` method when it encounters an unsupported `resource_type`. It confirms that the application does not accept arbitrary or invalid resource types, thereby maintaining the integrity of its static file serving functionality.\n\n**Code Being Tested and How It Works**:  \nThe relevant code being tested is the conditional logic within the `app.static()` method that checks the value of `resource_type`. If the `resource_type` is neither \"file\" nor \"dir\", the method raises a `ValueError`. The test simulates this scenario by calling `app.static()` with \"unknown\" as the `resource_type`, expecting the specified exception to be raised.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises()` context manager to assert that a specific exception (`ValueError`) is raised during the execution of the code block. This is a common pattern in unit testing that allows for clean and readable verification of error conditions. Additionally, the test is structured to be part of a larger suite of tests, leveraging fixtures like `app` and `static_file_directory` to set up the necessary context for the test."
    },
    {
      "name": "test_dotted_dir_ok",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 651,
      "end_line_number": 660,
      "source_code": "def test_dotted_dir_ok(\n    app: Sanic, static_file_directory: str, double_dotted_directory_file: Path\n):\n    app.static(\"/foo\", static_file_directory)\n    dot_relative_path = str(\n        double_dotted_directory_file.relative_to(static_file_directory)\n    )\n    _, response = app.test_client.get(\"/foo/\" + dot_relative_path)\n    assert response.status == 200\n    assert response.body == b\"DOT\\n\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(sys.platform == 'win32', reason='Windows does not support double dotted directories')"
      ],
      "arguments": [
        "app",
        "static_file_directory",
        "double_dotted_directory_file"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == b'DOT\\n'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_dotted_dir_ok` test case is designed to verify that the Sanic application correctly serves files from a static directory when accessed using a double-dotted path. This is particularly important for ensuring that the application handles relative paths securely and correctly.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that a file located in a subdirectory of the static file directory can be accessed using a relative path that includes a double dot (`..`). It asserts that the HTTP response status is `200 OK` and that the content of the response matches the expected byte string `b\"DOT\\n\"`.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `app.static` method, which sets up a static file serving route in the Sanic application. The test first registers a static route at `/foo` pointing to `static_file_directory`. It then constructs a relative path to the `double_dotted_directory_file` and makes a GET request to the constructed URL. The response is then validated for both status and body content.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses parameters (`app`, `static_file_directory`, `double_dotted_directory_file`) to allow for flexible testing with different configurations and inputs.\n- **Assertions**: The test employs assertions to validate the response status and body, ensuring that the application behaves as expected.\n- **Path Manipulation**: The use of `relative_to` from the `Path` class demonstrates effective handling of file paths, which is crucial for testing file access in a directory structure.\n- **Conditional Skipping**: The test is decorated with `@pytest.mark.skipif`, which conditionally skips the test on Windows platforms, acknowledging platform-specific behavior regarding double-dotted directories."
    },
    {
      "name": "test_breakout",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 663,
      "end_line_number": 670,
      "source_code": "def test_breakout(app: Sanic, static_file_directory: str):\n    app.static(\"/foo\", static_file_directory)\n\n    _, response = app.test_client.get(\"/foo/..%2Ffake/server.py\")\n    assert response.status == 404\n\n    _, response = app.test_client.get(\"/foo/..%2Fstatic/test.file\")\n    assert response.status == 404",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "static_file_directory"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 404",
        "assert response.status == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_breakout` function is designed to verify that the Sanic application correctly handles requests that attempt to access files outside of the designated static file directory. Specifically, it checks that such requests return a 404 Not Found status, ensuring that the application does not expose sensitive files or directories.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks the application's response to two specific requests that use path traversal techniques (i.e., `..%2F` which decodes to `../`). The expected behavior is that both requests should return a 404 status code, indicating that the requested resources are not found, thereby confirming that the application is secure against directory traversal attacks.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `app.static` method, which sets up a static file serving route for the Sanic application. The test uses `app.test_client.get` to simulate HTTP GET requests to the static file route. The first request attempts to access a file outside the static directory (`/foo/..%2Ffake/server.py`), and the second request tries to access another file outside the static directory (`/foo/..%2Fstatic/test.file`). Both requests are expected to yield a 404 response, which is asserted using `assert response.status == 404`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern to validate the expected outcomes of the HTTP requests. It uses the `assert` statement to check the response status codes directly. Additionally, the test leverages the Sanic testing client to simulate requests, which is a common technique in unit testing web applications to ensure that the application behaves as expected under various conditions. The use of path traversal in the request URLs is a notable aspect, as it specifically tests the application's security against a common vulnerability."
    },
    {
      "name": "test_double_backslash_prohibited_on_win32",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 676,
      "end_line_number": 684,
      "source_code": "def test_double_backslash_prohibited_on_win32(\n    app: Sanic, static_file_directory: str\n):\n    app.static(\"/foo\", static_file_directory)\n\n    _, response = app.test_client.get(\"/foo/static/..\\\\static/test.file\")\n    assert response.status == 404\n    _, response = app.test_client.get(\"/foo/static\\\\../static/test.file\")\n    assert response.status == 404",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(sys.platform != 'win32', reason='Block backslash on Windows only')"
      ],
      "arguments": [
        "app",
        "static_file_directory"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 404",
        "assert response.status == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_double_backslash_prohibited_on_win32` is designed to verify that the Sanic application correctly handles and rejects requests that attempt to access files using double backslashes in the path on a Windows platform. This is important for preventing directory traversal vulnerabilities that could allow unauthorized access to files.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that when a request is made with paths containing double backslashes (e.g., `..\\\\` and `static\\\\..`), the server responds with a 404 Not Found status. This indicates that the server is correctly interpreting these paths as invalid and is not allowing access to potentially sensitive files.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the Sanic application's static file serving functionality. The `app.static` method is used to define a static file directory, and the `app.test_client.get` method simulates HTTP GET requests to the defined static route. The test checks the response status for paths that include double backslashes, ensuring that the application does not serve files from these paths.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs parameterized testing by using the `@pytest.mark.skipif` decorator to conditionally skip the test on non-Windows platforms, ensuring that the test only runs in the appropriate environment. This is a common pattern in cross-platform applications to avoid false positives or negatives in tests. Additionally, the use of assertions to check the response status is a standard practice in unit testing to validate expected outcomes."
    },
    {
      "name": "test_ext_is_loaded",
      "module": "test_ext_integration",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_ext_integration.py",
      "line_number": 25,
      "end_line_number": 27,
      "source_code": "def test_ext_is_loaded(stoppable_app: Sanic, mock_sanic_ext, port):\n    stoppable_app.run(single_process=True, port=port)\n    mock_sanic_ext.Extend.assert_called_once_with(stoppable_app)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "stoppable_app",
        "mock_sanic_ext",
        "port"
      ],
      "imports": [
        "sys",
        "pytest",
        "sanic.Sanic",
        "sanic_ext"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "stoppable_app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_ext_is_loaded` test verifies that the Sanic application correctly loads the Sanic extensions when the application is run. It ensures that the `Extend` method of the mocked `sanic_ext` is called exactly once with the application instance as an argument.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the Sanic application (`stoppable_app`) invokes the extension loading mechanism when it is started. The assertion confirms that the `Extend` method is called with the correct parameters, indicating that the extension is properly integrated into the application lifecycle.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `run` method of the `stoppable_app`, which is a Sanic application instance. When `stoppable_app.run(single_process=True, port=port)` is executed, it simulates starting the application in a single process on the specified port. The `mock_sanic_ext.Extend.assert_called_once_with(stoppable_app)` line checks that the `Extend` method of the mocked `sanic_ext` was called once with the `stoppable_app` as its argument, confirming that the extension was loaded.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test uses a mock object (`mock_sanic_ext`) to simulate the behavior of the `sanic_ext` module, allowing the test to verify interactions without requiring the actual extension to be present.\n- **Fixture Usage**: The `stoppable_app` fixture sets up a Sanic application that can be started and stopped, providing a controlled environment for the test.\n- **Assertion**: The test employs `assert_called_once_with` to ensure that the expected method was called with the correct parameters, which is a common pattern in unit testing to verify interactions with dependencies."
    },
    {
      "name": "test_ext_is_not_loaded",
      "module": "test_ext_integration",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_ext_integration.py",
      "line_number": 30,
      "end_line_number": 33,
      "source_code": "def test_ext_is_not_loaded(stoppable_app: Sanic, mock_sanic_ext, port):\n    stoppable_app.config.AUTO_EXTEND = False\n    stoppable_app.run(single_process=True, port=port)\n    mock_sanic_ext.Extend.assert_not_called()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "stoppable_app",
        "mock_sanic_ext",
        "port"
      ],
      "imports": [
        "sys",
        "pytest",
        "sanic.Sanic",
        "sanic_ext"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "stoppable_app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_ext_is_not_loaded` test verifies that when the Sanic application is configured to not automatically load extensions (`AUTO_EXTEND` set to `False`), the `Extend` method of the mocked `sanic_ext` is not called during the application's startup process.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the extension loading mechanism is bypassed when the configuration explicitly disables it. It ensures that the application behaves correctly by not invoking any extension setup when it is not intended to.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `stoppable_app.run` method, which is responsible for starting the Sanic application. The `run` method constructs a command to start the server and captures its output. The test sets the `AUTO_EXTEND` configuration to `False`, runs the application, and then asserts that `mock_sanic_ext.Extend` was not called, confirming that no extensions were loaded.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test uses `mock_sanic_ext` to replace the actual `sanic_ext` module, allowing for verification of whether the `Extend` method was called without needing the real extension code.\n- **Configuration Testing**: It tests the behavior of the application based on configuration settings, ensuring that the application respects the `AUTO_EXTEND` flag.\n- **Isolation**: The use of a fixture (`stoppable_app`) ensures that the application is properly set up and torn down for each test, maintaining isolation between tests."
    },
    {
      "name": "test_extend_with_args",
      "module": "test_ext_integration",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_ext_integration.py",
      "line_number": 36,
      "end_line_number": 41,
      "source_code": "def test_extend_with_args(stoppable_app: Sanic, mock_sanic_ext, port):\n    stoppable_app.extend(built_in_extensions=False)\n    stoppable_app.run(single_process=True, port=port)\n    mock_sanic_ext.Extend.assert_called_once_with(\n        stoppable_app, built_in_extensions=False, config=None, extensions=None\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "stoppable_app",
        "mock_sanic_ext",
        "port"
      ],
      "imports": [
        "sys",
        "pytest",
        "sanic.Sanic",
        "sanic_ext"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "stoppable_app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_extend_with_args` unit test verifies that the `extend` method of the `stoppable_app` (an instance of the Sanic application) correctly invokes the `Extend` method of the `mock_sanic_ext` mock object with the expected arguments when the application is extended with specific parameters.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when the `extend` method is called with `built_in_extensions=False`, the `Extend` method is called exactly once with the correct parameters, including the application instance, the `built_in_extensions` flag, and default values for `config` and `extensions`.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `stoppable_app.extend` method, which is expected to set up extensions for the Sanic application. The `run` method of `stoppable_app` is called to simulate starting the application, but the primary focus is on the interaction with the `mock_sanic_ext.Extend` method. The assertion checks that `mock_sanic_ext.Extend` is called with the correct parameters, ensuring that the extension mechanism behaves as intended when configured with specific arguments.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test uses `mock_sanic_ext` to replace the actual extension functionality with a mock object, allowing for verification of interactions without executing the real extension logic.\n- **Assertions**: The test employs `assert_called_once_with` to ensure that the `Extend` method is called exactly once with the expected arguments, which is a common pattern in unit testing to validate interactions.\n- **Fixture Usage**: The `stoppable_app` fixture sets up a Sanic application instance that can be stopped after running, providing a controlled environment for the test. This encapsulates setup logic and promotes reusability across multiple tests."
    },
    {
      "name": "test_access_object_sets_up_extension",
      "module": "test_ext_integration",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_ext_integration.py",
      "line_number": 44,
      "end_line_number": 46,
      "source_code": "def test_access_object_sets_up_extension(app: Sanic, mock_sanic_ext):\n    app.ext\n    mock_sanic_ext.Extend.assert_called_once_with(app)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "mock_sanic_ext"
      ],
      "imports": [
        "sys",
        "pytest",
        "sanic.Sanic",
        "sanic_ext"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_access_object_sets_up_extension` verifies that the Sanic application correctly initializes its extension system when the `app.ext` attribute is accessed. It ensures that the `Extend` method of the mocked `sanic_ext` is called with the application instance.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that accessing the `app.ext` property triggers the setup of the Sanic extensions, confirming that the extension system is properly integrated with the application.\n\n**Code Being Tested and How It Works**:  \nThe relevant code being tested is the interaction between the Sanic application instance (`app`) and the `mock_sanic_ext` mock object. When `app.ext` is accessed, it is expected to call `mock_sanic_ext.Extend(app)`. The assertion `mock_sanic_ext.Extend.assert_called_once_with(app)` checks that this call occurred exactly once, indicating that the extension setup was executed as intended.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs mocking to isolate the behavior of the Sanic application from the actual implementation of the `sanic_ext` module. This allows for verification of interactions without requiring the real extension logic to be executed. The use of `assert_called_once_with` is a common pattern in unit tests to ensure that a specific method is called with the expected arguments, reinforcing the test's focus on behavior rather than implementation details."
    },
    {
      "name": "test_extend_cannot_be_called_multiple_times",
      "module": "test_ext_integration",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_ext_integration.py",
      "line_number": 49,
      "end_line_number": 57,
      "source_code": "def test_extend_cannot_be_called_multiple_times(app: Sanic, mock_sanic_ext):\n    app.extend()\n\n    message = \"Cannot extend Sanic after Sanic Extensions has been setup.\"\n    with pytest.raises(RuntimeError, match=message):\n        app.extend()\n    mock_sanic_ext.Extend.assert_called_once_with(\n        app, extensions=None, built_in_extensions=True, config=None\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "mock_sanic_ext"
      ],
      "imports": [
        "sys",
        "pytest",
        "sanic.Sanic",
        "sanic_ext"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_extend_cannot_be_called_multiple_times` test is to verify that the `Sanic` application correctly raises a `RuntimeError` when an attempt is made to extend the application after it has already been extended. This ensures that the extension mechanism is used correctly and prevents unintended behavior in the application lifecycle.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `app.extend()` method can only be called once. If it is called a second time, it should raise a `RuntimeError` with a specific error message indicating that extensions cannot be set up after they have already been initialized.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `extend` method of the `Sanic` class. The method checks if the application has already been extended by looking for an attribute (in this case, `_ext`). If this attribute exists, it raises a `RuntimeError` with the message \"Cannot extend Sanic after Sanic Extensions has been setup.\" The test first calls `app.extend()` to set up the extensions, and then it attempts to call `app.extend()` again within a context that expects an exception to be raised.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that a specific exception is raised, which is a common pattern in unit testing for verifying error conditions. Additionally, it uses the `match` parameter to ensure that the raised exception contains the expected error message, providing a more robust verification of the error handling. The test also verifies that the `mock_sanic_ext.Extend` method is called exactly once with the expected parameters, ensuring that the extension setup is performed correctly during the first call."
    },
    {
      "name": "test_fail_if_not_loaded",
      "module": "test_ext_integration",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_ext_integration.py",
      "line_number": 64,
      "end_line_number": 69,
      "source_code": "def test_fail_if_not_loaded(app: Sanic):\n    del sys.modules[\"sanic_ext\"]\n    with pytest.raises(\n        RuntimeError, match=\"Sanic Extensions is not installed.*\"\n    ):\n        app.extend(built_in_extensions=False)",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(SANIC_EXT_IN_ENV, reason='Running tests with sanic_ext already in the environment')"
      ],
      "arguments": [
        "app"
      ],
      "imports": [
        "sys",
        "pytest",
        "sanic.Sanic",
        "sanic_ext"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_fail_if_not_loaded` test is designed to verify that the Sanic application raises a `RuntimeError` when an attempt is made to extend the application without the `sanic_ext` module being loaded. This ensures that the application correctly handles the absence of required extensions.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the application fails gracefully by raising an appropriate exception when the `sanic_ext` module is not available in the environment. The error message must match a specific pattern indicating that Sanic Extensions are not installed.\n\n**Code Being Tested and How It Works**:  \nThe test modifies the Python environment by deleting the `sanic_ext` module from `sys.modules`, simulating a scenario where the module is not available. It then calls the `extend` method on the `app` instance with `built_in_extensions=False`. The expected behavior is that this call raises a `RuntimeError`, which is asserted using `pytest.raises`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management with `pytest.raises`**: This pattern is used to assert that a specific exception is raised during the execution of a block of code. It allows for clean and readable exception testing.\n- **Manipulation of `sys.modules`**: The test directly interacts with the Python module system to simulate the absence of a module, which is a powerful technique for testing error handling in scenarios where dependencies may not be present.\n- **Regular Expression Matching**: The use of the `match` parameter in `pytest.raises` allows for flexible verification of the exception message, ensuring that it contains the expected text while allowing for variations."
    },
    {
      "name": "test_can_access_app_ext_while_running",
      "module": "test_ext_integration",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_ext_integration.py",
      "line_number": 72,
      "end_line_number": 84,
      "source_code": "def test_can_access_app_ext_while_running(\n    app: Sanic, mock_sanic_ext, ext_instance, port\n):\n    class IceCream:\n        flavor: str\n\n    @app.before_server_start\n    async def injections(*_):\n        app.ext.injection(IceCream)\n        app.stop()\n\n    app.run(single_process=True, port=port)\n    ext_instance.injection.assert_called_with(IceCream)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "mock_sanic_ext",
        "ext_instance",
        "port"
      ],
      "imports": [
        "sys",
        "pytest",
        "sanic.Sanic",
        "sanic_ext"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_can_access_app_ext_while_running` is designed to verify that the Sanic application can successfully access and utilize an extension while the server is running. Specifically, it checks that the `injection` method of the extension is called with the correct class (`IceCream`) during the server's startup phase.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the application can register an extension (in this case, an injection of the `IceCream` class) before the server starts handling requests. It also confirms that the application can stop itself after the injection is performed, which is crucial for ensuring that the application behaves correctly in a running state.\n\n**Code Being Tested and How It Works**:  \nThe test defines a class `IceCream` and registers an asynchronous function `injections` to be called before the server starts. This function calls `app.ext.injection(IceCream)` to inject the `IceCream` class into the application context and then stops the application using `app.stop()`. The server is then run in a single process on a specified port. After the server has run, the test asserts that `ext_instance.injection` was called with `IceCream`, confirming that the injection occurred as expected.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The use of `async` in the `injections` function indicates that the test is designed to handle asynchronous operations, which is common in web frameworks like Sanic.\n- **Lifecycle Hooks**: The test utilizes the `@app.before_server_start` decorator to register a function that runs at a specific point in the application lifecycle, demonstrating how to hook into the server's startup process.\n- **Mocking**: The test relies on a mocked extension instance (`ext_instance`) to verify that the injection method was called correctly, which is a common practice in unit testing to isolate the unit of work from its dependencies."
    },
    {
      "name": "test_routes_with_host",
      "module": "test_url_for",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_for.py",
      "line_number": 10,
      "end_line_number": 22,
      "source_code": "def test_routes_with_host(app):\n    @app.route(\"/\", name=\"hostindex\", host=\"example.com\")\n    @app.route(\"/path\", name=\"hostpath\", host=\"path.example.com\")\n    def index(request):\n        pass\n\n    assert app.url_for(\"hostindex\") == \"/\"\n    assert app.url_for(\"hostpath\") == \"/path\"\n    assert app.url_for(\"hostindex\", _external=True) == \"http://example.com/\"\n    assert (\n        app.url_for(\"hostpath\", _external=True)\n        == \"http://path.example.com/path\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "pytest",
        "sanic_testing.testing.SanicTestClient",
        "sanic.blueprints.Blueprint"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.url_for('hostindex') == '/'",
        "assert app.url_for('hostpath') == '/path'",
        "assert app.url_for('hostindex', _external=True) == 'http://example.com/'",
        "assert app.url_for('hostpath', _external=True) == 'http://path.example.com/path'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_routes_with_host` function is designed to verify the correct behavior of route registration in a Sanic application when specific hostnames are used. It ensures that the application can generate URLs for routes that are associated with particular hostnames.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the `url_for` method correctly resolves the routes based on their names and the specified hostnames. It verifies both the internal URL paths and the external URLs that include the hostname, ensuring that the application can generate the correct URLs for different contexts.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `app.url_for` method, which is responsible for generating URLs based on route names. The routes are defined with specific hostnames using the `@app.route` decorator. The assertions in the test check that:\n- The internal URL for the route named \"hostindex\" is `/`.\n- The internal URL for the route named \"hostpath\" is `/path`.\n- The external URL for \"hostindex\" is `http://example.com/`.\n- The external URL for \"hostpath\" is `http://path.example.com/path`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs direct assertions to validate expected outcomes, which is a common pattern in unit testing. It uses the `assert` statement to compare the actual output of `app.url_for` against the expected values. This straightforward approach allows for quick identification of discrepancies between expected and actual behavior. Additionally, the test leverages route names to ensure that the correct routes are being referenced, demonstrating the use of named routes for clarity and maintainability in URL generation."
    },
    {
      "name": "test_routes_with_multiple_hosts",
      "module": "test_url_for",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_for.py",
      "line_number": 25,
      "end_line_number": 43,
      "source_code": "def test_routes_with_multiple_hosts(app):\n    @app.route(\"/\", name=\"hostindex\", host=[\"example.com\", \"path.example.com\"])\n    def index(request):\n        pass\n\n    assert app.url_for(\"hostindex\") == \"/\"\n    assert (\n        app.url_for(\"hostindex\", _host=\"example.com\") == \"http://example.com/\"\n    )\n\n    with pytest.raises(ValueError) as e:\n        assert app.url_for(\"hostindex\", _external=True)\n    assert str(e.value).startswith(\"Host is ambiguous\")\n\n    with pytest.raises(ValueError) as e:\n        assert app.url_for(\"hostindex\", _host=\"unknown.com\")\n    assert str(e.value).startswith(\n        \"Requested host (unknown.com) is not available for this route\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "pytest",
        "sanic_testing.testing.SanicTestClient",
        "sanic.blueprints.Blueprint"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.url_for('hostindex') == '/'",
        "assert app.url_for('hostindex', _host='example.com') == 'http://example.com/'",
        "assert str(e.value).startswith('Host is ambiguous')",
        "assert str(e.value).startswith('Requested host (unknown.com) is not available for this route')",
        "assert app.url_for('hostindex', _external=True)",
        "assert app.url_for('hostindex', _host='unknown.com')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_routes_with_multiple_hosts` function is designed to verify the behavior of the `url_for` method in the Sanic framework when routing requests to multiple hosts. It ensures that the application correctly handles routes that can be accessed via different hostnames and raises appropriate errors for ambiguous or invalid host requests.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks the following behaviors:\n1. It confirms that the `url_for` method returns the correct URL for the route when accessed without specifying a host.\n2. It verifies that the method returns the correct external URL when a valid host is specified.\n3. It ensures that a `ValueError` is raised when the host is ambiguous (i.e., when `_external=True` is called without specifying a host).\n4. It checks that a `ValueError` is raised when an unknown host is provided, ensuring that the application correctly restricts access to defined hosts.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `url_for` method of the Sanic application, which constructs URLs based on the route definitions. The relevant route is defined with multiple hosts (`example.com` and `path.example.com`). The method checks if the requested host is valid and whether it is ambiguous when multiple hosts are defined. If the host is not specified and multiple options exist, it raises a `ValueError` indicating ambiguity. If an invalid host is provided, it raises a `ValueError` indicating that the requested host is not available for the route.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Assertions**: It uses assertions to validate expected outcomes, such as checking the constructed URLs and the raised exceptions.\n- **Exception Testing**: The test utilizes `pytest.raises` to assert that specific exceptions are raised under certain conditions, which is a common practice for testing error handling in unit tests.\n- **Parameterization**: While not directly used in this specific test, the surrounding context shows the use of `pytest.mark.parametrize`, indicating a broader strategy for testing multiple scenarios efficiently. This pattern can be beneficial for testing various combinations of inputs and expected outputs."
    },
    {
      "name": "test_websocket_bp_route_name",
      "module": "test_url_for",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_for.py",
      "line_number": 54,
      "end_line_number": 83,
      "source_code": "def test_websocket_bp_route_name(app, name, expected):\n    \"\"\"Tests that blueprint websocket route is named.\"\"\"\n    event = asyncio.Event()\n    bp = Blueprint(\"test_bp\", url_prefix=\"/bp\")\n\n    @bp.get(\"/main\")\n    async def main(request): ...\n\n    @bp.websocket(\"/route\")\n    async def test_route(request, ws):\n        event.set()\n\n    @bp.websocket(\"/route2\")\n    async def test_route2(request, ws):\n        event.set()\n\n    @bp.websocket(\"/route3\", name=\"foobar_3\")\n    async def test_route3(request, ws):\n        event.set()\n\n    app.blueprint(bp)\n\n    uri = app.url_for(\"test_bp.main\")\n    assert uri == \"/bp/main\"\n\n    uri = app.url_for(f\"test_bp.{name}\")\n    assert uri == expected\n    request, response = SanicTestClient(app).websocket(uri)\n    assert response.opened is True\n    assert event.is_set()",
      "docstring": "Tests that blueprint websocket route is named.",
      "decorators": [
        "pytest.mark.parametrize('name,expected', (('test_route', '/bp/route'), ('test_route2', '/bp/route2'), ('foobar_3', '/bp/route3')))"
      ],
      "arguments": [
        "app",
        "name",
        "expected"
      ],
      "imports": [
        "asyncio",
        "pytest",
        "sanic_testing.testing.SanicTestClient",
        "sanic.blueprints.Blueprint"
      ],
      "fixtures": [],
      "assertions": [
        "assert uri == '/bp/main'",
        "assert uri == expected",
        "assert response.opened is True",
        "assert event.is_set()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "bp.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_websocket_bp_route_name` test is to verify that the websocket routes defined within a Sanic blueprint are correctly named and can be accessed as expected. It ensures that the routing mechanism of the Sanic application correctly resolves the URLs for the websocket endpoints.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that:\n1. The URL generated for the main route of the blueprint is correct.\n2. The URL generated for a specific websocket route (based on the provided `name` parameter) matches the expected URL.\n3. The websocket connection can be successfully established and that the event signaling the connection is set, indicating that the websocket handler was invoked.\n\n**Code Being Tested and How It Works**:  \nThe test defines a Sanic blueprint with multiple websocket routes. It uses the `app.url_for` method to generate URLs for these routes based on their names. The test then asserts that:\n- The URL for the main route (`/bp/main`) is correctly generated.\n- The URL for the specified websocket route (e.g., `/bp/route3` when `name` is \"foobar_3\") matches the expected value.\n- A websocket connection to the generated URL is opened successfully, and the event is set, confirming that the websocket handler was executed.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test is designed to be parameterized, allowing it to run with different values for `name` and `expected`, which enhances test coverage without duplicating code.\n- **Asynchronous Testing**: The use of `async` functions and `asyncio.Event` demonstrates how to handle asynchronous operations in tests, ensuring that the websocket connection and event signaling are properly managed.\n- **Assertions**: The test employs assertions to validate the correctness of the generated URLs and the state of the websocket connection, which is a standard practice in unit testing to confirm expected outcomes."
    },
    {
      "name": "test_trailing_slash_url_for",
      "module": "test_url_for",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_for.py",
      "line_number": 97,
      "end_line_number": 102,
      "source_code": "def test_trailing_slash_url_for(app, path, strict, expected):\n    @app.route(path, strict_slashes=strict)\n    def handler(*_): ...\n\n    url = app.url_for(\"handler\")\n    assert url == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('path,strict,expected', (('/foo', False, '/foo'), ('/foo/', False, '/foo'), ('/foo', True, '/foo'), ('/foo/', True, '/foo/')))"
      ],
      "arguments": [
        "app",
        "path",
        "strict",
        "expected"
      ],
      "imports": [
        "asyncio",
        "pytest",
        "sanic_testing.testing.SanicTestClient",
        "sanic.blueprints.Blueprint"
      ],
      "fixtures": [],
      "assertions": [
        "assert url == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_trailing_slash_url_for` test is designed to verify the behavior of the `app.url_for` method in generating URLs for routes defined in a Sanic application, specifically focusing on how it handles trailing slashes based on the `strict_slashes` parameter.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks whether the generated URL matches the expected URL when a route is defined with or without a trailing slash. It ensures that the `strict_slashes` setting correctly influences the URL generation, allowing for flexibility in how routes can be accessed.\n\n**Code Being Tested and How It Works**:  \nThe test defines a route using the `@app.route` decorator, where `path` specifies the URL pattern and `strict` determines whether the route should strictly require a trailing slash. The `app.url_for(\"handler\")` call generates the URL for the defined route, and the test asserts that this generated URL matches the `expected` value provided as an argument. The `handler` function is a placeholder that does not perform any operations but is necessary for the route definition.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test function takes multiple parameters (`app`, `path`, `strict`, `expected`), which allows it to be run with different sets of inputs, making it versatile and comprehensive in testing various scenarios.\n- **Assertion**: The use of `assert` to compare the generated URL with the expected URL is a straightforward and effective way to validate the functionality.\n- **Route Definition**: The test demonstrates the dynamic creation of routes and their associated handlers, showcasing how Sanic's routing system can be tested in isolation."
    },
    {
      "name": "test_check_app_default",
      "module": "test_typing",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/typing/test_typing.py",
      "line_number": 98,
      "end_line_number": 117,
      "source_code": "def test_check_app_default(\n    path_location: str, expected: List[Tuple[str, int]]\n) -> None:\n    output = run_check(f\"samples/{path_location}\")\n\n    for text, number in expected:\n        current = CURRENT_DIR / f\"samples/{path_location}\"\n        path = current.relative_to(CURRENT_DIR.parent)\n\n        target = Path.cwd()\n        while True:\n            note = _text_from_path(current, path, target, number, text)\n            try:\n                assert note in output, output\n            except AssertionError:\n                target = target.parent\n                if not target.exists() or target == target.parent:\n                    raise\n            else:\n                break",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('path_location,expected', (('app_default.py', [('sanic.app.Sanic[sanic.config.Config, types.SimpleNamespace]', 5)]), ('app_custom_config.py', [('sanic.app.Sanic[app_custom_config.CustomConfig, types.SimpleNamespace]', 10)]), ('app_custom_ctx.py', [('sanic.app.Sanic[sanic.config.Config, app_custom_ctx.Foo]', 9)]), ('app_fully_custom.py', [('sanic.app.Sanic[app_fully_custom.CustomConfig, app_fully_custom.Foo]', 14)]), ('request_custom_sanic.py', [('types.SimpleNamespace', 18), ('sanic.app.Sanic[request_custom_sanic.CustomConfig, types.SimpleNamespace]', 19)]), ('request_custom_ctx.py', [('request_custom_ctx.Foo', 16), ('sanic.app.Sanic[sanic.config.Config, types.SimpleNamespace]', 17)]), ('request_fully_custom.py', [('request_fully_custom.CustomRequest', 32), ('request_fully_custom.RequestContext', 33), ('sanic.app.Sanic[request_fully_custom.CustomConfig, request_fully_custom.Foo]', 34)])))"
      ],
      "arguments": [
        "path_location",
        "expected"
      ],
      "imports": [
        "subprocess",
        "pathlib.Path",
        "typing.List",
        "typing.Tuple",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert note in output, output"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "run_check",
          "body": "def run_check(path_location: str) -> str:\n    \"\"\"Use mypy to check the given path location and return the output.\"\"\"\n    mypy_path = 'mypy'\n    path = CURRENT_DIR / path_location\n    command = [mypy_path, path.resolve().as_posix()]\n    process = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)\n    output = process.stdout + process.stderr\n    return output"
        },
        {
          "name": "_text_from_path",
          "body": "def _text_from_path(base: Path, path: Path, target: Path, number: int, text: str) -> str:\n    relative_to_cwd = base.relative_to(target)\n    prefix = '.'.join(relative_to_cwd.parts[:-1])\n    text = text.replace(path.stem, f'{prefix}.{path.stem}')\n    return f'{path}:{number}: note: Revealed type is \"{text}\"'"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_check_app_default` function is designed to verify that the output of the `run_check` function, which runs the `mypy` type checker on a specified path, contains the expected type hints and notes for the given source files. It ensures that the type checking process produces the correct output based on the provided input files.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that for each expected note (a string indicating a type hint) and its corresponding line number, the output from `run_check` includes the correctly formatted note. This validates that the type hints are being revealed as expected by `mypy`, and that the output is correctly formatted according to the structure defined in `_text_from_path`.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes:\n- `run_check`: This function constructs a command to run `mypy` on a specified path and captures its output (both stdout and stderr). It returns the combined output as a string.\n- `_text_from_path`: This helper function formats the expected note string based on the path and line number, ensuring that the output matches the expected format for `mypy` notes.\n\nThe test iterates over a list of expected notes and line numbers, generating the expected output format using `_text_from_path` and checking if each note is present in the output from `run_check`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterized Testing**: The test uses a parameterized approach, allowing it to be run with different input values (`path_location` and `expected`), which enhances test coverage and reduces redundancy.\n- **Assertion Handling**: The test employs a loop with a try-except block to handle potential assertion failures gracefully, allowing it to check parent directories if the expected note is not found in the current directory's output. This demonstrates a robust approach to verifying output across different directory structures.\n- **Path Manipulation**: The test utilizes the `Path` class from the `pathlib` module for effective path manipulation, ensuring that the paths are handled correctly regardless of the operating system."
    },
    {
      "name": "test_setup_and_teardown_unix",
      "module": "test_socket",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_socket.py",
      "line_number": 10,
      "end_line_number": 17,
      "source_code": "def test_setup_and_teardown_unix():\n    socket_address = \"./test.sock\"\n    path = Path.cwd() / socket_address\n    assert not path.exists()\n    bind_unix_socket(socket_address)\n    assert path.exists()\n    remove_unix_socket(socket_address)\n    assert not path.exists()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pathlib.Path",
        "sanic.server.socket.bind_unix_socket",
        "sanic.server.socket.configure_socket",
        "sanic.server.socket.remove_unix_socket"
      ],
      "fixtures": [],
      "assertions": [
        "assert not path.exists()",
        "assert path.exists()",
        "assert not path.exists()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_setup_and_teardown_unix` function is designed to verify the correct setup and teardown of a Unix socket. It ensures that the socket is created and removed as expected, confirming that the `bind_unix_socket` and `remove_unix_socket` functions operate correctly.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks three key behaviors: \n1. It asserts that the socket file does not exist before binding.\n2. It verifies that the socket file is created after calling `bind_unix_socket`.\n3. It confirms that the socket file is removed after calling `remove_unix_socket`.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with two functions from the codebase:\n- `bind_unix_socket(socket_address)`: This function creates a Unix socket at the specified address. It first checks if the directory exists and if a socket already exists at that path. If not, it creates a new socket and binds it to the path.\n- `remove_unix_socket(socket_address)`: This function removes the socket file if it exists and is confirmed to be a socket. It checks the socket's status and unlinks it if it is not in use.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern to validate the existence of the socket file at various stages. It uses the `assert` statement to check conditions, which is a common practice in unit testing for verifying expected outcomes. The test also follows a setup-teardown pattern, where it prepares the environment (ensuring the socket does not exist), performs the action (binding and removing the socket), and then verifies the final state. This pattern is essential for ensuring that tests do not leave residual state that could affect subsequent tests."
    },
    {
      "name": "test_configure_socket",
      "module": "test_socket",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_socket.py",
      "line_number": 20,
      "end_line_number": 27,
      "source_code": "def test_configure_socket():\n    socket_address = \"./test.sock\"\n    path = Path.cwd() / socket_address\n    assert not path.exists()\n    configure_socket({\"unix\": socket_address, \"backlog\": 100})\n    assert path.exists()\n    remove_unix_socket(socket_address)\n    assert not path.exists()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pathlib.Path",
        "sanic.server.socket.bind_unix_socket",
        "sanic.server.socket.configure_socket",
        "sanic.server.socket.remove_unix_socket"
      ],
      "fixtures": [],
      "assertions": [
        "assert not path.exists()",
        "assert path.exists()",
        "assert not path.exists()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_configure_socket` function is designed to verify the correct configuration and management of a Unix socket within the Sanic framework. It ensures that the socket is created when configured and removed afterward, confirming the expected behavior of the `configure_socket` and `remove_unix_socket` functions.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks three key behaviors:\n1. The socket file does not exist before configuration.\n2. The socket file is created after calling `configure_socket`.\n3. The socket file is removed after calling `remove_unix_socket`, ensuring no residual files remain.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the following functions:\n- `configure_socket`: This function is expected to create a Unix socket at the specified address with a defined backlog.\n- `remove_unix_socket`: This function is expected to delete the Unix socket file.  \nThe test uses the `Path` class from the `pathlib` module to construct the path to the socket file and checks its existence using the `exists()` method.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Setup and Teardown**: The test implicitly sets up the environment by checking for the absence of the socket file before configuration and ensures cleanup by removing the socket afterward.\n- **Assertions**: The test employs assertions to validate the state of the file system before and after the socket configuration, which is a common practice in unit testing to confirm expected outcomes.\n- **Path Manipulation**: The use of `Path.cwd()` to create the socket path demonstrates a clean and platform-independent way to handle file paths in Python."
    },
    {
      "name": "test_manager_no_workers",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 34,
      "end_line_number": 37,
      "source_code": "def test_manager_no_workers():\n    message = \"Cannot serve with no workers\"\n    with pytest.raises(RuntimeError, match=message):\n        WorkerManager(0, fake_serve, {}, Mock(), (Mock(), Mock()), {})",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_manager_no_workers` test is to verify that the `WorkerManager` class raises a `RuntimeError` when it is instantiated with zero workers. This ensures that the system enforces a minimum requirement for worker processes, which is critical for the server's operation.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks the error handling mechanism of the `WorkerManager` class. It confirms that the class correctly identifies an invalid configuration (zero workers) and raises the appropriate exception with a specific error message, \"Cannot serve with no workers\".\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the instantiation of the `WorkerManager` class. The constructor of `WorkerManager` likely includes logic that checks the number of workers provided. If the number is zero, it raises a `RuntimeError`. The test uses the `pytest.raises` context manager to assert that this exception is raised during the instantiation process.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest` framework's `raises` context manager, which is a common pattern for testing exceptions in Python. By specifying the expected exception type and matching the error message, the test ensures that not only is the correct exception raised, but it also contains the expected message, providing a more robust verification of the error handling logic."
    },
    {
      "name": "test_terminate",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 41,
      "end_line_number": 48,
      "source_code": "def test_terminate(os_mock: Mock):\n    process = Mock()\n    process.pid = 1234\n    context = Mock()\n    context.Process.return_value = process\n    manager = WorkerManager(1, fake_serve, {}, context, (Mock(), Mock()), {})\n    manager.terminate()\n    os_mock.kill.assert_called_once_with(1234, SIGINT)",
      "docstring": null,
      "decorators": [
        "patch('sanic.worker.process.os')"
      ],
      "arguments": [
        "os_mock"
      ],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "manager.terminate",
          "body": "def terminate(proc):\n    if flags:\n        proc.send_signal(CTRL_BREAK_EVENT)\n    else:\n        proc.terminate()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_terminate` function is designed to verify that the `terminate` method of the `WorkerManager` class correctly sends a termination signal to a worker process when invoked. This ensures that the worker process can be gracefully shut down.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that the `os.kill` function is called once with the correct process ID (PID) and the signal `SIGINT`. This confirms that the `terminate` method is functioning as intended by signaling the worker process to terminate.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `terminate` method of the `WorkerManager` class. When `terminate` is called, it checks if any flags are set (not shown in the provided code) and either sends a `CTRL_BREAK_EVENT` or calls `proc.terminate()`. In this test, a mock process with a PID of `1234` is created, and the `terminate` method is invoked. The test then asserts that `os.kill` is called with the PID `1234` and the signal `SIGINT`, indicating that the process is being instructed to terminate.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `unittest.mock` library to create mock objects, allowing for isolation of the `terminate` method's behavior without needing to interact with real processes. The `@patch` decorator is used to replace the `os` module with a mock, enabling verification of the `kill` method call. This pattern is effective for unit testing as it allows for testing the logic of the method without side effects or dependencies on the actual operating system. Additionally, the use of assertions to check the call count and parameters of the mock enhances the reliability of the test."
    },
    {
      "name": "test_shutown",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 52,
      "end_line_number": 60,
      "source_code": "def test_shutown(os_mock: Mock):\n    process = Mock()\n    process.pid = 1234\n    process.is_alive.return_value = True\n    context = Mock()\n    context.Process.return_value = process\n    manager = WorkerManager(1, fake_serve, {}, context, (Mock(), Mock()), {})\n    manager.shutdown()\n    os_mock.kill.assert_called_once_with(1234, SIGINT)",
      "docstring": null,
      "decorators": [
        "patch('sanic.worker.process.os')"
      ],
      "arguments": [
        "os_mock"
      ],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "manager.shutdown",
          "body": "@app.after_server_start\ndef shutdown(*_):\n    app.stop()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_shutown` function is designed to verify that the `shutdown` method of the `WorkerManager` class correctly sends a termination signal (SIGINT) to the worker process when invoked.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when the `shutdown` method is called, it triggers the `os.kill` function with the correct process ID (PID) and signal (SIGINT). It ensures that the shutdown process is initiated properly, which is crucial for graceful termination of worker processes.\n\n**Code Being Tested and How It Works**:  \nThe test creates a mock process with a predefined PID (1234) and simulates that the process is alive. It then initializes a `WorkerManager` instance with this mock process and calls the `shutdown` method. The assertion checks that `os.kill` was called exactly once with the expected arguments, confirming that the shutdown logic is functioning as intended.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test uses the `Mock` class to create mock objects for the process and the `os` module, allowing isolation of the test from actual system calls and processes.\n- **Assertion**: The test employs `assert_called_once_with` to ensure that the `kill` function is called with the correct parameters, which is a common pattern in unit tests to verify interactions with mocked objects.\n- **Setup and Teardown**: Although not explicitly shown in this test, the use of mocks typically implies a setup phase where dependencies are replaced with mocks, ensuring that the test environment is controlled and predictable."
    },
    {
      "name": "test_kill",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 64,
      "end_line_number": 72,
      "source_code": "def test_kill(os_mock: Mock):\n    process = Mock()\n    process.pid = 1234\n    context = Mock()\n    context.Process.return_value = process\n    manager = WorkerManager(1, fake_serve, {}, context, (Mock(), Mock()), {})\n    with pytest.raises(ServerKilled):\n        manager.kill()\n    os_mock.kill.assert_called_once_with(1234, SIGKILL)",
      "docstring": null,
      "decorators": [
        "patch('sanic.worker.manager.os')"
      ],
      "arguments": [
        "os_mock"
      ],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_kill` function is designed to verify the behavior of the `kill` method in the `WorkerManager` class. Specifically, it checks that the method correctly attempts to terminate a worker process by sending a `SIGKILL` signal to the process identified by its PID.\n\n**Specific Functionality or Behavior Verified**:  \nThe test ensures that when the `kill` method is called, it raises a `ServerKilled` exception and that the `os.kill` function is invoked exactly once with the correct PID (1234) and the `SIGKILL` signal. This confirms that the process termination logic is functioning as intended.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `kill` method of the `WorkerManager` class. The test sets up a mock process with a predefined PID (1234) and a mock context that simulates the behavior of the process management system. When `manager.kill()` is called, it is expected to raise a `ServerKilled` exception, indicating that the server has been instructed to terminate. The test also verifies that the `os.kill` function is called with the correct parameters, ensuring that the intended process is targeted for termination.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest` framework along with mocking techniques from the `unittest.mock` library. The `os_mock` parameter is a mock object that simulates the `os` module, allowing the test to intercept calls to `os.kill` without affecting the actual operating system. The use of `pytest.raises` is a common pattern for asserting that specific exceptions are raised during the execution of code, which enhances the robustness of the test by ensuring that error handling is properly implemented."
    },
    {
      "name": "test_shutdown_signal_send_kill",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 77,
      "end_line_number": 90,
      "source_code": "def test_shutdown_signal_send_kill(\n    manager_os_mock: Mock, process_os_mock: Mock\n):\n    process = Mock()\n    process.pid = 1234\n    context = Mock()\n    context.Process.return_value = process\n    manager = WorkerManager(1, fake_serve, {}, context, (Mock(), Mock()), {})\n    assert manager._shutting_down is False\n    manager.shutdown_signal(SIGINT, None)\n    assert manager._shutting_down is True\n    process_os_mock.kill.assert_called_once_with(1234, SIGINT)\n    manager.shutdown_signal(SIGINT, None)\n    manager_os_mock.kill.assert_called_once_with(1234, SIGKILL)",
      "docstring": null,
      "decorators": [
        "patch('sanic.worker.process.os')",
        "patch('sanic.worker.manager.os')"
      ],
      "arguments": [
        "manager_os_mock",
        "process_os_mock"
      ],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [
        "assert manager._shutting_down is False",
        "assert manager._shutting_down is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_shutdown_signal_send_kill` test is designed to verify the behavior of the `WorkerManager` class when it receives a shutdown signal (specifically `SIGINT`). It ensures that the manager correctly transitions to a shutting down state and that the appropriate kill signals are sent to the worker process.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main behaviors: \n1. It verifies that the `_shutting_down` attribute of the `WorkerManager` instance is initially `False` and changes to `True` after the shutdown signal is sent.\n2. It confirms that the correct operating system kill signals (`SIGINT` and `SIGKILL`) are sent to the worker process when the shutdown signal is invoked.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `WorkerManager` class, which manages worker processes for a Sanic application. The `shutdown_signal` method is called with `SIGINT`, which should set the `_shutting_down` attribute to `True` and trigger the process to be killed. The test uses mocks to simulate the behavior of the operating system's process management functions, allowing it to assert that the correct signals are sent without actually terminating any processes.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test uses the `Mock` class to create mock objects for the operating system's process management functions (`os.kill`). This allows the test to verify interactions with these functions without executing them.\n- **Assertions**: The test employs assertions to check the state of the `WorkerManager` and to confirm that the expected methods on the mocks were called with the correct arguments.\n- **Signal Handling**: The test specifically checks the handling of shutdown signals, which is a common pattern in server applications to gracefully shut down processes."
    },
    {
      "name": "test_restart_all",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 93,
      "end_line_number": 130,
      "source_code": "def test_restart_all():\n    p1 = Mock()\n    p2 = Mock()\n    context = Mock()\n    context.Process.side_effect = [p1, p2, p1, p2]\n    manager = WorkerManager(2, fake_serve, {}, context, (Mock(), Mock()), {})\n    assert len(list(manager.transient_processes))\n    manager.restart()\n    p1.terminate.assert_called_once()\n    p2.terminate.assert_called_once()\n    context.Process.assert_has_calls(\n        [\n            call(\n                name=\"Sanic-Server-0-0\",\n                target=fake_serve,\n                kwargs={},\n                daemon=True,\n            ),\n            call(\n                name=\"Sanic-Server-1-0\",\n                target=fake_serve,\n                kwargs={},\n                daemon=True,\n            ),\n            call(\n                name=\"Sanic-Server-0-0\",\n                target=fake_serve,\n                kwargs={},\n                daemon=True,\n            ),\n            call(\n                name=\"Sanic-Server-1-0\",\n                target=fake_serve,\n                kwargs={},\n                daemon=True,\n            ),\n        ]\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(list(manager.transient_processes))"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_restart_all` function is designed to verify the behavior of the `WorkerManager` class when the `restart` method is called. Specifically, it checks that all transient processes are terminated and that new processes are created correctly.\n\n**Specific Functionality or Behavior Verified**:  \nThe test ensures that when `manager.restart()` is invoked, it successfully terminates existing worker processes (`p1` and `p2`) and subsequently creates new instances of these processes. It also verifies that the correct calls are made to the `context.Process` to instantiate the new processes with the expected parameters.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `WorkerManager` class, which manages worker processes for a Sanic application. The `restart` method is expected to terminate existing processes and start new ones. The test uses mocks to simulate the behavior of the worker processes and the context in which they are created. The `context.Process.side_effect` is set to return mock process instances (`p1` and `p2`) when new processes are created, allowing the test to assert that the correct methods are called on these mock instances.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test employs the `Mock` class from the `unittest.mock` module to create mock objects for processes and the context, allowing for isolation of the `WorkerManager` behavior without relying on actual process management.\n- **Assertions**: The test uses assertions to verify that the expected methods (`terminate` and `assert_has_calls`) are called on the mock objects, ensuring that the `restart` method behaves as intended.\n- **Call Verification**: The use of `assert_has_calls` allows the test to check that the correct sequence of calls to `context.Process` is made, ensuring that the new processes are instantiated with the expected parameters."
    },
    {
      "name": "test_monitor_all",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 134,
      "end_line_number": 160,
      "source_code": "def test_monitor_all(zero_downtime):\n    p1 = Mock()\n    p2 = Mock()\n    sub = Mock()\n    incoming = (\n        \"__ALL_PROCESSES__::STARTUP_FIRST\"\n        if zero_downtime\n        else \"__ALL_PROCESSES__:\"\n    )\n    sub.recv.side_effect = [incoming, \"\"]\n    context = Mock()\n    context.Process.side_effect = [p1, p2]\n    manager = WorkerManager(2, fake_serve, {}, context, (Mock(), sub), {})\n    manager.restart = Mock()  # type: ignore\n    manager.wait_for_ack = Mock()  # type: ignore\n    manager.monitor()\n\n    restart_order = (\n        RestartOrder.STARTUP_FIRST\n        if zero_downtime\n        else RestartOrder.SHUTDOWN_FIRST\n    )\n    manager.restart.assert_called_once_with(\n        process_names=None,\n        reloaded_files=\"\",\n        restart_order=restart_order,\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('zero_downtime', (False, True))"
      ],
      "arguments": [
        "zero_downtime"
      ],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_monitor_all` function is designed to verify the behavior of the `monitor` method in the `WorkerManager` class, specifically how it handles the monitoring of worker processes and the subsequent restart logic based on the incoming messages.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the `restart` method of the `WorkerManager` is called with the correct parameters depending on whether the `zero_downtime` flag is set. It ensures that the restart order is appropriately determined and that the manager reacts correctly to the messages received from the worker processes.\n\n**Code Being Tested and How It Works**:  \nThe `monitor` method in the `WorkerManager` class is responsible for managing worker processes, including waiting for acknowledgments and processing messages. The test simulates the reception of messages indicating whether to start up or shut down the processes. It uses mocks to simulate the behavior of worker processes and the message subscription, allowing the test to focus on the logic of the `monitor` method without needing actual worker processes.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test extensively uses the `Mock` class from the `unittest.mock` module to create mock objects for processes and subscriptions, allowing for isolation of the unit under test.\n- **Parameterization**: The test is parameterized with `zero_downtime` values (True and False), enabling the verification of different scenarios in a single test function.\n- **Assertions**: The test asserts that the `restart` method is called exactly once with the expected parameters, ensuring that the logic within the `monitor` method behaves as intended based on the input conditions."
    },
    {
      "name": "test_monitor_all_with_files",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 164,
      "end_line_number": 190,
      "source_code": "def test_monitor_all_with_files(zero_downtime):\n    p1 = Mock()\n    p2 = Mock()\n    sub = Mock()\n    incoming = (\n        \"__ALL_PROCESSES__:foo,bar:STARTUP_FIRST\"\n        if zero_downtime\n        else \"__ALL_PROCESSES__:foo,bar\"\n    )\n    sub.recv.side_effect = [incoming, \"\"]\n    context = Mock()\n    context.Process.side_effect = [p1, p2]\n    manager = WorkerManager(2, fake_serve, {}, context, (Mock(), sub), {})\n    manager.restart = Mock()  # type: ignore\n    manager.wait_for_ack = Mock()  # type: ignore\n    manager.monitor()\n\n    restart_order = (\n        RestartOrder.STARTUP_FIRST\n        if zero_downtime\n        else RestartOrder.SHUTDOWN_FIRST\n    )\n    manager.restart.assert_called_once_with(\n        process_names=None,\n        reloaded_files=\"foo,bar\",\n        restart_order=restart_order,\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('zero_downtime', (False, True))"
      ],
      "arguments": [
        "zero_downtime"
      ],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_monitor_all_with_files` function is designed to verify the behavior of the `monitor` method in the `WorkerManager` class when handling file reloads in a Sanic application. It specifically tests how the manager responds to incoming messages regarding process restarts, particularly in scenarios where zero downtime is either enabled or disabled.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the `restart` method of the `WorkerManager` is called with the correct parameters based on the `zero_downtime` flag. It ensures that the correct restart order and reloaded files are passed to the `restart` method, depending on whether the application is set to allow zero downtime during restarts.\n\n**Code Being Tested and How It Works**:  \nThe test creates mock objects to simulate the behavior of processes and a subscription object that receives messages. It constructs an incoming message string that varies based on the `zero_downtime` parameter. The `WorkerManager` is instantiated with these mocks, and the `monitor` method is invoked. After the call, the test asserts that the `restart` method was called exactly once with the expected arguments, which include the restart order and the names of the files to be reloaded.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test extensively uses the `Mock` class to create mock objects for processes and subscriptions, allowing for isolation of the `WorkerManager` behavior without relying on actual implementations.\n- **Side Effects**: The `side_effect` attribute of mocks is used to simulate the sequence of messages received by the subscription object, enabling the test to control the flow of data.\n- **Parameterization**: The test is designed to run with different configurations of the `zero_downtime` flag, allowing for comprehensive coverage of both scenarios (zero downtime enabled and disabled) within a single test function."
    },
    {
      "name": "test_monitor_one_process",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 194,
      "end_line_number": 221,
      "source_code": "def test_monitor_one_process(zero_downtime):\n    p1 = Mock()\n    p1.name = \"Testing\"\n    p2 = Mock()\n    sub = Mock()\n    incoming = (\n        f\"{p1.name}:foo,bar:STARTUP_FIRST\"\n        if zero_downtime\n        else f\"{p1.name}:foo,bar\"\n    )\n    sub.recv.side_effect = [incoming, \"\"]\n    context = Mock()\n    context.Process.side_effect = [p1, p2]\n    manager = WorkerManager(2, fake_serve, {}, context, (Mock(), sub), {})\n    manager.restart = Mock()  # type: ignore\n    manager.wait_for_ack = Mock()  # type: ignore\n    manager.monitor()\n\n    restart_order = (\n        RestartOrder.STARTUP_FIRST\n        if zero_downtime\n        else RestartOrder.SHUTDOWN_FIRST\n    )\n    manager.restart.assert_called_once_with(\n        process_names=[p1.name],\n        reloaded_files=\"foo,bar\",\n        restart_order=restart_order,\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('zero_downtime', (False, True))"
      ],
      "arguments": [
        "zero_downtime"
      ],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_monitor_one_process` function is designed to verify the behavior of the `WorkerManager` class when monitoring a single worker process. It specifically checks how the manager handles the restart of a worker based on the incoming message format, which varies depending on whether zero downtime is enabled.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies that the `restart` method of the `WorkerManager` is called with the correct parameters, including the process name, reloaded files, and the appropriate restart order (either `STARTUP_FIRST` or `SHUTDOWN_FIRST`) based on the `zero_downtime` flag. It ensures that the manager correctly interprets the incoming message and responds accordingly.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `WorkerManager` class, which is responsible for managing worker processes in a Sanic application. The test simulates the reception of a message indicating the need to restart a worker. It uses mocks to create a controlled environment where the `recv` method of a subscription object returns a predefined message. The `monitor` method of the `WorkerManager` is then called, which processes the incoming message and triggers the `restart` method with the expected parameters.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test extensively uses the `Mock` class from the `unittest.mock` module to create mock objects for the worker processes and the subscription. This allows for isolation of the test from external dependencies and control over the behavior of the objects.\n- **Parameterization**: The test is parameterized with `pytest.mark.parametrize`, allowing it to run twice with different values for `zero_downtime`, thus covering both scenarios in a single test function.\n- **Assertions**: The test uses assertions to verify that the `restart` method is called exactly once with the expected arguments, ensuring that the logic within the `monitor` method behaves as intended."
    },
    {
      "name": "test_shutdown_signal",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 224,
      "end_line_number": 231,
      "source_code": "def test_shutdown_signal():\n    pub = Mock()\n    manager = WorkerManager(1, fake_serve, {}, Mock(), (pub, Mock()), {})\n    manager.shutdown = Mock()  # type: ignore\n\n    manager.shutdown_signal(SIGINT, None)\n    pub.send.assert_called_with(None)\n    manager.shutdown.assert_called_once_with()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_shutdown_signal` function is designed to verify the behavior of the `shutdown_signal` method in the `WorkerManager` class when a shutdown signal (specifically `SIGINT`) is received. It ensures that the appropriate actions are taken, such as sending a shutdown signal to the publisher and invoking the shutdown procedure.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when the `shutdown_signal` method is called with `SIGINT`, the `send` method of the publisher is called with `None`, and the `shutdown` method of the `WorkerManager` is called exactly once. This confirms that the system responds correctly to a shutdown signal by notifying the publisher and executing the shutdown process.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `WorkerManager` class, which is responsible for managing worker processes in the Sanic framework. The `shutdown_signal` method is expected to handle incoming signals (like `SIGINT`) and trigger the shutdown sequence. The test uses a mock publisher to simulate the behavior of the actual publisher, allowing the test to verify interactions without needing a real publisher instance.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test employs the `Mock` class to create mock objects for the publisher and the `shutdown` method, allowing for isolation of the unit under test and verification of interactions.\n- **Assertions**: The test uses `assert_called_with` and `assert_called_once_with` to confirm that the expected methods are called with the correct arguments and the correct number of times, ensuring that the shutdown process is executed as intended.\n- **Signal Handling**: The test simulates the reception of a shutdown signal (`SIGINT`), which is a common pattern in server applications to gracefully handle shutdowns."
    },
    {
      "name": "test_shutdown_servers",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 234,
      "end_line_number": 259,
      "source_code": "def test_shutdown_servers(caplog):\n    p1 = Mock()\n    p1.pid = 1234\n    context = Mock()\n    context.Process.side_effect = [p1]\n    pub = Mock()\n    manager = WorkerManager(1, fake_serve, {}, context, (pub, Mock()), {})\n\n    with patch(\"os.kill\") as kill:\n        with caplog.at_level(ERROR):\n            manager.shutdown_server()\n\n            kill.assert_called_once_with(1234, SIGINT)\n            kill.reset_mock()\n\n            assert not caplog.record_tuples\n\n            manager.shutdown_server()\n\n            kill.assert_not_called()\n\n            assert (\n                \"sanic.error\",\n                ERROR,\n                \"Server shutdown failed because a server was not found.\",\n            ) in caplog.record_tuples",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "caplog"
      ],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [
        "assert not caplog.record_tuples",
        "assert ('sanic.error', ERROR, 'Server shutdown failed because a server was not found.') in caplog.record_tuples"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "kill.reset_mock",
          "body": "def reset_mock(self, *args, **kwargs):\n    super().reset_mock(*args, **kwargs)\n    self.await_count = 0"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_shutdown_servers` function is designed to verify the behavior of the `shutdown_server` method in the `WorkerManager` class. Specifically, it checks that the method correctly handles the shutdown of a server process, ensuring that the appropriate signals are sent and that the logging behavior is as expected when a server is not found.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies two main scenarios: \n1. When a server process is available (with PID 1234), the `shutdown_server` method should call `os.kill` with the correct PID and signal (SIGINT).\n2. When the `shutdown_server` method is called again without a valid server process, it should not call `os.kill` and should log an error message indicating that the server shutdown failed due to a missing server.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `WorkerManager` class, which manages server processes. The `shutdown_server` method is expected to send a shutdown signal to the server process identified by its PID. The test uses a mock process (`p1`) with a predefined PID and a mocked context to simulate the behavior of the `WorkerManager`. The `os.kill` function is patched to intercept calls to it, allowing the test to assert whether it was called with the expected arguments.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test uses `Mock` objects to simulate the behavior of external dependencies (like the server process and the context) without invoking real implementations. This isolates the unit of work being tested.\n- **Patching**: The `patch` function from the `unittest.mock` module is used to replace the `os.kill` function with a mock, allowing the test to verify interactions with it.\n- **Logging Capture**: The `caplog` fixture is employed to capture log messages generated during the test, enabling assertions on the logging behavior.\n- **Assertions**: The test includes assertions to verify that the expected calls to `os.kill` occur and that the correct log messages are generated, ensuring comprehensive coverage of the method's behavior."
    },
    {
      "name": "test_shutdown_servers_named",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 262,
      "end_line_number": 277,
      "source_code": "def test_shutdown_servers_named():\n    p1 = Mock()\n    p1.pid = 1234\n    p2 = Mock()\n    p2.pid = 6543\n    context = Mock()\n    context.Process.side_effect = [p1, p2]\n    pub = Mock()\n    manager = WorkerManager(2, fake_serve, {}, context, (pub, Mock()), {})\n\n    with patch(\"os.kill\") as kill:\n        with pytest.raises(KeyError):\n            manager.shutdown_server(\"foo\")\n        manager.shutdown_server(\"Server-1\")\n\n        kill.assert_called_once_with(6543, SIGINT)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_shutdown_servers_named` function is designed to verify the behavior of the `shutdown_server` method in the `WorkerManager` class when attempting to shut down a server by its name. It specifically tests the handling of both valid and invalid server names.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when an invalid server name (\"foo\") is provided, a `KeyError` is raised, indicating that the server does not exist. It also verifies that when a valid server name (\"Server-1\") is used, the corresponding server process (with PID 6543) is correctly signaled to shut down using the `os.kill` function with the `SIGINT` signal.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `shutdown_server` method of the `WorkerManager` class. This method is responsible for terminating a server process based on its name. The method first checks if the server name exists in its internal data structures (likely a dictionary or similar). If the name is not found, it raises a `KeyError`. If the name is valid, it retrieves the associated process ID (PID) and sends a termination signal using `os.kill`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test uses `Mock` objects to simulate the behavior of server processes and the context in which they operate. This allows for isolated testing without needing actual server processes.\n- **Patching**: The `patch` function from the `unittest.mock` module is used to replace the `os.kill` function with a mock, enabling the test to verify that the correct PID is used without actually sending a signal to a real process.\n- **Exception Testing**: The test employs `pytest.raises` to assert that a `KeyError` is raised when an invalid server name is provided, ensuring that the method handles errors appropriately."
    },
    {
      "name": "test_scale",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 280,
      "end_line_number": 316,
      "source_code": "def test_scale(caplog):\n    p1 = Mock()\n    p1.pid = 1234\n    p2 = Mock()\n    p2.pid = 3456\n    p3 = Mock()\n    p3.pid = 5678\n    context = Mock()\n    context.Process.side_effect = [p1, p2, p3]\n    pub = Mock()\n    manager = WorkerManager(1, fake_serve, {}, context, (pub, Mock()), {})\n\n    assert len(manager.transient) == 1\n\n    manager.scale(3)\n    assert len(manager.transient) == 3\n\n    with patch(\"os.kill\") as kill:\n        manager.scale(2)\n        assert len(manager.transient) == 2\n\n        manager.scale(1)\n        assert len(manager.transient) == 1\n\n        kill.call_count == 2\n\n    with caplog.at_level(INFO):\n        manager.scale(1)\n\n    assert (\n        \"sanic.root\",\n        INFO,\n        \"No change needed. There are already 1 workers.\",\n    ) in caplog.record_tuples\n\n    with pytest.raises(ValueError, match=r\"Cannot scale to 0 workers\\.\"):\n        manager.scale(0)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "caplog"
      ],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(manager.transient) == 1",
        "assert len(manager.transient) == 3",
        "assert ('sanic.root', INFO, 'No change needed. There are already 1 workers.') in caplog.record_tuples",
        "assert len(manager.transient) == 2",
        "assert len(manager.transient) == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_scale` function is designed to verify the scaling functionality of the `WorkerManager` class in the Sanic framework. It ensures that the manager can correctly adjust the number of worker processes based on the specified scale, while also handling edge cases such as scaling to zero workers.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the `WorkerManager` can scale the number of transient workers up and down as expected. It verifies that the number of workers matches the requested scale, and it also confirms that appropriate logging occurs when no scaling action is needed. Additionally, it tests that attempting to scale to zero workers raises a `ValueError`.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `scale` method of the `WorkerManager` class. The method is expected to manage a list of transient worker processes, which are represented by mock objects (`p1`, `p2`, `p3`). The `context.Process.side_effect` is set up to simulate the creation of these worker processes. The test initializes a `WorkerManager` instance with one worker and then calls the `scale` method with different values to check if the number of transient workers is updated correctly.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test uses the `Mock` class to create mock objects for worker processes and the context, allowing for isolation of the `WorkerManager` functionality without relying on actual process management.\n- **Patch**: The `patch` function is used to mock the `os.kill` method, enabling the test to verify that the correct signals are sent to terminate processes without affecting the actual operating system.\n- **Logging Capture**: The `caplog` fixture is employed to capture log messages generated during the test, allowing for assertions on log content to ensure that the expected messages are logged under specific conditions.\n- **Exception Testing**: The test uses `pytest.raises` to assert that a `ValueError` is raised when attempting to scale to zero workers, ensuring that the method handles invalid input correctly."
    },
    {
      "name": "test_manage_basic",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 319,
      "end_line_number": 333,
      "source_code": "def test_manage_basic(manager: WorkerManager):\n    assert len(manager.transient) == 1\n    assert len(manager.durable) == 0\n    manager.manage(\"TEST\", fake_serve, kwargs={\"foo\": \"bar\"})\n    assert len(manager.transient) == 1\n    assert len(manager.durable) == 1\n\n    worker_process = manager.durable[\"TEST\"]\n\n    assert isinstance(worker_process, Worker)\n    assert worker_process.server_settings == {\"foo\": \"bar\"}\n    assert worker_process.restartable is False\n    assert worker_process.tracked is True\n    assert worker_process.auto_start is True\n    assert worker_process.num == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "manager"
      ],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(manager.transient) == 1",
        "assert len(manager.durable) == 0",
        "assert len(manager.transient) == 1",
        "assert len(manager.durable) == 1",
        "assert isinstance(worker_process, Worker)",
        "assert worker_process.server_settings == {'foo': 'bar'}",
        "assert worker_process.restartable is False",
        "assert worker_process.tracked is True",
        "assert worker_process.auto_start is True",
        "assert worker_process.num == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_manage_basic` function is designed to verify the basic functionality of the `manage` method in the `WorkerManager` class. It ensures that a worker can be successfully managed and transitioned from a transient state to a durable state.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. Initially, there is one transient worker and no durable workers.\n2. After invoking the `manage` method with specific parameters, the number of durable workers increases to one while transient workers remain unchanged.\n3. The properties of the newly created durable worker are validated, including its type, server settings, and various flags (restartable, tracked, auto_start).\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `manage` method of the `WorkerManager` class. This method is responsible for creating and managing worker processes. When called with a worker identifier (\"TEST\"), a function (`fake_serve`), and keyword arguments, it should:\n- Create a new worker process if it does not already exist.\n- Store the worker in the `durable` dictionary if it is meant to persist beyond the current session.\n- Set the worker's properties based on the provided arguments, such as server settings and flags indicating its behavior.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertions**: The test employs multiple assertions to validate the state of the `manager` before and after the `manage` call, ensuring that the expected changes occur.\n- **State Verification**: It checks the length of the `transient` and `durable` collections to confirm the correct number of workers in each state.\n- **Type Checking**: The test uses `isinstance` to ensure that the created worker is of the expected `Worker` type, which is crucial for maintaining type safety and correctness in the application.\n- **Property Validation**: It verifies specific attributes of the worker to ensure that they are set correctly based on the input parameters, which helps in confirming that the `manage` method behaves as intended."
    },
    {
      "name": "test_manage_transient",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 336,
      "end_line_number": 349,
      "source_code": "def test_manage_transient(manager: WorkerManager):\n    manager.manage(\n        \"TEST\", fake_serve, kwargs={\"foo\": \"bar\"}, workers=3, transient=True\n    )\n    assert len(manager.transient) == 2\n    assert len(manager.durable) == 0\n\n    worker_process = manager.transient[\"TEST\"]\n\n    assert isinstance(worker_process, Worker)\n    assert worker_process.restartable is True\n    assert worker_process.tracked is True\n    assert worker_process.auto_start is True\n    assert worker_process.num == 3",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "manager"
      ],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(manager.transient) == 2",
        "assert len(manager.durable) == 0",
        "assert isinstance(worker_process, Worker)",
        "assert worker_process.restartable is True",
        "assert worker_process.tracked is True",
        "assert worker_process.auto_start is True",
        "assert worker_process.num == 3"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_manage_transient` function is designed to verify the behavior of the `manage` method in the `WorkerManager` class when creating a transient worker. It ensures that the worker is correctly instantiated with the expected properties and that the internal state of the `WorkerManager` reflects the addition of this transient worker.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when a transient worker named \"TEST\" is created with specific parameters (3 workers, restartable, tracked, and auto-start), the following conditions hold true:\n- The `transient` dictionary contains exactly 2 workers (indicating that the new worker was added).\n- The `durable` dictionary remains empty (indicating no durable workers were created).\n- The properties of the created worker (e.g., `restartable`, `tracked`, `auto_start`, and `num`) are set correctly.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `manage` method of the `WorkerManager` class, which is responsible for creating and managing worker processes. When called with the parameters provided in the test, it checks if a worker with the same name already exists, validates the transient and restartable conditions, and then creates a new `Worker` instance. This instance is added to the `transient` dictionary if it is transient, or to the `durable` dictionary if it is not.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs assertions to validate the state of the `WorkerManager` after invoking the `manage` method. It uses direct checks on the length of the `transient` and `durable` dictionaries to confirm the expected state. Additionally, it verifies the properties of the created `Worker` instance using `isinstance` and direct attribute checks, ensuring that the worker is configured correctly. This approach of validating both the state and the properties of objects is a common pattern in unit testing to ensure comprehensive coverage of functionality."
    },
    {
      "name": "test_manage_restartable",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 352,
      "end_line_number": 368,
      "source_code": "def test_manage_restartable(manager: WorkerManager):\n    manager.manage(\n        \"TEST\",\n        fake_serve,\n        kwargs={\"foo\": \"bar\"},\n        restartable=True,\n        auto_start=False,\n    )\n    assert len(manager.transient) == 1\n    assert len(manager.durable) == 1\n\n    worker_process = manager.durable[\"TEST\"]\n\n    assert isinstance(worker_process, Worker)\n    assert worker_process.restartable is True\n    assert worker_process.tracked is True\n    assert worker_process.auto_start is False",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "manager"
      ],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(manager.transient) == 1",
        "assert len(manager.durable) == 1",
        "assert isinstance(worker_process, Worker)",
        "assert worker_process.restartable is True",
        "assert worker_process.tracked is True",
        "assert worker_process.auto_start is False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_manage_restartable` function is designed to verify the behavior of the `WorkerManager` when managing a worker process that is marked as restartable. It ensures that the manager correctly tracks the state and properties of the worker process after it has been managed.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a worker is managed with the `restartable` flag set to `True`, the `WorkerManager` correctly updates its internal state to reflect that there is one transient and one durable worker. It also verifies that the properties of the managed worker, such as `restartable`, `tracked`, and `auto_start`, are set as expected.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `manage` method of the `WorkerManager` class, which is responsible for adding a worker process to the manager's tracking. The test calls this method with specific parameters, including a worker name, a target function (`fake_serve`), and flags for `restartable` and `auto_start`. After the call, the test checks the lengths of the `transient` and `durable` dictionaries in the manager to ensure they contain the expected number of workers. It also retrieves the managed worker from the `durable` dictionary and asserts its properties.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs assertions to validate the expected state of the `WorkerManager` and the properties of the worker process. It uses the `assert` statement to check conditions, which is a common practice in unit testing to ensure that the code behaves as intended. The test also follows a clear structure: it sets up the conditions, performs the action (managing the worker), and then verifies the outcomes, which is a standard pattern in unit testing known as Arrange-Act-Assert (AAA)."
    },
    {
      "name": "test_manage_untracked",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 371,
      "end_line_number": 381,
      "source_code": "def test_manage_untracked(manager: WorkerManager):\n    manager.manage(\"TEST\", fake_serve, kwargs={\"foo\": \"bar\"}, tracked=False)\n    assert len(manager.transient) == 1\n    assert len(manager.durable) == 1\n\n    worker_process = manager.durable[\"TEST\"]\n\n    assert isinstance(worker_process, Worker)\n    assert worker_process.restartable is False\n    assert worker_process.tracked is False\n    assert worker_process.auto_start is True",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "manager"
      ],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(manager.transient) == 1",
        "assert len(manager.durable) == 1",
        "assert isinstance(worker_process, Worker)",
        "assert worker_process.restartable is False",
        "assert worker_process.tracked is False",
        "assert worker_process.auto_start is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_manage_untracked` function is designed to verify the behavior of the `WorkerManager` when managing a worker that is marked as untracked. It ensures that the manager correctly handles the creation of a worker process that is transient and not tracked, confirming that the internal state of the manager reflects this configuration.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that after managing an untracked worker, the `transient` and `durable` collections within the `WorkerManager` contain exactly one worker each. It also verifies the properties of the created worker, specifically that it is not restartable, not tracked, and is set to auto-start.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `manage` method of the `WorkerManager` class, which is responsible for creating and managing worker processes. The test calls `manager.manage(\"TEST\", fake_serve, kwargs={\"foo\": \"bar\"}, tracked=False)`, which should create a worker named \"TEST\" using the `fake_serve` function with specified keyword arguments. The assertions that follow check the lengths of the `transient` and `durable` dictionaries and validate the properties of the worker process created.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs direct assertions to validate the state of the `WorkerManager` and the properties of the worker. It uses the `assert` statement to check conditions, which is a common practice in unit testing to ensure that the expected outcomes match the actual results. The test also follows a clear structure: it sets up the conditions, performs the action, and then asserts the expected outcomes, which is a standard pattern in unit tests."
    },
    {
      "name": "test_manage_duplicate_ident",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 384,
      "end_line_number": 388,
      "source_code": "def test_manage_duplicate_ident(manager: WorkerManager):\n    manager.manage(\"TEST\", fake_serve, kwargs={\"foo\": \"bar\"})\n    message = \"Worker TEST already exists\"\n    with pytest.raises(ValueError, match=message):\n        manager.manage(\"TEST\", fake_serve, kwargs={\"foo\": \"bar\"})",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "manager"
      ],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_manage_duplicate_ident` test is to verify that the `WorkerManager` correctly raises a `ValueError` when an attempt is made to manage a worker with an identifier that already exists.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks the behavior of the `manage` method in the `WorkerManager` class when it is called with a duplicate worker identifier. It ensures that the system prevents the creation of multiple workers with the same identifier and raises an appropriate error message.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `manage` method of the `WorkerManager` class. Initially, the test calls `manager.manage(\"TEST\", fake_serve, kwargs={\"foo\": \"bar\"})` to create a worker with the identifier \"TEST\". The subsequent call to `manager.manage(\"TEST\", fake_serve, kwargs={\"foo\": \"bar\"})` is expected to fail because a worker with the identifier \"TEST\" already exists. The test uses `pytest.raises` to assert that a `ValueError` is raised, and it checks that the error message matches the expected message: \"Worker TEST already exists\".\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the context manager `pytest.raises` to assert that an exception is raised during the execution of the code block. This is a common pattern in unit testing for verifying that specific error conditions are handled correctly. Additionally, the use of a specific error message in the `match` parameter ensures that not only is the correct type of exception raised, but also that it conveys the expected information about the error."
    },
    {
      "name": "test_transient_not_restartable",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 391,
      "end_line_number": 400,
      "source_code": "def test_transient_not_restartable(manager: WorkerManager):\n    message = \"Cannot create a transient worker that is not restartable\"\n    with pytest.raises(ValueError, match=message):\n        manager.manage(\n            \"TEST\",\n            fake_serve,\n            kwargs={\"foo\": \"bar\"},\n            transient=True,\n            restartable=False,\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "manager"
      ],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_transient_not_restartable` is designed to verify that the `WorkerManager` correctly raises a `ValueError` when attempting to create a transient worker that is not marked as restartable. This ensures that the constraints on worker creation are enforced, preventing invalid configurations.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that when a transient worker is requested with the `transient=True` and `restartable=False` parameters, the system raises a `ValueError` with the message \"Cannot create a transient worker that is not restartable\". This behavior is crucial for maintaining the integrity of the worker management system.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `manage` method of the `WorkerManager` class. This method is responsible for creating and managing worker processes. The relevant part of the implementation checks if a worker is transient and not restartable, and if so, it raises a `ValueError`. The test simulates a call to this method with the specified parameters to ensure that the exception is raised as expected.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that a specific exception is raised during the execution of the code block. This is a common pattern in unit testing that allows for clean and readable verification of error conditions. Additionally, the use of the `match` argument ensures that the exception message is not only raised but also matches the expected string, providing a more robust validation of the error handling logic."
    },
    {
      "name": "test_remove_worker",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 403,
      "end_line_number": 416,
      "source_code": "def test_remove_worker(manager: WorkerManager, caplog):\n    worker = manager.manage(\"TEST\", fake_serve, kwargs={})\n\n    assert \"Sanic-TEST-0\" in worker.worker_state\n    assert len(manager.transient) == 1\n    assert len(manager.durable) == 1\n\n    manager.remove_worker(worker)\n    message = \"Worker TEST is tracked and cannot be removed.\"\n\n    assert \"Sanic-TEST-0\" in worker.worker_state\n    assert len(manager.transient) == 1\n    assert len(manager.durable) == 1\n    assert (\"sanic.error\", 40, message) in caplog.record_tuples",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "manager",
        "caplog"
      ],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'Sanic-TEST-0' in worker.worker_state",
        "assert len(manager.transient) == 1",
        "assert len(manager.durable) == 1",
        "assert 'Sanic-TEST-0' in worker.worker_state",
        "assert len(manager.transient) == 1",
        "assert len(manager.durable) == 1",
        "assert ('sanic.error', 40, message) in caplog.record_tuples"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_remove_worker` function is designed to verify the behavior of the `WorkerManager` when attempting to remove a worker that is currently tracked. It ensures that the worker cannot be removed and that the appropriate error message is logged.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. A worker can be successfully managed and is in the expected state.\n2. The `remove_worker` method correctly prevents the removal of a tracked worker and logs an appropriate error message.\n3. The state of the `transient` and `durable` worker lists remains unchanged after the removal attempt.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `WorkerManager` class, specifically its `remove_worker` method. The test first creates a worker using the `manage` method, which adds the worker to the manager's lists. When `remove_worker` is called with this worker, it is expected to raise a ValueError (or similar) because the worker is tracked. The test then checks the worker's state and the lengths of the `transient` and `durable` lists to confirm that they remain unchanged. Additionally, it verifies that the expected error message is logged using the `caplog` fixture.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The test utilizes the `caplog` fixture to capture log messages generated during the test, allowing for verification of logging behavior.\n- **Assertions**: Multiple assertions are employed to validate the state of the worker and the manager before and after the removal attempt, ensuring comprehensive coverage of the expected behavior.\n- **State Verification**: The test checks both the presence of the worker in the state and the integrity of the manager's lists, which is a common pattern in unit tests to ensure that side effects are properly managed."
    },
    {
      "name": "test_remove_untracked_worker",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 419,
      "end_line_number": 443,
      "source_code": "def test_remove_untracked_worker(manager: WorkerManager, caplog):\n    caplog.set_level(20)\n    worker = manager.manage(\"TEST\", fake_serve, kwargs={}, tracked=False)\n    worker.has_alive_processes = Mock(return_value=True)\n\n    assert \"Sanic-TEST-0\" in worker.worker_state\n    assert len(manager.transient) == 1\n    assert len(manager.durable) == 1\n\n    manager.remove_worker(worker)\n    message = \"Worker TEST has alive processes and cannot be removed.\"\n\n    assert \"Sanic-TEST-0\" in worker.worker_state\n    assert len(manager.transient) == 1\n    assert len(manager.durable) == 1\n    assert (\"sanic.error\", 40, message) in caplog.record_tuples\n\n    worker.has_alive_processes = Mock(return_value=False)\n    manager.remove_worker(worker)\n    message = \"Removed worker TEST\"\n\n    assert \"Sanic-TEST-0\" not in worker.worker_state\n    assert len(manager.transient) == 1\n    assert len(manager.durable) == 0\n    assert (\"sanic.root\", 20, message) in caplog.record_tuples",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "manager",
        "caplog"
      ],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'Sanic-TEST-0' in worker.worker_state",
        "assert len(manager.transient) == 1",
        "assert len(manager.durable) == 1",
        "assert 'Sanic-TEST-0' in worker.worker_state",
        "assert len(manager.transient) == 1",
        "assert len(manager.durable) == 1",
        "assert ('sanic.error', 40, message) in caplog.record_tuples",
        "assert 'Sanic-TEST-0' not in worker.worker_state",
        "assert len(manager.transient) == 1",
        "assert len(manager.durable) == 0",
        "assert ('sanic.root', 20, message) in caplog.record_tuples"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_remove_untracked_worker` unit test is designed to verify the behavior of the `WorkerManager` when attempting to remove a worker that is untracked and has alive processes. It ensures that the system correctly prevents the removal of a worker with active processes and allows the removal when there are no active processes.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main scenarios: \n1. When the worker has alive processes, it should not be removed, and an appropriate error message should be logged.\n2. When the worker has no alive processes, it should be successfully removed, and a confirmation message should be logged.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `WorkerManager` class, specifically the `remove_worker` method. It first creates a worker with the `tracked` flag set to `False` and mocks the `has_alive_processes` method to simulate the worker having alive processes. The assertions confirm that the worker remains in the state and that the expected error message is logged. The test then changes the mock to indicate no alive processes and calls `remove_worker` again, asserting that the worker is removed and the correct success message is logged.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test uses `Mock` to simulate the behavior of the `has_alive_processes` method, allowing for controlled testing of different scenarios without needing actual worker processes.\n- **Logging Capture**: The `caplog` fixture is employed to capture log messages generated during the test, enabling verification of the correct logging behavior in response to different conditions.\n- **Assertions**: Multiple assertions are used to validate the state of the worker and the `WorkerManager` before and after the removal attempts, ensuring comprehensive coverage of the expected outcomes."
    },
    {
      "name": "test_set_get_state",
      "module": "test_state",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_state.py",
      "line_number": 10,
      "end_line_number": 15,
      "source_code": "def test_set_get_state():\n    state = gen_state()\n    state[\"additional\"] = 123\n    assert state[\"additional\"] == 123\n    assert state.get(\"additional\") == 123\n    assert state._state == {\"foo\": {\"additional\": 123}}",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [
        "assert state['additional'] == 123",
        "assert state.get('additional') == 123",
        "assert state._state == {'foo': {'additional': 123}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "gen_state",
          "body": "def gen_state(**kwargs):\n    return WorkerState({'foo': kwargs}, 'foo')"
        },
        {
          "name": "state.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_set_get_state` function is designed to verify the behavior of the `gen_state` function and the `WorkerState` class, specifically ensuring that the state can be set and retrieved correctly.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. A new key-value pair can be added to the state.\n2. The value can be retrieved both directly and through a `get` method.\n3. The internal representation of the state (`_state`) reflects the changes made.\n\n**Code Being Tested and How It Works**:  \n- The `gen_state` function initializes a `WorkerState` object with a dictionary containing a key `\"foo\"` and any additional keyword arguments passed to it. In this case, it initializes with an empty dictionary.\n- The test modifies the state by adding an entry with the key `\"additional\"` and the value `123`.\n- It then asserts that both direct access (`state[\"additional\"]`) and the `get` method (`state.get(\"additional\")`) return the expected value.\n- Finally, it checks that the internal state representation (`state._state`) correctly reflects the addition of the new key-value pair.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertions**: The test uses assertions to validate expected outcomes, which is a fundamental practice in unit testing.\n- **State Verification**: It verifies both the public interface (accessing state via keys) and the internal state representation, ensuring that the implementation details align with the expected behavior.\n- **Isolation**: The test is self-contained, relying only on the `gen_state` function and the `WorkerState` class, which helps in isolating the functionality being tested."
    },
    {
      "name": "test_del_state",
      "module": "test_state",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_state.py",
      "line_number": 18,
      "end_line_number": 22,
      "source_code": "def test_del_state():\n    state = gen_state(one=1)\n    assert state[\"one\"] == 1\n    del state[\"one\"]\n    assert state._state == {\"foo\": {}}",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [
        "assert state['one'] == 1",
        "assert state._state == {'foo': {}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "gen_state",
          "body": "def gen_state(**kwargs):\n    return WorkerState({'foo': kwargs}, 'foo')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_del_state` function is designed to verify the behavior of the `WorkerState` class when a key is deleted from its internal state. Specifically, it checks that after deleting a key, the state reflects the expected structure and content.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a key (in this case, `\"one\"`) is removed from the `WorkerState` instance, the internal state (`_state`) correctly updates to reflect that the key no longer exists. It asserts that the state is empty after the deletion.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `gen_state` function, which creates an instance of `WorkerState` initialized with a dictionary containing the provided keyword arguments. In this test, `gen_state(one=1)` initializes the state with `{\"foo\": {\"one\": 1}}`. The test first checks that the key `\"one\"` exists and has the value `1`. After deleting the key, it asserts that the internal state `_state` is now `{\"foo\": {}}`, indicating that the key has been successfully removed.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs direct assertions to validate the state before and after the deletion operation. It uses the `assert` statement to check conditions, which is a common practice in unit testing to ensure that the code behaves as expected. The test is straightforward and focuses on a single behavior (deletion), making it easy to understand and maintain. Additionally, it leverages the simplicity of Python's built-in data structures to facilitate the testing of state management."
    },
    {
      "name": "test_iter_state",
      "module": "test_state",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_state.py",
      "line_number": 25,
      "end_line_number": 27,
      "source_code": "def test_iter_state():\n    result = [item for item in gen_state(one=1, two=2)]\n    assert result == [\"one\", \"two\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [
        "assert result == ['one', 'two']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "gen_state",
          "body": "def gen_state(**kwargs):\n    return WorkerState({'foo': kwargs}, 'foo')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_iter_state` function is designed to verify the behavior of the `gen_state` function when it is used to create a `WorkerState` object. Specifically, it checks that the keys of the state can be iterated over and that they match the expected output.\n\n**Specific Functionality or Behavior Verified**:  \nThis test confirms that when `gen_state` is called with keyword arguments (`one=1` and `two=2`), the resulting `WorkerState` object can be iterated to yield the keys \"one\" and \"two\". The assertion checks that the collected keys from the iteration match the expected list `[\"one\", \"two\"]`.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `gen_state` function, which takes arbitrary keyword arguments and returns a `WorkerState` object containing those arguments in a dictionary format. The `WorkerState` class is expected to support iteration over its keys, allowing the test to collect these keys into a list. The test uses a list comprehension to iterate over the `WorkerState` instance created by `gen_state`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern, where the result of the iteration is directly compared to an expected value. This is a common practice in unit testing to ensure that the output of a function or method matches the expected outcome. The use of list comprehension for iteration is also a Pythonic way to collect results, making the test concise and readable. Additionally, the test does not rely on any external state or side effects, adhering to the principles of unit testing by isolating the functionality being tested."
    },
    {
      "name": "test_state_len",
      "module": "test_state",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_state.py",
      "line_number": 30,
      "end_line_number": 32,
      "source_code": "def test_state_len():\n    result = [item for item in gen_state(one=1, two=2)]\n    assert len(result) == 2",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(result) == 2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "gen_state",
          "body": "def gen_state(**kwargs):\n    return WorkerState({'foo': kwargs}, 'foo')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_state_len` function is designed to verify that the `gen_state` function correctly generates a state object that contains the expected number of keys when provided with keyword arguments.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the length of the result returned by `gen_state` when called with two keyword arguments (`one=1` and `two=2`) is equal to 2. This ensures that the function is correctly processing the input arguments and returning a state representation that reflects them.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `gen_state` function, which takes arbitrary keyword arguments (`**kwargs`) and returns an instance of `WorkerState`. The `WorkerState` is initialized with a dictionary containing the keyword arguments under the key `'foo'`. The test then creates a list comprehension that iterates over the `gen_state` output, which is expected to yield the keys of the state. The assertion checks that the length of this list is 2, confirming that both keys (`'one'` and `'two'`) are present.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern, using a list comprehension to extract keys from the state object. It also utilizes the `assert` statement to validate the expected outcome, which is a common practice in unit testing for ensuring that the actual results match the expected results. The test is simple and direct, focusing on a specific aspect of the `gen_state` function's behavior without introducing unnecessary complexity."
    },
    {
      "name": "test_state_repr",
      "module": "test_state",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_state.py",
      "line_number": 35,
      "end_line_number": 36,
      "source_code": "def test_state_repr():\n    assert repr(gen_state(one=1, two=2)) == repr({\"one\": 1, \"two\": 2})",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(gen_state(one=1, two=2)) == repr({'one': 1, 'two': 2})"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "gen_state",
          "body": "def gen_state(**kwargs):\n    return WorkerState({'foo': kwargs}, 'foo')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_state_repr` function is designed to verify the string representation of the `WorkerState` object returned by the `gen_state` function. It ensures that the representation accurately reflects the internal state of the object when initialized with specific keyword arguments.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the output of the `repr()` function on the `WorkerState` instance created by `gen_state(one=1, two=2)` matches the expected representation of a dictionary `{\"one\": 1, \"two\": 2}`. This confirms that the `WorkerState` class correctly formats its internal state for debugging and logging purposes.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `gen_state` function, which constructs a `WorkerState` object. The `WorkerState` is initialized with a dictionary containing a single key `'foo'`, which maps to another dictionary of the provided keyword arguments. The `repr()` method of `WorkerState` is expected to return a string representation that reflects the internal structure of this state, specifically the contents of the dictionary passed to it.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion to compare the output of `repr()` for the `WorkerState` instance against a predefined dictionary representation. This direct comparison is a common pattern in unit testing, allowing for clear and concise verification of expected outcomes. The absence of a docstring indicates a focus on simplicity, which is typical in unit tests where the purpose is often self-evident from the test name and assertions."
    },
    {
      "name": "test_state_eq",
      "module": "test_state",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_state.py",
      "line_number": 39,
      "end_line_number": 42,
      "source_code": "def test_state_eq():\n    state = gen_state(one=1, two=2)\n    assert state == {\"one\": 1, \"two\": 2}\n    assert state != {\"one\": 1}",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [
        "assert state == {'one': 1, 'two': 2}",
        "assert state != {'one': 1}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "gen_state",
          "body": "def gen_state(**kwargs):\n    return WorkerState({'foo': kwargs}, 'foo')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_state_eq` function is designed to verify the equality and inequality behavior of the `WorkerState` object returned by the `gen_state` function. It ensures that the state object correctly represents its internal data structure when compared to standard Python dictionaries.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks two specific assertions: \n1. It asserts that the `state` object is equal to a dictionary `{\"one\": 1, \"two\": 2}`. This verifies that the `WorkerState` object correctly reflects the key-value pairs passed to it.\n2. It asserts that the `state` object is not equal to a dictionary `{\"one\": 1}`. This ensures that the `WorkerState` object does not mistakenly consider itself equal to a dictionary that lacks some of its keys.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `gen_state` function, which creates an instance of `WorkerState` initialized with a dictionary containing the provided keyword arguments. The `WorkerState` class is expected to implement equality comparison such that it can be compared to a standard dictionary. The `gen_state` function constructs the state as `{\"foo\": kwargs}`, where `kwargs` is a dictionary of the provided keyword arguments. The test checks if this internal representation matches the expected dictionary format.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs direct assertions to validate the expected outcomes, which is a common pattern in unit testing. It uses the `assert` statement to check for equality and inequality, providing a straightforward way to verify the behavior of the `WorkerState` object. This approach is effective for ensuring that the object behaves as intended when compared to standard data structures, highlighting the importance of implementing proper equality methods in custom classes."
    },
    {
      "name": "test_state_keys",
      "module": "test_state",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_state.py",
      "line_number": 45,
      "end_line_number": 48,
      "source_code": "def test_state_keys():\n    assert list(gen_state(one=1, two=2).keys()) == list(\n        {\"one\": 1, \"two\": 2}.keys()\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [
        "assert list(gen_state(one=1, two=2).keys()) == list({'one': 1, 'two': 2}.keys())"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "gen_state",
          "body": "def gen_state(**kwargs):\n    return WorkerState({'foo': kwargs}, 'foo')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_state_keys` function is designed to verify that the `gen_state` function correctly initializes a `WorkerState` object with the expected keys when provided with keyword arguments. It ensures that the keys of the state object match the keys of the dictionary created from the input arguments.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the keys returned by the `gen_state` function, when called with `one=1` and `two=2`, are exactly the same as the keys of the dictionary `{\"one\": 1, \"two\": 2}`. It confirms that the internal representation of the state correctly reflects the input parameters.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `gen_state` function, which takes arbitrary keyword arguments (`**kwargs`) and returns a `WorkerState` object initialized with a dictionary containing these arguments under the key `'foo'`. The test calls `gen_state(one=1, two=2)` and checks the keys of the resulting `WorkerState` object against the expected keys from the dictionary.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion to compare lists of keys, which is a common pattern in unit testing to validate the output of functions. It uses the `list()` function to ensure that the order of keys does not affect the comparison, making the test robust against any potential ordering issues. The absence of a docstring indicates a simple and direct test case, focusing solely on the functionality being verified without additional context."
    },
    {
      "name": "test_state_values",
      "module": "test_state",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_state.py",
      "line_number": 51,
      "end_line_number": 54,
      "source_code": "def test_state_values():\n    assert list(gen_state(one=1, two=2).values()) == list(\n        {\"one\": 1, \"two\": 2}.values()\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [
        "assert list(gen_state(one=1, two=2).values()) == list({'one': 1, 'two': 2}.values())"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "gen_state",
          "body": "def gen_state(**kwargs):\n    return WorkerState({'foo': kwargs}, 'foo')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_state_values` function is designed to verify that the `gen_state` function correctly initializes a `WorkerState` object with the expected values when provided with keyword arguments. It ensures that the values returned by the `WorkerState` instance match the values of a dictionary created from the same keyword arguments.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `values()` method of the `WorkerState` instance returns a list of values that is equivalent to the list of values from a dictionary created with the same keyword arguments. In this case, it confirms that `gen_state(one=1, two=2)` produces a state that contains the values `[1, 2]`.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `gen_state` function, which takes arbitrary keyword arguments (`**kwargs`) and returns an instance of `WorkerState`. The `WorkerState` is initialized with a dictionary containing a single key `'foo'`, which maps to another dictionary of the provided keyword arguments. The test then calls the `values()` method on the `WorkerState` instance to retrieve its values and compares them to the values of a similarly constructed dictionary.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern using `assert` to compare the expected and actual results. It utilizes the `list()` function to ensure that both sides of the comparison are lists, which allows for a direct comparison of the values. This approach is common in unit tests to validate the output of functions and methods against expected outcomes, ensuring that the implementation behaves as intended."
    },
    {
      "name": "test_state_items",
      "module": "test_state",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_state.py",
      "line_number": 57,
      "end_line_number": 60,
      "source_code": "def test_state_items():\n    assert list(gen_state(one=1, two=2).items()) == list(\n        {\"one\": 1, \"two\": 2}.items()\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [
        "assert list(gen_state(one=1, two=2).items()) == list({'one': 1, 'two': 2}.items())"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "gen_state",
          "body": "def gen_state(**kwargs):\n    return WorkerState({'foo': kwargs}, 'foo')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_state_items` function is designed to verify that the `gen_state` function correctly initializes a `WorkerState` object with the expected key-value pairs. Specifically, it checks that the items returned by the `WorkerState` instance match the items of a dictionary created with the same key-value pairs.\n\n**Specific Functionality or Behavior Verified**:  \nThis test confirms that the `items()` method of the `WorkerState` class returns the correct items when initialized with specific keyword arguments. It ensures that the internal representation of the state is consistent with the expected dictionary format.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `gen_state` function, which takes arbitrary keyword arguments (`**kwargs`) and returns a `WorkerState` instance containing those arguments wrapped in a dictionary under the key `'foo'`. The `WorkerState` class is expected to implement an `items()` method that returns the items of its internal state dictionary. The test checks that the output of `gen_state(one=1, two=2).items()` matches the items of the dictionary `{\"one\": 1, \"two\": 2}`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion to compare two lists of items, leveraging the `list()` function to ensure that the order and structure of the items are consistent. This pattern of using assertions to compare expected and actual outputs is a common technique in unit testing, providing a clear pass/fail outcome based on the equality of the two lists. Additionally, the test is self-contained and does not rely on external state, which is a best practice in unit testing to ensure reliability and repeatability."
    },
    {
      "name": "test_state_update",
      "module": "test_state",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_state.py",
      "line_number": 63,
      "end_line_number": 68,
      "source_code": "def test_state_update():\n    state = gen_state()\n    assert len(state) == 0\n    state.update({\"nine\": 9})\n    assert len(state) == 1\n    assert state[\"nine\"] == 9",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(state) == 0",
        "assert len(state) == 1",
        "assert state['nine'] == 9"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "gen_state",
          "body": "def gen_state(**kwargs):\n    return WorkerState({'foo': kwargs}, 'foo')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_state_update` function is designed to verify the behavior of the `WorkerState` class when updating its internal state. Specifically, it checks that the state can be updated correctly and that the expected properties of the state are maintained after the update.\n\n**Specific Functionality or Behavior Verified**:  \nThis test verifies three key behaviors:\n1. The initial state is empty (i.e., has a length of 0).\n2. After updating the state with a new key-value pair (`\"nine\": 9`), the length of the state becomes 1.\n3. The value associated with the key `\"nine\"` is correctly set to 9.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `gen_state` function, which creates an instance of `WorkerState`. The `WorkerState` is initialized with a dictionary containing a key `\"foo\"` that maps to the provided keyword arguments. In this test, `gen_state()` is called without any arguments, resulting in an empty state. The `update` method of the `WorkerState` instance is then called to add a new key-value pair. The assertions that follow check the state\u2019s length and the value of the newly added key.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern to validate the state before and after the update. It uses the `assert` statement to check conditions, which is a common practice in unit testing for its simplicity and clarity. The test also follows the Arrange-Act-Assert (AAA) pattern:\n- **Arrange**: Set up the initial state by calling `gen_state()`.\n- **Act**: Update the state with a new key-value pair.\n- **Assert**: Verify the expected outcomes regarding the state\u2019s length and the value of the new key. This structured approach enhances readability and maintainability of the test."
    },
    {
      "name": "test_state_pop",
      "module": "test_state",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_state.py",
      "line_number": 71,
      "end_line_number": 74,
      "source_code": "def test_state_pop():\n    state = gen_state(one=1)\n    with pytest.raises(NotImplementedError):\n        state.pop()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "gen_state",
          "body": "def gen_state(**kwargs):\n    return WorkerState({'foo': kwargs}, 'foo')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_state_pop` unit test is designed to verify that the `pop` method of the `WorkerState` class raises a `NotImplementedError`. This indicates that the `pop` method is not yet implemented, which is an expected behavior in this context.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks for the correct exception type (`NotImplementedError`) when attempting to call the `pop` method on an instance of `WorkerState`. This ensures that the method is correctly marked as not implemented and that any attempt to use it will result in an appropriate error.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `pop` method within the `WorkerState` class, which is defined to raise a `NotImplementedError`. The `gen_state` function is used to create an instance of `WorkerState` with some initial state (in this case, a dictionary containing `one=1`). The test then attempts to call `state.pop()`, which should trigger the exception.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that a specific exception is raised during the execution of the code block. This is a common pattern in unit testing for verifying that error conditions are handled correctly. The use of `pytest` as the testing framework also indicates a preference for a more expressive and flexible testing style, allowing for clear and concise test definitions."
    },
    {
      "name": "test_state_full",
      "module": "test_state",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_state.py",
      "line_number": 77,
      "end_line_number": 79,
      "source_code": "def test_state_full():\n    state = gen_state(one=1)\n    assert state.full() == {\"foo\": {\"one\": 1}}",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [
        "assert state.full() == {'foo': {'one': 1}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "gen_state",
          "body": "def gen_state(**kwargs):\n    return WorkerState({'foo': kwargs}, 'foo')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_state_full` function is designed to verify the correct behavior of the `full` method in the `WorkerState` class. Specifically, it checks that the `full` method returns the expected state representation when the state is initialized with specific keyword arguments.\n\n**Specific Functionality or Behavior Verified**:  \nThis test asserts that when a `WorkerState` object is created with the argument `one=1`, the `full` method should return a dictionary that accurately reflects this state, specifically `{\"foo\": {\"one\": 1}}`. This ensures that the internal state management of the `WorkerState` class is functioning as intended.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `gen_state` function, which initializes a `WorkerState` object with a dictionary containing the provided keyword arguments. The `full` method of the `WorkerState` class returns the internal state as a dictionary. In this case, `gen_state(one=1)` creates a `WorkerState` instance with `_state` set to `{\"foo\": {\"one\": 1}}`, and the `full` method retrieves this state for verification.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern, using `assert` to compare the output of the `full` method against the expected dictionary. This direct comparison is a common practice in unit testing, allowing for clear and concise validation of functionality. Additionally, the test is isolated, focusing solely on the behavior of the `full` method without dependencies on external systems or states, which is a hallmark of effective unit tests."
    },
    {
      "name": "test_state_restricted_operation",
      "module": "test_state",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_state.py",
      "line_number": 83,
      "end_line_number": 91,
      "source_code": "def test_state_restricted_operation(key):\n    state = gen_state()\n    message = f\"Cannot set restricted key on WorkerState: {key}\"\n    with pytest.raises(LookupError, match=message):\n        state[key] = \"Nope\"\n        del state[key]\n\n    with pytest.raises(LookupError, match=message):\n        state.update({\"okay\": True, key: \"bad\"})",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('key', WorkerState.RESTRICTED)"
      ],
      "arguments": [
        "key"
      ],
      "imports": [
        "pytest",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "gen_state",
          "body": "def gen_state(**kwargs):\n    return WorkerState({'foo': kwargs}, 'foo')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_state_restricted_operation` test is to ensure that attempts to set or update restricted keys in the `WorkerState` class raise the appropriate `LookupError` exceptions. This is crucial for maintaining the integrity of the state management system by preventing unauthorized modifications.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies that when a restricted key (defined in `WorkerState.RESTRICTED`) is used to set a value or update the state, a `LookupError` is raised with a specific error message. This behavior is essential to enforce the rules around which keys can be modified in the `WorkerState`.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `WorkerState` class, specifically its ability to handle restricted keys. The `gen_state` function creates an instance of `WorkerState`, and the test attempts to assign a value to a restricted key and delete it, as well as update the state with a restricted key. The expected behavior is that both operations should trigger a `LookupError` with a message indicating that the operation is not allowed for the specified key.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that specific exceptions are raised during the execution of the code block. Additionally, it uses parameterization (`@pytest.mark.parametrize`) to run the test for each key in `WorkerState.RESTRICTED`, ensuring comprehensive coverage for all restricted keys without duplicating code. This approach enhances the test's maintainability and clarity."
    },
    {
      "name": "test_config_app",
      "module": "test_worker_serve",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_worker_serve.py",
      "line_number": 37,
      "end_line_number": 40,
      "source_code": "def test_config_app(mock_app: Mock):\n    with patch(\"sanic.worker.serve._serve_http_1\"):\n        worker_serve(**args(mock_app, config={\"FOO\": \"BAR\"}))\n    mock_app.update_config.assert_called_once_with({\"FOO\": \"BAR\"})",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "mock_app"
      ],
      "imports": [
        "logging",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.multiplexer.WorkerMultiplexer",
        "sanic.worker.process.Worker",
        "sanic.worker.process.WorkerProcess",
        "sanic.worker.serve.worker_serve"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "args",
          "body": "def args(app, **kwargs):\n    params = {**kwargs}\n    params.setdefault('host', '127.0.0.1')\n    params.setdefault('port', 9999)\n    params.setdefault('app_name', 'test_config_app')\n    params.setdefault('monitor_publisher', None)\n    params.setdefault('app_loader', AppLoader(factory=lambda : app))\n    return params"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_config_app` unit test is designed to verify that the `worker_serve` function correctly updates the configuration of a Sanic application when provided with specific configuration parameters. It ensures that the application receives the expected configuration settings.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `update_config` method of the `mock_app` is called exactly once with the argument `{\"FOO\": \"BAR\"}` when the `worker_serve` function is invoked with this configuration. This confirms that the application is set up with the intended configuration values.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `worker_serve` function from the `sanic.worker.serve` module, which is responsible for starting the Sanic application with the provided parameters. The `args` function constructs a dictionary of parameters, including the configuration settings, which are passed to `worker_serve`. The `patch` function is used to mock the `_serve_http_1` method, preventing the actual server from starting during the test.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test uses the `Mock` class to create a mock application (`mock_app`) that simulates the behavior of a real Sanic application without requiring a full implementation. This allows for isolated testing of the configuration update.\n- **Patching**: The `patch` function from the `unittest.mock` module is employed to replace the `_serve_http_1` method with a mock, ensuring that the test does not initiate a real server process.\n- **Assertion**: The test uses `assert_called_once_with` to verify that the `update_config` method is called with the correct parameters, ensuring that the configuration update logic is functioning as expected."
    },
    {
      "name": "test_bad_process",
      "module": "test_worker_serve",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_worker_serve.py",
      "line_number": 43,
      "end_line_number": 60,
      "source_code": "def test_bad_process(mock_app: Mock, caplog):\n    environ[\"SANIC_WORKER_NAME\"] = (\n        f\"{Worker.WORKER_PREFIX}-{WorkerProcess.SERVER_LABEL}-FOO\"\n    )\n\n    message = \"No restart publisher found in worker process\"\n    with pytest.raises(RuntimeError, match=message):\n        worker_serve(**args(mock_app))\n\n    message = \"No worker state found in worker process\"\n    publisher = Mock()\n    with caplog.at_level(logging.ERROR):\n        worker_serve(**args(mock_app, monitor_publisher=publisher))\n\n    assert (\"sanic.error\", logging.ERROR, message) in caplog.record_tuples\n    publisher.send.assert_called_once_with(\"__TERMINATE_EARLY__\")\n\n    del environ[\"SANIC_WORKER_NAME\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "mock_app",
        "caplog"
      ],
      "imports": [
        "logging",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.multiplexer.WorkerMultiplexer",
        "sanic.worker.process.Worker",
        "sanic.worker.process.WorkerProcess",
        "sanic.worker.serve.worker_serve"
      ],
      "fixtures": [],
      "assertions": [
        "assert ('sanic.error', logging.ERROR, message) in caplog.record_tuples"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "args",
          "body": "def args(app, **kwargs):\n    params = {**kwargs}\n    params.setdefault('host', '127.0.0.1')\n    params.setdefault('port', 9999)\n    params.setdefault('app_name', 'test_config_app')\n    params.setdefault('monitor_publisher', None)\n    params.setdefault('app_loader', AppLoader(factory=lambda : app))\n    return params"
        },
        {
          "name": "args",
          "body": "def args(app, **kwargs):\n    params = {**kwargs}\n    params.setdefault('host', '127.0.0.1')\n    params.setdefault('port', 9999)\n    params.setdefault('app_name', 'test_config_app')\n    params.setdefault('monitor_publisher', None)\n    params.setdefault('app_loader', AppLoader(factory=lambda : app))\n    return params"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_bad_process` function is designed to verify the behavior of the `worker_serve` function in the Sanic framework when certain conditions are not met, specifically when the worker process lacks a restart publisher or worker state. It ensures that appropriate exceptions are raised and logged when these conditions occur.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main scenarios: \n1. It verifies that a `RuntimeError` is raised with a specific message when `worker_serve` is called without a restart publisher.\n2. It confirms that when a monitor publisher is provided but the worker state is still missing, an error is logged, and the publisher's `send` method is called with the `__TERMINATE_EARLY__` message.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `worker_serve` function, which is responsible for starting the worker process in the Sanic application. The test sets up the environment variable `SANIC_WORKER_NAME` to simulate a worker process. It then calls `worker_serve` with various arguments generated by the `args` function, which provides default parameters for the server. The test checks for specific exceptions and logging behavior based on the state of the worker process.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test uses the `Mock` class to create a mock publisher, allowing the test to simulate interactions without requiring a real implementation.\n- **Context Management**: The `caplog` fixture is used to capture log messages generated during the test, enabling assertions on logging behavior.\n- **Exception Testing**: The `pytest.raises` context manager is employed to assert that specific exceptions are raised under certain conditions, ensuring that error handling is functioning as expected."
    },
    {
      "name": "test_has_multiplexer",
      "module": "test_worker_serve",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_worker_serve.py",
      "line_number": 63,
      "end_line_number": 75,
      "source_code": "def test_has_multiplexer(app: Sanic):\n    environ[\"SANIC_WORKER_NAME\"] = (\n        f\"{Worker.WORKER_PREFIX}-{WorkerProcess.SERVER_LABEL}-FOO\"\n    )\n\n    Sanic.register_app(app)\n    with patch(\"sanic.worker.serve._serve_http_1\"):\n        worker_serve(\n            **args(app, monitor_publisher=Mock(), worker_state=Mock())\n        )\n    assert isinstance(app.multiplexer, WorkerMultiplexer)\n\n    del environ[\"SANIC_WORKER_NAME\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.multiplexer.WorkerMultiplexer",
        "sanic.worker.process.Worker",
        "sanic.worker.process.WorkerProcess",
        "sanic.worker.serve.worker_serve"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(app.multiplexer, WorkerMultiplexer)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "args",
          "body": "def args(app, **kwargs):\n    params = {**kwargs}\n    params.setdefault('host', '127.0.0.1')\n    params.setdefault('port', 9999)\n    params.setdefault('app_name', 'test_config_app')\n    params.setdefault('monitor_publisher', None)\n    params.setdefault('app_loader', AppLoader(factory=lambda : app))\n    return params"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_has_multiplexer` test is to verify that the `Sanic` application instance (`app`) correctly initializes and has a `multiplexer` attribute of type `WorkerMultiplexer` after the `worker_serve` function is called. This ensures that the application is set up to manage worker processes effectively.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that the `app.multiplexer` is an instance of `WorkerMultiplexer`. This is crucial for the application's ability to handle inter-process communication and manage worker processes, which is a key feature in a server framework like Sanic that supports asynchronous operations and scaling.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `worker_serve` function, which is responsible for starting the server and managing worker processes. The test sets an environment variable to simulate a worker context, registers the application with Sanic, and then calls `worker_serve` with parameters that include a mock publisher and worker state. After the server is started, the test asserts that `app.multiplexer` is an instance of `WorkerMultiplexer`, confirming that the server setup was successful and the multiplexer was initialized.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `patch` function from the `unittest.mock` module to temporarily replace the `_serve_http_1` method during the test execution. This allows the test to focus on verifying the multiplexer initialization without actually starting an HTTP server. Additionally, the use of environment variables to simulate different contexts (like worker names) is a common technique in testing to isolate and control the environment in which the code runs. The test also utilizes assertions to validate the expected state of the application after the function call, which is a fundamental aspect of unit testing."
    },
    {
      "name": "test_serve_app_implicit",
      "module": "test_worker_serve",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_worker_serve.py",
      "line_number": 79,
      "end_line_number": 82,
      "source_code": "def test_serve_app_implicit(wm: Mock, app):\n    app.prepare()\n    Sanic.serve()\n    wm.call_args[0] == app.state.workers",
      "docstring": null,
      "decorators": [
        "patch('sanic.mixins.startup.WorkerManager')"
      ],
      "arguments": [
        "wm",
        "app"
      ],
      "imports": [
        "logging",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.multiplexer.WorkerMultiplexer",
        "sanic.worker.process.Worker",
        "sanic.worker.process.WorkerProcess",
        "sanic.worker.serve.worker_serve"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_serve_app_implicit` function is designed to verify that the `Sanic.serve()` method correctly interacts with the application instance (`app`) and that the worker multiplexer (`wm`) is called with the expected arguments, specifically the number of workers defined in the application's state.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that after preparing the application and invoking the `Sanic.serve()` method, the call arguments of the mock worker multiplexer (`wm`) match the expected number of workers defined in the application's state. This ensures that the application is set up correctly for serving requests with the specified worker configuration.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `Sanic.serve()` method, which is responsible for starting the server and managing worker processes. The `app.prepare()` method is called to set up the application, and then `Sanic.serve()` is invoked. The test asserts that the first argument of the call to `wm` matches `app.state.workers`, which indicates that the server is aware of how many worker processes it should utilize based on the application's configuration.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test uses a `Mock` object (`wm`) to simulate the behavior of the worker multiplexer, allowing the test to verify interactions without starting an actual server.\n- **Fixture Usage**: The `app` fixture is likely set up to provide a pre-configured instance of the Sanic application, ensuring that the test runs in a controlled environment.\n- **Assertion on Call Arguments**: The test checks the call arguments of the mock object to ensure that the application is configured correctly, which is a common pattern in unit testing to verify interactions with dependencies."
    },
    {
      "name": "test_serve_app_explicit",
      "module": "test_worker_serve",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_worker_serve.py",
      "line_number": 86,
      "end_line_number": 88,
      "source_code": "def test_serve_app_explicit(wm: Mock, mock_app):\n    Sanic.serve(mock_app)\n    wm.call_args[0] == mock_app.state.workers",
      "docstring": null,
      "decorators": [
        "patch('sanic.mixins.startup.WorkerManager')"
      ],
      "arguments": [
        "wm",
        "mock_app"
      ],
      "imports": [
        "logging",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.multiplexer.WorkerMultiplexer",
        "sanic.worker.process.Worker",
        "sanic.worker.process.WorkerProcess",
        "sanic.worker.serve.worker_serve"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_serve_app_explicit` function is designed to verify that the `Sanic.serve` method correctly serves the provided application (`mock_app`) and that the worker multiplexer (`wm`) is called with the expected arguments, specifically the number of workers defined in the application's state.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when the `Sanic.serve` method is invoked with a mock application, the call arguments of the worker multiplexer (`wm`) match the expected number of workers defined in the application's state. This ensures that the application is being served with the correct configuration regarding worker management.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `Sanic.serve` method, which is responsible for starting the application server. The `mock_app` is a mock object that simulates a Sanic application, and it has a state attribute `workers` set to 1. The test asserts that the first argument of the call to `wm` matches `mock_app.state.workers`, confirming that the application is served with the correct worker configuration.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs mocking to isolate the behavior of the `Sanic.serve` method from its dependencies. The `Mock` class is used to create a mock application and a mock worker multiplexer, allowing the test to focus solely on the interaction between these components without invoking the actual server logic. This is a common pattern in unit testing to ensure that tests are fast, reliable, and do not depend on external systems."
    },
    {
      "name": "test_serve_app_loader",
      "module": "test_worker_serve",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_worker_serve.py",
      "line_number": 92,
      "end_line_number": 94,
      "source_code": "def test_serve_app_loader(wm: Mock, mock_app):\n    Sanic.serve(app_loader=AppLoader(factory=lambda: mock_app))\n    wm.call_args[0] == mock_app.state.workers",
      "docstring": null,
      "decorators": [
        "patch('sanic.mixins.startup.WorkerManager')"
      ],
      "arguments": [
        "wm",
        "mock_app"
      ],
      "imports": [
        "logging",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.multiplexer.WorkerMultiplexer",
        "sanic.worker.process.Worker",
        "sanic.worker.process.WorkerProcess",
        "sanic.worker.serve.worker_serve"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_serve_app_loader` function is designed to verify that the `Sanic.serve` method correctly utilizes the `AppLoader` to load an application instance and that the worker multiplexer (represented by `wm`) is called with the expected number of workers.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when the `Sanic.serve` method is invoked with an `AppLoader` that uses a factory function to create a mock application (`mock_app`), the worker multiplexer (`wm`) receives the correct number of workers from the application's state.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `Sanic.serve` method, which is responsible for starting the Sanic server. It takes an `app_loader` argument, which is an instance of `AppLoader`. The `AppLoader` is initialized with a factory function that returns `mock_app`. The test then asserts that the first argument of the call to `wm` matches the number of workers defined in `mock_app.state.workers`, ensuring that the application is correctly loaded and the worker state is accurately reflected.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs mocking through the `Mock` class to simulate the behavior of the application and the worker multiplexer. This allows for isolation of the test from the actual implementation, ensuring that the test focuses solely on the interaction between `Sanic.serve` and the `AppLoader`. Additionally, the use of assertions to compare the expected and actual values is a common pattern in unit testing, providing a clear pass/fail outcome based on the defined expectations."
    },
    {
      "name": "test_serve_app_factory",
      "module": "test_worker_serve",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_worker_serve.py",
      "line_number": 99,
      "end_line_number": 101,
      "source_code": "def test_serve_app_factory(wm: Mock, mock_app):\n    Sanic.serve(factory=lambda: mock_app)\n    wm.call_args[0] == mock_app.state.workers",
      "docstring": null,
      "decorators": [
        "patch('sanic.mixins.startup.WorkerManager')"
      ],
      "arguments": [
        "wm",
        "mock_app"
      ],
      "imports": [
        "logging",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.multiplexer.WorkerMultiplexer",
        "sanic.worker.process.Worker",
        "sanic.worker.process.WorkerProcess",
        "sanic.worker.serve.worker_serve"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_serve_app_factory` function is designed to verify that the `Sanic.serve` method correctly initializes and serves the application created by the provided factory function, ensuring that the application state is properly set up for worker processes.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when the `Sanic.serve` method is called with a factory that returns a mock application (`mock_app`), the worker multiplexer (`wm`) is correctly configured to reference the application's worker state. Specifically, it asserts that the first argument of the `call_args` for the mock worker multiplexer matches the expected worker state of the mock application.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `Sanic.serve` method, which is responsible for starting the Sanic application in a worker context. The `factory` parameter is a lambda function that returns the `mock_app`, which is a mocked instance of a Sanic application. The test checks that the worker multiplexer (`wm`) has been called with the correct worker state from the `mock_app`, ensuring that the application is properly integrated with the worker system.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs mocking through the `Mock` class to simulate the behavior of the worker multiplexer and the application. This allows for isolation of the test from the actual implementation details of the Sanic framework. Additionally, the use of a lambda function as a factory demonstrates a common pattern in testing where dependencies are injected to control the environment and behavior of the code under test. The assertion checks the call arguments of the mock, which is a typical technique in unit tests to verify interactions with mocked objects."
    },
    {
      "name": "test_serve_with_inspector",
      "module": "test_worker_serve",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_worker_serve.py",
      "line_number": 106,
      "end_line_number": 125,
      "source_code": "def test_serve_with_inspector(\n    WorkerManager: Mock, mock_app: Mock, config: bool\n):\n    Inspector = Mock()\n    mock_app.config.INSPECTOR = config\n    mock_app.inspector_class = Inspector\n    inspector = Mock()\n    Inspector.return_value = inspector\n    WorkerManager.return_value = WorkerManager\n\n    Sanic.serve(mock_app)\n\n    if config:\n        Inspector.assert_called_once()\n        WorkerManager.manage.assert_called_once_with(\n            \"Inspector\", inspector, {}, transient=False\n        )\n    else:\n        Inspector.assert_not_called()\n        WorkerManager.manage.assert_not_called()",
      "docstring": null,
      "decorators": [
        "patch('sanic.mixins.startup.WorkerManager')",
        "pytest.mark.parametrize('config', (True, False))"
      ],
      "arguments": [
        "WorkerManager",
        "mock_app",
        "config"
      ],
      "imports": [
        "logging",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.multiplexer.WorkerMultiplexer",
        "sanic.worker.process.Worker",
        "sanic.worker.process.WorkerProcess",
        "sanic.worker.serve.worker_serve"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_serve_with_inspector` function is designed to verify the behavior of the `Sanic.serve` method when the inspector feature is enabled or disabled. It checks whether the `Inspector` class is instantiated and whether the `WorkerManager` manages the inspector correctly based on the configuration provided.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically verifies two scenarios: \n1. When the `config` parameter is `True`, it ensures that the `Inspector` is instantiated exactly once and that the `WorkerManager` manages the inspector with the expected parameters.\n2. When the `config` parameter is `False`, it confirms that the `Inspector` is not instantiated and that the `WorkerManager` does not manage the inspector.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `Sanic.serve` method, which is responsible for starting the Sanic application. The method's behavior is influenced by the `mock_app.config.INSPECTOR` setting. If this setting is `True`, the `Inspector` class is expected to be instantiated, and the `WorkerManager` should manage it. The test uses mocks to simulate the behavior of the `Inspector` and `WorkerManager`, allowing the test to assert that the correct methods are called with the expected arguments.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable testing techniques:\n- **Mocking**: The `Mock` class is used extensively to create mock objects for `WorkerManager`, `mock_app`, and `Inspector`, allowing isolation of the unit under test.\n- **Parameterization**: The test is parameterized with `@pytest.mark.parametrize`, allowing it to run twice with different configurations (`True` and `False`), which helps in verifying both branches of the conditional logic in a single test function.\n- **Assertions**: The test uses assertions to verify that the expected methods are called the correct number of times and with the correct arguments, ensuring that the behavior of the code matches the intended design."
    },
    {
      "name": "test_load_app_instance",
      "module": "test_loader",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_loader.py",
      "line_number": 20,
      "end_line_number": 23,
      "source_code": "def test_load_app_instance(module_input):\n    loader = AppLoader(module_input)\n    app = loader.load()\n    assert isinstance(app, Sanic)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('module_input', ('tests.fake.server:app', 'tests.fake.server.app'))"
      ],
      "arguments": [
        "module_input"
      ],
      "imports": [
        "sys",
        "os.getcwd",
        "pathlib.Path",
        "types.SimpleNamespace",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(app, Sanic)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "loader.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_load_app_instance` test is to verify that the `AppLoader` class can successfully load an application instance from a specified module input, ensuring that the loaded instance is of the expected type, `Sanic`.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `load` method of the `AppLoader` class returns an instance of the `Sanic` application. It ensures that the application loading mechanism works correctly for the provided module inputs, which are expected to point to valid Sanic application instances.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `load` method of the `AppLoader` class. The `load` method takes a module input (in this case, a string representing the module path) and attempts to load the corresponding application. The test creates an instance of `AppLoader` with the `module_input` parameter, calls the `load` method, and then asserts that the returned object is an instance of `Sanic`. The `load` method internally handles the import of the specified module and retrieves the application instance.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.mark.parametrize` decorator to run the same test logic with multiple inputs, allowing for efficient testing of different module paths. This pattern enhances test coverage by ensuring that various valid module inputs are validated without duplicating code. Additionally, the use of assertions to check the type of the loaded application instance is a common practice in unit testing to confirm that the expected behavior is achieved."
    },
    {
      "name": "test_load_app_factory",
      "module": "test_loader",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_loader.py",
      "line_number": 30,
      "end_line_number": 33,
      "source_code": "def test_load_app_factory(module_input):\n    loader = AppLoader(module_input, as_factory=True)\n    app = loader.load()\n    assert isinstance(app, Sanic)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('module_input', ('tests.fake.server:create_app', 'tests.fake.server:create_app()'))"
      ],
      "arguments": [
        "module_input"
      ],
      "imports": [
        "sys",
        "os.getcwd",
        "pathlib.Path",
        "types.SimpleNamespace",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(app, Sanic)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "loader.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_load_app_factory` unit test is designed to verify that the `AppLoader` class can successfully load a Sanic application instance from a specified factory function. This ensures that the application can be instantiated correctly when provided with a callable that returns a Sanic app.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that the object returned by the `load` method of `AppLoader` is an instance of the `Sanic` class when the `as_factory` flag is set to `True`. This confirms that the application loading mechanism correctly interprets the input as a factory function and executes it to produce a valid Sanic application.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `load` method of the `AppLoader` class. When `load` is called with `as_factory=True`, it processes the `module_input` (which is expected to be a callable that creates a Sanic app) and executes it. The method then returns the resulting app instance. The test uses the `module_input` parameterized with two different formats for calling the factory: `\"tests.fake.server:create_app\"` and `\"tests.fake.server:create_app()\"`, which represent different ways to reference the factory function.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.mark.parametrize` decorator to run the same test logic with multiple inputs, enhancing coverage and ensuring that different ways of referencing the factory function are handled correctly. The use of assertions to check the type of the returned object is a common practice in unit testing to validate that the expected behavior is achieved. Additionally, the test is structured to be clear and concise, focusing solely on the functionality being tested without extraneous complexity."
    },
    {
      "name": "test_load_app_simple",
      "module": "test_loader",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_loader.py",
      "line_number": 36,
      "end_line_number": 39,
      "source_code": "def test_load_app_simple():\n    loader = AppLoader(str(STATIC), as_simple=True)\n    app = loader.load()\n    assert isinstance(app, Sanic)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "sys",
        "os.getcwd",
        "pathlib.Path",
        "types.SimpleNamespace",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(app, Sanic)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "loader.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_load_app_simple` function is designed to verify that the `AppLoader` class can successfully load a Sanic application instance when provided with a simple application configuration.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `load` method of the `AppLoader` class returns an instance of the `Sanic` application when the loader is initialized with a directory path (in this case, `STATIC`) and the `as_simple` flag set to `True`. This ensures that the application loading mechanism works correctly for simple applications.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `load` method of the `AppLoader` class. When `load` is called, it attempts to load an application based on the provided `module_input`. In this test, `module_input` is set to the path of a static directory, and the `as_simple` flag indicates that the application should be loaded in a straightforward manner. The method sets up SSL data and then calls the superclass's `load` method to perform the actual loading. The test asserts that the returned object is an instance of `Sanic`, confirming that the application was loaded correctly.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern using `assert isinstance(app, Sanic)`, which is a common technique in unit testing to verify the type of an object. This ensures that the test is not only checking for the presence of an application but also confirming that it is of the expected type. Additionally, the use of a dedicated test function with a clear name (`test_load_app_simple`) follows best practices for readability and maintainability in unit tests."
    },
    {
      "name": "test_create_with_factory",
      "module": "test_loader",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_loader.py",
      "line_number": 42,
      "end_line_number": 45,
      "source_code": "def test_create_with_factory():\n    loader = AppLoader(factory=lambda: Sanic(\"Test\"))\n    app = loader.load()\n    assert isinstance(app, Sanic)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "sys",
        "os.getcwd",
        "pathlib.Path",
        "types.SimpleNamespace",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(app, Sanic)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "loader.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_create_with_factory` unit test is designed to verify that the `AppLoader` can successfully create and load a `Sanic` application instance when provided with a factory function. This ensures that the application loading mechanism works correctly when using a callable to instantiate the application.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that the object returned by the `loader.load()` method is indeed an instance of the `Sanic` class. This confirms that the factory function provided to the `AppLoader` is functioning as expected and that the application is being created correctly.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `AppLoader` class, particularly its `load` method. The `AppLoader` is initialized with a factory function (`lambda: Sanic(\"Test\")`), which, when called, creates a new `Sanic` application instance named \"Test\". The `load` method is then invoked, which is expected to execute the factory function and return the created `Sanic` instance. The assertion checks that the returned object is of the correct type.\n\n**Notable Testing Patterns or Techniques Used**:  \nThis test employs a simple assertion pattern to validate the type of the returned object, which is a common practice in unit testing to ensure that the output of a function or method meets expected criteria. The use of a lambda function as a factory is a demonstration of a functional programming technique, allowing for flexible and dynamic instantiation of objects. Additionally, the test is structured to be straightforward and focused, which is a hallmark of effective unit tests."
    },
    {
      "name": "test_cwd_in_path",
      "module": "test_loader",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_loader.py",
      "line_number": 48,
      "end_line_number": 50,
      "source_code": "def test_cwd_in_path():\n    AppLoader(\"tests.fake.server:app\").load()\n    assert getcwd() in sys.path",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "sys",
        "os.getcwd",
        "pathlib.Path",
        "types.SimpleNamespace",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert getcwd() in sys.path"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_cwd_in_path` unit test is designed to verify that the current working directory (CWD) is included in the Python module search path (`sys.path`) after loading an application using the `AppLoader` class from the Sanic framework.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks whether the CWD, obtained via `getcwd()`, is present in `sys.path` after invoking the `load()` method of the `AppLoader`. This is important because it ensures that the application can access modules and packages located in the current directory, which is a common requirement for dynamic module loading in Python applications.\n\n**Code Being Tested and How It Works**:  \nThe test calls `AppLoader(\"tests.fake.server:app\").load()`, which initializes an `AppLoader` instance with a specified module path and then loads the application. The `load()` method is expected to modify `sys.path` to include the CWD, allowing the application to resolve imports correctly. The assertion `assert getcwd() in sys.path` checks if this modification has occurred as intended.\n\n**Notable Testing Patterns or Techniques Used**:  \nThis test employs a straightforward assertion pattern to validate the expected state of `sys.path` after executing a method. It does not utilize mocking or parameterization, which are common techniques in unit testing, indicating that the test is focused on a specific side effect of the `load()` method rather than on the behavior of the method itself. The simplicity of the test reflects a direct verification of the environment setup required for the application to function correctly."
    },
    {
      "name": "test_input_is_dir",
      "module": "test_loader",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_loader.py",
      "line_number": 53,
      "end_line_number": 56,
      "source_code": "def test_input_is_dir():\n    loader = AppLoader(str(STATIC))\n    app = loader.load()\n    assert isinstance(app, Sanic)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "sys",
        "os.getcwd",
        "pathlib.Path",
        "types.SimpleNamespace",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(app, Sanic)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "loader.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_input_is_dir` test is designed to verify that the `AppLoader` can successfully load an application instance from a specified directory path, which is expected to contain the necessary application files. It ensures that the application loaded is indeed an instance of the `Sanic` class.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `load` method of the `AppLoader` class returns an object of type `Sanic` when provided with a directory path (in this case, the `STATIC` directory). This confirms that the loader can handle directory inputs correctly and instantiate the application as expected.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `load` method of the `AppLoader` class. When `loader.load()` is called, it attempts to load the application from the specified directory. The method sets up SSL data and then calls a superclass method to perform the actual loading. The test asserts that the result of this loading process is an instance of `Sanic`, which indicates that the application was loaded correctly.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern using `assert isinstance(app, Sanic)`, which is a common technique in unit testing to verify the type of an object. The use of a directory path as input is also notable, as it tests the loader's ability to handle different types of input (in this case, a directory rather than a module or factory function). The test is part of a larger suite that uses `pytest`, which allows for parameterization and structured testing of various application loading scenarios."
    },
    {
      "name": "test_input_is_factory",
      "module": "test_loader",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_loader.py",
      "line_number": 59,
      "end_line_number": 63,
      "source_code": "def test_input_is_factory():\n    ns = SimpleNamespace(target=\"foo\")\n    loader = AppLoader(\"tests.fake.server:create_app\", args=ns)\n    app = loader.load()\n    assert isinstance(app, Sanic)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "sys",
        "os.getcwd",
        "pathlib.Path",
        "types.SimpleNamespace",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(app, Sanic)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "loader.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_input_is_factory` unit test is designed to verify that the `AppLoader` class can correctly load a Sanic application instance from a specified factory function. This ensures that the application loading mechanism works as intended when the input is a callable that creates an application.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the application returned by the `loader.load()` method is an instance of the `Sanic` class when the input is a factory function (in this case, `create_app`). It confirms that the `AppLoader` can handle the creation of an application from a factory and that the resulting application is of the expected type.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `load` method of the `AppLoader` class. The `AppLoader` is initialized with a module input that specifies a factory function (`\"tests.fake.server:create_app\"`) and an argument namespace (`ns`). The `load` method is expected to execute this factory function and return an instance of `Sanic`. The test asserts that the returned `app` is indeed an instance of `Sanic`, confirming that the factory function was executed correctly and returned the expected application type.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of the `SimpleNamespace` from the `types` module to create a simple object for passing arguments to the factory function. This is a common pattern in testing to simulate the passing of parameters without needing to define a full class. Additionally, the test uses the `assert` statement to validate the type of the returned object, which is a straightforward and effective way to verify expected outcomes in unit tests. The use of a factory function as input is also a notable technique, demonstrating the flexibility of the `AppLoader` in handling different types of application instantiation."
    },
    {
      "name": "test_input_is_module",
      "module": "test_loader",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_loader.py",
      "line_number": 66,
      "end_line_number": 71,
      "source_code": "def test_input_is_module():\n    ns = SimpleNamespace(target=\"foo\")\n    loader = AppLoader(\"tests.fake.server\", args=ns)\n\n    app = loader.load()\n    assert isinstance(app, Sanic)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "sys",
        "os.getcwd",
        "pathlib.Path",
        "types.SimpleNamespace",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(app, Sanic)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "loader.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_input_is_module` test verifies that the `AppLoader` can successfully load a Sanic application instance from a specified module. It ensures that the loader correctly interprets the module input and returns an instance of the Sanic application.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `load` method of the `AppLoader` class returns an object of type `Sanic` when provided with a module input that points to a valid Sanic application. It confirms that the application loading mechanism works as intended for module-based inputs.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `load` method of the `AppLoader` class. The `load` method attempts to import the specified module (in this case, `\"tests.fake.server\"`) and retrieve the application instance. The test creates an instance of `AppLoader` with the module input and a `SimpleNamespace` for arguments, then calls `loader.load()`. The method checks if the loaded application is an instance of `Sanic`, which is the expected behavior for a valid Sanic application module.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the expected outcome, specifically using `assert isinstance(app, Sanic)` to confirm the type of the loaded application. It also utilizes the `SimpleNamespace` to simulate passing arguments to the application loader, demonstrating a common pattern in unit tests where mock or simple objects are used to provide necessary context or parameters for the test. The test is structured to be straightforward and focused, ensuring clarity in what is being validated."
    },
    {
      "name": "test_cert_loader",
      "module": "test_loader",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_loader.py",
      "line_number": 77,
      "end_line_number": 95,
      "source_code": "def test_cert_loader(MkcertCreator: Mock, TrustmeCreator: Mock, creator: str):\n    CertLoader._creators = {\n        \"mkcert\": MkcertCreator,\n        \"trustme\": TrustmeCreator,\n    }\n    MkcertCreator.return_value = MkcertCreator\n    TrustmeCreator.return_value = TrustmeCreator\n    data = {\n        \"creator\": creator,\n        \"key\": Path.cwd() / \"tests\" / \"certs\" / \"localhost\" / \"privkey.pem\",\n        \"cert\": Path.cwd() / \"tests\" / \"certs\" / \"localhost\" / \"fullchain.pem\",\n        \"localhost\": \"localhost\",\n    }\n    app = Sanic(\"Test\")\n    loader = CertLoader(data)  # type: ignore\n    loader.load(app)\n    creator_class = MkcertCreator if creator == \"mkcert\" else TrustmeCreator\n    creator_class.assert_called_once_with(app, data[\"key\"], data[\"cert\"])\n    creator_class.generate_cert.assert_called_once_with(\"localhost\")",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('creator', ('mkcert', 'trustme'))",
        "patch('sanic.worker.loader.TrustmeCreator')",
        "patch('sanic.worker.loader.MkcertCreator')"
      ],
      "arguments": [
        "MkcertCreator",
        "TrustmeCreator",
        "creator"
      ],
      "imports": [
        "sys",
        "os.getcwd",
        "pathlib.Path",
        "types.SimpleNamespace",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "loader.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_cert_loader` function is designed to verify the correct behavior of the `CertLoader` class in the Sanic framework when loading SSL certificates using different certificate creators (`MkcertCreator` and `TrustmeCreator`). It ensures that the appropriate creator is instantiated and that the expected methods are called with the correct parameters.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the `CertLoader` correctly selects the certificate creator based on the provided `creator` argument. It verifies that the `load` method of `CertLoader` is called with the Sanic app instance and that the `generate_cert` method is invoked with the correct hostname. Additionally, it ensures that the instantiation of the certificate creator is done with the correct key and certificate paths.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a mock environment where `MkcertCreator` and `TrustmeCreator` are mocked to simulate their behavior without needing actual implementations. It assigns these mocks to the `_creators` attribute of `CertLoader`. The test then creates a `Sanic` app instance and a `CertLoader` instance with a data dictionary containing paths to the SSL key and certificate files. The `load` method of `CertLoader` is called, which is expected to set up the SSL data for the app. Finally, assertions are made to confirm that the correct creator was called with the expected arguments.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test uses the `Mock` class from the `unittest.mock` module to create mock objects for `MkcertCreator` and `TrustmeCreator`, allowing for isolation of the test from external dependencies.\n- **Parameterization**: The test is designed to be parameterized (though the parameterization is not shown in the provided snippet), allowing it to run multiple times with different values for the `creator` argument, thus testing both certificate creators in a single test function.\n- **Assertions**: The test employs assertions to verify that the expected methods were called exactly once with the correct parameters, ensuring that the behavior of the `CertLoader` is as intended."
    },
    {
      "name": "test_run_http_1",
      "module": "test_runner",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_runner.py",
      "line_number": 12,
      "end_line_number": 15,
      "source_code": "def test_run_http_1(_serve_http_3: Mock, _serve_http_1: Mock, app: Sanic):\n    serve(\"\", 0, app)\n    _serve_http_3.assert_not_called()\n    _serve_http_1.assert_called_once()",
      "docstring": null,
      "decorators": [
        "patch('sanic.server.runners._serve_http_1')",
        "patch('sanic.server.runners._serve_http_3')"
      ],
      "arguments": [
        "_serve_http_3",
        "_serve_http_1",
        "app"
      ],
      "imports": [
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.app.Sanic",
        "sanic.http.constants.HTTP",
        "sanic.server.runners._run_server_forever",
        "sanic.server.runners.serve"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_run_http_1` unit test is designed to verify that the correct HTTP server handling function is invoked when the Sanic application is served without specifying an HTTP version. Specifically, it checks that the `_serve_http_1` function is called once, while `_serve_http_3` is not called at all.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when the `serve` function is called with default parameters (indicating HTTP/1.1), the application correctly routes the request handling to the appropriate HTTP version handler. It confirms that the application does not mistakenly invoke the HTTP/3 handler in this scenario.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `serve` function from the Sanic framework, which is responsible for starting the server and handling incoming requests. The test uses the `@patch` decorator from the `unittest.mock` module to replace the actual `_serve_http_1` and `_serve_http_3` functions with mock objects. This allows the test to assert whether these functions were called or not without executing their real implementations.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test employs mocking to isolate the behavior of the `serve` function from the actual HTTP handling functions. This is crucial for unit testing, as it allows the test to focus solely on the logic of the `serve` function without side effects from the real HTTP handlers.\n- **Assertions**: The test uses assertions (`assert_called_once` and `assert_not_called`) to verify the expected interactions with the mocked functions, ensuring that the correct function is invoked based on the input parameters.\n- **Parameterization**: Although not directly used in this specific test, the surrounding tests in the codebase utilize `pytest.mark.parametrize`, showcasing a pattern for testing multiple scenarios with different inputs efficiently."
    },
    {
      "name": "test_run_http_3",
      "module": "test_runner",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_runner.py",
      "line_number": 20,
      "end_line_number": 23,
      "source_code": "def test_run_http_3(_serve_http_3: Mock, _serve_http_1: Mock, app: Sanic):\n    serve(\"\", 0, app, version=HTTP.VERSION_3)\n    _serve_http_1.assert_not_called()\n    _serve_http_3.assert_called_once()",
      "docstring": null,
      "decorators": [
        "patch('sanic.server.runners._serve_http_1')",
        "patch('sanic.server.runners._serve_http_3')"
      ],
      "arguments": [
        "_serve_http_3",
        "_serve_http_1",
        "app"
      ],
      "imports": [
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.app.Sanic",
        "sanic.http.constants.HTTP",
        "sanic.server.runners._run_server_forever",
        "sanic.server.runners.serve"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_run_http_3` unit test is designed to verify that the Sanic application correctly utilizes HTTP/3 when the `serve` function is called with the `version` parameter set to `HTTP.VERSION_3`. It ensures that the appropriate HTTP handler for version 3 is invoked while confirming that the handler for HTTP/1 is not called.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when the server is started with HTTP/3, the `_serve_http_3` mock is called exactly once, indicating that the server is handling requests using the HTTP/3 protocol. Conversely, it asserts that the `_serve_http_1` mock is not called at all, confirming that the server does not fall back to HTTP/1 in this scenario.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `serve` function from the `sanic.server.runners` module. This function is responsible for starting the server and handling incoming requests. By passing an empty string and port `0` along with the application instance and the HTTP version, the test simulates starting the server. The `serve` function internally decides which HTTP handler to invoke based on the provided version, which is where the mocks `_serve_http_1` and `_serve_http_3` come into play.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `unittest.mock` library to create mock objects for the HTTP handlers. The `@patch` decorator is used to replace the actual `_serve_http_1` and `_serve_http_3` functions with mock objects, allowing the test to assert their call behavior without invoking the real implementations. This isolation of the test from the actual server logic is a common pattern in unit testing, enabling focused testing of specific behaviors without side effects. Additionally, the use of assertions (`assert_called_once` and `assert_not_called`) provides a clear and concise way to verify the expected interactions with the mocks."
    },
    {
      "name": "test_run_server_forever",
      "module": "test_runner",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_runner.py",
      "line_number": 28,
      "end_line_number": 58,
      "source_code": "def test_run_server_forever(remove_unix_socket: Mock, do_cleanup: bool):\n    loop = Mock()\n    cleanup = Mock()\n    loop.run_forever = Mock(side_effect=KeyboardInterrupt())\n    before_stop = Mock()\n    before_stop.return_value = Mock()\n    after_stop = Mock()\n    after_stop.return_value = Mock()\n    unix = Mock()\n\n    with pytest.raises(KeyboardInterrupt):\n        _run_server_forever(\n            loop,\n            before_stop,\n            after_stop,\n            cleanup if do_cleanup else None,\n            unix,\n        )\n\n    loop.run_forever.assert_called_once_with()\n    loop.run_until_complete.assert_has_calls(\n        [call(before_stop.return_value), call(after_stop.return_value)]\n    )\n\n    if do_cleanup:\n        cleanup.assert_called_once_with()\n    else:\n        cleanup.assert_not_called()\n\n    remove_unix_socket.assert_called_once_with(unix)\n    loop.close.assert_called_once_with()",
      "docstring": null,
      "decorators": [
        "patch('sanic.server.runners.remove_unix_socket')",
        "pytest.mark.parametrize('do_cleanup', (True, False))"
      ],
      "arguments": [
        "remove_unix_socket",
        "do_cleanup"
      ],
      "imports": [
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.app.Sanic",
        "sanic.http.constants.HTTP",
        "sanic.server.runners._run_server_forever",
        "sanic.server.runners.serve"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_run_server_forever` function is designed to verify the behavior of the `_run_server_forever` function in the Sanic framework when it is interrupted by a `KeyboardInterrupt`. This test ensures that the server's shutdown process is correctly initiated and that the appropriate cleanup actions are taken based on the `do_cleanup` parameter.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when `_run_server_forever` is called, it correctly handles a `KeyboardInterrupt` exception. It verifies that the event loop's `run_forever` method is called once, and that the `run_until_complete` method is called with the expected `before_stop` and `after_stop` return values. Additionally, it confirms that the cleanup function is called only if `do_cleanup` is `True`, and that the `remove_unix_socket` function is invoked with the correct argument.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `_run_server_forever` function, which is responsible for running the server indefinitely until interrupted. It utilizes an event loop to manage asynchronous tasks, including stopping the server gracefully. The test simulates a `KeyboardInterrupt` by setting the `run_forever` method of the mock event loop to raise this exception. The test then checks that the server's shutdown sequence is executed correctly, including calling cleanup functions and closing the event loop.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable testing techniques:\n- **Mocking**: The use of `Mock` objects allows the test to simulate the behavior of the event loop and other dependencies without requiring a real server environment.\n- **Parameterization**: The `do_cleanup` parameter is tested with both `True` and `False` values, allowing the test to cover different scenarios in a single test function.\n- **Exception Handling**: The test uses `pytest.raises` to assert that a `KeyboardInterrupt` is raised, ensuring that the function behaves as expected under this condition.\n- **Assertions**: Various assertions are made to confirm that the expected methods are called with the correct arguments, ensuring that the server's shutdown process is correctly implemented."
    },
    {
      "name": "test_get_context",
      "module": "test_startup",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_startup.py",
      "line_number": 24,
      "end_line_number": 28,
      "source_code": "def test_get_context(start_method, platform, expected):\n    if start_method:\n        Sanic.start_method = start_method\n    with patch(\"sys.platform\", platform):\n        assert Sanic._get_startup_method() == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('start_method,platform,expected', ((None, 'linux', 'spawn'), (None, 'other', 'spawn'), ('fork', 'linux', 'fork'), ('fork', 'other', 'fork'), ('forkserver', 'linux', 'forkserver'), ('forkserver', 'other', 'forkserver'), ('spawn', 'linux', 'spawn'), ('spawn', 'other', 'spawn')))"
      ],
      "arguments": [
        "start_method",
        "platform",
        "expected"
      ],
      "imports": [
        "sys",
        "multiprocessing.set_start_method",
        "unittest.mock.patch",
        "pytest",
        "sanic.Sanic"
      ],
      "fixtures": [],
      "assertions": [
        "assert Sanic._get_startup_method() == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_get_context` function is designed to verify the behavior of the `Sanic._get_startup_method()` function, specifically how it determines the startup method based on the provided `start_method` and the current platform.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the correct startup method is returned by `Sanic._get_startup_method()` given different combinations of `start_method` and `platform`. It ensures that the method correctly defaults to \"spawn\" when no specific method is set and that it respects the provided method when applicable.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `Sanic._get_startup_method()` method, which likely contains logic to determine the startup method based on the operating system and any user-defined settings. The test uses the `patch` function from the `unittest.mock` module to temporarily change the value of `sys.platform`, simulating different operating systems during the test. The assertion checks that the output of `_get_startup_method()` matches the expected value for each test case.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses `pytest.mark.parametrize` to run multiple scenarios with different combinations of `start_method`, `platform`, and `expected` values, promoting code reuse and clarity.\n- **Mocking**: The `patch` function is employed to mock the `sys.platform` variable, allowing the test to simulate different environments without needing to run on actual different operating systems.\n- **Conditional Logic**: The test includes a conditional statement to set `Sanic.start_method` only if a value is provided, demonstrating how to handle optional parameters in tests."
    },
    {
      "name": "test_set_startup_catch",
      "module": "test_startup",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_startup.py",
      "line_number": 34,
      "end_line_number": 44,
      "source_code": "def test_set_startup_catch():\n    Sanic.START_METHOD_SET = False\n    set_start_method(\"fork\", force=True)\n    Sanic.test_mode = False\n    message = (\n        \"Start method 'spawn' was requested, but 'fork' was already set.\\n\"\n        \"For more information, see: https://sanic.dev/en/guide/running/manager.html#overcoming-a-coderuntimeerrorcode\"\n    )\n    with pytest.raises(RuntimeError, match=message):\n        Sanic._set_startup_method()\n    Sanic.test_mode = True",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(not sys.platform.startswith('linux'), reason='Only test on Linux')"
      ],
      "arguments": [],
      "imports": [
        "sys",
        "multiprocessing.set_start_method",
        "unittest.mock.patch",
        "pytest",
        "sanic.Sanic"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_set_startup_catch` unit test is designed to verify that the `Sanic._set_startup_method()` function correctly raises a `RuntimeError` when an attempt is made to set a startup method that conflicts with an already established method. Specifically, it checks that if the startup method is set to \"fork\" while \"spawn\" is requested, the appropriate error message is raised.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the Sanic framework enforces the correct startup method for multiprocessing. It verifies that if the startup method has already been set (in this case, to \"fork\"), and a conflicting request is made to set it to \"spawn\", a `RuntimeError` is raised with a specific error message. This behavior is crucial for maintaining the integrity of the multiprocessing context in the application.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `Sanic._set_startup_method()` method. This method checks if the startup method has already been set and whether the application is in test mode. If the method is called when the startup method is already set to a different value than requested, it raises a `RuntimeError`. The test sets the startup method to \"fork\" and then attempts to set it to \"spawn\", expecting the error to be raised. The error message is matched against a predefined string to ensure it is the expected output.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The test uses a context manager (`with pytest.raises(...)`) to assert that an exception is raised during the execution of the code block.\n- **Parameterized Testing**: Although not directly used in this specific test, the surrounding code demonstrates the use of `pytest.mark.parametrize`, which is a common pattern in pytest for running the same test logic with different input values.\n- **Mocking**: The test indirectly relies on the behavior of the `set_start_method` function from the `multiprocessing` module, which is patched in other tests to control its behavior, ensuring that the test environment is isolated and does not affect the actual multiprocessing settings."
    },
    {
      "name": "test_restart_transient",
      "module": "test_restarter",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_restarter.py",
      "line_number": 24,
      "end_line_number": 40,
      "source_code": "def test_restart_transient():\n    transient = make_worker_process(\"Transient\")\n    durable = make_worker_process(\"Durable\")\n    restarter = Restarter()\n\n    restarter.restart([transient], [durable])\n    transient.restart.assert_called_once_with(\n        restart_order=RestartOrder.SHUTDOWN_FIRST\n    )\n    durable.restart.assert_not_called()\n    transient.restart.reset_mock()\n    restarter.restart(\n        [transient], [durable], restart_order=RestartOrder.STARTUP_FIRST\n    )\n    transient.restart.assert_called_once_with(\n        restart_order=RestartOrder.STARTUP_FIRST\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.worker.constants.ProcessState",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.process.WorkerProcess",
        "sanic.worker.restarter.Restarter"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_worker_process",
          "body": "def make_worker_process(name: str, state: ProcessState=ProcessState.STARTED) -> WorkerProcess:\n    worker_process = Mock()\n    worker_process.restart = Mock()\n    worker_process.name = name\n    worker_process.state = state\n    return worker_process"
        },
        {
          "name": "make_worker_process",
          "body": "def make_worker_process(name: str, state: ProcessState=ProcessState.STARTED) -> WorkerProcess:\n    worker_process = Mock()\n    worker_process.restart = Mock()\n    worker_process.name = name\n    worker_process.state = state\n    return worker_process"
        },
        {
          "name": "transient.restart.reset_mock",
          "body": "def reset_mock(self, *args, **kwargs):\n    super().reset_mock(*args, **kwargs)\n    self.await_count = 0"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_restart_transient` function is designed to verify the behavior of the `Restarter` class when restarting worker processes, specifically focusing on transient and durable worker processes. It ensures that the transient worker is restarted correctly based on the specified restart order, while the durable worker is not restarted under certain conditions.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main behaviors:\n1. When the `restart` method is called with the default `restart_order` of `SHUTDOWN_FIRST`, it verifies that the transient worker's `restart` method is called once with this order, and the durable worker's `restart` method is not called.\n2. It also verifies that when the `restart` method is called with a `restart_order` of `STARTUP_FIRST`, the transient worker's `restart` method is called again with this new order.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `Restarter` class's `restart` method, which is responsible for managing the restart of worker processes. The `make_worker_process` function creates mock worker processes with a `restart` method that can be tracked for calls. The transient worker is expected to respond to restart commands, while the durable worker should remain unaffected during the transient's restart process. The assertions in the test confirm that the correct methods are called with the expected parameters.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test uses the `Mock` class from the `unittest.mock` module to create mock worker processes, allowing for the tracking of method calls without needing actual implementations.\n- **Assertions**: The test employs assertions to verify that the `restart` method is called with the correct parameters and that it behaves as expected under different conditions.\n- **State Resetting**: The `reset_mock` method is used to clear the call history of the transient worker's `restart` method between assertions, ensuring that each test phase starts with a clean slate."
    },
    {
      "name": "test_restart_durable",
      "module": "test_restarter",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_restarter.py",
      "line_number": 58,
      "end_line_number": 89,
      "source_code": "def test_restart_durable(caplog, state, called):\n    transient = make_worker_process(\"Transient\")\n    durable = make_worker_process(\"Durable\")\n    restarter = Restarter()\n\n    restarter.restart([transient], [durable], process_names=[\"Durable\"])\n\n    transient.restart.assert_not_called()\n    durable.restart.assert_not_called()\n\n    assert (\n        \"sanic.error\",\n        40,\n        \"Cannot restart process Durable because it is not in a \"\n        \"final state. Current state is: STARTED.\",\n    ) in caplog.record_tuples\n    assert (\n        \"sanic.error\",\n        40,\n        \"Failed to restart processes: Durable\",\n    ) in caplog.record_tuples\n\n    durable.state = state\n    restarter.restart([transient], [durable], process_names=[\"Durable\"])\n\n    transient.restart.assert_not_called()\n    if called:\n        durable.restart.assert_called_once_with(\n            restart_order=RestartOrder.SHUTDOWN_FIRST\n        )\n    else:\n        durable.restart.assert_not_called()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('state,called', ((ProcessState.IDLE, False), (ProcessState.RESTARTING, False), (ProcessState.STARTING, False), (ProcessState.STARTED, False), (ProcessState.ACKED, False), (ProcessState.JOINED, False), (ProcessState.TERMINATED, False), (ProcessState.FAILED, True), (ProcessState.COMPLETED, True), (ProcessState.NONE, True)))"
      ],
      "arguments": [
        "caplog",
        "state",
        "called"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.worker.constants.ProcessState",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.process.WorkerProcess",
        "sanic.worker.restarter.Restarter"
      ],
      "fixtures": [],
      "assertions": [
        "assert ('sanic.error', 40, 'Cannot restart process Durable because it is not in a final state. Current state is: STARTED.') in caplog.record_tuples",
        "assert ('sanic.error', 40, 'Failed to restart processes: Durable') in caplog.record_tuples"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_worker_process",
          "body": "def make_worker_process(name: str, state: ProcessState=ProcessState.STARTED) -> WorkerProcess:\n    worker_process = Mock()\n    worker_process.restart = Mock()\n    worker_process.name = name\n    worker_process.state = state\n    return worker_process"
        },
        {
          "name": "make_worker_process",
          "body": "def make_worker_process(name: str, state: ProcessState=ProcessState.STARTED) -> WorkerProcess:\n    worker_process = Mock()\n    worker_process.restart = Mock()\n    worker_process.name = name\n    worker_process.state = state\n    return worker_process"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_restart_durable` function is designed to verify the behavior of the `Restarter` class when attempting to restart a \"durable\" worker process that is not in a final state. It ensures that the appropriate error messages are logged and that the restart behavior is correctly executed based on the state of the worker process.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main scenarios: \n1. When the durable process is in a non-final state (e.g., `STARTED`), it verifies that the restart method is not called and that specific error messages are logged.\n2. When the durable process is in a final state (controlled by the `state` parameter), it checks whether the restart method is called or not based on the `called` parameter, ensuring that the restart logic behaves correctly according to the process's state.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `Restarter` class's `restart` method, which takes lists of transient and durable worker processes and a list of process names to restart. The `make_worker_process` function creates mock worker processes with specified names and states. The test manipulates the state of the durable process and invokes the `restart` method, then asserts the expected behavior regarding the calls to the `restart` method of the mock processes and checks the log records for error messages.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test uses the `Mock` class to create mock worker processes, allowing for controlled testing of interactions without needing actual process implementations.\n- **Assertions on Call Counts**: The test employs assertions to verify that certain methods (like `restart`) are called or not called, which is a common pattern in unit testing to ensure that the code behaves as expected.\n- **Logging Verification**: The use of `caplog` to capture log messages allows the test to assert that the correct error messages are logged under specific conditions, ensuring that the logging behavior is also tested alongside the functional behavior."
    },
    {
      "name": "test_set_items",
      "module": "test_shared_ctx",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_shared_ctx.py",
      "line_number": 33,
      "end_line_number": 44,
      "source_code": "def test_set_items(item: Any, okay: bool, caplog):\n    ctx = SharedContext()\n\n    with caplog.at_level(logging.INFO):\n        ctx.item = item\n\n    assert ctx.is_locked is False\n    assert len(caplog.record_tuples) == 0 if okay else 1\n    if not okay:\n        assert caplog.record_tuples[0][0] == \"sanic.error\"\n        assert caplog.record_tuples[0][1] == logging.WARNING\n        assert \"Unsafe object\" in caplog.record_tuples[0][2]",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('item,okay', ((Pipe(), True), (Value('i', 0), True), (Queue(), True), (c_int32(1), True), (1, False), ('thing', False), (object(), False)))"
      ],
      "arguments": [
        "item",
        "okay",
        "caplog"
      ],
      "imports": [
        "logging",
        "ctypes.c_int32",
        "multiprocessing.Pipe",
        "multiprocessing.Queue",
        "multiprocessing.Value",
        "os.environ",
        "typing.Any",
        "pytest",
        "sanic.types.shared_ctx.SharedContext"
      ],
      "fixtures": [],
      "assertions": [
        "assert ctx.is_locked is False",
        "assert len(caplog.record_tuples) == 0 if okay else 1",
        "assert caplog.record_tuples[0][0] == 'sanic.error'",
        "assert caplog.record_tuples[0][1] == logging.WARNING",
        "assert 'Unsafe object' in caplog.record_tuples[0][2]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_set_items` function is designed to verify the behavior of the `SharedContext` class when setting an item. It checks whether the context correctly handles safe and unsafe objects, ensuring that appropriate logging occurs for unsafe items.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies two main behaviors: \n1. The `is_locked` attribute of the `SharedContext` instance remains `False` after setting an item.\n2. The logging behavior is validated based on the type of item being set. If the item is deemed unsafe (e.g., a string or a generic object), it checks that a warning is logged; otherwise, it confirms that no logs are generated.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `SharedContext` class, specifically its ability to accept various types of items. The test uses the `caplog` fixture from `pytest` to capture log messages generated during the execution of the test. The `item` parameter can be a safe or unsafe object, and the `okay` boolean indicates whether the item is expected to be accepted without warnings. The test sets the `item` attribute of the `SharedContext` instance and then asserts the expected state of the context and the log records.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses `pytest.mark.parametrize` to run multiple scenarios with different combinations of `item` and `okay`, allowing for efficient testing of various input cases without duplicating code.\n- **Logging Capture**: The `caplog` fixture is employed to capture log messages, enabling assertions on the logging output, which is crucial for verifying side effects in the code.\n- **Assertions**: The test includes multiple assertions to validate both the state of the `SharedContext` and the contents of the log records, ensuring comprehensive coverage of the expected behavior."
    },
    {
      "name": "test_set_items_in_worker",
      "module": "test_shared_ctx",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_shared_ctx.py",
      "line_number": 59,
      "end_line_number": 68,
      "source_code": "def test_set_items_in_worker(item: Any, caplog):\n    ctx = SharedContext()\n\n    environ[\"SANIC_WORKER_NAME\"] = \"foo\"\n    with caplog.at_level(logging.INFO):\n        ctx.item = item\n    del environ[\"SANIC_WORKER_NAME\"]\n\n    assert ctx.is_locked is False\n    assert len(caplog.record_tuples) == 0",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('item', (Pipe(), Value('i', 0), Queue(), c_int32(1), 1, 'thing', object()))"
      ],
      "arguments": [
        "item",
        "caplog"
      ],
      "imports": [
        "logging",
        "ctypes.c_int32",
        "multiprocessing.Pipe",
        "multiprocessing.Queue",
        "multiprocessing.Value",
        "os.environ",
        "typing.Any",
        "pytest",
        "sanic.types.shared_ctx.SharedContext"
      ],
      "fixtures": [],
      "assertions": [
        "assert ctx.is_locked is False",
        "assert len(caplog.record_tuples) == 0"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_set_items_in_worker` function is designed to verify the behavior of the `SharedContext` class when an item is set in a worker context. Specifically, it checks that the context remains unlocked and that no logging occurs when a valid item is assigned.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when an item is assigned to the `SharedContext` while the environment variable `SANIC_WORKER_NAME` is set, the `is_locked` attribute of the context remains `False`, indicating that the context is not locked. Additionally, it verifies that no log messages are generated during this operation, which suggests that the item being set is considered safe.\n\n**Code Being Tested and How It Works**:  \nThe test creates an instance of `SharedContext` and sets the environment variable `SANIC_WORKER_NAME` to \"foo\". It then assigns the provided `item` to `ctx.item` within a logging context that captures log messages at the INFO level. After the assignment, the test checks that `ctx.is_locked` is `False` and that the length of `caplog.record_tuples` is `0`, indicating no log messages were recorded.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterized Testing**: The test uses the `pytest.mark.parametrize` decorator to run the test with various types of items, allowing for comprehensive coverage of different scenarios.\n- **Context Management for Logging**: The use of `caplog.at_level(logging.INFO)` allows the test to capture log messages generated during the assignment operation, facilitating verification of logging behavior.\n- **Environment Variable Manipulation**: The test temporarily sets and deletes an environment variable to simulate the worker context, demonstrating a common pattern in testing where external dependencies are controlled to isolate the unit of work being tested."
    },
    {
      "name": "test_lock",
      "module": "test_shared_ctx",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_shared_ctx.py",
      "line_number": 71,
      "end_line_number": 82,
      "source_code": "def test_lock():\n    ctx = SharedContext()\n\n    assert ctx.is_locked is False\n\n    ctx.lock()\n\n    assert ctx.is_locked is True\n\n    message = \"Cannot set item on locked SharedContext object\"\n    with pytest.raises(RuntimeError, match=message):\n        ctx.item = 1",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "ctypes.c_int32",
        "multiprocessing.Pipe",
        "multiprocessing.Queue",
        "multiprocessing.Value",
        "os.environ",
        "typing.Any",
        "pytest",
        "sanic.types.shared_ctx.SharedContext"
      ],
      "fixtures": [],
      "assertions": [
        "assert ctx.is_locked is False",
        "assert ctx.is_locked is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_lock` function is designed to verify the locking mechanism of the `SharedContext` class. It ensures that the context can be locked and that attempts to modify it while locked raise the appropriate exceptions.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main behaviors: \n1. It confirms that the `is_locked` attribute of the `SharedContext` instance is initially `False`, indicating that the context is not locked.\n2. After invoking the `lock()` method, it verifies that `is_locked` becomes `True`. Additionally, it tests that attempting to set an item in the context while it is locked raises a `RuntimeError` with a specific error message.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `SharedContext` class, specifically its `lock()` method and the behavior of the `item` attribute when the context is locked. The `lock()` method presumably sets the `is_locked` attribute to `True`, preventing any modifications to the context. The test creates an instance of `SharedContext`, checks its initial state, locks it, and then attempts to assign a value to `ctx.item`, which should fail when the context is locked.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the state of the `SharedContext` before and after locking. It also utilizes the `pytest.raises` context manager to assert that a specific exception is raised under certain conditions, which is a common pattern in unit testing to handle expected failures. The use of a specific error message in the `match` parameter enhances the clarity of the test by ensuring that the correct exception is raised for the right reason."
    },
    {
      "name": "test_send_inspect",
      "module": "test_inspector",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_inspector.py",
      "line_number": 61,
      "end_line_number": 67,
      "source_code": "def test_send_inspect(write, urlopen, command: str):\n    urlopen.read.return_value = FULL_SERIALIZED.encode()\n    InspectorClient(\"localhost\", 9999, False, False, None).do(command)\n    write.assert_called()\n    write.reset_mock()\n    InspectorClient(\"localhost\", 9999, False, True, None).do(command)\n    write.assert_called_with(OUT_SERIALIZED + \"\\n\")",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('command', ('info',))",
        "patch('sanic.cli.inspector_client.sys.stdout.write')"
      ],
      "arguments": [
        "write",
        "urlopen",
        "command"
      ],
      "imports": [
        "datetime.datetime",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.error.URLError",
        "pytest",
        "sanic_testing.TestManager",
        "sanic.cli.inspector_client.InspectorClient",
        "sanic.helpers.Default",
        "sanic.log.Colors",
        "sanic.worker.inspector.Inspector",
        "ujson.dumps",
        "json.dumps"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "write.reset_mock",
          "body": "def reset_mock(self, *args, **kwargs):\n    super().reset_mock(*args, **kwargs)\n    self.await_count = 0"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_send_inspect` function is designed to verify the behavior of the `InspectorClient` when sending commands to an inspector service. It specifically checks that the correct output is generated based on the command sent and that the appropriate methods are called on the mocked `write` object.\n\n**Specific Functionality or Behavior Verified**:  \nThis test verifies two main behaviors: \n1. It ensures that when the `do` method of `InspectorClient` is called with a command, the `write` method is invoked at least once.\n2. It checks that when the `do` method is called with a different configuration (specifically, the last parameter set to `True`), the `write` method is called with the expected serialized output.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `InspectorClient` class, which is responsible for communicating with an inspector service. The `do` method of this class takes a command (in this case, \"info\") and sends it to the inspector. The test uses a mock for `sys.stdout.write` (aliased as `write`) to capture and assert the output generated by the `do` method. The `urlopen` mock simulates the response from the inspector service, returning a predefined serialized string (`FULL_SERIALIZED`).\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test uses the `unittest.mock.patch` decorator to replace `sys.stdout.write` with a mock object, allowing the test to assert calls and parameters without affecting the actual output.\n- **Parameterization**: The test is parameterized with the `@pytest.mark.parametrize` decorator, allowing it to run with different command inputs, which enhances test coverage and reduces code duplication.\n- **Resetting Mocks**: The `write.reset_mock()` method is called to clear previous call history, ensuring that assertions for subsequent calls are accurate and isolated from previous tests."
    },
    {
      "name": "test_send_inspect_conn_refused",
      "module": "test_inspector",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_inspector.py",
      "line_number": 71,
      "end_line_number": 82,
      "source_code": "def test_send_inspect_conn_refused(sys: Mock, urlopen):\n    urlopen.side_effect = URLError(\"\")\n    InspectorClient(\"localhost\", 9999, False, False, None).do(\"info\")\n\n    message = (\n        f\"{Colors.RED}Could not connect to inspector at: \"\n        f\"{Colors.YELLOW}http://localhost:9999{Colors.END}\\n\"\n        \"Either the application is not running, or it did not start \"\n        \"an inspector instance.\\n<urlopen error >\\n\"\n    )\n    sys.exit.assert_called_once_with(1)\n    sys.stderr.write.assert_called_once_with(message)",
      "docstring": null,
      "decorators": [
        "patch('sanic.cli.inspector_client.sys')"
      ],
      "arguments": [
        "sys",
        "urlopen"
      ],
      "imports": [
        "datetime.datetime",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.error.URLError",
        "pytest",
        "sanic_testing.TestManager",
        "sanic.cli.inspector_client.InspectorClient",
        "sanic.helpers.Default",
        "sanic.log.Colors",
        "sanic.worker.inspector.Inspector",
        "ujson.dumps",
        "json.dumps"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_send_inspect_conn_refused` unit test is designed to verify the behavior of the `InspectorClient` when it encounters a connection refusal while attempting to communicate with an inspector service. Specifically, it checks that the appropriate error message is written to standard error and that the program exits with a status code of 1.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a `URLError` is raised (simulating a connection failure), the system responds correctly by outputting a specific error message to `sys.stderr` and terminating the process with an exit code of 1. This behavior is crucial for user feedback and proper error handling in the application.\n\n**Code Being Tested and How It Works**:  \nThe code under test is part of the `InspectorClient` class, which attempts to connect to an inspector service using the `urlopen` function. When a connection cannot be established (in this case, due to a simulated `URLError`), the exception handling block captures the error, constructs a user-friendly error message, writes it to `sys.stderr`, and calls `sys.exit(1)` to terminate the program. The test mocks the `urlopen` function to raise a `URLError`, allowing the test to simulate the connection failure scenario.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `unittest.mock` library to mock dependencies (`sys` and `urlopen`), allowing for controlled testing of error conditions without requiring an actual network connection. It uses `assert_called_once_with` to verify that the expected methods (`sys.exit` and `sys.stderr.write`) are called with the correct arguments, ensuring that the test is both precise and focused on the expected outcomes of the error handling logic. This approach is a common pattern in unit testing to isolate the unit of work and verify its behavior under specific conditions."
    },
    {
      "name": "test_run_inspector_reload",
      "module": "test_inspector",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_inspector.py",
      "line_number": 85,
      "end_line_number": 88,
      "source_code": "def test_run_inspector_reload(publisher, http_client):\n    _, response = http_client.post(\"/reload\")\n    assert response.status == 200\n    publisher.send.assert_called_once_with(\"__ALL_PROCESSES__:\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "publisher",
        "http_client"
      ],
      "imports": [
        "datetime.datetime",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.error.URLError",
        "pytest",
        "sanic_testing.TestManager",
        "sanic.cli.inspector_client.InspectorClient",
        "sanic.helpers.Default",
        "sanic.log.Colors",
        "sanic.worker.inspector.Inspector",
        "ujson.dumps",
        "json.dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "http_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_run_inspector_reload` function is designed to verify that the `/reload` endpoint of the Sanic application correctly triggers a reload action and responds with a status code of 200. It also checks that the appropriate message is sent to the publisher, indicating that all processes should be reloaded.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically verifies two behaviors: \n1. The HTTP response status from the `/reload` endpoint is 200, indicating a successful request.\n2. The `send` method of the `publisher` mock is called exactly once with the argument `\"__ALL_PROCESSES__:\"`, confirming that the reload action is communicated correctly.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `http_client.post` method, which simulates an HTTP POST request to the `/reload` endpoint. The expected behavior is that this endpoint should handle the request and return a response with a status code of 200. The `publisher` mock is used to assert that the correct message is sent when the reload action is triggered. The `http_client` is set up through a fixture that provides a test client for the Sanic application.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of fixtures to set up the necessary context for the test, specifically the `publisher` and `http_client`. It also utilizes assertions to validate the response status and the call to the mock publisher. The use of `assert_called_once_with` is a notable technique here, as it ensures that the method is called exactly once with the expected argument, which is crucial for verifying the side effects of the reload action."
    },
    {
      "name": "test_run_inspector_reload_zero_downtime",
      "module": "test_inspector",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_inspector.py",
      "line_number": 91,
      "end_line_number": 94,
      "source_code": "def test_run_inspector_reload_zero_downtime(publisher, http_client):\n    _, response = http_client.post(\"/reload\", json={\"zero_downtime\": True})\n    assert response.status == 200\n    publisher.send.assert_called_once_with(\"__ALL_PROCESSES__::STARTUP_FIRST\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "publisher",
        "http_client"
      ],
      "imports": [
        "datetime.datetime",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.error.URLError",
        "pytest",
        "sanic_testing.TestManager",
        "sanic.cli.inspector_client.InspectorClient",
        "sanic.helpers.Default",
        "sanic.log.Colors",
        "sanic.worker.inspector.Inspector",
        "ujson.dumps",
        "json.dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "http_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_run_inspector_reload_zero_downtime` test is designed to verify that the application can successfully handle a request to reload its configuration or state without downtime, specifically when the `zero_downtime` flag is set to `True`.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks two main outcomes: \n1. It asserts that the HTTP response status is `200`, indicating a successful request.\n2. It verifies that the `publisher`'s `send` method is called exactly once with the argument `\"__ALL_PROCESSES__::STARTUP_FIRST\"`, which suggests that the application is signaling all processes to start up in a coordinated manner.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `http_client.post` method, which simulates sending a POST request to the `/reload` endpoint with a JSON payload containing `{\"zero_downtime\": True}`. The expected behavior is that the server processes this request and responds with a status code of `200`. The `publisher` is likely a mock object that simulates the behavior of a message broker or event dispatcher, which is expected to send a specific message when the reload action is triggered.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The `publisher` is mocked to track calls to its `send` method, allowing the test to verify interactions without needing a real implementation.\n- **Assertion**: The test uses assertions to validate both the response status and the call to the `send` method, ensuring that the application behaves as expected under the specified conditions.\n- **Integration Testing**: Although this is a unit test, it effectively tests the integration between the HTTP client and the application\u2019s reload functionality, ensuring that the components work together correctly."
    },
    {
      "name": "test_run_inspector_shutdown",
      "module": "test_inspector",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_inspector.py",
      "line_number": 97,
      "end_line_number": 100,
      "source_code": "def test_run_inspector_shutdown(publisher, http_client):\n    _, response = http_client.post(\"/shutdown\")\n    assert response.status == 200\n    publisher.send.assert_called_once_with(\"__TERMINATE__\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "publisher",
        "http_client"
      ],
      "imports": [
        "datetime.datetime",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.error.URLError",
        "pytest",
        "sanic_testing.TestManager",
        "sanic.cli.inspector_client.InspectorClient",
        "sanic.helpers.Default",
        "sanic.log.Colors",
        "sanic.worker.inspector.Inspector",
        "ujson.dumps",
        "json.dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "http_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_run_inspector_shutdown` unit test is designed to verify the correct behavior of the shutdown endpoint in a Sanic web application. Specifically, it checks that when a POST request is made to the `/shutdown` route, the application responds with a status code of 200 and that a termination signal is sent to the publisher.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the application correctly handles a shutdown request by confirming two key outcomes: \n1. The HTTP response status is 200, indicating a successful operation.\n2. The `send` method of the `publisher` mock object is called exactly once with the argument `\"__TERMINATE__\"`, which signifies that the application is instructed to terminate.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `http_client.post` method, which simulates sending a POST request to the `/shutdown` endpoint. The method is expected to return a response object, from which the status code can be extracted. The relevant part of the code that handles the shutdown logic is not shown, but it is implied that the application is set up to respond to this endpoint and perform the necessary actions (like sending a termination signal) when the request is received.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test uses a mock object for `publisher` to verify interactions without needing a real publisher implementation. This allows for isolated testing of the shutdown behavior.\n- **Assertion**: The test employs assertions to validate both the response status and the call to the publisher, ensuring that the expected outcomes are met.\n- **Integration Testing**: Although it is a unit test, it also serves as a form of integration testing by checking the interaction between the HTTP client and the application\u2019s shutdown logic."
    },
    {
      "name": "test_run_inspector_scale",
      "module": "test_inspector",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_inspector.py",
      "line_number": 103,
      "end_line_number": 106,
      "source_code": "def test_run_inspector_scale(publisher, http_client):\n    _, response = http_client.post(\"/scale\", json={\"replicas\": 4})\n    assert response.status == 200\n    publisher.send.assert_called_once_with(\"__SCALE__:4\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "publisher",
        "http_client"
      ],
      "imports": [
        "datetime.datetime",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.error.URLError",
        "pytest",
        "sanic_testing.TestManager",
        "sanic.cli.inspector_client.InspectorClient",
        "sanic.helpers.Default",
        "sanic.log.Colors",
        "sanic.worker.inspector.Inspector",
        "ujson.dumps",
        "json.dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "http_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_run_inspector_scale` unit test is designed to verify the functionality of the `/scale` endpoint in the application, ensuring that it correctly processes a request to scale the number of replicas and that the appropriate message is sent to the publisher.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks two main behaviors: first, it confirms that a POST request to the `/scale` endpoint with a JSON payload specifying `{\"replicas\": 4}` returns a successful HTTP status code of 200. Second, it verifies that the `publisher` object sends the correct message, `__SCALE__:4`, indicating that the scaling action has been triggered with the specified number of replicas.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `http_client.post` method, which simulates sending a POST request to the `/scale` endpoint. The method is expected to return a response object, from which the status code can be extracted. The `publisher.send` method is also tested to ensure it is called with the correct argument, confirming that the scaling action is communicated properly.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the Arrange-Act-Assert (AAA) pattern, where:\n- **Arrange**: The test sets up the necessary conditions by preparing the request data.\n- **Act**: It performs the action by invoking the `http_client.post` method.\n- **Assert**: Finally, it checks the response status and verifies that the `publisher.send` method was called with the expected argument. This structured approach enhances readability and maintainability of the test. Additionally, the use of mocking (with `publisher`) allows for isolation of the test, ensuring that it focuses solely on the behavior of the endpoint without side effects from the actual publishing mechanism."
    },
    {
      "name": "test_run_inspector_arbitrary",
      "module": "test_inspector",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_inspector.py",
      "line_number": 109,
      "end_line_number": 112,
      "source_code": "def test_run_inspector_arbitrary(http_client):\n    _, response = http_client.post(\"/foo\", json={\"bar\": 99})\n    assert response.status == 200\n    assert response.json == {\"meta\": {\"action\": \"foo\"}, \"result\": \"bar is 99\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "http_client"
      ],
      "imports": [
        "datetime.datetime",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.error.URLError",
        "pytest",
        "sanic_testing.TestManager",
        "sanic.cli.inspector_client.InspectorClient",
        "sanic.helpers.Default",
        "sanic.log.Colors",
        "sanic.worker.inspector.Inspector",
        "ujson.dumps",
        "json.dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.json == {'meta': {'action': 'foo'}, 'result': 'bar is 99'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "http_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_run_inspector_arbitrary` unit test is designed to verify that the HTTP POST request to the `/foo` endpoint correctly processes the input JSON data and returns the expected response. It ensures that the application behaves as intended when receiving specific input.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks two key aspects of the response from the server: \n1. The HTTP status code is `200`, indicating a successful request.\n2. The JSON response body matches the expected structure, specifically that it contains a `meta` field with an `action` of `\"foo\"` and a `result` field that correctly reflects the input data, stating `\"bar is 99\"`.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `http_client.post` method, which simulates sending a POST request to the server. The method is expected to handle the request to the `/foo` endpoint, process the incoming JSON payload (`{\"bar\": 99}`), and return a response object. The response object should have a `status` attribute for the HTTP status code and a `json` method that returns the parsed JSON response body.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertion**: The test uses assertions to validate the response's status and content, which is a common practice in unit testing to ensure that the actual output matches the expected output.\n- **Mocking**: Although not explicitly shown in this test, the `http_client` is likely a mock or a fixture that simulates the behavior of an actual HTTP client, allowing for isolated testing of the endpoint without needing a live server.\n- **JSON Handling**: The test checks the JSON response format, demonstrating the importance of validating structured data in API responses."
    },
    {
      "name": "test_state_to_json",
      "module": "test_inspector",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_inspector.py",
      "line_number": 115,
      "end_line_number": 128,
      "source_code": "def test_state_to_json():\n    now = datetime.now()\n    now_iso = now.isoformat()\n    app_info = {\"app\": \"hello\"}\n    worker_state = {\"Test\": {\"now\": now, \"nested\": {\"foo\": now}}}\n    inspector = Inspector(\n        Mock(), app_info, worker_state, \"\", 0, \"\", Default(), Default()\n    )\n    state = inspector._state_to_json()\n\n    assert state == {\n        \"info\": app_info,\n        \"workers\": {\"Test\": {\"now\": now_iso, \"nested\": {\"foo\": now_iso}}},\n    }",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.error.URLError",
        "pytest",
        "sanic_testing.TestManager",
        "sanic.cli.inspector_client.InspectorClient",
        "sanic.helpers.Default",
        "sanic.log.Colors",
        "sanic.worker.inspector.Inspector",
        "ujson.dumps",
        "json.dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert state == {'info': app_info, 'workers': {'Test': {'now': now_iso, 'nested': {'foo': now_iso}}}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_state_to_json` function is designed to verify the correct serialization of the internal state of an `Inspector` object into a JSON-compatible format. It ensures that the state representation accurately reflects the current state of the application and its workers.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `Inspector` class's method `_state_to_json` correctly converts the `worker_state` and `app_info` into a structured JSON format. It verifies that the timestamps in the state are converted to ISO 8601 string format, ensuring consistency and correctness in the output.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `Inspector` class, which is initialized with various parameters, including `app_info` and `worker_state`. The `worker_state` contains a timestamp (`now`) and a nested structure. The `_state_to_json` method is called to generate a JSON representation of the state. The test then asserts that the output matches the expected structure, where the timestamps are formatted as ISO strings.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test uses `Mock()` to create a mock object for the `Inspector` initialization, allowing for isolation of the test from external dependencies.\n- **Datetime Handling**: The test captures the current time using `datetime.now()` and checks that it is correctly formatted in the output, demonstrating an understanding of how to handle dynamic data in tests.\n- **Assertions**: The test employs a straightforward assertion to compare the actual output of `_state_to_json` with the expected dictionary, ensuring clarity and simplicity in verifying correctness."
    },
    {
      "name": "test_run_inspector_authentication",
      "module": "test_inspector",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_inspector.py",
      "line_number": 131,
      "end_line_number": 141,
      "source_code": "def test_run_inspector_authentication():\n    inspector = Inspector(\n        Mock(), {}, {}, \"\", 0, \"super-secret\", Default(), Default()\n    )(False)\n    manager = TestManager(inspector.app)\n    _, response = manager.test_client.get(\"/\")\n    assert response.status == 401\n    _, response = manager.test_client.get(\n        \"/\", headers={\"Authorization\": \"Bearer super-secret\"}\n    )\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.error.URLError",
        "pytest",
        "sanic_testing.TestManager",
        "sanic.cli.inspector_client.InspectorClient",
        "sanic.helpers.Default",
        "sanic.log.Colors",
        "sanic.worker.inspector.Inspector",
        "ujson.dumps",
        "json.dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 401",
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "manager.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "manager.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_run_inspector_authentication` test is designed to verify the authentication mechanism of the `Inspector` class within the Sanic application. It checks that unauthenticated requests are denied access (returning a 401 status) and that authenticated requests with a valid token are granted access (returning a 200 status).\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically verifies two behaviors: \n1. When a request is made to the root endpoint (\"/\") without an authorization token, the response status should be 401 (Unauthorized).\n2. When a request is made to the same endpoint with a valid Bearer token (\"super-secret\"), the response status should be 200 (OK), indicating successful authentication.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `Inspector` class, which is initialized with various parameters, including a secret token. The `TestManager` is then used to create a test client that simulates HTTP requests to the application. The test client makes two GET requests to the root endpoint: the first without any authorization headers and the second with a Bearer token. The expected behavior is defined by the assertions that check the response status codes.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward unit testing pattern where assertions are used to validate expected outcomes against actual results. It utilizes mocking (with `Mock()`) to isolate the `Inspector` class from its dependencies, ensuring that the test focuses solely on the authentication logic. The use of a test client to simulate HTTP requests is a common technique in testing web applications, allowing for easy verification of endpoint behavior."
    },
    {
      "name": "test_reload_send",
      "module": "test_reloader",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
      "line_number": 54,
      "end_line_number": 58,
      "source_code": "def test_reload_send():\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, set(), Mock())\n    reloader.reload(\"foobar\")\n    publisher.send.assert_called_once_with(\"__ALL_PROCESSES__:foobar\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "re",
        "signal",
        "threading",
        "asyncio.Event",
        "logging.DEBUG",
        "pathlib.Path",
        "time.sleep",
        "unittest.mock.Mock",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.constants.ProcessState",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.process.WorkerProcess",
        "sanic.worker.reloader.Reloader"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_reload_send` function is designed to verify that the `Reloader` class correctly sends a message to a publisher when the `reload` method is called with a specific argument. This ensures that the reloading mechanism communicates appropriately with other processes.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when the `reload` method is invoked with the argument `\"foobar\"`, the `send` method of the `publisher` mock is called exactly once with the expected message format `\"__ALL_PROCESSES__:foobar\"`. This confirms that the reloader is functioning as intended in notifying other processes about the reload event.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `Reloader` class, which is initialized with a `publisher`, a reload interval, a set of directories to monitor, and an application loader. The `reload` method is called with the string `\"foobar\"`, which triggers the `send` method of the `publisher` mock. The assertion checks that this method was called with the correct argument, ensuring that the reloader's communication logic is working properly.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of mocking through the `Mock` class from the `unittest.mock` module. This allows the test to isolate the behavior of the `Reloader` class without needing a real publisher implementation. The use of `assert_called_once_with` is a specific assertion technique that verifies both the call count and the arguments of the call, ensuring precise validation of the expected behavior."
    },
    {
      "name": "test_iter_files",
      "module": "test_reloader",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
      "line_number": 61,
      "end_line_number": 71,
      "source_code": "def test_iter_files():\n    reloader = Reloader(Mock(), 0.1, set(), Mock())\n    len_python_files = len(list(reloader.files()))\n    assert len_python_files > 0\n\n    static_dir = Path(__file__).parent.parent / \"static\"\n    len_static_files = len(list(static_dir.glob(\"**/*\")))\n    reloader = Reloader(Mock(), 0.1, set({static_dir}), Mock())\n    len_total_files = len(list(reloader.files()))\n    assert len_static_files > 0\n    assert len_total_files == len_python_files + len_static_files",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "re",
        "signal",
        "threading",
        "asyncio.Event",
        "logging.DEBUG",
        "pathlib.Path",
        "time.sleep",
        "unittest.mock.Mock",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.constants.ProcessState",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.process.WorkerProcess",
        "sanic.worker.reloader.Reloader"
      ],
      "fixtures": [],
      "assertions": [
        "assert len_python_files > 0",
        "assert len_static_files > 0",
        "assert len_total_files == len_python_files + len_static_files"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_iter_files` function is designed to verify the functionality of the `Reloader` class in the Sanic framework, specifically ensuring that it correctly identifies and counts Python files and static files in the specified directories.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the `Reloader` can successfully detect Python files and static files, asserting that:\n1. There are Python files present in the initial directory.\n2. There are static files present in the designated static directory.\n3. The total number of files detected by the `Reloader` matches the expected count, which is the sum of Python files and static files.\n\n**Code Being Tested and How It Works**:  \nThe test initializes a `Reloader` instance with a mock object and a specified delay. It first counts the number of Python files by calling `reloader.files()`. Then, it sets a static directory path and counts the files within that directory using `glob`. A second `Reloader` instance is created that includes the static directory, and the total number of files is counted again. The assertions ensure that the counts are as expected.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test uses `Mock()` to simulate dependencies of the `Reloader`, allowing for isolated testing without relying on actual file system interactions.\n- **Assertions**: Multiple assertions are employed to validate the expected outcomes, ensuring that the test fails if any condition is not met.\n- **Path Manipulation**: The test uses `Path` from the `pathlib` module to handle file paths, promoting better readability and cross-platform compatibility."
    },
    {
      "name": "test_default_reload_shutdown_order",
      "module": "test_reloader",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
      "line_number": 97,
      "end_line_number": 128,
      "source_code": "def test_default_reload_shutdown_order(monkeypatch, caplog, order, expected):\n    current_process = Mock()\n    worker_process = WorkerProcess(\n        lambda **_: current_process,\n        \"Test\",\n        \"TST\",\n        lambda **_: ...,\n        {},\n        {},\n    )\n\n    def start(self):\n        worker_process.set_state(ProcessState.ACKED)\n        self._target()\n\n    orig = threading.Thread.start\n    monkeypatch.setattr(threading.Thread, \"start\", start)\n\n    with caplog.at_level(DEBUG):\n        worker_process.restart(restart_order=order)\n\n    ansi = re.compile(r\"\\x1B(?:[@-Z\\\\-_]|\\[[0-?]*[ -/]*[@-~])\")\n\n    def clean(msg: str):\n        msg, _ = ansi.sub(\"\", msg).split(\":\", 1)\n        return msg\n\n    debug = [clean(record[2]) for record in caplog.record_tuples]\n    assert debug == expected\n    current_process.start.assert_called_once()\n    current_process.terminate.assert_called_once()\n    monkeypatch.setattr(threading.Thread, \"start\", orig)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('order,expected', ((RestartOrder.SHUTDOWN_FIRST, ['Restarting a process', 'Begin restart termination', 'Starting a process']), (RestartOrder.STARTUP_FIRST, ['Restarting a process', 'Starting a process', 'Begin restart termination', 'Waiting for process to be acked', 'Process acked. Terminating'])))"
      ],
      "arguments": [
        "monkeypatch",
        "caplog",
        "order",
        "expected"
      ],
      "imports": [
        "re",
        "signal",
        "threading",
        "asyncio.Event",
        "logging.DEBUG",
        "pathlib.Path",
        "time.sleep",
        "unittest.mock.Mock",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.constants.ProcessState",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.process.WorkerProcess",
        "sanic.worker.reloader.Reloader"
      ],
      "fixtures": [],
      "assertions": [
        "assert debug == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "clean",
          "body": "def clean(msg: str):\n    (msg, _) = ansi.sub('', msg).split(':', 1)\n    return msg"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_default_reload_shutdown_order` unit test is designed to verify the shutdown order of worker processes in a Sanic application when a reload is triggered. It ensures that the processes are started and terminated in the expected sequence based on the provided restart order.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the `current_process` is started and terminated exactly once during the reload process. It also verifies that the log messages generated during this process match the expected output, which reflects the correct order of operations.\n\n**Code Being Tested and How It Works**:  \nThe test creates a mock `current_process` and a `WorkerProcess` instance. It overrides the `start` method of the `threading.Thread` class to simulate the behavior of the worker process. The `worker_process.restart` method is called with a specified `restart_order`, which triggers the process's state changes. The test captures log messages at the DEBUG level and cleans them to remove ANSI escape codes before comparing them to the expected output.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test uses the `Mock` class to create a mock process, allowing for controlled testing without actual process management.\n- **Monkeypatching**: The `monkeypatch` fixture is used to temporarily replace the `start` method of `threading.Thread`, enabling the simulation of process behavior.\n- **Log Capture**: The `caplog` fixture captures log messages during the test execution, allowing for verification of the output against expected values.\n- **Regular Expressions**: A regex pattern is used to clean log messages by removing ANSI escape sequences, ensuring that the comparison focuses on the relevant content."
    },
    {
      "name": "test_reload_delayed",
      "module": "test_reloader",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
      "line_number": 131,
      "end_line_number": 155,
      "source_code": "def test_reload_delayed(monkeypatch):\n    WorkerProcess.THRESHOLD = 1\n\n    current_process = Mock()\n    worker_process = WorkerProcess(\n        lambda **_: current_process,\n        \"Test\",\n        \"TST\",\n        lambda **_: ...,\n        {},\n        {},\n    )\n\n    def start(self):\n        sleep(0.2)\n        self._target()\n\n    orig = threading.Thread.start\n    monkeypatch.setattr(threading.Thread, \"start\", start)\n\n    message = \"Worker Test failed to come ack within 0.1 seconds\"\n    with pytest.raises(TimeoutError, match=message):\n        worker_process.restart(restart_order=RestartOrder.STARTUP_FIRST)\n\n    monkeypatch.setattr(threading.Thread, \"start\", orig)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "re",
        "signal",
        "threading",
        "asyncio.Event",
        "logging.DEBUG",
        "pathlib.Path",
        "time.sleep",
        "unittest.mock.Mock",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.constants.ProcessState",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.process.WorkerProcess",
        "sanic.worker.reloader.Reloader"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_reload_delayed` unit test is designed to verify the behavior of the `WorkerProcess` class when it attempts to restart but does not receive an acknowledgment (ack) from the worker within a specified timeout period. This ensures that the system correctly raises a `TimeoutError` when the worker fails to respond in a timely manner.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that a `TimeoutError` is raised with the expected message when the worker process does not acknowledge the restart request within the defined threshold. This simulates a scenario where the worker is delayed in starting, allowing the test to confirm that the system handles such delays appropriately.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `WorkerProcess` class, particularly its `restart` method. The test sets up a mock worker process and modifies the behavior of the `threading.Thread.start` method to introduce a delay (0.2 seconds) before calling the target function. The `restart` method is then invoked with a specific restart order, and the test expects a `TimeoutError` to be raised due to the delay exceeding the threshold (0.1 seconds).\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Monkeypatching**: The test uses the `monkeypatch` fixture from pytest to temporarily replace the `start` method of `threading.Thread` with a custom function that introduces a delay. This allows for controlled testing of the worker's response time without modifying the actual implementation.\n- **Mocking**: The `Mock` class is used to create a mock object for the current process, allowing the test to focus on the behavior of the `WorkerProcess` without needing a real process.\n- **Exception Assertion**: The test uses `pytest.raises` to assert that a `TimeoutError` is raised, verifying that the error handling in the `restart` method works as intended when the worker does not respond in time."
    },
    {
      "name": "test_reloader_triggers_start_stop_listeners",
      "module": "test_reloader",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
      "line_number": 158,
      "end_line_number": 174,
      "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "app_loader"
      ],
      "imports": [
        "re",
        "signal",
        "threading",
        "asyncio.Event",
        "logging.DEBUG",
        "pathlib.Path",
        "time.sleep",
        "unittest.mock.Mock",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.constants.ProcessState",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.process.WorkerProcess",
        "sanic.worker.reloader.Reloader"
      ],
      "fixtures": [],
      "assertions": [
        "assert results == ['reload_process_start', 'reload_process_stop']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "run_reloader",
          "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_reloader_triggers_start_stop_listeners` test is to verify that the Sanic application's reload process correctly triggers the associated start and stop listeners when the reloader is executed. This ensures that the application can respond appropriately to reload events, which is crucial for maintaining state and functionality during development.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `reload_process_start` and `reload_process_stop` listeners are called in the correct order when the reloader is run. The expected behavior is that the results list should contain the strings \"reload_process_start\" and \"reload_process_stop\" in that exact sequence, indicating that both listeners were triggered as intended.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `run_reloader` function, which is responsible for executing the reloader logic. The test sets up two listeners using decorators provided by the Sanic framework: one for the start event and one for the stop event. When `run_reloader(reloader)` is called, it simulates the reloading process, which should invoke the registered listeners. The test then asserts that the `results` list contains the expected output, confirming that the listeners were triggered correctly.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable testing patterns:\n- **Listener Registration**: It uses decorators to register functions as listeners for specific events, showcasing a common pattern in event-driven programming.\n- **Mocking**: The `Mock()` object is used to create a mock publisher for the reloader, allowing the test to focus on the listener behavior without needing a real implementation.\n- **Assertions**: The test uses assertions to validate the expected outcomes, ensuring that the behavior of the application aligns with the defined requirements.\n- **Separation of Concerns**: By isolating the listener logic from the reloader execution, the test maintains a clear focus on verifying the interaction between these components."
    },
    {
      "name": "test_not_triggered",
      "module": "test_reloader",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
      "line_number": 177,
      "end_line_number": 183,
      "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app_loader"
      ],
      "imports": [
        "re",
        "signal",
        "threading",
        "asyncio.Event",
        "logging.DEBUG",
        "pathlib.Path",
        "time.sleep",
        "unittest.mock.Mock",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.constants.ProcessState",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.process.WorkerProcess",
        "sanic.worker.reloader.Reloader"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "run_reloader",
          "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_not_triggered` unit test is designed to verify that the `Reloader` class does not trigger any reload events when no file changes are detected in the specified reload directory.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `send` method of the `publisher` mock object is not called, indicating that no reload event was published during the execution of the reloader. This ensures that the reloader behaves correctly when there are no changes to the monitored files.\n\n**Code Being Tested and How It Works**:  \nThe test creates a `Reloader` instance with a mock `publisher`, a specified interval (0.1 seconds), and a set containing a directory path (`reload_dir`). The `run_reloader` function is then called with this reloader instance. Inside the `Reloader` class, the `__call__` method continuously checks for file changes in the specified directory. If no changes are detected, the `send` method of the `publisher` should not be invoked, which is what the test asserts.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test uses the `Mock` class from the `unittest.mock` module to create a mock object for the `publisher`, allowing the test to verify interactions without requiring a real implementation.\n- **Path Handling**: The test constructs a path to a fake directory, simulating the environment where the reloader would operate.\n- **Assertions**: The test employs `assert_not_called()` to confirm that the `send` method was never invoked, providing a clear and direct assertion of the expected behavior."
    },
    {
      "name": "test_triggered",
      "module": "test_reloader",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
      "line_number": 186,
      "end_line_number": 210,
      "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app_loader"
      ],
      "imports": [
        "re",
        "signal",
        "threading",
        "asyncio.Event",
        "logging.DEBUG",
        "pathlib.Path",
        "time.sleep",
        "unittest.mock.Mock",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.constants.ProcessState",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.process.WorkerProcess",
        "sanic.worker.reloader.Reloader"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(paths) == 2",
        "assert call_arg.startswith('__ALL_PROCESSES__:')",
        "assert call_arg.count(',') == 1",
        "assert str(path) in call_arg"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "run_reloader",
          "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_triggered` function is designed to verify that the `Reloader` class correctly identifies specific files that have changed in a designated directory and triggers the appropriate reload mechanism. It ensures that the reloader behaves as expected when certain files are modified.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when the `Reloader` is invoked, it successfully detects changes to the files `server.py` and `sanic/app.py`, adds their paths to a set, and confirms that the publisher sends a notification with the correct format. It asserts that exactly two paths are detected and that the notification includes these paths.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `Reloader` class, specifically its ability to monitor file changes in a specified directory. The `check_file` function is a custom callback that determines if a file should be considered for reloading based on its name. The `run_reloader` function initiates the reloader, which continuously checks for file changes and triggers the reload process when changes are detected. The test uses a mock publisher to simulate the behavior of the actual publisher without side effects.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test uses the `Mock` class to create a mock publisher, allowing the test to verify interactions without needing a real publisher.\n- **Assertions**: Multiple assertions are employed to validate the expected outcomes, including checking the number of detected paths and the format of the notification sent by the publisher.\n- **Set for Uniqueness**: A set is used to store file paths, ensuring that each path is unique and simplifying the verification of the number of detected files."
    },
    {
      "name": "test_reloader_triggers_reload_listeners",
      "module": "test_reloader",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
      "line_number": 213,
      "end_line_number": 237,
      "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "app_loader"
      ],
      "imports": [
        "re",
        "signal",
        "threading",
        "asyncio.Event",
        "logging.DEBUG",
        "pathlib.Path",
        "time.sleep",
        "unittest.mock.Mock",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.constants.ProcessState",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.process.WorkerProcess",
        "sanic.worker.reloader.Reloader"
      ],
      "fixtures": [],
      "assertions": [
        "assert before.is_set()",
        "assert after.is_set()",
        "assert len(changed_files) > 0",
        "assert changed_files == set(reloader.files())"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "run_reloader",
          "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_reloader_triggers_reload_listeners` test is to verify that the Sanic application's reloader correctly triggers the associated reload listeners before and after a file change is detected. This ensures that the application responds appropriately to changes in the codebase, which is crucial for development environments where live reloading is expected.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. The `before_reload_trigger` listener is activated before the reloader processes any file changes.\n2. The `after_reload_trigger` listener is activated after the reloader has detected changes.\n3. At least one file change is detected and recorded in the `changed_files` set.\n4. The set of changed files matches the files that the reloader is monitoring.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `Reloader` class, which monitors specified directories for changes to Python files. The `run_reloader` function initiates the reloader, which runs in a loop checking for file modifications. The `check_file` function determines if a file has changed based on its modification time. The test sets up two asynchronous listeners (`before_reload_trigger` and `after_reload_trigger`) that set events when triggered. The assertions at the end of the test confirm that these events were set and that file changes were detected.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Event-Driven Testing**: The test utilizes asynchronous event listeners to simulate the behavior of the application during a reload, allowing for a more realistic testing scenario.\n- **Mocking**: The `Mock()` object is used to simulate the publisher for the reloader, isolating the test from external dependencies.\n- **Assertions**: The test employs multiple assertions to validate the state of the application after the reloader runs, ensuring comprehensive coverage of the expected behavior.\n- **Setup and Teardown**: The use of fixtures (`app` and `app_loader`) provides a clean setup for the test environment, ensuring that each test runs in isolation without side effects from other tests."
    },
    {
      "name": "test_check_file",
      "module": "test_reloader",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
      "line_number": 240,
      "end_line_number": 248,
      "source_code": "def test_check_file(tmp_path):\n    current = tmp_path / \"testing.txt\"\n    current.touch()\n    mtimes = {}\n    assert Reloader.check_file(current, mtimes) is False\n    assert len(mtimes) == 1\n    assert Reloader.check_file(current, mtimes) is False\n    mtimes[current] = mtimes[current] - 1\n    assert Reloader.check_file(current, mtimes) is True",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmp_path"
      ],
      "imports": [
        "re",
        "signal",
        "threading",
        "asyncio.Event",
        "logging.DEBUG",
        "pathlib.Path",
        "time.sleep",
        "unittest.mock.Mock",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.constants.ProcessState",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.process.WorkerProcess",
        "sanic.worker.reloader.Reloader"
      ],
      "fixtures": [],
      "assertions": [
        "assert Reloader.check_file(current, mtimes) is False",
        "assert len(mtimes) == 1",
        "assert Reloader.check_file(current, mtimes) is False",
        "assert Reloader.check_file(current, mtimes) is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "Reloader.check_file",
          "body": "def check_file(filename, mtimes):\n    if isinstance(filename, Path) and filename.name == 'server.py' or (isinstance(filename, str) and 'sanic/app.py' in filename):\n        paths.add(str(filename))\n        return True\n    return False"
        },
        {
          "name": "Reloader.check_file",
          "body": "def check_file(filename, mtimes):\n    if isinstance(filename, Path) and filename.name == 'server.py' or (isinstance(filename, str) and 'sanic/app.py' in filename):\n        paths.add(str(filename))\n        return True\n    return False"
        },
        {
          "name": "Reloader.check_file",
          "body": "def check_file(filename, mtimes):\n    if isinstance(filename, Path) and filename.name == 'server.py' or (isinstance(filename, str) and 'sanic/app.py' in filename):\n        paths.add(str(filename))\n        return True\n    return False"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_check_file` function is designed to verify the behavior of the `Reloader.check_file` method in the Sanic framework. Specifically, it checks how the method responds to changes in file modification times and whether it correctly updates the `mtimes` dictionary that tracks these changes.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies that the `check_file` method returns `False` when a file is first checked and has not been modified since its last recorded time. It also checks that the method returns `True` when the file's modification time has changed, indicating that a reload is necessary. Additionally, it ensures that the `mtimes` dictionary is updated correctly to reflect the file's state.\n\n**Code Being Tested and How It Works**:  \nThe `Reloader.check_file` method checks if a given file (identified by `filename`) has been modified by comparing its current modification time with a previously recorded time stored in the `mtimes` dictionary. If the file is new (not in `mtimes`), it adds the current modification time. If the file has been modified (current time is greater than the recorded time), it updates the time and indicates that a reload is needed by returning `True`. If the file has not been modified, it returns `False`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of a temporary file created with `tmp_path`, which is a fixture provided by pytest for creating temporary directories and files. This ensures that the test does not affect the actual filesystem. The assertions are straightforward, checking both the return values of the `check_file` method and the state of the `mtimes` dictionary, which is a common practice in unit testing to validate both output and side effects. The test also demonstrates the use of state manipulation by directly modifying the `mtimes` dictionary to simulate file modification scenarios."
    },
    {
      "name": "test_has_multiplexer_default",
      "module": "test_multiplexer",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_multiplexer.py",
      "line_number": 42,
      "end_line_number": 58,
      "source_code": "def test_has_multiplexer_default(app: Sanic):\n    event = Event()\n\n    @app.main_process_start\n    async def setup(app, _):\n        app.shared_ctx.event = event\n\n    @app.after_server_start\n    def stop(app):\n        if hasattr(app, \"m\") and isinstance(app.m, WorkerMultiplexer):\n            app.shared_ctx.event.set()\n        app.stop()\n\n    with use_context(\"fork\"):\n        app.run()\n\n    assert event.is_set()",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(sys.platform not in ('linux', 'darwin'), reason='This test requires fork context')"
      ],
      "arguments": [
        "app"
      ],
      "imports": [
        "sys",
        "multiprocessing.Event",
        "os.environ",
        "os.getpid",
        "typing.Any",
        "typing.Dict",
        "typing.Type",
        "typing.Union",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.compat.use_context",
        "sanic.worker.multiplexer.WorkerMultiplexer",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [
        "assert event.is_set()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        },
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_has_multiplexer_default` test is designed to verify that the Sanic application correctly initializes and utilizes a `WorkerMultiplexer` when running in a multi-process environment. Specifically, it checks that the application can signal the completion of its startup process by setting an event, which indicates that the multiplexer is active.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when the Sanic application starts in a forked context, the `WorkerMultiplexer` is properly instantiated and that the event signaling mechanism works as expected. The test asserts that the event is set after the server has started, confirming that the application has recognized the multiplexer.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `app.run()` method, which starts the Sanic server. It sets up two event listeners: one for the `main_process_start` event, which initializes a shared event object, and another for the `after_server_start` event, which checks if the multiplexer is present and sets the event accordingly. The `app.stop()` method is called to cleanly shut down the server after the event is set. The assertion `assert event.is_set()` checks that the event was indeed triggered, indicating that the multiplexer was active during the server's operation.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of asynchronous event listeners to manage the server's lifecycle, showcasing a common pattern in asynchronous programming. It also utilizes the `use_context(\"fork\")` context manager to ensure that the test runs in a forked process, which is essential for testing multi-process behavior. Additionally, the test uses the `pytest.mark.skipif` decorator to conditionally skip the test on unsupported platforms, ensuring that it only runs in appropriate environments (Linux and macOS). This demonstrates good practice in writing robust and platform-aware tests."
    },
    {
      "name": "test_not_have_multiplexer_single",
      "module": "test_multiplexer",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_multiplexer.py",
      "line_number": 61,
      "end_line_number": 76,
      "source_code": "def test_not_have_multiplexer_single(app: Sanic):\n    event = Event()\n\n    @app.main_process_start\n    async def setup(app, _):\n        app.shared_ctx.event = event\n\n    @app.after_server_start\n    def stop(app):\n        if hasattr(app, \"m\") and isinstance(app.m, WorkerMultiplexer):\n            app.shared_ctx.event.set()\n        app.stop()\n\n    app.run(single_process=True)\n\n    assert not event.is_set()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "sys",
        "multiprocessing.Event",
        "os.environ",
        "os.getpid",
        "typing.Any",
        "typing.Dict",
        "typing.Type",
        "typing.Union",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.compat.use_context",
        "sanic.worker.multiplexer.WorkerMultiplexer",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [
        "assert not event.is_set()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_not_have_multiplexer_single` test is to verify that when the Sanic application is run in single-process mode, the `WorkerMultiplexer` is not instantiated, and consequently, the event signaling mechanism does not trigger.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `event` object remains unset (i.e., `event.is_set()` returns `False`) after the application has started and stopped. This indicates that the application did not enter a multiplexer state, which would normally set the event.\n\n**Code Being Tested and How It Works**:  \nThe test involves the `app.run(single_process=True)` method, which starts the Sanic application in a single process. The `@app.main_process_start` decorator is used to set up an event in the shared context of the application, while the `@app.after_server_start` decorator checks if the application has a `WorkerMultiplexer` instance. If it does, it sets the event and stops the application. Since the test runs in single-process mode, the multiplexer should not be present, and thus the event should not be set.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of decorators to register asynchronous setup and teardown functions, which is a common pattern in testing frameworks like pytest. It also utilizes the `Event` class from the `multiprocessing` module to manage state across the application lifecycle. The assertion at the end of the test confirms the expected behavior, ensuring that the application behaves correctly in single-process mode without a multiplexer."
    },
    {
      "name": "test_ack",
      "module": "test_multiplexer",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_multiplexer.py",
      "line_number": 79,
      "end_line_number": 82,
      "source_code": "def test_ack(worker_state: Dict[str, Any], m: WorkerMultiplexer):\n    worker_state[\"Test\"] = {\"foo\": \"bar\"}\n    m.ack()\n    assert worker_state[\"Test\"] == {\"foo\": \"bar\", \"state\": \"ACKED\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "worker_state",
        "m"
      ],
      "imports": [
        "sys",
        "multiprocessing.Event",
        "os.environ",
        "os.getpid",
        "typing.Any",
        "typing.Dict",
        "typing.Type",
        "typing.Union",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.compat.use_context",
        "sanic.worker.multiplexer.WorkerMultiplexer",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [
        "assert worker_state['Test'] == {'foo': 'bar', 'state': 'ACKED'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_ack` function is designed to verify that the `ack` method of the `WorkerMultiplexer` class correctly updates the worker's state in the `worker_state` dictionary to indicate that the worker is ready (ACKED). This ensures that the state management functionality of the multiplexer is working as intended.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that after calling the `ack` method, the `worker_state` dictionary for the key \"Test\" is updated to include a new key-value pair: `\"state\": \"ACKED\"`. This confirms that the acknowledgment process modifies the state correctly, reflecting the worker's readiness.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `ack` method of the `WorkerMultiplexer` class. When `ack` is called, it logs a debug message and updates the internal state of the worker by adding or modifying the entry for the worker's name in the `_state` attribute (which is an instance of `WorkerState`). The method sets the state to \"ACKED\" by merging the existing state with the new state information.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern, where the expected state of `worker_state` is compared against the actual state after invoking the `ack` method. It uses a dictionary comparison to verify that the state has been updated correctly. This pattern is common in unit tests, as it allows for clear and concise validation of state changes resulting from method calls. Additionally, the use of fixtures (like `worker_state` and `m`) suggests that the test is part of a larger test suite, likely utilizing pytest for setup and teardown of test environments."
    },
    {
      "name": "test_restart_self",
      "module": "test_multiplexer",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_multiplexer.py",
      "line_number": 85,
      "end_line_number": 87,
      "source_code": "def test_restart_self(monitor_publisher: Mock, m: WorkerMultiplexer):\n    m.restart()\n    monitor_publisher.send.assert_called_once_with(\"Test:\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monitor_publisher",
        "m"
      ],
      "imports": [
        "sys",
        "multiprocessing.Event",
        "os.environ",
        "os.getpid",
        "typing.Any",
        "typing.Dict",
        "typing.Type",
        "typing.Union",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.compat.use_context",
        "sanic.worker.multiplexer.WorkerMultiplexer",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_restart_self` function is designed to verify that the `restart` method of the `WorkerMultiplexer` class correctly triggers a message to be sent to the `monitor_publisher` when called without any parameters.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when the `restart` method is invoked, the `monitor_publisher` sends a message formatted as \"Test:\". This ensures that the expected communication occurs between the worker multiplexer and the monitoring system, confirming that the restart action is properly acknowledged.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `restart` method of the `WorkerMultiplexer` class. When `m.restart()` is called, it is expected to invoke the `send` method on the `monitor_publisher` mock object with the argument \"Test:\". The test asserts that this interaction occurs exactly once, indicating that the restart process is being communicated correctly.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of mocking (via `Mock`) to simulate the `monitor_publisher` object, allowing for verification of interactions without requiring the actual implementation of the publisher. This is a common pattern in unit testing to isolate the unit of work (in this case, the `restart` method) and focus on its behavior. The use of `assert_called_once_with` is a specific assertion technique that checks both the number of calls and the parameters of the call, ensuring precise validation of the expected behavior."
    },
    {
      "name": "test_restart_foo",
      "module": "test_multiplexer",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_multiplexer.py",
      "line_number": 90,
      "end_line_number": 92,
      "source_code": "def test_restart_foo(monitor_publisher: Mock, m: WorkerMultiplexer):\n    m.restart(\"foo\")\n    monitor_publisher.send.assert_called_once_with(\"foo:\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monitor_publisher",
        "m"
      ],
      "imports": [
        "sys",
        "multiprocessing.Event",
        "os.environ",
        "os.getpid",
        "typing.Any",
        "typing.Dict",
        "typing.Type",
        "typing.Union",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.compat.use_context",
        "sanic.worker.multiplexer.WorkerMultiplexer",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_restart_foo` unit test is designed to verify that the `restart` method of the `WorkerMultiplexer` class correctly triggers a message to be sent to the `monitor_publisher` when it is called with the argument `\"foo\"`.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when the `restart` method is invoked with the string `\"foo\"`, the `monitor_publisher` sends a message formatted as `\"foo:\"`. This ensures that the correct communication occurs between the worker multiplexer and the monitoring system.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `restart` method of the `WorkerMultiplexer` class. When `m.restart(\"foo\")` is called, it is expected to invoke the `send` method on the `monitor_publisher` mock object with the argument `\"foo:\"`. The assertion `monitor_publisher.send.assert_called_once_with(\"foo:\")` checks that this interaction occurred exactly once, confirming the expected behavior.\n\n**Notable Testing Patterns or Techniques Used**:  \nThis test employs the use of mocking (via `Mock`) to isolate the `WorkerMultiplexer` from the actual implementation of the `monitor_publisher`. This allows the test to focus solely on the interaction between these components without needing to verify the internal workings of the `monitor_publisher`. Additionally, the use of `assert_called_once_with` is a common pattern in unit tests to ensure that a specific method was called with the expected arguments, reinforcing the test's reliability and clarity."
    },
    {
      "name": "test_reload_alias",
      "module": "test_multiplexer",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_multiplexer.py",
      "line_number": 95,
      "end_line_number": 97,
      "source_code": "def test_reload_alias(monitor_publisher: Mock, m: WorkerMultiplexer):\n    m.reload()\n    monitor_publisher.send.assert_called_once_with(\"Test:\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monitor_publisher",
        "m"
      ],
      "imports": [
        "sys",
        "multiprocessing.Event",
        "os.environ",
        "os.getpid",
        "typing.Any",
        "typing.Dict",
        "typing.Type",
        "typing.Union",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.compat.use_context",
        "sanic.worker.multiplexer.WorkerMultiplexer",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_reload_alias` function is designed to verify that the `reload` method of the `WorkerMultiplexer` class correctly triggers a notification to the `monitor_publisher` with the expected message format.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when the `reload` method is called, it sends a message to the `monitor_publisher` indicating that a reload has occurred. The expected message is \"Test:\", which suggests that the reload operation is associated with a worker named \"Test\".\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `reload` method of the `WorkerMultiplexer` class. When `m.reload()` is invoked, it is expected to call the `send` method on the `monitor_publisher` mock object with the argument \"Test:\". The assertion `monitor_publisher.send.assert_called_once_with(\"Test:\")` confirms that this interaction occurs exactly once, ensuring that the method behaves as intended.\n\n**Notable Testing Patterns or Techniques Used**:  \nThis test employs the use of mocking (via `Mock`) to isolate the `WorkerMultiplexer` from its dependencies, allowing for focused testing of its behavior without requiring the actual implementation of the `monitor_publisher`. The use of `assert_called_once_with` is a common pattern in unit tests to verify that a specific method was called with the expected arguments, ensuring that the interaction between components is functioning correctly."
    },
    {
      "name": "test_terminate",
      "module": "test_multiplexer",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_multiplexer.py",
      "line_number": 100,
      "end_line_number": 102,
      "source_code": "def test_terminate(monitor_publisher: Mock, m: WorkerMultiplexer):\n    m.terminate()\n    monitor_publisher.send.assert_called_once_with(\"__TERMINATE__\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monitor_publisher",
        "m"
      ],
      "imports": [
        "sys",
        "multiprocessing.Event",
        "os.environ",
        "os.getpid",
        "typing.Any",
        "typing.Dict",
        "typing.Type",
        "typing.Union",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.compat.use_context",
        "sanic.worker.multiplexer.WorkerMultiplexer",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "m.terminate",
          "body": "def terminate(proc):\n    if flags:\n        proc.send_signal(CTRL_BREAK_EVENT)\n    else:\n        proc.terminate()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_terminate` function is designed to verify that the `terminate` method of the `WorkerMultiplexer` class correctly sends a termination signal to the monitor publisher when invoked.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when the `terminate` method is called, it triggers the `monitor_publisher` to send a message with the content `\"__TERMINATE__\"`. This ensures that the system's shutdown mechanism is properly communicated to the monitoring component.\n\n**Code Being Tested and How It Works**:  \nThe `terminate` method in the `WorkerMultiplexer` class is responsible for handling the termination of worker processes. It checks certain flags to determine whether to send a `CTRL_BREAK_EVENT` signal or to simply terminate the process. The test mocks the `monitor_publisher` to intercept calls to its `send` method, allowing the test to assert that the correct message is sent when `terminate` is called.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs mocking (using `Mock` from the `unittest.mock` module) to isolate the behavior of the `WorkerMultiplexer` from the actual implementation of the `monitor_publisher`. This allows for a focused test that verifies the interaction between components without requiring the full system to be operational. The use of `assert_called_once_with` is a common pattern in unit tests to ensure that a specific method is called exactly once with the expected arguments, reinforcing the test's reliability."
    },
    {
      "name": "test_scale",
      "module": "test_multiplexer",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_multiplexer.py",
      "line_number": 105,
      "end_line_number": 107,
      "source_code": "def test_scale(monitor_publisher: Mock, m: WorkerMultiplexer):\n    m.scale(99)\n    monitor_publisher.send.assert_called_once_with(\"__SCALE__:99\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monitor_publisher",
        "m"
      ],
      "imports": [
        "sys",
        "multiprocessing.Event",
        "os.environ",
        "os.getpid",
        "typing.Any",
        "typing.Dict",
        "typing.Type",
        "typing.Union",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.compat.use_context",
        "sanic.worker.multiplexer.WorkerMultiplexer",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_scale` function is designed to verify that the `scale` method of the `WorkerMultiplexer` class correctly triggers a message to be sent to the `monitor_publisher` with the expected scaling command.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when the `scale` method is called with an argument (in this case, `99`), the `monitor_publisher` sends a message formatted as `\"__SCALE__:99\"`. This ensures that the scaling operation is communicated properly to the monitoring system.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `scale` method of the `WorkerMultiplexer` class. When `m.scale(99)` is invoked, it is expected to perform an internal operation to adjust the number of worker processes to `99`. The test then asserts that the `send` method of the `monitor_publisher` mock object was called exactly once with the correct argument, confirming that the scaling action was communicated as intended.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of mocking (via `Mock`) to isolate the `WorkerMultiplexer` from its dependencies, specifically the `monitor_publisher`. This allows the test to focus solely on the behavior of the `scale` method without needing to involve the actual implementation of the `monitor_publisher`. Additionally, the use of `assert_called_once_with` is a common pattern in unit tests to verify that a specific method was called with the expected parameters, ensuring that the interaction between components is functioning correctly."
    },
    {
      "name": "test_manage",
      "module": "test_multiplexer",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_multiplexer.py",
      "line_number": 110,
      "end_line_number": 114,
      "source_code": "def test_manage(monitor_publisher: Mock, m: WorkerMultiplexer):\n    m.manage(\"NEW\", noop, auto_start=False, kwargs={\"foo\": 99})\n    monitor_publisher.send.assert_called_once_with(\n        (\"NEW\", noop, {\"foo\": 99}, False, None, False, False, 1)\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monitor_publisher",
        "m"
      ],
      "imports": [
        "sys",
        "multiprocessing.Event",
        "os.environ",
        "os.getpid",
        "typing.Any",
        "typing.Dict",
        "typing.Type",
        "typing.Union",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.compat.use_context",
        "sanic.worker.multiplexer.WorkerMultiplexer",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_manage` function is designed to verify that the `manage` method of the `WorkerMultiplexer` class correctly sends a specific message to the `monitor_publisher` when invoked with certain parameters. This ensures that the method behaves as expected in terms of communication with the monitoring system.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when `m.manage(\"NEW\", noop, auto_start=False, kwargs={\"foo\": 99})` is called, the `monitor_publisher.send` method is invoked exactly once with the expected tuple of arguments. This confirms that the `manage` method constructs and sends the correct message format to the publisher.\n\n**Code Being Tested and How It Works**:  \nThe `manage` method of the `WorkerMultiplexer` class is responsible for handling management commands related to worker processes. In this test, it is called with the command \"NEW\", a `noop` function, a flag `auto_start` set to `False`, and a dictionary `kwargs` containing `{\"foo\": 99}`. The expected output sent to the `monitor_publisher` is a tuple that includes these parameters along with additional default values, ensuring that the method correctly formats the message for the monitoring system.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of mocking through the `Mock` class from the `unittest.mock` module to simulate the `monitor_publisher`. This allows the test to verify interactions with the publisher without requiring a real implementation. The use of `assert_called_once_with` is a common pattern in unit tests to ensure that a method is called with the expected arguments, providing a clear and concise way to validate the behavior of the code under test."
    },
    {
      "name": "test_properties",
      "module": "test_multiplexer",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_multiplexer.py",
      "line_number": 117,
      "end_line_number": 125,
      "source_code": "def test_properties(\n    monitor_publisher: Mock, worker_state: Dict[str, Any], m: WorkerMultiplexer\n):\n    assert m.reload == m.restart\n    assert m.pid == getpid()\n    assert m.name == \"Test\"\n    assert m.workers == worker_state\n    assert m.state == worker_state[\"Test\"]\n    assert isinstance(m.state, WorkerState)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monitor_publisher",
        "worker_state",
        "m"
      ],
      "imports": [
        "sys",
        "multiprocessing.Event",
        "os.environ",
        "os.getpid",
        "typing.Any",
        "typing.Dict",
        "typing.Type",
        "typing.Union",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.compat.use_context",
        "sanic.worker.multiplexer.WorkerMultiplexer",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [
        "assert m.reload == m.restart",
        "assert m.pid == getpid()",
        "assert m.name == 'Test'",
        "assert m.workers == worker_state",
        "assert m.state == worker_state['Test']",
        "assert isinstance(m.state, WorkerState)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_properties` function is designed to verify the properties of a `WorkerMultiplexer` instance (`m`). It ensures that the instance is correctly initialized and that its attributes reflect expected values, which is crucial for the proper functioning of the worker management system in the Sanic framework.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks several key attributes of the `WorkerMultiplexer`:\n- It confirms that the `reload` and `restart` methods are equivalent.\n- It verifies that the process ID (`pid`) matches the current process ID.\n- It checks that the `name` attribute is set to \"Test\".\n- It ensures that the `workers` attribute matches the provided `worker_state`.\n- It validates that the `state` attribute corresponds to the worker state for \"Test\" and that it is an instance of `WorkerState`.\n\n**Code Being Tested and How It Works**:  \nThe test operates on the `WorkerMultiplexer` class, which is part of the Sanic framework's worker management system. The `WorkerMultiplexer` is responsible for managing multiple worker processes, handling their states, and facilitating communication between them. The assertions in the test confirm that the instance's properties are correctly initialized, which is essential for the multiplexer to function as intended.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertions**: The test employs direct assertions to validate the state of the `WorkerMultiplexer` instance, which is a straightforward and effective way to check expected outcomes.\n- **Mocking**: The use of `Mock` for `monitor_publisher` indicates that the test is designed to isolate the `WorkerMultiplexer` from external dependencies, allowing for focused testing of its properties without side effects.\n- **Parameterization**: Although not directly used in this specific test, the surrounding tests utilize `pytest.mark.parametrize`, showcasing a pattern for testing multiple scenarios with varying inputs and expected outcomes, which enhances test coverage and robustness."
    },
    {
      "name": "test_restart_params",
      "module": "test_multiplexer",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_multiplexer.py",
      "line_number": 147,
      "end_line_number": 158,
      "source_code": "def test_restart_params(\n    monitor_publisher: Mock,\n    m: WorkerMultiplexer,\n    params: Dict[str, Any],\n    expected: Union[str, Type[Exception]],\n):\n    if isinstance(expected, str):\n        m.restart(**params)\n        monitor_publisher.send.assert_called_once_with(expected)\n    else:\n        with pytest.raises(expected):\n            m.restart(**params)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('params,expected', (({}, 'Test:'), ({'name': 'foo'}, 'foo:'), ({'all_workers': True}, '__ALL_PROCESSES__:'), ({'zero_downtime': True}, 'Test::STARTUP_FIRST'), ({'name': 'foo', 'all_workers': True}, ValueError), ({'name': 'foo', 'zero_downtime': True}, 'foo::STARTUP_FIRST'), ({'all_workers': True, 'zero_downtime': True}, '__ALL_PROCESSES__::STARTUP_FIRST'), ({'name': 'foo', 'all_workers': True, 'zero_downtime': True}, ValueError)))"
      ],
      "arguments": [
        "monitor_publisher",
        "m",
        "params",
        "expected"
      ],
      "imports": [
        "sys",
        "multiprocessing.Event",
        "os.environ",
        "os.getpid",
        "typing.Any",
        "typing.Dict",
        "typing.Type",
        "typing.Union",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.compat.use_context",
        "sanic.worker.multiplexer.WorkerMultiplexer",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_restart_params` function is designed to verify the behavior of the `restart` method in the `WorkerMultiplexer` class, specifically how it handles different parameters and the expected outcomes, whether they are successful or raise exceptions.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two scenarios: \n1. When the `expected` parameter is a string, it verifies that the `restart` method successfully executes and that the `monitor_publisher` sends the expected message.\n2. When the `expected` parameter is an exception type, it ensures that the `restart` method raises the correct exception when called with the given parameters.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `restart` method of the `WorkerMultiplexer` class. The test uses the `params` dictionary to pass arguments to this method. If the method executes without errors and the expected output is a string, it checks that the `send` method of `monitor_publisher` is called with that string. If an exception is expected, it asserts that the `restart` method raises the specified exception type.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses parameters (`params` and `expected`) to cover multiple scenarios in a single test function, enhancing test coverage and reducing redundancy.\n- **Mocking**: The `monitor_publisher` is mocked to verify interactions without needing a real implementation, allowing for isolated testing of the `restart` method's behavior.\n- **Exception Handling**: The use of `pytest.raises` allows for clean and clear verification of expected exceptions, ensuring that the method behaves correctly under erroneous conditions."
    },
    {
      "name": "test_session_ticket_store",
      "module": "test_session_ticket_store",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/http3/test_session_ticket_store.py",
      "line_number": 22,
      "end_line_number": 46,
      "source_code": "def test_session_ticket_store():\n    store = SessionTicketStore()\n\n    assert len(store.tickets) == 0\n\n    ticket1 = _generate_ticket(b\"foo\")\n    store.add(ticket1)\n\n    assert len(store.tickets) == 1\n\n    ticket2 = _generate_ticket(b\"bar\")\n    store.add(ticket2)\n\n    assert len(store.tickets) == 2\n    assert len(store.tickets) == 2\n\n    popped2 = store.pop(ticket2.ticket)\n\n    assert len(store.tickets) == 1\n    assert popped2 is ticket2\n\n    popped1 = store.pop(ticket1.ticket)\n\n    assert len(store.tickets) == 0\n    assert popped1 is ticket1",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "aioquic.tls.CipherSuite",
        "aioquic.tls.SessionTicket",
        "sanic.http.http3.SessionTicketStore"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(store.tickets) == 0",
        "assert len(store.tickets) == 1",
        "assert len(store.tickets) == 2",
        "assert len(store.tickets) == 2",
        "assert len(store.tickets) == 1",
        "assert popped2 is ticket2",
        "assert len(store.tickets) == 0",
        "assert popped1 is ticket1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "_generate_ticket",
          "body": "def _generate_ticket(label):\n    return SessionTicket(1, CipherSuite.AES_128_GCM_SHA256, datetime.now(), datetime.now(), label, label.decode(), label, None, [])"
        },
        {
          "name": "_generate_ticket",
          "body": "def _generate_ticket(label):\n    return SessionTicket(1, CipherSuite.AES_128_GCM_SHA256, datetime.now(), datetime.now(), label, label.decode(), label, None, [])"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_session_ticket_store` function is designed to verify the functionality of the `SessionTicketStore` class, specifically its ability to manage session tickets. This includes adding tickets, checking the count of tickets, and removing tickets while ensuring that the correct tickets are returned.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. The initial state of the ticket store is empty.\n2. Tickets can be added to the store, and the count of tickets reflects this addition.\n3. Tickets can be removed from the store, and the count updates accordingly.\n4. The correct ticket is returned when a ticket is popped from the store.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `SessionTicketStore` class, which presumably maintains a collection of session tickets. The `_generate_ticket` function creates a new `SessionTicket` instance with specific attributes. The test first initializes a `SessionTicketStore`, checks its initial state, adds two tickets generated by `_generate_ticket`, and then verifies the count of tickets. It subsequently pops the tickets from the store and checks that the store is empty afterward and that the correct tickets are returned.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertions**: The test uses assertions to validate the expected outcomes at various stages, ensuring that the state of the `SessionTicketStore` is as expected after each operation.\n- **Setup and Teardown**: Although not explicitly shown, the test implicitly sets up the state by creating a new `SessionTicketStore` instance at the beginning of the test.\n- **Isolation**: Each test case operates independently, ensuring that the state of the `SessionTicketStore` is reset for each test run, which is crucial for reliable unit testing."
    },
    {
      "name": "test_http_receiver_init",
      "module": "test_http_receiver",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/http3/test_http_receiver.py",
      "line_number": 71,
      "end_line_number": 78,
      "source_code": "def test_http_receiver_init(app: Sanic, http_request: Request):\n    receiver = generate_http_receiver(app, http_request)\n    assert receiver.request_body is None\n    assert receiver.stage is Stage.IDLE\n    assert receiver.headers_sent is False\n    assert receiver.response is None\n    assert receiver.request_max_size == DEFAULT_CONFIG[\"REQUEST_MAX_SIZE\"]\n    assert receiver.request_bytes == 0",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "http_request"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "aioquic.h3.connection.H3Connection",
        "aioquic.h3.events.DataReceived",
        "aioquic.h3.events.HeadersReceived",
        "aioquic.quic.configuration.QuicConfiguration",
        "aioquic.quic.connection.QuicConnection",
        "aioquic.quic.events.ProtocolNegotiated",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.constants.Stage",
        "sanic.http.http3.Http3",
        "sanic.http.http3.HTTPReceiver",
        "sanic.models.server_types.ConnInfo",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.server.protocols.http_protocol.Http3Protocol",
        "unittest.mock.AsyncMock",
        "tests.asyncmock.AsyncMock"
      ],
      "fixtures": [],
      "assertions": [
        "assert receiver.request_body is None",
        "assert receiver.stage is Stage.IDLE",
        "assert receiver.headers_sent is False",
        "assert receiver.response is None",
        "assert receiver.request_max_size == DEFAULT_CONFIG['REQUEST_MAX_SIZE']",
        "assert receiver.request_bytes == 0"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "generate_http_receiver",
          "body": "def generate_http_receiver(app, http_request) -> HTTPReceiver:\n    protocol = generate_protocol(app)\n    receiver = HTTPReceiver(protocol.transmit, protocol, http_request)\n    http_request.stream = receiver\n    return receiver"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_http_receiver_init` function is designed to verify the initial state of an `HTTPReceiver` object created by the `generate_http_receiver` function. It ensures that the receiver is correctly initialized with default values when it is instantiated.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks several attributes of the `receiver` object immediately after its creation:\n- `request_body` should be `None`, indicating no request body has been received yet.\n- `stage` should be `Stage.IDLE`, confirming that the receiver is in the idle state.\n- `headers_sent` should be `False`, indicating that no headers have been sent.\n- `response` should be `None`, meaning no response has been generated yet.\n- `request_max_size` should match the default configuration value for maximum request size.\n- `request_bytes` should be `0`, indicating that no bytes have been received.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `generate_http_receiver` function, which takes an `app` instance and an `http_request` object as parameters. It creates an `HTTPReceiver` instance by generating a protocol and passing the necessary parameters to the `HTTPReceiver` constructor. The `http_request.stream` is set to the newly created receiver, linking the request to the receiver for further processing.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs direct assertions to validate the state of the `receiver` object, which is a common pattern in unit testing. It uses the `assert` statement to check expected values against actual values, providing a straightforward way to verify correctness. The test is also structured to be independent, relying solely on the behavior of the `generate_http_receiver` function without external dependencies, which is a key principle in unit testing."
    },
    {
      "name": "test_http_receiver_respond",
      "module": "test_http_receiver",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/http3/test_http_receiver.py",
      "line_number": 117,
      "end_line_number": 131,
      "source_code": "def test_http_receiver_respond(app: Sanic, http_request: Request):\n    receiver = generate_http_receiver(app, http_request)\n    response = empty()\n\n    receiver.stage = Stage.RESPONSE\n    with pytest.raises(RuntimeError, match=\"Response already started\"):\n        receiver.respond(response)\n\n    receiver.stage = Stage.HANDLER\n    receiver.response = Mock()\n    resp = receiver.respond(response)\n\n    assert receiver.response is resp\n    assert resp is response\n    assert response.stream is receiver",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "http_request"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "aioquic.h3.connection.H3Connection",
        "aioquic.h3.events.DataReceived",
        "aioquic.h3.events.HeadersReceived",
        "aioquic.quic.configuration.QuicConfiguration",
        "aioquic.quic.connection.QuicConnection",
        "aioquic.quic.events.ProtocolNegotiated",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.constants.Stage",
        "sanic.http.http3.Http3",
        "sanic.http.http3.HTTPReceiver",
        "sanic.models.server_types.ConnInfo",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.server.protocols.http_protocol.Http3Protocol",
        "unittest.mock.AsyncMock",
        "tests.asyncmock.AsyncMock"
      ],
      "fixtures": [],
      "assertions": [
        "assert receiver.response is resp",
        "assert resp is response",
        "assert response.stream is receiver"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "generate_http_receiver",
          "body": "def generate_http_receiver(app, http_request) -> HTTPReceiver:\n    protocol = generate_protocol(app)\n    receiver = HTTPReceiver(protocol.transmit, protocol, http_request)\n    http_request.stream = receiver\n    return receiver"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_http_receiver_respond` function is designed to verify the behavior of the `respond` method in the `HTTPReceiver` class. Specifically, it checks that the method correctly handles state transitions and raises appropriate exceptions when the receiver is in an invalid state.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies two key behaviors of the `respond` method:\n1. It ensures that a `RuntimeError` is raised with the message \"Response already started\" when the receiver is in the `Stage.RESPONSE` state and an attempt is made to call `respond`.\n2. It confirms that when the receiver is in the `Stage.HANDLER` state, the `respond` method correctly assigns the response and updates the internal state, ensuring that the response returned is the same as the one passed in.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `generate_http_receiver` function, which initializes an `HTTPReceiver` instance with a given application and HTTP request. The `respond` method of the `HTTPReceiver` is then called with a response object. The test first sets the receiver's stage to `Stage.RESPONSE` and checks for an exception. After changing the stage to `Stage.HANDLER`, it verifies that the response is correctly assigned and that the response stream is linked to the receiver.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the following techniques:\n- **Context Management with Exception Checking**: It uses `pytest.raises` to assert that a specific exception is raised under certain conditions, which is a common pattern for testing error handling.\n- **Mocking**: The test uses `Mock` to simulate the response object, allowing for controlled testing of the `respond` method's behavior without relying on actual response implementations.\n- **State Verification**: The test checks the internal state of the `receiver` object before and after calling `respond`, ensuring that the method behaves correctly based on the receiver's state."
    },
    {
      "name": "test_http_receiver_receive_body",
      "module": "test_http_receiver",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/http3/test_http_receiver.py",
      "line_number": 134,
      "end_line_number": 147,
      "source_code": "def test_http_receiver_receive_body(app: Sanic, http_request: Request):\n    receiver = generate_http_receiver(app, http_request)\n    receiver.request_max_size = 4\n\n    receiver.receive_body(b\"..\")\n    assert receiver.request.body == b\"..\"\n\n    receiver.receive_body(b\"..\")\n    assert receiver.request.body == b\"....\"\n\n    with pytest.raises(\n        PayloadTooLarge, match=\"Request body exceeds the size limit\"\n    ):\n        receiver.receive_body(b\"..\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "http_request"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "aioquic.h3.connection.H3Connection",
        "aioquic.h3.events.DataReceived",
        "aioquic.h3.events.HeadersReceived",
        "aioquic.quic.configuration.QuicConfiguration",
        "aioquic.quic.connection.QuicConnection",
        "aioquic.quic.events.ProtocolNegotiated",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.constants.Stage",
        "sanic.http.http3.Http3",
        "sanic.http.http3.HTTPReceiver",
        "sanic.models.server_types.ConnInfo",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.server.protocols.http_protocol.Http3Protocol",
        "unittest.mock.AsyncMock",
        "tests.asyncmock.AsyncMock"
      ],
      "fixtures": [],
      "assertions": [
        "assert receiver.request.body == b'..'",
        "assert receiver.request.body == b'....'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "generate_http_receiver",
          "body": "def generate_http_receiver(app, http_request) -> HTTPReceiver:\n    protocol = generate_protocol(app)\n    receiver = HTTPReceiver(protocol.transmit, protocol, http_request)\n    http_request.stream = receiver\n    return receiver"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_http_receiver_receive_body` test is to verify the behavior of the `HTTPReceiver` class when receiving data in the request body, particularly focusing on the handling of body size limits and the correct accumulation of received data.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the `HTTPReceiver` correctly accumulates data in the request body up to a specified maximum size (`request_max_size`). It ensures that when the accumulated size exceeds this limit, a `PayloadTooLarge` exception is raised, indicating that the request body exceeds the allowed size.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the `generate_http_receiver` function to create an instance of `HTTPReceiver`, which is initialized with a maximum request body size of 4 bytes. The test then simulates receiving data in chunks:\n1. It first sends two chunks of data (`b\"..\"`), verifying that the body accumulates correctly to `b\"....\"`.\n2. Finally, it attempts to send another chunk of data, which should exceed the maximum size, triggering a `PayloadTooLarge` exception.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Assertion**: The test uses assertions to verify the state of the `receiver.request.body` after each data reception, ensuring that the body is correctly updated.\n- **Exception Testing**: The test employs `pytest.raises` to assert that the correct exception is raised when the body size limit is exceeded, which is a common pattern for testing error conditions in unit tests.\n- **Setup and Teardown**: The test implicitly sets up the necessary context (e.g., creating the `receiver` and setting `request_max_size`) without needing explicit teardown, as it focuses on a single scenario."
    },
    {
      "name": "test_http3_events",
      "module": "test_http_receiver",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/http3/test_http_receiver.py",
      "line_number": 150,
      "end_line_number": 174,
      "source_code": "def test_http3_events(app):\n    protocol = generate_protocol(app)\n    http3 = Http3(protocol, protocol.transmit)\n    http3.http_event_received(\n        HeadersReceived(\n            [\n                (b\":method\", b\"GET\"),\n                (b\":path\", b\"/location\"),\n                (b\":scheme\", b\"https\"),\n                (b\":authority\", b\"localhost:8443\"),\n                (b\"foo\", b\"bar\"),\n            ],\n            1,\n            False,\n        )\n    )\n    http3.http_event_received(DataReceived(b\"foobar\", 1, False))\n    receiver = http3.receivers[1]\n\n    assert len(http3.receivers) == 1\n    assert receiver.request.stream_id == 1\n    assert receiver.request.path == \"/location\"\n    assert receiver.request.method == \"GET\"\n    assert receiver.request.headers[\"foo\"] == \"bar\"\n    assert receiver.request.body == b\"foobar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "aioquic.h3.connection.H3Connection",
        "aioquic.h3.events.DataReceived",
        "aioquic.h3.events.HeadersReceived",
        "aioquic.quic.configuration.QuicConfiguration",
        "aioquic.quic.connection.QuicConnection",
        "aioquic.quic.events.ProtocolNegotiated",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.constants.Stage",
        "sanic.http.http3.Http3",
        "sanic.http.http3.HTTPReceiver",
        "sanic.models.server_types.ConnInfo",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.server.protocols.http_protocol.Http3Protocol",
        "unittest.mock.AsyncMock",
        "tests.asyncmock.AsyncMock"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(http3.receivers) == 1",
        "assert receiver.request.stream_id == 1",
        "assert receiver.request.path == '/location'",
        "assert receiver.request.method == 'GET'",
        "assert receiver.request.headers['foo'] == 'bar'",
        "assert receiver.request.body == b'foobar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "generate_protocol",
          "body": "def generate_protocol(app):\n    connection = QuicConnection(configuration=QuicConfiguration())\n    connection._ack_delay = 0\n    connection._loss = Mock()\n    connection._loss.spaces = []\n    connection._loss.get_loss_detection_time = lambda : None\n    connection.datagrams_to_send = Mock(return_value=[])\n    return Http3Protocol(connection, app=app, stream_handler=None)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_http3_events` unit test is to verify the correct handling of HTTP/3 events within the `Http3` class. Specifically, it checks that the class properly processes incoming HTTP/3 headers and data, and that it constructs the corresponding request object accurately.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies that when HTTP/3 events (headers and data) are received, the `Http3` instance correctly updates its internal state, specifically the `receivers` list. It checks that the request attributes such as `stream_id`, `path`, `method`, headers, and body are set as expected based on the received events.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `Http3` class and its method `http_event_received`, which processes events like `HeadersReceived` and `DataReceived`. The `generate_protocol` function creates an instance of `Http3Protocol`, which is passed to the `Http3` instance. The test simulates receiving HTTP/3 events and then asserts that the internal `receiver` object has the correct attributes reflecting the received data.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the Arrange-Act-Assert (AAA) pattern:\n- **Arrange**: It sets up the necessary objects and state by generating the protocol and creating an `Http3` instance.\n- **Act**: It simulates the reception of HTTP/3 events by calling `http_event_received` with `HeadersReceived` and `DataReceived`.\n- **Assert**: It checks the state of the `http3.receivers` list and the attributes of the `receiver` object to ensure they match the expected values. This structured approach enhances readability and maintainability of the test."
    },
    {
      "name": "test_multiple_streams",
      "module": "test_http_receiver",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/http3/test_http_receiver.py",
      "line_number": 216,
      "end_line_number": 251,
      "source_code": "def test_multiple_streams(app):\n    protocol = generate_protocol(app)\n    http3 = Http3(protocol, protocol.transmit)\n    http3.http_event_received(\n        HeadersReceived(\n            [\n                (b\":method\", b\"GET\"),\n                (b\":path\", b\"/location\"),\n                (b\":scheme\", b\"https\"),\n                (b\":authority\", b\"localhost:8443\"),\n                (b\"foo\", b\"bar\"),\n            ],\n            1,\n            False,\n        )\n    )\n    http3.http_event_received(\n        HeadersReceived(\n            [\n                (b\":method\", b\"GET\"),\n                (b\":path\", b\"/location\"),\n                (b\":scheme\", b\"https\"),\n                (b\":authority\", b\"localhost:8443\"),\n                (b\"foo\", b\"bar\"),\n            ],\n            2,\n            False,\n        )\n    )\n\n    receiver1 = http3.get_receiver_by_stream_id(1)\n    receiver2 = http3.get_receiver_by_stream_id(2)\n    assert len(http3.receivers) == 2\n    assert isinstance(receiver1, HTTPReceiver)\n    assert isinstance(receiver2, HTTPReceiver)\n    assert receiver1 is not receiver2",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "aioquic.h3.connection.H3Connection",
        "aioquic.h3.events.DataReceived",
        "aioquic.h3.events.HeadersReceived",
        "aioquic.quic.configuration.QuicConfiguration",
        "aioquic.quic.connection.QuicConnection",
        "aioquic.quic.events.ProtocolNegotiated",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.constants.Stage",
        "sanic.http.http3.Http3",
        "sanic.http.http3.HTTPReceiver",
        "sanic.models.server_types.ConnInfo",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.server.protocols.http_protocol.Http3Protocol",
        "unittest.mock.AsyncMock",
        "tests.asyncmock.AsyncMock"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(http3.receivers) == 2",
        "assert isinstance(receiver1, HTTPReceiver)",
        "assert isinstance(receiver2, HTTPReceiver)",
        "assert receiver1 is not receiver2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "generate_protocol",
          "body": "def generate_protocol(app):\n    connection = QuicConnection(configuration=QuicConfiguration())\n    connection._ack_delay = 0\n    connection._loss = Mock()\n    connection._loss.spaces = []\n    connection._loss.get_loss_detection_time = lambda : None\n    connection.datagrams_to_send = Mock(return_value=[])\n    return Http3Protocol(connection, app=app, stream_handler=None)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_multiple_streams` function is designed to verify that the `Http3` class can correctly handle multiple HTTP streams. It ensures that when two separate streams are initiated, each stream is associated with its own `HTTPReceiver` instance, confirming that the system can manage concurrent requests effectively.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that two distinct streams (identified by their stream IDs) are created and managed independently. It asserts that the number of receivers in the `http3` instance is exactly two, and that the receivers for each stream ID are not only instances of `HTTPReceiver` but also distinct from one another.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `Http3` class, specifically its `http_event_received` method, which processes incoming HTTP events. The `HeadersReceived` objects simulate HTTP headers for two separate GET requests, each associated with a unique stream ID (1 and 2). The `get_receiver_by_stream_id` method retrieves the corresponding `HTTPReceiver` instances for these stream IDs, allowing the test to validate the expected behavior of the `Http3` class in managing multiple streams.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several key testing techniques:\n- **Assertions**: It uses assertions to validate the expected outcomes, such as checking the count of receivers and their types.\n- **Isolation of Tests**: By using unique stream IDs and separate header events, the test isolates the behavior of the `Http3` class, ensuring that the handling of one stream does not interfere with another.\n- **Mocking and Dependency Injection**: The `generate_protocol` function is used to create a mock protocol for the `Http3` instance, allowing the test to focus on the functionality of the `Http3` class without needing a full application context."
    },
    {
      "name": "test_request_stream_id",
      "module": "test_http_receiver",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/http3/test_http_receiver.py",
      "line_number": 254,
      "end_line_number": 273,
      "source_code": "def test_request_stream_id(app):\n    protocol = generate_protocol(app)\n    http3 = Http3(protocol, protocol.transmit)\n    http3.http_event_received(\n        HeadersReceived(\n            [\n                (b\":method\", b\"GET\"),\n                (b\":path\", b\"/location\"),\n                (b\":scheme\", b\"https\"),\n                (b\":authority\", b\"localhost:8443\"),\n                (b\"foo\", b\"bar\"),\n            ],\n            1,\n            False,\n        )\n    )\n    receiver = http3.get_receiver_by_stream_id(1)\n\n    assert isinstance(receiver.request, Request)\n    assert receiver.request.stream_id == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "aioquic.h3.connection.H3Connection",
        "aioquic.h3.events.DataReceived",
        "aioquic.h3.events.HeadersReceived",
        "aioquic.quic.configuration.QuicConfiguration",
        "aioquic.quic.connection.QuicConnection",
        "aioquic.quic.events.ProtocolNegotiated",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.constants.Stage",
        "sanic.http.http3.Http3",
        "sanic.http.http3.HTTPReceiver",
        "sanic.models.server_types.ConnInfo",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.server.protocols.http_protocol.Http3Protocol",
        "unittest.mock.AsyncMock",
        "tests.asyncmock.AsyncMock"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(receiver.request, Request)",
        "assert receiver.request.stream_id == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "generate_protocol",
          "body": "def generate_protocol(app):\n    connection = QuicConnection(configuration=QuicConfiguration())\n    connection._ack_delay = 0\n    connection._loss = Mock()\n    connection._loss.spaces = []\n    connection._loss.get_loss_detection_time = lambda : None\n    connection.datagrams_to_send = Mock(return_value=[])\n    return Http3Protocol(connection, app=app, stream_handler=None)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_request_stream_id` unit test is designed to verify that the HTTP/3 protocol implementation correctly associates a request with its corresponding stream ID. It ensures that when an HTTP event is received, the request object can be retrieved and that its stream ID matches the expected value.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that after an HTTP event (headers received) is processed, the request object associated with the stream ID (in this case, `1`) is correctly instantiated and that its `stream_id` attribute is set to `1`. This confirms that the system is correctly handling and mapping requests to their respective streams.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `Http3` class, which is part of the HTTP/3 protocol implementation. It first generates a protocol instance using `generate_protocol(app)`, then simulates the reception of HTTP headers through the `http_event_received` method. The headers include essential HTTP fields such as method, path, and authority, along with a stream ID of `1`. After processing this event, the test retrieves the corresponding receiver using `get_receiver_by_stream_id(1)` and asserts that the request is an instance of the `Request` class and that its `stream_id` is correctly set.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the Arrange-Act-Assert (AAA) pattern, where:\n- **Arrange**: The necessary objects and state are set up (protocol and HTTP event).\n- **Act**: The method under test is invoked (processing the HTTP event).\n- **Assert**: The expected outcomes are verified (checking the type and stream ID of the request).  \nAdditionally, the test uses assertions to validate the state of the system, ensuring that the implementation adheres to the expected behavior."
    },
    {
      "name": "test_request_conn_info",
      "module": "test_http_receiver",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/http3/test_http_receiver.py",
      "line_number": 276,
      "end_line_number": 294,
      "source_code": "def test_request_conn_info(app):\n    protocol = generate_protocol(app)\n    http3 = Http3(protocol, protocol.transmit)\n    http3.http_event_received(\n        HeadersReceived(\n            [\n                (b\":method\", b\"GET\"),\n                (b\":path\", b\"/location\"),\n                (b\":scheme\", b\"https\"),\n                (b\":authority\", b\"localhost:8443\"),\n                (b\"foo\", b\"bar\"),\n            ],\n            1,\n            False,\n        )\n    )\n    receiver = http3.get_receiver_by_stream_id(1)\n\n    assert isinstance(receiver.request.conn_info, ConnInfo)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "aioquic.h3.connection.H3Connection",
        "aioquic.h3.events.DataReceived",
        "aioquic.h3.events.HeadersReceived",
        "aioquic.quic.configuration.QuicConfiguration",
        "aioquic.quic.connection.QuicConnection",
        "aioquic.quic.events.ProtocolNegotiated",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.constants.Stage",
        "sanic.http.http3.Http3",
        "sanic.http.http3.HTTPReceiver",
        "sanic.models.server_types.ConnInfo",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.server.protocols.http_protocol.Http3Protocol",
        "unittest.mock.AsyncMock",
        "tests.asyncmock.AsyncMock"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(receiver.request.conn_info, ConnInfo)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "generate_protocol",
          "body": "def generate_protocol(app):\n    connection = QuicConnection(configuration=QuicConfiguration())\n    connection._ack_delay = 0\n    connection._loss = Mock()\n    connection._loss.spaces = []\n    connection._loss.get_loss_detection_time = lambda : None\n    connection.datagrams_to_send = Mock(return_value=[])\n    return Http3Protocol(connection, app=app, stream_handler=None)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_request_conn_info` unit test is designed to verify that the connection information associated with an HTTP request is correctly instantiated and accessible within the context of a Sanic application using the HTTP/3 protocol.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `conn_info` attribute of the `request` object, which is expected to be an instance of the `ConnInfo` class, is properly set up after an HTTP event (specifically, headers being received) is processed. This ensures that the connection information is correctly linked to the request.\n\n**Code Being Tested and How It Works**:  \nThe test begins by generating a protocol instance using the `generate_protocol` function, which sets up a QUIC connection and returns an `Http3Protocol` object. It then simulates the reception of HTTP headers through the `http_event_received` method of the `Http3` class. The headers include method, path, scheme, authority, and additional custom headers. After processing the headers, the test retrieves the receiver associated with the stream ID (1) and asserts that the `conn_info` attribute of the request is an instance of `ConnInfo`, confirming that the connection information is correctly established.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Mocking**: The `generate_protocol` function uses mocks to simulate the behavior of the QUIC connection, allowing the test to focus on the HTTP/3 protocol's functionality without needing a real network connection.\n- **Event Simulation**: The test simulates the reception of HTTP events, which is crucial for testing asynchronous protocols like HTTP/3, ensuring that the system behaves as expected when events are processed.\n- **Type Assertion**: The use of `assert isinstance(...)` is a common pattern in unit tests to verify that an object is of the expected type, which helps ensure that the system's components are correctly instantiated and integrated."
    },
    {
      "name": "test_request_header_encoding",
      "module": "test_http_receiver",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/http3/test_http_receiver.py",
      "line_number": 297,
      "end_line_number": 318,
      "source_code": "def test_request_header_encoding(app):\n    protocol = generate_protocol(app)\n    http3 = Http3(protocol, protocol.transmit)\n    with pytest.raises(BadRequest) as exc_info:\n        http3.http_event_received(\n            HeadersReceived(\n                [\n                    (b\":method\", b\"GET\"),\n                    (b\":path\", b\"/location\"),\n                    (b\":scheme\", b\"https\"),\n                    (b\":authority\", b\"localhost:8443\"),\n                    (\"foo\\u00a0\".encode(), b\"bar\"),\n                ],\n                1,\n                False,\n            )\n        )\n    assert exc_info.value.status_code == 400\n    assert (\n        str(exc_info.value)\n        == \"Header names may only contain US-ASCII characters.\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "aioquic.h3.connection.H3Connection",
        "aioquic.h3.events.DataReceived",
        "aioquic.h3.events.HeadersReceived",
        "aioquic.quic.configuration.QuicConfiguration",
        "aioquic.quic.connection.QuicConnection",
        "aioquic.quic.events.ProtocolNegotiated",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.constants.Stage",
        "sanic.http.http3.Http3",
        "sanic.http.http3.HTTPReceiver",
        "sanic.models.server_types.ConnInfo",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.server.protocols.http_protocol.Http3Protocol",
        "unittest.mock.AsyncMock",
        "tests.asyncmock.AsyncMock"
      ],
      "fixtures": [],
      "assertions": [
        "assert exc_info.value.status_code == 400",
        "assert str(exc_info.value) == 'Header names may only contain US-ASCII characters.'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "generate_protocol",
          "body": "def generate_protocol(app):\n    connection = QuicConnection(configuration=QuicConfiguration())\n    connection._ack_delay = 0\n    connection._loss = Mock()\n    connection._loss.spaces = []\n    connection._loss.get_loss_detection_time = lambda : None\n    connection.datagrams_to_send = Mock(return_value=[])\n    return Http3Protocol(connection, app=app, stream_handler=None)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_request_header_encoding` unit test is designed to verify that the HTTP/3 implementation correctly handles invalid header names that contain non-US-ASCII characters. Specifically, it checks that such headers trigger a `BadRequest` exception with the appropriate error message.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when a header name includes a non-ASCII character (in this case, a non-breaking space represented by `\\u00a0`), the system raises a `BadRequest` exception. It also verifies that the exception contains the correct status code (400) and a specific error message indicating that header names must be US-ASCII compliant.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `http3.http_event_received` method of the `Http3` class, which processes incoming HTTP/3 events. The `HeadersReceived` object simulates an incoming HTTP request with headers, one of which is invalid due to the presence of a non-ASCII character. The `generate_protocol` function is used to set up the necessary protocol context for the test. When the invalid header is processed, the method is expected to raise a `BadRequest` exception, which is then captured and asserted against expected values.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that an exception is raised during the execution of the code block. This is a common pattern in unit testing for verifying error handling. Additionally, it uses assertions to check both the status code and the message of the raised exception, ensuring comprehensive validation of the error handling behavior. The test is structured to be clear and focused, making it easy to understand the expected outcome and the conditions under which it occurs."
    },
    {
      "name": "test_request_url_encoding",
      "module": "test_http_receiver",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/http3/test_http_receiver.py",
      "line_number": 321,
      "end_line_number": 339,
      "source_code": "def test_request_url_encoding(app):\n    protocol = generate_protocol(app)\n    http3 = Http3(protocol, protocol.transmit)\n    with pytest.raises(BadRequest) as exc_info:\n        http3.http_event_received(\n            HeadersReceived(\n                [\n                    (b\":method\", b\"GET\"),\n                    (b\":path\", b\"/location\\xa0\"),\n                    (b\":scheme\", b\"https\"),\n                    (b\":authority\", b\"localhost:8443\"),\n                    (b\"foo\", b\"bar\"),\n                ],\n                1,\n                False,\n            )\n        )\n    assert exc_info.value.status_code == 400\n    assert str(exc_info.value) == \"URL may only contain US-ASCII characters.\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "aioquic.h3.connection.H3Connection",
        "aioquic.h3.events.DataReceived",
        "aioquic.h3.events.HeadersReceived",
        "aioquic.quic.configuration.QuicConfiguration",
        "aioquic.quic.connection.QuicConnection",
        "aioquic.quic.events.ProtocolNegotiated",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.constants.Stage",
        "sanic.http.http3.Http3",
        "sanic.http.http3.HTTPReceiver",
        "sanic.models.server_types.ConnInfo",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.server.protocols.http_protocol.Http3Protocol",
        "unittest.mock.AsyncMock",
        "tests.asyncmock.AsyncMock"
      ],
      "fixtures": [],
      "assertions": [
        "assert exc_info.value.status_code == 400",
        "assert str(exc_info.value) == 'URL may only contain US-ASCII characters.'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "generate_protocol",
          "body": "def generate_protocol(app):\n    connection = QuicConnection(configuration=QuicConfiguration())\n    connection._ack_delay = 0\n    connection._loss = Mock()\n    connection._loss.spaces = []\n    connection._loss.get_loss_detection_time = lambda : None\n    connection.datagrams_to_send = Mock(return_value=[])\n    return Http3Protocol(connection, app=app, stream_handler=None)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_request_url_encoding` unit test is designed to verify that the HTTP request handling in the Sanic framework correctly raises a `BadRequest` exception when a URL contains non-US-ASCII characters. This ensures that the application adheres to the expected standards for URL encoding.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that when a URL path with a non-ASCII character (in this case, a non-breaking space represented as `\\xa0`) is received, the system raises a `BadRequest` exception with a status code of 400 and an appropriate error message indicating that URLs may only contain US-ASCII characters.\n\n**Code Being Tested and How It Works**:  \nThe code under test is part of the HTTP event handling mechanism in the `Http3` class, which processes incoming HTTP events. The `http_event_received` method is invoked with a `HeadersReceived` object that includes the problematic URL path. The `generate_protocol` function sets up the necessary protocol context for the test, while the `Http3` instance processes the headers. When the invalid URL is detected, a `BadRequest` exception is raised, which the test captures and asserts against.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that a specific exception (`BadRequest`) is raised during the execution of the code block. This is a common pattern in unit testing for verifying that error conditions are handled correctly. Additionally, the test includes assertions to check both the status code and the error message of the raised exception, ensuring comprehensive validation of the error handling behavior."
    },
    {
      "name": "test_server_starts_http3",
      "module": "test_server",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/http3/test_server.py",
      "line_number": 23,
      "end_line_number": 46,
      "source_code": "def test_server_starts_http3(app: Sanic, version, caplog):\n    ev = Event()\n\n    @app.after_server_start\n    def shutdown(*_):\n        ev.set()\n        app.stop()\n\n    with caplog.at_level(logging.INFO):\n        app.run(\n            version=version,\n            ssl={\n                \"cert\": localhost_dir / \"fullchain.pem\",\n                \"key\": localhost_dir / \"privkey.pem\",\n            },\n            single_process=True,\n        )\n\n    assert ev.is_set()\n    assert (\n        \"sanic.root\",\n        logging.INFO,\n        \"server: sanic, HTTP/3\",\n    ) in caplog.record_tuples",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('version', (3, HTTP.VERSION_3))",
        "pytest.mark.skipif(sys.version_info < (3, 8) and (not UVLOOP_INSTALLED), reason='In 3.7 w/o uvloop the port is not always released')"
      ],
      "arguments": [
        "app",
        "version",
        "caplog"
      ],
      "imports": [
        "logging",
        "sys",
        "asyncio.Event",
        "pathlib.Path",
        "pytest",
        "sanic.Sanic",
        "sanic.compat.UVLOOP_INSTALLED",
        "sanic.http.constants.HTTP"
      ],
      "fixtures": [],
      "assertions": [
        "assert ev.is_set()",
        "assert ('sanic.root', logging.INFO, 'server: sanic, HTTP/3') in caplog.record_tuples"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        },
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_server_starts_http3` unit test is designed to verify that a Sanic server can successfully start with HTTP/3 support enabled. It ensures that the server logs the appropriate message indicating that it is running with HTTP/3.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main behaviors: \n1. It confirms that the server starts and the shutdown event is triggered correctly by asserting that the event `ev` is set.\n2. It verifies that the expected log message indicating the server is running with HTTP/3 is present in the captured logs.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `app.run` method, which is responsible for starting the Sanic server. It uses SSL certificates for secure connections and runs the server in a single process. The `app.after_server_start` decorator is used to define a shutdown function that sets an event when the server starts, allowing the test to confirm that the server has started successfully. The `caplog` fixture captures log messages at the INFO level to check for specific log entries.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Event Handling**: The use of an `Event` object to signal when the server has started is a common pattern in asynchronous programming, allowing the test to wait for a specific condition.\n- **Log Capture**: The `caplog` fixture from pytest is employed to capture log messages, enabling assertions on log output, which is crucial for verifying that the server behaves as expected in terms of logging.\n- **Context Management**: The use of `with` statements for both `caplog` and the server run ensures that the logging level is set appropriately only during the execution of the test, maintaining isolation and preventing side effects on other tests."
    },
    {
      "name": "test_server_starts_http1_and_http3",
      "module": "test_server",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/http3/test_server.py",
      "line_number": 53,
      "end_line_number": 84,
      "source_code": "def test_server_starts_http1_and_http3(app: Sanic, caplog):\n    @app.after_server_start\n    def shutdown(*_):\n        app.stop()\n\n    app.prepare(\n        version=3,\n        ssl={\n            \"cert\": localhost_dir / \"fullchain.pem\",\n            \"key\": localhost_dir / \"privkey.pem\",\n        },\n    )\n    app.prepare(\n        version=1,\n        ssl={\n            \"cert\": localhost_dir / \"fullchain.pem\",\n            \"key\": localhost_dir / \"privkey.pem\",\n        },\n    )\n    with caplog.at_level(logging.INFO):\n        Sanic.serve_single()\n\n    assert (\n        \"sanic.root\",\n        logging.INFO,\n        \"server: sanic, HTTP/1.1\",\n    ) in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.INFO,\n        \"server: sanic, HTTP/3\",\n    ) in caplog.record_tuples",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(sys.version_info < (3, 8) and (not UVLOOP_INSTALLED), reason='In 3.7 w/o uvloop the port is not always released')"
      ],
      "arguments": [
        "app",
        "caplog"
      ],
      "imports": [
        "logging",
        "sys",
        "asyncio.Event",
        "pathlib.Path",
        "pytest",
        "sanic.Sanic",
        "sanic.compat.UVLOOP_INSTALLED",
        "sanic.http.constants.HTTP"
      ],
      "fixtures": [],
      "assertions": [
        "assert ('sanic.root', logging.INFO, 'server: sanic, HTTP/1.1') in caplog.record_tuples",
        "assert ('sanic.root', logging.INFO, 'server: sanic, HTTP/3') in caplog.record_tuples"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_server_starts_http1_and_http3` test is to verify that a Sanic application can successfully start servers for both HTTP/1.1 and HTTP/3 protocols, and that appropriate logging messages are generated for each server type upon startup.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the Sanic application logs the correct messages indicating the successful startup of both HTTP/1.1 and HTTP/3 servers. It ensures that the application can handle multiple versions of the HTTP protocol simultaneously and that the logging system captures these events accurately.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `app.prepare` method, which is called twice to set up the application for HTTP/1.1 and HTTP/3, respectively. Each call includes SSL configuration for secure connections. The `Sanic.serve_single()` method is then invoked to start the server. The test uses the `caplog` fixture to capture log messages at the INFO level, allowing assertions to be made on the expected log entries that indicate the servers have started.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of fixtures (`app` and `caplog`) to manage the application context and capture log output, respectively. It also utilizes assertions to validate that specific log messages are present in the captured log records, which is a common pattern in unit testing to verify side effects (in this case, logging) of the code being tested. Additionally, the use of the `@app.after_server_start` decorator to define a shutdown function demonstrates a clean-up pattern that ensures the server stops after the test completes, preventing resource leaks."
    },
    {
      "name": "test_server_starts_http1_and_http3_bad_order",
      "module": "test_server",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/http3/test_server.py",
      "line_number": 91,
      "end_line_number": 115,
      "source_code": "def test_server_starts_http1_and_http3_bad_order(app: Sanic, caplog):\n    @app.after_server_start\n    def shutdown(*_):\n        app.stop()\n\n    app.prepare(\n        version=1,\n        ssl={\n            \"cert\": localhost_dir / \"fullchain.pem\",\n            \"key\": localhost_dir / \"privkey.pem\",\n        },\n    )\n    message = (\n        \"Serving HTTP/3 instances as a secondary server is not supported. \"\n        \"There can only be a single HTTP/3 worker and it must be the first \"\n        \"instance prepared.\"\n    )\n    with pytest.raises(RuntimeError, match=message):\n        app.prepare(\n            version=3,\n            ssl={\n                \"cert\": localhost_dir / \"fullchain.pem\",\n                \"key\": localhost_dir / \"privkey.pem\",\n            },\n        )",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(sys.version_info < (3, 8) and (not UVLOOP_INSTALLED), reason='In 3.7 w/o uvloop the port is not always released')"
      ],
      "arguments": [
        "app",
        "caplog"
      ],
      "imports": [
        "logging",
        "sys",
        "asyncio.Event",
        "pathlib.Path",
        "pytest",
        "sanic.Sanic",
        "sanic.compat.UVLOOP_INSTALLED",
        "sanic.http.constants.HTTP"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_server_starts_http1_and_http3_bad_order` is designed to verify that the Sanic application correctly raises a `RuntimeError` when an attempt is made to prepare an HTTP/3 server instance after an HTTP/1.1 instance. This ensures that the server adheres to the requirement that HTTP/3 must be the first instance prepared.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks for the enforcement of server preparation order. It confirms that if an HTTP/1.1 server is prepared first, followed by an HTTP/3 server, the application raises a `RuntimeError` with a specific error message indicating that HTTP/3 cannot be a secondary server.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `app.prepare` method of the Sanic application. The first call to `app.prepare` sets up an HTTP/1.1 server with SSL certificates. The second call attempts to set up an HTTP/3 server, which is expected to fail. The error message is checked against a predefined string to ensure it matches the expected output when the invalid order is attempted.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that a specific exception is raised during the execution of the code block. This is a common pattern in unit testing to verify that error handling works as intended. Additionally, the use of a custom error message in the `match` parameter allows for precise validation of the error raised, ensuring that not only is an error raised, but it is the correct error for the specific scenario being tested."
    }
  ]
}