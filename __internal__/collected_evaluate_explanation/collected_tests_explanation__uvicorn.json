{
  "tests": [
    {
      "name": "test_run_invalid_app_config_combination",
      "module": "test_main",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_main.py",
      "line_number": 75,
      "end_line_number": 83,
      "source_code": "def test_run_invalid_app_config_combination(caplog: pytest.LogCaptureFixture) -> None:\n    with pytest.raises(SystemExit) as exit_exception:\n        run(app, reload=True)\n    assert exit_exception.value.code == 1\n    assert caplog.records[-1].name == \"uvicorn.error\"\n    assert caplog.records[-1].levelno == WARNING\n    assert caplog.records[-1].message == (\n        \"You must pass the application as an import string to enable \" \"'reload' or 'workers'.\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "caplog"
      ],
      "imports": [
        "inspect",
        "socket",
        "logging.WARNING",
        "httpx",
        "pytest",
        "tests.utils.run_server",
        "uvicorn.Server",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Scope",
        "uvicorn.config.Config",
        "uvicorn.main.run"
      ],
      "fixtures": [],
      "assertions": [
        "assert exit_exception.value.code == 1",
        "assert caplog.records[-1].name == 'uvicorn.error'",
        "assert caplog.records[-1].levelno == WARNING",
        "assert caplog.records[-1].message == \"You must pass the application as an import string to enable 'reload' or 'workers'.\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "run",
          "body": "def run(sockets):\n    pass"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_run_invalid_app_config_combination` is designed to verify that the `run` function of the Uvicorn server correctly handles an invalid application configuration when the `reload` option is enabled. Specifically, it checks that the application fails to start and exits with the appropriate error code.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when an invalid application configuration is provided (in this case, the application is not passed as an import string), the system raises a `SystemExit` exception with an exit code of `1`. Additionally, it verifies that a warning message is logged, indicating the specific requirement for the application configuration.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `run` function, which is expected to start the Uvicorn server. The test simulates a scenario where the `run` function is called with an invalid configuration (the `app` variable is not defined in the provided context). The `reload` parameter is set to `True`, which triggers the requirement for the application to be specified as an import string. The test captures the exit code and the log output to validate the expected behavior.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Exception Testing**: The test uses `pytest.raises` to assert that a `SystemExit` exception is raised, which is a common pattern for testing error conditions in Python.\n- **Log Capture**: The `caplog` fixture is employed to capture log messages generated during the test, allowing for verification of the specific warning message that should be logged when the invalid configuration is encountered.\n- **Assertions**: Multiple assertions are made to ensure both the exit code and the log message meet the expected criteria, providing a comprehensive check of the function's behavior under the test conditions."
    },
    {
      "name": "test_run_startup_failure",
      "module": "test_main",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_main.py",
      "line_number": 86,
      "end_line_number": 95,
      "source_code": "def test_run_startup_failure(caplog: pytest.LogCaptureFixture) -> None:\n    async def app(scope, receive, send):\n        assert scope[\"type\"] == \"lifespan\"\n        message = await receive()\n        if message[\"type\"] == \"lifespan.startup\":\n            raise RuntimeError(\"Startup failed\")\n\n    with pytest.raises(SystemExit) as exit_exception:\n        run(app, lifespan=\"on\")\n    assert exit_exception.value.code == 3",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "caplog"
      ],
      "imports": [
        "inspect",
        "socket",
        "logging.WARNING",
        "httpx",
        "pytest",
        "tests.utils.run_server",
        "uvicorn.Server",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Scope",
        "uvicorn.config.Config",
        "uvicorn.main.run"
      ],
      "fixtures": [],
      "assertions": [
        "assert exit_exception.value.code == 3",
        "assert scope['type'] == 'lifespan'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "run",
          "body": "def run(sockets):\n    pass"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_run_startup_failure` test is designed to verify that the application correctly handles a startup failure during the lifespan event. Specifically, it checks that the application raises a `SystemExit` exception with the appropriate exit code when a runtime error occurs during the startup phase.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when the application raises a `RuntimeError` during the \"lifespan.startup\" event, the `run` function exits the process with a specific exit code (in this case, code `3`). This behavior is crucial for signaling to the environment that the application failed to start properly.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `run` function, which is expected to manage the application lifecycle, including handling startup events. The test defines an asynchronous application (`app`) that simulates a startup failure by raising a `RuntimeError` when it receives a \"lifespan.startup\" message. The test then calls `run(app, lifespan=\"on\")` within a context that expects a `SystemExit` exception, capturing the exit code for verification.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test utilizes an asynchronous application and the `async def` syntax to define the app, which is essential for testing asynchronous code in Python.\n- **Exception Assertion**: The use of `pytest.raises(SystemExit)` allows the test to assert that a specific exception is raised, which is a common pattern in unit testing to verify error handling.\n- **Exit Code Verification**: The test checks the exit code of the raised exception to ensure that the application communicates the correct failure state, which is a critical aspect of robust application behavior."
    },
    {
      "name": "test_run_match_config_params",
      "module": "test_main",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_main.py",
      "line_number": 98,
      "end_line_number": 107,
      "source_code": "def test_run_match_config_params() -> None:\n    config_params = {\n        key: repr(value)\n        for key, value in inspect.signature(Config.__init__).parameters.items()\n        if key not in (\"self\", \"timeout_notify\", \"callback_notify\")\n    }\n    run_params = {\n        key: repr(value) for key, value in inspect.signature(run).parameters.items() if key not in (\"app_dir\",)\n    }\n    assert config_params == run_params",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "inspect",
        "socket",
        "logging.WARNING",
        "httpx",
        "pytest",
        "tests.utils.run_server",
        "uvicorn.Server",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Scope",
        "uvicorn.config.Config",
        "uvicorn.main.run"
      ],
      "fixtures": [],
      "assertions": [
        "assert config_params == run_params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_run_match_config_params` test aims to ensure that the parameters defined in the `Config` class's `__init__` method match the parameters expected by the `run` function. This is crucial for maintaining consistency between configuration and execution.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies that the configuration parameters required to initialize the `Config` object align with the parameters that the `run` function accepts. This alignment is essential for ensuring that the application can be configured correctly when it is started.\n\n**Code Being Tested and How It Works**:  \nThe test uses the `inspect.signature` function to retrieve the parameters of both the `Config.__init__` method and the `run` function. It constructs two dictionaries: `config_params`, which contains the parameters of the `Config` constructor (excluding `self`, `timeout_notify`, and `callback_notify`), and `run_params`, which contains the parameters of the `run` function (excluding `app_dir`). The test then asserts that these two dictionaries are equal, indicating that the parameters match.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Reflection**: The test employs Python's `inspect` module to dynamically retrieve function signatures, which allows for a flexible and maintainable way to compare parameters without hardcoding them.\n- **Assertions**: The use of an assertion to compare the two dictionaries ensures that any mismatch in parameters will cause the test to fail, providing immediate feedback on configuration consistency.\n- **Exclusion Logic**: The test demonstrates the use of exclusion logic to filter out specific parameters that are not relevant for the comparison, ensuring that only pertinent parameters are considered."
    },
    {
      "name": "test_get_subprocess",
      "module": "test_subprocess",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_subprocess.py",
      "line_number": 19,
      "end_line_number": 28,
      "source_code": "def test_get_subprocess() -> None:\n    fdsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    fd = fdsock.fileno()\n    config = Config(app=app, fd=fd)\n    config.load()\n\n    process = get_subprocess(config, server_run, [fdsock])\n    assert isinstance(process, SpawnProcess)\n\n    fdsock.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "socket",
        "unittest.mock.patch",
        "uvicorn._subprocess.SpawnProcess",
        "uvicorn._subprocess.get_subprocess",
        "uvicorn._subprocess.subprocess_started",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Scope",
        "uvicorn.config.Config"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(process, SpawnProcess)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "fdsock.close",
          "body": "def close(self):\n    assert not self.closed\n    self.closed = True"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_get_subprocess` function is designed to verify that the `get_subprocess` function correctly creates a subprocess when provided with a valid configuration and a server run function. It ensures that the subprocess is an instance of the `SpawnProcess` class, which indicates that the subprocess has been set up correctly for handling server operations.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that the object returned by `get_subprocess` is of type `SpawnProcess`. This confirms that the subprocess creation logic is functioning as intended and that the server can be run in a separate process, which is crucial for handling concurrent requests in an ASGI application.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `get_subprocess` function, which is responsible for spawning a new process to run the server. The test sets up a socket using `socket.socket`, retrieves its file descriptor, and creates a `Config` object with the application and file descriptor. The `get_subprocess` function is then called with this configuration and the `server_run` function, along with the socket. The assertion checks that the returned process is indeed a `SpawnProcess`, which is a class that encapsulates the logic for managing a subprocess in the Uvicorn server.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward unit testing pattern where a setup phase (creating a socket and configuration) is followed by an execution phase (calling `get_subprocess`) and a verification phase (asserting the type of the returned process). The use of assertions to validate the expected outcome is a common practice in unit tests, ensuring that the code behaves as expected. Additionally, the test ensures proper resource management by closing the socket after the test execution, which is a good practice to prevent resource leaks."
    },
    {
      "name": "test_subprocess_started",
      "module": "test_subprocess",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_subprocess.py",
      "line_number": 31,
      "end_line_number": 43,
      "source_code": "def test_subprocess_started() -> None:\n    fdsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    fd = fdsock.fileno()\n    config = Config(app=app, fd=fd)\n    config.load()\n\n    with patch(\"tests.test_subprocess.server_run\") as mock_run:\n        with patch.object(config, \"configure_logging\") as mock_config_logging:\n            subprocess_started(config, server_run, [fdsock], None)\n            mock_run.assert_called_once()\n            mock_config_logging.assert_called_once()\n\n    fdsock.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "socket",
        "unittest.mock.patch",
        "uvicorn._subprocess.SpawnProcess",
        "uvicorn._subprocess.get_subprocess",
        "uvicorn._subprocess.subprocess_started",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Scope",
        "uvicorn.config.Config"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "fdsock.close",
          "body": "def close(self):\n    assert not self.closed\n    self.closed = True"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_subprocess_started` function is designed to verify that the `subprocess_started` function correctly initiates the server process and configures logging when invoked with a valid configuration and socket.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the `server_run` function and the `configure_logging` method of the `Config` class are called exactly once during the execution of `subprocess_started`. This ensures that the server is set up and logging is configured as expected.\n\n**Code Being Tested and How It Works**:  \nThe test creates a socket and a configuration object for the server. It then uses the `subprocess_started` function, which is expected to start the server process and configure logging. The test uses mocking to intercept calls to `server_run` and `configure_logging`, allowing it to assert that these methods are called correctly without executing their actual implementations.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test employs the `patch` function from the `unittest.mock` module to replace the `server_run` function and the `configure_logging` method with mock objects. This isolates the test from the actual implementations, allowing for focused verification of interactions.\n- **Assertions**: The test uses `assert_called_once()` to ensure that the mocked methods are called exactly once, which is a common pattern in unit tests to verify that specific interactions occur as expected.\n- **Resource Management**: The test ensures that the socket is properly closed after its use, demonstrating good resource management practices in unit tests."
    },
    {
      "name": "test_config_should_reload_is_set",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 61,
      "end_line_number": 64,
      "source_code": "def test_config_should_reload_is_set(app: ASGIApplication, expected_should_reload: bool) -> None:\n    config = Config(app=app, reload=True)\n    assert config.reload is True\n    assert config.should_reload is expected_should_reload",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('app, expected_should_reload', [(asgi_app, False), ('tests.test_config:asgi_app', True)])"
      ],
      "arguments": [
        "app",
        "expected_should_reload"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert config.reload is True",
        "assert config.should_reload is expected_should_reload"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_config_should_reload_is_set` is designed to verify the behavior of the `Config` class in the Uvicorn application, specifically checking whether the `should_reload` attribute is set correctly when the `reload` parameter is enabled.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a `Config` object is instantiated with `reload=True`, the `reload` attribute is explicitly set to `True`, and it verifies that the `should_reload` attribute matches the expected boolean value passed as an argument (`expected_should_reload`).\n\n**Code Being Tested and How It Works**:  \nThe test creates an instance of the `Config` class with the application (`app`) and the `reload` flag set to `True`. It then asserts that the `reload` attribute of the `Config` instance is `True`, confirming that the configuration is set to allow reloading. Additionally, it checks that the `should_reload` attribute is equal to the `expected_should_reload` parameter, which is likely determined by the context or conditions under which the test is run.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses parameters (`app` and `expected_should_reload`), which suggests that it may be part of a parameterized test suite, allowing for multiple scenarios to be tested with different inputs.\n- **Assertions**: The test employs assertions to validate the state of the `Config` object, ensuring that both the `reload` and `should_reload` attributes are set as expected.\n- **Isolation**: The test focuses on a specific aspect of the `Config` class without dependencies on external systems, which is a hallmark of unit testing, ensuring that the test is reliable and repeatable."
    },
    {
      "name": "test_should_warn_on_invalid_reload_configuration",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 67,
      "end_line_number": 82,
      "source_code": "def test_should_warn_on_invalid_reload_configuration(tmp_path: Path, caplog: pytest.LogCaptureFixture) -> None:\n    config_class = Config(app=asgi_app, reload_dirs=[str(tmp_path)])\n    assert not config_class.should_reload\n    assert len(caplog.records) == 1\n    assert (\n        caplog.records[-1].message == \"Current configuration will not reload as not all conditions are met, \"\n        \"please refer to documentation.\"\n    )\n\n    config_no_reload = Config(app=\"tests.test_config:asgi_app\", reload_dirs=[str(tmp_path)])\n    assert not config_no_reload.should_reload\n    assert len(caplog.records) == 2\n    assert (\n        caplog.records[-1].message == \"Current configuration will not reload as not all conditions are met, \"\n        \"please refer to documentation.\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmp_path",
        "caplog"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert not config_class.should_reload",
        "assert len(caplog.records) == 1",
        "assert caplog.records[-1].message == 'Current configuration will not reload as not all conditions are met, please refer to documentation.'",
        "assert not config_no_reload.should_reload",
        "assert len(caplog.records) == 2",
        "assert caplog.records[-1].message == 'Current configuration will not reload as not all conditions are met, please refer to documentation.'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_should_warn_on_invalid_reload_configuration` is designed to verify that the `Config` class correctly identifies invalid reload configurations and logs appropriate warnings when the conditions for reloading are not met.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two scenarios: \n1. When a `Config` instance is created with a valid application and a reload directory, it asserts that the `should_reload` attribute is `False` and that a warning message is logged.\n2. It also verifies the same behavior when the application is specified as a string reference to a module, ensuring that the logging behavior remains consistent.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `Config` class, specifically its `should_reload` property, which determines if the application should reload based on the provided configuration. The test uses the `caplog` fixture from `pytest` to capture log messages generated during the execution of the code. The expected log message indicates that the current configuration does not meet the conditions for reloading, guiding the user to refer to the documentation for further details.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The test utilizes `tmp_path` to create a temporary directory for testing, ensuring that the test environment is isolated and does not affect the filesystem.\n- **Log Capture**: The `caplog` fixture is employed to capture and assert log messages, allowing the test to verify that the correct warnings are issued without needing to check the console output directly.\n- **Assertions**: Multiple assertions are used to validate both the state of the `Config` instance and the contents of the log records, ensuring comprehensive coverage of the expected behavior."
    },
    {
      "name": "test_reload_dir_is_set",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 85,
      "end_line_number": 93,
      "source_code": "def test_reload_dir_is_set(reload_directory_structure: Path, caplog: pytest.LogCaptureFixture) -> None:\n    app_dir = reload_directory_structure / \"app\"\n    with caplog.at_level(logging.INFO):\n        config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_dirs=[str(app_dir)])\n        assert len(caplog.records) == 1\n        assert caplog.records[-1].message == f\"Will watch for changes in these directories: {[str(app_dir)]}\"\n        assert config.reload_dirs == [app_dir]\n        config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_dirs=str(app_dir))\n        assert config.reload_dirs == [app_dir]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "reload_directory_structure",
        "caplog"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(caplog.records) == 1",
        "assert caplog.records[-1].message == f'Will watch for changes in these directories: {[str(app_dir)]}'",
        "assert config.reload_dirs == [app_dir]",
        "assert config.reload_dirs == [app_dir]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_reload_dir_is_set` unit test verifies that the `Config` class correctly sets the reload directories when provided with valid directory paths. It ensures that the application logs the appropriate message indicating which directories are being watched for changes.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that:\n1. The log captures the correct message when the reload configuration is set.\n2. The `reload_dirs` attribute of the `Config` instance is correctly populated with the specified directory paths.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `Config` class, specifically its constructor, which takes parameters for the application, reload flag, and reload directories. When the `reload` parameter is set to `True`, the class should log a message indicating the directories being watched. The test asserts that:\n- The log contains exactly one record.\n- The log message matches the expected format.\n- The `reload_dirs` attribute is set correctly, both when a list and a single string are provided.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Log Capture**: The test uses `caplog` to capture log messages generated during the execution of the test, allowing for verification of logging behavior.\n- **Path Manipulation**: The test utilizes the `Path` class from the `pathlib` module to handle file system paths in a platform-independent manner.\n- **Fixture Usage**: The test relies on the `reload_directory_structure` fixture to create a temporary directory structure for testing, ensuring that the test environment is isolated and reproducible."
    },
    {
      "name": "test_non_existant_reload_dir_is_not_set",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 96,
      "end_line_number": 104,
      "source_code": "def test_non_existant_reload_dir_is_not_set(reload_directory_structure: Path, caplog: pytest.LogCaptureFixture) -> None:\n    with as_cwd(reload_directory_structure), caplog.at_level(logging.WARNING):\n        config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_dirs=[\"reload\"])\n        assert config.reload_dirs == [reload_directory_structure]\n        assert (\n            caplog.records[-1].message\n            == \"Provided reload directories ['reload'] did not contain valid \"\n            + \"directories, watching current working directory.\"\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "reload_directory_structure",
        "caplog"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert config.reload_dirs == [reload_directory_structure]",
        "assert caplog.records[-1].message == \"Provided reload directories ['reload'] did not contain valid \" + 'directories, watching current working directory.'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_non_existant_reload_dir_is_not_set` verifies that when a non-existent directory is specified in the reload configuration, the system correctly handles this scenario by not setting the reload directories and logging a warning message.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the `reload_dirs` attribute of the `Config` object is set to the current working directory when the specified reload directory does not exist. It also ensures that a warning message is logged, indicating that the provided reload directories are invalid.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the `Config` class, which is initialized with an application reference and a list of reload directories. The `as_cwd` context manager temporarily changes the current working directory to `reload_directory_structure`. Inside this context, the test creates a `Config` instance with a reload directory that does not exist (`[\"reload\"]`). The assertions confirm that `config.reload_dirs` is equal to the current working directory and that the last log message matches the expected warning about the invalid reload directory.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The use of the `as_cwd` context manager allows for safe manipulation of the current working directory during the test, ensuring that the original directory is restored afterward.\n- **Log Capture**: The `caplog` fixture is employed to capture log messages generated during the test, enabling verification of the logging behavior.\n- **Assertions**: The test uses assertions to validate both the state of the `Config` object and the content of the log messages, ensuring comprehensive verification of the expected behavior."
    },
    {
      "name": "test_reload_subdir_removal",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 107,
      "end_line_number": 114,
      "source_code": "def test_reload_subdir_removal(reload_directory_structure: Path) -> None:\n    app_dir = reload_directory_structure / \"app\"\n\n    reload_dirs = [str(reload_directory_structure), \"app\", str(app_dir)]\n\n    with as_cwd(reload_directory_structure):\n        config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_dirs=reload_dirs)\n        assert config.reload_dirs == [reload_directory_structure]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "reload_directory_structure"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert config.reload_dirs == [reload_directory_structure]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_reload_subdir_removal` test verifies that the `Config` class correctly handles the removal of subdirectories from the reload directories when the application is set up for reloading. It ensures that only the specified top-level directory is included in the reload directories.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when a list of reload directories is provided, any subdirectories (in this case, the \"app\" subdirectory) are not included in the final configuration of reload directories. The expected outcome is that the `reload_dirs` attribute of the `Config` instance should only contain the root reload directory.\n\n**Code Being Tested and How It Works**:  \nThe test creates a directory structure using the `reload_directory_structure` fixture and sets the current working directory to this structure using the `as_cwd` context manager. It then initializes a `Config` object with the `reload` option enabled and a list of reload directories that includes both the root directory and its subdirectories. The assertion checks that the `reload_dirs` attribute of the `Config` instance only contains the root directory, confirming that subdirectories are effectively ignored.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Managers**: The use of the `as_cwd` context manager allows for temporary changes to the working directory, ensuring that the test environment is isolated and does not affect other tests.\n- **Fixtures**: The `reload_directory_structure` fixture sets up a controlled environment for the test, providing a consistent directory structure for testing.\n- **Assertions**: The test employs a straightforward assertion to validate the expected state of the `Config` object, which is a common practice in unit testing to confirm that the code behaves as intended."
    },
    {
      "name": "test_reload_included_dir_is_added_to_reload_dirs",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 117,
      "end_line_number": 131,
      "source_code": "def test_reload_included_dir_is_added_to_reload_dirs(\n    reload_directory_structure: Path,\n) -> None:\n    app_dir = reload_directory_structure / \"app\"\n    ext_dir = reload_directory_structure / \"ext\"\n\n    with as_cwd(reload_directory_structure):\n        config = Config(\n            app=\"tests.test_config:asgi_app\",\n            reload=True,\n            reload_dirs=[str(app_dir)],\n            reload_includes=[\"*.js\", str(ext_dir)],\n        )\n        assert frozenset(config.reload_dirs), frozenset([app_dir, ext_dir])\n        assert frozenset(config.reload_includes) == frozenset([\"*.js\", str(ext_dir)])",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "reload_directory_structure"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert frozenset(config.reload_dirs), frozenset([app_dir, ext_dir])",
        "assert frozenset(config.reload_includes) == frozenset(['*.js', str(ext_dir)])"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_reload_included_dir_is_added_to_reload_dirs` verifies that the configuration for the Uvicorn server correctly includes specified directories for reloading when the application is modified. It ensures that the directories specified in `reload_dirs` and `reload_includes` are accurately reflected in the `Config` object.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `reload_dirs` and `reload_includes` attributes of the `Config` object contain the expected values after initialization. It asserts that the application directory (`app_dir`) and the external directory (`ext_dir`) are included in the reload directories, and that the specified glob pattern for JavaScript files (`*.js`) and the external directory are included in the reload includes.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `Config` class, which is initialized with parameters that dictate how the Uvicorn server should handle file reloading. The `reload_dirs` parameter specifies directories to watch for changes, while `reload_includes` specifies file patterns to include. The test uses the `as_cwd` context manager to temporarily change the working directory to `reload_directory_structure`, ensuring that the paths are correctly resolved relative to this directory.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of context managers (`as_cwd`) to manage the working directory during the test execution, ensuring that the test environment is isolated and controlled. It also utilizes `frozenset` for assertions, which allows for an unordered comparison of the sets of directories and includes, ensuring that the order of elements does not affect the test outcome. This pattern is effective for verifying that the configuration behaves as expected regardless of the order in which directories or patterns are specified."
    },
    {
      "name": "test_reload_dir_subdirectories_are_removed",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 134,
      "end_line_number": 153,
      "source_code": "def test_reload_dir_subdirectories_are_removed(\n    reload_directory_structure: Path,\n) -> None:\n    app_dir = reload_directory_structure / \"app\"\n    app_sub_dir = app_dir / \"sub\"\n    ext_dir = reload_directory_structure / \"ext\"\n    ext_sub_dir = ext_dir / \"sub\"\n\n    with as_cwd(reload_directory_structure):\n        config = Config(\n            app=\"tests.test_config:asgi_app\",\n            reload=True,\n            reload_dirs=[\n                str(app_dir),\n                str(app_sub_dir),\n                str(ext_sub_dir),\n                str(ext_dir),\n            ],\n        )\n        assert frozenset(config.reload_dirs) == frozenset([app_dir, ext_dir])",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "reload_directory_structure"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert frozenset(config.reload_dirs) == frozenset([app_dir, ext_dir])"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_reload_dir_subdirectories_are_removed` aims to verify that the configuration for the Uvicorn server correctly excludes subdirectories from the list of directories that should trigger a reload when changes are detected. This ensures that only the specified top-level directories are monitored for changes, preventing unnecessary reloads from subdirectory modifications.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when a list of directories (including subdirectories) is provided to the `Config` object, the resulting `reload_dirs` only contains the top-level directories. Specifically, it asserts that the `reload_dirs` set contains only `app_dir` and `ext_dir`, effectively confirming that `app_sub_dir` and `ext_sub_dir` are removed from consideration.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `Config` class from the Uvicorn library, which is responsible for managing server configurations, including which directories to monitor for changes. The test sets up a context manager (`as_cwd`) to temporarily change the working directory to a specified path (`reload_directory_structure`). It then initializes a `Config` instance with a list of directories, including subdirectories. The assertion checks that the `reload_dirs` attribute of the `Config` instance only includes the intended top-level directories, confirming that the logic for filtering out subdirectories is functioning correctly.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Context Management**: The use of the `as_cwd` context manager allows for safe manipulation of the current working directory, ensuring that the original directory is restored after the test.\n- **Path Handling**: The test utilizes the `Path` class from the `pathlib` module for robust path manipulations, enhancing readability and reliability.\n- **Set Comparison**: The use of `frozenset` for assertions allows for an unordered comparison of the directory lists, ensuring that the test is not sensitive to the order of elements in the lists being compared. This is particularly useful when verifying collections where order is not guaranteed."
    },
    {
      "name": "test_reload_excluded_subdirectories_are_removed",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 156,
      "end_line_number": 170,
      "source_code": "def test_reload_excluded_subdirectories_are_removed(\n    reload_directory_structure: Path,\n) -> None:\n    app_dir = reload_directory_structure / \"app\"\n    app_sub_dir = app_dir / \"sub\"\n\n    with as_cwd(reload_directory_structure):\n        config = Config(\n            app=\"tests.test_config:asgi_app\",\n            reload=True,\n            reload_excludes=[str(app_dir), str(app_sub_dir)],\n        )\n        assert frozenset(config.reload_dirs) == frozenset([reload_directory_structure])\n        assert frozenset(config.reload_dirs_excludes) == frozenset([app_dir])\n        assert frozenset(config.reload_excludes) == frozenset([str(app_dir), str(app_sub_dir)])",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "reload_directory_structure"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert frozenset(config.reload_dirs) == frozenset([reload_directory_structure])",
        "assert frozenset(config.reload_dirs_excludes) == frozenset([app_dir])",
        "assert frozenset(config.reload_excludes) == frozenset([str(app_dir), str(app_sub_dir)])"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_reload_excluded_subdirectories_are_removed` verifies that the configuration for the Uvicorn server correctly excludes specified subdirectories from being monitored for changes when the auto-reload feature is enabled. This ensures that changes in excluded directories do not trigger a reload of the application.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the `reload_dirs`, `reload_dirs_excludes`, and `reload_excludes` attributes of the `Config` object are set correctly based on the provided parameters. It specifically verifies that the main reload directory is set to the root directory, while the specified app directory and its subdirectory are excluded from the reload monitoring.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `Config` class, which is responsible for managing the application's configuration settings, including directories to watch for changes. The test sets up a context where the current working directory is changed to a temporary directory structure created by the `reload_directory_structure` fixture. It then initializes a `Config` object with the app path and reload settings, asserting that the directories are configured as expected. The `as_cwd` context manager temporarily changes the working directory, ensuring that the configuration is tested in the correct context.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Manager**: The use of the `as_cwd` context manager allows for a clean and temporary change of the working directory, ensuring that the test does not affect the global state.\n- **Assertions with `frozenset`**: The test employs `frozenset` to compare sets of directories, which is useful for ensuring that the order of elements does not affect the equality check. This pattern is effective for verifying that the configuration contains the expected directories regardless of their order.\n- **Fixture Usage**: The test relies on the `reload_directory_structure` fixture to create a controlled environment for testing, which promotes reusability and isolation of test cases."
    },
    {
      "name": "test_reload_includes_exclude_dir_patterns_are_matched",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 173,
      "end_line_number": 193,
      "source_code": "def test_reload_includes_exclude_dir_patterns_are_matched(\n    reload_directory_structure: Path, caplog: pytest.LogCaptureFixture\n) -> None:\n    with caplog.at_level(logging.INFO):\n        first_app_dir = reload_directory_structure / \"app_first\" / \"src\"\n        second_app_dir = reload_directory_structure / \"app_second\" / \"src\"\n\n        with as_cwd(reload_directory_structure):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\"*/src\"],\n                reload_excludes=[\"app\", \"*third*\"],\n            )\n            assert len(caplog.records) == 1\n            assert (\n                caplog.records[-1].message == \"Will watch for changes in these directories: \"\n                f\"{sorted([str(first_app_dir), str(second_app_dir)])}\"\n            )\n            assert frozenset(config.reload_dirs) == frozenset([first_app_dir, second_app_dir])\n            assert config.reload_includes == [\"*/src\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "reload_directory_structure",
        "caplog"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(caplog.records) == 1",
        "assert caplog.records[-1].message == f'Will watch for changes in these directories: {sorted([str(first_app_dir), str(second_app_dir)])}'",
        "assert frozenset(config.reload_dirs) == frozenset([first_app_dir, second_app_dir])",
        "assert config.reload_includes == ['*/src']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_reload_includes_exclude_dir_patterns_are_matched` is designed to verify that the configuration for directory reloading in the Uvicorn server correctly includes and excludes specified directory patterns. It ensures that the application only watches the intended directories for changes, which is crucial for efficient hot-reloading during development.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the logging output correctly reflects the directories being watched and that the configuration object (`Config`) accurately captures the included and excluded directories. It asserts that the directories specified in `reload_includes` and `reload_excludes` are processed correctly, ensuring that the application behaves as expected when monitoring file changes.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `Config` class, which is responsible for managing the application's reload settings. It sets up a context manager (`as_cwd`) to temporarily change the working directory to a test-specific structure. The `Config` instance is initialized with specific include and exclude patterns. The test then checks the log records to confirm that the expected message about the directories being watched is logged, and it verifies that the `reload_dirs` and `reload_includes` attributes of the `Config` instance contain the correct values.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Manager**: The use of `as_cwd` allows for a clean and isolated testing environment by changing the current working directory temporarily.\n- **Log Capture**: The `caplog` fixture is employed to capture log messages generated during the test, enabling assertions on logging behavior.\n- **Assertions**: Multiple assertions are used to validate the state of the `caplog` records and the configuration object, ensuring comprehensive verification of the expected outcomes."
    },
    {
      "name": "test_wsgi_app",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 196,
      "end_line_number": 202,
      "source_code": "def test_wsgi_app() -> None:\n    config = Config(app=wsgi_app, interface=\"wsgi\", proxy_headers=False)\n    config.load()\n\n    assert isinstance(config.loaded_app, WSGIMiddleware)\n    assert config.interface == \"wsgi\"\n    assert config.asgi_version == \"3.0\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(config.loaded_app, WSGIMiddleware)",
        "assert config.interface == 'wsgi'",
        "assert config.asgi_version == '3.0'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_wsgi_app` function is designed to verify the correct configuration and loading of a WSGI application within the `Config` class of the uvicorn repository. It ensures that the application is properly wrapped in the `WSGIMiddleware` and that the configuration parameters are set as expected.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks three key aspects: \n1. It confirms that the `loaded_app` attribute of the `Config` instance is an instance of `WSGIMiddleware`, indicating that the WSGI application has been correctly wrapped.\n2. It verifies that the `interface` attribute is set to \"wsgi\", ensuring that the configuration recognizes the application as a WSGI app.\n3. It checks that the `asgi_version` is set to \"3.0\", which is important for compatibility with ASGI standards.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `Config` class, which is responsible for loading and configuring applications. In this test, an instance of `Config` is created with a WSGI application (`wsgi_app`) and the interface type specified as \"wsgi\". The `load()` method is called to initialize the configuration, which internally sets up the application and its middleware. The assertions then validate that the application has been loaded correctly and that the configuration parameters are as expected.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate the state of the `Config` instance after loading the application. It uses `isinstance` to check the type of the loaded application, which is a common pattern in unit tests to ensure that the correct class is instantiated. Additionally, the test is structured to be simple and direct, focusing on a single aspect of functionality, which is a best practice in unit testing to ensure clarity and maintainability."
    },
    {
      "name": "test_proxy_headers",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 205,
      "end_line_number": 210,
      "source_code": "def test_proxy_headers() -> None:\n    config = Config(app=asgi_app)\n    config.load()\n\n    assert config.proxy_headers is True\n    assert isinstance(config.loaded_app, ProxyHeadersMiddleware)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert config.proxy_headers is True",
        "assert isinstance(config.loaded_app, ProxyHeadersMiddleware)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_proxy_headers` function is designed to verify the correct configuration of the `Config` class when it is initialized with an ASGI application. Specifically, it checks that the proxy headers feature is enabled and that the application is wrapped in the `ProxyHeadersMiddleware`.\n\n**Specific Functionality or Behavior Verified**:  \nThis test asserts two key behaviors: \n1. It confirms that the `proxy_headers` attribute of the `Config` instance is set to `True`, indicating that the application is configured to handle proxy headers.\n2. It checks that the `loaded_app` attribute of the `Config` instance is an instance of `ProxyHeadersMiddleware`, ensuring that the middleware is correctly applied to the application.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `Config` class, which is responsible for loading and configuring an ASGI application. When the `load` method is called, it initializes the application and applies any specified middleware, such as `ProxyHeadersMiddleware`. This middleware modifies the request's client and scheme information based on the `X-Forwarded-Proto` and `X-Forwarded-For` headers, which are commonly set by proxies.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs direct assertions to validate the state of the `Config` instance after loading the application. It uses `assert` statements to check boolean conditions and type checks, which is a straightforward and effective approach in unit testing. The test is also structured to be simple and focused, ensuring that it only verifies the specific behavior related to proxy headers without introducing unnecessary complexity."
    },
    {
      "name": "test_app_unimportable_module",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 213,
      "end_line_number": 216,
      "source_code": "def test_app_unimportable_module() -> None:\n    config = Config(app=\"no.such:app\")\n    with pytest.raises(ImportError):\n        config.load()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_app_unimportable_module` test is designed to verify that the `Config` class correctly raises an `ImportError` when an application specified by an invalid module path (in this case, `\"no.such:app\"`) is attempted to be loaded.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks the error handling behavior of the `Config.load()` method when it encounters a module that cannot be imported. It ensures that the system responds appropriately by raising an `ImportError`, which indicates that the application cannot be found.\n\n**Code Being Tested and How It Works**:  \nThe test creates an instance of the `Config` class with an invalid application path. It then calls the `load()` method within a context manager that expects an `ImportError` to be raised. If the error is raised as expected, the test passes; if not, it fails, indicating that the error handling in the `load()` method is not functioning correctly.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises()` context manager, which is a common pattern in unit testing for asserting that specific exceptions are raised during the execution of a block of code. This technique enhances readability and clarity, making it explicit that the test is focused on verifying the occurrence of an exception under certain conditions. Additionally, the test is structured to be concise and focused, adhering to best practices in unit testing by isolating a single behavior for verification."
    },
    {
      "name": "test_app_unimportable_other",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 219,
      "end_line_number": 229,
      "source_code": "def test_app_unimportable_other(caplog: pytest.LogCaptureFixture) -> None:\n    config = Config(app=\"tests.test_config:app\")\n    with pytest.raises(SystemExit):\n        config.load()\n    error_messages = [\n        record.message for record in caplog.records if record.name == \"uvicorn.error\" and record.levelname == \"ERROR\"\n    ]\n    assert (\n        'Error loading ASGI app. Attribute \"app\" not found in module \"tests.test_config\".'  # noqa: E501\n        == error_messages.pop(0)\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "caplog"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'Error loading ASGI app. Attribute \"app\" not found in module \"tests.test_config\".' == error_messages.pop(0)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_app_unimportable_other` test is designed to verify that the Uvicorn server correctly handles the scenario where an ASGI application cannot be loaded due to a missing attribute in the specified module. Specifically, it checks that the appropriate error message is logged when the application cannot be found.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when an invalid application string is provided (in this case, `\"tests.test_config:app\"` where `app` does not exist), the system raises a `SystemExit` exception and logs an error message indicating the specific issue. The test confirms that the error message matches the expected output.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `Config.load()` method, which attempts to load the ASGI application specified by the `app` parameter. When the application cannot be found, it raises a `SystemExit` exception. The test captures log messages generated during this process using the `caplog` fixture, filtering for error messages from the `uvicorn.error` logger.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Exception Testing**: The test uses `pytest.raises(SystemExit)` to assert that the `load()` method raises a `SystemExit` exception when the application is unimportable.\n- **Log Capture**: The `caplog` fixture is employed to capture log messages, allowing the test to verify that the correct error message is logged.\n- **Assertion of Specific Output**: The test checks that the first error message logged matches the expected string, ensuring that the logging behavior is correct and informative for debugging purposes."
    },
    {
      "name": "test_app_factory",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 232,
      "end_line_number": 253,
      "source_code": "def test_app_factory(caplog: pytest.LogCaptureFixture) -> None:\n    def create_app() -> ASGIApplication:\n        return asgi_app\n\n    config = Config(app=create_app, factory=True, proxy_headers=False)\n    config.load()\n    assert config.loaded_app is asgi_app\n\n    # Flag not passed. In this case, successfully load the app, but issue a warning\n    # to indicate that an explicit flag is preferred.\n    caplog.clear()\n    config = Config(app=create_app, proxy_headers=False)\n    with caplog.at_level(logging.WARNING):\n        config.load()\n    assert config.loaded_app is asgi_app\n    assert len(caplog.records) == 1\n    assert \"--factory\" in caplog.records[0].message\n\n    # App not a no-arguments callable.\n    config = Config(app=asgi_app, factory=True)\n    with pytest.raises(SystemExit):\n        config.load()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "caplog"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert config.loaded_app is asgi_app",
        "assert config.loaded_app is asgi_app",
        "assert len(caplog.records) == 1",
        "assert '--factory' in caplog.records[0].message"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_app_factory` function is designed to verify the behavior of the `Config` class when an ASGI application is provided as a factory function. It checks that the application can be loaded correctly, that appropriate warnings are issued when certain flags are not used, and that errors are raised when the application does not conform to expected callable signatures.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies three main behaviors:\n1. The application can be successfully loaded when provided as a factory function with the `factory` flag set to `True`.\n2. A warning is logged when the application is loaded without the `factory` flag, indicating that it is preferred to use the flag.\n3. An error is raised when the application is not a no-argument callable while the `factory` flag is set to `True`.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `Config` class, which is responsible for loading ASGI applications. The `create_app` function is defined as a factory that returns `asgi_app`. The test first creates a `Config` instance with `create_app` and verifies that `loaded_app` matches `asgi_app`. It then tests the behavior when the `factory` flag is omitted, checking for a warning in the logs. Finally, it tests the scenario where `asgi_app` is passed directly with the `factory` flag, expecting a `SystemExit` exception due to the callable signature mismatch.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Fixture Usage**: The test utilizes the `caplog` fixture from `pytest` to capture log messages, allowing for verification of warning messages.\n- **Context Managers**: The use of `with` statements to set log levels and handle exceptions ensures that the test environment is clean and that resources are managed properly.\n- **Assertions**: Multiple assertions are employed to validate the expected outcomes, including checking the number of log records and the content of specific log messages.\n- **Exception Testing**: The test uses `pytest.raises` to assert that specific exceptions are raised under certain conditions, ensuring that error handling is functioning as intended."
    },
    {
      "name": "test_concrete_http_class",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 256,
      "end_line_number": 259,
      "source_code": "def test_concrete_http_class() -> None:\n    config = Config(app=asgi_app, http=H11Protocol)\n    config.load()\n    assert config.http_protocol_class is H11Protocol",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert config.http_protocol_class is H11Protocol"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_concrete_http_class` unit test is designed to verify that the `Config` class correctly initializes and loads the specified HTTP protocol class, specifically checking that the `http_protocol_class` attribute is set to `H11Protocol`.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks the behavior of the `Config` class when instantiated with a specific HTTP protocol. It ensures that after loading the configuration, the `http_protocol_class` attribute reflects the expected protocol class (`H11Protocol`), confirming that the configuration loading process correctly recognizes and assigns the specified protocol.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `Config` class, which is part of the Uvicorn server's configuration management. When an instance of `Config` is created with `app=asgi_app` and `http=H11Protocol`, the `load()` method is called to initialize the configuration. This method is expected to set various attributes, including `http_protocol_class`, based on the provided parameters. The assertion checks if `config.http_protocol_class` is indeed the `H11Protocol`, which is a specific implementation of the HTTP protocol.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern to validate the expected state of an object after a method call. It uses the `assert` statement to compare the actual value of `config.http_protocol_class` with the expected value (`H11Protocol`). This direct comparison is a common practice in unit testing to ensure that the system under test behaves as intended. Additionally, the test is structured to be simple and focused, which is a hallmark of effective unit tests, allowing for easy identification of failures related to the configuration loading process."
    },
    {
      "name": "test_socket_bind",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 262,
      "end_line_number": 267,
      "source_code": "def test_socket_bind() -> None:\n    config = Config(app=asgi_app)\n    config.load()\n    sock = config.bind_socket()\n    assert isinstance(sock, socket.socket)\n    sock.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(sock, socket.socket)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "sock.close",
          "body": "def close(self):\n    assert not self.closed\n    self.closed = True"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_socket_bind` function is designed to verify that the `bind_socket` method of the `Config` class correctly creates and returns a socket object when invoked. This ensures that the application can successfully bind to a socket, which is essential for network communication.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the object returned by `config.bind_socket()` is an instance of `socket.socket`. This confirms that the method is functioning as expected and that it is capable of creating a valid socket for the application.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `Config` class, specifically its `bind_socket` method. The test first initializes a `Config` object with an ASGI application (`asgi_app`), then calls `config.load()` to prepare the configuration. After that, it calls `config.bind_socket()`, which is expected to return a socket object. The test asserts that this object is indeed a socket instance and then closes the socket to clean up resources.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern using `assert isinstance(sock, socket.socket)` to validate the type of the returned object. It also follows good practices by closing the socket after the assertion to prevent resource leaks. The test is simple and direct, focusing solely on the functionality of the `bind_socket` method without introducing unnecessary complexity."
    },
    {
      "name": "test_ssl_config",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 270,
      "end_line_number": 281,
      "source_code": "def test_ssl_config(\n    tls_ca_certificate_pem_path: str,\n    tls_ca_certificate_private_key_path: str,\n) -> None:\n    config = Config(\n        app=asgi_app,\n        ssl_certfile=tls_ca_certificate_pem_path,\n        ssl_keyfile=tls_ca_certificate_private_key_path,\n    )\n    config.load()\n\n    assert config.is_ssl is True",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tls_ca_certificate_pem_path",
        "tls_ca_certificate_private_key_path"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert config.is_ssl is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_ssl_config` function is designed to verify that the SSL configuration is correctly set up in the `Config` class when valid SSL certificate and key file paths are provided. It ensures that the application is configured to use SSL by checking the `is_ssl` attribute.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `is_ssl` property of the `Config` instance is set to `True` after loading the configuration with valid SSL certificate and key file paths. This indicates that the application is expected to run with SSL enabled.\n\n**Code Being Tested and How It Works**:  \nThe test creates an instance of the `Config` class, passing in the application (`asgi_app`) and the paths to the SSL certificate and key files. The `load()` method is called on the `Config` instance, which presumably initializes the configuration and sets the `is_ssl` attribute based on the provided SSL files. The assertion checks that `config.is_ssl` is `True`, confirming that SSL is enabled.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test function accepts parameters (`tls_ca_certificate_pem_path` and `tls_ca_certificate_private_key_path`), which are likely provided by a test fixture or a parameterized test setup. This allows for testing with different SSL configurations without duplicating code.\n- **Assertions**: The use of assertions to validate the expected state of the `Config` instance after loading the configuration is a fundamental aspect of unit testing, ensuring that the code behaves as intended.\n- **Isolation**: The test focuses solely on the SSL configuration aspect of the `Config` class, isolating this functionality from other potential configurations, which is a best practice in unit testing."
    },
    {
      "name": "test_ssl_config_combined",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 284,
      "end_line_number": 291,
      "source_code": "def test_ssl_config_combined(tls_certificate_key_and_chain_path: str) -> None:\n    config = Config(\n        app=asgi_app,\n        ssl_certfile=tls_certificate_key_and_chain_path,\n    )\n    config.load()\n\n    assert config.is_ssl is True",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tls_certificate_key_and_chain_path"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert config.is_ssl is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_ssl_config_combined` unit test is designed to verify that the SSL configuration of the `Config` class correctly identifies when SSL is enabled using a combined certificate and key file.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `is_ssl` attribute of the `Config` instance is set to `True` when a valid SSL certificate file is provided. This indicates that the application is configured to use SSL for secure communication.\n\n**Code Being Tested and How It Works**:  \nThe test creates an instance of the `Config` class, passing in the application (`asgi_app`) and the path to the SSL certificate file (`tls_certificate_key_and_chain_path`). It then calls the `load()` method on the `Config` instance, which presumably initializes the configuration settings, including SSL parameters. After loading, the test asserts that `config.is_ssl` is `True`, confirming that the SSL configuration was successfully recognized.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test likely relies on a parameterized input (`tls_certificate_key_and_chain_path`), which allows for different certificate paths to be tested without modifying the test code. This is a common practice in unit testing to ensure that various scenarios can be validated efficiently.\n- **Assertion**: The use of an assertion (`assert config.is_ssl is True`) is a fundamental aspect of unit tests, providing a clear pass/fail outcome based on the expected behavior of the code under test."
    },
    {
      "name": "test_asgi_version",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 302,
      "end_line_number": 305,
      "source_code": "def test_asgi_version(app: ASGIApplication, expected_interface: Literal[\"2.0\", \"3.0\"]) -> None:\n    config = Config(app=app)\n    config.load()\n    assert config.asgi_version == expected_interface",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('app, expected_interface', [(asgi_app, '3.0'), (asgi2_app, '2.0')])"
      ],
      "arguments": [
        "app",
        "expected_interface"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert config.asgi_version == expected_interface"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_asgi_version` unit test is designed to verify that the ASGI application correctly reports its ASGI version as specified in the configuration. This ensures that the application adheres to the expected ASGI interface version, which is crucial for compatibility with ASGI servers and middleware.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the `asgi_version` attribute of the `Config` object matches the `expected_interface` parameter. This confirms that the application is configured to use the correct version of the ASGI specification, either \"2.0\" or \"3.0\".\n\n**Code Being Tested and How It Works**:  \nThe test creates an instance of the `Config` class, passing the ASGI application (`app`) to it. The `load()` method is called on the `Config` instance, which presumably initializes various configuration settings, including the ASGI version. The assertion then compares the `asgi_version` attribute of the `Config` instance to the `expected_interface`, ensuring they are equal.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses parameters (`app` and `expected_interface`) to allow for multiple test cases with different ASGI applications and expected versions, enhancing test coverage without duplicating code.\n- **Assertion**: The use of `assert` statements is a straightforward way to validate that the actual output matches the expected output, which is a common practice in unit testing.\n- **Isolation**: The test focuses solely on the configuration of the ASGI application, ensuring that it does not depend on external factors or the implementation details of the ASGI application itself. This isolation helps in identifying issues specifically related to configuration."
    },
    {
      "name": "test_log_config_default",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 317,
      "end_line_number": 333,
      "source_code": "def test_log_config_default(\n    mocked_logging_config_module: MagicMock,\n    use_colors: bool | None,\n    expected: bool | None,\n    logging_config: dict[str, Any],\n) -> None:\n    \"\"\"\n    Test that one can specify the use_colors option when using the default logging\n    config.\n    \"\"\"\n    config = Config(app=asgi_app, use_colors=use_colors, log_config=logging_config)\n    config.load()\n\n    mocked_logging_config_module.dictConfig.assert_called_once_with(logging_config)\n\n    (provided_dict_config,), _ = mocked_logging_config_module.dictConfig.call_args\n    assert provided_dict_config[\"formatters\"][\"default\"][\"use_colors\"] == expected",
      "docstring": "Test that one can specify the use_colors option when using the default logging\nconfig.",
      "decorators": [
        "pytest.mark.parametrize('use_colors, expected', [pytest.param(None, None, id='use_colors_not_provided'), pytest.param('invalid', None, id='use_colors_invalid_value'), pytest.param(True, True, id='use_colors_enabled'), pytest.param(False, False, id='use_colors_disabled')])"
      ],
      "arguments": [
        "mocked_logging_config_module",
        "use_colors",
        "expected",
        "logging_config"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert provided_dict_config['formatters']['default']['use_colors'] == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_log_config_default` function is designed to verify that the `use_colors` option can be correctly specified and applied when using the default logging configuration in the Uvicorn application server.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a `Config` object is created with a specified `use_colors` value, the resulting logging configuration correctly reflects this value in the formatter settings. Specifically, it asserts that the `use_colors` key in the logging configuration's default formatter matches the expected value.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `Config` class, which is responsible for setting up the application configuration, including logging. The `load` method of the `Config` class is called to initialize the logging configuration. The test then verifies that the `dictConfig` method of the mocked logging configuration module is called with the expected logging configuration. It extracts the provided configuration from the call arguments and checks that the `use_colors` setting is as expected.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test uses a `MagicMock` to simulate the logging configuration module, allowing the test to verify interactions without relying on the actual logging implementation.\n- **Parameterization**: The test is likely part of a parameterized test suite, as indicated by the presence of parameters like `use_colors`, `expected`, and `logging_config`, which allows for multiple scenarios to be tested with different inputs.\n- **Assertions**: The test employs assertions to validate that the expected behavior occurs, specifically checking the call to `dictConfig` and the correctness of the `use_colors` setting in the logging configuration."
    },
    {
      "name": "test_log_config_json",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 336,
      "end_line_number": 351,
      "source_code": "def test_log_config_json(\n    mocked_logging_config_module: MagicMock,\n    logging_config: dict[str, Any],\n    json_logging_config: str,\n    mocker: MockerFixture,\n) -> None:\n    \"\"\"\n    Test that one can load a json config from disk.\n    \"\"\"\n    mocked_open = mocker.patch(\"uvicorn.config.open\", mocker.mock_open(read_data=json_logging_config))\n\n    config = Config(app=asgi_app, log_config=\"log_config.json\")\n    config.load()\n\n    mocked_open.assert_called_once_with(\"log_config.json\")\n    mocked_logging_config_module.dictConfig.assert_called_once_with(logging_config)",
      "docstring": "Test that one can load a json config from disk.",
      "decorators": [],
      "arguments": [
        "mocked_logging_config_module",
        "logging_config",
        "json_logging_config",
        "mocker"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mocker.patch('uvicorn.config.open', mocker.mock_open(read_data=json_logging_config))"
      ],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_log_config_json` unit test is designed to verify that the application can successfully load a JSON logging configuration from a specified file on disk.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the `Config` class correctly opens a JSON configuration file and that the logging configuration is applied using the `dictConfig` method from the logging module. It ensures that the file is accessed correctly and that the expected configuration is passed to the logging setup.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `Config` class from the `uvicorn` module. It creates a mock for the built-in `open` function to simulate reading from a JSON file (`log_config.json`). The `load` method of the `Config` instance is called, which is expected to read the JSON data and configure logging accordingly. The assertions check that the `open` function was called with the correct filename and that the `dictConfig` method was called with the expected logging configuration.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test uses `mocker.patch` to replace the `open` function with a mock that returns predefined JSON data, allowing the test to run without needing an actual file.\n- **Assertions**: It employs assertions to verify that the mocked `open` function was called exactly once with the correct argument and that the logging configuration was set up as expected.\n- **Dependency Injection**: The test uses fixtures to inject dependencies like `mocked_logging_config_module`, `logging_config`, and `json_logging_config`, promoting modularity and reusability in tests."
    },
    {
      "name": "test_log_config_yaml",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 355,
      "end_line_number": 371,
      "source_code": "def test_log_config_yaml(\n    mocked_logging_config_module: MagicMock,\n    logging_config: dict[str, Any],\n    yaml_logging_config: str,\n    mocker: MockerFixture,\n    config_filename: str,\n) -> None:\n    \"\"\"\n    Test that one can load a yaml config from disk.\n    \"\"\"\n    mocked_open = mocker.patch(\"uvicorn.config.open\", mocker.mock_open(read_data=yaml_logging_config))\n\n    config = Config(app=asgi_app, log_config=config_filename)\n    config.load()\n\n    mocked_open.assert_called_once_with(config_filename)\n    mocked_logging_config_module.dictConfig.assert_called_once_with(logging_config)",
      "docstring": "Test that one can load a yaml config from disk.",
      "decorators": [
        "pytest.mark.parametrize('config_filename', ['log_config.yml', 'log_config.yaml'])"
      ],
      "arguments": [
        "mocked_logging_config_module",
        "logging_config",
        "yaml_logging_config",
        "mocker",
        "config_filename"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mocker.patch('uvicorn.config.open', mocker.mock_open(read_data=yaml_logging_config))"
      ],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_log_config_yaml` function is designed to verify that the Uvicorn application can successfully load a YAML logging configuration from a specified file on disk.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the `Config` class correctly opens the specified YAML configuration file and that the logging configuration is applied using the `dictConfig` method from the logging module. It ensures that the file is read exactly once and that the loaded configuration matches the expected structure.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `Config` class, specifically its `load` method, which is responsible for loading the logging configuration. The method checks if the `log_config` attribute is a string (indicating a file path) and attempts to read the file's contents. If the file ends with `.yaml` or `.yml`, it uses the PyYAML library to parse the file and then applies the configuration using `logging.config.dictConfig`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test uses `mocker.patch` to replace the built-in `open` function with a mock that simulates reading from a file, allowing the test to run without needing an actual file on disk.\n- **Assertions**: The test asserts that the mocked `open` function is called exactly once with the correct filename and that the `dictConfig` method is called with the expected logging configuration dictionary.\n- **Dependency Injection**: The test leverages fixtures to inject dependencies like `mocked_logging_config_module`, `logging_config`, and `yaml_logging_config`, promoting reusability and separation of concerns in the test setup."
    },
    {
      "name": "test_log_config_file",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 375,
      "end_line_number": 385,
      "source_code": "def test_log_config_file(\n    mocked_logging_config_module: MagicMock,\n    config_file: str | configparser.RawConfigParser | typing.IO[Any],\n) -> None:\n    \"\"\"\n    Test that one can load a configparser config from disk.\n    \"\"\"\n    config = Config(app=asgi_app, log_config=config_file)\n    config.load()\n\n    mocked_logging_config_module.fileConfig.assert_called_once_with(config_file, disable_existing_loggers=False)",
      "docstring": "Test that one can load a configparser config from disk.",
      "decorators": [
        "pytest.mark.parametrize('config_file', ['log_config.ini', configparser.ConfigParser(), io.StringIO()])"
      ],
      "arguments": [
        "mocked_logging_config_module",
        "config_file"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_log_config_file` unit test verifies that a logging configuration can be successfully loaded from a specified configuration file using Python's `configparser`. It ensures that the logging configuration is applied correctly by asserting that the appropriate method is called with the expected parameters.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the `fileConfig` method of the `logging.config` module is called exactly once with the provided configuration file and that the `disable_existing_loggers` parameter is set to `False`. This confirms that the logging system is configured to respect existing loggers when loading the configuration.\n\n**Code Being Tested and How It Works**:  \nThe code under test is part of a `Config` class that handles application configuration, including logging settings. The `log_config` parameter can accept various types, including a string representing a file path, a `configparser.RawConfigParser` object, or an IO stream. The `load` method of the `Config` class is responsible for loading the configuration, which in turn calls `logging.config.fileConfig` if the `log_config` is a string or a `configparser` object. The test ensures that this loading mechanism works correctly for the specified input types.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test uses a `MagicMock` to replace the actual logging configuration module, allowing the test to verify interactions without affecting the global logging configuration.\n- **Parameterization**: The test is parameterized with different types of `config_file` inputs (a string, a `configparser` object, and an IO stream), which allows for comprehensive testing of the `log_config` handling in a single test function.\n- **Assertions**: The test employs assertions to confirm that the expected method was called with the correct arguments, ensuring that the behavior of the logging configuration loading is as intended."
    },
    {
      "name": "test_env_file",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 402,
      "end_line_number": 421,
      "source_code": "def test_env_file(\n    web_concurrency: int,\n    forwarded_allow_ips: str,\n    caplog: pytest.LogCaptureFixture,\n    tmp_path: Path,\n) -> None:\n    \"\"\"\n    Test that one can load environment variables using an env file.\n    \"\"\"\n    fp = tmp_path / \".env\"\n    content = f\"WEB_CONCURRENCY={web_concurrency}\\n\" f\"FORWARDED_ALLOW_IPS={forwarded_allow_ips}\\n\"\n    fp.write_text(content)\n    with caplog.at_level(logging.INFO):\n        config = Config(app=asgi_app, env_file=fp)\n        config.load()\n\n    assert config.workers == int(str(os.getenv(\"WEB_CONCURRENCY\")))\n    assert config.forwarded_allow_ips == os.getenv(\"FORWARDED_ALLOW_IPS\")\n    assert len(caplog.records) == 1\n    assert f\"Loading environment from '{fp}'\" in caplog.records[0].message",
      "docstring": "Test that one can load environment variables using an env file.",
      "decorators": [],
      "arguments": [
        "web_concurrency",
        "forwarded_allow_ips",
        "caplog",
        "tmp_path"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert config.workers == int(str(os.getenv('WEB_CONCURRENCY')))",
        "assert config.forwarded_allow_ips == os.getenv('FORWARDED_ALLOW_IPS')",
        "assert len(caplog.records) == 1",
        "assert f\"Loading environment from '{fp}'\" in caplog.records[0].message"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_env_file` function is designed to verify that environment variables can be successfully loaded from a specified `.env` file. This ensures that the application can correctly read configuration settings from an external file, which is a common practice for managing environment-specific configurations.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the `Config` class correctly sets the `workers` and `forwarded_allow_ips` attributes based on the values defined in the `.env` file. It also verifies that a log message is generated indicating that the environment variables are being loaded from the specified file.\n\n**Code Being Tested and How It Works**:  \nThe test creates a temporary `.env` file containing two environment variables: `WEB_CONCURRENCY` and `FORWARDED_ALLOW_IPS`. It then instantiates a `Config` object with the path to this file and calls the `load()` method. The `load()` method is expected to read the environment variables from the file and set the corresponding attributes in the `Config` instance. The assertions confirm that the values are correctly set and that the appropriate log message is generated.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses parameters (`web_concurrency` and `forwarded_allow_ips`) to allow for multiple test cases with different values, enhancing test coverage.\n- **Temporary File Handling**: The use of `tmp_path` ensures that the test does not affect the actual filesystem, as it creates a temporary file that is cleaned up after the test runs.\n- **Log Capture**: The `caplog` fixture is employed to capture log messages during the test, allowing for verification of logging behavior without requiring external log monitoring.\n- **Assertions**: Multiple assertions are used to validate different aspects of the configuration loading process, ensuring comprehensive verification of the functionality."
    },
    {
      "name": "test_config_access_log",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 431,
      "end_line_number": 436,
      "source_code": "def test_config_access_log(access_log: bool, handlers: int) -> None:\n    config = Config(app=asgi_app, access_log=access_log)\n    config.load()\n\n    assert len(logging.getLogger(\"uvicorn.access\").handlers) == handlers\n    assert config.access_log == access_log",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('access_log, handlers', [pytest.param(True, 1, id='access log enabled should have single handler'), pytest.param(False, 0, id=\"access log disabled shouldn't have handlers\")])"
      ],
      "arguments": [
        "access_log",
        "handlers"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(logging.getLogger('uvicorn.access').handlers) == handlers",
        "assert config.access_log == access_log"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_config_access_log` function is designed to verify the behavior of the `Config` class in relation to the access logging feature. Specifically, it checks whether the correct number of logging handlers is set up based on the `access_log` configuration parameter.\n\n**Specific Functionality or Behavior Verified**:  \nThis test verifies two key aspects: \n1. The number of handlers associated with the `uvicorn.access` logger matches the expected count based on the `access_log` parameter (1 handler if access logging is enabled, 0 if disabled).\n2. The `access_log` attribute of the `Config` instance correctly reflects the value passed during initialization.\n\n**Code Being Tested and How It Works**:  \nThe test creates an instance of the `Config` class, passing in the `access_log` parameter. It then calls the `load` method, which is expected to configure the logging settings. After loading, the test checks the number of handlers for the `uvicorn.access` logger using `logging.getLogger(\"uvicorn.access\").handlers` and compares it to the expected `handlers` count. It also asserts that the `config.access_log` property matches the input `access_log` value.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.mark.parametrize` decorator to run the test with multiple sets of input values for `access_log` and `handlers`. This parameterization allows for efficient testing of different scenarios (enabled vs. disabled access logging) without duplicating code. The use of assertions to validate the expected outcomes is a standard practice in unit testing, ensuring that the code behaves as intended under various conditions."
    },
    {
      "name": "test_config_log_level",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 440,
      "end_line_number": 447,
      "source_code": "def test_config_log_level(log_level: int) -> None:\n    config = Config(app=asgi_app, log_level=log_level)\n    config.load()\n\n    assert logging.getLogger(\"uvicorn.error\").level == log_level\n    assert logging.getLogger(\"uvicorn.access\").level == log_level\n    assert logging.getLogger(\"uvicorn.asgi\").level == log_level\n    assert config.log_level == log_level",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('log_level', [5, 10, 20, 30, 40, 50])"
      ],
      "arguments": [
        "log_level"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert logging.getLogger('uvicorn.error').level == log_level",
        "assert logging.getLogger('uvicorn.access').level == log_level",
        "assert logging.getLogger('uvicorn.asgi').level == log_level",
        "assert config.log_level == log_level"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_config_log_level` function is designed to verify that the logging configuration for the Uvicorn application is correctly set according to the specified log level. It ensures that the log level for various loggers (error, access, and ASGI) matches the expected value provided during the configuration.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that after loading the configuration, the log levels of the loggers `uvicorn.error`, `uvicorn.access`, and `uvicorn.asgi` are all set to the same value as the `log_level` parameter. Additionally, it verifies that the `log_level` attribute of the `Config` instance itself reflects the same value.\n\n**Code Being Tested and How It Works**:  \nThe test instantiates a `Config` object with an application (`asgi_app`) and a specified `log_level`. It then calls the `load()` method on the `Config` instance, which is expected to configure the logging settings. The assertions that follow check the log levels of the specified loggers using `logging.getLogger()` and compare them to the `log_level` passed to the test.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs parameterized testing, allowing it to run multiple scenarios with different log levels (including `None` and various integer values). This approach helps ensure comprehensive coverage of potential log level configurations. The use of assertions to validate the state of the loggers after configuration is a common practice in unit testing, ensuring that the system behaves as expected under different conditions."
    },
    {
      "name": "test_config_log_effective_level",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 452,
      "end_line_number": 467,
      "source_code": "def test_config_log_effective_level(log_level: int, uvicorn_logger_level: int) -> None:\n    default_level = 30\n    log_config = {\n        \"version\": 1,\n        \"disable_existing_loggers\": False,\n        \"loggers\": {\n            \"uvicorn\": {\"level\": uvicorn_logger_level},\n        },\n    }\n    config = Config(app=asgi_app, log_level=log_level, log_config=log_config)\n    config.load()\n\n    effective_level = log_level or uvicorn_logger_level or default_level\n    assert logging.getLogger(\"uvicorn.error\").getEffectiveLevel() == effective_level\n    assert logging.getLogger(\"uvicorn.access\").getEffectiveLevel() == effective_level\n    assert logging.getLogger(\"uvicorn.asgi\").getEffectiveLevel() == effective_level",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('log_level', [None, 0, 5, 10, 20, 30, 40, 50])",
        "pytest.mark.parametrize('uvicorn_logger_level', [0, 5, 10, 20, 30, 40, 50])"
      ],
      "arguments": [
        "log_level",
        "uvicorn_logger_level"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert logging.getLogger('uvicorn.error').getEffectiveLevel() == effective_level",
        "assert logging.getLogger('uvicorn.access').getEffectiveLevel() == effective_level",
        "assert logging.getLogger('uvicorn.asgi').getEffectiveLevel() == effective_level"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_config_log_effective_level` test is designed to verify that the effective logging level for the Uvicorn application is correctly determined based on the provided `log_level` and `uvicorn_logger_level`. It ensures that the logging configuration behaves as expected when different logging levels are set.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the effective logging level for the Uvicorn loggers (`uvicorn.error`, `uvicorn.access`, and `uvicorn.asgi`) matches the expected value, which is derived from the provided `log_level`, `uvicorn_logger_level`, or a default level of 30 if both are not set. It confirms that the logging system correctly prioritizes these levels.\n\n**Code Being Tested and How It Works**:  \nThe test creates a logging configuration dictionary and initializes a `Config` object with the application and the specified logging levels. The `config.load()` method is called to apply the logging configuration. The effective logging level is calculated as `log_level or uvicorn_logger_level or default_level`, and assertions are made to ensure that the effective levels of the specified loggers match this calculated effective level. The relevant code being tested is primarily the logging configuration and the logic that determines the effective logging level.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.mark.parametrize` decorator to run multiple test cases with different combinations of `log_level` and `uvicorn_logger_level`. This parameterization allows for comprehensive coverage of various scenarios, ensuring that the logging behavior is validated across a range of inputs. Additionally, the use of assertions to compare the actual logger levels against the expected effective level is a standard practice in unit testing to confirm correctness."
    },
    {
      "name": "test_ws_max_size",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 470,
      "end_line_number": 473,
      "source_code": "def test_ws_max_size() -> None:\n    config = Config(app=asgi_app, ws_max_size=1000)\n    config.load()\n    assert config.ws_max_size == 1000",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert config.ws_max_size == 1000"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_ws_max_size` unit test is designed to verify that the `Config` class correctly initializes and retains the specified maximum WebSocket message size (`ws_max_size`). This ensures that the configuration for WebSocket connections can be set and accessed as intended.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when a `Config` object is created with a specific `ws_max_size` value (in this case, 1000), the `ws_max_size` attribute of the `Config` instance reflects this value after the configuration is loaded. This confirms that the initialization logic for the WebSocket maximum size is functioning correctly.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `Config` class, specifically its constructor and the `load` method. The `Config` class is initialized with parameters, including `ws_max_size`. The `load` method is called to set up the configuration, and the test asserts that the `ws_max_size` attribute of the `config` object equals 1000. This indicates that the value passed during initialization is correctly stored and accessible.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern, using `assert` to validate the expected state of the `config` object after loading. It does not utilize any mocking or complex setup, making it a simple and effective unit test that focuses on verifying a single aspect of the `Config` class's behavior. The test is also self-contained, ensuring that it can be run independently without dependencies on other tests or external systems."
    },
    {
      "name": "test_ws_max_queue",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 476,
      "end_line_number": 479,
      "source_code": "def test_ws_max_queue() -> None:\n    config = Config(app=asgi_app, ws_max_queue=64)\n    config.load()\n    assert config.ws_max_queue == 64",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert config.ws_max_queue == 64"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_ws_max_queue` unit test is to verify that the `Config` class correctly initializes and retains the `ws_max_queue` attribute when set during configuration. This ensures that the WebSocket maximum queue size is configurable and that the configuration is applied as expected.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that when a `Config` object is created with a `ws_max_queue` value of 64, this value is correctly stored and can be accessed afterward. The assertion confirms that the expected value matches the actual value stored in the configuration.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `Config` class, which is responsible for managing application settings, including WebSocket configurations. The `ws_max_queue` parameter is passed to the `Config` constructor, and the `load()` method is called to initialize the configuration. The test then asserts that the `ws_max_queue` attribute of the `config` object equals 64, confirming that the initialization process correctly sets this attribute.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern, where the expected outcome (64) is compared against the actual outcome (`config.ws_max_queue`). This is a common practice in unit testing to validate that a specific piece of functionality behaves as intended. The use of a dedicated test function (`test_ws_max_queue`) also follows the convention of isolating tests for clarity and maintainability."
    },
    {
      "name": "test_bind_unix_socket_works_with_reload_or_workers",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 491,
      "end_line_number": 500,
      "source_code": "def test_bind_unix_socket_works_with_reload_or_workers(\n    tmp_path: Path, reload: bool, workers: int, short_socket_name: str\n):  # pragma: py-win32\n    config = Config(app=asgi_app, uds=short_socket_name, reload=reload, workers=workers)\n    config.load()\n    sock = config.bind_socket()\n    assert isinstance(sock, socket.socket)\n    assert sock.family == socket.AF_UNIX\n    assert sock.getsockname() == short_socket_name\n    sock.close()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reload, workers', [(True, 1), (False, 2)], ids=['--reload=True --workers=1', '--reload=False --workers=2'])",
        "pytest.mark.skipif(sys.platform == 'win32', reason='require unix-like system')"
      ],
      "arguments": [
        "tmp_path",
        "reload",
        "workers",
        "short_socket_name"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(sock, socket.socket)",
        "assert sock.family == socket.AF_UNIX",
        "assert sock.getsockname() == short_socket_name"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "sock.close",
          "body": "def close(self):\n    assert not self.closed\n    self.closed = True"
        },
        {
          "name": "sock.getsockname",
          "body": "def getsockname(self):\n    return self.sockname"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_bind_unix_socket_works_with_reload_or_workers` is designed to verify that the `Config` class can successfully bind a UNIX domain socket when the server is configured with specific parameters, such as enabling reloads or specifying the number of worker processes.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the socket created by the `bind_socket` method is indeed a UNIX socket, and it confirms that the socket's name matches the expected socket name provided in the test parameters. This ensures that the configuration settings are correctly applied and that the server can operate as intended with UNIX sockets.\n\n**Code Being Tested and How It Works**:  \nThe test instantiates a `Config` object with parameters including the application (`asgi_app`), the UNIX domain socket name (`short_socket_name`), and flags for reloading and worker processes. It then calls the `load` method to prepare the configuration and subsequently calls `bind_socket` to create the socket. The assertions check the type of the socket, its family (ensuring it is a UNIX socket), and its name (ensuring it matches the expected value). Finally, the socket is closed to free up resources.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs parameterized testing through the use of pytest's `@pytest.mark.parametrize`, allowing it to run multiple scenarios with different combinations of the `reload` and `workers` parameters. This approach enhances test coverage and ensures that various configurations are validated without duplicating code. Additionally, the test uses assertions to validate the expected outcomes, which is a standard practice in unit testing to ensure that the code behaves as intended."
    },
    {
      "name": "test_bind_fd_works_with_reload_or_workers",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 512,
      "end_line_number": 522,
      "source_code": "def test_bind_fd_works_with_reload_or_workers(reload: bool, workers: int):  # pragma: py-win32\n    fdsock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n    fd = fdsock.fileno()\n    config = Config(app=asgi_app, fd=fd, reload=reload, workers=workers)\n    config.load()\n    sock = config.bind_socket()\n    assert isinstance(sock, socket.socket)\n    assert sock.family == socket.AF_UNIX\n    assert sock.getsockname() == \"\"\n    sock.close()\n    fdsock.close()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reload, workers', [(True, 1), (False, 2)], ids=['--reload=True --workers=1', '--reload=False --workers=2'])",
        "pytest.mark.skipif(sys.platform == 'win32', reason='require unix-like system')"
      ],
      "arguments": [
        "reload",
        "workers"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(sock, socket.socket)",
        "assert sock.family == socket.AF_UNIX",
        "assert sock.getsockname() == ''"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "sock.close",
          "body": "def close(self):\n    assert not self.closed\n    self.closed = True"
        },
        {
          "name": "fdsock.close",
          "body": "def close(self):\n    assert not self.closed\n    self.closed = True"
        },
        {
          "name": "sock.getsockname",
          "body": "def getsockname(self):\n    return self.sockname"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_bind_fd_works_with_reload_or_workers` is designed to verify that the `Config` class can successfully bind a Unix domain socket using a file descriptor (fd) when the application is configured to use reloading or multiple worker processes. This ensures that the server can handle socket connections correctly under these conditions.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the socket returned by the `bind_socket` method is indeed a socket of the correct type (Unix socket) and that it is properly initialized with an empty socket name. This confirms that the binding process works as expected when using a file descriptor.\n\n**Code Being Tested and How It Works**:  \nThe test creates a Unix socket (`fdsock`) and retrieves its file descriptor (`fd`). It then initializes a `Config` object with this file descriptor, along with parameters for reloading and worker processes. After loading the configuration, it calls `bind_socket()` to obtain a socket (`sock`). The assertions verify that `sock` is a socket of type `socket.socket`, that its family is `AF_UNIX`, and that its socket name is an empty string, indicating it is not bound to a specific path.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterization**: The test uses `pytest.mark.parametrize` to run the test with different combinations of `reload` and `workers`, allowing for comprehensive coverage of various configurations without duplicating code.\n- **Socket Handling**: The test demonstrates proper resource management by closing both the `sock` and `fdsock` sockets after their use, preventing resource leaks.\n- **Platform-Specific Behavior**: The test includes a pragma directive (`# pragma: py-win32`) to indicate that it is intended for Windows platforms, which is relevant for the context of Unix sockets. Additionally, it uses `pytest.mark.skipif` to skip the test on non-Unix-like systems, ensuring that the test suite runs only on appropriate platforms."
    },
    {
      "name": "test_config_use_subprocess",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 538,
      "end_line_number": 541,
      "source_code": "def test_config_use_subprocess(reload: bool, workers: int, expected: bool):\n    config = Config(app=asgi_app, reload=reload, workers=workers)\n    config.load()\n    assert config.use_subprocess == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reload, workers, expected', [(True, 1, True), (False, 2, True), (False, 1, False)], ids=['--reload=True --workers=1', '--reload=False --workers=2', '--reload=False --workers=1'])"
      ],
      "arguments": [
        "reload",
        "workers",
        "expected"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert config.use_subprocess == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_config_use_subprocess` function is designed to verify the behavior of the `Config` class in determining whether to use subprocesses based on the `reload` and `workers` parameters. It ensures that the `use_subprocess` property of the `Config` instance returns the expected boolean value based on the provided inputs.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks the logic that dictates when the application should run in a subprocess. Specifically, it verifies that if `reload` is set to `True` or if `workers` is greater than 1, the `use_subprocess` property should return `True`. Conversely, if `reload` is `False` and `workers` is 1, it should return `False`.\n\n**Code Being Tested and How It Works**:  \nThe test creates an instance of the `Config` class with the parameters `app`, `reload`, and `workers`. After calling the `load()` method on the `Config` instance, it asserts that the `use_subprocess` property reflects the expected behavior. The `use_subprocess` property is defined in the `Config` class and evaluates to `True` if either `self.reload` is `True` or `self.workers` is greater than 1.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.mark.parametrize` decorator to run multiple test cases with different combinations of `reload`, `workers`, and `expected` values. This approach allows for concise and efficient testing of various scenarios without duplicating code. The use of parameterization enhances test coverage by systematically checking the logic under different configurations."
    },
    {
      "name": "test_warn_when_using_reload_and_workers",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_config.py",
      "line_number": 544,
      "end_line_number": 547,
      "source_code": "def test_warn_when_using_reload_and_workers(caplog: pytest.LogCaptureFixture) -> None:\n    Config(app=asgi_app, reload=True, workers=2)\n    assert len(caplog.records) == 1\n    assert '\"workers\" flag is ignored when reloading is enabled.' in caplog.records[0].message",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "caplog"
      ],
      "imports": [
        "__future__.annotations",
        "configparser",
        "io",
        "json",
        "logging",
        "os",
        "socket",
        "sys",
        "typing",
        "pathlib.Path",
        "typing.Any",
        "typing.Literal",
        "unittest.mock.MagicMock",
        "pytest",
        "yaml",
        "pytest_mock.MockerFixture",
        "tests.utils.as_cwd",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Environ",
        "uvicorn._types.Scope",
        "uvicorn._types.StartResponse",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.wsgi.WSGIMiddleware",
        "uvicorn.protocols.http.h11_impl.H11Protocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(caplog.records) == 1",
        "assert '\"workers\" flag is ignored when reloading is enabled.' in caplog.records[0].message"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_warn_when_using_reload_and_workers` is designed to verify that a warning is logged when the configuration for a Uvicorn server specifies both the `reload` and `workers` options. Specifically, it checks that the `workers` flag is ignored when reloading is enabled, which is a critical aspect of the server's configuration logic.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when the server is configured to reload (i.e., `reload=True`) and also specifies a number of worker processes (i.e., `workers=2`), a warning message is logged. The test asserts that exactly one log record is created and that this record contains the expected warning message indicating that the `workers` flag is ignored.\n\n**Code Being Tested and How It Works**:  \nThe code under test is part of the `Config` class, which manages the server's configuration settings. When an instance of `Config` is created with `reload=True` and `workers=2`, the constructor checks these parameters and logs a warning if both are set. The relevant logging occurs within the constructor of the `Config` class, where it evaluates the conditions and uses the logger to emit a warning message.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `caplog` fixture from `pytest` to capture log messages generated during the test execution. This allows the test to assert the presence and content of log records, which is a common pattern for verifying logging behavior in unit tests. Additionally, the test checks the length of the log records to ensure that only the expected warning was logged, demonstrating a focused approach to validating specific side effects of the code under test."
    },
    {
      "name": "test_lifespan_on",
      "module": "test_lifespan",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
      "line_number": 10,
      "end_line_number": 40,
      "source_code": "def test_lifespan_on():\n    startup_complete = False\n    shutdown_complete = False\n\n    async def app(scope, receive, send):\n        nonlocal startup_complete, shutdown_complete\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.startup\"\n        startup_complete = True\n        await send({\"type\": \"lifespan.startup.complete\"})\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.shutdown\"\n        shutdown_complete = True\n        await send({\"type\": \"lifespan.shutdown.complete\"})\n\n    async def test():\n        config = Config(app=app, lifespan=\"on\")\n        lifespan = LifespanOn(config)\n\n        assert not startup_complete\n        assert not shutdown_complete\n        await lifespan.startup()\n        assert startup_complete\n        assert not shutdown_complete\n        await lifespan.shutdown()\n        assert startup_complete\n        assert shutdown_complete\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "uvicorn.config.Config",
        "uvicorn.lifespan.off.LifespanOff",
        "uvicorn.lifespan.on.LifespanOn"
      ],
      "fixtures": [],
      "assertions": [
        "assert message['type'] == 'lifespan.startup'",
        "assert message['type'] == 'lifespan.shutdown'",
        "assert not startup_complete",
        "assert not shutdown_complete",
        "assert startup_complete",
        "assert not shutdown_complete",
        "assert startup_complete",
        "assert shutdown_complete"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "loop.close",
          "body": "def close(self):\n    assert not self.closed\n    self.closed = True"
        },
        {
          "name": "lifespan.startup",
          "body": "def startup(self):\n    calls.append('startup')"
        },
        {
          "name": "lifespan.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_lifespan_on` function is designed to verify the correct behavior of the `LifespanOn` class in the Uvicorn framework during the startup and shutdown phases of an application. It ensures that the application correctly handles lifespan events, specifically the transition from startup to shutdown.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the application correctly receives and responds to lifespan messages, specifically `lifespan.startup` and `lifespan.shutdown`. It verifies that the startup process completes successfully before the shutdown process begins, and it confirms that the appropriate flags (`startup_complete` and `shutdown_complete`) are set at the correct times.\n\n**Code Being Tested and How It Works**:  \nThe test uses an asynchronous application (`app`) that simulates receiving lifespan messages. It asserts that the first message is `lifespan.startup`, sets the `startup_complete` flag, and sends a completion message. It then waits for the `lifespan.shutdown` message, sets the `shutdown_complete` flag, and sends a shutdown completion message. The `LifespanOn` class is instantiated with a configuration that specifies the app and its lifespan behavior, and the test calls the `startup` and `shutdown` methods to trigger the respective processes.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of asynchronous programming with `async` and `await`, allowing for non-blocking execution of the lifespan events. It also utilizes assertions to validate the state of the application at various points in the process, ensuring that the expected transitions occur. The use of `nonlocal` allows the test to modify the flags defined in the outer scope, which is a common pattern in nested functions. Additionally, the test creates a new event loop for running the asynchronous test, which is a standard practice in testing asynchronous code in Python."
    },
    {
      "name": "test_lifespan_off",
      "module": "test_lifespan",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
      "line_number": 43,
      "end_line_number": 56,
      "source_code": "def test_lifespan_off():\n    async def app(scope, receive, send):\n        pass  # pragma: no cover\n\n    async def test():\n        config = Config(app=app, lifespan=\"off\")\n        lifespan = LifespanOff(config)\n\n        await lifespan.startup()\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "uvicorn.config.Config",
        "uvicorn.lifespan.off.LifespanOff",
        "uvicorn.lifespan.on.LifespanOn"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "loop.close",
          "body": "def close(self):\n    assert not self.closed\n    self.closed = True"
        },
        {
          "name": "lifespan.startup",
          "body": "def startup(self):\n    calls.append('startup')"
        },
        {
          "name": "lifespan.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_lifespan_off` function is designed to verify the behavior of the `LifespanOff` class when the lifespan configuration is set to \"off\". It ensures that the startup and shutdown methods can be called without any exceptions, confirming that the application can operate without a lifespan management mechanism.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the `startup` and `shutdown` methods of the `LifespanOff` class execute successfully without performing any operations, as the lifespan is effectively disabled. It verifies that the application can initialize and terminate without any side effects or errors.\n\n**Code Being Tested and How It Works**:  \nThe test creates an asynchronous application (`app`) that does nothing (a placeholder) and initializes a `Config` object with the app and a lifespan set to \"off\". It then instantiates the `LifespanOff` class and calls its `startup` and `shutdown` methods. The `LifespanOff` class has empty implementations for these methods, which means they should complete without any actions or state changes.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of asynchronous programming with `asyncio` to handle the lifecycle of the application. It creates a new event loop to run the asynchronous test function, which is a common pattern in testing asynchronous code in Python. The use of `async def` for the test function and the application allows for non-blocking execution, which is essential for testing asynchronous components effectively."
    },
    {
      "name": "test_lifespan_auto",
      "module": "test_lifespan",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
      "line_number": 59,
      "end_line_number": 89,
      "source_code": "def test_lifespan_auto():\n    startup_complete = False\n    shutdown_complete = False\n\n    async def app(scope, receive, send):\n        nonlocal startup_complete, shutdown_complete\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.startup\"\n        startup_complete = True\n        await send({\"type\": \"lifespan.startup.complete\"})\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.shutdown\"\n        shutdown_complete = True\n        await send({\"type\": \"lifespan.shutdown.complete\"})\n\n    async def test():\n        config = Config(app=app, lifespan=\"auto\")\n        lifespan = LifespanOn(config)\n\n        assert not startup_complete\n        assert not shutdown_complete\n        await lifespan.startup()\n        assert startup_complete\n        assert not shutdown_complete\n        await lifespan.shutdown()\n        assert startup_complete\n        assert shutdown_complete\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "uvicorn.config.Config",
        "uvicorn.lifespan.off.LifespanOff",
        "uvicorn.lifespan.on.LifespanOn"
      ],
      "fixtures": [],
      "assertions": [
        "assert message['type'] == 'lifespan.startup'",
        "assert message['type'] == 'lifespan.shutdown'",
        "assert not startup_complete",
        "assert not shutdown_complete",
        "assert startup_complete",
        "assert not shutdown_complete",
        "assert startup_complete",
        "assert shutdown_complete"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "loop.close",
          "body": "def close(self):\n    assert not self.closed\n    self.closed = True"
        },
        {
          "name": "lifespan.startup",
          "body": "def startup(self):\n    calls.append('startup')"
        },
        {
          "name": "lifespan.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_lifespan_auto` function is designed to verify the correct behavior of the `LifespanOn` class during the startup and shutdown phases of an ASGI application. It ensures that the application correctly handles lifespan events, specifically the transition from startup to shutdown, and that the appropriate messages are sent and received.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the application correctly identifies and processes the \"lifespan.startup\" and \"lifespan.shutdown\" messages. It asserts that the startup phase completes successfully before the shutdown phase begins, and it verifies that the state flags (`startup_complete` and `shutdown_complete`) are updated correctly throughout the process.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes an asynchronous application (`app`) that simulates the lifespan events. The `LifespanOn` class is instantiated with a configuration that specifies automatic lifespan management. The `startup` method sends a \"lifespan.startup\" message, and the `shutdown` method sends a \"lifespan.shutdown\" message. The assertions in the test confirm that the application transitions through these states correctly, with the expected messages being received and processed.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs asynchronous programming patterns using `async` and `await`, allowing for non-blocking execution of the lifespan events. It also uses `nonlocal` variables to maintain state across nested functions, which is a common technique in Python to manage state in closures. Additionally, the test creates a new event loop for running the asynchronous test, ensuring isolation and proper cleanup after execution."
    },
    {
      "name": "test_lifespan_auto_with_error",
      "module": "test_lifespan",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
      "line_number": 92,
      "end_line_number": 107,
      "source_code": "def test_lifespan_auto_with_error():\n    async def app(scope, receive, send):\n        assert scope[\"type\"] == \"http\"\n\n    async def test():\n        config = Config(app=app, lifespan=\"auto\")\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        assert lifespan.error_occured\n        assert not lifespan.should_exit\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "uvicorn.config.Config",
        "uvicorn.lifespan.off.LifespanOff",
        "uvicorn.lifespan.on.LifespanOn"
      ],
      "fixtures": [],
      "assertions": [
        "assert scope['type'] == 'http'",
        "assert lifespan.error_occured",
        "assert not lifespan.should_exit"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "loop.close",
          "body": "def close(self):\n    assert not self.closed\n    self.closed = True"
        },
        {
          "name": "lifespan.startup",
          "body": "def startup(self):\n    calls.append('startup')"
        },
        {
          "name": "lifespan.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_lifespan_auto_with_error` unit test is designed to verify the behavior of the lifespan management in an ASGI application when an error occurs during the startup phase. It ensures that the application correctly identifies that an error has occurred and that it does not trigger an exit.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that after invoking the `startup` method of the `LifespanOn` class, the `error_occured` attribute is set to `True`, indicating that an error was encountered. Additionally, it verifies that the `should_exit` attribute remains `False`, confirming that the application should not exit despite the error.\n\n**Code Being Tested and How It Works**:  \nThe test uses an asynchronous application (`app`) that asserts the `scope[\"type\"]` is \"http\". It creates a `Config` object with the application and sets the lifespan to \"auto\". The `LifespanOn` class is instantiated with this configuration. The `startup` method is called, which is expected to simulate an error condition. After the startup, the test checks the state of `lifespan.error_occured` and `lifespan.should_exit`. Finally, it calls the `shutdown` method to clean up resources.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs asynchronous programming with `async` and `await`, allowing it to handle potentially non-blocking operations effectively. It also uses a new event loop created specifically for the test, ensuring isolation from other tests. The assertions are straightforward, focusing on the state of the `lifespan` object after the startup process, which is a common pattern in unit testing to validate state changes."
    },
    {
      "name": "test_lifespan_on_with_error",
      "module": "test_lifespan",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
      "line_number": 110,
      "end_line_number": 126,
      "source_code": "def test_lifespan_on_with_error():\n    async def app(scope, receive, send):\n        if scope[\"type\"] != \"http\":\n            raise RuntimeError()\n\n    async def test():\n        config = Config(app=app, lifespan=\"on\")\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        assert lifespan.error_occured\n        assert lifespan.should_exit\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "uvicorn.config.Config",
        "uvicorn.lifespan.off.LifespanOff",
        "uvicorn.lifespan.on.LifespanOn"
      ],
      "fixtures": [],
      "assertions": [
        "assert lifespan.error_occured",
        "assert lifespan.should_exit"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "loop.close",
          "body": "def close(self):\n    assert not self.closed\n    self.closed = True"
        },
        {
          "name": "lifespan.startup",
          "body": "def startup(self):\n    calls.append('startup')"
        },
        {
          "name": "lifespan.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_lifespan_on_with_error` unit test is designed to verify the behavior of the `LifespanOn` class when an error occurs during the application lifespan startup phase. Specifically, it checks that the system correctly identifies an error condition and sets the appropriate flags to indicate that an error occurred and that the application should exit.\n\n**Specific Functionality or Behavior Verified**:  \nThe test ensures that when the application raises a `RuntimeError` during the startup phase, the `LifespanOn` instance correctly sets the `error_occured` attribute to `True` and the `should_exit` attribute to `True`. This indicates that the application has encountered a critical error and needs to terminate.\n\n**Code Being Tested and How It Works**:  \nThe test defines an asynchronous application (`app`) that raises a `RuntimeError` if the scope type is not \"http\". The test then creates a `Config` object with the application and a lifespan mode set to \"on\". It instantiates the `LifespanOn` class and calls its `startup` method. After the startup, it asserts that `lifespan.error_occured` is `True` and `lifespan.should_exit` is also `True`. Finally, it calls the `shutdown` method to clean up resources. The `LifespanOn` class is expected to handle the error during startup and set the appropriate flags.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of asynchronous programming with `async` and `await`, allowing for non-blocking execution of the application and lifespan methods. It also utilizes assertions to validate the state of the `LifespanOn` instance after the startup process. The test is structured to run within a new event loop, ensuring that the asynchronous code executes correctly. This pattern is common in testing asynchronous code, allowing for clear separation of setup, execution, and verification phases."
    },
    {
      "name": "test_lifespan_with_failed_startup",
      "module": "test_lifespan",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
      "line_number": 131,
      "end_line_number": 157,
      "source_code": "def test_lifespan_with_failed_startup(mode, raise_exception, caplog):\n    async def app(scope, receive, send):\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.startup\"\n        await send({\"type\": \"lifespan.startup.failed\", \"message\": \"the lifespan event failed\"})\n        if raise_exception:\n            # App should be able to re-raise an exception if startup failed.\n            raise RuntimeError()\n\n    async def test():\n        config = Config(app=app, lifespan=mode)\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        assert lifespan.startup_failed\n        assert lifespan.error_occured is raise_exception\n        assert lifespan.should_exit\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()\n    error_messages = [\n        record.message for record in caplog.records if record.name == \"uvicorn.error\" and record.levelname == \"ERROR\"\n    ]\n    assert \"the lifespan event failed\" in error_messages.pop(0)\n    assert \"Application startup failed. Exiting.\" in error_messages.pop(0)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('mode', ('auto', 'on'))",
        "pytest.mark.parametrize('raise_exception', (True, False))"
      ],
      "arguments": [
        "mode",
        "raise_exception",
        "caplog"
      ],
      "imports": [
        "asyncio",
        "pytest",
        "uvicorn.config.Config",
        "uvicorn.lifespan.off.LifespanOff",
        "uvicorn.lifespan.on.LifespanOn"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'the lifespan event failed' in error_messages.pop(0)",
        "assert 'Application startup failed. Exiting.' in error_messages.pop(0)",
        "assert message['type'] == 'lifespan.startup'",
        "assert lifespan.startup_failed",
        "assert lifespan.error_occured is raise_exception",
        "assert lifespan.should_exit"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "loop.close",
          "body": "def close(self):\n    assert not self.closed\n    self.closed = True"
        },
        {
          "name": "lifespan.startup",
          "body": "def startup(self):\n    calls.append('startup')"
        },
        {
          "name": "lifespan.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_lifespan_with_failed_startup` is designed to verify the behavior of the application during the lifespan startup phase when an error occurs. It checks that the application correctly handles a failed startup event, logs the appropriate error messages, and sets the relevant flags indicating that the startup has failed.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically verifies that when the application receives a `lifespan.startup` message and subsequently sends a `lifespan.startup.failed` message, the application correctly identifies that the startup has failed. It also checks whether the application raises an exception if the `raise_exception` flag is set, and ensures that the appropriate error messages are logged.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `LifespanOn` class, which manages the startup and shutdown lifecycle of the application. The `startup` method initiates the startup process, while the `shutdown` method handles the shutdown process. The test simulates the application receiving messages through the ASGI interface, asserting that the application behaves correctly in response to these messages. It checks the state of the `lifespan` object to confirm that the flags `startup_failed`, `error_occured`, and `should_exit` are set correctly based on the simulated events.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.mark.parametrize` decorator to run the test with multiple combinations of `mode` and `raise_exception`, allowing for comprehensive coverage of different scenarios. It also utilizes the `caplog` fixture to capture log messages generated during the test, enabling assertions on the logged output. The use of asynchronous testing with `asyncio` ensures that the test accurately reflects the asynchronous nature of the application lifecycle."
    },
    {
      "name": "test_lifespan_scope_asgi3app",
      "module": "test_lifespan",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
      "line_number": 160,
      "end_line_number": 180,
      "source_code": "def test_lifespan_scope_asgi3app():\n    async def asgi3app(scope, receive, send):\n        assert scope == {\n            \"type\": \"lifespan\",\n            \"asgi\": {\"version\": \"3.0\", \"spec_version\": \"2.0\"},\n            \"state\": {},\n        }\n\n    async def test():\n        config = Config(app=asgi3app, lifespan=\"on\")\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        assert not lifespan.startup_failed\n        assert not lifespan.error_occured\n        assert not lifespan.should_exit\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "uvicorn.config.Config",
        "uvicorn.lifespan.off.LifespanOff",
        "uvicorn.lifespan.on.LifespanOn"
      ],
      "fixtures": [],
      "assertions": [
        "assert scope == {'type': 'lifespan', 'asgi': {'version': '3.0', 'spec_version': '2.0'}, 'state': {}}",
        "assert not lifespan.startup_failed",
        "assert not lifespan.error_occured",
        "assert not lifespan.should_exit"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "loop.close",
          "body": "def close(self):\n    assert not self.closed\n    self.closed = True"
        },
        {
          "name": "lifespan.startup",
          "body": "def startup(self):\n    calls.append('startup')"
        },
        {
          "name": "lifespan.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_lifespan_scope_asgi3app` unit test is designed to verify the correct behavior of the lifespan management in an ASGI application, specifically ensuring that the application correctly handles the startup and shutdown lifecycle events. It checks that the application initializes properly and that no errors occur during these phases.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies that the `scope` passed to the ASGI application during the lifespan events matches the expected structure, which includes the type of event and ASGI version information. It also checks that the `LifespanOn` class correctly manages the startup and shutdown processes without encountering failures or errors.\n\n**Code Being Tested and How It Works**:  \nThe test defines an asynchronous ASGI application (`asgi3app`) that asserts the structure of the `scope` it receives. The `test` function creates a `Config` object with the ASGI app and initiates a `LifespanOn` instance. It then calls the `startup` method, which should not fail, and subsequently calls the `shutdown` method. The `LifespanOn` class manages the lifecycle events, logging the startup and shutdown processes and maintaining state information.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs asynchronous programming with `async` and `await` to handle the lifecycle events, which is crucial for testing ASGI applications. It uses assertions to validate the expected outcomes, ensuring that the application behaves as intended during the startup and shutdown phases. Additionally, it creates a new event loop for running the asynchronous test, which is a common pattern in testing asynchronous code in Python."
    },
    {
      "name": "test_lifespan_scope_asgi2app",
      "module": "test_lifespan",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
      "line_number": 183,
      "end_line_number": 205,
      "source_code": "def test_lifespan_scope_asgi2app():\n    def asgi2app(scope):\n        assert scope == {\n            \"type\": \"lifespan\",\n            \"asgi\": {\"version\": \"2.0\", \"spec_version\": \"2.0\"},\n            \"state\": {},\n        }\n\n        async def asgi(receive, send):\n            pass\n\n        return asgi\n\n    async def test():\n        config = Config(app=asgi2app, lifespan=\"on\")\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "uvicorn.config.Config",
        "uvicorn.lifespan.off.LifespanOff",
        "uvicorn.lifespan.on.LifespanOn"
      ],
      "fixtures": [],
      "assertions": [
        "assert scope == {'type': 'lifespan', 'asgi': {'version': '2.0', 'spec_version': '2.0'}, 'state': {}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "loop.close",
          "body": "def close(self):\n    assert not self.closed\n    self.closed = True"
        },
        {
          "name": "lifespan.startup",
          "body": "def startup(self):\n    calls.append('startup')"
        },
        {
          "name": "lifespan.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_lifespan_scope_asgi2app` unit test is designed to verify the correct behavior of the lifespan management in an ASGI application that adheres to the ASGI 2.0 specification. It ensures that the application correctly handles the startup and shutdown lifecycle events.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the application receives the expected lifespan scope during its initialization. It also verifies that the `startup` and `shutdown` methods of the `LifespanOn` class are called without errors, indicating that the application can properly manage its lifecycle.\n\n**Code Being Tested and How It Works**:  \nThe test defines an `asgi2app` function that asserts the `scope` parameter matches the expected structure for an ASGI 2.0 lifespan event. The `test` coroutine creates a `Config` object with the `asgi2app` and initiates a `LifespanOn` instance. It then calls `await lifespan.startup()` and `await lifespan.shutdown()`, which are methods that simulate the startup and shutdown processes of the application. The `LifespanOn` class is expected to manage the state and lifecycle of the application during these calls.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of asynchronous programming with `async` and `await`, allowing for non-blocking execution of the startup and shutdown processes. It also utilizes a nested function structure to encapsulate the ASGI application logic and the test logic, which helps in maintaining clarity and separation of concerns. Additionally, the test uses assertions to validate the expected behavior, ensuring that the application adheres to the ASGI lifecycle requirements. The event loop is manually managed, which is a common pattern in testing asynchronous code in Python."
    },
    {
      "name": "test_lifespan_with_failed_shutdown",
      "module": "test_lifespan",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
      "line_number": 210,
      "end_line_number": 241,
      "source_code": "def test_lifespan_with_failed_shutdown(mode, raise_exception, caplog):\n    async def app(scope, receive, send):\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.startup\"\n        await send({\"type\": \"lifespan.startup.complete\"})\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.shutdown\"\n        await send({\"type\": \"lifespan.shutdown.failed\", \"message\": \"the lifespan event failed\"})\n\n        if raise_exception:\n            # App should be able to re-raise an exception if startup failed.\n            raise RuntimeError()\n\n    async def test():\n        config = Config(app=app, lifespan=mode)\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        assert not lifespan.startup_failed\n        await lifespan.shutdown()\n        assert lifespan.shutdown_failed\n        assert lifespan.error_occured is raise_exception\n        assert lifespan.should_exit\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    error_messages = [\n        record.message for record in caplog.records if record.name == \"uvicorn.error\" and record.levelname == \"ERROR\"\n    ]\n    assert \"the lifespan event failed\" in error_messages.pop(0)\n    assert \"Application shutdown failed. Exiting.\" in error_messages.pop(0)\n    loop.close()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('mode', ('auto', 'on'))",
        "pytest.mark.parametrize('raise_exception', (True, False))"
      ],
      "arguments": [
        "mode",
        "raise_exception",
        "caplog"
      ],
      "imports": [
        "asyncio",
        "pytest",
        "uvicorn.config.Config",
        "uvicorn.lifespan.off.LifespanOff",
        "uvicorn.lifespan.on.LifespanOn"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'the lifespan event failed' in error_messages.pop(0)",
        "assert 'Application shutdown failed. Exiting.' in error_messages.pop(0)",
        "assert message['type'] == 'lifespan.startup'",
        "assert message['type'] == 'lifespan.shutdown'",
        "assert not lifespan.startup_failed",
        "assert lifespan.shutdown_failed",
        "assert lifespan.error_occured is raise_exception",
        "assert lifespan.should_exit"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "loop.close",
          "body": "def close(self):\n    assert not self.closed\n    self.closed = True"
        },
        {
          "name": "lifespan.startup",
          "body": "def startup(self):\n    calls.append('startup')"
        },
        {
          "name": "lifespan.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_lifespan_with_failed_shutdown` is designed to verify the behavior of the application during the lifespan events, specifically focusing on the shutdown process when it fails. It checks that the application correctly handles a failed shutdown event and logs the appropriate error messages.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies that when a shutdown event fails (simulated by sending a \"lifespan.shutdown.failed\" message), the application correctly sets the `shutdown_failed` flag, logs the error messages, and determines whether it should exit based on the presence of an exception during startup.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `LifespanOn` class, which manages the startup and shutdown lifecycle of an ASGI application. The `startup` and `shutdown` methods are invoked to simulate the application lifecycle. The test checks the state of the `lifespan` object after these methods are called, ensuring that the flags (`startup_failed`, `shutdown_failed`, `error_occured`, and `should_exit`) reflect the expected outcomes based on the simulated events.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs asynchronous programming with `asyncio` to simulate the application lifecycle, allowing for non-blocking operations. It also uses the `caplog` fixture from pytest to capture log messages generated during the test, enabling verification of error logging. The test is parameterized with `mode` and `raise_exception` to cover multiple scenarios, ensuring comprehensive coverage of the shutdown behavior under different conditions."
    },
    {
      "name": "test_lifespan_state",
      "module": "test_lifespan",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
      "line_number": 244,
      "end_line_number": 264,
      "source_code": "def test_lifespan_state():\n    async def app(scope, receive, send):\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.startup\"\n        await send({\"type\": \"lifespan.startup.complete\"})\n        scope[\"state\"][\"foo\"] = 123\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.shutdown\"\n        await send({\"type\": \"lifespan.shutdown.complete\"})\n\n    async def test():\n        config = Config(app=app, lifespan=\"on\")\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        assert lifespan.state == {\"foo\": 123}\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "uvicorn.config.Config",
        "uvicorn.lifespan.off.LifespanOff",
        "uvicorn.lifespan.on.LifespanOn"
      ],
      "fixtures": [],
      "assertions": [
        "assert message['type'] == 'lifespan.startup'",
        "assert message['type'] == 'lifespan.shutdown'",
        "assert lifespan.state == {'foo': 123}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "loop.close",
          "body": "def close(self):\n    assert not self.closed\n    self.closed = True"
        },
        {
          "name": "lifespan.startup",
          "body": "def startup(self):\n    calls.append('startup')"
        },
        {
          "name": "lifespan.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_lifespan_state` function is designed to verify the correct behavior of the lifespan management in an ASGI application using the Uvicorn server. It specifically tests the startup and shutdown phases of the application lifecycle, ensuring that the application state is correctly set and that the appropriate messages are sent and received during these phases.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. The application correctly receives a \"lifespan.startup\" message and responds with \"lifespan.startup.complete\".\n2. The application state is updated with a specific value (`{\"foo\": 123}`) during the startup phase.\n3. The application correctly receives a \"lifespan.shutdown\" message and responds with \"lifespan.shutdown.complete\".\n\n**Code Being Tested and How It Works**:  \nThe test involves an asynchronous application (`app`) that simulates the ASGI lifecycle. The `LifespanOn` class manages the startup and shutdown events. During the startup, it waits for a \"lifespan.startup\" event, updates its internal state, and then waits for a \"lifespan.shutdown\" event during the shutdown phase. The assertions in the test confirm that the expected messages are received and that the application state is correctly modified.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Asynchronous Testing**: The test uses `async` functions and the `asyncio` event loop to handle asynchronous operations, which is crucial for testing ASGI applications.\n- **State Verification**: The test verifies the internal state of the `LifespanOn` instance after the startup phase, ensuring that the application behaves as expected.\n- **Message Assertion**: The test asserts the types of messages received during the lifespan events, ensuring that the application correctly follows the ASGI lifespan protocol."
    },
    {
      "name": "test_loop_auto",
      "module": "test_auto_detection",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_auto_detection.py",
      "line_number": 35,
      "end_line_number": 39,
      "source_code": "def test_loop_auto():\n    auto_loop_setup()\n    policy = asyncio.get_event_loop_policy()\n    assert isinstance(policy, asyncio.events.BaseDefaultEventLoopPolicy)\n    assert type(policy).__module__.startswith(expected_loop)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "importlib",
        "pytest",
        "uvicorn.config.Config",
        "uvicorn.loops.auto.auto_loop_setup",
        "uvicorn.main.ServerState",
        "uvicorn.protocols.http.auto.AutoHTTPProtocol",
        "uvicorn.protocols.websockets.auto.AutoWebSocketsProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(policy, asyncio.events.BaseDefaultEventLoopPolicy)",
        "assert type(policy).__module__.startswith(expected_loop)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_loop_auto` function is designed to verify the automatic setup of the event loop policy in the Uvicorn server. It ensures that the correct event loop policy is being used based on the environment and the presence of the `uvloop` library.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main assertions: first, that the event loop policy retrieved from `asyncio.get_event_loop_policy()` is an instance of `asyncio.events.BaseDefaultEventLoopPolicy`, which indicates that the default event loop is being used. Second, it verifies that the module of the policy's type starts with a specified string (`expected_loop`), ensuring that the correct implementation of the event loop is being utilized.\n\n**Code Being Tested and How It Works**:  \nThe relevant code includes the `auto_loop_setup` function, which attempts to import `uvloop`. If `uvloop` is not available, it falls back to setting up the default asyncio event loop. The test indirectly verifies this behavior by checking the event loop policy after calling `auto_loop_setup()`, ensuring that the setup function correctly configures the event loop based on the environment.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs assertions to validate the expected state of the event loop policy, which is a common pattern in unit testing. It also uses the `asyncio` library to manage the event loop, demonstrating an understanding of asynchronous programming in Python. The test is structured to be simple and direct, focusing on the verification of the event loop policy without testing any specific methods directly, which is typical in unit tests that validate configuration or setup behavior."
    },
    {
      "name": "test_cli_print_version",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_cli.py",
      "line_number": 37,
      "end_line_number": 50,
      "source_code": "def test_cli_print_version() -> None:\n    runner = CliRunner()\n\n    result = runner.invoke(cli, [\"--version\"])\n\n    assert result.exit_code == 0\n    assert (\n        \"Running uvicorn {version} with {py_implementation} {py_version} on {system}\".format(  # noqa: UP032\n            version=uvicorn.__version__,\n            py_implementation=platform.python_implementation(),\n            py_version=platform.python_version(),\n            system=platform.system(),\n        )\n    ) in result.output",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "contextlib",
        "importlib",
        "os",
        "platform",
        "sys",
        "pathlib.Path",
        "textwrap.dedent",
        "typing.Iterator",
        "unittest.mock",
        "pytest",
        "click.testing.CliRunner",
        "uvicorn",
        "uvicorn.config.Config",
        "uvicorn.main.main",
        "uvicorn.server.Server",
        "uvicorn.supervisors.ChangeReload",
        "uvicorn.supervisors.Multiprocess"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 0",
        "assert 'Running uvicorn {version} with {py_implementation} {py_version} on {system}'.format(version=uvicorn.__version__, py_implementation=platform.python_implementation(), py_version=platform.python_version(), system=platform.system()) in result.output"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_cli_print_version` function is designed to verify that the command-line interface (CLI) of the Uvicorn server correctly outputs the version information when the `--version` flag is invoked. This ensures that users can easily check the version of Uvicorn they are running.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two main aspects: \n1. It asserts that the command execution returns an exit code of `0`, indicating successful execution without errors.\n2. It verifies that the output contains a formatted string with the current Uvicorn version, Python implementation, Python version, and the operating system, ensuring that the output is both accurate and informative.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `print_version` function, which is invoked when the CLI receives the `--version` argument. This function constructs a string using the current Uvicorn version and system information, then prints it to the console using `click.echo()`. The function also calls `ctx.exit()` to terminate the command after printing the version information.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `CliRunner` from the `click` testing utilities, which allows for simulating command-line interface interactions. This pattern is effective for testing CLI applications as it captures the output and exit status of the command. Additionally, the use of formatted strings in assertions ensures that the test checks for both the presence of expected content and the correctness of the output format."
    },
    {
      "name": "test_cli_headers",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_cli.py",
      "line_number": 53,
      "end_line_number": 67,
      "source_code": "def test_cli_headers() -> None:\n    runner = CliRunner()\n\n    with mock.patch.object(main, \"run\") as mock_run:\n        result = runner.invoke(cli, [\"tests.test_cli:App\", \"--header\", HEADERS])\n\n    assert result.output == \"\"\n    assert result.exit_code == 0\n    mock_run.assert_called_once()\n    assert mock_run.call_args[1][\"headers\"] == [\n        [\n            \"Content-Security-Policy\",\n            \"default-src 'self'; script-src https://example.com\",\n        ]\n    ]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "contextlib",
        "importlib",
        "os",
        "platform",
        "sys",
        "pathlib.Path",
        "textwrap.dedent",
        "typing.Iterator",
        "unittest.mock",
        "pytest",
        "click.testing.CliRunner",
        "uvicorn",
        "uvicorn.config.Config",
        "uvicorn.main.main",
        "uvicorn.server.Server",
        "uvicorn.supervisors.ChangeReload",
        "uvicorn.supervisors.Multiprocess"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.output == ''",
        "assert result.exit_code == 0",
        "assert mock_run.call_args[1]['headers'] == [['Content-Security-Policy', \"default-src 'self'; script-src https://example.com\"]]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_cli_headers` function is designed to verify that the command-line interface (CLI) of the Uvicorn application correctly processes header arguments and invokes the appropriate application run method with the expected parameters.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when the CLI is invoked with a specific header argument, the output is empty, the exit code is zero (indicating success), and that the `run` method is called exactly once with the correct headers.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `cli` command of the Uvicorn application, specifically testing the handling of headers passed via the command line. It uses the `CliRunner` from the `click` testing utilities to simulate command-line execution. The `mock.patch.object` is used to replace the actual `run` method in the `main` module with a mock, allowing the test to assert that it was called with the expected arguments without executing the real method.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test employs mocking to isolate the behavior of the `run` method, ensuring that the test focuses solely on the CLI's handling of input without side effects from the actual application logic.\n- **Assertions**: Multiple assertions are used to validate the output, exit code, and the parameters passed to the mocked method, ensuring comprehensive verification of the expected behavior.\n- **CLI Testing**: The use of `CliRunner` demonstrates a common pattern for testing command-line interfaces in Python applications, allowing for easy simulation of command-line arguments and capturing of output."
    },
    {
      "name": "test_cli_call_server_run",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_cli.py",
      "line_number": 70,
      "end_line_number": 77,
      "source_code": "def test_cli_call_server_run() -> None:\n    runner = CliRunner()\n\n    with mock.patch.object(Server, \"run\") as mock_run:\n        result = runner.invoke(cli, [\"tests.test_cli:App\"])\n\n    assert result.exit_code == 3\n    mock_run.assert_called_once()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "contextlib",
        "importlib",
        "os",
        "platform",
        "sys",
        "pathlib.Path",
        "textwrap.dedent",
        "typing.Iterator",
        "unittest.mock",
        "pytest",
        "click.testing.CliRunner",
        "uvicorn",
        "uvicorn.config.Config",
        "uvicorn.main.main",
        "uvicorn.server.Server",
        "uvicorn.supervisors.ChangeReload",
        "uvicorn.supervisors.Multiprocess"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 3"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_cli_call_server_run` unit test is designed to verify the behavior of the command-line interface (CLI) when attempting to run a server using a specified application. It ensures that the server's `run` method is invoked correctly and that the CLI returns the expected exit code.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when the CLI is invoked with the argument for the application (`tests.test_cli:App`), the server's `run` method is called exactly once, and the exit code returned by the CLI is `3`. The exit code `3` typically indicates an error or a specific condition defined in the CLI's implementation.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the CLI command that is expected to start a server with the specified application. The `CliRunner` is used to simulate command-line execution, and the `mock.patch.object` is employed to replace the actual `run` method of the `Server` class with a mock object. This allows the test to verify that the method is called without executing the actual server logic, which is crucial for unit testing.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The use of `mock.patch.object` allows the test to intercept calls to the `Server.run` method, enabling verification of its invocation without side effects.\n- **CLI Testing**: The `CliRunner` from the `click` testing utilities is utilized to simulate command-line interactions, making it easier to test CLI commands in isolation.\n- **Assertion of Exit Codes**: The test asserts the exit code returned by the CLI, which is a common practice in testing command-line applications to ensure they behave as expected under various conditions."
    },
    {
      "name": "test_cli_call_change_reload_run",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_cli.py",
      "line_number": 80,
      "end_line_number": 89,
      "source_code": "def test_cli_call_change_reload_run() -> None:\n    runner = CliRunner()\n\n    with mock.patch.object(Config, \"bind_socket\") as mock_bind_socket:\n        with mock.patch.object(ChangeReload, \"run\") as mock_run:\n            result = runner.invoke(cli, [\"tests.test_cli:App\", \"--reload\"])\n\n    assert result.exit_code == 0\n    mock_bind_socket.assert_called_once()\n    mock_run.assert_called_once()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "contextlib",
        "importlib",
        "os",
        "platform",
        "sys",
        "pathlib.Path",
        "textwrap.dedent",
        "typing.Iterator",
        "unittest.mock",
        "pytest",
        "click.testing.CliRunner",
        "uvicorn",
        "uvicorn.config.Config",
        "uvicorn.main.main",
        "uvicorn.server.Server",
        "uvicorn.supervisors.ChangeReload",
        "uvicorn.supervisors.Multiprocess"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 0"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_cli_call_change_reload_run` is designed to verify the behavior of the command-line interface (CLI) of the Uvicorn server when the `--reload` option is used. It ensures that the server can successfully start with the specified application and that the necessary internal methods are invoked correctly.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when the CLI is invoked with the `--reload` flag, the server's socket binding method (`bind_socket`) and the reload mechanism (`run` method of `ChangeReload`) are both called exactly once, and that the command completes successfully (indicated by an exit code of 0).\n\n**Code Being Tested and How It Works**:  \nThe test uses the `CliRunner` from the `click` testing framework to simulate command-line execution. It invokes the CLI with the application path and the `--reload` flag. The `mock.patch.object` is used to replace the actual implementations of `Config.bind_socket` and `ChangeReload.run` with mock objects, allowing the test to verify that these methods are called without executing their real logic. The assertions check that the exit code is 0 and that both mocked methods were called once.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test employs mocking to isolate the behavior of the CLI from the actual implementations of the methods being tested. This allows for focused testing on the CLI's behavior without side effects from the actual server logic.\n- **Assertions**: The test uses assertions to validate the expected outcomes, such as the exit code and the call counts of the mocked methods, ensuring that the CLI behaves as intended under the specified conditions.\n- **Context Management**: The use of `with` statements for mocking ensures that the mocks are properly set up and torn down, maintaining test isolation and preventing side effects on other tests."
    },
    {
      "name": "test_cli_call_multiprocess_run",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_cli.py",
      "line_number": 92,
      "end_line_number": 101,
      "source_code": "def test_cli_call_multiprocess_run() -> None:\n    runner = CliRunner()\n\n    with mock.patch.object(Config, \"bind_socket\") as mock_bind_socket:\n        with mock.patch.object(Multiprocess, \"run\") as mock_run:\n            result = runner.invoke(cli, [\"tests.test_cli:App\", \"--workers=2\"])\n\n    assert result.exit_code == 0\n    mock_bind_socket.assert_called_once()\n    mock_run.assert_called_once()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "contextlib",
        "importlib",
        "os",
        "platform",
        "sys",
        "pathlib.Path",
        "textwrap.dedent",
        "typing.Iterator",
        "unittest.mock",
        "pytest",
        "click.testing.CliRunner",
        "uvicorn",
        "uvicorn.config.Config",
        "uvicorn.main.main",
        "uvicorn.server.Server",
        "uvicorn.supervisors.ChangeReload",
        "uvicorn.supervisors.Multiprocess"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 0"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_cli_call_multiprocess_run` function is designed to verify that the command-line interface (CLI) of the Uvicorn server can successfully invoke a multiprocess run with the specified number of workers. It ensures that the application can be launched correctly without errors when using the CLI.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the CLI command to run the application with two worker processes executes without errors (indicated by an exit code of 0). It also verifies that the necessary methods for binding sockets and running the multiprocess setup are called exactly once, ensuring that the expected behavior of the application is followed.\n\n**Code Being Tested and How It Works**:  \nThe test invokes the CLI using `CliRunner`, which simulates command-line execution. It uses `mock.patch.object` to replace the `bind_socket` method of the `Config` class and the `run` method of the `Multiprocess` class with mock objects. This allows the test to check if these methods are called without actually executing their real implementations. The command being tested is `[\"tests.test_cli:App\", \"--workers=2\"]`, which specifies the application to run and the number of worker processes.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test employs mocking to isolate the functionality being tested. By replacing actual method calls with mocks, it prevents side effects and allows for verification of method calls.\n- **CLI Testing**: The use of `CliRunner` is a common pattern for testing command-line interfaces in Python, allowing for easy simulation of command execution and capturing of output.\n- **Assertions**: The test includes assertions to validate the exit code and the number of times the mocked methods were called, ensuring that the application behaves as expected under the given conditions."
    },
    {
      "name": "test_cli_uds",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_cli.py",
      "line_number": 114,
      "end_line_number": 125,
      "source_code": "def test_cli_uds(uds_file: Path) -> None:  # pragma: py-win32\n    runner = CliRunner()\n\n    with mock.patch.object(Config, \"bind_socket\") as mock_bind_socket:\n        with mock.patch.object(Multiprocess, \"run\") as mock_run:\n            result = runner.invoke(cli, [\"tests.test_cli:App\", \"--workers=2\", \"--uds\", str(uds_file)])\n\n    assert result.exit_code == 0\n    assert result.output == \"\"\n    mock_bind_socket.assert_called_once()\n    mock_run.assert_called_once()\n    assert not uds_file.exists()",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(sys.platform == 'win32', reason='require unix-like system')"
      ],
      "arguments": [
        "uds_file"
      ],
      "imports": [
        "contextlib",
        "importlib",
        "os",
        "platform",
        "sys",
        "pathlib.Path",
        "textwrap.dedent",
        "typing.Iterator",
        "unittest.mock",
        "pytest",
        "click.testing.CliRunner",
        "uvicorn",
        "uvicorn.config.Config",
        "uvicorn.main.main",
        "uvicorn.server.Server",
        "uvicorn.supervisors.ChangeReload",
        "uvicorn.supervisors.Multiprocess"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 0",
        "assert result.output == ''",
        "assert not uds_file.exists()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_cli_uds` function is designed to verify the behavior of the Uvicorn command-line interface (CLI) when invoked with a UNIX Domain Socket (UDS) option. It ensures that the application can correctly bind to a UDS and that the expected functions are called during this process.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when the CLI is run with the `--uds` flag, the application successfully binds to the specified UDS file, the appropriate methods for binding the socket and running the application are invoked exactly once, and that the UDS file does not exist after the command execution.\n\n**Code Being Tested and How It Works**:  \nThe test invokes the CLI with parameters that include a reference to a UDS file. It uses the `CliRunner` from the `click` testing utilities to simulate command-line execution. The `mock.patch.object` is used to replace the actual implementations of `Config.bind_socket` and `Multiprocess.run` with mock objects, allowing the test to verify that these methods are called without executing their real logic. The assertions at the end confirm that the exit code is `0` (indicating success), that there is no output, and that the UDS file has been removed.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test employs mocking to isolate the unit of work by replacing real method calls with mock objects, allowing for verification of interactions without side effects.\n- **Parameterization**: The `uds_file` fixture is parameterized to test both scenarios where the UDS file exists and does not exist, ensuring comprehensive coverage of the UDS handling logic.\n- **Assertions**: The test uses assertions to validate the expected outcomes, including exit codes, output, and the state of the UDS file, which are critical for confirming the correctness of the CLI behavior."
    },
    {
      "name": "test_cli_incomplete_app_parameter",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_cli.py",
      "line_number": 128,
      "end_line_number": 136,
      "source_code": "def test_cli_incomplete_app_parameter() -> None:\n    runner = CliRunner()\n\n    result = runner.invoke(cli, [\"tests.test_cli\"])\n\n    assert (\n        'Error loading ASGI app. Import string \"tests.test_cli\" ' 'must be in format \"<module>:<attribute>\".'\n    ) in result.output\n    assert result.exit_code == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "contextlib",
        "importlib",
        "os",
        "platform",
        "sys",
        "pathlib.Path",
        "textwrap.dedent",
        "typing.Iterator",
        "unittest.mock",
        "pytest",
        "click.testing.CliRunner",
        "uvicorn",
        "uvicorn.config.Config",
        "uvicorn.main.main",
        "uvicorn.server.Server",
        "uvicorn.supervisors.ChangeReload",
        "uvicorn.supervisors.Multiprocess"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'Error loading ASGI app. Import string \"tests.test_cli\" must be in format \"<module>:<attribute>\".' in result.output",
        "assert result.exit_code == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_cli_incomplete_app_parameter` unit test is designed to verify that the command-line interface (CLI) of the Uvicorn server correctly handles an invalid application import string. Specifically, it checks that the error message returned when the import string does not conform to the expected format is accurate and that the exit code indicates a failure.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that when the user attempts to invoke the CLI with an incomplete application parameter (in this case, just a module name without specifying an attribute), the system responds with an appropriate error message. It also verifies that the exit code is set to `1`, indicating an error occurred.\n\n**Code Being Tested and How It Works**:  \nThe test invokes the CLI using the `CliRunner` from the `click` testing utilities, passing the argument `[\"tests.test_cli\"]`. The expected behavior is that the CLI should raise an error because the import string does not specify an attribute (e.g., `tests.test_cli:App`). The test checks the output for the specific error message indicating the correct format and asserts that the exit code is `1`, which signifies an error.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Use of `CliRunner`**: This utility is employed to simulate command-line interface interactions, allowing for testing of CLI commands in isolation.\n- **Assertion of Output and Exit Code**: The test uses assertions to validate both the content of the output and the exit code, ensuring comprehensive verification of the CLI's behavior.\n- **String Matching**: The test checks for the presence of a specific error message in the output, which is a common practice in testing to ensure that the correct feedback is provided to the user."
    },
    {
      "name": "test_cli_event_size",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_cli.py",
      "line_number": 139,
      "end_line_number": 151,
      "source_code": "def test_cli_event_size() -> None:\n    runner = CliRunner()\n\n    with mock.patch.object(main, \"run\") as mock_run:\n        result = runner.invoke(\n            cli,\n            [\"tests.test_cli:App\", \"--h11-max-incomplete-event-size\", str(32 * 1024)],\n        )\n\n    assert result.output == \"\"\n    assert result.exit_code == 0\n    mock_run.assert_called_once()\n    assert mock_run.call_args[1][\"h11_max_incomplete_event_size\"] == 32768",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "contextlib",
        "importlib",
        "os",
        "platform",
        "sys",
        "pathlib.Path",
        "textwrap.dedent",
        "typing.Iterator",
        "unittest.mock",
        "pytest",
        "click.testing.CliRunner",
        "uvicorn",
        "uvicorn.config.Config",
        "uvicorn.main.main",
        "uvicorn.server.Server",
        "uvicorn.supervisors.ChangeReload",
        "uvicorn.supervisors.Multiprocess"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.output == ''",
        "assert result.exit_code == 0",
        "assert mock_run.call_args[1]['h11_max_incomplete_event_size'] == 32768"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_cli_event_size` function is designed to verify that the command-line interface (CLI) of the Uvicorn server correctly processes the `--h11-max-incomplete-event-size` option. It ensures that the application can accept this parameter and that it is passed correctly to the underlying `run` function.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when the CLI is invoked with a specific maximum incomplete event size (32 KB), the output is empty, the exit code is 0 (indicating success), and the `run` function is called exactly once with the expected parameter value for `h11_max_incomplete_event_size`.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the CLI command that starts the Uvicorn server. The `runner.invoke` method simulates running the CLI with the specified arguments. The `mock.patch.object` is used to replace the actual `run` method in the `main` module with a mock, allowing the test to verify that it was called with the correct parameters without executing the actual server logic.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The use of `mock.patch.object` allows the test to intercept calls to the `run` method, enabling verification of its invocation without side effects.\n- **CLI Testing**: The `CliRunner` from the `click.testing` module is employed to simulate command-line execution, capturing output and exit codes.\n- **Assertions**: The test includes multiple assertions to validate the output, exit code, and parameters passed to the mocked function, ensuring comprehensive verification of the CLI behavior."
    },
    {
      "name": "test_env_variables",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_cli.py",
      "line_number": 155,
      "end_line_number": 161,
      "source_code": "def test_env_variables(http_protocol: str):\n    with load_env_var(\"UVICORN_HTTP\", http_protocol):\n        runner = CliRunner(env=os.environ)\n        with mock.patch.object(main, \"run\") as mock_run:\n            runner.invoke(cli, [\"tests.test_cli:App\"])\n            _, kwargs = mock_run.call_args\n            assert kwargs[\"http\"] == http_protocol",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('http_protocol', ['h11', 'httptools'])"
      ],
      "arguments": [
        "http_protocol"
      ],
      "imports": [
        "contextlib",
        "importlib",
        "os",
        "platform",
        "sys",
        "pathlib.Path",
        "textwrap.dedent",
        "typing.Iterator",
        "unittest.mock",
        "pytest",
        "click.testing.CliRunner",
        "uvicorn",
        "uvicorn.config.Config",
        "uvicorn.main.main",
        "uvicorn.server.Server",
        "uvicorn.supervisors.ChangeReload",
        "uvicorn.supervisors.Multiprocess"
      ],
      "fixtures": [],
      "assertions": [
        "assert kwargs['http'] == http_protocol"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "load_env_var",
          "body": "@contextlib.contextmanager\ndef load_env_var(key: str, value: str) -> Iterator[None]:\n    old_environ = dict(os.environ)\n    os.environ[key] = value\n    yield\n    os.environ.clear()\n    os.environ.update(old_environ)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_env_variables` function is designed to verify that the Uvicorn CLI correctly utilizes environment variables to configure the HTTP protocol used by the server. Specifically, it checks that when the `UVICORN_HTTP` environment variable is set, the server's run method receives the expected protocol value.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the HTTP protocol specified in the environment variable is correctly passed to the Uvicorn server's run method. It asserts that the `http` keyword argument in the call to `main.run` matches the value of `http_protocol` provided to the test.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `load_env_var` context manager, which temporarily sets an environment variable (`UVICORN_HTTP`) to a specified value (`http_protocol`). Inside this context, it uses `CliRunner` to invoke the Uvicorn CLI with a specified application. The `mock.patch.object` is used to replace the `run` method of the `main` module with a mock, allowing the test to capture its arguments without executing the actual server logic. After invoking the CLI, the test checks the arguments passed to the mocked `run` method to ensure the correct HTTP protocol was used.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Manager**: The `load_env_var` function is a context manager that temporarily modifies the environment variables, ensuring that changes are reverted after the test completes.\n- **Mocking**: The use of `mock.patch.object` allows the test to intercept calls to the `run` method, enabling verification of its arguments without side effects.\n- **Parameterization**: The test is designed to be run with different values of `http_protocol`, allowing for comprehensive testing of various configurations in a single test function. This is facilitated by the `pytest.mark.parametrize` decorator, which enhances test coverage and maintainability."
    },
    {
      "name": "test_ignore_environment_variable_when_set_on_cli",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_cli.py",
      "line_number": 164,
      "end_line_number": 170,
      "source_code": "def test_ignore_environment_variable_when_set_on_cli():\n    with load_env_var(\"UVICORN_HTTP\", \"h11\"):\n        runner = CliRunner(env=os.environ)\n        with mock.patch.object(main, \"run\") as mock_run:\n            runner.invoke(cli, [\"tests.test_cli:App\", \"--http=httptools\"])\n            _, kwargs = mock_run.call_args\n            assert kwargs[\"http\"] == \"httptools\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "contextlib",
        "importlib",
        "os",
        "platform",
        "sys",
        "pathlib.Path",
        "textwrap.dedent",
        "typing.Iterator",
        "unittest.mock",
        "pytest",
        "click.testing.CliRunner",
        "uvicorn",
        "uvicorn.config.Config",
        "uvicorn.main.main",
        "uvicorn.server.Server",
        "uvicorn.supervisors.ChangeReload",
        "uvicorn.supervisors.Multiprocess"
      ],
      "fixtures": [],
      "assertions": [
        "assert kwargs['http'] == 'httptools'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "load_env_var",
          "body": "@contextlib.contextmanager\ndef load_env_var(key: str, value: str) -> Iterator[None]:\n    old_environ = dict(os.environ)\n    os.environ[key] = value\n    yield\n    os.environ.clear()\n    os.environ.update(old_environ)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_ignore_environment_variable_when_set_on_cli` is designed to verify that command-line interface (CLI) arguments take precedence over environment variables when both are set. Specifically, it checks that the HTTP protocol specified via the CLI (`--http=httptools`) overrides the HTTP protocol set in the environment variable (`UVICORN_HTTP`).\n\n**Specific Functionality or Behavior Verified**:  \nThe test ensures that when the `--http` option is provided in the CLI, the application uses the value from the CLI instead of the value from the environment variable. It asserts that the `http` keyword argument passed to the `main.run` function is equal to `\"httptools\"`.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `CliRunner` from the `click` library, which simulates command-line execution. The `load_env_var` context manager temporarily sets the environment variable `UVICORN_HTTP` to `\"h11\"` during the test. The `runner.invoke` method simulates running the CLI command with the specified arguments. The `mock.patch.object` is used to replace the `main.run` function with a mock, allowing the test to capture the arguments passed to it without executing the actual function.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Manager**: The `load_env_var` context manager is used to manage the environment variable's lifecycle, ensuring it is restored after the test.\n- **Mocking**: The `mock.patch.object` technique is employed to intercept calls to `main.run`, allowing the test to verify the arguments without executing the actual logic.\n- **CLI Testing**: The use of `CliRunner` facilitates testing of command-line interfaces, enabling the simulation of user input and capturing output and exit codes."
    },
    {
      "name": "test_app_dir",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_cli.py",
      "line_number": 173,
      "end_line_number": 192,
      "source_code": "def test_app_dir(tmp_path: Path, caplog: pytest.LogCaptureFixture) -> None:\n    app_dir = tmp_path / \"dir\" / \"app_dir\"\n    app_file = app_dir / \"main.py\"\n    app_dir.mkdir(parents=True)\n    app_file.touch()\n    app_file.write_text(\n        dedent(\n            \"\"\"\n            async def app(scope, receive, send):\n                ...\n            \"\"\"\n        )\n    )\n    runner = CliRunner()\n    with mock.patch.object(Server, \"run\") as mock_run:\n        result = runner.invoke(cli, [\"main:app\", \"--app-dir\", f\"{str(app_dir)}\"])\n\n    assert result.exit_code == 3\n    mock_run.assert_called_once()\n    assert sys.path[0] == str(app_dir)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmp_path",
        "caplog"
      ],
      "imports": [
        "contextlib",
        "importlib",
        "os",
        "platform",
        "sys",
        "pathlib.Path",
        "textwrap.dedent",
        "typing.Iterator",
        "unittest.mock",
        "pytest",
        "click.testing.CliRunner",
        "uvicorn",
        "uvicorn.config.Config",
        "uvicorn.main.main",
        "uvicorn.server.Server",
        "uvicorn.supervisors.ChangeReload",
        "uvicorn.supervisors.Multiprocess"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 3",
        "assert sys.path[0] == str(app_dir)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_app_dir` function is designed to verify the behavior of the command-line interface (CLI) when an application directory is specified. It ensures that the application can be correctly located and that the expected exit code is returned when the application is invoked.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the CLI correctly recognizes the application directory and that the application can be invoked without errors. It specifically verifies that the exit code is `3`, which likely indicates a specific error or state related to the application directory handling. Additionally, it confirms that the application directory is added to the Python path.\n\n**Code Being Tested and How It Works**:  \nThe test creates a temporary directory structure using `tmp_path`, where it creates a subdirectory `app_dir` and a file `main.py` containing an asynchronous application function. It then uses `CliRunner` to simulate invoking the CLI with the argument pointing to the application. The `mock.patch.object` is used to replace the `run` method of the `Server` class, allowing the test to verify that this method is called without executing the actual server code. The assertions check the exit code and the modification of `sys.path`.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Temporary File Creation**: The use of `tmp_path` allows for the creation of a temporary directory structure that is cleaned up after the test, ensuring no side effects on the filesystem.\n- **Mocking**: The `mock.patch.object` technique is employed to isolate the test from the actual implementation of the `Server.run` method, allowing for verification of interactions without side effects.\n- **CLI Testing**: The `CliRunner` from `pytest` is used to simulate command-line execution, making it easier to test CLI applications in a controlled manner.\n- **Assertions**: The test uses assertions to validate both the exit code and the state of `sys.path`, ensuring that the application directory is correctly recognized."
    },
    {
      "name": "test_set_app_via_environment_variable",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/test_cli.py",
      "line_number": 195,
      "end_line_number": 203,
      "source_code": "def test_set_app_via_environment_variable():\n    app_path = \"tests.test_cli:App\"\n    with load_env_var(\"UVICORN_APP\", app_path):\n        runner = CliRunner(env=os.environ)\n        with mock.patch.object(main, \"run\") as mock_run:\n            result = runner.invoke(cli)\n            args, _ = mock_run.call_args\n            assert result.exit_code == 0\n            assert args == (app_path,)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "contextlib",
        "importlib",
        "os",
        "platform",
        "sys",
        "pathlib.Path",
        "textwrap.dedent",
        "typing.Iterator",
        "unittest.mock",
        "pytest",
        "click.testing.CliRunner",
        "uvicorn",
        "uvicorn.config.Config",
        "uvicorn.main.main",
        "uvicorn.server.Server",
        "uvicorn.supervisors.ChangeReload",
        "uvicorn.supervisors.Multiprocess"
      ],
      "fixtures": [],
      "assertions": [
        "assert result.exit_code == 0",
        "assert args == (app_path,)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "load_env_var",
          "body": "@contextlib.contextmanager\ndef load_env_var(key: str, value: str) -> Iterator[None]:\n    old_environ = dict(os.environ)\n    os.environ[key] = value\n    yield\n    os.environ.clear()\n    os.environ.update(old_environ)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_set_app_via_environment_variable` test is to verify that the Uvicorn command-line interface (CLI) correctly sets and utilizes the application path specified through an environment variable (`UVICORN_APP`). This ensures that the application can be dynamically configured based on the environment, which is crucial for deployment scenarios.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when the `UVICORN_APP` environment variable is set to a specific application path, the CLI runner invokes the `main.run` function with the correct arguments and that the command execution completes successfully (exit code 0). It confirms that the application path is passed correctly to the Uvicorn server.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `load_env_var` context manager, which temporarily sets an environment variable and restores the original environment after the block of code is executed. Inside the test, the `CliRunner` is used to simulate command-line execution, and `mock.patch.object` is employed to intercept calls to the `main.run` function. The test then asserts that the exit code of the command is 0 and that the arguments passed to `main.run` match the expected application path.\n\n**Notable Testing Patterns or Techniques Used**:  \n1. **Context Manager**: The `load_env_var` function is a context manager that ensures the environment variable is set only for the duration of the test, promoting clean test isolation.\n2. **Mocking**: The use of `mock.patch.object` allows the test to replace the actual `main.run` function with a mock, enabling verification of the arguments without executing the real function.\n3. **CLI Testing**: The `CliRunner` from the `click.testing` module is utilized to simulate command-line interactions, making it easier to test CLI applications.\n4. **Assertions**: The test employs assertions to validate both the exit code and the arguments passed to the mocked function, ensuring comprehensive verification of the expected behavior."
    },
    {
      "name": "test_reloader_should_initialize",
      "module": "test_reload",
      "class_name": "TestBaseReload",
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 77,
      "end_line_number": 87,
      "source_code": "def test_reloader_should_initialize(self) -> None:\n        \"\"\"\n        A basic sanity check.\n\n        Simply run the reloader against a no-op server, and signal for it to\n        quit immediately.\n        \"\"\"\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n            reloader.shutdown()",
      "docstring": "A basic sanity check.\n\nSimply run the reloader against a no-op server, and signal for it to\nquit immediately.",
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_reloader_should_initialize` test serves as a basic sanity check to ensure that the reloader component of the application initializes correctly when provided with a configuration for a no-operation (no-op) server. It verifies that the reloader can start and shut down without errors.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically verifies that the reloader can be set up and subsequently shut down without encountering any issues. It checks that the reloader's initialization process completes successfully and that the shutdown method can be called without raising exceptions.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the `as_cwd` context manager to temporarily change the working directory to `self.reload_path`. Within this context, it creates a `Config` object with the application set to a no-op ASGI app and the reload option enabled. The `_setup_reloader` method is then called to initialize the reloader with this configuration. Finally, the `shutdown` method of the reloader is invoked to ensure it can terminate cleanly. The `Config` class is responsible for managing application settings, while the reloader class (either `StatReload` or `WatchFilesReload`) handles the reloading logic.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Manager**: The use of the `as_cwd` context manager allows for safe manipulation of the working directory, ensuring that the original directory is restored after the test completes.\n- **Parameterized Testing**: The test is decorated with `@pytest.mark.parametrize`, allowing it to run with different reloader classes (`StatReload` and `WatchFilesReload`), which enhances test coverage and ensures that both implementations are validated.\n- **Fixture Setup**: The test class uses a fixture (`setup`) to prepare the necessary environment and dependencies before each test runs, ensuring that the tests are isolated and repeatable."
    },
    {
      "name": "test_reload_when_python_file_is_changed",
      "module": "test_reload",
      "class_name": "TestBaseReload",
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 90,
      "end_line_number": 100,
      "source_code": "def test_reload_when_python_file_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            changes = self._reload_tester(touch_soon, reloader, file)\n            assert changes == [file]\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
      ],
      "arguments": [
        "self",
        "touch_soon"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert changes == [file]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_reload_when_python_file_is_changed` verifies that the reloader functionality in the Uvicorn server correctly detects changes to a specified Python file (`main.py`) and triggers a reload of the application.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when the `main.py` file is modified (touched), the reloader identifies this change and returns the modified file in the list of changes. The assertion `assert changes == [file]` confirms that the reloader behaves as expected by returning the correct file that was changed.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes several components:\n- `as_cwd`: A context manager that temporarily changes the current working directory to `self.reload_path`, ensuring that the reloader operates in the correct context.\n- `Config`: An object that holds configuration settings for the Uvicorn server, including the application to run and the reload option.\n- `_setup_reloader`: A method that initializes the reloader based on the provided configuration, setting up the necessary parameters and starting the reloader.\n- `_reload_tester`: A method that simulates file changes and checks if the reloader detects these changes. It touches the specified file and checks for changes.\n- `reloader.shutdown()`: This method is called to cleanly shut down the reloader after the test completes.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The use of `as_cwd` ensures that the test runs in a controlled environment, preventing side effects on the global state.\n- **Assertions**: The test employs assertions to validate the expected behavior of the reloader, ensuring that it correctly identifies file changes.\n- **Separation of Concerns**: The test is structured to focus solely on the reloader's behavior, leveraging helper methods (`_setup_reloader` and `_reload_tester`) to encapsulate specific functionalities, which enhances readability and maintainability."
    },
    {
      "name": "test_should_reload_when_python_file_in_subdir_is_changed",
      "module": "test_reload",
      "class_name": "TestBaseReload",
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 103,
      "end_line_number": 112,
      "source_code": "def test_should_reload_when_python_file_in_subdir_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \"app\" / \"sub\" / \"sub.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, file)\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
      ],
      "arguments": [
        "self",
        "touch_soon"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert self._reload_tester(touch_soon, reloader, file)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_should_reload_when_python_file_in_subdir_is_changed` verifies that the application correctly reloads when a Python file located in a subdirectory is modified. This is crucial for development environments where changes to code should trigger an automatic reload of the application to reflect updates without manual intervention.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that the reloader detects changes to the specified Python file (`sub.py`) in the `app/sub` directory and confirms that the reloader responds appropriately by restarting the application. The assertion ensures that the file change is recognized and that the reloader behaves as expected.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `BaseReload` class, which manages the reloading mechanism. It sets up a reloader instance using the `Config` class, which is configured to enable reloading. The `_reload_tester` method is called to simulate the file change (using the `touch_soon` function) and check if the reloader detects the change. The test asserts that the reloader correctly identifies the modified file and triggers a reload.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The `as_cwd` context manager is used to temporarily change the working directory for the duration of the test, ensuring that the reloader operates in the correct context.\n- **Parameterized Testing**: The test is part of a parameterized test suite, allowing it to be run with different reloader classes (`StatReload` and `WatchFilesReload`), which helps ensure that the functionality is consistent across different implementations of the reloader.\n- **Assertions**: The use of assertions to validate the expected behavior of the reloader after a file change is a standard practice in unit testing, ensuring that the code behaves as intended."
    },
    {
      "name": "test_should_not_reload_when_python_file_in_excluded_subdir_is_changed",
      "module": "test_reload",
      "class_name": "TestBaseReload",
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 115,
      "end_line_number": 129,
      "source_code": "def test_should_not_reload_when_python_file_in_excluded_subdir_is_changed(self, touch_soon) -> None:\n        sub_dir = self.reload_path / \"app\" / \"sub\"\n        sub_file = sub_dir / \"sub.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_excludes=[str(sub_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert not self._reload_tester(touch_soon, reloader, sub_file)\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [WatchFilesReload, WatchGodReload])"
      ],
      "arguments": [
        "self",
        "touch_soon"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert not self._reload_tester(touch_soon, reloader, sub_file)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_should_not_reload_when_python_file_in_excluded_subdir_is_changed` aims to verify that the reloader does not trigger a reload when a Python file in a specified excluded subdirectory is modified. This is crucial for ensuring that the reloader respects the configuration settings for excluded directories, preventing unnecessary reloads that could disrupt the application.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that changes to a Python file located in a subdirectory that is listed in the `reload_excludes` configuration do not result in a reload. The assertion `assert not self._reload_tester(touch_soon, reloader, sub_file)` confirms that the reloader does not detect any changes that would necessitate a restart of the application.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `WatchFilesReload` class, which monitors specified directories for file changes. The `reload_excludes` parameter in the `Config` object is used to specify directories that should be ignored by the reloader. The `_reload_tester` method simulates file changes and checks if the reloader responds appropriately. In this case, it is expected that the reloader will not restart when the `sub_file` is modified, as it resides in the excluded `sub_dir`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the context manager `as_cwd` to temporarily change the working directory, ensuring that the reloader operates in the correct context. It also utilizes assertions to validate the expected behavior, specifically checking for the absence of reloads. The use of a helper method (`_reload_tester`) encapsulates the logic for testing the reloader's response to file changes, promoting code reuse and clarity. Additionally, the test is structured to run within a parameterized context, allowing for flexibility in testing different reloader classes."
    },
    {
      "name": "test_reload_when_pattern_matched_file_is_changed",
      "module": "test_reload",
      "class_name": "TestBaseReload",
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 132,
      "end_line_number": 141,
      "source_code": "def test_reload_when_pattern_matched_file_is_changed(self, result: bool, touch_soon) -> None:\n        file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_includes=[\"*.js\"])\n            reloader = self._setup_reloader(config)\n\n            assert bool(self._reload_tester(touch_soon, reloader, file)) == result\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class, result', [(StatReload, False), (WatchFilesReload, True)])"
      ],
      "arguments": [
        "self",
        "result",
        "touch_soon"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert bool(self._reload_tester(touch_soon, reloader, file)) == result"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_reload_when_pattern_matched_file_is_changed` is designed to verify that the application correctly reloads when a file matching a specified pattern (in this case, a JavaScript file) is modified. This is crucial for development environments where live reloading is expected to reflect changes immediately.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when a file (`main.js`) is touched (modified), the reloader detects this change and triggers a reload of the application. The expected behavior is that the result of the reload operation matches the provided `result` argument, indicating whether a reload should occur based on the file change.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes several components:\n- `as_cwd`: A context manager that temporarily changes the current working directory to `self.reload_path`, ensuring that the reloader operates in the correct context.\n- `Config`: A configuration object that specifies the application to run, enables reloading, and includes a pattern for files to watch (`reload_includes=[\"*.js\"]`).\n- `_setup_reloader`: This method initializes the reloader with the given configuration and starts it.\n- `_reload_tester`: This method simulates the file modification and checks if the reloader detects the change. It uses the `touch_soon` function to modify the file and then checks the reloader's response.\n\nThe assertion `assert bool(self._reload_tester(touch_soon, reloader, file)) == result` confirms that the reloader's behavior aligns with the expected outcome based on the file change.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterized Testing**: The test is likely part of a larger suite that uses parameterization (as seen in other tests) to run multiple scenarios with different inputs, enhancing coverage and robustness.\n- **Context Management**: The use of `as_cwd` ensures that the test does not affect the global state of the working directory, promoting isolation and reliability in tests.\n- **Assertions**: The test employs assertions to validate the expected behavior, which is a fundamental practice in unit testing to ensure correctness.\n- **Mocking or Stubbing**: The `touch_soon` function is likely a mock or stub that simulates file changes without requiring actual file system modifications, allowing for controlled testing environments."
    },
    {
      "name": "test_should_not_reload_when_exclude_pattern_match_file_is_changed",
      "module": "test_reload",
      "class_name": "TestBaseReload",
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 150,
      "end_line_number": 168,
      "source_code": "def test_should_not_reload_when_exclude_pattern_match_file_is_changed(self, touch_soon) -> None:\n        python_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        css_file = self.reload_path / \"app\" / \"css\" / \"main.css\"\n        js_file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\"*\"],\n                reload_excludes=[\"*.js\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, python_file)\n            assert self._reload_tester(touch_soon, reloader, css_file)\n            assert not self._reload_tester(touch_soon, reloader, js_file)\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
      ],
      "arguments": [
        "self",
        "touch_soon"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert self._reload_tester(touch_soon, reloader, python_file)",
        "assert self._reload_tester(touch_soon, reloader, css_file)",
        "assert not self._reload_tester(touch_soon, reloader, js_file)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_should_not_reload_when_exclude_pattern_match_file_is_changed` aims to verify that the reloader does not trigger a reload when a file that matches the exclusion pattern (in this case, a JavaScript file) is modified. This is crucial for ensuring that the application behaves as expected when certain file types are excluded from the auto-reload mechanism.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that changes to a JavaScript file (`main.js`) do not cause the application to reload, while changes to other file types (like Python and CSS files) do trigger a reload. This behavior is validated through assertions that confirm the expected outcomes of the `_reload_tester` method.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `Config` class, which is configured with `reload_excludes` set to exclude JavaScript files. The `_setup_reloader` method initializes the reloader with this configuration, and the `_reload_tester` method simulates file changes to check if the reloader correctly identifies which files should trigger a reload. The test uses the `touch_soon` function to modify the files and checks the reloader's response.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Context Management**: The `as_cwd` context manager temporarily changes the working directory for the duration of the test, ensuring that the reloader operates in the correct context.\n- **Assertions**: The use of assertions to validate the expected behavior of the reloader after file modifications is a standard practice in unit testing, ensuring that the code behaves as intended.\n- **Parameterized Testing**: The test is part of a parameterized test suite, allowing it to be run with different reloader classes, which enhances test coverage and flexibility."
    },
    {
      "name": "test_should_not_reload_when_dot_file_is_changed",
      "module": "test_reload",
      "class_name": "TestBaseReload",
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 171,
      "end_line_number": 180,
      "source_code": "def test_should_not_reload_when_dot_file_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \".dotted\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            assert not self._reload_tester(touch_soon, reloader, file)\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
      ],
      "arguments": [
        "self",
        "touch_soon"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert not self._reload_tester(touch_soon, reloader, file)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_should_not_reload_when_dot_file_is_changed` aims to verify that the reloader does not trigger a reload when a dot file (specifically, a file starting with a dot, which is often used for configuration or hidden files) is modified. This is important for ensuring that certain files do not inadvertently cause the application to restart, which could disrupt ongoing processes.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that modifying a dot file does not result in a reload of the application. It asserts that the return value of the `_reload_tester` method is `False`, indicating that no changes were detected that would necessitate a reload.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the `Config` class to set up a reloader with the `reload` option enabled. The `_setup_reloader` method initializes the reloader, and the `_reload_tester` method is called with the modified dot file. The `touch_soon` function simulates the modification of the file. The reloader's behavior is controlled by the `BaseReload` class, which manages the detection of file changes and the decision to restart the application.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Manager**: The `as_cwd` context manager is used to temporarily change the working directory for the duration of the test, ensuring that the reloader operates in the correct context.\n- **Assertions**: The test employs assertions to validate the expected behavior, specifically checking that the reloader does not trigger a reload when a dot file is modified.\n- **Isolation**: The test is designed to run independently, focusing solely on the behavior of the reloader with respect to dot files, which helps in pinpointing issues related to file change detection without interference from other tests."
    },
    {
      "name": "test_should_reload_when_directories_have_same_prefix",
      "module": "test_reload",
      "class_name": "TestBaseReload",
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 183,
      "end_line_number": 200,
      "source_code": "def test_should_reload_when_directories_have_same_prefix(self, touch_soon) -> None:\n        app_dir = self.reload_path / \"app\"\n        app_file = app_dir / \"src\" / \"main.py\"\n        app_first_dir = self.reload_path / \"app_first\"\n        app_first_file = app_first_dir / \"src\" / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_dirs=[str(app_dir), str(app_first_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, app_file)\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
      ],
      "arguments": [
        "self",
        "touch_soon"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert self._reload_tester(touch_soon, reloader, app_file)",
        "assert self._reload_tester(touch_soon, reloader, app_first_file)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_should_reload_when_directories_have_same_prefix` is designed to verify that the application correctly reloads when files in two directories that share the same prefix are modified. This is crucial for ensuring that the development server responds to changes in the codebase, enhancing the developer experience.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the reloader detects changes in both `app` and `app_first` directories. It asserts that modifications to files in these directories trigger the reloader, confirming that the application behaves as expected when files in directories with similar names are altered.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the `Config` class to set up the reloader with specified directories. The `_setup_reloader` method initializes the reloader based on the configuration, while the `_reload_tester` method simulates file modifications using the `touch_soon` function. The assertions ensure that the reloader correctly identifies changes in both `app_file` and `app_first_file`, indicating that the reloader is functioning properly.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs context management with `as_cwd` to temporarily change the working directory, ensuring that the reloader operates in the correct context. It also uses assertions to validate the expected behavior of the reloader, and it leverages parameterization (though not directly in this test) to allow for testing with different reloader classes, enhancing the test's coverage and flexibility."
    },
    {
      "name": "test_should_not_reload_when_only_subdirectory_is_watched",
      "module": "test_reload",
      "class_name": "TestBaseReload",
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 210,
      "end_line_number": 225,
      "source_code": "def test_should_not_reload_when_only_subdirectory_is_watched(self, touch_soon) -> None:\n        app_dir = self.reload_path / \"app\"\n        app_dir_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        root_file = self.reload_path / \"main.py\"\n\n        config = Config(\n            app=\"tests.test_config:asgi_app\",\n            reload=True,\n            reload_dirs=[str(app_dir)],\n        )\n        reloader = self._setup_reloader(config)\n\n        assert self._reload_tester(touch_soon, reloader, app_dir_file)\n        assert not self._reload_tester(touch_soon, reloader, root_file, app_dir / \"~ignored\")\n\n        reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, pytest.param(WatchFilesReload, marks=skip_if_m1)])"
      ],
      "arguments": [
        "self",
        "touch_soon"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert self._reload_tester(touch_soon, reloader, app_dir_file)",
        "assert not self._reload_tester(touch_soon, reloader, root_file, app_dir / '~ignored')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_should_not_reload_when_only_subdirectory_is_watched` aims to verify that the application does not reload when changes are made to files in a directory that is not explicitly included in the reload configuration. Specifically, it checks that modifications in the root directory do not trigger a reload if only a subdirectory is being monitored.\n\n**Specific Functionality or Behavior Verified**:  \nThis test ensures that the reloader behaves correctly by asserting that changes to a file in the root directory (`main.py`) do not cause a reload when the reloader is configured to watch only a specific subdirectory (`app`). It confirms that the reloader respects the boundaries set by the `reload_dirs` configuration.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the `_setup_reloader` method to initialize a reloader with a configuration that specifies the directory to watch (`app_dir`). The `_reload_tester` method is then called twice: first with a file in the watched subdirectory (`app_dir_file`), which should trigger a reload, and second with a file in the root directory (`root_file`), which should not trigger a reload. The assertions check the expected behavior of the reloader based on these configurations.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of assertions to validate expected outcomes, leveraging helper methods (`_setup_reloader` and `_reload_tester`) to encapsulate setup and testing logic. It also uses a parameterized approach to test different configurations of the reloader, ensuring that the behavior is consistent across various scenarios. The use of `touch_soon` simulates file changes, allowing the test to verify the reloader's response to file modifications effectively."
    },
    {
      "name": "test_override_defaults",
      "module": "test_reload",
      "class_name": "TestBaseReload",
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 234,
      "end_line_number": 253,
      "source_code": "def test_override_defaults(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        dotted_dir_file = self.reload_path / \".dotted_dir\" / \"file.txt\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                # We need to add *.txt otherwise no regular files will match\n                reload_includes=[\".*\", \"*.txt\"],\n                reload_excludes=[\"*.py\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, dotted_dir_file)\n            assert not self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
      ],
      "arguments": [
        "self",
        "touch_soon"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert self._reload_tester(touch_soon, reloader, dotted_file)",
        "assert self._reload_tester(touch_soon, reloader, dotted_dir_file)",
        "assert not self._reload_tester(touch_soon, reloader, python_file)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_override_defaults` unit test is designed to verify the behavior of the reloader configuration in the Uvicorn server, specifically ensuring that the file reload mechanism correctly includes and excludes files based on specified patterns.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. Files matching the inclusion patterns (like `.dotted` and `.dotted_dir/file.txt`) trigger a reload.\n2. Files that do not match the inclusion patterns (like `main.py`) do not trigger a reload.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the `Config` class to set up a reloader with specific inclusion and exclusion patterns. The `_setup_reloader` method initializes the reloader, and the `_reload_tester` method simulates file changes to check if the reloader behaves as expected. The assertions confirm that the reloader responds correctly to file modifications based on the defined patterns.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Manager**: The `as_cwd` context manager temporarily changes the working directory for the duration of the test, ensuring that file paths are resolved correctly.\n- **Assertions**: The use of assertions to validate the expected outcomes of the reloader's behavior is a standard practice in unit testing, ensuring that the test fails if the actual behavior does not match expectations.\n- **Parameterized Testing**: The test is marked with `pytest.mark.parametrize`, allowing it to be run with different reloader classes, enhancing its robustness and coverage."
    },
    {
      "name": "test_explicit_paths",
      "module": "test_reload",
      "class_name": "TestBaseReload",
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 262,
      "end_line_number": 279,
      "source_code": "def test_explicit_paths(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        non_dotted_file = self.reload_path / \"ext\" / \"ext.jpg\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\".dotted\", \"ext/ext.jpg\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, non_dotted_file)\n            assert self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
      ],
      "arguments": [
        "self",
        "touch_soon"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert self._reload_tester(touch_soon, reloader, dotted_file)",
        "assert self._reload_tester(touch_soon, reloader, non_dotted_file)",
        "assert self._reload_tester(touch_soon, reloader, python_file)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_explicit_paths` unit test is designed to verify that the Uvicorn reloader correctly identifies and responds to changes in specified files, particularly those that are explicitly included in the reload configuration. This ensures that the application can dynamically reload when certain files are modified, which is crucial for development efficiency.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the reloader successfully detects changes to three specific files: a hidden file (\".dotted\"), a non-hidden image file (\"ext/ext.jpg\"), and a Python file (\"main.py\"). It asserts that the reloader triggers a reload for each of these files when they are touched (modified), confirming that the reloader's behavior aligns with the specified `reload_includes` configuration.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the `Config` class to set up a reloader with specific parameters, including `reload_includes` that lists the files to monitor for changes. The `_setup_reloader` method initializes the reloader based on this configuration. The `_reload_tester` method is then called for each file, which restarts the reloader and simulates file modifications using the `touch_soon` function. The assertions check that the reloader correctly identifies the changes and triggers a reload.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The `as_cwd` context manager temporarily changes the working directory for the duration of the test, ensuring that file paths are resolved correctly relative to the test's execution context.\n- **Parameterized Testing**: The test is part of a parameterized suite, allowing it to be run with different reloader classes, which enhances test coverage and flexibility.\n- **Assertions**: The use of assertions to validate the expected behavior of the reloader after file modifications is a standard practice in unit testing, ensuring that the code behaves as intended under various conditions."
    },
    {
      "name": "test_watchfiles_no_changes",
      "module": "test_reload",
      "class_name": "TestBaseReload",
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 283,
      "end_line_number": 308,
      "source_code": "def test_watchfiles_no_changes(self) -> None:\n        sub_dir = self.reload_path / \"app\" / \"sub\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_excludes=[str(sub_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            from watchfiles import watch\n\n            assert isinstance(reloader, WatchFilesReload)\n            # just so we can make rust_timeout 100ms\n            reloader.watcher = watch(\n                sub_dir,\n                watch_filter=None,\n                stop_event=reloader.should_exit,\n                yield_on_timeout=True,\n                rust_timeout=100,\n            )\n\n            assert reloader.should_restart() is None\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(WatchFilesReload is None, reason='watchfiles not available')",
        "pytest.mark.parametrize('reloader_class', [WatchFilesReload])"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(reloader, WatchFilesReload)",
        "assert reloader.should_restart() is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        },
        {
          "name": "reloader.should_restart",
          "body": "def should_restart(self):\n    nonlocal step\n    step += 1\n    if step == 1:\n        return None\n    elif step == 2:\n        return [tmp_path / 'foobar.py']\n    else:\n        raise StopIteration()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_watchfiles_no_changes` unit test is designed to verify that the reloader does not trigger a restart when there are no changes detected in the specified directory being watched. This is crucial for ensuring that the application behaves correctly during development, where automatic reloading should only occur when actual changes are made to the codebase.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that the `should_restart` method of the `WatchFilesReload` class returns `None`, indicating that no changes have been detected in the watched directory. This confirms that the reloader is functioning as intended when no modifications occur.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a reloader using the `Config` class, specifying a directory to watch (`sub_dir`) and excluding it from reload triggers. The `watch` function from the `watchfiles` module is used to monitor the directory. The `should_restart` method is called to check for changes, and the expected outcome is that it returns `None`, indicating no changes were detected. The reloader is then shut down to clean up resources.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Managers**: The `as_cwd` context manager is used to temporarily change the working directory for the duration of the test, ensuring that the test environment is isolated and does not affect the global state.\n- **Assertions**: The test employs assertions to validate the type of the reloader and the result of the `should_restart` method, ensuring that the expected behavior is met.\n- **Dependency Injection**: The test uses a configuration object (`Config`) to set up the reloader, demonstrating a common pattern in testing where dependencies are injected to facilitate testing in isolation."
    },
    {
      "name": "test_should_detect_new_reload_dirs",
      "module": "test_reload",
      "class_name": "TestBaseReload",
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 311,
      "end_line_number": 332,
      "source_code": "def test_should_detect_new_reload_dirs(self, touch_soon, caplog: pytest.LogCaptureFixture, tmp_path: Path) -> None:\n        app_dir = tmp_path / \"app\"\n        app_file = app_dir / \"file.py\"\n        app_dir.mkdir()\n        app_file.touch()\n        app_first_dir = tmp_path / \"app_first\"\n        app_first_file = app_first_dir / \"file.py\"\n\n        with as_cwd(tmp_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_includes=[\"app*\"])\n            reloader = self._setup_reloader(config)\n            assert self._reload_tester(touch_soon, reloader, app_file)\n\n            app_first_dir.mkdir()\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n            assert caplog.records[-2].levelno == logging.INFO\n            assert (\n                caplog.records[-1].message == \"WatchGodReload detected a new reload \"\n                f\"dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\"\n            )\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [WatchGodReload])"
      ],
      "arguments": [
        "self",
        "touch_soon",
        "caplog",
        "tmp_path"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert self._reload_tester(touch_soon, reloader, app_file)",
        "assert self._reload_tester(touch_soon, reloader, app_first_file)",
        "assert caplog.records[-2].levelno == logging.INFO",
        "assert caplog.records[-1].message == f\"WatchGodReload detected a new reload dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_should_detect_new_reload_dirs` is designed to verify that the reloader correctly detects and responds to the addition of new directories that should be monitored for file changes. Specifically, it checks that when a new directory is created, the reloader acknowledges it and logs the appropriate message.\n\n**Specific Functionality or Behavior Verified**:  \nThe test ensures that the reloader can detect a new directory (`app_first_dir`) added after the initial setup and that it logs an informational message indicating that this new directory is now being watched. It also verifies that the reloader functions correctly by asserting that it restarts and recognizes changes in the specified files.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `Config` class to set up a reloader with specific directories to watch. The `_setup_reloader` method initializes the reloader based on the provided configuration, while the `_reload_tester` method simulates file changes to trigger the reloader. The test checks the log records to confirm that the expected message about the new directory is logged, indicating that the reloader is functioning as intended.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The `as_cwd` context manager is used to temporarily change the working directory for the duration of the test, ensuring that the reloader operates in the correct context.\n- **Log Capture**: The `caplog` fixture captures log messages generated during the test, allowing for assertions on the log output to verify that the correct messages are logged.\n- **Assertions**: The test employs multiple assertions to validate both the behavior of the reloader and the correctness of the log messages, ensuring comprehensive coverage of the expected outcomes."
    },
    {
      "name": "test_should_watch_one_dir_cwd",
      "module": "test_reload",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 336,
      "end_line_number": 349,
      "source_code": "def test_should_watch_one_dir_cwd(mocker, reload_directory_structure):\n    mock_watch = mocker.patch(\"uvicorn.supervisors.watchfilesreload.watch\")\n    app_dir = reload_directory_structure / \"app\"\n    app_first_dir = reload_directory_structure / \"app_first\"\n\n    with as_cwd(reload_directory_structure):\n        config = Config(\n            app=\"tests.test_config:asgi_app\",\n            reload=True,\n            reload_dirs=[str(app_dir), str(app_first_dir)],\n        )\n        WatchFilesReload(config, target=run, sockets=[])\n        mock_watch.assert_called_once()\n        assert mock_watch.call_args[0] == (Path.cwd(),)",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(WatchFilesReload is None, reason='watchfiles not available')"
      ],
      "arguments": [
        "mocker",
        "reload_directory_structure"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert mock_watch.call_args[0] == (Path.cwd(),)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mocker.patch('uvicorn.supervisors.watchfilesreload.watch')"
      ],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_should_watch_one_dir_cwd` verifies that the `WatchFilesReload` class correctly sets up a file watching mechanism for a single directory, specifically the current working directory (CWD), when the application is configured to reload.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the `watch` function is called exactly once and that it is invoked with the current working directory as its argument. This ensures that the file watching functionality is correctly initialized to monitor changes in the specified directory.\n\n**Code Being Tested and How It Works**:  \nThe test creates a `Config` object with a specified application and reload settings, including directories to watch. It uses the `as_cwd` context manager to temporarily change the working directory to `reload_directory_structure`. Inside this context, it instantiates `WatchFilesReload`, which is expected to call the `watch` function with the current directory. The assertion checks that `mock_watch` was called once and that the argument passed to it matches the current working directory.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The `mocker.patch` method is used to replace the actual `watch` function with a mock, allowing the test to verify interactions without invoking the real file watching logic.\n- **Context Managers**: The `as_cwd` context manager is employed to manage the working directory change cleanly, ensuring that the original directory is restored after the test.\n- **Assertions**: The test uses assertions to validate that the expected behavior (i.e., the call to `watch`) occurs as intended, which is a fundamental aspect of unit testing to confirm that the code behaves correctly under specified conditions."
    },
    {
      "name": "test_should_watch_separate_dirs_outside_cwd",
      "module": "test_reload",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 353,
      "end_line_number": 368,
      "source_code": "def test_should_watch_separate_dirs_outside_cwd(mocker, reload_directory_structure):\n    mock_watch = mocker.patch(\"uvicorn.supervisors.watchfilesreload.watch\")\n    app_dir = reload_directory_structure / \"app\"\n    app_first_dir = reload_directory_structure / \"app_first\"\n    config = Config(\n        app=\"tests.test_config:asgi_app\",\n        reload=True,\n        reload_dirs=[str(app_dir), str(app_first_dir)],\n    )\n    WatchFilesReload(config, target=run, sockets=[])\n    mock_watch.assert_called_once()\n    assert set(mock_watch.call_args[0]) == {\n        app_dir,\n        app_first_dir,\n        Path.cwd(),\n    }",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(WatchFilesReload is None, reason='watchfiles not available')"
      ],
      "arguments": [
        "mocker",
        "reload_directory_structure"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert set(mock_watch.call_args[0]) == {app_dir, app_first_dir, Path.cwd()}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "mocker.patch('uvicorn.supervisors.watchfilesreload.watch')"
      ],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_should_watch_separate_dirs_outside_cwd` verifies that the `WatchFilesReload` class correctly monitors specified directories for changes, even when those directories are outside the current working directory (CWD). This ensures that the application can reload when files in these directories are modified.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the `watch` function is called exactly once and that the arguments passed to it include the specified directories (`app_dir`, `app_first_dir`) and the current working directory. This confirms that the reload mechanism is set up to monitor the correct paths.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `WatchFilesReload` class, which is initialized with a configuration that specifies the application to run and the directories to watch for changes. The `reload_dirs` parameter is crucial as it determines which directories will trigger a reload when changes are detected. The `mock_watch` is a mock object that replaces the actual `watch` function, allowing the test to assert that it was called with the expected arguments without executing the real file-watching logic.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test uses the `mocker.patch` method to replace the `watch` function with a mock, enabling verification of its call without side effects.\n- **Path Handling**: The test constructs paths using the `Path` class, ensuring compatibility across different operating systems.\n- **Set Assertions**: The test uses a set to compare the arguments passed to the mock, which allows for an unordered comparison of the expected directories, ensuring that all specified directories are included regardless of their order."
    },
    {
      "name": "test_display_path_relative",
      "module": "test_reload",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 371,
      "end_line_number": 375,
      "source_code": "def test_display_path_relative(tmp_path):\n    with as_cwd(tmp_path):\n        p = tmp_path / \"app\" / \"foobar.py\"\n        # accept windows paths as wells as posix\n        assert _display_path(p) in (\"'app/foobar.py'\", \"'app\\\\foobar.py'\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmp_path"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert _display_path(p) in (\"'app/foobar.py'\", \"'app\\\\foobar.py'\")"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_display_path_relative` unit test is designed to verify the behavior of the `_display_path` function when given a file path that is relative to the current working directory. It ensures that the function correctly formats the path in a way that is consistent across different operating systems (Windows and POSIX).\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the output of `_display_path` for a given path (`p`) matches one of the expected string formats: either `\"'app/foobar.py'\"` for POSIX systems or `\"'app\\\\foobar.py'\"` for Windows systems. This confirms that the function handles relative paths correctly and formats them appropriately based on the operating system.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `_display_path` function, which attempts to return a string representation of a path relative to the current working directory. It uses `path.relative_to(Path.cwd())` to compute the relative path. If the path cannot be made relative (e.g., if it is outside the current working directory), it falls back to returning the absolute path. The test sets the current working directory to `tmp_path` using the `as_cwd` context manager, ensuring that the path is relative to this temporary directory.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Manager**: The `as_cwd` context manager is employed to temporarily change the working directory for the duration of the test, ensuring isolation and preventing side effects on other tests.\n- **Path Manipulation**: The test utilizes the `Path` class from the `pathlib` module to handle file paths in a platform-independent manner.\n- **Assertions**: The test uses an assertion to verify that the output of `_display_path` is one of the expected values, which is a common practice in unit testing to validate functionality."
    },
    {
      "name": "test_display_path_non_relative",
      "module": "test_reload",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 378,
      "end_line_number": 380,
      "source_code": "def test_display_path_non_relative():\n    p = Path(\"/foo/bar.py\")\n    assert _display_path(p) in (\"'/foo/bar.py'\", \"'\\\\foo\\\\bar.py'\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert _display_path(p) in (\"'/foo/bar.py'\", \"'\\\\foo\\\\bar.py'\")"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_display_path_non_relative` aims to verify the behavior of the `_display_path` function when provided with an absolute path. Specifically, it checks that the function correctly formats the path as a string, ensuring that it returns the expected output for non-relative paths.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the output of `_display_path` for the input `Path(\"/foo/bar.py\")` is either `'/foo/bar.py'` or `'\\\\foo\\\\bar.py'`. This is important because it confirms that the function handles absolute paths correctly and formats them consistently, regardless of the operating system's path separator.\n\n**Code Being Tested and How It Works**:  \nThe `_display_path` function attempts to return a string representation of the path relative to the current working directory (using `path.relative_to(Path.cwd())`). If the path is not relative (which is the case for absolute paths), it raises a `ValueError`, and the function falls back to returning the absolute path as a string. The test specifically checks this fallback behavior by providing an absolute path.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a simple assertion to verify the output of the function against expected values. It uses a tuple to check if the result is one of the two valid string representations of the path, which is a straightforward way to handle multiple expected outcomes. This pattern is effective for validating functions with potentially variable outputs based on the environment (e.g., different path formats on different operating systems)."
    },
    {
      "name": "test_base_reloader_run",
      "module": "test_reload",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 383,
      "end_line_number": 411,
      "source_code": "def test_base_reloader_run(tmp_path):\n    calls = []\n    step = 0\n\n    class CustomReload(BaseReload):\n        def startup(self):\n            calls.append(\"startup\")\n\n        def restart(self):\n            calls.append(\"restart\")\n\n        def shutdown(self):\n            calls.append(\"shutdown\")\n\n        def should_restart(self):\n            nonlocal step\n            step += 1\n            if step == 1:\n                return None\n            elif step == 2:\n                return [tmp_path / \"foobar.py\"]\n            else:\n                raise StopIteration()\n\n    config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n    reloader = CustomReload(config, target=run, sockets=[])\n    reloader.run()\n\n    assert calls == [\"startup\", \"restart\", \"shutdown\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmp_path"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert calls == ['startup', 'restart', 'shutdown']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "reloader.run",
          "body": "def run(sockets):\n    pass"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_base_reloader_run` unit test is designed to verify the behavior of the `BaseReload` class's `run` method, specifically ensuring that the reloader correctly executes its lifecycle methods: `startup`, `restart`, and `shutdown` in the expected order when a file change is detected.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the `CustomReload` class, which extends `BaseReload`, properly invokes the `startup`, `restart`, and `shutdown` methods in sequence. It also verifies that the reloader's `should_restart` method behaves as intended, returning `None` on the first call, a list of files on the second call, and raising a `StopIteration` exception on subsequent calls.\n\n**Code Being Tested and How It Works**:  \nThe test creates a subclass `CustomReload` of `BaseReload`, overriding its methods to append strings to a `calls` list whenever they are invoked. The `should_restart` method is designed to control the flow of the reloader's execution based on the `step` variable. The test initializes a `Config` object with a specified app and reload option, creates an instance of `CustomReload`, and calls its `run` method. Finally, it asserts that the `calls` list matches the expected sequence of method calls.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Subclassing for Testing**: The test uses a subclass (`CustomReload`) to override specific methods of `BaseReload`, allowing for controlled testing of the reloader's behavior without modifying the original class.\n- **State Tracking**: The test tracks the state of method calls using a list (`calls`) and a counter (`step`), which helps in verifying the order and conditions under which methods are invoked.\n- **Assertions**: The test concludes with an assertion to ensure that the expected sequence of method calls occurred, which is a common practice in unit testing to validate outcomes against expected results."
    },
    {
      "name": "test_base_reloader_should_exit",
      "module": "test_reload",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 414,
      "end_line_number": 427,
      "source_code": "def test_base_reloader_should_exit(tmp_path):\n    config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n    reloader = BaseReload(config, target=run, sockets=[])\n    assert not reloader.should_exit.is_set()\n    reloader.pause()\n\n    if sys.platform == \"win32\":\n        reloader.signal_handler(signal.CTRL_C_EVENT, None)  # pragma: py-not-win32\n    else:\n        reloader.signal_handler(signal.SIGINT, None)  # pragma: py-win32\n\n    assert reloader.should_exit.is_set()\n    with pytest.raises(StopIteration):\n        reloader.pause()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmp_path"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert not reloader.should_exit.is_set()",
        "assert reloader.should_exit.is_set()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_base_reloader_should_exit` test verifies the behavior of the `BaseReload` class in handling exit signals, specifically ensuring that the reloader correctly sets its exit flag when a termination signal (like `SIGINT` or `CTRL_C_EVENT`) is received.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the `should_exit` flag of the `BaseReload` instance is initially unset, indicating that the reloader is running. After simulating a signal (either `SIGINT` or `CTRL_C_EVENT` depending on the platform), it asserts that the `should_exit` flag is set, indicating that the reloader should exit. It also verifies that calling `pause()` after the signal raises a `StopIteration` exception, which is expected behavior when the reloader is instructed to stop.\n\n**Code Being Tested and How It Works**:  \nThe test creates an instance of `BaseReload` with a configuration that enables reloading. It then calls `pause()` to simulate the reloader waiting for signals. The test simulates a signal using the `signal_handler` method, which is responsible for setting the `should_exit` flag. The test checks the state of this flag before and after the signal is handled, ensuring that the reloader behaves as expected when it receives a termination signal.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs assertions to validate the state of the `should_exit` flag before and after the signal handling. It also uses `pytest.raises` to assert that a specific exception (`StopIteration`) is raised when the reloader is paused after receiving a signal. This pattern of checking state changes and expected exceptions is a common technique in unit testing to ensure that the code behaves correctly under various conditions. Additionally, the test is designed to be platform-independent by checking the operating system and adjusting the signal handling accordingly."
    },
    {
      "name": "test_base_reloader_closes_sockets_on_shutdown",
      "module": "test_reload",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 430,
      "end_line_number": 437,
      "source_code": "def test_base_reloader_closes_sockets_on_shutdown():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n    reloader = BaseReload(config, target=run, sockets=[sock])\n    reloader.startup()\n    assert sock.fileno() != -1\n    reloader.shutdown()\n    assert sock.fileno() == -1",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert sock.fileno() != -1",
        "assert sock.fileno() == -1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "reloader.startup",
          "body": "def startup(self):\n    calls.append('startup')"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe main purpose of the `test_base_reloader_closes_sockets_on_shutdown` test is to verify that the `BaseReload` class properly closes the sockets it manages when the `shutdown` method is called. This ensures that resources are released correctly and that the application can shut down cleanly without leaving open socket connections.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that after invoking the `shutdown` method on the `BaseReload` instance, the file descriptor associated with the socket is no longer valid (i.e., it should return -1). This indicates that the socket has been successfully closed.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `BaseReload` class, particularly its `shutdown` method. The test creates a socket using the `socket` module, initializes a `BaseReload` instance with this socket, and calls the `startup` method to simulate starting the reloader. After confirming that the socket is open (file descriptor is not -1), it calls the `shutdown` method, which is expected to close the socket. The test then asserts that the socket's file descriptor is -1, confirming that the socket has been closed.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward setup and teardown pattern, where a socket is created before the test and is expected to be closed during the test. It uses assertions to validate the state of the socket before and after the shutdown operation. This pattern is common in unit tests to ensure that resources are managed correctly and that the system behaves as expected under different conditions. Additionally, the test is self-contained, meaning it does not rely on external state or configuration, which is a best practice in unit testing."
    },
    {
      "name": "test_reloader_should_initialize",
      "module": "test_reload",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 77,
      "end_line_number": 87,
      "source_code": "def test_reloader_should_initialize(self) -> None:\n        \"\"\"\n        A basic sanity check.\n\n        Simply run the reloader against a no-op server, and signal for it to\n        quit immediately.\n        \"\"\"\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n            reloader.shutdown()",
      "docstring": "A basic sanity check.\n\nSimply run the reloader against a no-op server, and signal for it to\nquit immediately.",
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_reloader_should_initialize` test serves as a basic sanity check to ensure that the reloader component of the application initializes correctly when provided with a configuration for a no-operation (no-op) server. It verifies that the reloader can start and shut down without errors.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically verifies that the reloader can be set up with a given configuration and that it can be shut down immediately afterward. It checks that the reloader's initialization process does not raise any exceptions and that the configuration is valid for reloading.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the `as_cwd` context manager to temporarily change the working directory to `self.reload_path`. Within this context, it creates a `Config` object with the application set to a no-op ASGI app and the reload option enabled. The `_setup_reloader` method is called to initialize the reloader with this configuration. Finally, the `shutdown` method is invoked on the reloader to ensure it can terminate cleanly. The `shutdown` method appends a 'shutdown' call to a list, which indicates that the shutdown process was executed.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Manager**: The use of the `as_cwd` context manager allows for a clean setup and teardown of the working directory, ensuring that the test does not affect the global state.\n- **Fixture Setup**: The test class uses a fixture (`setup`) to prepare the necessary environment and dependencies before each test runs, ensuring that the tests are isolated and repeatable.\n- **Parameterization**: The test is parameterized with different reloader classes (`StatReload` and `WatchFilesReload`), allowing it to verify the behavior of the reloader under different configurations without duplicating code. This enhances test coverage and maintainability."
    },
    {
      "name": "test_reload_when_python_file_is_changed",
      "module": "test_reload",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 90,
      "end_line_number": 100,
      "source_code": "def test_reload_when_python_file_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            changes = self._reload_tester(touch_soon, reloader, file)\n            assert changes == [file]\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
      ],
      "arguments": [
        "self",
        "touch_soon"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert changes == [file]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_reload_when_python_file_is_changed` verifies that the reloader functionality in the Uvicorn server correctly detects changes to a specified Python file (`main.py`) and triggers a reload of the application.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when the `main.py` file is modified (touched), the reloader identifies this change and returns the modified file in a list. The assertion `assert changes == [file]` confirms that the reloader correctly recognizes the file change.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with several components:\n- **`as_cwd`**: A context manager that temporarily changes the working directory to `self.reload_path`, ensuring that the reloader operates in the correct context.\n- **`Config`**: An object that holds configuration settings for the Uvicorn server, including the application to run and the reload option.\n- **`_setup_reloader`**: This method initializes the reloader based on the provided configuration, setting up the necessary parameters for file watching.\n- **`_reload_tester`**: This method simulates file changes and checks if the reloader detects them. It uses the `touch_soon` function to modify the file and then checks for changes.\n- **`reloader.shutdown`**: This method is called to cleanly shut down the reloader after the test completes.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The use of `as_cwd` ensures that the test runs in a controlled environment, preventing side effects on the global state.\n- **Assertions**: The test employs assertions to validate expected outcomes, ensuring that the reloader behaves as intended.\n- **Separation of Concerns**: The test is structured to focus solely on the reloader's behavior, relying on helper methods (`_setup_reloader` and `_reload_tester`) to encapsulate specific functionalities, promoting code reusability and clarity."
    },
    {
      "name": "test_should_reload_when_python_file_in_subdir_is_changed",
      "module": "test_reload",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 103,
      "end_line_number": 112,
      "source_code": "def test_should_reload_when_python_file_in_subdir_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \"app\" / \"sub\" / \"sub.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, file)\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
      ],
      "arguments": [
        "self",
        "touch_soon"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert self._reload_tester(touch_soon, reloader, file)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_should_reload_when_python_file_in_subdir_is_changed` verifies that the application correctly reloads when a Python file located in a subdirectory is modified. This is crucial for development environments where changes to code should trigger an automatic reload of the application.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that the reloader detects changes to the specified Python file (`sub.py`) in the subdirectory and confirms that the reloader's behavior aligns with the expected outcome, which is that the file change should trigger a reload.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the `as_cwd` context manager to temporarily change the working directory to `self.reload_path`. It then creates a `Config` object with the application to be tested and enables the reload feature. The `_setup_reloader` method initializes the reloader based on the configuration. The `_reload_tester` method is called to simulate the file change using the `touch_soon` function, which is expected to modify the file. The assertion checks that the reloader correctly identifies the change and returns the modified file.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The use of the `as_cwd` context manager ensures that the working directory is reset after the test, maintaining test isolation.\n- **Dependency Injection**: The `touch_soon` callable is passed as a parameter, allowing for flexible simulation of file changes.\n- **Assertions**: The test employs assertions to validate that the expected behavior (file change detection) occurs, ensuring that the reloader functions as intended.\n- **Parameterized Testing**: The test is part of a parameterized suite, allowing it to be run with different reloader classes, enhancing coverage and robustness of the tests."
    },
    {
      "name": "test_should_not_reload_when_python_file_in_excluded_subdir_is_changed",
      "module": "test_reload",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 115,
      "end_line_number": 129,
      "source_code": "def test_should_not_reload_when_python_file_in_excluded_subdir_is_changed(self, touch_soon) -> None:\n        sub_dir = self.reload_path / \"app\" / \"sub\"\n        sub_file = sub_dir / \"sub.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_excludes=[str(sub_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert not self._reload_tester(touch_soon, reloader, sub_file)\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [WatchFilesReload, WatchGodReload])"
      ],
      "arguments": [
        "self",
        "touch_soon"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert not self._reload_tester(touch_soon, reloader, sub_file)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_should_not_reload_when_python_file_in_excluded_subdir_is_changed` aims to verify that the application does not trigger a reload when a Python file located in a specified excluded subdirectory is modified. This is crucial for ensuring that the reloader respects the exclusion rules defined in the configuration.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that changes to a Python file (`sub.py`) within an excluded directory (`app/sub`) do not cause the reloader to restart the application. The expected outcome is that the `_reload_tester` method returns `False`, indicating no reload occurred.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a reloader using a configuration that includes the `reload_excludes` option, which specifies the subdirectory to be excluded from reload monitoring. The `as_cwd` context manager temporarily changes the working directory to the reload path, ensuring that the reloader operates in the correct context. The `_setup_reloader` method initializes the reloader with the provided configuration, and `_reload_tester` is called to simulate a file change. The assertion checks that the reloader does not trigger a reload when the specified file is touched.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The use of the `as_cwd` context manager allows for clean management of the working directory, ensuring that the test does not affect the global state.\n- **Assertions**: The test employs assertions to validate the expected behavior, specifically checking that the reloader does not restart when a file in the excluded directory is modified.\n- **Configuration Testing**: The test verifies the behavior of the reloader based on specific configuration settings, ensuring that the application behaves correctly under different conditions."
    },
    {
      "name": "test_reload_when_pattern_matched_file_is_changed",
      "module": "test_reload",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 132,
      "end_line_number": 141,
      "source_code": "def test_reload_when_pattern_matched_file_is_changed(self, result: bool, touch_soon) -> None:\n        file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_includes=[\"*.js\"])\n            reloader = self._setup_reloader(config)\n\n            assert bool(self._reload_tester(touch_soon, reloader, file)) == result\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class, result', [(StatReload, False), (WatchFilesReload, True)])"
      ],
      "arguments": [
        "self",
        "result",
        "touch_soon"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert bool(self._reload_tester(touch_soon, reloader, file)) == result"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_reload_when_pattern_matched_file_is_changed` is designed to verify that the application correctly reloads when a file matching a specified pattern (in this case, a JavaScript file) is modified. This is crucial for development environments where live reloading is expected to reflect changes immediately.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when a file (`main.js`) is touched (modified), the reloader detects this change and triggers a reload. The expected behavior is that the result of the reload operation matches the provided `result` argument, indicating whether the reload was successful or not.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes several components:\n- `as_cwd`: A context manager that temporarily changes the working directory to `self.reload_path`, ensuring that the reloader operates in the correct context.\n- `Config`: An object that holds configuration settings for the reloader, including the application to run and the file patterns to include for reloading.\n- `_setup_reloader`: A method that initializes the reloader based on the provided configuration, ensuring it is set up to monitor the correct files.\n- `_reload_tester`: A method that simulates the file modification (using `touch_soon`) and checks if the reloader detects the change and triggers a reload.\n\nThe test asserts that the boolean result of `_reload_tester` matches the expected `result`, confirming the reloader's behavior.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Parameterized Testing**: The test likely uses parameters (not shown in the snippet) to run multiple scenarios with different expected results, enhancing coverage and robustness.\n- **Context Management**: The use of `as_cwd` ensures that the test does not affect the global state of the working directory, promoting isolation and reliability in tests.\n- **Assertions**: The test employs assertions to validate the expected outcomes, which is a fundamental practice in unit testing to ensure correctness.\n- **Mocking/Touching Files**: The `touch_soon` function simulates file changes, allowing the test to verify the reloader's response without needing actual file modifications in a real filesystem."
    },
    {
      "name": "test_should_not_reload_when_exclude_pattern_match_file_is_changed",
      "module": "test_reload",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 150,
      "end_line_number": 168,
      "source_code": "def test_should_not_reload_when_exclude_pattern_match_file_is_changed(self, touch_soon) -> None:\n        python_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        css_file = self.reload_path / \"app\" / \"css\" / \"main.css\"\n        js_file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\"*\"],\n                reload_excludes=[\"*.js\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, python_file)\n            assert self._reload_tester(touch_soon, reloader, css_file)\n            assert not self._reload_tester(touch_soon, reloader, js_file)\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
      ],
      "arguments": [
        "self",
        "touch_soon"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert self._reload_tester(touch_soon, reloader, python_file)",
        "assert self._reload_tester(touch_soon, reloader, css_file)",
        "assert not self._reload_tester(touch_soon, reloader, js_file)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_should_not_reload_when_exclude_pattern_match_file_is_changed` aims to verify that the reloader does not trigger a reload when a file that matches the exclusion pattern (in this case, a JavaScript file) is modified. This is crucial for ensuring that the application behaves as expected when certain file types are excluded from the reload mechanism.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that changes to a JavaScript file (`main.js`) do not cause the application to reload, while changes to other file types (like Python and CSS files) do trigger a reload. This behavior is validated through assertions that confirm the expected outcomes of the `_reload_tester` method.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `Config` class, which is configured with `reload_excludes` set to exclude JavaScript files. The `_setup_reloader` method initializes the reloader with this configuration, and the `_reload_tester` method simulates file changes and checks if the reloader detects them. The test uses the `touch_soon` function to modify the files and checks the reloader's response to these modifications.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Context Management**: The `as_cwd` context manager temporarily changes the working directory for the duration of the test, ensuring that the reloader operates in the correct context.\n- **Assertions**: The use of assertions to validate the expected behavior of the reloader after file modifications is a standard practice in unit testing, ensuring that the code behaves as intended.\n- **Parameterized Testing**: The test is part of a parameterized test suite, allowing it to be run with different reloader classes, which enhances test coverage and flexibility."
    },
    {
      "name": "test_should_not_reload_when_dot_file_is_changed",
      "module": "test_reload",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 171,
      "end_line_number": 180,
      "source_code": "def test_should_not_reload_when_dot_file_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \".dotted\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            assert not self._reload_tester(touch_soon, reloader, file)\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
      ],
      "arguments": [
        "self",
        "touch_soon"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert not self._reload_tester(touch_soon, reloader, file)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_should_not_reload_when_dot_file_is_changed` aims to verify that the reloader does not trigger a reload when a dot file (specifically, a file starting with a dot, such as `.dotted`) is modified. This is important for ensuring that certain files, which may be configuration or metadata files, do not inadvertently cause the application to restart.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the reloader correctly identifies that a change to a dot file should not result in a reload of the application. The assertion `assert not self._reload_tester(touch_soon, reloader, file)` confirms that the reloader does not detect the change as a reason to restart the application.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `BaseReload` class and its methods, particularly `_reload_tester`, which is responsible for checking for file changes and determining if a reload is necessary. The `touch_soon` function simulates a file modification, and the `reloader` is set up with a configuration that allows for reloading. The test runs within a context manager `as_cwd`, which temporarily changes the working directory to `self.reload_path`, ensuring that the file paths are correctly resolved.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The use of the `as_cwd` context manager allows for clean setup and teardown of the working directory, ensuring that the test does not affect the global state.\n- **Assertions**: The test employs assertions to validate the expected behavior of the reloader, specifically checking that no reload occurs when a dot file is modified.\n- **Isolation of Tests**: The test is designed to be independent, focusing solely on the behavior of the reloader with respect to dot files, which is a good practice in unit testing to ensure clarity and maintainability."
    },
    {
      "name": "test_should_reload_when_directories_have_same_prefix",
      "module": "test_reload",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 183,
      "end_line_number": 200,
      "source_code": "def test_should_reload_when_directories_have_same_prefix(self, touch_soon) -> None:\n        app_dir = self.reload_path / \"app\"\n        app_file = app_dir / \"src\" / \"main.py\"\n        app_first_dir = self.reload_path / \"app_first\"\n        app_first_file = app_first_dir / \"src\" / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_dirs=[str(app_dir), str(app_first_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, app_file)\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
      ],
      "arguments": [
        "self",
        "touch_soon"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert self._reload_tester(touch_soon, reloader, app_file)",
        "assert self._reload_tester(touch_soon, reloader, app_first_file)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_should_reload_when_directories_have_same_prefix` is designed to verify that the reloader correctly detects changes in files located in directories that share the same prefix. This is crucial for ensuring that the application can automatically reload when relevant files are modified, enhancing the development experience.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that when files in both `app` and `app_first` directories are modified, the reloader responds appropriately by triggering a reload. It asserts that the `_reload_tester` method returns a truthy value, indicating that the reloader has detected the changes and is functioning as expected.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a configuration for the reloader using the `Config` class, specifying the application to be reloaded and the directories to watch for changes. The `_setup_reloader` method initializes the reloader based on the provided configuration. The `_reload_tester` method is then called with the `touch_soon` function and the paths of the files to be monitored. This method simulates file modifications and checks if the reloader detects these changes. Finally, the reloader is shut down to clean up resources.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Context Management**: The `as_cwd` context manager temporarily changes the working directory for the duration of the test, ensuring that file paths are resolved correctly.\n- **Parameterized Testing**: The use of `pytest.mark.parametrize` allows the test to run with different reloader classes (`StatReload` and `WatchFilesReload`), ensuring that the functionality is validated across multiple implementations.\n- **Assertions**: The test uses assertions to verify that the expected behavior occurs, specifically that the reloader detects file changes, which is critical for the reliability of the reloading mechanism."
    },
    {
      "name": "test_should_not_reload_when_only_subdirectory_is_watched",
      "module": "test_reload",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 210,
      "end_line_number": 225,
      "source_code": "def test_should_not_reload_when_only_subdirectory_is_watched(self, touch_soon) -> None:\n        app_dir = self.reload_path / \"app\"\n        app_dir_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        root_file = self.reload_path / \"main.py\"\n\n        config = Config(\n            app=\"tests.test_config:asgi_app\",\n            reload=True,\n            reload_dirs=[str(app_dir)],\n        )\n        reloader = self._setup_reloader(config)\n\n        assert self._reload_tester(touch_soon, reloader, app_dir_file)\n        assert not self._reload_tester(touch_soon, reloader, root_file, app_dir / \"~ignored\")\n\n        reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, pytest.param(WatchFilesReload, marks=skip_if_m1)])"
      ],
      "arguments": [
        "self",
        "touch_soon"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert self._reload_tester(touch_soon, reloader, app_dir_file)",
        "assert not self._reload_tester(touch_soon, reloader, root_file, app_dir / '~ignored')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_should_not_reload_when_only_subdirectory_is_watched` aims to verify that the application does not reload when changes are made to files in a specific subdirectory that is being watched, while the main application directory is also being monitored. This ensures that the reloader behaves correctly by ignoring changes in certain directories, which is crucial for performance and stability during development.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two scenarios: \n1. It asserts that a change in a file located in the watched subdirectory (`app_dir_file`) triggers a reload.\n2. It confirms that a change in a file located in the root directory (`root_file`) does not trigger a reload when the reloader is configured to watch only the subdirectory (`app_dir`).\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the `_setup_reloader` method to initialize a reloader with a configuration that specifies the directories to watch. The `_reload_tester` method is then called to simulate file changes and check if the reloader detects these changes. The reloader's behavior is determined by the `should_restart` method in the `WatchFilesReload` class, which checks for changes in the specified directories and applies the defined filters to decide if a reload should occur.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs assertions to validate expected outcomes, using `assert` statements to confirm that the reloader behaves as intended. It also utilizes a parameterized approach to test different reloader classes, ensuring that the functionality is consistent across various implementations. The use of helper methods (`_setup_reloader` and `_reload_tester`) encapsulates setup and testing logic, promoting code reuse and clarity in the test structure."
    },
    {
      "name": "test_override_defaults",
      "module": "test_reload",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 234,
      "end_line_number": 253,
      "source_code": "def test_override_defaults(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        dotted_dir_file = self.reload_path / \".dotted_dir\" / \"file.txt\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                # We need to add *.txt otherwise no regular files will match\n                reload_includes=[\".*\", \"*.txt\"],\n                reload_excludes=[\"*.py\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, dotted_dir_file)\n            assert not self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
      ],
      "arguments": [
        "self",
        "touch_soon"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert self._reload_tester(touch_soon, reloader, dotted_file)",
        "assert self._reload_tester(touch_soon, reloader, dotted_dir_file)",
        "assert not self._reload_tester(touch_soon, reloader, python_file)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_override_defaults` unit test is designed to verify the behavior of the reloader configuration in the Uvicorn server when handling file changes. Specifically, it checks that the reloader correctly identifies which files should trigger a reload based on the specified inclusion and exclusion patterns.\n\n**Specific Functionality or Behavior Verified**:  \nThe test ensures that:\n1. Files matching the inclusion patterns (e.g., `*.txt` and any regular files) trigger a reload.\n2. Files matching the exclusion patterns (e.g., Python files) do not trigger a reload.\n3. The reloader behaves as expected when files are touched (modified) to simulate changes.\n\n**Code Being Tested and How It Works**:  \nThe test interacts with the `Config` class to set up a reloader with specific inclusion and exclusion patterns. It uses the `_setup_reloader` method to initialize the reloader and the `_reload_tester` method to simulate file modifications. The assertions check:\n- That touching the `dotted_file` and `dotted_dir_file` results in a reload (returns `True`).\n- That touching the `python_file` does not trigger a reload (returns `False`).\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Manager**: The `as_cwd` context manager is used to temporarily change the working directory for the duration of the test, ensuring that file paths are resolved correctly.\n- **Assertions**: The test employs assertions to validate the expected outcomes of the reloader's behavior, ensuring that the reloader responds correctly to file changes.\n- **Parameterized Testing**: The test is marked with `pytest.mark.parametrize`, allowing it to be run with different reloader classes, enhancing its robustness and coverage."
    },
    {
      "name": "test_explicit_paths",
      "module": "test_reload",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 262,
      "end_line_number": 279,
      "source_code": "def test_explicit_paths(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        non_dotted_file = self.reload_path / \"ext\" / \"ext.jpg\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\".dotted\", \"ext/ext.jpg\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, non_dotted_file)\n            assert self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
      ],
      "arguments": [
        "self",
        "touch_soon"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert self._reload_tester(touch_soon, reloader, dotted_file)",
        "assert self._reload_tester(touch_soon, reloader, non_dotted_file)",
        "assert self._reload_tester(touch_soon, reloader, python_file)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_explicit_paths` function is designed to verify that the reloader correctly identifies and responds to changes in specified files, particularly those that are explicitly included in the reload configuration. This ensures that the application can dynamically reload when certain files are modified, which is crucial for development efficiency.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the reloader successfully detects changes in three specific files: a hidden file (\".dotted\"), a non-hidden file (\"ext/ext.jpg\"), and a Python file (\"main.py\"). It asserts that the reloader responds appropriately to modifications in these files, confirming that the reload mechanism is functioning as intended.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the `Config` class to set up a reloader with specific parameters, including `reload_includes` that specify which files should trigger a reload. The `_setup_reloader` method initializes the reloader based on this configuration. The `_reload_tester` method is then called for each file, which restarts the reloader and simulates file modifications to check if the reloader detects these changes. The test concludes by shutting down the reloader to clean up resources.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Management**: The `as_cwd` context manager temporarily changes the working directory for the duration of the test, ensuring that file paths are resolved correctly relative to the test's execution context.\n- **Assertions**: The use of assertions to validate the expected behavior of the reloader after file modifications is a key aspect of unit testing, ensuring that the code behaves as intended.\n- **Parameterized Testing**: Although not explicitly shown in this test, the surrounding context indicates the use of parameterized tests (e.g., `pytest.mark.parametrize`), which allows for testing multiple scenarios with different configurations efficiently."
    },
    {
      "name": "test_watchfiles_no_changes",
      "module": "test_reload",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 283,
      "end_line_number": 308,
      "source_code": "def test_watchfiles_no_changes(self) -> None:\n        sub_dir = self.reload_path / \"app\" / \"sub\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_excludes=[str(sub_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            from watchfiles import watch\n\n            assert isinstance(reloader, WatchFilesReload)\n            # just so we can make rust_timeout 100ms\n            reloader.watcher = watch(\n                sub_dir,\n                watch_filter=None,\n                stop_event=reloader.should_exit,\n                yield_on_timeout=True,\n                rust_timeout=100,\n            )\n\n            assert reloader.should_restart() is None\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(WatchFilesReload is None, reason='watchfiles not available')",
        "pytest.mark.parametrize('reloader_class', [WatchFilesReload])"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(reloader, WatchFilesReload)",
        "assert reloader.should_restart() is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        },
        {
          "name": "reloader.should_restart",
          "body": "def should_restart(self):\n    nonlocal step\n    step += 1\n    if step == 1:\n        return None\n    elif step == 2:\n        return [tmp_path / 'foobar.py']\n    else:\n        raise StopIteration()"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_watchfiles_no_changes` unit test is designed to verify that the reloader does not trigger a restart when there are no changes detected in the specified directory. This is crucial for ensuring that the application behaves correctly during development, where automatic reloading should only occur in response to actual file changes.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that the `should_restart` method of the `WatchFilesReload` class returns `None`, indicating that no changes have been detected in the watched directory. This confirms that the reloader is functioning as intended when no modifications occur.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a reloader using the `Config` class, specifying a directory to watch (`sub_dir`) and excluding it from reload triggers. The `watch` function from the `watchfiles` module is used to monitor the directory. The `should_restart` method is called to check for changes, and it is expected to return `None` when no changes are present. The reloader is then shut down to clean up resources.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Context Managers**: The `as_cwd` context manager is employed to temporarily change the working directory for the duration of the test, ensuring that the reloader operates in the correct context.\n- **Assertions**: The test uses assertions to validate the type of the reloader and the expected behavior of the `should_restart` method.\n- **Dependency Injection**: The test relies on the `Config` class to configure the reloader, demonstrating a common pattern in unit tests where dependencies are injected to facilitate testing in isolation."
    },
    {
      "name": "test_should_detect_new_reload_dirs",
      "module": "test_reload",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
      "line_number": 311,
      "end_line_number": 332,
      "source_code": "def test_should_detect_new_reload_dirs(self, touch_soon, caplog: pytest.LogCaptureFixture, tmp_path: Path) -> None:\n        app_dir = tmp_path / \"app\"\n        app_file = app_dir / \"file.py\"\n        app_dir.mkdir()\n        app_file.touch()\n        app_first_dir = tmp_path / \"app_first\"\n        app_first_file = app_first_dir / \"file.py\"\n\n        with as_cwd(tmp_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_includes=[\"app*\"])\n            reloader = self._setup_reloader(config)\n            assert self._reload_tester(touch_soon, reloader, app_file)\n\n            app_first_dir.mkdir()\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n            assert caplog.records[-2].levelno == logging.INFO\n            assert (\n                caplog.records[-1].message == \"WatchGodReload detected a new reload \"\n                f\"dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\"\n            )\n\n            reloader.shutdown()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('reloader_class', [WatchGodReload])"
      ],
      "arguments": [
        "self",
        "touch_soon",
        "caplog",
        "tmp_path"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "platform",
        "signal",
        "socket",
        "sys",
        "pathlib.Path",
        "time.sleep",
        "pytest",
        "tests.utils.as_cwd",
        "uvicorn.config.Config",
        "uvicorn.supervisors.basereload.BaseReload",
        "uvicorn.supervisors.basereload._display_path",
        "uvicorn.supervisors.statreload.StatReload",
        "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
        "uvicorn.supervisors.watchgodreload.WatchGodReload",
        "watchfiles.watch"
      ],
      "fixtures": [],
      "assertions": [
        "assert self._reload_tester(touch_soon, reloader, app_file)",
        "assert self._reload_tester(touch_soon, reloader, app_first_file)",
        "assert caplog.records[-2].levelno == logging.INFO",
        "assert caplog.records[-1].message == f\"WatchGodReload detected a new reload dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "as_cwd",
          "body": "@contextmanager\ndef as_cwd(path: Path):\n    \"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)"
        },
        {
          "name": "self._setup_reloader",
          "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "self._reload_tester",
          "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)"
        },
        {
          "name": "reloader.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe test `test_should_detect_new_reload_dirs` is designed to verify that the reloader correctly detects and responds to the addition of new directories that should be monitored for file changes. Specifically, it checks that when a new directory is created and added to the watch list, the reloader acknowledges this change and logs the appropriate message.\n\n**Specific Functionality or Behavior Verified**:  \nThe test ensures that the reloader can detect a new directory (`app_first_dir`) after it has been created and that it logs an informational message indicating that this directory has been added to the watch list. It also verifies that the reloader functions correctly by asserting that it can restart and detect changes in both the initially created directory and the newly added directory.\n\n**Code Being Tested and How It Works**:  \nThe code under test includes the `Config` class, which manages the application configuration, including reload settings, and the reloader class (likely `WatchGodReload` or similar) that monitors file changes. The `_setup_reloader` method initializes the reloader with the specified configuration, while the `_reload_tester` method simulates file changes to test if the reloader responds appropriately. The test creates a temporary directory structure, initializes the reloader, and then checks if it can detect changes in both the original and newly created directories.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable patterns:\n- **Context Management**: The `as_cwd` context manager temporarily changes the working directory for the duration of the test, ensuring that the reloader operates in the correct context.\n- **Logging Capture**: The `caplog` fixture is used to capture log messages generated during the test, allowing for assertions on the log output to verify that the expected messages are logged.\n- **Assertions**: The test uses assertions to validate both the functionality of the reloader (through `_reload_tester`) and the correctness of the log messages, ensuring that the behavior aligns with expectations."
    },
    {
      "name": "test_process_ping_pong",
      "module": "test_multiprocess",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_multiprocess.py",
      "line_number": 52,
      "end_line_number": 55,
      "source_code": "def test_process_ping_pong() -> None:\n    process = Process(Config(app=app), target=lambda x: None, sockets=[])\n    threading.Thread(target=process.always_pong, daemon=True).start()\n    assert process.ping()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "functools",
        "os",
        "signal",
        "socket",
        "threading",
        "time",
        "typing.Any",
        "typing.Callable",
        "pytest",
        "uvicorn.Config",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Scope",
        "uvicorn.supervisors.Multiprocess",
        "uvicorn.supervisors.multiprocess.Process",
        "subprocess",
        "sys"
      ],
      "fixtures": [],
      "assertions": [
        "assert process.ping()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_process_ping_pong` function is designed to verify that the `Process` class can successfully respond to a ping request. This is a fundamental check to ensure that inter-process communication (IPC) is functioning correctly, specifically that the process can receive a ping and send back a pong response.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks the behavior of the `ping` method in the `Process` class. It asserts that when a ping is sent to the process, it receives a response within the default timeout period, indicating that the process is alive and responsive.\n\n**Code Being Tested and How It Works**:  \nThe test creates an instance of the `Process` class, passing a configuration and a target function (which does nothing in this case). It then starts a separate thread that continuously sends pong responses via the `always_pong` method. The `assert process.ping()` line checks if the process can successfully receive a ping and respond with a pong, confirming that the IPC mechanism (using pipes) is operational.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Threading**: The test utilizes a separate thread to run the `always_pong` method, simulating a long-running process that can respond to pings. This is a common pattern in testing asynchronous or multi-threaded code.\n- **Assertions**: The use of assertions (`assert process.ping()`) is a straightforward way to validate expected outcomes in unit tests, ensuring that the process behaves as intended.\n- **Isolation**: The test is isolated from other tests, focusing solely on the ping-pong functionality of the `Process` class, which is crucial for maintaining the reliability of unit tests."
    },
    {
      "name": "test_process_ping_pong_timeout",
      "module": "test_multiprocess",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_multiprocess.py",
      "line_number": 58,
      "end_line_number": 60,
      "source_code": "def test_process_ping_pong_timeout() -> None:\n    process = Process(Config(app=app), target=lambda x: None, sockets=[])\n    assert not process.ping(0.1)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "functools",
        "os",
        "signal",
        "socket",
        "threading",
        "time",
        "typing.Any",
        "typing.Callable",
        "pytest",
        "uvicorn.Config",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Scope",
        "uvicorn.supervisors.Multiprocess",
        "uvicorn.supervisors.multiprocess.Process",
        "subprocess",
        "sys"
      ],
      "fixtures": [],
      "assertions": [
        "assert not process.ping(0.1)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_process_ping_pong_timeout` test is designed to verify the behavior of the `Process` class's `ping` method when a timeout occurs. Specifically, it checks that the method returns `False` when the ping operation does not receive a response within the specified timeout period of 0.1 seconds.\n\n**Specific Functionality or Behavior Verified**:  \nThis test confirms that the `ping` method of the `Process` class correctly identifies a timeout scenario. The assertion `assert not process.ping(0.1)` ensures that the method returns `False`, indicating that the process did not respond in time.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `Process` class, which is initialized with a configuration object (`Config(app=app)`) and a target function that does nothing (`lambda x: None`). The `sockets` parameter is an empty list, indicating that no sockets are being used. The `ping` method is expected to send a ping signal to the process and wait for a response. If the response is not received within the specified timeout (0.1 seconds), it should return `False`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThis test employs a straightforward assertion pattern to validate the expected outcome of a method under specific conditions (timeout). It uses a minimal setup for the `Process` class, focusing on the behavior of the `ping` method without involving complex interactions or dependencies. The use of a lambda function as the target allows for a controlled environment where the process does not perform any operations, isolating the test to the timeout behavior of the `ping` method."
    },
    {
      "name": "test_multiprocess_run",
      "module": "test_multiprocess",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_multiprocess.py",
      "line_number": 64,
      "end_line_number": 75,
      "source_code": "def test_multiprocess_run() -> None:\n    \"\"\"\n    A basic sanity check.\n\n    Simply run the supervisor against a no-op server, and signal for it to\n    quit immediately.\n    \"\"\"\n    config = Config(app=app, workers=2)\n    supervisor = Multiprocess(config, target=run, sockets=[])\n    threading.Thread(target=supervisor.run, daemon=True).start()\n    supervisor.signal_queue.append(signal.SIGINT)\n    supervisor.join_all()",
      "docstring": "A basic sanity check.\n\nSimply run the supervisor against a no-op server, and signal for it to\nquit immediately.",
      "decorators": [
        "new_console_in_windows"
      ],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "functools",
        "os",
        "signal",
        "socket",
        "threading",
        "time",
        "typing.Any",
        "typing.Callable",
        "pytest",
        "uvicorn.Config",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Scope",
        "uvicorn.supervisors.Multiprocess",
        "uvicorn.supervisors.multiprocess.Process",
        "subprocess",
        "sys"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_multiprocess_run` function serves as a basic sanity check for the multiprocess functionality of the Uvicorn server. It ensures that the supervisor can start a no-op server and handle a quit signal correctly.\n\n**Specific Functionality or Behavior Verified**:  \nThis test verifies that the `Multiprocess` supervisor can be initiated with a specified configuration and that it can respond to a signal (SIGINT) to terminate gracefully. It checks that the supervisor can run in a separate thread and that the signal handling mechanism works as intended.\n\n**Code Being Tested and How It Works**:  \nThe test creates a `Config` object with two workers and initializes a `Multiprocess` supervisor with a no-op target function (`run`). It starts the supervisor in a separate daemon thread, appends a SIGINT signal to the supervisor's signal queue, and then calls `join_all()` to wait for all processes to finish. This simulates a scenario where the server is instructed to shut down immediately.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Threading**: The test uses a separate thread to run the supervisor, allowing the main thread to continue executing and send signals.\n- **Signal Handling**: The test checks the ability of the supervisor to handle termination signals, which is crucial for graceful shutdowns in server applications.\n- **Daemon Threads**: The use of a daemon thread ensures that the test can exit without waiting for the thread to complete, which is useful for tests that need to run quickly and not block indefinitely."
    },
    {
      "name": "test_multiprocess_health_check",
      "module": "test_multiprocess",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_multiprocess.py",
      "line_number": 79,
      "end_line_number": 94,
      "source_code": "def test_multiprocess_health_check() -> None:\n    \"\"\"\n    Ensure that the health check works as expected.\n    \"\"\"\n    config = Config(app=app, workers=2)\n    supervisor = Multiprocess(config, target=run, sockets=[])\n    threading.Thread(target=supervisor.run, daemon=True).start()\n    time.sleep(1)\n    process = supervisor.processes[0]\n    process.kill()\n    assert not process.is_alive()\n    time.sleep(1)\n    for p in supervisor.processes:\n        assert p.is_alive()\n    supervisor.signal_queue.append(signal.SIGINT)\n    supervisor.join_all()",
      "docstring": "Ensure that the health check works as expected.",
      "decorators": [
        "new_console_in_windows"
      ],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "functools",
        "os",
        "signal",
        "socket",
        "threading",
        "time",
        "typing.Any",
        "typing.Callable",
        "pytest",
        "uvicorn.Config",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Scope",
        "uvicorn.supervisors.Multiprocess",
        "uvicorn.supervisors.multiprocess.Process",
        "subprocess",
        "sys"
      ],
      "fixtures": [],
      "assertions": [
        "assert not process.is_alive()",
        "assert p.is_alive()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_multiprocess_health_check` function is designed to verify that the health check mechanism of a multiprocess server operates correctly. It ensures that when a process is killed, the remaining processes are still alive, confirming that the supervisor can manage multiple worker processes effectively.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks two main behaviors: \n1. After killing one of the worker processes, it asserts that the killed process is no longer alive.\n2. It verifies that the other worker processes remain alive, ensuring that the supervisor can handle process failures without affecting the overall service availability.\n\n**Code Being Tested and How It Works**:  \nThe test utilizes the `Multiprocess` class, which is responsible for managing multiple worker processes. It starts a supervisor that runs the application with two workers. The test then simulates a failure by killing one of the worker processes and checks the state of the processes afterward. The `supervisor.signal_queue` is used to send a termination signal to gracefully shut down the remaining processes.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Threading**: The test runs the supervisor in a separate daemon thread, allowing the main thread to continue executing while the supervisor manages the worker processes.\n- **Assertions**: It employs assertions to validate the expected states of the processes, ensuring that the test fails if the actual behavior does not match the expected outcomes.\n- **Sleep Delays**: The use of `time.sleep()` introduces necessary delays to allow the processes to transition states, which is common in tests involving asynchronous or multiprocess behavior. This helps to ensure that the assertions are made after the state changes have had time to propagate."
    },
    {
      "name": "test_multiprocess_sigterm",
      "module": "test_multiprocess",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_multiprocess.py",
      "line_number": 98,
      "end_line_number": 107,
      "source_code": "def test_multiprocess_sigterm() -> None:\n    \"\"\"\n    Ensure that the SIGTERM signal is handled as expected.\n    \"\"\"\n    config = Config(app=app, workers=2)\n    supervisor = Multiprocess(config, target=run, sockets=[])\n    threading.Thread(target=supervisor.run, daemon=True).start()\n    time.sleep(1)\n    supervisor.signal_queue.append(signal.SIGTERM)\n    supervisor.join_all()",
      "docstring": "Ensure that the SIGTERM signal is handled as expected.",
      "decorators": [
        "new_console_in_windows"
      ],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "functools",
        "os",
        "signal",
        "socket",
        "threading",
        "time",
        "typing.Any",
        "typing.Callable",
        "pytest",
        "uvicorn.Config",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Scope",
        "uvicorn.supervisors.Multiprocess",
        "uvicorn.supervisors.multiprocess.Process",
        "subprocess",
        "sys"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_multiprocess_sigterm` function is designed to verify that the application correctly handles the SIGTERM signal, which is typically used to request the termination of a process. This test ensures that the application can gracefully shut down when it receives this signal.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that when the SIGTERM signal is appended to the `supervisor.signal_queue`, the application responds appropriately by terminating the worker processes. This behavior is crucial for ensuring that the application can be stopped cleanly, allowing for resource cleanup and preventing data loss.\n\n**Code Being Tested and How It Works**:  \nThe test creates a `Config` object with two worker processes and initializes a `Multiprocess` supervisor to manage these workers. It starts the supervisor in a separate thread and then simulates the receipt of a SIGTERM signal by appending it to the `signal_queue`. The `supervisor.join_all()` method is called to wait for all processes to finish, which should occur as a result of handling the SIGTERM signal. The actual handling of the signal is implemented in the `terminate` method of the `Multiprocess` class, which sends the SIGTERM signal to the worker processes.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Threading**: The test uses a separate thread to run the supervisor, allowing the main thread to continue executing and simulating the signal handling.\n- **Signal Simulation**: Instead of sending an actual SIGTERM signal, the test appends it to a signal queue, which is a common technique in unit tests to simulate external events.\n- **Graceful Shutdown Verification**: The test indirectly verifies that the application can handle shutdown requests gracefully, which is essential for robust server applications."
    },
    {
      "name": "test_multiprocess_sigbreak",
      "module": "test_multiprocess",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_multiprocess.py",
      "line_number": 112,
      "end_line_number": 121,
      "source_code": "def test_multiprocess_sigbreak() -> None:  # pragma: py-not-win32\n    \"\"\"\n    Ensure that the SIGBREAK signal is handled as expected.\n    \"\"\"\n    config = Config(app=app, workers=2)\n    supervisor = Multiprocess(config, target=run, sockets=[])\n    threading.Thread(target=supervisor.run, daemon=True).start()\n    time.sleep(1)\n    supervisor.signal_queue.append(getattr(signal, \"SIGBREAK\"))\n    supervisor.join_all()",
      "docstring": "Ensure that the SIGBREAK signal is handled as expected.",
      "decorators": [
        "pytest.mark.skipif(not hasattr(signal, 'SIGBREAK'), reason='platform unsupports SIGBREAK')",
        "new_console_in_windows"
      ],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "functools",
        "os",
        "signal",
        "socket",
        "threading",
        "time",
        "typing.Any",
        "typing.Callable",
        "pytest",
        "uvicorn.Config",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Scope",
        "uvicorn.supervisors.Multiprocess",
        "uvicorn.supervisors.multiprocess.Process",
        "subprocess",
        "sys"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_multiprocess_sigbreak` function is designed to verify that the SIGBREAK signal is handled correctly within a multiprocess environment. This is particularly relevant for platforms like Windows, where SIGBREAK is used instead of SIGTERM to terminate processes.\n\n**Specific Functionality or Behavior Verified**:  \nThe test ensures that when the SIGBREAK signal is appended to the `signal_queue` of the `supervisor`, the supervisor correctly processes this signal, which should lead to the termination of the worker processes. The test indirectly checks that the signal handling mechanism is functioning as intended.\n\n**Code Being Tested and How It Works**:  \nThe test creates a `Config` object with an application and two worker processes. It then initializes a `Multiprocess` supervisor that runs the application in a separate thread. After a brief sleep to allow the supervisor to start, the SIGBREAK signal is added to the `signal_queue`. The `join_all` method is called to wait for all processes to finish, which should occur as a result of the signal being processed. The actual behavior of the signal handling is implemented in the `target` method of the `Process` class, which sets up the signal handler for SIGBREAK.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Threading**: The test uses a separate thread to run the supervisor, allowing the main thread to continue executing and simulating asynchronous behavior.\n- **Signal Handling**: The test leverages Python's signal module to simulate the sending of a signal to the process, which is a common technique in testing systems that rely on asynchronous events or inter-process communication.\n- **Daemon Threads**: The use of a daemon thread ensures that the test can exit cleanly without waiting indefinitely for the thread to finish, which is important for unit tests to avoid hanging."
    },
    {
      "name": "test_multiprocess_sighup",
      "module": "test_multiprocess",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_multiprocess.py",
      "line_number": 125,
      "end_line_number": 138,
      "source_code": "def test_multiprocess_sighup() -> None:\n    \"\"\"\n    Ensure that the SIGHUP signal is handled as expected.\n    \"\"\"\n    config = Config(app=app, workers=2)\n    supervisor = Multiprocess(config, target=run, sockets=[])\n    threading.Thread(target=supervisor.run, daemon=True).start()\n    time.sleep(1)\n    pids = [p.pid for p in supervisor.processes]\n    supervisor.signal_queue.append(signal.SIGHUP)\n    time.sleep(1)\n    assert pids != [p.pid for p in supervisor.processes]\n    supervisor.signal_queue.append(signal.SIGINT)\n    supervisor.join_all()",
      "docstring": "Ensure that the SIGHUP signal is handled as expected.",
      "decorators": [
        "pytest.mark.skipif(not hasattr(signal, 'SIGHUP'), reason='platform unsupports SIGHUP')"
      ],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "functools",
        "os",
        "signal",
        "socket",
        "threading",
        "time",
        "typing.Any",
        "typing.Callable",
        "pytest",
        "uvicorn.Config",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Scope",
        "uvicorn.supervisors.Multiprocess",
        "uvicorn.supervisors.multiprocess.Process",
        "subprocess",
        "sys"
      ],
      "fixtures": [],
      "assertions": [
        "assert pids != [p.pid for p in supervisor.processes]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_multiprocess_sighup` function is designed to verify that the SIGHUP signal is correctly handled by the multiprocess supervisor in the Uvicorn server. It ensures that when the SIGHUP signal is sent, the processes managed by the supervisor are appropriately restarted or terminated.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the number of active processes changes after sending the SIGHUP signal. The assertion `assert pids != [p.pid for p in supervisor.processes]` confirms that the process list has been modified, indicating that the SIGHUP signal has triggered a response that affects the running processes.\n\n**Code Being Tested and How It Works**:  \nThe test initializes a `Multiprocess` supervisor with a specified configuration (2 workers) and starts it in a separate thread. It then captures the initial process IDs before sending the SIGHUP signal to the supervisor's signal queue. After a brief pause, it checks if the list of process IDs has changed, which would imply that the supervisor has reacted to the SIGHUP signal by altering the state of its managed processes.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Threading**: The test runs the supervisor in a separate thread to simulate a real-world scenario where the server operates concurrently with the main thread.\n- **Signal Handling**: It utilizes Python's `signal` module to send signals to the process, testing the signal handling capabilities of the supervisor.\n- **Assertions**: The test employs assertions to validate the expected behavior, ensuring that the process management logic responds correctly to signals.\n- **Sleep Delays**: The use of `time.sleep()` allows for asynchronous operations to complete, ensuring that the test checks the state of processes after sufficient time has passed for the signal handling to take effect."
    },
    {
      "name": "test_multiprocess_sigttin",
      "module": "test_multiprocess",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_multiprocess.py",
      "line_number": 142,
      "end_line_number": 153,
      "source_code": "def test_multiprocess_sigttin() -> None:\n    \"\"\"\n    Ensure that the SIGTTIN signal is handled as expected.\n    \"\"\"\n    config = Config(app=app, workers=2)\n    supervisor = Multiprocess(config, target=run, sockets=[])\n    threading.Thread(target=supervisor.run, daemon=True).start()\n    supervisor.signal_queue.append(signal.SIGTTIN)\n    time.sleep(1)\n    assert len(supervisor.processes) == 3\n    supervisor.signal_queue.append(signal.SIGINT)\n    supervisor.join_all()",
      "docstring": "Ensure that the SIGTTIN signal is handled as expected.",
      "decorators": [
        "pytest.mark.skipif(not hasattr(signal, 'SIGTTIN'), reason='platform unsupports SIGTTIN')"
      ],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "functools",
        "os",
        "signal",
        "socket",
        "threading",
        "time",
        "typing.Any",
        "typing.Callable",
        "pytest",
        "uvicorn.Config",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Scope",
        "uvicorn.supervisors.Multiprocess",
        "uvicorn.supervisors.multiprocess.Process",
        "subprocess",
        "sys"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(supervisor.processes) == 3"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_multiprocess_sigttin` function is designed to verify that the SIGTTIN signal is handled correctly by the multiprocess server in the Uvicorn application. It ensures that when the SIGTTIN signal is sent, the expected number of worker processes is created.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that upon receiving the SIGTTIN signal, the number of processes managed by the `Multiprocess` supervisor increases to three. This behavior is significant as it indicates that the server is correctly spawning additional worker processes in response to the signal, which is a critical aspect of its multiprocess handling capabilities.\n\n**Code Being Tested and How It Works**:  \nThe test initializes a `Config` object with an application and two workers, then creates a `Multiprocess` supervisor that runs the server. A separate thread is started to run the supervisor's `run` method. The test appends the SIGTTIN signal to the supervisor's signal queue, simulating the receipt of this signal. After a brief sleep to allow the signal to be processed, the test asserts that the length of the `supervisor.processes` list is three, indicating that the server has spawned the expected number of processes. Finally, it appends a SIGINT signal to gracefully shut down the server.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Threading**: The test uses a separate thread to run the supervisor, allowing the main thread to continue executing and simulating asynchronous behavior typical in server applications.\n- **Signal Handling**: The test directly manipulates the signal queue to simulate the reception of system signals, which is a common technique in testing applications that rely on signal handling.\n- **Assertions**: The test employs assertions to validate the expected state of the system after the signal is processed, ensuring that the behavior aligns with the intended design of the multiprocess server."
    },
    {
      "name": "test_multiprocess_sigttou",
      "module": "test_multiprocess",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/supervisors/test_multiprocess.py",
      "line_number": 157,
      "end_line_number": 171,
      "source_code": "def test_multiprocess_sigttou() -> None:\n    \"\"\"\n    Ensure that the SIGTTOU signal is handled as expected.\n    \"\"\"\n    config = Config(app=app, workers=2)\n    supervisor = Multiprocess(config, target=run, sockets=[])\n    threading.Thread(target=supervisor.run, daemon=True).start()\n    supervisor.signal_queue.append(signal.SIGTTOU)\n    time.sleep(1)\n    assert len(supervisor.processes) == 1\n    supervisor.signal_queue.append(signal.SIGTTOU)\n    time.sleep(1)\n    assert len(supervisor.processes) == 1\n    supervisor.signal_queue.append(signal.SIGINT)\n    supervisor.join_all()",
      "docstring": "Ensure that the SIGTTOU signal is handled as expected.",
      "decorators": [
        "pytest.mark.skipif(not hasattr(signal, 'SIGTTOU'), reason='platform unsupports SIGTTOU')"
      ],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "functools",
        "os",
        "signal",
        "socket",
        "threading",
        "time",
        "typing.Any",
        "typing.Callable",
        "pytest",
        "uvicorn.Config",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Scope",
        "uvicorn.supervisors.Multiprocess",
        "uvicorn.supervisors.multiprocess.Process",
        "subprocess",
        "sys"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(supervisor.processes) == 1",
        "assert len(supervisor.processes) == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_multiprocess_sigttou` test is to verify that the `SIGTTOU` signal is handled correctly by the `Multiprocess` supervisor in the Uvicorn server. Specifically, it checks that the number of active worker processes remains stable when the `SIGTTOU` signal is sent, ensuring that the server does not reduce the number of processes below one.\n\n**Specific Functionality or Behavior Verified**:  \nThe test ensures that when the `SIGTTOU` signal is sent to the supervisor, it does not decrease the number of running processes if there is only one process active. The test checks this behavior by asserting that the length of the `supervisor.processes` list remains equal to one after sending the signal twice.\n\n**Code Being Tested and How It Works**:  \nThe code under test involves the `Multiprocess` class, which manages multiple worker processes for handling requests. The `handle_ttou` method is responsible for responding to the `SIGTTOU` signal by potentially terminating a worker process. The test initializes a `Multiprocess` instance with two workers, starts it in a separate thread, and then manipulates the `signal_queue` to simulate the receipt of `SIGTTOU` signals. The assertions check that the number of processes does not change unexpectedly.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs several notable techniques:\n- **Threading**: It runs the `supervisor` in a separate daemon thread to allow for asynchronous signal handling.\n- **Signal Handling Simulation**: The test directly manipulates the `signal_queue` to simulate the sending of signals, allowing for controlled testing of signal handling behavior.\n- **Assertions**: It uses assertions to validate the expected state of the system after signals are processed, ensuring that the test fails if the behavior deviates from expectations."
    },
    {
      "name": "test_forwarded_hosts",
      "module": "test_proxy_headers",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/middleware/test_proxy_headers.py",
      "line_number": 339,
      "end_line_number": 341,
      "source_code": "def test_forwarded_hosts(init_hosts: str | list[str], test_host: str, expected: bool) -> None:\n    trusted_hosts = _TrustedHosts(init_hosts)\n    assert (test_host in trusted_hosts) is expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize(('init_hosts', 'test_host', 'expected'), [(_TRUSTED_NOTHING, '127.0.0.0', False), (_TRUSTED_NOTHING, '127.0.0.1', False), (_TRUSTED_NOTHING, '127.1.1.1', False), (_TRUSTED_NOTHING, '127.255.255.255', False), (_TRUSTED_NOTHING, '10.0.0.0', False), (_TRUSTED_NOTHING, '10.0.0.1', False), (_TRUSTED_NOTHING, '10.1.1.1', False), (_TRUSTED_NOTHING, '10.255.255.255', False), (_TRUSTED_NOTHING, '192.168.0.0', False), (_TRUSTED_NOTHING, '192.168.0.1', False), (_TRUSTED_NOTHING, '1.1.1.1', False), (_TRUSTED_NOTHING, '2001:db8::', False), (_TRUSTED_NOTHING, '2001:db8:abcd:0012::0', False), (_TRUSTED_NOTHING, '2001:db8:abcd:0012::1:1', False), (_TRUSTED_NOTHING, '::', False), (_TRUSTED_NOTHING, '::1', False), (_TRUSTED_NOTHING, '2001:db8:3333:4444:5555:6666:102:304', False), (_TRUSTED_NOTHING, '::b16:212c', False), (_TRUSTED_NOTHING, 'a:b:c:d::', False), (_TRUSTED_NOTHING, '::a:b:c:d', False), (_TRUSTED_NOTHING, 'some-literal', False), (_TRUSTED_NOTHING, 'unix:///foo/bar', False), (_TRUSTED_NOTHING, '/foo/bar', False), (_TRUSTED_NOTHING, '*', False), (_TRUSTED_NOTHING, 'another-literal', False), (_TRUSTED_NOTHING, 'unix:///another/path', False), (_TRUSTED_NOTHING, '/another/path', False), (_TRUSTED_NOTHING, '', False), (_TRUSTED_EVERYTHING, '127.0.0.0', True), (_TRUSTED_EVERYTHING, '127.0.0.1', True), (_TRUSTED_EVERYTHING, '127.1.1.1', True), (_TRUSTED_EVERYTHING, '127.255.255.255', True), (_TRUSTED_EVERYTHING, '10.0.0.0', True), (_TRUSTED_EVERYTHING, '10.0.0.1', True), (_TRUSTED_EVERYTHING, '10.1.1.1', True), (_TRUSTED_EVERYTHING, '10.255.255.255', True), (_TRUSTED_EVERYTHING, '192.168.0.0', True), (_TRUSTED_EVERYTHING, '192.168.0.1', True), (_TRUSTED_EVERYTHING, '1.1.1.1', True), (_TRUSTED_EVERYTHING_LIST, '1.1.1.1', True), (_TRUSTED_EVERYTHING, '2001:db8::', True), (_TRUSTED_EVERYTHING, '2001:db8:abcd:0012::0', True), (_TRUSTED_EVERYTHING, '2001:db8:abcd:0012::1:1', True), (_TRUSTED_EVERYTHING, '::', True), (_TRUSTED_EVERYTHING, '::1', True), (_TRUSTED_EVERYTHING, '2001:db8:3333:4444:5555:6666:102:304', True), (_TRUSTED_EVERYTHING, '::b16:212c', True), (_TRUSTED_EVERYTHING, 'a:b:c:d::', True), (_TRUSTED_EVERYTHING, '::a:b:c:d', True), (_TRUSTED_EVERYTHING_LIST, '::a:b:c:d', True), (_TRUSTED_EVERYTHING, 'some-literal', True), (_TRUSTED_EVERYTHING, 'unix:///foo/bar', True), (_TRUSTED_EVERYTHING, '/foo/bar', True), (_TRUSTED_EVERYTHING, '*', True), (_TRUSTED_EVERYTHING, 'another-literal', True), (_TRUSTED_EVERYTHING, 'unix:///another/path', True), (_TRUSTED_EVERYTHING, '/another/path', True), (_TRUSTED_EVERYTHING, '', True), (_TRUSTED_EVERYTHING_LIST, '', True), (_TRUSTED_IPv4_ADDRESSES, '127.0.0.0', False), (_TRUSTED_IPv4_ADDRESSES, '127.0.0.1', True), (_TRUSTED_IPv4_ADDRESSES, '127.1.1.1', False), (_TRUSTED_IPv4_ADDRESSES, '127.255.255.255', False), (_TRUSTED_IPv4_ADDRESSES, '10.0.0.0', False), (_TRUSTED_IPv4_ADDRESSES, '10.0.0.1', True), (_TRUSTED_IPv4_ADDRESSES, '10.1.1.1', False), (_TRUSTED_IPv4_ADDRESSES, '10.255.255.255', False), (_TRUSTED_IPv4_ADDRESSES, '192.168.0.0', False), (_TRUSTED_IPv4_ADDRESSES, '192.168.0.1', False), (_TRUSTED_IPv4_ADDRESSES, '1.1.1.1', False), (_TRUSTED_IPv4_ADDRESSES, '2001:db8::', False), (_TRUSTED_IPv4_ADDRESSES, '2001:db8:abcd:0012::0', False), (_TRUSTED_IPv4_ADDRESSES, '2001:db8:abcd:0012::1:1', False), (_TRUSTED_IPv4_ADDRESSES, '::', False), (_TRUSTED_IPv4_ADDRESSES, '::1', False), (_TRUSTED_IPv4_ADDRESSES, '2001:db8:3333:4444:5555:6666:102:304', False), (_TRUSTED_IPv4_ADDRESSES, '::b16:212c', False), (_TRUSTED_IPv4_ADDRESSES, 'a:b:c:d::', False), (_TRUSTED_IPv4_ADDRESSES, '::a:b:c:d', False), (_TRUSTED_IPv4_ADDRESSES, 'some-literal', False), (_TRUSTED_IPv4_ADDRESSES, 'unix:///foo/bar', False), (_TRUSTED_IPv4_ADDRESSES, '*', False), (_TRUSTED_IPv4_ADDRESSES, '/foo/bar', False), (_TRUSTED_IPv4_ADDRESSES, 'another-literal', False), (_TRUSTED_IPv4_ADDRESSES, 'unix:///another/path', False), (_TRUSTED_IPv4_ADDRESSES, '/another/path', False), (_TRUSTED_IPv4_ADDRESSES, '', False), (_TRUSTED_IPv6_ADDRESSES, '127.0.0.0', False), (_TRUSTED_IPv6_ADDRESSES, '127.0.0.1', False), (_TRUSTED_IPv6_ADDRESSES, '127.1.1.1', False), (_TRUSTED_IPv6_ADDRESSES, '127.255.255.255', False), (_TRUSTED_IPv6_ADDRESSES, '10.0.0.0', False), (_TRUSTED_IPv6_ADDRESSES, '10.0.0.1', False), (_TRUSTED_IPv6_ADDRESSES, '10.1.1.1', False), (_TRUSTED_IPv6_ADDRESSES, '10.255.255.255', False), (_TRUSTED_IPv6_ADDRESSES, '192.168.0.0', False), (_TRUSTED_IPv6_ADDRESSES, '192.168.0.1', False), (_TRUSTED_IPv6_ADDRESSES, '1.1.1.1', False), (_TRUSTED_IPv6_ADDRESSES, '2001:db8::', True), (_TRUSTED_IPv6_ADDRESSES, '2001:db8:abcd:0012::0', False), (_TRUSTED_IPv6_ADDRESSES, '2001:db8:abcd:0012::1:1', False), (_TRUSTED_IPv6_ADDRESSES, '::', False), (_TRUSTED_IPv6_ADDRESSES, '::1', False), (_TRUSTED_IPv6_ADDRESSES, '2001:db8:3333:4444:5555:6666:102:304', True), (_TRUSTED_IPv6_ADDRESSES, '::b16:212c', True), (_TRUSTED_IPv6_ADDRESSES, 'a:b:c:d::', False), (_TRUSTED_IPv6_ADDRESSES, '::a:b:c:d', False), (_TRUSTED_IPv6_ADDRESSES, 'some-literal', False), (_TRUSTED_IPv6_ADDRESSES, 'unix:///foo/bar', False), (_TRUSTED_IPv6_ADDRESSES, '*', False), (_TRUSTED_IPv6_ADDRESSES, '/foo/bar', False), (_TRUSTED_IPv6_ADDRESSES, 'another-literal', False), (_TRUSTED_IPv6_ADDRESSES, 'unix:///another/path', False), (_TRUSTED_IPv6_ADDRESSES, '/another/path', False), (_TRUSTED_IPv6_ADDRESSES, '', False), (_TRUSTED_IPv4_NETWORKS, '127.0.0.0', True), (_TRUSTED_IPv4_NETWORKS, '127.0.0.1', True), (_TRUSTED_IPv4_NETWORKS, '127.1.1.1', True), (_TRUSTED_IPv4_NETWORKS, '127.255.255.255', True), (_TRUSTED_IPv4_NETWORKS, '10.0.0.0', True), (_TRUSTED_IPv4_NETWORKS, '10.0.0.1', True), (_TRUSTED_IPv4_NETWORKS, '10.1.1.1', True), (_TRUSTED_IPv4_NETWORKS, '10.255.255.255', True), (_TRUSTED_IPv4_NETWORKS, '192.168.0.0', False), (_TRUSTED_IPv4_NETWORKS, '192.168.0.1', False), (_TRUSTED_IPv4_NETWORKS, '1.1.1.1', False), (_TRUSTED_IPv4_NETWORKS, '2001:db8::', False), (_TRUSTED_IPv4_NETWORKS, '2001:db8:abcd:0012::0', False), (_TRUSTED_IPv4_NETWORKS, '2001:db8:abcd:0012::1:1', False), (_TRUSTED_IPv4_NETWORKS, '::', False), (_TRUSTED_IPv4_NETWORKS, '::1', False), (_TRUSTED_IPv4_NETWORKS, '2001:db8:3333:4444:5555:6666:102:304', False), (_TRUSTED_IPv4_NETWORKS, '::b16:212c', False), (_TRUSTED_IPv4_NETWORKS, 'a:b:c:d::', False), (_TRUSTED_IPv4_NETWORKS, '::a:b:c:d', False), (_TRUSTED_IPv4_NETWORKS, 'some-literal', False), (_TRUSTED_IPv4_NETWORKS, 'unix:///foo/bar', False), (_TRUSTED_IPv4_NETWORKS, '*', False), (_TRUSTED_IPv4_NETWORKS, '/foo/bar', False), (_TRUSTED_IPv4_NETWORKS, 'another-literal', False), (_TRUSTED_IPv4_NETWORKS, 'unix:///another/path', False), (_TRUSTED_IPv4_NETWORKS, '/another/path', False), (_TRUSTED_IPv4_NETWORKS, '', False), (_TRUSTED_IPv6_NETWORKS, '127.0.0.0', False), (_TRUSTED_IPv6_NETWORKS, '127.0.0.1', False), (_TRUSTED_IPv6_NETWORKS, '127.1.1.1', False), (_TRUSTED_IPv6_NETWORKS, '127.255.255.255', False), (_TRUSTED_IPv6_NETWORKS, '10.0.0.0', False), (_TRUSTED_IPv6_NETWORKS, '10.0.0.1', False), (_TRUSTED_IPv6_NETWORKS, '10.1.1.1', False), (_TRUSTED_IPv6_NETWORKS, '10.255.255.255', False), (_TRUSTED_IPv6_NETWORKS, '192.168.0.0', False), (_TRUSTED_IPv6_NETWORKS, '192.168.0.1', False), (_TRUSTED_IPv6_NETWORKS, '1.1.1.1', False), (_TRUSTED_IPv6_NETWORKS, '2001:db8::', False), (_TRUSTED_IPv6_NETWORKS, '2001:db8:abcd:0012::0', True), (_TRUSTED_IPv6_NETWORKS, '2001:db8:abcd:0012::1:1', True), (_TRUSTED_IPv6_NETWORKS, '::', False), (_TRUSTED_IPv6_NETWORKS, '::1', False), (_TRUSTED_IPv6_NETWORKS, '2001:db8:3333:4444:5555:6666:102:304', False), (_TRUSTED_IPv6_NETWORKS, '::b16:212c', False), (_TRUSTED_IPv6_NETWORKS, 'a:b:c:d::', False), (_TRUSTED_IPv6_NETWORKS, '::a:b:c:d', False), (_TRUSTED_IPv6_NETWORKS, 'some-literal', False), (_TRUSTED_IPv6_NETWORKS, 'unix:///foo/bar', False), (_TRUSTED_IPv6_NETWORKS, '*', False), (_TRUSTED_IPv6_NETWORKS, '/foo/bar', False), (_TRUSTED_IPv6_NETWORKS, 'another-literal', False), (_TRUSTED_IPv6_NETWORKS, 'unix:///another/path', False), (_TRUSTED_IPv6_NETWORKS, '/another/path', False), (_TRUSTED_IPv6_NETWORKS, '', False), (_TRUSTED_LITERALS, '127.0.0.0', False), (_TRUSTED_LITERALS, '127.0.0.1', False), (_TRUSTED_LITERALS, '127.1.1.1', False), (_TRUSTED_LITERALS, '127.255.255.255', False), (_TRUSTED_LITERALS, '10.0.0.0', False), (_TRUSTED_LITERALS, '10.0.0.1', False), (_TRUSTED_LITERALS, '10.1.1.1', False), (_TRUSTED_LITERALS, '10.255.255.255', False), (_TRUSTED_LITERALS, '192.168.0.0', False), (_TRUSTED_LITERALS, '192.168.0.1', False), (_TRUSTED_LITERALS, '1.1.1.1', False), (_TRUSTED_LITERALS, '2001:db8::', False), (_TRUSTED_LITERALS, '2001:db8:abcd:0012::0', False), (_TRUSTED_LITERALS, '2001:db8:abcd:0012::1:1', False), (_TRUSTED_LITERALS, '::', False), (_TRUSTED_LITERALS, '::1', False), (_TRUSTED_LITERALS, '2001:db8:3333:4444:5555:6666:102:304', False), (_TRUSTED_LITERALS, '::b16:212c', False), (_TRUSTED_LITERALS, 'a:b:c:d::', False), (_TRUSTED_LITERALS, '::a:b:c:d', False), (_TRUSTED_LITERALS, 'some-literal', True), (_TRUSTED_LITERALS, 'unix:///foo/bar', True), (_TRUSTED_LITERALS, '*', False), (_TRUSTED_LITERALS, '/foo/bar', True), (_TRUSTED_LITERALS, 'another-literal', False), (_TRUSTED_LITERALS, 'unix:///another/path', False), (_TRUSTED_LITERALS, '/another/path', False), (_TRUSTED_LITERALS, '', False)])"
      ],
      "arguments": [
        "init_hosts",
        "test_host",
        "expected"
      ],
      "imports": [
        "__future__.annotations",
        "typing.TYPE_CHECKING",
        "httpx",
        "httpx._transports.asgi",
        "pytest",
        "websockets.client",
        "tests.response.Response",
        "tests.utils.run_server",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Scope",
        "uvicorn.config.Config",
        "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
        "uvicorn.middleware.proxy_headers._TrustedHosts",
        "uvicorn.protocols.http.h11_impl.H11Protocol",
        "uvicorn.protocols.http.httptools_impl.HttpToolsProtocol",
        "uvicorn.protocols.websockets.websockets_impl.WebSocketProtocol",
        "uvicorn.protocols.websockets.wsproto_impl.WSProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert (test_host in trusted_hosts) is expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_forwarded_hosts` function is designed to verify the behavior of the `_TrustedHosts` class, specifically checking whether a given `test_host` is recognized as a trusted host based on the provided `init_hosts`. This is crucial for ensuring that only legitimate hosts are allowed to access the application, thereby enhancing security.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks if the `test_host` is included in the set of trusted hosts created from `init_hosts`. The assertion compares the result of the membership test (`test_host in trusted_hosts`) against the expected boolean value (`expected`). This ensures that the logic for determining trusted hosts is functioning correctly.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `_TrustedHosts` class, which initializes a set of trusted hosts and networks based on the input `init_hosts`. It handles both string and list inputs, parsing them to identify valid IP addresses and networks. The class also includes logic to always trust certain hosts (e.g., \"*\"). The test specifically instantiates this class and checks if a specific host is recognized as trusted.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs parameterized testing using `pytest.mark.parametrize`, allowing multiple sets of inputs (`init_hosts`, `test_host`, and `expected`) to be tested in a single function. This approach enhances test coverage and efficiency by systematically verifying various scenarios, such as trusted hosts, untrusted hosts, and different formats of input (strings and lists). The use of assertions to validate expected outcomes is a standard practice in unit testing, ensuring that the code behaves as intended."
    },
    {
      "name": "test_build_environ_encoding",
      "module": "test_wsgi",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/middleware/test_wsgi.py",
      "line_number": 114,
      "end_line_number": 138,
      "source_code": "def test_build_environ_encoding() -> None:\n    scope: HTTPScope = {\n        \"asgi\": {\"version\": \"3.0\", \"spec_version\": \"2.0\"},\n        \"scheme\": \"http\",\n        \"raw_path\": b\"/\\xe6\\x96\\x87%2Fall\",\n        \"type\": \"http\",\n        \"http_version\": \"1.1\",\n        \"method\": \"GET\",\n        \"path\": \"/\u6587/all\",\n        \"root_path\": \"/\u6587\",\n        \"client\": None,\n        \"server\": None,\n        \"query_string\": b\"a=123&b=456\",\n        \"headers\": [(b\"key\", b\"value1\"), (b\"key\", b\"value2\")],\n        \"extensions\": {},\n    }\n    message: HTTPRequestEvent = {\n        \"type\": \"http.request\",\n        \"body\": b\"\",\n        \"more_body\": False,\n    }\n    environ = wsgi.build_environ(scope, message, io.BytesIO(b\"\"))\n    assert environ[\"SCRIPT_NAME\"] == \"/\u6587\".encode().decode(\"latin-1\")\n    assert environ[\"PATH_INFO\"] == b\"/all\".decode(\"latin-1\")\n    assert environ[\"HTTP_KEY\"] == \"value1,value2\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "io",
        "sys",
        "typing.AsyncGenerator",
        "typing.Callable",
        "a2wsgi",
        "httpx",
        "pytest",
        "uvicorn._types.Environ",
        "uvicorn._types.HTTPRequestEvent",
        "uvicorn._types.HTTPScope",
        "uvicorn._types.StartResponse",
        "uvicorn.middleware.wsgi"
      ],
      "fixtures": [],
      "assertions": [
        "assert environ['SCRIPT_NAME'] == '/\u6587'.encode().decode('latin-1')",
        "assert environ['PATH_INFO'] == b'/all'.decode('latin-1')",
        "assert environ['HTTP_KEY'] == 'value1,value2'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe primary purpose of the `test_build_environ_encoding` test is to verify that the `wsgi.build_environ` function correctly constructs a WSGI environment dictionary from a given ASGI scope and HTTP request message, particularly focusing on the proper handling of encoding for paths and headers.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that the `SCRIPT_NAME` and `PATH_INFO` values in the resulting WSGI environment are correctly encoded and decoded, ensuring that non-ASCII characters (like those in the path) are handled properly. It also verifies that HTTP headers are correctly formatted in the environment.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `wsgi.build_environ` function, which takes an ASGI `scope` and an `HTTPRequestEvent` message to create a WSGI-compatible environment. The test provides a sample `scope` with a path containing non-ASCII characters and a message indicating an HTTP request. The assertions check that the resulting `environ` dictionary has the expected values for `SCRIPT_NAME`, `PATH_INFO`, and `HTTP_KEY`, ensuring that the encoding and header formatting are correct.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs direct assertions to validate the output of the `build_environ` function against expected values. It uses Python's built-in `assert` statements to check for equality, which is a common pattern in unit testing. The test also utilizes type hints for clarity, indicating the expected types of the `scope` and `message` variables, which enhances code readability and maintainability."
    },
    {
      "name": "test_fragmentation",
      "module": "test_http",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/protocols/test_http.py",
      "line_number": 902,
      "end_line_number": 944,
      "source_code": "def test_fragmentation(unused_tcp_port: int):\n    def receive_all(sock: socket.socket):\n        chunks: list[bytes] = []\n        while True:\n            chunk = sock.recv(1024)\n            if not chunk:\n                break\n            chunks.append(chunk)\n        return b\"\".join(chunks)\n\n    app = Response(\"Hello, world\", media_type=\"text/plain\")\n\n    def send_fragmented_req(path: str):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect((\"127.0.0.1\", unused_tcp_port))\n        d = (f\"GET {path} HTTP/1.1\\r\\n\" \"Host: localhost\\r\\n\" \"Connection: close\\r\\n\\r\\n\").encode()\n        split = len(path) // 2\n        sock.sendall(d[:split])\n        time.sleep(0.01)\n        sock.sendall(d[split:])\n        resp = receive_all(sock)\n        # see https://github.com/kmonsoor/py-amqplib/issues/45\n        # we skip the error on bsd systems if python is too slow\n        try:\n            sock.shutdown(socket.SHUT_RDWR)\n        except Exception:  # pragma: no cover\n            pass\n        sock.close()\n        return resp\n\n    config = Config(app=app, http=\"httptools\", port=unused_tcp_port)\n    server = Server(config=config)\n    t = threading.Thread(target=server.run)\n    t.daemon = True\n    t.start()\n    time.sleep(1)  # wait for uvicorn to start\n\n    path = \"/?param=\" + \"q\" * 10\n    response = send_fragmented_req(path)\n    bad_response = b\"HTTP/1.1 400 Bad Request\"\n    assert bad_response != response[: len(bad_response)]\n    server.should_exit = True\n    t.join()",
      "docstring": null,
      "decorators": [
        "skip_if_no_httptools"
      ],
      "arguments": [
        "unused_tcp_port"
      ],
      "imports": [
        "__future__.annotations",
        "logging",
        "socket",
        "threading",
        "time",
        "typing.TYPE_CHECKING",
        "typing.Any",
        "pytest",
        "tests.response.Response",
        "uvicorn.Server",
        "uvicorn._types.ASGIApplication",
        "uvicorn._types.ASGIReceiveCallable",
        "uvicorn._types.ASGISendCallable",
        "uvicorn._types.Scope",
        "uvicorn.config.WS_PROTOCOLS",
        "uvicorn.config.Config",
        "uvicorn.lifespan.off.LifespanOff",
        "uvicorn.lifespan.on.LifespanOn",
        "uvicorn.main.ServerState",
        "uvicorn.protocols.http.h11_impl.H11Protocol",
        "uvicorn.protocols.http.httptools_impl.HttpToolsProtocol",
        "sys",
        "uvicorn.protocols.http.httptools_impl.HttpToolsProtocol",
        "uvicorn.protocols.websockets.websockets_impl.WebSocketProtocol",
        "uvicorn.protocols.websockets.wsproto_impl.WSProtocol",
        "typing.TypeAlias",
        "typing_extensions.TypeAlias"
      ],
      "fixtures": [],
      "assertions": [
        "assert bad_response != response[:len(bad_response)]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "t.start",
          "body": "def start(*paths: Path):\n    thread = Thread(target=sleep_touch, args=paths)\n    thread.start()\n    threads.append(thread)"
        },
        {
          "name": "send_fragmented_req",
          "body": "def send_fragmented_req(path: str):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect(('127.0.0.1', unused_tcp_port))\n    d = f'GET {path} HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n'.encode()\n    split = len(path) // 2\n    sock.sendall(d[:split])\n    time.sleep(0.01)\n    sock.sendall(d[split:])\n    resp = receive_all(sock)\n    try:\n        sock.shutdown(socket.SHUT_RDWR)\n    except Exception:\n        pass\n    sock.close()\n    return resp"
        },
        {
          "name": "receive_all",
          "body": "def receive_all(sock: socket.socket):\n    chunks: list[bytes] = []\n    while True:\n        chunk = sock.recv(1024)\n        if not chunk:\n            break\n        chunks.append(chunk)\n    return b''.join(chunks)"
        },
        {
          "name": "sock.close",
          "body": "def close(self):\n    assert not self.closed\n    self.closed = True"
        },
        {
          "name": "sock.shutdown",
          "body": "def shutdown(self):\n    calls.append('shutdown')"
        }
      ],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_fragmentation` function is designed to verify the behavior of the Uvicorn server when handling fragmented HTTP requests. Specifically, it tests whether the server can correctly process a GET request that is sent in two parts, ensuring that it does not mistakenly interpret the fragmented request as invalid.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that the server does not return a \"400 Bad Request\" response when it receives a fragmented request. It asserts that the response received from the server does not start with the byte sequence indicating a bad request, thereby confirming that the server can handle fragmented input correctly.\n\n**Code Being Tested and How It Works**:  \nThe test sets up a simple HTTP application that responds with \"Hello, world\" and uses a socket to send a GET request to the server. The request is intentionally split into two parts, with a brief pause in between to simulate network fragmentation. The `send_fragmented_req` function handles the socket connection, sends the fragmented request, and collects the server's response using the `receive_all` function, which reads all incoming data until the connection is closed. The server is started in a separate thread to allow asynchronous handling of requests.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Threading**: The server runs in a separate thread, allowing the test to send requests while the server is actively listening for connections.\n- **Socket Programming**: The test utilizes low-level socket programming to simulate real HTTP requests, providing a realistic environment for testing the server's behavior.\n- **Assertions**: The test employs assertions to validate the response from the server, specifically checking that it does not match the expected \"400 Bad Request\" response.\n- **Fragmentation Simulation**: The test intentionally fragments the request to ensure that the server can handle incomplete data streams, which is a common scenario in real-world network communications."
    },
    {
      "name": "test_get_local_addr_with_socket",
      "module": "test_utils",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/protocols/test_utils.py",
      "line_number": 33,
      "end_line_number": 45,
      "source_code": "def test_get_local_addr_with_socket():\n    transport = MockTransport({\"socket\": MockSocket(family=socket.AF_IPX)})\n    assert get_local_addr(transport) is None\n\n    transport = MockTransport({\"socket\": MockSocket(family=socket.AF_INET6, sockname=(\"::1\", 123))})\n    assert get_local_addr(transport) == (\"::1\", 123)\n\n    transport = MockTransport({\"socket\": MockSocket(family=socket.AF_INET, sockname=(\"123.45.6.7\", 123))})\n    assert get_local_addr(transport) == (\"123.45.6.7\", 123)\n\n    if hasattr(socket, \"AF_UNIX\"):  # pragma: no cover\n        transport = MockTransport({\"socket\": MockSocket(family=socket.AF_UNIX, sockname=(\"127.0.0.1\", 8000))})\n        assert get_local_addr(transport) == (\"127.0.0.1\", 8000)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "socket",
        "asyncio.Transport",
        "typing.Any",
        "pytest",
        "uvicorn.protocols.utils.get_client_addr",
        "uvicorn.protocols.utils.get_local_addr",
        "uvicorn.protocols.utils.get_remote_addr"
      ],
      "fixtures": [],
      "assertions": [
        "assert get_local_addr(transport) is None",
        "assert get_local_addr(transport) == ('::1', 123)",
        "assert get_local_addr(transport) == ('123.45.6.7', 123)",
        "assert get_local_addr(transport) == ('127.0.0.1', 8000)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_get_local_addr_with_socket` function is designed to verify the behavior of the `get_local_addr` function when provided with different types of socket transports. It checks how the function handles various socket families and their associated socket names.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies that `get_local_addr` correctly returns the local address (IP and port) for valid socket families (IPv4 and IPv6) and returns `None` for unsupported socket families (like IPX). It also checks that the function behaves correctly when using UNIX domain sockets, if available.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `get_local_addr` function, which is expected to extract the local address from a transport object that provides a socket. The `MockTransport` class simulates a transport layer by returning a mock socket's information through its `get_extra_info` method. The test cases cover different socket families (AF_IPX, AF_INET6, AF_INET, and optionally AF_UNIX) and their respective socket names.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test uses a `MockTransport` class to simulate the behavior of a transport layer without needing actual network connections. This allows for isolated unit testing.\n- **Conditional Testing**: The test includes a conditional check for the presence of `AF_UNIX` to ensure that the test only runs if the system supports UNIX domain sockets, which is a good practice for cross-platform compatibility.\n- **Assertions**: The test employs assertions to validate the expected outcomes, ensuring that the function behaves as intended under various scenarios."
    },
    {
      "name": "test_get_remote_addr_with_socket",
      "module": "test_utils",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/protocols/test_utils.py",
      "line_number": 48,
      "end_line_number": 60,
      "source_code": "def test_get_remote_addr_with_socket():\n    transport = MockTransport({\"socket\": MockSocket(family=socket.AF_IPX)})\n    assert get_remote_addr(transport) is None\n\n    transport = MockTransport({\"socket\": MockSocket(family=socket.AF_INET6, peername=(\"::1\", 123))})\n    assert get_remote_addr(transport) == (\"::1\", 123)\n\n    transport = MockTransport({\"socket\": MockSocket(family=socket.AF_INET, peername=(\"123.45.6.7\", 123))})\n    assert get_remote_addr(transport) == (\"123.45.6.7\", 123)\n\n    if hasattr(socket, \"AF_UNIX\"):  # pragma: no cover\n        transport = MockTransport({\"socket\": MockSocket(family=socket.AF_UNIX, peername=(\"127.0.0.1\", 8000))})\n        assert get_remote_addr(transport) == (\"127.0.0.1\", 8000)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "socket",
        "asyncio.Transport",
        "typing.Any",
        "pytest",
        "uvicorn.protocols.utils.get_client_addr",
        "uvicorn.protocols.utils.get_local_addr",
        "uvicorn.protocols.utils.get_remote_addr"
      ],
      "fixtures": [],
      "assertions": [
        "assert get_remote_addr(transport) is None",
        "assert get_remote_addr(transport) == ('::1', 123)",
        "assert get_remote_addr(transport) == ('123.45.6.7', 123)",
        "assert get_remote_addr(transport) == ('127.0.0.1', 8000)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_get_remote_addr_with_socket` function is designed to verify the behavior of the `get_remote_addr` function, which retrieves the remote address of a connection based on the provided transport object. It ensures that the function correctly handles various socket families and peer names.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks that:\n1. When the socket family is unsupported (e.g., `AF_IPX`), `get_remote_addr` returns `None`.\n2. For valid IPv6 and IPv4 addresses, it correctly returns the expected tuple of the address and port.\n3. If the socket family is `AF_UNIX`, it also verifies that the function can handle this case, provided the system supports it.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `get_remote_addr` function, which likely accesses the `peername` attribute of the socket to determine the remote address. The `MockTransport` class simulates a transport layer by providing a mock socket through its `info` dictionary. The `MockSocket` class (not shown in the provided code) presumably mimics the behavior of a real socket, allowing the test to simulate different socket configurations without needing actual network connections.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The test uses mock objects (`MockTransport` and `MockSocket`) to simulate the behavior of real network components, allowing for isolated testing without external dependencies.\n- **Conditional Coverage**: The use of `if hasattr(socket, \"AF_UNIX\")` indicates a conditional test that only runs if the system supports UNIX sockets, ensuring that the test suite remains portable across different environments.\n- **Assertions**: The test employs assertions to validate the expected outcomes, which is a standard practice in unit testing to ensure that the code behaves as intended under various scenarios."
    },
    {
      "name": "test_get_local_addr",
      "module": "test_utils",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/protocols/test_utils.py",
      "line_number": 63,
      "end_line_number": 68,
      "source_code": "def test_get_local_addr():\n    transport = MockTransport({\"sockname\": \"path/to/unix-domain-socket\"})\n    assert get_local_addr(transport) is None\n\n    transport = MockTransport({\"sockname\": (\"123.45.6.7\", 123)})\n    assert get_local_addr(transport) == (\"123.45.6.7\", 123)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "socket",
        "asyncio.Transport",
        "typing.Any",
        "pytest",
        "uvicorn.protocols.utils.get_client_addr",
        "uvicorn.protocols.utils.get_local_addr",
        "uvicorn.protocols.utils.get_remote_addr"
      ],
      "fixtures": [],
      "assertions": [
        "assert get_local_addr(transport) is None",
        "assert get_local_addr(transport) == ('123.45.6.7', 123)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_get_local_addr` function is designed to verify the behavior of the `get_local_addr` function when provided with different types of transport objects. It specifically checks how the function handles both valid and invalid socket address formats.\n\n**Specific Functionality or Behavior Verified**:  \nThe test checks two scenarios: \n1. When the transport's `sockname` is set to a string (representing a Unix domain socket), the expected output is `None`.\n2. When the transport's `sockname` is a tuple representing an IPv4 address and port, the expected output is the same tuple, confirming that the function correctly extracts the local address.\n\n**Code Being Tested and How It Works**:  \nThe `get_local_addr` function is expected to retrieve the local address from the transport object. The `MockTransport` class simulates a transport layer by providing a method `get_extra_info` that returns information based on the input dictionary. The test cases utilize this mock to simulate different socket configurations, allowing the `get_local_addr` function to be tested without needing actual socket connections.\n\n**Notable Testing Patterns or Techniques Used**:  \n- **Mocking**: The use of `MockTransport` allows for the isolation of the `get_local_addr` function from real network dependencies, enabling unit testing in a controlled environment.\n- **Assertions**: The test employs assertions to validate the expected outcomes against the actual results returned by `get_local_addr`, ensuring that the function behaves as intended under different conditions."
    },
    {
      "name": "test_get_remote_addr",
      "module": "test_utils",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/protocols/test_utils.py",
      "line_number": 71,
      "end_line_number": 76,
      "source_code": "def test_get_remote_addr():\n    transport = MockTransport({\"peername\": None})\n    assert get_remote_addr(transport) is None\n\n    transport = MockTransport({\"peername\": (\"123.45.6.7\", 123)})\n    assert get_remote_addr(transport) == (\"123.45.6.7\", 123)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "__future__.annotations",
        "socket",
        "asyncio.Transport",
        "typing.Any",
        "pytest",
        "uvicorn.protocols.utils.get_client_addr",
        "uvicorn.protocols.utils.get_local_addr",
        "uvicorn.protocols.utils.get_remote_addr"
      ],
      "fixtures": [],
      "assertions": [
        "assert get_remote_addr(transport) is None",
        "assert get_remote_addr(transport) == ('123.45.6.7', 123)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_get_remote_addr` function is designed to verify the behavior of the `get_remote_addr` function, specifically how it retrieves the remote address from a transport object. It checks both scenarios: when the remote address is absent and when it is present.\n\n**Specific Functionality or Behavior Verified**:  \nThe test verifies that when the `peername` attribute of the transport is `None`, the `get_remote_addr` function correctly returns `None`. Conversely, when `peername` is set to a valid address tuple (IP address and port), the function should return that tuple, confirming that it accurately extracts the remote address.\n\n**Code Being Tested and How It Works**:  \nThe `get_remote_addr` function is expected to access the `peername` attribute of a transport object, which is simulated by the `MockTransport` class. The `MockTransport` class mimics the behavior of a real transport by allowing the test to specify what information it should return when queried. The test creates instances of `MockTransport` with different `peername` values to validate the expected outputs of `get_remote_addr`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the use of a mock object (`MockTransport`) to isolate the functionality being tested from external dependencies. This allows for controlled testing of specific scenarios without needing a real transport layer. Additionally, the assertions are straightforward, directly comparing the output of `get_remote_addr` against expected values, which is a common practice in unit testing to ensure correctness."
    },
    {
      "name": "test_get_client_addr",
      "module": "test_utils",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/protocols/test_utils.py",
      "line_number": 84,
      "end_line_number": 85,
      "source_code": "def test_get_client_addr(scope, expected_client):\n    assert get_client_addr(scope) == expected_client",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('scope, expected_client', [({'client': ('127.0.0.1', 36000)}, '127.0.0.1:36000'), ({'client': None}, '')], ids=['ip:port client', 'None client'])"
      ],
      "arguments": [
        "scope",
        "expected_client"
      ],
      "imports": [
        "__future__.annotations",
        "socket",
        "asyncio.Transport",
        "typing.Any",
        "pytest",
        "uvicorn.protocols.utils.get_client_addr",
        "uvicorn.protocols.utils.get_local_addr",
        "uvicorn.protocols.utils.get_remote_addr"
      ],
      "fixtures": [],
      "assertions": [
        "assert get_client_addr(scope) == expected_client"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_get_client_addr` function is designed to verify the behavior of the `get_client_addr` function, ensuring that it correctly extracts and formats the client address from the provided `scope` dictionary.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks two scenarios: when the `scope` contains a valid client address (in the form of a tuple with IP and port) and when the `scope` has no client information (i.e., `None`). The expected output is a formatted string representing the client address or an empty string if no client is present.\n\n**Code Being Tested and How It Works**:  \nThe `get_client_addr` function retrieves the \"client\" entry from the `scope` dictionary. If the client exists, it formats the IP and port into a string of the form \"IP:port\". If the client is `None`, it returns an empty string. This behavior is critical for applications that need to log or process client connection information.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs parameterized testing using `pytest.mark.parametrize`, which allows for multiple input scenarios to be tested in a single function. This approach enhances test coverage and reduces code duplication by systematically checking different inputs and their expected outputs. The use of assertions ensures that the actual output from `get_client_addr` matches the expected results, providing a clear pass/fail outcome for each test case."
    },
    {
      "name": "test_invalid_format",
      "module": "test_importer",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/importer/test_importer.py",
      "line_number": 6,
      "end_line_number": 10,
      "source_code": "def test_invalid_format() -> None:\n    with pytest.raises(ImportFromStringError) as exc_info:\n        import_from_string(\"example:\")\n    expected = 'Import string \"example:\" must be in format \"<module>:<attribute>\".'\n    assert expected in str(exc_info.value)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "uvicorn.importer.ImportFromStringError",
        "uvicorn.importer.import_from_string",
        "tempfile.TemporaryFile",
        "tempfile.TemporaryFile"
      ],
      "fixtures": [],
      "assertions": [
        "assert expected in str(exc_info.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_invalid_format` unit test is designed to verify that the `import_from_string` function correctly raises an `ImportFromStringError` when provided with an improperly formatted import string. Specifically, it checks that the error message returned is informative and matches the expected format.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that the function enforces the requirement that import strings must be in the format `<module>:<attribute>`. It ensures that when an invalid string (in this case, \"example:\") is passed, the appropriate exception is raised, and the error message clearly indicates the expected format.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `import_from_string` function, which attempts to import a module and its attributes based on a string input. The function splits the input string into a module part and an attribute part. If the input string does not conform to the expected format (i.e., it lacks a valid module and attribute), it raises an `ImportFromStringError` with a specific error message. The test specifically checks the behavior when the input string is malformed.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that an exception is raised during the execution of the code block. This is a common pattern in unit testing for verifying that specific error conditions are met. Additionally, it checks the content of the exception message to ensure it provides the correct guidance to the user, which is a good practice for ensuring that error handling is both functional and user-friendly."
    },
    {
      "name": "test_invalid_module",
      "module": "test_importer",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/importer/test_importer.py",
      "line_number": 13,
      "end_line_number": 17,
      "source_code": "def test_invalid_module() -> None:\n    with pytest.raises(ImportFromStringError) as exc_info:\n        import_from_string(\"module_does_not_exist:myattr\")\n    expected = 'Could not import module \"module_does_not_exist\".'\n    assert expected in str(exc_info.value)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "uvicorn.importer.ImportFromStringError",
        "uvicorn.importer.import_from_string",
        "tempfile.TemporaryFile",
        "tempfile.TemporaryFile"
      ],
      "fixtures": [],
      "assertions": [
        "assert expected in str(exc_info.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_invalid_module` function is designed to verify that the `import_from_string` function correctly raises an `ImportFromStringError` when attempting to import a non-existent module. This ensures that the error handling for invalid module names is functioning as expected.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks that when an invalid module name is provided (in this case, \"module_does_not_exist\"), the appropriate error message is generated. It asserts that the error message contains the expected text indicating that the module could not be imported.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `import_from_string` function from the `uvicorn.importer` module. This function attempts to import a specified attribute from a given module string formatted as \"<module>:<attribute>\". If the module does not exist, it raises an `ImportFromStringError`, which is then caught in the test to verify the correctness of the error message.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that an exception is raised during the execution of the `import_from_string` function. This is a common pattern in unit testing for verifying that specific exceptions are thrown under certain conditions. Additionally, the test checks the content of the exception message, which is a good practice to ensure that not only is an error raised, but that it is the correct error with the expected message."
    },
    {
      "name": "test_invalid_attr",
      "module": "test_importer",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/importer/test_importer.py",
      "line_number": 20,
      "end_line_number": 24,
      "source_code": "def test_invalid_attr() -> None:\n    with pytest.raises(ImportFromStringError) as exc_info:\n        import_from_string(\"tempfile:attr_does_not_exist\")\n    expected = 'Attribute \"attr_does_not_exist\" not found in module \"tempfile\".'\n    assert expected in str(exc_info.value)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "uvicorn.importer.ImportFromStringError",
        "uvicorn.importer.import_from_string",
        "tempfile.TemporaryFile",
        "tempfile.TemporaryFile"
      ],
      "fixtures": [],
      "assertions": [
        "assert expected in str(exc_info.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_invalid_attr` function is designed to verify that the `import_from_string` function correctly raises an `ImportFromStringError` when an attempt is made to import an attribute that does not exist in a specified module.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks the error handling of the `import_from_string` function when the provided import string references a valid module (`tempfile`) but an invalid attribute (`attr_does_not_exist`). It ensures that the error message generated is accurate and informative.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `import_from_string` function, which takes a string formatted as `<module>:<attribute>`. It attempts to import the specified module and then access the specified attribute. If the attribute does not exist, it raises an `ImportFromStringError` with a message indicating that the attribute was not found in the module. In this case, the test checks that the error message matches the expected format when the attribute is invalid.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that an exception is raised during the execution of the code block. This is a common pattern in unit testing for verifying that specific error conditions are met. Additionally, the test checks the content of the exception message to ensure it provides the correct feedback, which is a good practice for validating the robustness of error handling in the code."
    },
    {
      "name": "test_internal_import_error",
      "module": "test_importer",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/importer/test_importer.py",
      "line_number": 27,
      "end_line_number": 29,
      "source_code": "def test_internal_import_error() -> None:\n    with pytest.raises(ImportError):\n        import_from_string(\"tests.importer.raise_import_error:myattr\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "uvicorn.importer.ImportFromStringError",
        "uvicorn.importer.import_from_string",
        "tempfile.TemporaryFile",
        "tempfile.TemporaryFile"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_internal_import_error` unit test is designed to verify that the `import_from_string` function correctly raises an `ImportError` when attempting to import an attribute from a module that is intentionally designed to raise an import error.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically checks the behavior of the `import_from_string` function when the import string references a module that contains an import statement for a non-existent module. The expected outcome is that an `ImportError` is raised, indicating that the import operation has failed.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `import_from_string` function, which attempts to import a module and its attributes based on a provided string in the format `<module>:<attribute>`. In this case, the string `\"tests.importer.raise_import_error:myattr\"` is used, where `tests.importer.raise_import_error` is a module that contains an import statement for a non-existent module (`does_not_exist`). When `import_from_string` is called with this string, it should trigger an `ImportError` due to the failed import of `does_not_exist`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that an `ImportError` is raised during the execution of the import statement. This is a common pattern in unit testing for verifying that specific exceptions are raised under certain conditions, ensuring that the code behaves as expected in error scenarios. The test is concise and focuses solely on the expected failure case, making it clear and easy to understand."
    },
    {
      "name": "test_valid_import",
      "module": "test_importer",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/importer/test_importer.py",
      "line_number": 32,
      "end_line_number": 36,
      "source_code": "def test_valid_import() -> None:\n    instance = import_from_string(\"tempfile:TemporaryFile\")\n    from tempfile import TemporaryFile\n\n    assert instance == TemporaryFile",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "uvicorn.importer.ImportFromStringError",
        "uvicorn.importer.import_from_string",
        "tempfile.TemporaryFile",
        "tempfile.TemporaryFile"
      ],
      "fixtures": [],
      "assertions": [
        "assert instance == TemporaryFile"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_valid_import` function is designed to verify that the `import_from_string` function correctly imports an attribute from a specified module when provided with a valid import string. In this case, it checks if the `TemporaryFile` class from the `tempfile` module can be successfully imported.\n\n**Specific Functionality or Behavior Verified**:  \nThis test specifically verifies that the `import_from_string` function can accurately resolve and return the `TemporaryFile` class when given the string \"tempfile:TemporaryFile\". It ensures that the import mechanism works as intended for valid inputs.\n\n**Code Being Tested and How It Works**:  \nThe code being tested is the `import_from_string` function from the `uvicorn.importer` module. This function takes a string formatted as \"<module>:<attribute>\" and attempts to import the specified attribute from the given module. In this test, the string \"tempfile:TemporaryFile\" is passed to the function, and the result is compared to the directly imported `TemporaryFile` class from the `tempfile` module to confirm they are the same.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs a straightforward assertion pattern, using `assert` to compare the result of the import with the expected class. This is a common technique in unit testing to validate outcomes. Additionally, the test is structured to be clear and concise, focusing solely on the specific functionality being tested without extraneous logic or dependencies, which is a best practice in unit testing."
    },
    {
      "name": "test_no_import_needed",
      "module": "test_importer",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/importer/test_importer.py",
      "line_number": 39,
      "end_line_number": 43,
      "source_code": "def test_no_import_needed() -> None:\n    from tempfile import TemporaryFile\n\n    instance = import_from_string(TemporaryFile)\n    assert instance == TemporaryFile",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "uvicorn.importer.ImportFromStringError",
        "uvicorn.importer.import_from_string",
        "tempfile.TemporaryFile",
        "tempfile.TemporaryFile"
      ],
      "fixtures": [],
      "assertions": [
        "assert instance == TemporaryFile"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_no_import_needed` function is designed to verify that the `import_from_string` function can correctly handle a direct reference to a class (in this case, `TemporaryFile`) without requiring a string format for the import. This tests the flexibility of the import mechanism in the `uvicorn` codebase.\n\n**Specific Functionality or Behavior Verified**:  \nThis test checks that when a class is passed directly to `import_from_string`, it returns the same class without raising any errors. It ensures that the function can accept both string-based imports and direct references, confirming its robustness in handling different input types.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `import_from_string` function from the `uvicorn.importer` module. The test imports `TemporaryFile` from the `tempfile` module and then calls `import_from_string` with `TemporaryFile` as an argument. The expected behavior is that `import_from_string` should return the `TemporaryFile` class itself, which is asserted by the line `assert instance == TemporaryFile`.\n\n**Notable Testing Patterns or Techniques Used**:  \nThis test employs a straightforward assertion pattern, where the output of a function is compared to an expected value. It also demonstrates the use of direct imports within the test function, which can help in reducing the scope of the imported module and keeping the test isolated. The test does not rely on mocking or complex setup, making it simple and easy to understand."
    },
    {
      "name": "test_circular_import_error",
      "module": "test_importer",
      "class_name": null,
      "file_path": "__internal__/data/uvicorn/tests/importer/test_importer.py",
      "line_number": 46,
      "end_line_number": 53,
      "source_code": "def test_circular_import_error() -> None:\n    with pytest.raises(ImportError) as exc_info:\n        import_from_string(\"tests.importer.circular_import_a:bar\")\n    expected = (\n        \"cannot import name 'bar' from partially initialized module \"\n        \"'tests.importer.circular_import_a' (most likely due to a circular import)\"\n    )\n    assert expected in str(exc_info.value)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "uvicorn.importer.ImportFromStringError",
        "uvicorn.importer.import_from_string",
        "tempfile.TemporaryFile",
        "tempfile.TemporaryFile"
      ],
      "fixtures": [],
      "assertions": [
        "assert expected in str(exc_info.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [],
      "code_explanation": "**Main Purpose of the Test**:  \nThe `test_circular_import_error` unit test is designed to verify that the `import_from_string` function correctly raises an `ImportError` when attempting to import an attribute from a module that is partially initialized due to a circular import. This ensures that the function handles circular dependencies gracefully and provides informative error messages.\n\n**Specific Functionality or Behavior Verified**:  \nThe test specifically checks that when the import string `\"tests.importer.circular_import_a:bar\"` is used, the resulting `ImportError` contains a specific message indicating that the import failed due to a circular import. This behavior is crucial for developers to understand the nature of the error when dealing with circular dependencies in their code.\n\n**Code Being Tested and How It Works**:  \nThe code under test is the `import_from_string` function, which attempts to dynamically import a specified attribute from a given module. In this case, the module `tests.importer.circular_import_a` contains a variable `bar`, but it also imports from another module (`circular_import_b`) that may lead to a circular reference. When the import is attempted, Python raises an `ImportError` because the module is not fully initialized, and the test checks that this error is raised and that the error message matches the expected output.\n\n**Notable Testing Patterns or Techniques Used**:  \nThe test employs the `pytest.raises` context manager to assert that an exception is raised during the execution of the import statement. This is a common pattern in unit testing for verifying that specific errors are raised under certain conditions. Additionally, the test checks the content of the exception message to ensure it provides the expected information about the nature of the error, which is a good practice for ensuring that error handling is both functional and user-friendly."
    }
  ]
}