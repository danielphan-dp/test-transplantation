{
  "tests": [
    {
      "name": "run",
      "module": "cli",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\cli.py",
      "line_number": 28,
      "end_line_number": 29,
      "source_code": "def run(app: AbstractApp, args: argparse.Namespace):\n    app.run(\"connexion.cli:create_app\", port=args.port, host=args.host, factory=True)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "args"
      ],
      "imports": [
        "argparse",
        "importlib.metadata",
        "logging",
        "os",
        "sys",
        "typing",
        "connexion",
        "connexion.apps.AbstractApp",
        "connexion.mock.MockResolver",
        "connexion.options.SwaggerUIOptions"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.run",
          "body": "def run(app: AbstractApp, args: argparse.Namespace):\n    app.run('connexion.cli:create_app', port=args.port, host=args.host, factory=True)"
        }
      ]
    },
    {
      "name": "create_app",
      "module": "cli",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\cli.py",
      "line_number": 106,
      "end_line_number": 159,
      "source_code": "def create_app(args: t.Optional[argparse.Namespace] = None) -> AbstractApp:\n    \"\"\"Runs a server compliant with a OpenAPI/Swagger Specification file.\"\"\"\n    if args is None:\n        args = parser.parse_args()\n\n    if args.verbose == 1:\n        logging_level = logging.INFO\n    elif args.verbose >= 2:\n        logging_level = logging.DEBUG\n    else:\n        logging_level = logging.WARN\n\n    logging.basicConfig(level=logging_level)\n\n    if args.spec_file.startswith(\"http\") or args.spec_file.startswith(\"https\"):\n        spec_file_full_path = args.spec_file\n    else:\n        spec_file_full_path = os.path.abspath(args.spec_file)\n        py_module_path = args.base_module_path or os.path.dirname(spec_file_full_path)\n        sys.path.insert(1, os.path.abspath(py_module_path))\n        logger.debug(f\"Added {py_module_path} to system path.\")\n\n    resolver_error = None\n    if args.stub:\n        resolver_error = 501\n\n    api_extra_args = {}\n    if args.mock:\n        resolver = MockResolver(mock_all=args.mock == \"all\")\n        api_extra_args[\"resolver\"] = resolver\n\n    app_cls = connexion.utils.get_function_from_name(AVAILABLE_APPS[args.app_framework])\n\n    swagger_ui_options = SwaggerUIOptions(\n        swagger_ui_path=args.swagger_ui_path,\n        swagger_ui_template_dir=args.swagger_ui_template_dir,\n    )\n\n    app = app_cls(\n        __name__,\n        auth_all_paths=args.auth_all_paths,\n        swagger_ui_options=swagger_ui_options,\n    )\n\n    app.add_api(\n        spec_file_full_path,\n        base_path=args.base_path,\n        resolver_error=resolver_error,\n        validate_responses=args.validate_responses,\n        strict_validation=args.strict_validation,\n        **api_extra_args,\n    )\n\n    return app",
      "docstring": "Runs a server compliant with a OpenAPI/Swagger Specification file.",
      "decorators": [],
      "arguments": [
        "args"
      ],
      "imports": [
        "argparse",
        "importlib.metadata",
        "logging",
        "os",
        "sys",
        "typing",
        "connexion",
        "connexion.apps.AbstractApp",
        "connexion.mock.MockResolver",
        "connexion.options.SwaggerUIOptions"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "connexion.utils.get_function_from_name",
          "body": "def get_function_from_name(function_name):\n    \"\"\"\n    Tries to get function by fully qualified name (e.g. \"mymodule.myobj.myfunc\")\n\n    :type function_name: str\n    \"\"\"\n    if function_name is None:\n        raise ValueError('Empty function name')\n    if '.' in function_name:\n        module_name, attr_path = function_name.rsplit('.', 1)\n    else:\n        module_name = ''\n        attr_path = function_name\n    module = None\n    last_import_error = None\n    while not module:\n        try:\n            module = importlib.import_module(module_name)\n        except ImportError as import_error:\n            last_import_error = import_error\n            if '.' in module_name:\n                module_name, attr_path1 = module_name.rsplit('.', 1)\n                attr_path = f'{attr_path1}.{attr_path}'\n            else:\n                raise\n    try:\n        function = deep_getattr(module, attr_path)\n    except AttributeError:\n        if last_import_error:\n            raise last_import_error\n        else:\n            raise\n    return function"
        },
        {
          "name": "app.add_api",
          "body": "def add_api(self, specification: t.Union[pathlib.Path, str, dict], *, base_path: t.Optional[str]=None, name: t.Optional[str]=None, arguments: t.Optional[dict]=None, auth_all_paths: t.Optional[bool]=None, jsonifier: t.Optional[Jsonifier]=None, pythonic_params: t.Optional[bool]=None, resolver: t.Optional[t.Union[Resolver, t.Callable]]=None, resolver_error: t.Optional[int]=None, strict_validation: t.Optional[bool]=None, swagger_ui_options: t.Optional[SwaggerUIOptions]=None, uri_parser_class: t.Optional[AbstractURIParser]=None, validate_responses: t.Optional[bool]=None, validator_map: t.Optional[dict]=None, security_map: t.Optional[dict]=None, **kwargs) -> t.Any:\n    \"\"\"\n        Register an API represented by a single OpenAPI specification on this application.\n        Multiple APIs can be registered on a single application.\n\n        :param specification: OpenAPI specification. Can be provided either as dict, a path\n            to file, or a URL.\n        :param base_path: Base path to host the API. This overrides the basePath / servers in the\n            specification.\n        :param name: Name to register the API with. If no name is passed, the base_path is used\n            as name instead.\n        :param arguments: Arguments to substitute the specification using Jinja.\n        :param auth_all_paths: whether to authenticate not paths not defined in the specification.\n            Defaults to False.\n        :param jsonifier: Custom jsonifier to overwrite json encoding for json responses.\n        :param pythonic_params: When True, CamelCase parameters are converted to snake_case and an\n            underscore is appended to any shadowed built-ins. Defaults to False.\n        :param resolver: Callable that maps operationId to a function or instance of\n            :class:`resolver.Resolver`.\n        :param resolver_error: Error code to return for operations for which the operationId could\n            not be resolved. If no error code is provided, the application will fail when trying to\n            start.\n        :param strict_validation: When True, extra form or query parameters not defined in the\n            specification result in a validation error. Defaults to False.\n        :param swagger_ui_options: A :class:`options.SwaggerUIOptions` instance with configuration\n            options for the swagger ui.\n        :param uri_parser_class: Class to use for uri parsing. See :mod:`uri_parsing`.\n        :param validate_responses: Whether to validate responses against the specification. This has\n            an impact on performance. Defaults to False.\n        :param validator_map: A dictionary of validators to use. Defaults to\n            :obj:`validators.VALIDATOR_MAP`\n        :param security_map: A dictionary of security handlers to use. Defaults to\n            :obj:`security.SECURITY_HANDLERS`\n        :param kwargs: Additional keyword arguments to pass to the `add_api` method of the managed\n            middlewares. This can be used to pass arguments to middlewares added beyond the default\n            ones.\n\n        :return: The Api registered on the middleware application wrapping the framework.\n        \"\"\"\n    return self.middleware.add_api(specification, base_path=base_path, name=name, arguments=arguments, auth_all_paths=auth_all_paths, jsonifier=jsonifier, pythonic_params=pythonic_params, resolver=resolver, resolver_error=resolver_error, strict_validation=strict_validation, swagger_ui_options=swagger_ui_options, uri_parser_class=uri_parser_class, validate_responses=validate_responses, validator_map=validator_map, security_map=security_map, **kwargs)"
        }
      ]
    },
    {
      "name": "main",
      "module": "cli",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\cli.py",
      "line_number": 162,
      "end_line_number": 170,
      "source_code": "def main(argv: t.Optional[t.List[str]] = None) -> None:\n    if argv is None:\n        argv = sys.argv[1:]\n    if not argv:\n        argv = [\"--help\"]\n\n    args = parser.parse_args(argv)\n    app = create_app(args)\n    args.func(app, args)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "argv"
      ],
      "imports": [
        "argparse",
        "importlib.metadata",
        "logging",
        "os",
        "sys",
        "typing",
        "connexion",
        "connexion.apps.AbstractApp",
        "connexion.mock.MockResolver",
        "connexion.options.SwaggerUIOptions"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "create_app",
          "body": "def create_app(args: t.Optional[argparse.Namespace]=None) -> AbstractApp:\n    \"\"\"Runs a server compliant with a OpenAPI/Swagger Specification file.\"\"\"\n    if args is None:\n        args = parser.parse_args()\n    if args.verbose == 1:\n        logging_level = logging.INFO\n    elif args.verbose >= 2:\n        logging_level = logging.DEBUG\n    else:\n        logging_level = logging.WARN\n    logging.basicConfig(level=logging_level)\n    if args.spec_file.startswith('http') or args.spec_file.startswith('https'):\n        spec_file_full_path = args.spec_file\n    else:\n        spec_file_full_path = os.path.abspath(args.spec_file)\n        py_module_path = args.base_module_path or os.path.dirname(spec_file_full_path)\n        sys.path.insert(1, os.path.abspath(py_module_path))\n        logger.debug(f'Added {py_module_path} to system path.')\n    resolver_error = None\n    if args.stub:\n        resolver_error = 501\n    api_extra_args = {}\n    if args.mock:\n        resolver = MockResolver(mock_all=args.mock == 'all')\n        api_extra_args['resolver'] = resolver\n    app_cls = connexion.utils.get_function_from_name(AVAILABLE_APPS[args.app_framework])\n    swagger_ui_options = SwaggerUIOptions(swagger_ui_path=args.swagger_ui_path, swagger_ui_template_dir=args.swagger_ui_template_dir)\n    app = app_cls(__name__, auth_all_paths=args.auth_all_paths, swagger_ui_options=swagger_ui_options)\n    app.add_api(spec_file_full_path, base_path=args.base_path, resolver_error=resolver_error, validate_responses=args.validate_responses, strict_validation=args.strict_validation, **api_extra_args)\n    return app"
        }
      ]
    },
    {
      "name": "__getitem__",
      "module": "datastructures",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\datastructures.py",
      "line_number": 16,
      "end_line_number": 21,
      "source_code": "def __getitem__(self, item):\n        # Sort keys in order of specificity\n        for key in sorted(self, key=lambda k: (\"*\" not in k, k), reverse=True):\n            if fnmatch(item, key):\n                return super().__getitem__(key)\n        raise super().__getitem__(item)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "item"
      ],
      "imports": [
        "fnmatch.fnmatch"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "get",
      "module": "datastructures",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\datastructures.py",
      "line_number": 23,
      "end_line_number": 27,
      "source_code": "def get(self, item, default=None):\n        try:\n            return self[item]\n        except KeyError:\n            return default",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "item",
        "default"
      ],
      "imports": [
        "fnmatch.fnmatch"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__contains__",
      "module": "datastructures",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\datastructures.py",
      "line_number": 29,
      "end_line_number": 35,
      "source_code": "def __contains__(self, item):\n        try:\n            self[item]\n        except KeyError:\n            return False\n        else:\n            return True",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "item"
      ],
      "imports": [
        "fnmatch.fnmatch"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "exceptions",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\exceptions.py",
      "line_number": 40,
      "end_line_number": 57,
      "source_code": "def __init__(\n        self,\n        *,\n        status=500,\n        title=None,\n        detail=None,\n        type=None,\n        instance=None,\n        headers=None,\n        ext=None,\n    ):\n        self.status = self.status_code = status\n        self.title = title\n        self.detail = detail\n        self.type = type\n        self.instance = instance\n        self.headers = headers\n        self.ext = ext",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "typing",
        "jsonschema.exceptions.ValidationError",
        "starlette.exceptions.HTTPException",
        "problem.problem"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "to_problem",
      "module": "exceptions",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\exceptions.py",
      "line_number": 59,
      "end_line_number": 68,
      "source_code": "def to_problem(self):\n        return problem(\n            status=self.status,\n            title=self.title,\n            detail=self.detail,\n            type=self.type,\n            instance=self.instance,\n            headers=self.headers,\n            ext=self.ext,\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "typing",
        "jsonschema.exceptions.ValidationError",
        "starlette.exceptions.HTTPException",
        "problem.problem"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "problem",
          "body": "def problem(status, title, detail, type=None, instance=None, headers=None, ext=None):\n    \"\"\"\n    Returns a `Problem Details <https://tools.ietf.org/html/draft-ietf-appsawg-http-problem-00>`_ error response.\n\n\n    :param status: The HTTP status code generated by the origin server for this occurrence of the problem.\n    :type status: int\n    :param title: A short, human-readable summary of the problem type.  It SHOULD NOT change from occurrence to\n                  occurrence of the problem, except for purposes of localisation.\n    :type title: str\n    :param detail: An human readable explanation specific to this occurrence of the problem.\n    :type detail: str\n    :param type: An absolute URI that identifies the problem type.  When dereferenced, it SHOULD provide human-readable\n                 documentation for the problem type (e.g., using HTML).  When this member is not present its value is\n                 assumed to be \"about:blank\".\n    :type: type: str\n    :param instance: An absolute URI that identifies the specific occurrence of the problem.  It may or may not yield\n                     further information if dereferenced.\n    :type instance: str\n    :param headers: HTTP headers to include in the response\n    :type headers: dict | None\n    :param ext: Extension members to include in the body\n    :type ext: dict | None\n    :return: error response\n    :rtype: ConnexionResponse\n    \"\"\"\n    from .lifecycle import ConnexionResponse\n    if not type:\n        type = 'about:blank'\n    problem_response = {'type': type, 'title': title, 'detail': detail, 'status': status}\n    if instance:\n        problem_response['instance'] = instance\n    if ext:\n        problem_response.update(ext)\n    mimetype = content_type = 'application/problem+json'\n    return ConnexionResponse(status, mimetype, content_type, body=json.dumps(problem_response), headers=headers)"
        }
      ]
    },
    {
      "name": "__init__",
      "module": "exceptions",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\exceptions.py",
      "line_number": 78,
      "end_line_number": 85,
      "source_code": "def __init__(\n        self,\n        status: int = 400,\n        title: t.Optional[str] = None,\n        *,\n        detail: t.Optional[str] = None,\n    ):\n        super().__init__(status=status, title=title, detail=detail)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "status",
        "title"
      ],
      "imports": [
        "typing",
        "jsonschema.exceptions.ValidationError",
        "starlette.exceptions.HTTPException",
        "problem.problem"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "exceptions",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\exceptions.py",
      "line_number": 91,
      "end_line_number": 92,
      "source_code": "def __init__(self, detail=None):\n        super().__init__(status=400, title=\"Bad Request\", detail=detail)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "detail"
      ],
      "imports": [
        "typing",
        "jsonschema.exceptions.ValidationError",
        "starlette.exceptions.HTTPException",
        "problem.problem"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "exceptions",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\exceptions.py",
      "line_number": 99,
      "end_line_number": 101,
      "source_code": "def __init__(self, *, param_type: str, extra_params: t.Iterable[str]):\n        detail = f\"Extra {param_type} parameter(s) {','.join(extra_params)} not in spec\"\n        super().__init__(detail=detail)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "typing",
        "jsonschema.exceptions.ValidationError",
        "starlette.exceptions.HTTPException",
        "problem.problem"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "exceptions",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\exceptions.py",
      "line_number": 108,
      "end_line_number": 110,
      "source_code": "def __init__(self, schema_type: str, parameter_type: str, parameter_name: str):\n        detail = f\"Wrong type, expected '{schema_type}' for {parameter_type} parameter '{parameter_name}'\"\n        super().__init__(detail=detail)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "schema_type",
        "parameter_type",
        "parameter_name"
      ],
      "imports": [
        "typing",
        "jsonschema.exceptions.ValidationError",
        "starlette.exceptions.HTTPException",
        "problem.problem"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "exceptions",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\exceptions.py",
      "line_number": 123,
      "end_line_number": 124,
      "source_code": "def __init__(self, detail: str = description):\n        super().__init__(401, title=\"Unauthorized\", detail=detail)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "detail"
      ],
      "imports": [
        "typing",
        "jsonschema.exceptions.ValidationError",
        "starlette.exceptions.HTTPException",
        "problem.problem"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "exceptions",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\exceptions.py",
      "line_number": 144,
      "end_line_number": 151,
      "source_code": "def __init__(self, detail: t.Optional[str] = None):\n        if detail is None:\n            detail = (\n                \"You don't have the permission to access the requested\"\n                \" resource. It is either read-protected or not readable by the\"\n                \" server.\"\n            )\n        super().__init__(403, detail=detail)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "detail"
      ],
      "imports": [
        "typing",
        "jsonschema.exceptions.ValidationError",
        "starlette.exceptions.HTTPException",
        "problem.problem"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "exceptions",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\exceptions.py",
      "line_number": 157,
      "end_line_number": 164,
      "source_code": "def __init__(self, token_scopes: list, required_scopes: list) -> None:\n        self.required_scopes = required_scopes\n        self.token_scopes = token_scopes\n        detail = (\n            f\"Provided token does not have the required scopes. \"\n            f\"Provided: {token_scopes}; Required: {required_scopes}\"\n        )\n        super().__init__(detail=detail)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "token_scopes",
        "required_scopes"
      ],
      "imports": [
        "typing",
        "jsonschema.exceptions.ValidationError",
        "starlette.exceptions.HTTPException",
        "problem.problem"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "exceptions",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\exceptions.py",
      "line_number": 171,
      "end_line_number": 172,
      "source_code": "def __init__(self, detail: t.Optional[str] = None):\n        super().__init__(status=415, title=\"Unsupported Media Type\", detail=detail)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "detail"
      ],
      "imports": [
        "typing",
        "jsonschema.exceptions.ValidationError",
        "starlette.exceptions.HTTPException",
        "problem.problem"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "exceptions",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\exceptions.py",
      "line_number": 182,
      "end_line_number": 192,
      "source_code": "def __init__(\n        self,\n        status: int = 500,\n        title: t.Optional[str] = None,\n        *,\n        detail: t.Optional[str] = None,\n    ):\n        if title is None:\n            title = \"Internal Server Error\"\n\n        super().__init__(status=status, title=title, detail=detail)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "status",
        "title"
      ],
      "imports": [
        "typing",
        "jsonschema.exceptions.ValidationError",
        "starlette.exceptions.HTTPException",
        "problem.problem"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "exceptions",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\exceptions.py",
      "line_number": 198,
      "end_line_number": 204,
      "source_code": "def __init__(self, detail: t.Optional[str] = None):\n        if detail is None:\n            detail = (\n                \"The server encountered an internal error and was unable to complete your \"\n                \"request. Either the server is overloaded or there is an error in the application.\"\n            )\n        super().__init__(status=500, title=\"Internal Server Error\", detail=detail)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "detail"
      ],
      "imports": [
        "typing",
        "jsonschema.exceptions.ValidationError",
        "starlette.exceptions.HTTPException",
        "problem.problem"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "exceptions",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\exceptions.py",
      "line_number": 211,
      "end_line_number": 212,
      "source_code": "def __init__(self, detail: t.Optional[str] = None):\n        super().__init__(detail=detail)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "detail"
      ],
      "imports": [
        "typing",
        "jsonschema.exceptions.ValidationError",
        "starlette.exceptions.HTTPException",
        "problem.problem"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "exceptions",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\exceptions.py",
      "line_number": 219,
      "end_line_number": 223,
      "source_code": "def __init__(self, detail: t.Optional[str] = None):\n        if detail is None:\n            detail = \"Response body does not conform to specification\"\n\n        super().__init__(detail=detail)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "detail"
      ],
      "imports": [
        "typing",
        "jsonschema.exceptions.ValidationError",
        "starlette.exceptions.HTTPException",
        "problem.problem"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "exceptions",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\exceptions.py",
      "line_number": 230,
      "end_line_number": 234,
      "source_code": "def __init__(self, detail: t.Optional[str] = None):\n        if detail is None:\n            detail = \"Response headers do not conform to specification\"\n\n        super().__init__(detail=detail)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "detail"
      ],
      "imports": [
        "typing",
        "jsonschema.exceptions.ValidationError",
        "starlette.exceptions.HTTPException",
        "problem.problem"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "exceptions",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\exceptions.py",
      "line_number": 241,
      "end_line_number": 242,
      "source_code": "def __init__(self, status: int = 501, *, detail: t.Optional[str] = None):\n        super().__init__(status=status, title=\"Not Implemented\", detail=detail)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "status"
      ],
      "imports": [
        "typing",
        "jsonschema.exceptions.ValidationError",
        "starlette.exceptions.HTTPException",
        "problem.problem"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "handlers",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\handlers.py",
      "line_number": 19,
      "end_line_number": 21,
      "source_code": "def __init__(self, status_code, exception):\n        self.status_code = status_code\n        self.exception = exception",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "status_code",
        "exception"
      ],
      "imports": [
        "logging",
        "exceptions.ResolverProblem"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "function",
      "module": "handlers",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\handlers.py",
      "line_number": 24,
      "end_line_number": 25,
      "source_code": "def function(self):\n        return self.handle",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "logging",
        "exceptions.ResolverProblem"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "handle",
      "module": "handlers",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\handlers.py",
      "line_number": 27,
      "end_line_number": 31,
      "source_code": "def handle(self, *args, **kwargs):\n        raise ResolverProblem(\n            detail=self.exception.args[0],\n            status=self.status_code,\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "logging",
        "exceptions.ResolverProblem"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "operation_id",
      "module": "handlers",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\handlers.py",
      "line_number": 34,
      "end_line_number": 35,
      "source_code": "def operation_id(self):\n        return \"noop\"",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "logging",
        "exceptions.ResolverProblem"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "randomize_endpoint",
      "module": "handlers",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\handlers.py",
      "line_number": 38,
      "end_line_number": 39,
      "source_code": "def randomize_endpoint(self):\n        return RESOLVER_ERROR_ENDPOINT_RANDOM_DIGITS",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "logging",
        "exceptions.ResolverProblem"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "get_path_parameter_types",
      "module": "handlers",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\handlers.py",
      "line_number": 41,
      "end_line_number": 42,
      "source_code": "def get_path_parameter_types(self):\n        return {}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "logging",
        "exceptions.ResolverProblem"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "uri_parser_class",
      "module": "handlers",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\handlers.py",
      "line_number": 45,
      "end_line_number": 46,
      "source_code": "def uri_parser_class(self):\n        return \"dummy\"",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "logging",
        "exceptions.ResolverProblem"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "api",
      "module": "handlers",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\handlers.py",
      "line_number": 49,
      "end_line_number": 50,
      "source_code": "def api(self):\n        return \"dummy\"",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "logging",
        "exceptions.ResolverProblem"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "get_mimetype",
      "module": "handlers",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\handlers.py",
      "line_number": 52,
      "end_line_number": 53,
      "source_code": "def get_mimetype(self):\n        return \"dummy\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "logging",
        "exceptions.ResolverProblem"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "wrap_default",
      "module": "jsonifier",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\jsonifier.py",
      "line_number": 13,
      "end_line_number": 46,
      "source_code": "def wrap_default(default_fn: t.Callable) -> t.Callable:\n    \"\"\"The Connexion defaults for JSON encoding. Handles extra types compared to the\n    built-in :class:`json.JSONEncoder`.\n\n    -   :class:`datetime.datetime` and :class:`datetime.date` are\n        serialized to :rfc:`822` strings. This is the same as the HTTP\n        date format.\n    -   :class:`decimal.Decimal` is serialized to a float.\n    -   :class:`uuid.UUID` is serialized to a string.\n    \"\"\"\n\n    @functools.wraps(default_fn)\n    def wrapped_default(self, o):\n        if isinstance(o, datetime.datetime):\n            if o.tzinfo:\n                # eg: '2015-09-25T23:14:42.588601+00:00'\n                return o.isoformat(\"T\")\n            else:\n                # No timezone present - assume UTC.\n                # eg: '2015-09-25T23:14:42.588601Z'\n                return o.isoformat(\"T\") + \"Z\"\n\n        if isinstance(o, datetime.date):\n            return o.isoformat()\n\n        if isinstance(o, Decimal):\n            return float(o)\n\n        if isinstance(o, uuid.UUID):\n            return str(o)\n\n        return default_fn(self, o)\n\n    return wrapped_default",
      "docstring": "The Connexion defaults for JSON encoding. Handles extra types compared to the\nbuilt-in :class:`json.JSONEncoder`.\n\n-   :class:`datetime.datetime` and :class:`datetime.date` are\n    serialized to :rfc:`822` strings. This is the same as the HTTP\n    date format.\n-   :class:`decimal.Decimal` is serialized to a float.\n-   :class:`uuid.UUID` is serialized to a string.",
      "decorators": [],
      "arguments": [
        "default_fn"
      ],
      "imports": [
        "datetime",
        "functools",
        "json",
        "typing",
        "uuid",
        "decimal.Decimal"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "wrapped_default",
      "module": "jsonifier",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\jsonifier.py",
      "line_number": 25,
      "end_line_number": 44,
      "source_code": "def wrapped_default(self, o):\n        if isinstance(o, datetime.datetime):\n            if o.tzinfo:\n                # eg: '2015-09-25T23:14:42.588601+00:00'\n                return o.isoformat(\"T\")\n            else:\n                # No timezone present - assume UTC.\n                # eg: '2015-09-25T23:14:42.588601Z'\n                return o.isoformat(\"T\") + \"Z\"\n\n        if isinstance(o, datetime.date):\n            return o.isoformat()\n\n        if isinstance(o, Decimal):\n            return float(o)\n\n        if isinstance(o, uuid.UUID):\n            return str(o)\n\n        return default_fn(self, o)",
      "docstring": null,
      "decorators": [
        "functools.wraps(default_fn)"
      ],
      "arguments": [
        "self",
        "o"
      ],
      "imports": [
        "datetime",
        "functools",
        "json",
        "typing",
        "uuid",
        "decimal.Decimal"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "default",
      "module": "jsonifier",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\jsonifier.py",
      "line_number": 60,
      "end_line_number": 61,
      "source_code": "def default(self, o):\n        return super().default(o)",
      "docstring": null,
      "decorators": [
        "wrap_default"
      ],
      "arguments": [
        "self",
        "o"
      ],
      "imports": [
        "datetime",
        "functools",
        "json",
        "typing",
        "uuid",
        "decimal.Decimal"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "jsonifier",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\jsonifier.py",
      "line_number": 69,
      "end_line_number": 76,
      "source_code": "def __init__(self, json_=json, **kwargs):\n        \"\"\"\n        :param json_: json library to use. Must have loads() and dumps() method  # NOQA\n        :param kwargs: default arguments to pass to json.dumps()\n        \"\"\"\n        self.json = json_\n        self.dumps_args = kwargs\n        self.dumps_args.setdefault(\"cls\", JSONEncoder)",
      "docstring": ":param json_: json library to use. Must have loads() and dumps() method  # NOQA\n:param kwargs: default arguments to pass to json.dumps()",
      "decorators": [],
      "arguments": [
        "self",
        "json_"
      ],
      "imports": [
        "datetime",
        "functools",
        "json",
        "typing",
        "uuid",
        "decimal.Decimal"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "dumps",
      "module": "jsonifier",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\jsonifier.py",
      "line_number": 78,
      "end_line_number": 84,
      "source_code": "def dumps(self, data, **kwargs):\n        \"\"\"Central point where JSON serialization happens inside\n        Connexion.\n        \"\"\"\n        for k, v in self.dumps_args.items():\n            kwargs.setdefault(k, v)\n        return self.json.dumps(data, **kwargs) + \"\\n\"",
      "docstring": "Central point where JSON serialization happens inside\nConnexion.",
      "decorators": [],
      "arguments": [
        "self",
        "data"
      ],
      "imports": [
        "datetime",
        "functools",
        "json",
        "typing",
        "uuid",
        "decimal.Decimal"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.json.dumps",
          "body": "def dumps(self, data, **kwargs):\n    \"\"\"Central point where JSON serialization happens inside\n        Connexion.\n        \"\"\"\n    for k, v in self.dumps_args.items():\n        kwargs.setdefault(k, v)\n    return self.json.dumps(data, **kwargs) + '\\n'"
        }
      ]
    },
    {
      "name": "loads",
      "module": "jsonifier",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\jsonifier.py",
      "line_number": 86,
      "end_line_number": 97,
      "source_code": "def loads(self, data):\n        \"\"\"Central point where JSON deserialization happens inside\n        Connexion.\n        \"\"\"\n        if isinstance(data, bytes):\n            data = data.decode()\n\n        try:\n            return self.json.loads(data)\n        except Exception:\n            if isinstance(data, str):\n                return data",
      "docstring": "Central point where JSON deserialization happens inside\nConnexion.",
      "decorators": [],
      "arguments": [
        "self",
        "data"
      ],
      "imports": [
        "datetime",
        "functools",
        "json",
        "typing",
        "uuid",
        "decimal.Decimal"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.json.loads",
          "body": "def loads(self, data):\n    \"\"\"Central point where JSON deserialization happens inside\n        Connexion.\n        \"\"\"\n    if isinstance(data, bytes):\n        data = data.decode()\n    try:\n        return self.json.loads(data)\n    except Exception:\n        if isinstance(data, str):\n            return data"
        }
      ]
    },
    {
      "name": "resolve_refs",
      "module": "json_schema",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\json_schema.py",
      "line_number": 73,
      "end_line_number": 107,
      "source_code": "def resolve_refs(spec, store=None, base_uri=\"\"):\n    \"\"\"\n    Resolve JSON references like {\"$ref\": <some URI>} in a spec.\n    Optionally takes a store, which is a mapping from reference URLs to a\n    dereferenced objects. Prepopulating the store can avoid network calls.\n    \"\"\"\n    spec = deepcopy(spec)\n    store = store or {}\n    resolver = RefResolver(base_uri, spec, store, handlers=handlers)\n\n    def _do_resolve(node):\n        if isinstance(node, Mapping) and \"$ref\" in node:\n            path = node[\"$ref\"][2:].split(\"/\")\n            try:\n                # resolve known references\n                retrieved = deep_get(spec, path)\n                node.update(retrieved)\n                if isinstance(retrieved, Mapping) and \"$ref\" in retrieved:\n                    node = _do_resolve(node)\n                node.pop(\"$ref\", None)\n                return node\n            except KeyError:\n                # resolve external references\n                with resolver.resolving(node[\"$ref\"]) as resolved:\n                    return _do_resolve(resolved)\n        elif isinstance(node, Mapping):\n            for k, v in node.items():\n                node[k] = _do_resolve(v)\n        elif isinstance(node, (list, tuple)):\n            for i, _ in enumerate(node):\n                node[i] = _do_resolve(node[i])\n        return node\n\n    res = _do_resolve(spec)\n    return res",
      "docstring": "Resolve JSON references like {\"$ref\": <some URI>} in a spec.\nOptionally takes a store, which is a mapping from reference URLs to a\ndereferenced objects. Prepopulating the store can avoid network calls.",
      "decorators": [],
      "arguments": [
        "spec",
        "store",
        "base_uri"
      ],
      "imports": [
        "contextlib",
        "io",
        "os",
        "typing",
        "urllib.parse",
        "urllib.request",
        "collections.abc.Mapping",
        "copy.deepcopy",
        "requests",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.RefResolver",
        "jsonschema.exceptions.RefResolutionError",
        "jsonschema.exceptions.ValidationError",
        "jsonschema.validators.extend",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "_do_resolve",
          "body": "def _do_resolve(node):\n    if isinstance(node, Mapping) and '$ref' in node:\n        path = node['$ref'][2:].split('/')\n        try:\n            retrieved = deep_get(spec, path)\n            node.update(retrieved)\n            if isinstance(retrieved, Mapping) and '$ref' in retrieved:\n                node = _do_resolve(node)\n            node.pop('$ref', None)\n            return node\n        except KeyError:\n            with resolver.resolving(node['$ref']) as resolved:\n                return _do_resolve(resolved)\n    elif isinstance(node, Mapping):\n        for k, v in node.items():\n            node[k] = _do_resolve(v)\n    elif isinstance(node, (list, tuple)):\n        for i, _ in enumerate(node):\n            node[i] = _do_resolve(node[i])\n    return node"
        },
        {
          "name": "deep_get",
          "body": "def deep_get(obj, keys):\n    \"\"\"\n    Recurses through a nested object get a leaf value.\n\n    There are cases where the use of inheritance or polymorphism-- the use of allOf or\n    oneOf keywords-- will cause the obj to be a list. In this case the keys will\n    contain one or more strings containing integers.\n\n    :type obj: list or dict\n    :type keys: list of strings\n    \"\"\"\n    if not keys:\n        return obj\n    if isinstance(obj, list):\n        return deep_get(obj[int(keys[0])], keys[1:])\n    else:\n        return deep_get(obj[keys[0]], keys[1:])"
        },
        {
          "name": "_do_resolve",
          "body": "def _do_resolve(node):\n    if isinstance(node, Mapping) and '$ref' in node:\n        path = node['$ref'][2:].split('/')\n        try:\n            retrieved = deep_get(spec, path)\n            node.update(retrieved)\n            if isinstance(retrieved, Mapping) and '$ref' in retrieved:\n                node = _do_resolve(node)\n            node.pop('$ref', None)\n            return node\n        except KeyError:\n            with resolver.resolving(node['$ref']) as resolved:\n                return _do_resolve(resolved)\n    elif isinstance(node, Mapping):\n        for k, v in node.items():\n            node[k] = _do_resolve(v)\n    elif isinstance(node, (list, tuple)):\n        for i, _ in enumerate(node):\n            node[i] = _do_resolve(node[i])\n    return node"
        },
        {
          "name": "_do_resolve",
          "body": "def _do_resolve(node):\n    if isinstance(node, Mapping) and '$ref' in node:\n        path = node['$ref'][2:].split('/')\n        try:\n            retrieved = deep_get(spec, path)\n            node.update(retrieved)\n            if isinstance(retrieved, Mapping) and '$ref' in retrieved:\n                node = _do_resolve(node)\n            node.pop('$ref', None)\n            return node\n        except KeyError:\n            with resolver.resolving(node['$ref']) as resolved:\n                return _do_resolve(resolved)\n    elif isinstance(node, Mapping):\n        for k, v in node.items():\n            node[k] = _do_resolve(v)\n    elif isinstance(node, (list, tuple)):\n        for i, _ in enumerate(node):\n            node[i] = _do_resolve(node[i])\n    return node"
        },
        {
          "name": "_do_resolve",
          "body": "def _do_resolve(node):\n    if isinstance(node, Mapping) and '$ref' in node:\n        path = node['$ref'][2:].split('/')\n        try:\n            retrieved = deep_get(spec, path)\n            node.update(retrieved)\n            if isinstance(retrieved, Mapping) and '$ref' in retrieved:\n                node = _do_resolve(node)\n            node.pop('$ref', None)\n            return node\n        except KeyError:\n            with resolver.resolving(node['$ref']) as resolved:\n                return _do_resolve(resolved)\n    elif isinstance(node, Mapping):\n        for k, v in node.items():\n            node[k] = _do_resolve(v)\n    elif isinstance(node, (list, tuple)):\n        for i, _ in enumerate(node):\n            node[i] = _do_resolve(node[i])\n    return node"
        },
        {
          "name": "_do_resolve",
          "body": "def _do_resolve(node):\n    if isinstance(node, Mapping) and '$ref' in node:\n        path = node['$ref'][2:].split('/')\n        try:\n            retrieved = deep_get(spec, path)\n            node.update(retrieved)\n            if isinstance(retrieved, Mapping) and '$ref' in retrieved:\n                node = _do_resolve(node)\n            node.pop('$ref', None)\n            return node\n        except KeyError:\n            with resolver.resolving(node['$ref']) as resolved:\n                return _do_resolve(resolved)\n    elif isinstance(node, Mapping):\n        for k, v in node.items():\n            node[k] = _do_resolve(v)\n    elif isinstance(node, (list, tuple)):\n        for i, _ in enumerate(node):\n            node[i] = _do_resolve(node[i])\n    return node"
        }
      ]
    },
    {
      "name": "format_error_with_path",
      "module": "json_schema",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\json_schema.py",
      "line_number": 110,
      "end_line_number": 114,
      "source_code": "def format_error_with_path(exception: ValidationError) -> str:\n    \"\"\"Format a `ValidationError` with path to error.\"\"\"\n    error_path = \".\".join(str(item) for item in exception.path)\n    error_path_msg = f\" - '{error_path}'\" if error_path else \"\"\n    return error_path_msg",
      "docstring": "Format a `ValidationError` with path to error.",
      "decorators": [],
      "arguments": [
        "exception"
      ],
      "imports": [
        "contextlib",
        "io",
        "os",
        "typing",
        "urllib.parse",
        "urllib.request",
        "collections.abc.Mapping",
        "copy.deepcopy",
        "requests",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.RefResolver",
        "jsonschema.exceptions.RefResolutionError",
        "jsonschema.exceptions.ValidationError",
        "jsonschema.validators.extend",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "allow_nullable",
      "module": "json_schema",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\json_schema.py",
      "line_number": 117,
      "end_line_number": 128,
      "source_code": "def allow_nullable(validation_fn: t.Callable) -> t.Callable:\n    \"\"\"Extend an existing validation function, so it allows nullable values to be null.\"\"\"\n\n    def nullable_validation_fn(validator, to_validate, instance, schema):\n        if instance is None and (\n            schema.get(\"x-nullable\") is True or schema.get(\"nullable\")\n        ):\n            return\n\n        yield from validation_fn(validator, to_validate, instance, schema)\n\n    return nullable_validation_fn",
      "docstring": "Extend an existing validation function, so it allows nullable values to be null.",
      "decorators": [],
      "arguments": [
        "validation_fn"
      ],
      "imports": [
        "contextlib",
        "io",
        "os",
        "typing",
        "urllib.parse",
        "urllib.request",
        "collections.abc.Mapping",
        "copy.deepcopy",
        "requests",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.RefResolver",
        "jsonschema.exceptions.RefResolutionError",
        "jsonschema.exceptions.ValidationError",
        "jsonschema.validators.extend",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "schema.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "schema.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "validate_writeOnly",
      "module": "json_schema",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\json_schema.py",
      "line_number": 131,
      "end_line_number": 132,
      "source_code": "def validate_writeOnly(validator, wo, instance, schema):\n    yield ValidationError(\"Property is write-only\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "validator",
        "wo",
        "instance",
        "schema"
      ],
      "imports": [
        "contextlib",
        "io",
        "os",
        "typing",
        "urllib.parse",
        "urllib.request",
        "collections.abc.Mapping",
        "copy.deepcopy",
        "requests",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.RefResolver",
        "jsonschema.exceptions.RefResolutionError",
        "jsonschema.exceptions.ValidationError",
        "jsonschema.validators.extend",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "json_schema",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\json_schema.py",
      "line_number": 26,
      "end_line_number": 29,
      "source_code": "def __init__(self, stream):\n        self.original_construct_mapping = self.construct_mapping\n        self.construct_mapping = self.extended_construct_mapping\n        super().__init__(stream)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "stream"
      ],
      "imports": [
        "contextlib",
        "io",
        "os",
        "typing",
        "urllib.parse",
        "urllib.request",
        "collections.abc.Mapping",
        "copy.deepcopy",
        "requests",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.RefResolver",
        "jsonschema.exceptions.RefResolutionError",
        "jsonschema.exceptions.ValidationError",
        "jsonschema.validators.extend",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "extended_construct_mapping",
      "module": "json_schema",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\json_schema.py",
      "line_number": 31,
      "end_line_number": 33,
      "source_code": "def extended_construct_mapping(self, node, deep=False):\n        data = self.original_construct_mapping(node, deep)\n        return {str(key): data[key] for key in data}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "node",
        "deep"
      ],
      "imports": [
        "contextlib",
        "io",
        "os",
        "typing",
        "urllib.parse",
        "urllib.request",
        "collections.abc.Mapping",
        "copy.deepcopy",
        "requests",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.RefResolver",
        "jsonschema.exceptions.RefResolutionError",
        "jsonschema.exceptions.ValidationError",
        "jsonschema.validators.extend",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__call__",
      "module": "json_schema",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\json_schema.py",
      "line_number": 39,
      "end_line_number": 42,
      "source_code": "def __call__(self, uri):\n        filepath = self._uri_to_path(uri)\n        with open(filepath) as fh:\n            return yaml.load(fh, ExtendedSafeLoader)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "uri"
      ],
      "imports": [
        "contextlib",
        "io",
        "os",
        "typing",
        "urllib.parse",
        "urllib.request",
        "collections.abc.Mapping",
        "copy.deepcopy",
        "requests",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.RefResolver",
        "jsonschema.exceptions.RefResolutionError",
        "jsonschema.exceptions.ValidationError",
        "jsonschema.validators.extend",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._uri_to_path",
          "body": "@staticmethod\ndef _uri_to_path(uri):\n    parsed = urllib.parse.urlparse(uri)\n    host = '{0}{0}{mnt}{0}'.format(os.path.sep, mnt=parsed.netloc)\n    return os.path.abspath(os.path.join(host, urllib.request.url2pathname(parsed.path)))"
        },
        {
          "name": "yaml.load",
          "body": "@classmethod\ndef load(cls, spec, *, arguments=None):\n    if isinstance(spec, str) and (spec.startswith('http://') or spec.startswith('https://')):\n        return cls.from_url(spec)\n    if not isinstance(spec, dict):\n        base_uri = f'{pathlib.Path(spec).parent}{os.sep}'\n        return cls.from_file(spec, arguments=arguments, base_uri=base_uri)\n    return cls.from_dict(spec)"
        }
      ]
    },
    {
      "name": "_uri_to_path",
      "module": "json_schema",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\json_schema.py",
      "line_number": 45,
      "end_line_number": 50,
      "source_code": "def _uri_to_path(uri):\n        parsed = urllib.parse.urlparse(uri)\n        host = \"{0}{0}{mnt}{0}\".format(os.path.sep, mnt=parsed.netloc)\n        return os.path.abspath(\n            os.path.join(host, urllib.request.url2pathname(parsed.path))\n        )",
      "docstring": null,
      "decorators": [
        "staticmethod"
      ],
      "arguments": [
        "uri"
      ],
      "imports": [
        "contextlib",
        "io",
        "os",
        "typing",
        "urllib.parse",
        "urllib.request",
        "collections.abc.Mapping",
        "copy.deepcopy",
        "requests",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.RefResolver",
        "jsonschema.exceptions.RefResolutionError",
        "jsonschema.exceptions.ValidationError",
        "jsonschema.validators.extend",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__call__",
      "module": "json_schema",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\json_schema.py",
      "line_number": 56,
      "end_line_number": 62,
      "source_code": "def __call__(self, uri):\n        response = requests.get(uri)\n        response.raise_for_status()\n\n        data = io.StringIO(response.text)\n        with contextlib.closing(data) as fh:\n            return yaml.load(fh, ExtendedSafeLoader)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "uri"
      ],
      "imports": [
        "contextlib",
        "io",
        "os",
        "typing",
        "urllib.parse",
        "urllib.request",
        "collections.abc.Mapping",
        "copy.deepcopy",
        "requests",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.RefResolver",
        "jsonschema.exceptions.RefResolutionError",
        "jsonschema.exceptions.ValidationError",
        "jsonschema.validators.extend",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "yaml.load",
          "body": "@classmethod\ndef load(cls, spec, *, arguments=None):\n    if isinstance(spec, str) and (spec.startswith('http://') or spec.startswith('https://')):\n        return cls.from_url(spec)\n    if not isinstance(spec, dict):\n        base_uri = f'{pathlib.Path(spec).parent}{os.sep}'\n        return cls.from_file(spec, arguments=arguments, base_uri=base_uri)\n    return cls.from_dict(spec)"
        }
      ]
    },
    {
      "name": "_do_resolve",
      "module": "json_schema",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\json_schema.py",
      "line_number": 83,
      "end_line_number": 104,
      "source_code": "def _do_resolve(node):\n        if isinstance(node, Mapping) and \"$ref\" in node:\n            path = node[\"$ref\"][2:].split(\"/\")\n            try:\n                # resolve known references\n                retrieved = deep_get(spec, path)\n                node.update(retrieved)\n                if isinstance(retrieved, Mapping) and \"$ref\" in retrieved:\n                    node = _do_resolve(node)\n                node.pop(\"$ref\", None)\n                return node\n            except KeyError:\n                # resolve external references\n                with resolver.resolving(node[\"$ref\"]) as resolved:\n                    return _do_resolve(resolved)\n        elif isinstance(node, Mapping):\n            for k, v in node.items():\n                node[k] = _do_resolve(v)\n        elif isinstance(node, (list, tuple)):\n            for i, _ in enumerate(node):\n                node[i] = _do_resolve(node[i])\n        return node",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "node"
      ],
      "imports": [
        "contextlib",
        "io",
        "os",
        "typing",
        "urllib.parse",
        "urllib.request",
        "collections.abc.Mapping",
        "copy.deepcopy",
        "requests",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.RefResolver",
        "jsonschema.exceptions.RefResolutionError",
        "jsonschema.exceptions.ValidationError",
        "jsonschema.validators.extend",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "deep_get",
          "body": "def deep_get(obj, keys):\n    \"\"\"\n    Recurses through a nested object get a leaf value.\n\n    There are cases where the use of inheritance or polymorphism-- the use of allOf or\n    oneOf keywords-- will cause the obj to be a list. In this case the keys will\n    contain one or more strings containing integers.\n\n    :type obj: list or dict\n    :type keys: list of strings\n    \"\"\"\n    if not keys:\n        return obj\n    if isinstance(obj, list):\n        return deep_get(obj[int(keys[0])], keys[1:])\n    else:\n        return deep_get(obj[keys[0]], keys[1:])"
        },
        {
          "name": "_do_resolve",
          "body": "def _do_resolve(node):\n    if isinstance(node, Mapping) and '$ref' in node:\n        path = node['$ref'][2:].split('/')\n        try:\n            retrieved = deep_get(spec, path)\n            node.update(retrieved)\n            if isinstance(retrieved, Mapping) and '$ref' in retrieved:\n                node = _do_resolve(node)\n            node.pop('$ref', None)\n            return node\n        except KeyError:\n            with resolver.resolving(node['$ref']) as resolved:\n                return _do_resolve(resolved)\n    elif isinstance(node, Mapping):\n        for k, v in node.items():\n            node[k] = _do_resolve(v)\n    elif isinstance(node, (list, tuple)):\n        for i, _ in enumerate(node):\n            node[i] = _do_resolve(node[i])\n    return node"
        },
        {
          "name": "_do_resolve",
          "body": "def _do_resolve(node):\n    if isinstance(node, Mapping) and '$ref' in node:\n        path = node['$ref'][2:].split('/')\n        try:\n            retrieved = deep_get(spec, path)\n            node.update(retrieved)\n            if isinstance(retrieved, Mapping) and '$ref' in retrieved:\n                node = _do_resolve(node)\n            node.pop('$ref', None)\n            return node\n        except KeyError:\n            with resolver.resolving(node['$ref']) as resolved:\n                return _do_resolve(resolved)\n    elif isinstance(node, Mapping):\n        for k, v in node.items():\n            node[k] = _do_resolve(v)\n    elif isinstance(node, (list, tuple)):\n        for i, _ in enumerate(node):\n            node[i] = _do_resolve(node[i])\n    return node"
        },
        {
          "name": "_do_resolve",
          "body": "def _do_resolve(node):\n    if isinstance(node, Mapping) and '$ref' in node:\n        path = node['$ref'][2:].split('/')\n        try:\n            retrieved = deep_get(spec, path)\n            node.update(retrieved)\n            if isinstance(retrieved, Mapping) and '$ref' in retrieved:\n                node = _do_resolve(node)\n            node.pop('$ref', None)\n            return node\n        except KeyError:\n            with resolver.resolving(node['$ref']) as resolved:\n                return _do_resolve(resolved)\n    elif isinstance(node, Mapping):\n        for k, v in node.items():\n            node[k] = _do_resolve(v)\n    elif isinstance(node, (list, tuple)):\n        for i, _ in enumerate(node):\n            node[i] = _do_resolve(node[i])\n    return node"
        },
        {
          "name": "_do_resolve",
          "body": "def _do_resolve(node):\n    if isinstance(node, Mapping) and '$ref' in node:\n        path = node['$ref'][2:].split('/')\n        try:\n            retrieved = deep_get(spec, path)\n            node.update(retrieved)\n            if isinstance(retrieved, Mapping) and '$ref' in retrieved:\n                node = _do_resolve(node)\n            node.pop('$ref', None)\n            return node\n        except KeyError:\n            with resolver.resolving(node['$ref']) as resolved:\n                return _do_resolve(resolved)\n    elif isinstance(node, Mapping):\n        for k, v in node.items():\n            node[k] = _do_resolve(v)\n    elif isinstance(node, (list, tuple)):\n        for i, _ in enumerate(node):\n            node[i] = _do_resolve(node[i])\n    return node"
        }
      ]
    },
    {
      "name": "nullable_validation_fn",
      "module": "json_schema",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\json_schema.py",
      "line_number": 120,
      "end_line_number": 126,
      "source_code": "def nullable_validation_fn(validator, to_validate, instance, schema):\n        if instance is None and (\n            schema.get(\"x-nullable\") is True or schema.get(\"nullable\")\n        ):\n            return\n\n        yield from validation_fn(validator, to_validate, instance, schema)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "validator",
        "to_validate",
        "instance",
        "schema"
      ],
      "imports": [
        "contextlib",
        "io",
        "os",
        "typing",
        "urllib.parse",
        "urllib.request",
        "collections.abc.Mapping",
        "copy.deepcopy",
        "requests",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.RefResolver",
        "jsonschema.exceptions.RefResolutionError",
        "jsonschema.exceptions.ValidationError",
        "jsonschema.validators.extend",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "schema.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "schema.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "context",
      "module": "lifecycle",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\lifecycle.py",
      "line_number": 19,
      "end_line_number": 21,
      "source_code": "def context(self) -> t.Dict[str, t.Any]:\n        \"\"\"The connexion context of the current request cycle.\"\"\"\n        raise NotImplementedError",
      "docstring": "The connexion context of the current request cycle.",
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "typing",
        "collections.defaultdict",
        "python_multipart.multipart.parse_options_header",
        "starlette.datastructures.UploadFile",
        "starlette.requests.Request",
        "werkzeug.Request",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.utils.is_json_mimetype"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "content_type",
      "module": "lifecycle",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\lifecycle.py",
      "line_number": 24,
      "end_line_number": 26,
      "source_code": "def content_type(self) -> str:\n        \"\"\"The content type included in the request headers.\"\"\"\n        raise NotImplementedError",
      "docstring": "The content type included in the request headers.",
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "typing",
        "collections.defaultdict",
        "python_multipart.multipart.parse_options_header",
        "starlette.datastructures.UploadFile",
        "starlette.requests.Request",
        "werkzeug.Request",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.utils.is_json_mimetype"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "mimetype",
      "module": "lifecycle",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\lifecycle.py",
      "line_number": 29,
      "end_line_number": 32,
      "source_code": "def mimetype(self) -> str:\n        \"\"\"The content type included in the request headers stripped from any optional character\n        set encoding\"\"\"\n        raise NotImplementedError",
      "docstring": "The content type included in the request headers stripped from any optional character\nset encoding",
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "typing",
        "collections.defaultdict",
        "python_multipart.multipart.parse_options_header",
        "starlette.datastructures.UploadFile",
        "starlette.requests.Request",
        "werkzeug.Request",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.utils.is_json_mimetype"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "path_params",
      "module": "lifecycle",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\lifecycle.py",
      "line_number": 35,
      "end_line_number": 37,
      "source_code": "def path_params(self) -> t.Dict[str, t.Any]:\n        \"\"\"Path parameters exposed as a dictionary\"\"\"\n        raise NotImplementedError",
      "docstring": "Path parameters exposed as a dictionary",
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "typing",
        "collections.defaultdict",
        "python_multipart.multipart.parse_options_header",
        "starlette.datastructures.UploadFile",
        "starlette.requests.Request",
        "werkzeug.Request",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.utils.is_json_mimetype"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "query_params",
      "module": "lifecycle",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\lifecycle.py",
      "line_number": 40,
      "end_line_number": 42,
      "source_code": "def query_params(self) -> t.Dict[str, t.Any]:\n        \"\"\"Query parameters exposed as a dictionary\"\"\"\n        raise NotImplementedError",
      "docstring": "Query parameters exposed as a dictionary",
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "typing",
        "collections.defaultdict",
        "python_multipart.multipart.parse_options_header",
        "starlette.datastructures.UploadFile",
        "starlette.requests.Request",
        "werkzeug.Request",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.utils.is_json_mimetype"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "form",
      "module": "lifecycle",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\lifecycle.py",
      "line_number": 44,
      "end_line_number": 46,
      "source_code": "def form(self) -> t.Union[t.Dict[str, t.Any], t.Awaitable[t.Dict[str, t.Any]]]:\n        \"\"\"Form data, including files.\"\"\"\n        raise NotImplementedError",
      "docstring": "Form data, including files.",
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "typing",
        "collections.defaultdict",
        "python_multipart.multipart.parse_options_header",
        "starlette.datastructures.UploadFile",
        "starlette.requests.Request",
        "werkzeug.Request",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.utils.is_json_mimetype"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "files",
      "module": "lifecycle",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\lifecycle.py",
      "line_number": 48,
      "end_line_number": 50,
      "source_code": "def files(self) -> t.Dict[str, t.Any]:\n        \"\"\"Files included in the request.\"\"\"\n        raise NotImplementedError",
      "docstring": "Files included in the request.",
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "typing",
        "collections.defaultdict",
        "python_multipart.multipart.parse_options_header",
        "starlette.datastructures.UploadFile",
        "starlette.requests.Request",
        "werkzeug.Request",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.utils.is_json_mimetype"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "json",
      "module": "lifecycle",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\lifecycle.py",
      "line_number": 52,
      "end_line_number": 54,
      "source_code": "def json(self) -> dict:\n        \"\"\"Json data included in the request.\"\"\"\n        raise NotImplementedError",
      "docstring": "Json data included in the request.",
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "typing",
        "collections.defaultdict",
        "python_multipart.multipart.parse_options_header",
        "starlette.datastructures.UploadFile",
        "starlette.requests.Request",
        "werkzeug.Request",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.utils.is_json_mimetype"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "get_body",
      "module": "lifecycle",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\lifecycle.py",
      "line_number": 56,
      "end_line_number": 60,
      "source_code": "def get_body(self) -> t.Any:\n        \"\"\"Get body based on the content type. This returns json data for json content types,\n        form data for form content types, and bytes for all others. If the bytes data is empty,\n        :code:`None` is returned instead.\"\"\"\n        raise NotImplementedError",
      "docstring": "Get body based on the content type. This returns json data for json content types,\nform data for form content types, and bytes for all others. If the bytes data is empty,\n:code:`None` is returned instead.",
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "typing",
        "collections.defaultdict",
        "python_multipart.multipart.parse_options_header",
        "starlette.datastructures.UploadFile",
        "starlette.requests.Request",
        "werkzeug.Request",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.utils.is_json_mimetype"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "lifecycle",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\lifecycle.py",
      "line_number": 64,
      "end_line_number": 75,
      "source_code": "def __init__(\n        self, werkzeug_request: WerkzeugRequest, uri_parser=None, view_args=None\n    ):\n        self._werkzeug_request = werkzeug_request\n        self.uri_parser = uri_parser\n        self.view_args = view_args\n\n        self._context = None\n        self._path_params = None\n        self._query_params = None\n        self._form = None\n        self._body = None",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "werkzeug_request",
        "uri_parser",
        "view_args"
      ],
      "imports": [
        "typing",
        "collections.defaultdict",
        "python_multipart.multipart.parse_options_header",
        "starlette.datastructures.UploadFile",
        "starlette.requests.Request",
        "werkzeug.Request",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.utils.is_json_mimetype"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "context",
      "module": "lifecycle",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\lifecycle.py",
      "line_number": 78,
      "end_line_number": 83,
      "source_code": "def context(self):\n        if self._context is None:\n            scope = self.environ[\"asgi.scope\"]\n            extensions = scope.setdefault(\"extensions\", {})\n            self._context = extensions.setdefault(\"connexion_context\", {})\n        return self._context",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "typing",
        "collections.defaultdict",
        "python_multipart.multipart.parse_options_header",
        "starlette.datastructures.UploadFile",
        "starlette.requests.Request",
        "werkzeug.Request",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.utils.is_json_mimetype"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "content_type",
      "module": "lifecycle",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\lifecycle.py",
      "line_number": 86,
      "end_line_number": 87,
      "source_code": "def content_type(self) -> str:\n        return self._werkzeug_request.content_type or \"application/octet-stream\"",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "typing",
        "collections.defaultdict",
        "python_multipart.multipart.parse_options_header",
        "starlette.datastructures.UploadFile",
        "starlette.requests.Request",
        "werkzeug.Request",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.utils.is_json_mimetype"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "mimetype",
      "module": "lifecycle",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\lifecycle.py",
      "line_number": 90,
      "end_line_number": 91,
      "source_code": "def mimetype(self) -> str:\n        return self._werkzeug_request.mimetype",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "typing",
        "collections.defaultdict",
        "python_multipart.multipart.parse_options_header",
        "starlette.datastructures.UploadFile",
        "starlette.requests.Request",
        "werkzeug.Request",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.utils.is_json_mimetype"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "path_params",
      "module": "lifecycle",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\lifecycle.py",
      "line_number": 94,
      "end_line_number": 97,
      "source_code": "def path_params(self):\n        if self._path_params is None:\n            self._path_params = self.uri_parser.resolve_path(self.view_args)\n        return self._path_params",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "typing",
        "collections.defaultdict",
        "python_multipart.multipart.parse_options_header",
        "starlette.datastructures.UploadFile",
        "starlette.requests.Request",
        "werkzeug.Request",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.utils.is_json_mimetype"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.uri_parser.resolve_path",
          "body": "@abc.abstractmethod\ndef resolve_path(self, path):\n    \"\"\"Resolve cases where path parameters include lists\"\"\""
        }
      ]
    },
    {
      "name": "query_params",
      "module": "lifecycle",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\lifecycle.py",
      "line_number": 100,
      "end_line_number": 104,
      "source_code": "def query_params(self):\n        if self._query_params is None:\n            query_params = {k: self.args.getlist(k) for k in self.args}\n            self._query_params = self.uri_parser.resolve_query(query_params)\n        return self._query_params",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "typing",
        "collections.defaultdict",
        "python_multipart.multipart.parse_options_header",
        "starlette.datastructures.UploadFile",
        "starlette.requests.Request",
        "werkzeug.Request",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.utils.is_json_mimetype"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.uri_parser.resolve_query",
          "body": "@abc.abstractmethod\ndef resolve_query(self, query_data):\n    \"\"\"Resolve cases where query parameters are provided multiple times.\"\"\""
        }
      ]
    },
    {
      "name": "form",
      "module": "lifecycle",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\lifecycle.py",
      "line_number": 106,
      "end_line_number": 110,
      "source_code": "def form(self):\n        if self._form is None:\n            form = self._werkzeug_request.form.to_dict(flat=False)\n            self._form = self.uri_parser.resolve_form(form)\n        return self._form",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "typing",
        "collections.defaultdict",
        "python_multipart.multipart.parse_options_header",
        "starlette.datastructures.UploadFile",
        "starlette.requests.Request",
        "werkzeug.Request",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.utils.is_json_mimetype"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.uri_parser.resolve_form",
          "body": "@abc.abstractmethod\ndef resolve_form(self, form_data):\n    \"\"\"Resolve cases where form parameters are provided multiple times.\"\"\""
        }
      ]
    },
    {
      "name": "files",
      "module": "lifecycle",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\lifecycle.py",
      "line_number": 112,
      "end_line_number": 113,
      "source_code": "def files(self):\n        return self._werkzeug_request.files.to_dict(flat=False)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "typing",
        "collections.defaultdict",
        "python_multipart.multipart.parse_options_header",
        "starlette.datastructures.UploadFile",
        "starlette.requests.Request",
        "werkzeug.Request",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.utils.is_json_mimetype"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "json",
      "module": "lifecycle",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\lifecycle.py",
      "line_number": 115,
      "end_line_number": 116,
      "source_code": "def json(self):\n        return self.get_json(silent=True)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "typing",
        "collections.defaultdict",
        "python_multipart.multipart.parse_options_header",
        "starlette.datastructures.UploadFile",
        "starlette.requests.Request",
        "werkzeug.Request",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.utils.is_json_mimetype"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "get_body",
      "module": "lifecycle",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\lifecycle.py",
      "line_number": 118,
      "end_line_number": 127,
      "source_code": "def get_body(self):\n        if self._body is None:\n            if is_json_mimetype(self.content_type):\n                self._body = self.get_json(silent=True)\n            elif self.mimetype in FORM_CONTENT_TYPES:\n                self._body = self.form()\n            else:\n                # Return explicit None instead of empty bytestring so it is handled as null downstream\n                self._body = self.get_data() or None\n        return self._body",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "typing",
        "collections.defaultdict",
        "python_multipart.multipart.parse_options_header",
        "starlette.datastructures.UploadFile",
        "starlette.requests.Request",
        "werkzeug.Request",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.utils.is_json_mimetype"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "is_json_mimetype",
          "body": "def is_json_mimetype(mimetype):\n    \"\"\"\n    :type mimetype: str\n    :rtype: bool\n    \"\"\"\n    if mimetype is None:\n        return False\n    maintype, subtype = mimetype.split('/')\n    if ';' in subtype:\n        subtype, parameter = subtype.split(';', maxsplit=1)\n    return maintype == 'application' and (subtype == 'json' or subtype.endswith('+json'))"
        },
        {
          "name": "self.form",
          "body": "def form(self) -> t.Union[t.Dict[str, t.Any], t.Awaitable[t.Dict[str, t.Any]]]:\n    \"\"\"Form data, including files.\"\"\"\n    raise NotImplementedError"
        }
      ]
    },
    {
      "name": "__getattr__",
      "module": "lifecycle",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\lifecycle.py",
      "line_number": 129,
      "end_line_number": 130,
      "source_code": "def __getattr__(self, item):\n        return getattr(self._werkzeug_request, item)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "item"
      ],
      "imports": [
        "typing",
        "collections.defaultdict",
        "python_multipart.multipart.parse_options_header",
        "starlette.datastructures.UploadFile",
        "starlette.requests.Request",
        "werkzeug.Request",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.utils.is_json_mimetype"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "lifecycle",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\lifecycle.py",
      "line_number": 145,
      "end_line_number": 156,
      "source_code": "def __init__(self, *args, uri_parser=None, **kwargs):\n        # Might be set in `from_starlette_request` class method\n        if not hasattr(self, \"_starlette_request\"):\n            self._starlette_request = StarletteRequest(*args, **kwargs)\n        self.uri_parser = uri_parser\n\n        self._context = None\n        self._mimetype = None\n        self._path_params = None\n        self._query_params = None\n        self._form = None\n        self._files = None",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "typing",
        "collections.defaultdict",
        "python_multipart.multipart.parse_options_header",
        "starlette.datastructures.UploadFile",
        "starlette.requests.Request",
        "werkzeug.Request",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.utils.is_json_mimetype"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "from_starlette_request",
      "module": "lifecycle",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\lifecycle.py",
      "line_number": 159,
      "end_line_number": 166,
      "source_code": "def from_starlette_request(\n        cls, request: StarletteRequest, uri_parser=None\n    ) -> \"ConnexionRequest\":\n        # Instantiate the class, and set the `_starlette_request` property before initializing.\n        self = cls.__new__(cls)\n        self._starlette_request = request\n        self.__init__(uri_parser=uri_parser)  # type: ignore\n        return self",
      "docstring": null,
      "decorators": [
        "classmethod"
      ],
      "arguments": [
        "cls",
        "request",
        "uri_parser"
      ],
      "imports": [
        "typing",
        "collections.defaultdict",
        "python_multipart.multipart.parse_options_header",
        "starlette.datastructures.UploadFile",
        "starlette.requests.Request",
        "werkzeug.Request",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.utils.is_json_mimetype"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.__init__",
          "body": "def __init__(self, *, status=500, title=None, detail=None, type=None, instance=None, headers=None, ext=None):\n    self.status = self.status_code = status\n    self.title = title\n    self.detail = detail\n    self.type = type\n    self.instance = instance\n    self.headers = headers\n    self.ext = ext"
        }
      ]
    },
    {
      "name": "context",
      "module": "lifecycle",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\lifecycle.py",
      "line_number": 169,
      "end_line_number": 173,
      "source_code": "def context(self):\n        if self._context is None:\n            extensions = self.scope.setdefault(\"extensions\", {})\n            self._context = extensions.setdefault(\"connexion_context\", {})\n        return self._context",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "typing",
        "collections.defaultdict",
        "python_multipart.multipart.parse_options_header",
        "starlette.datastructures.UploadFile",
        "starlette.requests.Request",
        "werkzeug.Request",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.utils.is_json_mimetype"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "content_type",
      "module": "lifecycle",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\lifecycle.py",
      "line_number": 176,
      "end_line_number": 177,
      "source_code": "def content_type(self):\n        return self.headers.get(\"content-type\", \"application/octet-stream\")",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "typing",
        "collections.defaultdict",
        "python_multipart.multipart.parse_options_header",
        "starlette.datastructures.UploadFile",
        "starlette.requests.Request",
        "werkzeug.Request",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.utils.is_json_mimetype"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.headers.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "mimetype",
      "module": "lifecycle",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\lifecycle.py",
      "line_number": 180,
      "end_line_number": 184,
      "source_code": "def mimetype(self):\n        if not self._mimetype:\n            mimetype, _ = parse_options_header(self.content_type)\n            self._mimetype = mimetype.decode()\n        return self._mimetype",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "typing",
        "collections.defaultdict",
        "python_multipart.multipart.parse_options_header",
        "starlette.datastructures.UploadFile",
        "starlette.requests.Request",
        "werkzeug.Request",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.utils.is_json_mimetype"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "path_params",
      "module": "lifecycle",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\lifecycle.py",
      "line_number": 187,
      "end_line_number": 192,
      "source_code": "def path_params(self) -> t.Dict[str, t.Any]:\n        if self._path_params is None:\n            self._path_params = self.uri_parser.resolve_path(\n                self._starlette_request.path_params\n            )\n        return self._path_params",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "typing",
        "collections.defaultdict",
        "python_multipart.multipart.parse_options_header",
        "starlette.datastructures.UploadFile",
        "starlette.requests.Request",
        "werkzeug.Request",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.utils.is_json_mimetype"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.uri_parser.resolve_path",
          "body": "@abc.abstractmethod\ndef resolve_path(self, path):\n    \"\"\"Resolve cases where path parameters include lists\"\"\""
        }
      ]
    },
    {
      "name": "query_params",
      "module": "lifecycle",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\lifecycle.py",
      "line_number": 195,
      "end_line_number": 200,
      "source_code": "def query_params(self):\n        if self._query_params is None:\n            args = self._starlette_request.query_params\n            query_params = {k: args.getlist(k) for k in args}\n            self._query_params = self.uri_parser.resolve_query(query_params)\n        return self._query_params",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "typing",
        "collections.defaultdict",
        "python_multipart.multipart.parse_options_header",
        "starlette.datastructures.UploadFile",
        "starlette.requests.Request",
        "werkzeug.Request",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.utils.is_json_mimetype"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.uri_parser.resolve_query",
          "body": "@abc.abstractmethod\ndef resolve_query(self, query_data):\n    \"\"\"Resolve cases where query parameters are provided multiple times.\"\"\""
        }
      ]
    },
    {
      "name": "__getattr__",
      "module": "lifecycle",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\lifecycle.py",
      "line_number": 241,
      "end_line_number": 243,
      "source_code": "def __getattr__(self, item):\n        if self.__getattribute__(\"_starlette_request\"):\n            return getattr(self._starlette_request, item)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "item"
      ],
      "imports": [
        "typing",
        "collections.defaultdict",
        "python_multipart.multipart.parse_options_header",
        "starlette.datastructures.UploadFile",
        "starlette.requests.Request",
        "werkzeug.Request",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.utils.is_json_mimetype"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "lifecycle",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\lifecycle.py",
      "line_number": 249,
      "end_line_number": 265,
      "source_code": "def __init__(\n        self,\n        status_code=200,\n        mimetype=None,\n        content_type=None,\n        body=None,\n        headers=None,\n        is_streamed=False,\n    ):\n        self.status_code = status_code\n        self.mimetype = mimetype\n        self.content_type = content_type\n        self.body = body\n        self.headers = headers or {}\n        if content_type:\n            self.headers.update({\"Content-Type\": content_type})\n        self.is_streamed = is_streamed",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "status_code",
        "mimetype",
        "content_type",
        "body",
        "headers",
        "is_streamed"
      ],
      "imports": [
        "typing",
        "collections.defaultdict",
        "python_multipart.multipart.parse_options_header",
        "starlette.datastructures.UploadFile",
        "starlette.requests.Request",
        "werkzeug.Request",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.utils.is_json_mimetype"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "mock",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\mock.py",
      "line_number": 14,
      "end_line_number": 17,
      "source_code": "def __init__(self, mock_all):\n        super().__init__()\n        self.mock_all = mock_all\n        self._operation_id_counter = 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "mock_all"
      ],
      "imports": [
        "functools",
        "logging",
        "connexion.resolver.Resolution",
        "connexion.resolver.Resolver",
        "connexion.resolver.ResolverError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "resolve",
      "module": "mock",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\mock.py",
      "line_number": 19,
      "end_line_number": 48,
      "source_code": "def resolve(self, operation):\n        \"\"\"\n        Mock operation resolver\n\n        :type operation: connexion.operations.AbstractOperation\n        \"\"\"\n        operation_id = self.resolve_operation_id(operation)\n        if not operation_id:\n            # just generate an unique operation ID\n            operation_id = f\"mock-{self._operation_id_counter}\"\n            self._operation_id_counter += 1\n\n        mock_func = functools.partial(self.mock_operation, operation=operation)\n        if self.mock_all:\n            func = mock_func\n        else:\n            try:\n                func = self.resolve_function_from_operation_id(operation_id)\n                msg = \"... Successfully resolved operationId '{}'! Mock is *not* used for this operation.\".format(\n                    operation_id\n                )\n                logger.debug(msg)\n            except ResolverError as resolution_error:\n                logger.debug(\n                    \"... {}! Mock function is used for this operation.\".format(\n                        resolution_error.args[0].capitalize()\n                    )\n                )\n                func = mock_func\n        return Resolution(func, operation_id)",
      "docstring": "Mock operation resolver\n\n:type operation: connexion.operations.AbstractOperation",
      "decorators": [],
      "arguments": [
        "self",
        "operation"
      ],
      "imports": [
        "functools",
        "logging",
        "connexion.resolver.Resolution",
        "connexion.resolver.Resolver",
        "connexion.resolver.ResolverError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.resolve_operation_id",
          "body": "def resolve_operation_id(self, operation):\n    \"\"\"\n        Default operationId resolver\n\n        :type operation: connexion.operations.AbstractOperation\n        \"\"\"\n    operation_id = operation.operation_id\n    router_controller = operation.router_controller\n    if router_controller is None:\n        return operation_id\n    return f'{router_controller}.{operation_id}'"
        },
        {
          "name": "self.resolve_function_from_operation_id",
          "body": "def resolve_function_from_operation_id(self, operation_id):\n    \"\"\"\n        Invokes the function_resolver\n\n        :type operation_id: str\n        \"\"\"\n    try:\n        return self.function_resolver(operation_id)\n    except ImportError as e:\n        msg = f'Cannot resolve operationId \"{operation_id}\"! Import error was \"{str(e)}\"'\n        raise ResolverError(msg)\n    except (AttributeError, ValueError) as e:\n        raise ResolverError(str(e))"
        }
      ]
    },
    {
      "name": "mock_operation",
      "module": "mock",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\mock.py",
      "line_number": 50,
      "end_line_number": 59,
      "source_code": "def mock_operation(self, operation, *args, **kwargs):\n        resp, code = operation.example_response()\n        if resp is not None:\n            return resp, code\n        return (\n            \"No example response defined in the API, and response \"\n            \"auto-generation disabled. To enable response auto-generation, \"\n            \"install connexion using the mock extra (connexion[mock])\",\n            501,\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "operation"
      ],
      "imports": [
        "functools",
        "logging",
        "connexion.resolver.Resolution",
        "connexion.resolver.Resolver",
        "connexion.resolver.ResolverError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "operation.example_response",
          "body": "@abc.abstractmethod\ndef example_response(self, status_code=None, content_type=None):\n    \"\"\"\n        Returns an example from the spec\n        \"\"\""
        }
      ]
    },
    {
      "name": "__init__",
      "module": "options",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\options.py",
      "line_number": 51,
      "end_line_number": 67,
      "source_code": "def __init__(\n        self,\n        options: t.Optional[SwaggerUIOptions] = None,\n        oas_version: t.Tuple[int, ...] = (2,),\n    ):\n        if oas_version >= (3, 0, 0):\n            self.spec_path = \"/openapi.json\"\n        else:\n            self.spec_path = \"/swagger.json\"\n\n        if options is not None and not isinstance(options, SwaggerUIOptions):\n            raise ValueError(\n                f\"`swaggger_ui_options` should be of type `SwaggerUIOptions`, \"\n                f\"but received {type(options)} instead.\"\n            )\n\n        self._options = options or SwaggerUIOptions()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "options",
        "oas_version"
      ],
      "imports": [
        "dataclasses",
        "logging",
        "typing",
        "swagger_ui_bundle.swagger_ui_path"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "openapi_spec_available",
      "module": "options",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\options.py",
      "line_number": 70,
      "end_line_number": 72,
      "source_code": "def openapi_spec_available(self) -> bool:\n        \"\"\"Whether to make the OpenAPI Specification available.\"\"\"\n        return self._options.serve_spec",
      "docstring": "Whether to make the OpenAPI Specification available.",
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "dataclasses",
        "logging",
        "typing",
        "swagger_ui_bundle.swagger_ui_path"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "openapi_spec_path",
      "module": "options",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\options.py",
      "line_number": 75,
      "end_line_number": 77,
      "source_code": "def openapi_spec_path(self) -> str:\n        \"\"\"Path to host the Swagger UI.\"\"\"\n        return self._options.spec_path or self.spec_path",
      "docstring": "Path to host the Swagger UI.",
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "dataclasses",
        "logging",
        "typing",
        "swagger_ui_bundle.swagger_ui_path"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "swagger_ui_available",
      "module": "options",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\options.py",
      "line_number": 80,
      "end_line_number": 85,
      "source_code": "def swagger_ui_available(self) -> bool:\n        \"\"\"Whether to make the Swagger UI available.\"\"\"\n        if self._options.swagger_ui and self.swagger_ui_template_dir is None:\n            logger.warning(NO_UI_MSG)\n            return False\n        return self._options.swagger_ui",
      "docstring": "Whether to make the Swagger UI available.",
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "dataclasses",
        "logging",
        "typing",
        "swagger_ui_bundle.swagger_ui_path"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "swagger_ui_path",
      "module": "options",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\options.py",
      "line_number": 88,
      "end_line_number": 90,
      "source_code": "def swagger_ui_path(self) -> str:\n        \"\"\"Path to mount the Swagger UI and make it accessible via a browser.\"\"\"\n        return self._options.swagger_ui_path",
      "docstring": "Path to mount the Swagger UI and make it accessible via a browser.",
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "dataclasses",
        "logging",
        "typing",
        "swagger_ui_bundle.swagger_ui_path"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "swagger_ui_template_dir",
      "module": "options",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\options.py",
      "line_number": 93,
      "end_line_number": 95,
      "source_code": "def swagger_ui_template_dir(self) -> str:\n        \"\"\"Directory with static files to use to serve Swagger UI.\"\"\"\n        return self._options.swagger_ui_template_dir or default_template_dir",
      "docstring": "Directory with static files to use to serve Swagger UI.",
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "dataclasses",
        "logging",
        "typing",
        "swagger_ui_bundle.swagger_ui_path"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "swagger_ui_config",
      "module": "options",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\options.py",
      "line_number": 98,
      "end_line_number": 100,
      "source_code": "def swagger_ui_config(self) -> dict:\n        \"\"\"Options to configure the Swagger UI.\"\"\"\n        return self._options.swagger_ui_config",
      "docstring": "Options to configure the Swagger UI.",
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "dataclasses",
        "logging",
        "typing",
        "swagger_ui_bundle.swagger_ui_path"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "swagger_ui_template_arguments",
      "module": "options",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\options.py",
      "line_number": 103,
      "end_line_number": 105,
      "source_code": "def swagger_ui_template_arguments(self) -> dict:\n        \"\"\"Arguments passed to the Swagger UI template.\"\"\"\n        return self._options.swagger_ui_template_arguments",
      "docstring": "Arguments passed to the Swagger UI template.",
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "dataclasses",
        "logging",
        "typing",
        "swagger_ui_bundle.swagger_ui_path"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "problem",
      "module": "problem",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\problem.py",
      "line_number": 10,
      "end_line_number": 60,
      "source_code": "def problem(status, title, detail, type=None, instance=None, headers=None, ext=None):\n    \"\"\"\n    Returns a `Problem Details <https://tools.ietf.org/html/draft-ietf-appsawg-http-problem-00>`_ error response.\n\n\n    :param status: The HTTP status code generated by the origin server for this occurrence of the problem.\n    :type status: int\n    :param title: A short, human-readable summary of the problem type.  It SHOULD NOT change from occurrence to\n                  occurrence of the problem, except for purposes of localisation.\n    :type title: str\n    :param detail: An human readable explanation specific to this occurrence of the problem.\n    :type detail: str\n    :param type: An absolute URI that identifies the problem type.  When dereferenced, it SHOULD provide human-readable\n                 documentation for the problem type (e.g., using HTML).  When this member is not present its value is\n                 assumed to be \"about:blank\".\n    :type: type: str\n    :param instance: An absolute URI that identifies the specific occurrence of the problem.  It may or may not yield\n                     further information if dereferenced.\n    :type instance: str\n    :param headers: HTTP headers to include in the response\n    :type headers: dict | None\n    :param ext: Extension members to include in the body\n    :type ext: dict | None\n    :return: error response\n    :rtype: ConnexionResponse\n    \"\"\"\n    from .lifecycle import ConnexionResponse  # prevent circular import\n\n    if not type:\n        type = \"about:blank\"\n\n    problem_response = {\n        \"type\": type,\n        \"title\": title,\n        \"detail\": detail,\n        \"status\": status,\n    }\n    if instance:\n        problem_response[\"instance\"] = instance\n    if ext:\n        problem_response.update(ext)\n\n    mimetype = content_type = \"application/problem+json\"\n\n    return ConnexionResponse(\n        status,\n        mimetype,\n        content_type,\n        body=json.dumps(problem_response),\n        headers=headers,\n    )",
      "docstring": "Returns a `Problem Details <https://tools.ietf.org/html/draft-ietf-appsawg-http-problem-00>`_ error response.\n\n\n:param status: The HTTP status code generated by the origin server for this occurrence of the problem.\n:type status: int\n:param title: A short, human-readable summary of the problem type.  It SHOULD NOT change from occurrence to\n              occurrence of the problem, except for purposes of localisation.\n:type title: str\n:param detail: An human readable explanation specific to this occurrence of the problem.\n:type detail: str\n:param type: An absolute URI that identifies the problem type.  When dereferenced, it SHOULD provide human-readable\n             documentation for the problem type (e.g., using HTML).  When this member is not present its value is\n             assumed to be \"about:blank\".\n:type: type: str\n:param instance: An absolute URI that identifies the specific occurrence of the problem.  It may or may not yield\n                 further information if dereferenced.\n:type instance: str\n:param headers: HTTP headers to include in the response\n:type headers: dict | None\n:param ext: Extension members to include in the body\n:type ext: dict | None\n:return: error response\n:rtype: ConnexionResponse",
      "decorators": [],
      "arguments": [
        "status",
        "title",
        "detail",
        "type",
        "instance",
        "headers",
        "ext"
      ],
      "imports": [
        "json",
        "lifecycle.ConnexionResponse"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "resolver",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\resolver.py",
      "line_number": 19,
      "end_line_number": 27,
      "source_code": "def __init__(self, function, operation_id):\n        \"\"\"\n        Represents the result of operation resolution\n\n        :param function: The endpoint function\n        :type function: types.FunctionType\n        \"\"\"\n        self.function = function\n        self.operation_id = operation_id",
      "docstring": "Represents the result of operation resolution\n\n:param function: The endpoint function\n:type function: types.FunctionType",
      "decorators": [],
      "arguments": [
        "self",
        "function",
        "operation_id"
      ],
      "imports": [
        "inspect",
        "logging",
        "typing",
        "inflection.camelize",
        "connexion.utils",
        "connexion.exceptions.ResolverError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "resolver",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\resolver.py",
      "line_number": 31,
      "end_line_number": 37,
      "source_code": "def __init__(self, function_resolver: t.Callable = utils.get_function_from_name):\n        \"\"\"\n        Standard resolver\n\n        :param function_resolver: Function that resolves functions using an operationId\n        \"\"\"\n        self.function_resolver = function_resolver",
      "docstring": "Standard resolver\n\n:param function_resolver: Function that resolves functions using an operationId",
      "decorators": [],
      "arguments": [
        "self",
        "function_resolver"
      ],
      "imports": [
        "inspect",
        "logging",
        "typing",
        "inflection.camelize",
        "connexion.utils",
        "connexion.exceptions.ResolverError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "resolve",
      "module": "resolver",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\resolver.py",
      "line_number": 39,
      "end_line_number": 48,
      "source_code": "def resolve(self, operation):\n        \"\"\"\n        Default operation resolver\n\n        :type operation: connexion.operations.AbstractOperation\n        \"\"\"\n        operation_id = self.resolve_operation_id(operation)\n        return Resolution(\n            self.resolve_function_from_operation_id(operation_id), operation_id\n        )",
      "docstring": "Default operation resolver\n\n:type operation: connexion.operations.AbstractOperation",
      "decorators": [],
      "arguments": [
        "self",
        "operation"
      ],
      "imports": [
        "inspect",
        "logging",
        "typing",
        "inflection.camelize",
        "connexion.utils",
        "connexion.exceptions.ResolverError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.resolve_operation_id",
          "body": "def resolve_operation_id(self, operation):\n    \"\"\"\n        Default operationId resolver\n\n        :type operation: connexion.operations.AbstractOperation\n        \"\"\"\n    operation_id = operation.operation_id\n    router_controller = operation.router_controller\n    if router_controller is None:\n        return operation_id\n    return f'{router_controller}.{operation_id}'"
        },
        {
          "name": "self.resolve_function_from_operation_id",
          "body": "def resolve_function_from_operation_id(self, operation_id):\n    \"\"\"\n        Invokes the function_resolver\n\n        :type operation_id: str\n        \"\"\"\n    try:\n        return self.function_resolver(operation_id)\n    except ImportError as e:\n        msg = f'Cannot resolve operationId \"{operation_id}\"! Import error was \"{str(e)}\"'\n        raise ResolverError(msg)\n    except (AttributeError, ValueError) as e:\n        raise ResolverError(str(e))"
        }
      ]
    },
    {
      "name": "resolve_operation_id",
      "module": "resolver",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\resolver.py",
      "line_number": 50,
      "end_line_number": 60,
      "source_code": "def resolve_operation_id(self, operation):\n        \"\"\"\n        Default operationId resolver\n\n        :type operation: connexion.operations.AbstractOperation\n        \"\"\"\n        operation_id = operation.operation_id\n        router_controller = operation.router_controller\n        if router_controller is None:\n            return operation_id\n        return f\"{router_controller}.{operation_id}\"",
      "docstring": "Default operationId resolver\n\n:type operation: connexion.operations.AbstractOperation",
      "decorators": [],
      "arguments": [
        "self",
        "operation"
      ],
      "imports": [
        "inspect",
        "logging",
        "typing",
        "inflection.camelize",
        "connexion.utils",
        "connexion.exceptions.ResolverError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "resolve_function_from_operation_id",
      "module": "resolver",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\resolver.py",
      "line_number": 62,
      "end_line_number": 74,
      "source_code": "def resolve_function_from_operation_id(self, operation_id):\n        \"\"\"\n        Invokes the function_resolver\n\n        :type operation_id: str\n        \"\"\"\n        try:\n            return self.function_resolver(operation_id)\n        except ImportError as e:\n            msg = f'Cannot resolve operationId \"{operation_id}\"! Import error was \"{str(e)}\"'\n            raise ResolverError(msg)\n        except (AttributeError, ValueError) as e:\n            raise ResolverError(str(e))",
      "docstring": "Invokes the function_resolver\n\n:type operation_id: str",
      "decorators": [],
      "arguments": [
        "self",
        "operation_id"
      ],
      "imports": [
        "inspect",
        "logging",
        "typing",
        "inflection.camelize",
        "connexion.utils",
        "connexion.exceptions.ResolverError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "resolver",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\resolver.py",
      "line_number": 82,
      "end_line_number": 96,
      "source_code": "def __init__(self, root_path, function_resolver=utils.get_function_from_name):\n        \"\"\"\n        :param root_path: The root path relative to which an operationId is resolved.\n            Can also be a module. Has the same effect as setting\n            `x-swagger-router-controller` or `x-openapi-router-controller` equal to\n            `root_path` for every operation individually.\n        :type root_path: typing.Union[str, types.ModuleType]\n        :param function_resolver: Function that resolves functions using an operationId\n        :type function_resolver: types.FunctionType\n        \"\"\"\n        super().__init__(function_resolver=function_resolver)\n        if inspect.ismodule(root_path):\n            self.root_path = root_path.__name__\n        else:\n            self.root_path = root_path",
      "docstring": ":param root_path: The root path relative to which an operationId is resolved.\n    Can also be a module. Has the same effect as setting\n    `x-swagger-router-controller` or `x-openapi-router-controller` equal to\n    `root_path` for every operation individually.\n:type root_path: typing.Union[str, types.ModuleType]\n:param function_resolver: Function that resolves functions using an operationId\n:type function_resolver: types.FunctionType",
      "decorators": [],
      "arguments": [
        "self",
        "root_path",
        "function_resolver"
      ],
      "imports": [
        "inspect",
        "logging",
        "typing",
        "inflection.camelize",
        "connexion.utils",
        "connexion.exceptions.ResolverError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "resolve_operation_id",
      "module": "resolver",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\resolver.py",
      "line_number": 98,
      "end_line_number": 109,
      "source_code": "def resolve_operation_id(self, operation):\n        \"\"\"Resolves the operationId relative to the root path, unless\n        x-swagger-router-controller or x-openapi-router-controller is specified.\n\n        :param operation: The operation to resolve\n        :type operation: connexion.operations.AbstractOperation\n        \"\"\"\n        operation_id = operation.operation_id\n        router_controller = operation.router_controller\n        if router_controller is None:\n            return f\"{self.root_path}.{operation_id}\"\n        return f\"{router_controller}.{operation_id}\"",
      "docstring": "Resolves the operationId relative to the root path, unless\nx-swagger-router-controller or x-openapi-router-controller is specified.\n\n:param operation: The operation to resolve\n:type operation: connexion.operations.AbstractOperation",
      "decorators": [],
      "arguments": [
        "self",
        "operation"
      ],
      "imports": [
        "inspect",
        "logging",
        "typing",
        "inflection.camelize",
        "connexion.utils",
        "connexion.exceptions.ResolverError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "resolver",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\resolver.py",
      "line_number": 117,
      "end_line_number": 126,
      "source_code": "def __init__(\n        self, default_module_name: str, *, collection_endpoint_name: str = \"search\"\n    ):\n        \"\"\"\n        :param default_module_name: Default module name for operations\n        :param collection_endpoint_name: Name of function to resolve collection endpoints to\n        \"\"\"\n        super().__init__()\n        self.default_module_name = default_module_name\n        self.collection_endpoint_name = collection_endpoint_name",
      "docstring": ":param default_module_name: Default module name for operations\n:param collection_endpoint_name: Name of function to resolve collection endpoints to",
      "decorators": [],
      "arguments": [
        "self",
        "default_module_name"
      ],
      "imports": [
        "inspect",
        "logging",
        "typing",
        "inflection.camelize",
        "connexion.utils",
        "connexion.exceptions.ResolverError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "resolve_operation_id",
      "module": "resolver",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\resolver.py",
      "line_number": 128,
      "end_line_number": 137,
      "source_code": "def resolve_operation_id(self, operation):\n        \"\"\"\n        Resolves the operationId using REST semantics unless explicitly configured in the spec\n\n        :type operation: connexion.operations.AbstractOperation\n        \"\"\"\n        if operation.operation_id:\n            return super().resolve_operation_id(operation)\n\n        return self.resolve_operation_id_using_rest_semantics(operation)",
      "docstring": "Resolves the operationId using REST semantics unless explicitly configured in the spec\n\n:type operation: connexion.operations.AbstractOperation",
      "decorators": [],
      "arguments": [
        "self",
        "operation"
      ],
      "imports": [
        "inspect",
        "logging",
        "typing",
        "inflection.camelize",
        "connexion.utils",
        "connexion.exceptions.ResolverError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.resolve_operation_id_using_rest_semantics",
          "body": "def resolve_operation_id_using_rest_semantics(self, operation):\n    \"\"\"\n        Resolves the operationId using REST semantics\n\n        :type operation: connexion.operations.AbstractOperation\n        \"\"\"\n    path_components = [c for c in operation.path.split('/') if len(c)]\n\n    def is_var(component):\n        \"\"\"True if the path component is a var. eg, '{id}'\"\"\"\n        return component[0] == '{' and component[-1] == '}'\n    resource_name = '.'.join([c for c in path_components if not is_var(c)]).replace('-', '_')\n\n    def get_controller_name():\n        x_router_controller = operation.router_controller\n        name = self.default_module_name\n        if x_router_controller:\n            name = x_router_controller\n        elif resource_name:\n            name += '.' + resource_name\n        return name\n\n    def get_function_name():\n        method = operation.method\n        is_collection_endpoint = method.lower() == 'get' and len(resource_name) and (not is_var(path_components[-1]))\n        return self.collection_endpoint_name if is_collection_endpoint else method.lower()\n    return f'{get_controller_name()}.{get_function_name()}'"
        }
      ]
    },
    {
      "name": "resolve_operation_id_using_rest_semantics",
      "module": "resolver",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\resolver.py",
      "line_number": 139,
      "end_line_number": 185,
      "source_code": "def resolve_operation_id_using_rest_semantics(self, operation):\n        \"\"\"\n        Resolves the operationId using REST semantics\n\n        :type operation: connexion.operations.AbstractOperation\n        \"\"\"\n\n        # Split the path into components delimited by '/'\n        path_components = [c for c in operation.path.split(\"/\") if len(c)]\n\n        def is_var(component):\n            \"\"\"True if the path component is a var. eg, '{id}'\"\"\"\n            return (component[0] == \"{\") and (component[-1] == \"}\")\n\n        resource_name = \".\".join([c for c in path_components if not is_var(c)]).replace(\n            \"-\", \"_\"\n        )\n\n        def get_controller_name():\n            x_router_controller = operation.router_controller\n\n            name = self.default_module_name\n\n            if x_router_controller:\n                name = x_router_controller\n\n            elif resource_name:\n                name += \".\" + resource_name\n\n            return name\n\n        def get_function_name():\n            method = operation.method\n\n            is_collection_endpoint = (\n                method.lower() == \"get\"\n                and len(resource_name)\n                and not is_var(path_components[-1])\n            )\n\n            return (\n                self.collection_endpoint_name\n                if is_collection_endpoint\n                else method.lower()\n            )\n\n        return f\"{get_controller_name()}.{get_function_name()}\"",
      "docstring": "Resolves the operationId using REST semantics\n\n:type operation: connexion.operations.AbstractOperation",
      "decorators": [],
      "arguments": [
        "self",
        "operation"
      ],
      "imports": [
        "inspect",
        "logging",
        "typing",
        "inflection.camelize",
        "connexion.utils",
        "connexion.exceptions.ResolverError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_controller_name",
          "body": "def get_controller_name():\n    x_router_controller = operation.router_controller\n    name = self.default_module_name\n    if x_router_controller:\n        name = x_router_controller\n    elif resource_name:\n        name += '.' + resource_name\n    return name"
        },
        {
          "name": "get_function_name",
          "body": "def get_function_name():\n    method = operation.method\n    is_collection_endpoint = method.lower() == 'get' and len(resource_name) and (not is_var(path_components[-1]))\n    return self.collection_endpoint_name if is_collection_endpoint else method.lower()"
        },
        {
          "name": "is_var",
          "body": "def is_var(component):\n    \"\"\"True if the path component is a var. eg, '{id}'\"\"\"\n    return component[0] == '{' and component[-1] == '}'"
        },
        {
          "name": "is_var",
          "body": "def is_var(component):\n    \"\"\"True if the path component is a var. eg, '{id}'\"\"\"\n    return component[0] == '{' and component[-1] == '}'"
        }
      ]
    },
    {
      "name": "__init__",
      "module": "resolver",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\resolver.py",
      "line_number": 213,
      "end_line_number": 232,
      "source_code": "def __init__(self, *args, class_arguments: _class_arguments_type = None, **kwargs):\n        \"\"\"\n        :param args: Arguments passed to :class:`~RestyResolver`\n        :param class_arguments: Arguments to instantiate the View Class in the format below\n        :param kwargs: Keywords arguments passed to :class:`~RestyResolver`\n\n        .. code-block:: python\n\n            {\n              \"ViewName\": {\n                \"args\": (positional arguments,)\n                \"kwargs\": {\n                  \"keyword\": \"argument\"\n                }\n              }\n            }\n        \"\"\"\n        self.class_arguments = class_arguments or {}\n        super(MethodResolverBase, self).__init__(*args, **kwargs)\n        self.initialized_views: list = []",
      "docstring": ":param args: Arguments passed to :class:`~RestyResolver`\n:param class_arguments: Arguments to instantiate the View Class in the format below\n:param kwargs: Keywords arguments passed to :class:`~RestyResolver`\n\n.. code-block:: python\n\n    {\n      \"ViewName\": {\n        \"args\": (positional arguments,)\n        \"kwargs\": {\n          \"keyword\": \"argument\"\n        }\n      }\n    }",
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "inspect",
        "logging",
        "typing",
        "inflection.camelize",
        "connexion.utils",
        "connexion.exceptions.ResolverError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "resolve_operation_id",
      "module": "resolver",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\resolver.py",
      "line_number": 234,
      "end_line_number": 251,
      "source_code": "def resolve_operation_id(self, operation):\n        \"\"\"\n        Resolves the operationId using REST semantics unless explicitly configured in the spec\n        Once resolved with REST semantics the view_name is capitalised and has 'View' added\n        to it so it now matches the Class names of the MethodView\n\n        :type operation: connexion.operations.AbstractOperation\n        \"\"\"\n        if operation.operation_id:\n            # If operation_id is defined then use the higher level API to resolve\n            return RestyResolver.resolve_operation_id(self, operation)\n\n        # Use RestyResolver to get operation_id for us (follow their naming conventions/structure)\n        operation_id = self.resolve_operation_id_using_rest_semantics(operation)\n        module_name, view_base, meth_name = operation_id.rsplit(\".\", 2)\n        view_name = camelize(view_base) + \"View\"\n\n        return f\"{module_name}.{view_name}.{meth_name}\"",
      "docstring": "Resolves the operationId using REST semantics unless explicitly configured in the spec\nOnce resolved with REST semantics the view_name is capitalised and has 'View' added\nto it so it now matches the Class names of the MethodView\n\n:type operation: connexion.operations.AbstractOperation",
      "decorators": [],
      "arguments": [
        "self",
        "operation"
      ],
      "imports": [
        "inspect",
        "logging",
        "typing",
        "inflection.camelize",
        "connexion.utils",
        "connexion.exceptions.ResolverError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.resolve_operation_id_using_rest_semantics",
          "body": "def resolve_operation_id_using_rest_semantics(self, operation):\n    \"\"\"\n        Resolves the operationId using REST semantics\n\n        :type operation: connexion.operations.AbstractOperation\n        \"\"\"\n    path_components = [c for c in operation.path.split('/') if len(c)]\n\n    def is_var(component):\n        \"\"\"True if the path component is a var. eg, '{id}'\"\"\"\n        return component[0] == '{' and component[-1] == '}'\n    resource_name = '.'.join([c for c in path_components if not is_var(c)]).replace('-', '_')\n\n    def get_controller_name():\n        x_router_controller = operation.router_controller\n        name = self.default_module_name\n        if x_router_controller:\n            name = x_router_controller\n        elif resource_name:\n            name += '.' + resource_name\n        return name\n\n    def get_function_name():\n        method = operation.method\n        is_collection_endpoint = method.lower() == 'get' and len(resource_name) and (not is_var(path_components[-1]))\n        return self.collection_endpoint_name if is_collection_endpoint else method.lower()\n    return f'{get_controller_name()}.{get_function_name()}'"
        },
        {
          "name": "RestyResolver.resolve_operation_id",
          "body": "def resolve_operation_id(self, operation):\n    \"\"\"\n        Resolves the operationId using REST semantics unless explicitly configured in the spec\n\n        :type operation: connexion.operations.AbstractOperation\n        \"\"\"\n    if operation.operation_id:\n        return super().resolve_operation_id(operation)\n    return self.resolve_operation_id_using_rest_semantics(operation)"
        }
      ]
    },
    {
      "name": "resolve_function_from_operation_id",
      "module": "resolver",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\resolver.py",
      "line_number": 253,
      "end_line_number": 277,
      "source_code": "def resolve_function_from_operation_id(self, operation_id):\n        \"\"\"\n        Invokes the function_resolver\n\n        :type operation_id: str\n        \"\"\"\n\n        try:\n            module_name, view_name, meth_name = operation_id.rsplit(\".\", 2)\n            if operation_id and not view_name.endswith(\"View\"):\n                # If operation_id is not a view then assume it is a standard function\n                return self.function_resolver(operation_id)\n\n            mod = __import__(module_name, fromlist=[view_name])\n            view_cls = getattr(mod, view_name)\n            # find the view and return it\n            return self.resolve_method_from_class(view_name, meth_name, view_cls)\n\n        except ImportError as e:\n            msg = 'Cannot resolve operationId \"{}\"! Import error was \"{}\"'.format(\n                operation_id, str(e)\n            )\n            raise ResolverError(msg)\n        except (AttributeError, ValueError) as e:\n            raise ResolverError(str(e))",
      "docstring": "Invokes the function_resolver\n\n:type operation_id: str",
      "decorators": [],
      "arguments": [
        "self",
        "operation_id"
      ],
      "imports": [
        "inspect",
        "logging",
        "typing",
        "inflection.camelize",
        "connexion.utils",
        "connexion.exceptions.ResolverError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.resolve_method_from_class",
          "body": "def resolve_method_from_class(self, view_name, meth_name, view_cls):\n    \"\"\"\n        Returns the view function for the given view class.\n        \"\"\"\n    raise NotImplementedError()"
        }
      ]
    },
    {
      "name": "resolve_method_from_class",
      "module": "resolver",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\resolver.py",
      "line_number": 279,
      "end_line_number": 283,
      "source_code": "def resolve_method_from_class(self, view_name, meth_name, view_cls):\n        \"\"\"\n        Returns the view function for the given view class.\n        \"\"\"\n        raise NotImplementedError()",
      "docstring": "Returns the view function for the given view class.",
      "decorators": [],
      "arguments": [
        "self",
        "view_name",
        "meth_name",
        "view_cls"
      ],
      "imports": [
        "inspect",
        "logging",
        "typing",
        "inflection.camelize",
        "connexion.utils",
        "connexion.exceptions.ResolverError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "resolve_method_from_class",
      "module": "resolver",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\resolver.py",
      "line_number": 292,
      "end_line_number": 309,
      "source_code": "def resolve_method_from_class(self, view_name, meth_name, view_cls):\n        view = None\n        for v in self.initialized_views:\n            if v.__class__ == view_cls:\n                view = v\n                break\n        if view is None:\n            # get the args and kwargs for this view\n            cls_arguments = self.class_arguments.get(view_name, {})\n            cls_args = cls_arguments.get(\"args\", ())\n            cls_kwargs = cls_arguments.get(\"kwargs\", {})\n            # instantiate the class with the args and kwargs\n            view = view_cls(*cls_args, **cls_kwargs)\n            self.initialized_views.append(view)\n        # get the method if the class\n        func = getattr(view, meth_name)\n        # Return the method function of the class\n        return func",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "view_name",
        "meth_name",
        "view_cls"
      ],
      "imports": [
        "inspect",
        "logging",
        "typing",
        "inflection.camelize",
        "connexion.utils",
        "connexion.exceptions.ResolverError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.class_arguments.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "cls_arguments.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "cls_arguments.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "__init__",
      "module": "resolver",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\resolver.py",
      "line_number": 318,
      "end_line_number": 326,
      "source_code": "def __init__(self, *args, **kwargs):\n        if \"collection_endpoint_name\" in kwargs:\n            del kwargs[\"collection_endpoint_name\"]\n            # Dispatch of request is done by Flask\n            logger.warning(\n                \"collection_endpoint_name is ignored by the MethodViewResolver. \"\n                \"Requests to a collection endpoint will be routed to .get()\"\n            )\n        super().__init__(*args, **kwargs)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "inspect",
        "logging",
        "typing",
        "inflection.camelize",
        "connexion.utils",
        "connexion.exceptions.ResolverError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "resolve_method_from_class",
      "module": "resolver",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\resolver.py",
      "line_number": 328,
      "end_line_number": 352,
      "source_code": "def resolve_method_from_class(self, view_name, meth_name, view_cls):\n        view = None\n        for v in self.initialized_views:\n            # views returned by <class>.as_view\n            # have the origin class attached as .view_class\n            if v.view_class == view_cls:\n                view = v\n                break\n        if view is None:\n            # get the args and kwargs for this view\n            cls_arguments = self.class_arguments.get(view_name, {})\n            cls_args = cls_arguments.get(\"args\", ())\n            cls_kwargs = cls_arguments.get(\"kwargs\", {})\n            # call as_view to get a view function\n            # that is decorated with the classes\n            # decorator list, if any\n            view = view_cls.as_view(view_name, *cls_args, **cls_kwargs)\n            # add the view to the list of initialized views\n            # in order to call as_view only once\n            self.initialized_views.append(view)\n        # return the class as view function\n        # for each operation so that requests\n        # are dispatched with <class>.dispatch_request,\n        # when calling the view function\n        return view",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "view_name",
        "meth_name",
        "view_cls"
      ],
      "imports": [
        "inspect",
        "logging",
        "typing",
        "inflection.camelize",
        "connexion.utils",
        "connexion.exceptions.ResolverError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.class_arguments.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "cls_arguments.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "cls_arguments.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "is_var",
      "module": "resolver",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\resolver.py",
      "line_number": 149,
      "end_line_number": 151,
      "source_code": "def is_var(component):\n            \"\"\"True if the path component is a var. eg, '{id}'\"\"\"\n            return (component[0] == \"{\") and (component[-1] == \"}\")",
      "docstring": "True if the path component is a var. eg, '{id}'",
      "decorators": [],
      "arguments": [
        "component"
      ],
      "imports": [
        "inspect",
        "logging",
        "typing",
        "inflection.camelize",
        "connexion.utils",
        "connexion.exceptions.ResolverError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "get_controller_name",
      "module": "resolver",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\resolver.py",
      "line_number": 157,
      "end_line_number": 168,
      "source_code": "def get_controller_name():\n            x_router_controller = operation.router_controller\n\n            name = self.default_module_name\n\n            if x_router_controller:\n                name = x_router_controller\n\n            elif resource_name:\n                name += \".\" + resource_name\n\n            return name",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "inspect",
        "logging",
        "typing",
        "inflection.camelize",
        "connexion.utils",
        "connexion.exceptions.ResolverError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "get_function_name",
      "module": "resolver",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\resolver.py",
      "line_number": 170,
      "end_line_number": 183,
      "source_code": "def get_function_name():\n            method = operation.method\n\n            is_collection_endpoint = (\n                method.lower() == \"get\"\n                and len(resource_name)\n                and not is_var(path_components[-1])\n            )\n\n            return (\n                self.collection_endpoint_name\n                if is_collection_endpoint\n                else method.lower()\n            )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "inspect",
        "logging",
        "typing",
        "inflection.camelize",
        "connexion.utils",
        "connexion.exceptions.ResolverError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "is_var",
          "body": "def is_var(component):\n    \"\"\"True if the path component is a var. eg, '{id}'\"\"\"\n    return component[0] == '{' and component[-1] == '}'"
        }
      ]
    },
    {
      "name": "get_fn",
      "module": "security",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\security.py",
      "line_number": 77,
      "end_line_number": 84,
      "source_code": "def get_fn(self, security_scheme, required_scopes):\n        \"\"\"Returns the handler function\"\"\"\n        security_func = self._resolve_func(security_scheme)\n        if not security_func:\n            logger.warning(\"... %s missing\", self.security_definition_key)\n            return None\n\n        return self._get_verify_func(security_func)",
      "docstring": "Returns the handler function",
      "decorators": [],
      "arguments": [
        "self",
        "security_scheme",
        "required_scopes"
      ],
      "imports": [
        "asyncio",
        "base64",
        "http.cookies",
        "logging",
        "os",
        "typing",
        "httpx",
        "connexion.decorators.parameter.inspect_function_arguments",
        "connexion.exceptions.OAuthProblem",
        "connexion.exceptions.OAuthResponseProblem",
        "connexion.exceptions.OAuthScopeProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.get_function_from_name"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._resolve_func",
          "body": "def _resolve_func(self, security_scheme):\n    \"\"\"\n        Get the user function object based on the security scheme or the environment variable.\n\n        :param security_scheme: Security Definition (scheme) from the spec.\n        \"\"\"\n    return self._get_function(security_scheme, self.security_definition_key, self.environ_key)"
        },
        {
          "name": "self._get_verify_func",
          "body": "def _get_verify_func(self, function):\n    \"\"\"\n        Wraps the user security function in a function that checks the request for the correct\n        security credentials and calls the user function with the correct arguments.\n        \"\"\"\n    return self._generic_check(function, 'Provided authorization is not valid')"
        }
      ]
    },
    {
      "name": "_get_function",
      "module": "security",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\security.py",
      "line_number": 87,
      "end_line_number": 107,
      "source_code": "def _get_function(\n        cls,\n        security_definition: dict,\n        security_definition_key: str,\n        environ_key: str,\n        default: t.Optional[t.Callable] = None,\n    ):\n        \"\"\"\n        Return function by getting its name from security_definition or environment variable\n\n        :param security_definition: Security Definition (scheme) from the spec.\n        :param security_definition_key: The key which contains the value for the function name to resolve.\n        :param environ_key: The name of the environment variable that can be used alternatively for the function name.\n        :param default: The default to use in case the function cannot be found based on the security_definition_key or the environ_key\n        \"\"\"\n        func_name = security_definition.get(security_definition_key) or os.environ.get(\n            environ_key\n        )\n        if func_name:\n            return get_function_from_name(func_name)\n        return default",
      "docstring": "Return function by getting its name from security_definition or environment variable\n\n:param security_definition: Security Definition (scheme) from the spec.\n:param security_definition_key: The key which contains the value for the function name to resolve.\n:param environ_key: The name of the environment variable that can be used alternatively for the function name.\n:param default: The default to use in case the function cannot be found based on the security_definition_key or the environ_key",
      "decorators": [
        "classmethod"
      ],
      "arguments": [
        "cls",
        "security_definition",
        "security_definition_key",
        "environ_key",
        "default"
      ],
      "imports": [
        "asyncio",
        "base64",
        "http.cookies",
        "logging",
        "os",
        "typing",
        "httpx",
        "connexion.decorators.parameter.inspect_function_arguments",
        "connexion.exceptions.OAuthProblem",
        "connexion.exceptions.OAuthResponseProblem",
        "connexion.exceptions.OAuthScopeProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.get_function_from_name"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "security_definition.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "get_function_from_name",
          "body": "def get_function_from_name(function_name):\n    \"\"\"\n    Tries to get function by fully qualified name (e.g. \"mymodule.myobj.myfunc\")\n\n    :type function_name: str\n    \"\"\"\n    if function_name is None:\n        raise ValueError('Empty function name')\n    if '.' in function_name:\n        module_name, attr_path = function_name.rsplit('.', 1)\n    else:\n        module_name = ''\n        attr_path = function_name\n    module = None\n    last_import_error = None\n    while not module:\n        try:\n            module = importlib.import_module(module_name)\n        except ImportError as import_error:\n            last_import_error = import_error\n            if '.' in module_name:\n                module_name, attr_path1 = module_name.rsplit('.', 1)\n                attr_path = f'{attr_path1}.{attr_path}'\n            else:\n                raise\n    try:\n        function = deep_getattr(module, attr_path)\n    except AttributeError:\n        if last_import_error:\n            raise last_import_error\n        else:\n            raise\n    return function"
        }
      ]
    },
    {
      "name": "_generic_check",
      "module": "security",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\security.py",
      "line_number": 109,
      "end_line_number": 125,
      "source_code": "def _generic_check(self, func, exception_msg):\n        async def wrapper(request, *args, required_scopes=None):\n            kwargs = {}\n            if self._accepts_kwarg(func, self.required_scopes_kw):\n                kwargs[self.required_scopes_kw] = required_scopes\n            if self._accepts_kwarg(func, self.request_kw):\n                kwargs[self.request_kw] = request\n            token_info = func(*args, **kwargs)\n            while asyncio.iscoroutine(token_info):\n                token_info = await token_info\n            if token_info is NO_VALUE:\n                return NO_VALUE\n            if token_info is None:\n                raise OAuthResponseProblem(detail=exception_msg)\n            return token_info\n\n        return wrapper",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "func",
        "exception_msg"
      ],
      "imports": [
        "asyncio",
        "base64",
        "http.cookies",
        "logging",
        "os",
        "typing",
        "httpx",
        "connexion.decorators.parameter.inspect_function_arguments",
        "connexion.exceptions.OAuthProblem",
        "connexion.exceptions.OAuthResponseProblem",
        "connexion.exceptions.OAuthScopeProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.get_function_from_name"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._accepts_kwarg",
          "body": "@staticmethod\ndef _accepts_kwarg(func: t.Callable, keyword: str) -> bool:\n    \"\"\"Check if the function accepts the provided keyword argument.\"\"\"\n    arguments, has_kwargs = inspect_function_arguments(func)\n    return has_kwargs or keyword in arguments"
        },
        {
          "name": "self._accepts_kwarg",
          "body": "@staticmethod\ndef _accepts_kwarg(func: t.Callable, keyword: str) -> bool:\n    \"\"\"Check if the function accepts the provided keyword argument.\"\"\"\n    arguments, has_kwargs = inspect_function_arguments(func)\n    return has_kwargs or keyword in arguments"
        }
      ]
    },
    {
      "name": "get_auth_header_value",
      "module": "security",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\security.py",
      "line_number": 128,
      "end_line_number": 142,
      "source_code": "def get_auth_header_value(request):\n        \"\"\"\n        Return Authorization type and value if any.\n        If not Authorization, return (None, None)\n        Raise OAuthProblem for invalid Authorization header\n        \"\"\"\n        authorization = request.headers.get(\"Authorization\")\n        if not authorization:\n            return None, None\n\n        try:\n            auth_type, value = authorization.split(maxsplit=1)\n        except ValueError:\n            raise OAuthProblem(detail=\"Invalid authorization header\")\n        return auth_type.lower(), value",
      "docstring": "Return Authorization type and value if any.\nIf not Authorization, return (None, None)\nRaise OAuthProblem for invalid Authorization header",
      "decorators": [
        "staticmethod"
      ],
      "arguments": [
        "request"
      ],
      "imports": [
        "asyncio",
        "base64",
        "http.cookies",
        "logging",
        "os",
        "typing",
        "httpx",
        "connexion.decorators.parameter.inspect_function_arguments",
        "connexion.exceptions.OAuthProblem",
        "connexion.exceptions.OAuthResponseProblem",
        "connexion.exceptions.OAuthScopeProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.get_function_from_name"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "request.headers.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "_accepts_kwarg",
      "module": "security",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\security.py",
      "line_number": 145,
      "end_line_number": 148,
      "source_code": "def _accepts_kwarg(func: t.Callable, keyword: str) -> bool:\n        \"\"\"Check if the function accepts the provided keyword argument.\"\"\"\n        arguments, has_kwargs = inspect_function_arguments(func)\n        return has_kwargs or keyword in arguments",
      "docstring": "Check if the function accepts the provided keyword argument.",
      "decorators": [
        "staticmethod"
      ],
      "arguments": [
        "func",
        "keyword"
      ],
      "imports": [
        "asyncio",
        "base64",
        "http.cookies",
        "logging",
        "os",
        "typing",
        "httpx",
        "connexion.decorators.parameter.inspect_function_arguments",
        "connexion.exceptions.OAuthProblem",
        "connexion.exceptions.OAuthResponseProblem",
        "connexion.exceptions.OAuthScopeProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.get_function_from_name"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "inspect_function_arguments",
          "body": "def inspect_function_arguments(function: t.Callable) -> t.Tuple[t.List[str], bool]:\n    \"\"\"\n    Returns the list of variables names of a function and if it\n    accepts keyword arguments.\n    \"\"\"\n    parameters = inspect.signature(function).parameters\n    bound_arguments = [name for name, p in parameters.items() if p.kind not in (p.VAR_POSITIONAL, p.VAR_KEYWORD)]\n    has_kwargs = any((p.kind == p.VAR_KEYWORD for p in parameters.values()))\n    return (list(bound_arguments), has_kwargs)"
        }
      ]
    },
    {
      "name": "_resolve_func",
      "module": "security",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\security.py",
      "line_number": 150,
      "end_line_number": 158,
      "source_code": "def _resolve_func(self, security_scheme):\n        \"\"\"\n        Get the user function object based on the security scheme or the environment variable.\n\n        :param security_scheme: Security Definition (scheme) from the spec.\n        \"\"\"\n        return self._get_function(\n            security_scheme, self.security_definition_key, self.environ_key\n        )",
      "docstring": "Get the user function object based on the security scheme or the environment variable.\n\n:param security_scheme: Security Definition (scheme) from the spec.",
      "decorators": [],
      "arguments": [
        "self",
        "security_scheme"
      ],
      "imports": [
        "asyncio",
        "base64",
        "http.cookies",
        "logging",
        "os",
        "typing",
        "httpx",
        "connexion.decorators.parameter.inspect_function_arguments",
        "connexion.exceptions.OAuthProblem",
        "connexion.exceptions.OAuthResponseProblem",
        "connexion.exceptions.OAuthScopeProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.get_function_from_name"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._get_function",
          "body": "@classmethod\ndef _get_function(cls, security_definition: dict, security_definition_key: str, environ_key: str, default: t.Optional[t.Callable]=None):\n    \"\"\"\n        Return function by getting its name from security_definition or environment variable\n\n        :param security_definition: Security Definition (scheme) from the spec.\n        :param security_definition_key: The key which contains the value for the function name to resolve.\n        :param environ_key: The name of the environment variable that can be used alternatively for the function name.\n        :param default: The default to use in case the function cannot be found based on the security_definition_key or the environ_key\n        \"\"\"\n    func_name = security_definition.get(security_definition_key) or os.environ.get(environ_key)\n    if func_name:\n        return get_function_from_name(func_name)\n    return default"
        }
      ]
    },
    {
      "name": "_get_verify_func",
      "module": "security",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\security.py",
      "line_number": 160,
      "end_line_number": 165,
      "source_code": "def _get_verify_func(self, function):\n        \"\"\"\n        Wraps the user security function in a function that checks the request for the correct\n        security credentials and calls the user function with the correct arguments.\n        \"\"\"\n        return self._generic_check(function, \"Provided authorization is not valid\")",
      "docstring": "Wraps the user security function in a function that checks the request for the correct\nsecurity credentials and calls the user function with the correct arguments.",
      "decorators": [],
      "arguments": [
        "self",
        "function"
      ],
      "imports": [
        "asyncio",
        "base64",
        "http.cookies",
        "logging",
        "os",
        "typing",
        "httpx",
        "connexion.decorators.parameter.inspect_function_arguments",
        "connexion.exceptions.OAuthProblem",
        "connexion.exceptions.OAuthResponseProblem",
        "connexion.exceptions.OAuthScopeProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.get_function_from_name"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._generic_check",
          "body": "def _generic_check(self, func, exception_msg):\n\n    async def wrapper(request, *args, required_scopes=None):\n        kwargs = {}\n        if self._accepts_kwarg(func, self.required_scopes_kw):\n            kwargs[self.required_scopes_kw] = required_scopes\n        if self._accepts_kwarg(func, self.request_kw):\n            kwargs[self.request_kw] = request\n        token_info = func(*args, **kwargs)\n        while asyncio.iscoroutine(token_info):\n            token_info = await token_info\n        if token_info is NO_VALUE:\n            return NO_VALUE\n        if token_info is None:\n            raise OAuthResponseProblem(detail=exception_msg)\n        return token_info\n    return wrapper"
        }
      ]
    },
    {
      "name": "_get_verify_func",
      "module": "security",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\security.py",
      "line_number": 178,
      "end_line_number": 195,
      "source_code": "def _get_verify_func(self, basic_info_func):\n        check_basic_info_func = self.check_basic_auth(basic_info_func)\n\n        def wrapper(request):\n            auth_type, user_pass = self.get_auth_header_value(request)\n            if auth_type != \"basic\":\n                return NO_VALUE\n\n            try:\n                username, password = (\n                    base64.b64decode(user_pass).decode(\"latin1\").split(\":\", 1)\n                )\n            except Exception:\n                raise OAuthProblem(detail=\"Invalid authorization header\")\n\n            return check_basic_info_func(request, username, password)\n\n        return wrapper",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "basic_info_func"
      ],
      "imports": [
        "asyncio",
        "base64",
        "http.cookies",
        "logging",
        "os",
        "typing",
        "httpx",
        "connexion.decorators.parameter.inspect_function_arguments",
        "connexion.exceptions.OAuthProblem",
        "connexion.exceptions.OAuthResponseProblem",
        "connexion.exceptions.OAuthScopeProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.get_function_from_name"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.check_basic_auth",
          "body": "def check_basic_auth(self, basic_info_func):\n    return self._generic_check(basic_info_func, 'Provided authorization is not valid')"
        },
        {
          "name": "self.get_auth_header_value",
          "body": "@staticmethod\ndef get_auth_header_value(request):\n    \"\"\"\n        Return Authorization type and value if any.\n        If not Authorization, return (None, None)\n        Raise OAuthProblem for invalid Authorization header\n        \"\"\"\n    authorization = request.headers.get('Authorization')\n    if not authorization:\n        return (None, None)\n    try:\n        auth_type, value = authorization.split(maxsplit=1)\n    except ValueError:\n        raise OAuthProblem(detail='Invalid authorization header')\n    return (auth_type.lower(), value)"
        }
      ]
    },
    {
      "name": "check_basic_auth",
      "module": "security",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\security.py",
      "line_number": 197,
      "end_line_number": 200,
      "source_code": "def check_basic_auth(self, basic_info_func):\n        return self._generic_check(\n            basic_info_func, \"Provided authorization is not valid\"\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "basic_info_func"
      ],
      "imports": [
        "asyncio",
        "base64",
        "http.cookies",
        "logging",
        "os",
        "typing",
        "httpx",
        "connexion.decorators.parameter.inspect_function_arguments",
        "connexion.exceptions.OAuthProblem",
        "connexion.exceptions.OAuthResponseProblem",
        "connexion.exceptions.OAuthScopeProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.get_function_from_name"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._generic_check",
          "body": "def _generic_check(self, func, exception_msg):\n\n    async def wrapper(request, *args, required_scopes=None):\n        kwargs = {}\n        if self._accepts_kwarg(func, self.required_scopes_kw):\n            kwargs[self.required_scopes_kw] = required_scopes\n        if self._accepts_kwarg(func, self.request_kw):\n            kwargs[self.request_kw] = request\n        token_info = func(*args, **kwargs)\n        while asyncio.iscoroutine(token_info):\n            token_info = await token_info\n        if token_info is NO_VALUE:\n            return NO_VALUE\n        if token_info is None:\n            raise OAuthResponseProblem(detail=exception_msg)\n        return token_info\n    return wrapper"
        }
      ]
    },
    {
      "name": "check_bearer_token",
      "module": "security",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\security.py",
      "line_number": 211,
      "end_line_number": 212,
      "source_code": "def check_bearer_token(self, token_info_func):\n        return self._generic_check(token_info_func, \"Provided token is not valid\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "token_info_func"
      ],
      "imports": [
        "asyncio",
        "base64",
        "http.cookies",
        "logging",
        "os",
        "typing",
        "httpx",
        "connexion.decorators.parameter.inspect_function_arguments",
        "connexion.exceptions.OAuthProblem",
        "connexion.exceptions.OAuthResponseProblem",
        "connexion.exceptions.OAuthScopeProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.get_function_from_name"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._generic_check",
          "body": "def _generic_check(self, func, exception_msg):\n\n    async def wrapper(request, *args, required_scopes=None):\n        kwargs = {}\n        if self._accepts_kwarg(func, self.required_scopes_kw):\n            kwargs[self.required_scopes_kw] = required_scopes\n        if self._accepts_kwarg(func, self.request_kw):\n            kwargs[self.request_kw] = request\n        token_info = func(*args, **kwargs)\n        while asyncio.iscoroutine(token_info):\n            token_info = await token_info\n        if token_info is NO_VALUE:\n            return NO_VALUE\n        if token_info is None:\n            raise OAuthResponseProblem(detail=exception_msg)\n        return token_info\n    return wrapper"
        }
      ]
    },
    {
      "name": "_get_verify_func",
      "module": "security",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\security.py",
      "line_number": 214,
      "end_line_number": 227,
      "source_code": "def _get_verify_func(self, token_info_func):\n        \"\"\"\n        :param token_info_func: types.FunctionType\n        :rtype: types.FunctionType\n        \"\"\"\n        check_bearer_func = self.check_bearer_token(token_info_func)\n\n        def wrapper(request):\n            auth_type, token = self.get_auth_header_value(request)\n            if auth_type != \"bearer\":\n                return NO_VALUE\n            return check_bearer_func(request, token)\n\n        return wrapper",
      "docstring": ":param token_info_func: types.FunctionType\n:rtype: types.FunctionType",
      "decorators": [],
      "arguments": [
        "self",
        "token_info_func"
      ],
      "imports": [
        "asyncio",
        "base64",
        "http.cookies",
        "logging",
        "os",
        "typing",
        "httpx",
        "connexion.decorators.parameter.inspect_function_arguments",
        "connexion.exceptions.OAuthProblem",
        "connexion.exceptions.OAuthResponseProblem",
        "connexion.exceptions.OAuthScopeProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.get_function_from_name"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.check_bearer_token",
          "body": "def check_bearer_token(self, token_info_func):\n    return self._generic_check(token_info_func, 'Provided token is not valid')"
        },
        {
          "name": "self.get_auth_header_value",
          "body": "@staticmethod\ndef get_auth_header_value(request):\n    \"\"\"\n        Return Authorization type and value if any.\n        If not Authorization, return (None, None)\n        Raise OAuthProblem for invalid Authorization header\n        \"\"\"\n    authorization = request.headers.get('Authorization')\n    if not authorization:\n        return (None, None)\n    try:\n        auth_type, value = authorization.split(maxsplit=1)\n    except ValueError:\n        raise OAuthProblem(detail='Invalid authorization header')\n    return (auth_type.lower(), value)"
        }
      ]
    },
    {
      "name": "get_fn",
      "module": "security",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\security.py",
      "line_number": 238,
      "end_line_number": 249,
      "source_code": "def get_fn(self, security_scheme, required_scopes):\n        apikey_info_func = self._resolve_func(security_scheme)\n        if not apikey_info_func:\n            logger.warning(\"... %s missing\", self.security_definition_key)\n            return None\n\n        return self._get_verify_func(\n            apikey_info_func,\n            security_scheme[\"in\"],\n            security_scheme[\"name\"],\n            required_scopes,\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "security_scheme",
        "required_scopes"
      ],
      "imports": [
        "asyncio",
        "base64",
        "http.cookies",
        "logging",
        "os",
        "typing",
        "httpx",
        "connexion.decorators.parameter.inspect_function_arguments",
        "connexion.exceptions.OAuthProblem",
        "connexion.exceptions.OAuthResponseProblem",
        "connexion.exceptions.OAuthScopeProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.get_function_from_name"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._resolve_func",
          "body": "def _resolve_func(self, security_scheme):\n    \"\"\"\n        Get the user function object based on the security scheme or the environment variable.\n\n        :param security_scheme: Security Definition (scheme) from the spec.\n        \"\"\"\n    return self._get_function(security_scheme, self.security_definition_key, self.environ_key)"
        },
        {
          "name": "self._get_verify_func",
          "body": "def _get_verify_func(self, function):\n    \"\"\"\n        Wraps the user security function in a function that checks the request for the correct\n        security credentials and calls the user function with the correct arguments.\n        \"\"\"\n    return self._generic_check(function, 'Provided authorization is not valid')"
        }
      ]
    },
    {
      "name": "_get_verify_func",
      "module": "security",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\security.py",
      "line_number": 251,
      "end_line_number": 270,
      "source_code": "def _get_verify_func(self, api_key_info_func, loc, name, required_scopes):\n        check_api_key_func = self.check_api_key(api_key_info_func)\n\n        def wrapper(request: ConnexionRequest):\n            if loc == \"query\":\n                api_key = request.query_params.get(name)\n            elif loc == \"header\":\n                api_key = request.headers.get(name)\n            elif loc == \"cookie\":\n                cookie_list = request.headers.get(\"Cookie\")\n                api_key = self.get_cookie_value(cookie_list, name)\n            else:\n                return NO_VALUE\n\n            if api_key is None:\n                return NO_VALUE\n\n            return check_api_key_func(request, api_key, required_scopes=required_scopes)\n\n        return wrapper",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "api_key_info_func",
        "loc",
        "name",
        "required_scopes"
      ],
      "imports": [
        "asyncio",
        "base64",
        "http.cookies",
        "logging",
        "os",
        "typing",
        "httpx",
        "connexion.decorators.parameter.inspect_function_arguments",
        "connexion.exceptions.OAuthProblem",
        "connexion.exceptions.OAuthResponseProblem",
        "connexion.exceptions.OAuthScopeProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.get_function_from_name"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.check_api_key",
          "body": "def check_api_key(self, api_key_info_func):\n    return self._generic_check(api_key_info_func, 'Provided apikey is not valid')"
        },
        {
          "name": "request.query_params.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "request.headers.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "request.headers.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "self.get_cookie_value",
          "body": "@staticmethod\ndef get_cookie_value(cookies, name):\n    \"\"\"\n        Returns cookie value by its name. `None` if no such value.\n\n        :param cookies: str: cookies raw data\n        :param name: str: cookies key\n        \"\"\"\n    cookie_parser = http.cookies.SimpleCookie()\n    cookie_parser.load(str(cookies))\n    try:\n        return cookie_parser[name].value\n    except KeyError:\n        return None"
        }
      ]
    },
    {
      "name": "check_api_key",
      "module": "security",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\security.py",
      "line_number": 272,
      "end_line_number": 273,
      "source_code": "def check_api_key(self, api_key_info_func):\n        return self._generic_check(api_key_info_func, \"Provided apikey is not valid\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "api_key_info_func"
      ],
      "imports": [
        "asyncio",
        "base64",
        "http.cookies",
        "logging",
        "os",
        "typing",
        "httpx",
        "connexion.decorators.parameter.inspect_function_arguments",
        "connexion.exceptions.OAuthProblem",
        "connexion.exceptions.OAuthResponseProblem",
        "connexion.exceptions.OAuthScopeProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.get_function_from_name"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._generic_check",
          "body": "def _generic_check(self, func, exception_msg):\n\n    async def wrapper(request, *args, required_scopes=None):\n        kwargs = {}\n        if self._accepts_kwarg(func, self.required_scopes_kw):\n            kwargs[self.required_scopes_kw] = required_scopes\n        if self._accepts_kwarg(func, self.request_kw):\n            kwargs[self.request_kw] = request\n        token_info = func(*args, **kwargs)\n        while asyncio.iscoroutine(token_info):\n            token_info = await token_info\n        if token_info is NO_VALUE:\n            return NO_VALUE\n        if token_info is None:\n            raise OAuthResponseProblem(detail=exception_msg)\n        return token_info\n    return wrapper"
        }
      ]
    },
    {
      "name": "get_cookie_value",
      "module": "security",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\security.py",
      "line_number": 276,
      "end_line_number": 288,
      "source_code": "def get_cookie_value(cookies, name):\n        \"\"\"\n        Returns cookie value by its name. `None` if no such value.\n\n        :param cookies: str: cookies raw data\n        :param name: str: cookies key\n        \"\"\"\n        cookie_parser = http.cookies.SimpleCookie()\n        cookie_parser.load(str(cookies))\n        try:\n            return cookie_parser[name].value\n        except KeyError:\n            return None",
      "docstring": "Returns cookie value by its name. `None` if no such value.\n\n:param cookies: str: cookies raw data\n:param name: str: cookies key",
      "decorators": [
        "staticmethod"
      ],
      "arguments": [
        "cookies",
        "name"
      ],
      "imports": [
        "asyncio",
        "base64",
        "http.cookies",
        "logging",
        "os",
        "typing",
        "httpx",
        "connexion.decorators.parameter.inspect_function_arguments",
        "connexion.exceptions.OAuthProblem",
        "connexion.exceptions.OAuthResponseProblem",
        "connexion.exceptions.OAuthScopeProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.get_function_from_name"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "cookie_parser.load",
          "body": "@classmethod\ndef load(cls, spec, *, arguments=None):\n    if isinstance(spec, str) and (spec.startswith('http://') or spec.startswith('https://')):\n        return cls.from_url(spec)\n    if not isinstance(spec, dict):\n        base_uri = f'{pathlib.Path(spec).parent}{os.sep}'\n        return cls.from_file(spec, arguments=arguments, base_uri=base_uri)\n    return cls.from_dict(spec)"
        }
      ]
    },
    {
      "name": "get_fn",
      "module": "security",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\security.py",
      "line_number": 296,
      "end_line_number": 305,
      "source_code": "def get_fn(self, security_scheme, required_scopes):\n        token_info_func = self.get_tokeninfo_func(security_scheme)\n        scope_validate_func = self.get_scope_validate_func(security_scheme)\n        if not token_info_func:\n            logger.warning(\"... x-tokenInfoFunc missing\")\n            return None\n\n        return self._get_verify_func(\n            token_info_func, scope_validate_func, required_scopes\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "security_scheme",
        "required_scopes"
      ],
      "imports": [
        "asyncio",
        "base64",
        "http.cookies",
        "logging",
        "os",
        "typing",
        "httpx",
        "connexion.decorators.parameter.inspect_function_arguments",
        "connexion.exceptions.OAuthProblem",
        "connexion.exceptions.OAuthResponseProblem",
        "connexion.exceptions.OAuthScopeProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.get_function_from_name"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.get_tokeninfo_func",
          "body": "def get_tokeninfo_func(self, security_definition: dict) -> t.Optional[t.Callable]:\n    \"\"\"\n        Gets the function for retrieving the token info.\n        It is possible to specify a function or a URL. The function variant is\n        preferred. If it is not found, the URL variant is used with the\n        `get_token_info_remote` function.\n\n        >>> get_tokeninfo_func({'x-tokenInfoFunc': 'foo.bar'})\n        '<function foo.bar>'\n        \"\"\"\n    token_info_func = self._get_function(security_definition, 'x-tokenInfoFunc', 'TOKENINFO_FUNC')\n    if token_info_func:\n        return token_info_func\n    token_info_url = security_definition.get('x-tokenInfoUrl') or os.environ.get('TOKENINFO_URL')\n    if token_info_url:\n        return self.get_token_info_remote(token_info_url)\n    return None"
        },
        {
          "name": "self.get_scope_validate_func",
          "body": "@classmethod\ndef get_scope_validate_func(cls, security_definition):\n    \"\"\"\n        Gets the function for validating the token scopes.\n        If it is not found, the default `validate_scope` function is used.\n\n        >>> get_scope_validate_func({'x-scopeValidateFunc': 'foo.bar'})\n        '<function foo.bar>'\n        \"\"\"\n    return cls._get_function(security_definition, 'x-scopeValidateFunc', 'SCOPEVALIDATE_FUNC', cls.validate_scope)"
        },
        {
          "name": "self._get_verify_func",
          "body": "def _get_verify_func(self, function):\n    \"\"\"\n        Wraps the user security function in a function that checks the request for the correct\n        security credentials and calls the user function with the correct arguments.\n        \"\"\"\n    return self._generic_check(function, 'Provided authorization is not valid')"
        }
      ]
    },
    {
      "name": "get_tokeninfo_func",
      "module": "security",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\security.py",
      "line_number": 307,
      "end_line_number": 329,
      "source_code": "def get_tokeninfo_func(self, security_definition: dict) -> t.Optional[t.Callable]:\n        \"\"\"\n        Gets the function for retrieving the token info.\n        It is possible to specify a function or a URL. The function variant is\n        preferred. If it is not found, the URL variant is used with the\n        `get_token_info_remote` function.\n\n        >>> get_tokeninfo_func({'x-tokenInfoFunc': 'foo.bar'})\n        '<function foo.bar>'\n        \"\"\"\n        token_info_func = self._get_function(\n            security_definition, \"x-tokenInfoFunc\", \"TOKENINFO_FUNC\"\n        )\n        if token_info_func:\n            return token_info_func\n\n        token_info_url = security_definition.get(\"x-tokenInfoUrl\") or os.environ.get(\n            \"TOKENINFO_URL\"\n        )\n        if token_info_url:\n            return self.get_token_info_remote(token_info_url)\n\n        return None",
      "docstring": "Gets the function for retrieving the token info.\nIt is possible to specify a function or a URL. The function variant is\npreferred. If it is not found, the URL variant is used with the\n`get_token_info_remote` function.\n\n>>> get_tokeninfo_func({'x-tokenInfoFunc': 'foo.bar'})\n'<function foo.bar>'",
      "decorators": [],
      "arguments": [
        "self",
        "security_definition"
      ],
      "imports": [
        "asyncio",
        "base64",
        "http.cookies",
        "logging",
        "os",
        "typing",
        "httpx",
        "connexion.decorators.parameter.inspect_function_arguments",
        "connexion.exceptions.OAuthProblem",
        "connexion.exceptions.OAuthResponseProblem",
        "connexion.exceptions.OAuthScopeProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.get_function_from_name"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._get_function",
          "body": "@classmethod\ndef _get_function(cls, security_definition: dict, security_definition_key: str, environ_key: str, default: t.Optional[t.Callable]=None):\n    \"\"\"\n        Return function by getting its name from security_definition or environment variable\n\n        :param security_definition: Security Definition (scheme) from the spec.\n        :param security_definition_key: The key which contains the value for the function name to resolve.\n        :param environ_key: The name of the environment variable that can be used alternatively for the function name.\n        :param default: The default to use in case the function cannot be found based on the security_definition_key or the environ_key\n        \"\"\"\n    func_name = security_definition.get(security_definition_key) or os.environ.get(environ_key)\n    if func_name:\n        return get_function_from_name(func_name)\n    return default"
        },
        {
          "name": "security_definition.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "self.get_token_info_remote",
          "body": "def get_token_info_remote(self, token_info_url: str) -> t.Callable:\n    \"\"\"\n        Return a function which will call `token_info_url` to retrieve token info.\n\n        Returned function must accept oauth token in parameter.\n        It must return a token_info dict in case of success, None otherwise.\n\n        :param token_info_url: URL to get information about the token\n        \"\"\"\n\n    async def wrapper(token):\n        if self.client is None:\n            self.client = httpx.AsyncClient()\n        headers = {'Authorization': f'Bearer {token}'}\n        token_request = await self.client.get(token_info_url, headers=headers, timeout=5)\n        if token_request.status_code != 200:\n            return\n        return token_request.json()\n    return wrapper"
        }
      ]
    },
    {
      "name": "get_scope_validate_func",
      "module": "security",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\security.py",
      "line_number": 332,
      "end_line_number": 345,
      "source_code": "def get_scope_validate_func(cls, security_definition):\n        \"\"\"\n        Gets the function for validating the token scopes.\n        If it is not found, the default `validate_scope` function is used.\n\n        >>> get_scope_validate_func({'x-scopeValidateFunc': 'foo.bar'})\n        '<function foo.bar>'\n        \"\"\"\n        return cls._get_function(\n            security_definition,\n            \"x-scopeValidateFunc\",\n            \"SCOPEVALIDATE_FUNC\",\n            cls.validate_scope,\n        )",
      "docstring": "Gets the function for validating the token scopes.\nIf it is not found, the default `validate_scope` function is used.\n\n>>> get_scope_validate_func({'x-scopeValidateFunc': 'foo.bar'})\n'<function foo.bar>'",
      "decorators": [
        "classmethod"
      ],
      "arguments": [
        "cls",
        "security_definition"
      ],
      "imports": [
        "asyncio",
        "base64",
        "http.cookies",
        "logging",
        "os",
        "typing",
        "httpx",
        "connexion.decorators.parameter.inspect_function_arguments",
        "connexion.exceptions.OAuthProblem",
        "connexion.exceptions.OAuthResponseProblem",
        "connexion.exceptions.OAuthScopeProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.get_function_from_name"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "cls._get_function",
          "body": "@classmethod\ndef _get_function(cls, security_definition: dict, security_definition_key: str, environ_key: str, default: t.Optional[t.Callable]=None):\n    \"\"\"\n        Return function by getting its name from security_definition or environment variable\n\n        :param security_definition: Security Definition (scheme) from the spec.\n        :param security_definition_key: The key which contains the value for the function name to resolve.\n        :param environ_key: The name of the environment variable that can be used alternatively for the function name.\n        :param default: The default to use in case the function cannot be found based on the security_definition_key or the environ_key\n        \"\"\"\n    func_name = security_definition.get(security_definition_key) or os.environ.get(environ_key)\n    if func_name:\n        return get_function_from_name(func_name)\n    return default"
        }
      ]
    },
    {
      "name": "validate_scope",
      "module": "security",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\security.py",
      "line_number": 348,
      "end_line_number": 369,
      "source_code": "def validate_scope(required_scopes, token_scopes):\n        \"\"\"\n        :param required_scopes: Scopes required to access operation\n        :param token_scopes: Scopes granted by authorization server\n        :rtype: bool\n        \"\"\"\n        required_scopes = set(required_scopes)\n        if isinstance(token_scopes, list):\n            token_scopes = set(token_scopes)\n        else:\n            token_scopes = set(token_scopes.split())\n        logger.debug(\"... Scopes required: %s\", required_scopes)\n        logger.debug(\"... Token scopes: %s\", token_scopes)\n        if not required_scopes <= token_scopes:\n            logger.info(\n                \"... Token scopes (%s) do not match the scopes necessary to call endpoint (%s).\"\n                \" Aborting with 403.\",\n                token_scopes,\n                required_scopes,\n            )\n            return False\n        return True",
      "docstring": ":param required_scopes: Scopes required to access operation\n:param token_scopes: Scopes granted by authorization server\n:rtype: bool",
      "decorators": [
        "staticmethod"
      ],
      "arguments": [
        "required_scopes",
        "token_scopes"
      ],
      "imports": [
        "asyncio",
        "base64",
        "http.cookies",
        "logging",
        "os",
        "typing",
        "httpx",
        "connexion.decorators.parameter.inspect_function_arguments",
        "connexion.exceptions.OAuthProblem",
        "connexion.exceptions.OAuthResponseProblem",
        "connexion.exceptions.OAuthScopeProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.get_function_from_name"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "get_token_info_remote",
      "module": "security",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\security.py",
      "line_number": 371,
      "end_line_number": 392,
      "source_code": "def get_token_info_remote(self, token_info_url: str) -> t.Callable:\n        \"\"\"\n        Return a function which will call `token_info_url` to retrieve token info.\n\n        Returned function must accept oauth token in parameter.\n        It must return a token_info dict in case of success, None otherwise.\n\n        :param token_info_url: URL to get information about the token\n        \"\"\"\n\n        async def wrapper(token):\n            if self.client is None:\n                self.client = httpx.AsyncClient()\n            headers = {\"Authorization\": f\"Bearer {token}\"}\n            token_request = await self.client.get(\n                token_info_url, headers=headers, timeout=5\n            )\n            if token_request.status_code != 200:\n                return\n            return token_request.json()\n\n        return wrapper",
      "docstring": "Return a function which will call `token_info_url` to retrieve token info.\n\nReturned function must accept oauth token in parameter.\nIt must return a token_info dict in case of success, None otherwise.\n\n:param token_info_url: URL to get information about the token",
      "decorators": [],
      "arguments": [
        "self",
        "token_info_url"
      ],
      "imports": [
        "asyncio",
        "base64",
        "http.cookies",
        "logging",
        "os",
        "typing",
        "httpx",
        "connexion.decorators.parameter.inspect_function_arguments",
        "connexion.exceptions.OAuthProblem",
        "connexion.exceptions.OAuthResponseProblem",
        "connexion.exceptions.OAuthScopeProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.get_function_from_name"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "token_request.json",
          "body": "def json(self) -> dict:\n    \"\"\"Json data included in the request.\"\"\"\n    raise NotImplementedError"
        },
        {
          "name": "self.client.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "_get_verify_func",
      "module": "security",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\security.py",
      "line_number": 394,
      "end_line_number": 404,
      "source_code": "def _get_verify_func(self, token_info_func, scope_validate_func, required_scopes):\n        check_oauth_func = self.check_oauth_func(token_info_func, scope_validate_func)\n\n        def wrapper(request):\n            auth_type, token = self.get_auth_header_value(request)\n            if auth_type != \"bearer\":\n                return NO_VALUE\n\n            return check_oauth_func(request, token, required_scopes=required_scopes)\n\n        return wrapper",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "token_info_func",
        "scope_validate_func",
        "required_scopes"
      ],
      "imports": [
        "asyncio",
        "base64",
        "http.cookies",
        "logging",
        "os",
        "typing",
        "httpx",
        "connexion.decorators.parameter.inspect_function_arguments",
        "connexion.exceptions.OAuthProblem",
        "connexion.exceptions.OAuthResponseProblem",
        "connexion.exceptions.OAuthScopeProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.get_function_from_name"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.check_oauth_func",
          "body": "def check_oauth_func(self, token_info_func, scope_validate_func):\n    get_token_info = self._generic_check(token_info_func, 'Provided token is not valid')\n\n    async def wrapper(request, token, required_scopes):\n        token_info = await get_token_info(request, token, required_scopes=required_scopes)\n        token_scopes = token_info.get('scope', token_info.get('scopes', ''))\n        validation = scope_validate_func(required_scopes, token_scopes)\n        while asyncio.iscoroutine(validation):\n            validation = await validation\n        if not validation:\n            raise OAuthScopeProblem(required_scopes=required_scopes, token_scopes=token_scopes)\n        return token_info\n    return wrapper"
        },
        {
          "name": "self.get_auth_header_value",
          "body": "@staticmethod\ndef get_auth_header_value(request):\n    \"\"\"\n        Return Authorization type and value if any.\n        If not Authorization, return (None, None)\n        Raise OAuthProblem for invalid Authorization header\n        \"\"\"\n    authorization = request.headers.get('Authorization')\n    if not authorization:\n        return (None, None)\n    try:\n        auth_type, value = authorization.split(maxsplit=1)\n    except ValueError:\n        raise OAuthProblem(detail='Invalid authorization header')\n    return (auth_type.lower(), value)"
        },
        {
          "name": "check_oauth_func",
          "body": "def check_oauth_func(self, token_info_func, scope_validate_func):\n    get_token_info = self._generic_check(token_info_func, 'Provided token is not valid')\n\n    async def wrapper(request, token, required_scopes):\n        token_info = await get_token_info(request, token, required_scopes=required_scopes)\n        token_scopes = token_info.get('scope', token_info.get('scopes', ''))\n        validation = scope_validate_func(required_scopes, token_scopes)\n        while asyncio.iscoroutine(validation):\n            validation = await validation\n        if not validation:\n            raise OAuthScopeProblem(required_scopes=required_scopes, token_scopes=token_scopes)\n        return token_info\n    return wrapper"
        }
      ]
    },
    {
      "name": "check_oauth_func",
      "module": "security",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\security.py",
      "line_number": 406,
      "end_line_number": 430,
      "source_code": "def check_oauth_func(self, token_info_func, scope_validate_func):\n        get_token_info = self._generic_check(\n            token_info_func, \"Provided token is not valid\"\n        )\n\n        async def wrapper(request, token, required_scopes):\n            token_info = await get_token_info(\n                request, token, required_scopes=required_scopes\n            )\n\n            # Fallback to 'scopes' for backward compatibility\n            token_scopes = token_info.get(\"scope\", token_info.get(\"scopes\", \"\"))\n\n            validation = scope_validate_func(required_scopes, token_scopes)\n            while asyncio.iscoroutine(validation):\n                validation = await validation\n            if not validation:\n                raise OAuthScopeProblem(\n                    required_scopes=required_scopes,\n                    token_scopes=token_scopes,\n                )\n\n            return token_info\n\n        return wrapper",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "token_info_func",
        "scope_validate_func"
      ],
      "imports": [
        "asyncio",
        "base64",
        "http.cookies",
        "logging",
        "os",
        "typing",
        "httpx",
        "connexion.decorators.parameter.inspect_function_arguments",
        "connexion.exceptions.OAuthProblem",
        "connexion.exceptions.OAuthResponseProblem",
        "connexion.exceptions.OAuthScopeProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.get_function_from_name"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._generic_check",
          "body": "def _generic_check(self, func, exception_msg):\n\n    async def wrapper(request, *args, required_scopes=None):\n        kwargs = {}\n        if self._accepts_kwarg(func, self.required_scopes_kw):\n            kwargs[self.required_scopes_kw] = required_scopes\n        if self._accepts_kwarg(func, self.request_kw):\n            kwargs[self.request_kw] = request\n        token_info = func(*args, **kwargs)\n        while asyncio.iscoroutine(token_info):\n            token_info = await token_info\n        if token_info is NO_VALUE:\n            return NO_VALUE\n        if token_info is None:\n            raise OAuthResponseProblem(detail=exception_msg)\n        return token_info\n    return wrapper"
        },
        {
          "name": "token_info.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "token_info.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "__init__",
      "module": "security",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\security.py",
      "line_number": 455,
      "end_line_number": 461,
      "source_code": "def __init__(\n        self,\n        security_handlers: t.Optional[dict] = None,\n    ) -> None:\n        self.security_handlers = SECURITY_HANDLERS.copy()\n        if security_handlers is not None:\n            self.security_handlers.update(security_handlers)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "security_handlers"
      ],
      "imports": [
        "asyncio",
        "base64",
        "http.cookies",
        "logging",
        "os",
        "typing",
        "httpx",
        "connexion.decorators.parameter.inspect_function_arguments",
        "connexion.exceptions.OAuthProblem",
        "connexion.exceptions.OAuthResponseProblem",
        "connexion.exceptions.OAuthScopeProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.get_function_from_name"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "parse_security_scheme",
      "module": "security",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\security.py",
      "line_number": 463,
      "end_line_number": 506,
      "source_code": "def parse_security_scheme(\n        self,\n        security_scheme: dict,\n        required_scopes: t.List[str],\n    ) -> t.Optional[t.Callable]:\n        \"\"\"Parses the security scheme and returns the function for verifying it.\n\n        :param security_scheme: The security scheme from the spec.\n        :param required_scopes: List of scopes for this security scheme.\n        \"\"\"\n        security_type = security_scheme[\"type\"]\n        if security_type in (\"basic\", \"oauth2\"):\n            security_handler = self.security_handlers[security_type]\n            return security_handler().get_fn(security_scheme, required_scopes)\n\n        # OpenAPI 3.0.0\n        elif security_type == \"http\":\n            scheme = security_scheme[\"scheme\"].lower()\n            if scheme in self.security_handlers:\n                security_handler = self.security_handlers[scheme]\n                return security_handler().get_fn(security_scheme, required_scopes)\n            else:\n                logger.warning(\"... Unsupported http authorization scheme %s\", scheme)\n                return None\n\n        elif security_type == \"apiKey\":\n            scheme = security_scheme.get(\"x-authentication-scheme\", \"\").lower()\n            if scheme == \"bearer\":\n                return BearerSecurityHandler().get_fn(security_scheme, required_scopes)\n            else:\n                security_handler = self.security_handlers[\"apiKey\"]\n                return security_handler().get_fn(security_scheme, required_scopes)\n\n        # Custom security handler\n        elif (scheme := security_scheme[\"scheme\"].lower()) in self.security_handlers:\n            security_handler = self.security_handlers[scheme]\n            return security_handler().get_fn(security_scheme, required_scopes)\n\n        else:\n            logger.warning(\n                \"... Unsupported security scheme type %s\",\n                security_type,\n            )\n            return None",
      "docstring": "Parses the security scheme and returns the function for verifying it.\n\n:param security_scheme: The security scheme from the spec.\n:param required_scopes: List of scopes for this security scheme.",
      "decorators": [],
      "arguments": [
        "self",
        "security_scheme",
        "required_scopes"
      ],
      "imports": [
        "asyncio",
        "base64",
        "http.cookies",
        "logging",
        "os",
        "typing",
        "httpx",
        "connexion.decorators.parameter.inspect_function_arguments",
        "connexion.exceptions.OAuthProblem",
        "connexion.exceptions.OAuthResponseProblem",
        "connexion.exceptions.OAuthScopeProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.get_function_from_name"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "security_scheme.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "verify_none",
      "module": "security",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\security.py",
      "line_number": 524,
      "end_line_number": 535,
      "source_code": "def verify_none(request):\n        \"\"\"Used for optional security.\n\n        Equivalent OpenAPI snippet:\n\n        .. code-block:: yaml\n\n            security:\n              - {}  # <--\n              - myapikey: []\n        \"\"\"\n        return {}",
      "docstring": "Used for optional security.\n\nEquivalent OpenAPI snippet:\n\n.. code-block:: yaml\n\n    security:\n      - {}  # <--\n      - myapikey: []",
      "decorators": [
        "staticmethod"
      ],
      "arguments": [
        "request"
      ],
      "imports": [
        "asyncio",
        "base64",
        "http.cookies",
        "logging",
        "os",
        "typing",
        "httpx",
        "connexion.decorators.parameter.inspect_function_arguments",
        "connexion.exceptions.OAuthProblem",
        "connexion.exceptions.OAuthResponseProblem",
        "connexion.exceptions.OAuthScopeProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.get_function_from_name"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "verify_multiple_schemes",
      "module": "security",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\security.py",
      "line_number": 537,
      "end_line_number": 559,
      "source_code": "def verify_multiple_schemes(self, schemes):\n        \"\"\"\n        Verifies multiple authentication schemes in AND fashion.\n        If any scheme fails, the entire authentication fails.\n\n        :param schemes: mapping scheme_name to auth function\n        :type schemes: dict\n        :rtype: types.FunctionType\n        \"\"\"\n\n        async def wrapper(request):\n            token_info = {}\n            for scheme_name, func in schemes.items():\n                result = func(request)\n                while asyncio.iscoroutine(result):\n                    result = await result\n                if result is NO_VALUE:\n                    return NO_VALUE\n                token_info[scheme_name] = result\n\n            return token_info\n\n        return wrapper",
      "docstring": "Verifies multiple authentication schemes in AND fashion.\nIf any scheme fails, the entire authentication fails.\n\n:param schemes: mapping scheme_name to auth function\n:type schemes: dict\n:rtype: types.FunctionType",
      "decorators": [],
      "arguments": [
        "self",
        "schemes"
      ],
      "imports": [
        "asyncio",
        "base64",
        "http.cookies",
        "logging",
        "os",
        "typing",
        "httpx",
        "connexion.decorators.parameter.inspect_function_arguments",
        "connexion.exceptions.OAuthProblem",
        "connexion.exceptions.OAuthResponseProblem",
        "connexion.exceptions.OAuthScopeProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.get_function_from_name"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "verify_security",
      "module": "security",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\security.py",
      "line_number": 562,
      "end_line_number": 591,
      "source_code": "def verify_security(cls, auth_funcs):\n        async def verify_fn(request):\n            token_info = NO_VALUE\n            errors = []\n            for func in auth_funcs:\n                try:\n                    token_info = func(request)\n                    while asyncio.iscoroutine(token_info):\n                        token_info = await token_info\n                    if token_info is not NO_VALUE:\n                        break\n                except Exception as err:\n                    errors.append(err)\n\n            else:\n                if errors != []:\n                    cls._raise_most_specific(errors)\n                else:\n                    logger.info(\"... No auth provided. Aborting with 401.\")\n                    raise OAuthProblem(detail=\"No authorization token provided\")\n\n            request.context.update(\n                {\n                    # Fallback to 'uid' for backward compatibility\n                    \"user\": token_info.get(\"sub\", token_info.get(\"uid\")),\n                    \"token_info\": token_info,\n                }\n            )\n\n        return verify_fn",
      "docstring": null,
      "decorators": [
        "classmethod"
      ],
      "arguments": [
        "cls",
        "auth_funcs"
      ],
      "imports": [
        "asyncio",
        "base64",
        "http.cookies",
        "logging",
        "os",
        "typing",
        "httpx",
        "connexion.decorators.parameter.inspect_function_arguments",
        "connexion.exceptions.OAuthProblem",
        "connexion.exceptions.OAuthResponseProblem",
        "connexion.exceptions.OAuthScopeProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.get_function_from_name"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "cls._raise_most_specific",
          "body": "@staticmethod\ndef _raise_most_specific(exceptions: t.List[Exception]) -> None:\n    \"\"\"Raises the most specific error from a list of exceptions by status code.\n\n        The status codes are expected to be either in the `code`\n        or in the `status` attribute of the exceptions.\n\n        The order is as follows:\n            - 403: valid credentials but not enough privileges\n            - 401: no or invalid credentials\n            - for other status codes, the smallest one is selected\n\n        :param errors: List of exceptions.\n        :type errors: t.List[Exception]\n        \"\"\"\n    if not exceptions:\n        return\n    status_to_exc = {getattr(exc, 'status_code', getattr(exc, 'status', 600)): exc for exc in exceptions}\n    if 403 in status_to_exc:\n        raise status_to_exc[403]\n    elif 401 in status_to_exc:\n        raise status_to_exc[401]\n    else:\n        lowest_status_code = min(status_to_exc)\n        raise status_to_exc[lowest_status_code]"
        },
        {
          "name": "token_info.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "token_info.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "_raise_most_specific",
      "module": "security",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\security.py",
      "line_number": 594,
      "end_line_number": 622,
      "source_code": "def _raise_most_specific(exceptions: t.List[Exception]) -> None:\n        \"\"\"Raises the most specific error from a list of exceptions by status code.\n\n        The status codes are expected to be either in the `code`\n        or in the `status` attribute of the exceptions.\n\n        The order is as follows:\n            - 403: valid credentials but not enough privileges\n            - 401: no or invalid credentials\n            - for other status codes, the smallest one is selected\n\n        :param errors: List of exceptions.\n        :type errors: t.List[Exception]\n        \"\"\"\n        if not exceptions:\n            return\n        # We only use status code attributes from exceptions\n        # We use 600 as default because 599 is highest valid status code\n        status_to_exc = {\n            getattr(exc, \"status_code\", getattr(exc, \"status\", 600)): exc\n            for exc in exceptions\n        }\n        if 403 in status_to_exc:\n            raise status_to_exc[403]\n        elif 401 in status_to_exc:\n            raise status_to_exc[401]\n        else:\n            lowest_status_code = min(status_to_exc)\n            raise status_to_exc[lowest_status_code]",
      "docstring": "Raises the most specific error from a list of exceptions by status code.\n\nThe status codes are expected to be either in the `code`\nor in the `status` attribute of the exceptions.\n\nThe order is as follows:\n    - 403: valid credentials but not enough privileges\n    - 401: no or invalid credentials\n    - for other status codes, the smallest one is selected\n\n:param errors: List of exceptions.\n:type errors: t.List[Exception]",
      "decorators": [
        "staticmethod"
      ],
      "arguments": [
        "exceptions"
      ],
      "imports": [
        "asyncio",
        "base64",
        "http.cookies",
        "logging",
        "os",
        "typing",
        "httpx",
        "connexion.decorators.parameter.inspect_function_arguments",
        "connexion.exceptions.OAuthProblem",
        "connexion.exceptions.OAuthResponseProblem",
        "connexion.exceptions.OAuthScopeProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.get_function_from_name"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "wrapper",
      "module": "security",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\security.py",
      "line_number": 181,
      "end_line_number": 193,
      "source_code": "def wrapper(request):\n            auth_type, user_pass = self.get_auth_header_value(request)\n            if auth_type != \"basic\":\n                return NO_VALUE\n\n            try:\n                username, password = (\n                    base64.b64decode(user_pass).decode(\"latin1\").split(\":\", 1)\n                )\n            except Exception:\n                raise OAuthProblem(detail=\"Invalid authorization header\")\n\n            return check_basic_info_func(request, username, password)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "request"
      ],
      "imports": [
        "asyncio",
        "base64",
        "http.cookies",
        "logging",
        "os",
        "typing",
        "httpx",
        "connexion.decorators.parameter.inspect_function_arguments",
        "connexion.exceptions.OAuthProblem",
        "connexion.exceptions.OAuthResponseProblem",
        "connexion.exceptions.OAuthScopeProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.get_function_from_name"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.get_auth_header_value",
          "body": "@staticmethod\ndef get_auth_header_value(request):\n    \"\"\"\n        Return Authorization type and value if any.\n        If not Authorization, return (None, None)\n        Raise OAuthProblem for invalid Authorization header\n        \"\"\"\n    authorization = request.headers.get('Authorization')\n    if not authorization:\n        return (None, None)\n    try:\n        auth_type, value = authorization.split(maxsplit=1)\n    except ValueError:\n        raise OAuthProblem(detail='Invalid authorization header')\n    return (auth_type.lower(), value)"
        }
      ]
    },
    {
      "name": "wrapper",
      "module": "security",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\security.py",
      "line_number": 221,
      "end_line_number": 225,
      "source_code": "def wrapper(request):\n            auth_type, token = self.get_auth_header_value(request)\n            if auth_type != \"bearer\":\n                return NO_VALUE\n            return check_bearer_func(request, token)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "request"
      ],
      "imports": [
        "asyncio",
        "base64",
        "http.cookies",
        "logging",
        "os",
        "typing",
        "httpx",
        "connexion.decorators.parameter.inspect_function_arguments",
        "connexion.exceptions.OAuthProblem",
        "connexion.exceptions.OAuthResponseProblem",
        "connexion.exceptions.OAuthScopeProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.get_function_from_name"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.get_auth_header_value",
          "body": "@staticmethod\ndef get_auth_header_value(request):\n    \"\"\"\n        Return Authorization type and value if any.\n        If not Authorization, return (None, None)\n        Raise OAuthProblem for invalid Authorization header\n        \"\"\"\n    authorization = request.headers.get('Authorization')\n    if not authorization:\n        return (None, None)\n    try:\n        auth_type, value = authorization.split(maxsplit=1)\n    except ValueError:\n        raise OAuthProblem(detail='Invalid authorization header')\n    return (auth_type.lower(), value)"
        }
      ]
    },
    {
      "name": "wrapper",
      "module": "security",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\security.py",
      "line_number": 254,
      "end_line_number": 268,
      "source_code": "def wrapper(request: ConnexionRequest):\n            if loc == \"query\":\n                api_key = request.query_params.get(name)\n            elif loc == \"header\":\n                api_key = request.headers.get(name)\n            elif loc == \"cookie\":\n                cookie_list = request.headers.get(\"Cookie\")\n                api_key = self.get_cookie_value(cookie_list, name)\n            else:\n                return NO_VALUE\n\n            if api_key is None:\n                return NO_VALUE\n\n            return check_api_key_func(request, api_key, required_scopes=required_scopes)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "request"
      ],
      "imports": [
        "asyncio",
        "base64",
        "http.cookies",
        "logging",
        "os",
        "typing",
        "httpx",
        "connexion.decorators.parameter.inspect_function_arguments",
        "connexion.exceptions.OAuthProblem",
        "connexion.exceptions.OAuthResponseProblem",
        "connexion.exceptions.OAuthScopeProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.get_function_from_name"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "request.query_params.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "request.headers.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "request.headers.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "self.get_cookie_value",
          "body": "@staticmethod\ndef get_cookie_value(cookies, name):\n    \"\"\"\n        Returns cookie value by its name. `None` if no such value.\n\n        :param cookies: str: cookies raw data\n        :param name: str: cookies key\n        \"\"\"\n    cookie_parser = http.cookies.SimpleCookie()\n    cookie_parser.load(str(cookies))\n    try:\n        return cookie_parser[name].value\n    except KeyError:\n        return None"
        }
      ]
    },
    {
      "name": "wrapper",
      "module": "security",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\security.py",
      "line_number": 397,
      "end_line_number": 402,
      "source_code": "def wrapper(request):\n            auth_type, token = self.get_auth_header_value(request)\n            if auth_type != \"bearer\":\n                return NO_VALUE\n\n            return check_oauth_func(request, token, required_scopes=required_scopes)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "request"
      ],
      "imports": [
        "asyncio",
        "base64",
        "http.cookies",
        "logging",
        "os",
        "typing",
        "httpx",
        "connexion.decorators.parameter.inspect_function_arguments",
        "connexion.exceptions.OAuthProblem",
        "connexion.exceptions.OAuthResponseProblem",
        "connexion.exceptions.OAuthScopeProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.get_function_from_name"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.get_auth_header_value",
          "body": "@staticmethod\ndef get_auth_header_value(request):\n    \"\"\"\n        Return Authorization type and value if any.\n        If not Authorization, return (None, None)\n        Raise OAuthProblem for invalid Authorization header\n        \"\"\"\n    authorization = request.headers.get('Authorization')\n    if not authorization:\n        return (None, None)\n    try:\n        auth_type, value = authorization.split(maxsplit=1)\n    except ValueError:\n        raise OAuthProblem(detail='Invalid authorization header')\n    return (auth_type.lower(), value)"
        },
        {
          "name": "check_oauth_func",
          "body": "def check_oauth_func(self, token_info_func, scope_validate_func):\n    get_token_info = self._generic_check(token_info_func, 'Provided token is not valid')\n\n    async def wrapper(request, token, required_scopes):\n        token_info = await get_token_info(request, token, required_scopes=required_scopes)\n        token_scopes = token_info.get('scope', token_info.get('scopes', ''))\n        validation = scope_validate_func(required_scopes, token_scopes)\n        while asyncio.iscoroutine(validation):\n            validation = await validation\n        if not validation:\n            raise OAuthScopeProblem(required_scopes=required_scopes, token_scopes=token_scopes)\n        return token_info\n    return wrapper"
        }
      ]
    },
    {
      "name": "create_spec_validator",
      "module": "spec",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\spec.py",
      "line_number": 29,
      "end_line_number": 60,
      "source_code": "def create_spec_validator(spec: dict) -> Draft4Validator:\n    \"\"\"Create a Validator to validate an OpenAPI spec against the OpenAPI schema.\n\n    :param spec: specification to validate\n    \"\"\"\n    # Create an instance validator, which validates defaults against the spec itself instead of\n    # against the OpenAPI schema.\n    InstanceValidator = extend_validator(\n        Draft4Validator, {\"type\": NullableTypeValidator}\n    )\n    instance_validator = InstanceValidator(spec)\n\n    def validate_defaults(validator, properties, instance, schema):\n        \"\"\"Validation function to validate the `properties` subschema, enforcing each default\n        value validates against the schema in which it resides.\n        \"\"\"\n        valid = True\n        for error in validate_properties(validator, properties, instance, schema):\n            valid = False\n            yield error\n\n        # Validate default only when the subschema has validated successfully\n        if not valid:\n            return\n        if isinstance(instance, dict) and \"default\" in instance:\n            for error in instance_validator.evolve(schema=instance).iter_errors(\n                instance[\"default\"]\n            ):\n                yield error\n\n    SpecValidator = extend_validator(Draft4Validator, {\"properties\": validate_defaults})\n    return SpecValidator",
      "docstring": "Create a Validator to validate an OpenAPI spec against the OpenAPI schema.\n\n:param spec: specification to validate",
      "decorators": [],
      "arguments": [
        "spec"
      ],
      "imports": [
        "abc",
        "copy",
        "json",
        "os",
        "pathlib",
        "pkgutil",
        "typing",
        "collections.abc.Mapping",
        "urllib.parse.urlsplit",
        "jinja2",
        "jsonschema",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.validators.extend",
        "exceptions.InvalidSpecification",
        "json_schema.NullableTypeValidator",
        "json_schema.URLHandler",
        "json_schema.resolve_refs",
        "operations.AbstractOperation",
        "operations.OpenAPIOperation",
        "operations.Swagger2Operation",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "canonical_base_path",
      "module": "spec",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\spec.py",
      "line_number": 68,
      "end_line_number": 72,
      "source_code": "def canonical_base_path(base_path):\n    \"\"\"\n    Make given \"basePath\" a canonical base URL which can be prepended to paths starting with \"/\".\n    \"\"\"\n    return base_path.rstrip(\"/\")",
      "docstring": "Make given \"basePath\" a canonical base URL which can be prepended to paths starting with \"/\".",
      "decorators": [],
      "arguments": [
        "base_path"
      ],
      "imports": [
        "abc",
        "copy",
        "json",
        "os",
        "pathlib",
        "pkgutil",
        "typing",
        "collections.abc.Mapping",
        "urllib.parse.urlsplit",
        "jinja2",
        "jsonschema",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.validators.extend",
        "exceptions.InvalidSpecification",
        "json_schema.NullableTypeValidator",
        "json_schema.URLHandler",
        "json_schema.resolve_refs",
        "operations.AbstractOperation",
        "operations.OpenAPIOperation",
        "operations.Swagger2Operation",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "validate_defaults",
      "module": "spec",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\spec.py",
      "line_number": 41,
      "end_line_number": 57,
      "source_code": "def validate_defaults(validator, properties, instance, schema):\n        \"\"\"Validation function to validate the `properties` subschema, enforcing each default\n        value validates against the schema in which it resides.\n        \"\"\"\n        valid = True\n        for error in validate_properties(validator, properties, instance, schema):\n            valid = False\n            yield error\n\n        # Validate default only when the subschema has validated successfully\n        if not valid:\n            return\n        if isinstance(instance, dict) and \"default\" in instance:\n            for error in instance_validator.evolve(schema=instance).iter_errors(\n                instance[\"default\"]\n            ):\n                yield error",
      "docstring": "Validation function to validate the `properties` subschema, enforcing each default\nvalue validates against the schema in which it resides.",
      "decorators": [],
      "arguments": [
        "validator",
        "properties",
        "instance",
        "schema"
      ],
      "imports": [
        "abc",
        "copy",
        "json",
        "os",
        "pathlib",
        "pkgutil",
        "typing",
        "collections.abc.Mapping",
        "urllib.parse.urlsplit",
        "jinja2",
        "jsonschema",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.validators.extend",
        "exceptions.InvalidSpecification",
        "json_schema.NullableTypeValidator",
        "json_schema.URLHandler",
        "json_schema.resolve_refs",
        "operations.AbstractOperation",
        "operations.OpenAPIOperation",
        "operations.Swagger2Operation",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "spec",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\spec.py",
      "line_number": 79,
      "end_line_number": 83,
      "source_code": "def __init__(self, raw_spec, *, base_uri=\"\"):\n        self._raw_spec = copy.deepcopy(raw_spec)\n        self._set_defaults(raw_spec)\n        self._validate_spec(raw_spec)\n        self._spec = resolve_refs(raw_spec, base_uri=base_uri)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "raw_spec"
      ],
      "imports": [
        "abc",
        "copy",
        "json",
        "os",
        "pathlib",
        "pkgutil",
        "typing",
        "collections.abc.Mapping",
        "urllib.parse.urlsplit",
        "jinja2",
        "jsonschema",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.validators.extend",
        "exceptions.InvalidSpecification",
        "json_schema.NullableTypeValidator",
        "json_schema.URLHandler",
        "json_schema.resolve_refs",
        "operations.AbstractOperation",
        "operations.OpenAPIOperation",
        "operations.Swagger2Operation",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._set_defaults",
          "body": "@classmethod\n@abc.abstractmethod\ndef _set_defaults(cls, spec):\n    \"\"\"set some default values in the spec\"\"\""
        },
        {
          "name": "self._validate_spec",
          "body": "@classmethod\ndef _validate_spec(cls, spec):\n    \"\"\"validate spec against schema\"\"\"\n    try:\n        OpenApiValidator = create_spec_validator(spec)\n        validator = OpenApiValidator(cls.openapi_schema)\n        validator.validate(spec)\n    except jsonschema.exceptions.ValidationError as e:\n        raise InvalidSpecification.create_from(e)"
        },
        {
          "name": "resolve_refs",
          "body": "def resolve_refs(spec, store=None, base_uri=''):\n    \"\"\"\n    Resolve JSON references like {\"$ref\": <some URI>} in a spec.\n    Optionally takes a store, which is a mapping from reference URLs to a\n    dereferenced objects. Prepopulating the store can avoid network calls.\n    \"\"\"\n    spec = deepcopy(spec)\n    store = store or {}\n    resolver = RefResolver(base_uri, spec, store, handlers=handlers)\n\n    def _do_resolve(node):\n        if isinstance(node, Mapping) and '$ref' in node:\n            path = node['$ref'][2:].split('/')\n            try:\n                retrieved = deep_get(spec, path)\n                node.update(retrieved)\n                if isinstance(retrieved, Mapping) and '$ref' in retrieved:\n                    node = _do_resolve(node)\n                node.pop('$ref', None)\n                return node\n            except KeyError:\n                with resolver.resolving(node['$ref']) as resolved:\n                    return _do_resolve(resolved)\n        elif isinstance(node, Mapping):\n            for k, v in node.items():\n                node[k] = _do_resolve(v)\n        elif isinstance(node, (list, tuple)):\n            for i, _ in enumerate(node):\n                node[i] = _do_resolve(node[i])\n        return node\n    res = _do_resolve(spec)\n    return res"
        }
      ]
    },
    {
      "name": "_set_defaults",
      "module": "spec",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\spec.py",
      "line_number": 87,
      "end_line_number": 88,
      "source_code": "def _set_defaults(cls, spec):\n        \"\"\"set some default values in the spec\"\"\"",
      "docstring": "set some default values in the spec",
      "decorators": [
        "classmethod",
        "abc.abstractmethod"
      ],
      "arguments": [
        "cls",
        "spec"
      ],
      "imports": [
        "abc",
        "copy",
        "json",
        "os",
        "pathlib",
        "pkgutil",
        "typing",
        "collections.abc.Mapping",
        "urllib.parse.urlsplit",
        "jinja2",
        "jsonschema",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.validators.extend",
        "exceptions.InvalidSpecification",
        "json_schema.NullableTypeValidator",
        "json_schema.URLHandler",
        "json_schema.resolve_refs",
        "operations.AbstractOperation",
        "operations.OpenAPIOperation",
        "operations.Swagger2Operation",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_validate_spec",
      "module": "spec",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\spec.py",
      "line_number": 91,
      "end_line_number": 98,
      "source_code": "def _validate_spec(cls, spec):\n        \"\"\"validate spec against schema\"\"\"\n        try:\n            OpenApiValidator = create_spec_validator(spec)\n            validator = OpenApiValidator(cls.openapi_schema)\n            validator.validate(spec)\n        except jsonschema.exceptions.ValidationError as e:\n            raise InvalidSpecification.create_from(e)",
      "docstring": "validate spec against schema",
      "decorators": [
        "classmethod"
      ],
      "arguments": [
        "cls",
        "spec"
      ],
      "imports": [
        "abc",
        "copy",
        "json",
        "os",
        "pathlib",
        "pkgutil",
        "typing",
        "collections.abc.Mapping",
        "urllib.parse.urlsplit",
        "jinja2",
        "jsonschema",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.validators.extend",
        "exceptions.InvalidSpecification",
        "json_schema.NullableTypeValidator",
        "json_schema.URLHandler",
        "json_schema.resolve_refs",
        "operations.AbstractOperation",
        "operations.OpenAPIOperation",
        "operations.Swagger2Operation",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "create_spec_validator",
          "body": "def create_spec_validator(spec: dict) -> Draft4Validator:\n    \"\"\"Create a Validator to validate an OpenAPI spec against the OpenAPI schema.\n\n    :param spec: specification to validate\n    \"\"\"\n    InstanceValidator = extend_validator(Draft4Validator, {'type': NullableTypeValidator})\n    instance_validator = InstanceValidator(spec)\n\n    def validate_defaults(validator, properties, instance, schema):\n        \"\"\"Validation function to validate the `properties` subschema, enforcing each default\n        value validates against the schema in which it resides.\n        \"\"\"\n        valid = True\n        for error in validate_properties(validator, properties, instance, schema):\n            valid = False\n            yield error\n        if not valid:\n            return\n        if isinstance(instance, dict) and 'default' in instance:\n            for error in instance_validator.evolve(schema=instance).iter_errors(instance['default']):\n                yield error\n    SpecValidator = extend_validator(Draft4Validator, {'properties': validate_defaults})\n    return SpecValidator"
        },
        {
          "name": "validator.validate",
          "body": "def validate(self, scope):\n    logger.debug('%s validating parameters...', scope.get('path'))\n    request = ConnexionRequest(scope, uri_parser=self.uri_parser)\n    self.validate_request(request)"
        }
      ]
    },
    {
      "name": "get_path_params",
      "module": "spec",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\spec.py",
      "line_number": 100,
      "end_line_number": 101,
      "source_code": "def get_path_params(self, path):\n        return deep_get(self._spec, [\"paths\", path]).get(\"parameters\", [])",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "path"
      ],
      "imports": [
        "abc",
        "copy",
        "json",
        "os",
        "pathlib",
        "pkgutil",
        "typing",
        "collections.abc.Mapping",
        "urllib.parse.urlsplit",
        "jinja2",
        "jsonschema",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.validators.extend",
        "exceptions.InvalidSpecification",
        "json_schema.NullableTypeValidator",
        "json_schema.URLHandler",
        "json_schema.resolve_refs",
        "operations.AbstractOperation",
        "operations.OpenAPIOperation",
        "operations.Swagger2Operation",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "deep_get",
          "body": "def deep_get(obj, keys):\n    \"\"\"\n    Recurses through a nested object get a leaf value.\n\n    There are cases where the use of inheritance or polymorphism-- the use of allOf or\n    oneOf keywords-- will cause the obj to be a list. In this case the keys will\n    contain one or more strings containing integers.\n\n    :type obj: list or dict\n    :type keys: list of strings\n    \"\"\"\n    if not keys:\n        return obj\n    if isinstance(obj, list):\n        return deep_get(obj[int(keys[0])], keys[1:])\n    else:\n        return deep_get(obj[keys[0]], keys[1:])"
        }
      ]
    },
    {
      "name": "get_operation",
      "module": "spec",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\spec.py",
      "line_number": 103,
      "end_line_number": 104,
      "source_code": "def get_operation(self, path, method):\n        return deep_get(self._spec, [\"paths\", path, method])",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "path",
        "method"
      ],
      "imports": [
        "abc",
        "copy",
        "json",
        "os",
        "pathlib",
        "pkgutil",
        "typing",
        "collections.abc.Mapping",
        "urllib.parse.urlsplit",
        "jinja2",
        "jsonschema",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.validators.extend",
        "exceptions.InvalidSpecification",
        "json_schema.NullableTypeValidator",
        "json_schema.URLHandler",
        "json_schema.resolve_refs",
        "operations.AbstractOperation",
        "operations.OpenAPIOperation",
        "operations.Swagger2Operation",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "deep_get",
          "body": "def deep_get(obj, keys):\n    \"\"\"\n    Recurses through a nested object get a leaf value.\n\n    There are cases where the use of inheritance or polymorphism-- the use of allOf or\n    oneOf keywords-- will cause the obj to be a list. In this case the keys will\n    contain one or more strings containing integers.\n\n    :type obj: list or dict\n    :type keys: list of strings\n    \"\"\"\n    if not keys:\n        return obj\n    if isinstance(obj, list):\n        return deep_get(obj[int(keys[0])], keys[1:])\n    else:\n        return deep_get(obj[keys[0]], keys[1:])"
        }
      ]
    },
    {
      "name": "raw",
      "module": "spec",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\spec.py",
      "line_number": 107,
      "end_line_number": 108,
      "source_code": "def raw(self):\n        return self._raw_spec",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "copy",
        "json",
        "os",
        "pathlib",
        "pkgutil",
        "typing",
        "collections.abc.Mapping",
        "urllib.parse.urlsplit",
        "jinja2",
        "jsonschema",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.validators.extend",
        "exceptions.InvalidSpecification",
        "json_schema.NullableTypeValidator",
        "json_schema.URLHandler",
        "json_schema.resolve_refs",
        "operations.AbstractOperation",
        "operations.OpenAPIOperation",
        "operations.Swagger2Operation",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "version",
      "module": "spec",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\spec.py",
      "line_number": 111,
      "end_line_number": 112,
      "source_code": "def version(self):\n        return self._get_spec_version(self._spec)",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "copy",
        "json",
        "os",
        "pathlib",
        "pkgutil",
        "typing",
        "collections.abc.Mapping",
        "urllib.parse.urlsplit",
        "jinja2",
        "jsonschema",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.validators.extend",
        "exceptions.InvalidSpecification",
        "json_schema.NullableTypeValidator",
        "json_schema.URLHandler",
        "json_schema.resolve_refs",
        "operations.AbstractOperation",
        "operations.OpenAPIOperation",
        "operations.Swagger2Operation",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._get_spec_version",
          "body": "@staticmethod\ndef _get_spec_version(spec):\n    try:\n        version_string = spec.get('openapi') or spec.get('swagger')\n    except AttributeError:\n        raise InvalidSpecification(NO_SPEC_VERSION_ERR_MSG)\n    if version_string is None:\n        raise InvalidSpecification(NO_SPEC_VERSION_ERR_MSG)\n    try:\n        version_tuple = tuple(map(int, version_string.split('.')))\n    except TypeError:\n        err = 'Unable to convert version string to semantic version tuple: {version_string}.'\n        err = err.format(version_string=version_string)\n        raise InvalidSpecification(err)\n    return version_tuple"
        }
      ]
    },
    {
      "name": "security",
      "module": "spec",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\spec.py",
      "line_number": 115,
      "end_line_number": 116,
      "source_code": "def security(self):\n        return self._spec.get(\"security\")",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "copy",
        "json",
        "os",
        "pathlib",
        "pkgutil",
        "typing",
        "collections.abc.Mapping",
        "urllib.parse.urlsplit",
        "jinja2",
        "jsonschema",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.validators.extend",
        "exceptions.InvalidSpecification",
        "json_schema.NullableTypeValidator",
        "json_schema.URLHandler",
        "json_schema.resolve_refs",
        "operations.AbstractOperation",
        "operations.OpenAPIOperation",
        "operations.Swagger2Operation",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._spec.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "security_schemes",
      "module": "spec",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\spec.py",
      "line_number": 120,
      "end_line_number": 121,
      "source_code": "def security_schemes(self):\n        raise NotImplementedError",
      "docstring": null,
      "decorators": [
        "property",
        "abc.abstractmethod"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "copy",
        "json",
        "os",
        "pathlib",
        "pkgutil",
        "typing",
        "collections.abc.Mapping",
        "urllib.parse.urlsplit",
        "jinja2",
        "jsonschema",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.validators.extend",
        "exceptions.InvalidSpecification",
        "json_schema.NullableTypeValidator",
        "json_schema.URLHandler",
        "json_schema.resolve_refs",
        "operations.AbstractOperation",
        "operations.OpenAPIOperation",
        "operations.Swagger2Operation",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__getitem__",
      "module": "spec",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\spec.py",
      "line_number": 123,
      "end_line_number": 124,
      "source_code": "def __getitem__(self, k):\n        return self._spec[k]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "k"
      ],
      "imports": [
        "abc",
        "copy",
        "json",
        "os",
        "pathlib",
        "pkgutil",
        "typing",
        "collections.abc.Mapping",
        "urllib.parse.urlsplit",
        "jinja2",
        "jsonschema",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.validators.extend",
        "exceptions.InvalidSpecification",
        "json_schema.NullableTypeValidator",
        "json_schema.URLHandler",
        "json_schema.resolve_refs",
        "operations.AbstractOperation",
        "operations.OpenAPIOperation",
        "operations.Swagger2Operation",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__iter__",
      "module": "spec",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\spec.py",
      "line_number": 126,
      "end_line_number": 127,
      "source_code": "def __iter__(self):\n        return self._spec.__iter__()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "copy",
        "json",
        "os",
        "pathlib",
        "pkgutil",
        "typing",
        "collections.abc.Mapping",
        "urllib.parse.urlsplit",
        "jinja2",
        "jsonschema",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.validators.extend",
        "exceptions.InvalidSpecification",
        "json_schema.NullableTypeValidator",
        "json_schema.URLHandler",
        "json_schema.resolve_refs",
        "operations.AbstractOperation",
        "operations.OpenAPIOperation",
        "operations.Swagger2Operation",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._spec.__iter__",
          "body": "def __iter__(self):\n    return self._spec.__iter__()"
        }
      ]
    },
    {
      "name": "__len__",
      "module": "spec",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\spec.py",
      "line_number": 129,
      "end_line_number": 130,
      "source_code": "def __len__(self):\n        return self._spec.__len__()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "copy",
        "json",
        "os",
        "pathlib",
        "pkgutil",
        "typing",
        "collections.abc.Mapping",
        "urllib.parse.urlsplit",
        "jinja2",
        "jsonschema",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.validators.extend",
        "exceptions.InvalidSpecification",
        "json_schema.NullableTypeValidator",
        "json_schema.URLHandler",
        "json_schema.resolve_refs",
        "operations.AbstractOperation",
        "operations.OpenAPIOperation",
        "operations.Swagger2Operation",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._spec.__len__",
          "body": "def __len__(self):\n    return self._spec.__len__()"
        }
      ]
    },
    {
      "name": "_load_spec_from_file",
      "module": "spec",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\spec.py",
      "line_number": 133,
      "end_line_number": 150,
      "source_code": "def _load_spec_from_file(arguments, specification):\n        \"\"\"\n        Loads a YAML specification file, optionally rendering it with Jinja2.\n\n        :param arguments: passed to Jinja2 renderer\n        :param specification: path to specification\n        \"\"\"\n        arguments = arguments or {}\n\n        with specification.open(mode=\"rb\") as openapi_yaml:\n            contents = openapi_yaml.read()\n            try:\n                openapi_template = contents.decode()\n            except UnicodeDecodeError:\n                openapi_template = contents.decode(\"utf-8\", \"replace\")\n\n            openapi_string = jinja2.Template(openapi_template).render(**arguments)\n            return yaml.safe_load(openapi_string)",
      "docstring": "Loads a YAML specification file, optionally rendering it with Jinja2.\n\n:param arguments: passed to Jinja2 renderer\n:param specification: path to specification",
      "decorators": [
        "staticmethod"
      ],
      "arguments": [
        "arguments",
        "specification"
      ],
      "imports": [
        "abc",
        "copy",
        "json",
        "os",
        "pathlib",
        "pkgutil",
        "typing",
        "collections.abc.Mapping",
        "urllib.parse.urlsplit",
        "jinja2",
        "jsonschema",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.validators.extend",
        "exceptions.InvalidSpecification",
        "json_schema.NullableTypeValidator",
        "json_schema.URLHandler",
        "json_schema.resolve_refs",
        "operations.AbstractOperation",
        "operations.OpenAPIOperation",
        "operations.Swagger2Operation",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "from_file",
      "module": "spec",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\spec.py",
      "line_number": 153,
      "end_line_number": 159,
      "source_code": "def from_file(cls, spec, *, arguments=None, base_uri=\"\"):\n        \"\"\"\n        Takes in a path to a YAML file, and returns a Specification\n        \"\"\"\n        specification_path = pathlib.Path(spec)\n        spec = cls._load_spec_from_file(arguments, specification_path)\n        return cls.from_dict(spec, base_uri=base_uri)",
      "docstring": "Takes in a path to a YAML file, and returns a Specification",
      "decorators": [
        "classmethod"
      ],
      "arguments": [
        "cls",
        "spec"
      ],
      "imports": [
        "abc",
        "copy",
        "json",
        "os",
        "pathlib",
        "pkgutil",
        "typing",
        "collections.abc.Mapping",
        "urllib.parse.urlsplit",
        "jinja2",
        "jsonschema",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.validators.extend",
        "exceptions.InvalidSpecification",
        "json_schema.NullableTypeValidator",
        "json_schema.URLHandler",
        "json_schema.resolve_refs",
        "operations.AbstractOperation",
        "operations.OpenAPIOperation",
        "operations.Swagger2Operation",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "cls._load_spec_from_file",
          "body": "@staticmethod\ndef _load_spec_from_file(arguments, specification):\n    \"\"\"\n        Loads a YAML specification file, optionally rendering it with Jinja2.\n\n        :param arguments: passed to Jinja2 renderer\n        :param specification: path to specification\n        \"\"\"\n    arguments = arguments or {}\n    with specification.open(mode='rb') as openapi_yaml:\n        contents = openapi_yaml.read()\n        try:\n            openapi_template = contents.decode()\n        except UnicodeDecodeError:\n            openapi_template = contents.decode('utf-8', 'replace')\n        openapi_string = jinja2.Template(openapi_template).render(**arguments)\n        return yaml.safe_load(openapi_string)"
        },
        {
          "name": "cls.from_dict",
          "body": "@classmethod\ndef from_dict(cls, spec, *, base_uri=''):\n    \"\"\"\n        Takes in a dictionary, and returns a Specification\n        \"\"\"\n\n    def enforce_string_keys(obj):\n        if isinstance(obj, dict):\n            return {str(k): enforce_string_keys(v) for k, v in obj.items()}\n        return obj\n    spec = enforce_string_keys(spec)\n    version = cls._get_spec_version(spec)\n    if version < (3, 0, 0):\n        return Swagger2Specification(spec, base_uri=base_uri)\n    return OpenAPISpecification(spec, base_uri=base_uri)"
        }
      ]
    },
    {
      "name": "from_url",
      "module": "spec",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\spec.py",
      "line_number": 162,
      "end_line_number": 167,
      "source_code": "def from_url(cls, spec, *, base_uri=\"\"):\n        \"\"\"\n        Takes in a path to a YAML file, and returns a Specification\n        \"\"\"\n        spec = URLHandler()(spec)\n        return cls.from_dict(spec, base_uri=base_uri)",
      "docstring": "Takes in a path to a YAML file, and returns a Specification",
      "decorators": [
        "classmethod"
      ],
      "arguments": [
        "cls",
        "spec"
      ],
      "imports": [
        "abc",
        "copy",
        "json",
        "os",
        "pathlib",
        "pkgutil",
        "typing",
        "collections.abc.Mapping",
        "urllib.parse.urlsplit",
        "jinja2",
        "jsonschema",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.validators.extend",
        "exceptions.InvalidSpecification",
        "json_schema.NullableTypeValidator",
        "json_schema.URLHandler",
        "json_schema.resolve_refs",
        "operations.AbstractOperation",
        "operations.OpenAPIOperation",
        "operations.Swagger2Operation",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "cls.from_dict",
          "body": "@classmethod\ndef from_dict(cls, spec, *, base_uri=''):\n    \"\"\"\n        Takes in a dictionary, and returns a Specification\n        \"\"\"\n\n    def enforce_string_keys(obj):\n        if isinstance(obj, dict):\n            return {str(k): enforce_string_keys(v) for k, v in obj.items()}\n        return obj\n    spec = enforce_string_keys(spec)\n    version = cls._get_spec_version(spec)\n    if version < (3, 0, 0):\n        return Swagger2Specification(spec, base_uri=base_uri)\n    return OpenAPISpecification(spec, base_uri=base_uri)"
        }
      ]
    },
    {
      "name": "_get_spec_version",
      "module": "spec",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\spec.py",
      "line_number": 170,
      "end_line_number": 186,
      "source_code": "def _get_spec_version(spec):\n        try:\n            version_string = spec.get(\"openapi\") or spec.get(\"swagger\")\n        except AttributeError:\n            raise InvalidSpecification(NO_SPEC_VERSION_ERR_MSG)\n        if version_string is None:\n            raise InvalidSpecification(NO_SPEC_VERSION_ERR_MSG)\n        try:\n            version_tuple = tuple(map(int, version_string.split(\".\")))\n        except TypeError:\n            err = (\n                \"Unable to convert version string to semantic version tuple: \"\n                \"{version_string}.\"\n            )\n            err = err.format(version_string=version_string)\n            raise InvalidSpecification(err)\n        return version_tuple",
      "docstring": null,
      "decorators": [
        "staticmethod"
      ],
      "arguments": [
        "spec"
      ],
      "imports": [
        "abc",
        "copy",
        "json",
        "os",
        "pathlib",
        "pkgutil",
        "typing",
        "collections.abc.Mapping",
        "urllib.parse.urlsplit",
        "jinja2",
        "jsonschema",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.validators.extend",
        "exceptions.InvalidSpecification",
        "json_schema.NullableTypeValidator",
        "json_schema.URLHandler",
        "json_schema.resolve_refs",
        "operations.AbstractOperation",
        "operations.OpenAPIOperation",
        "operations.Swagger2Operation",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "spec.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "spec.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "from_dict",
      "module": "spec",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\spec.py",
      "line_number": 189,
      "end_line_number": 204,
      "source_code": "def from_dict(cls, spec, *, base_uri=\"\"):\n        \"\"\"\n        Takes in a dictionary, and returns a Specification\n        \"\"\"\n\n        def enforce_string_keys(obj):\n            # YAML supports integer keys, but JSON does not\n            if isinstance(obj, dict):\n                return {str(k): enforce_string_keys(v) for k, v in obj.items()}\n            return obj\n\n        spec = enforce_string_keys(spec)\n        version = cls._get_spec_version(spec)\n        if version < (3, 0, 0):\n            return Swagger2Specification(spec, base_uri=base_uri)\n        return OpenAPISpecification(spec, base_uri=base_uri)",
      "docstring": "Takes in a dictionary, and returns a Specification",
      "decorators": [
        "classmethod"
      ],
      "arguments": [
        "cls",
        "spec"
      ],
      "imports": [
        "abc",
        "copy",
        "json",
        "os",
        "pathlib",
        "pkgutil",
        "typing",
        "collections.abc.Mapping",
        "urllib.parse.urlsplit",
        "jinja2",
        "jsonschema",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.validators.extend",
        "exceptions.InvalidSpecification",
        "json_schema.NullableTypeValidator",
        "json_schema.URLHandler",
        "json_schema.resolve_refs",
        "operations.AbstractOperation",
        "operations.OpenAPIOperation",
        "operations.Swagger2Operation",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "enforce_string_keys",
          "body": "def enforce_string_keys(obj):\n    if isinstance(obj, dict):\n        return {str(k): enforce_string_keys(v) for k, v in obj.items()}\n    return obj"
        },
        {
          "name": "cls._get_spec_version",
          "body": "@staticmethod\ndef _get_spec_version(spec):\n    try:\n        version_string = spec.get('openapi') or spec.get('swagger')\n    except AttributeError:\n        raise InvalidSpecification(NO_SPEC_VERSION_ERR_MSG)\n    if version_string is None:\n        raise InvalidSpecification(NO_SPEC_VERSION_ERR_MSG)\n    try:\n        version_tuple = tuple(map(int, version_string.split('.')))\n    except TypeError:\n        err = 'Unable to convert version string to semantic version tuple: {version_string}.'\n        err = err.format(version_string=version_string)\n        raise InvalidSpecification(err)\n    return version_tuple"
        },
        {
          "name": "enforce_string_keys",
          "body": "def enforce_string_keys(obj):\n    if isinstance(obj, dict):\n        return {str(k): enforce_string_keys(v) for k, v in obj.items()}\n    return obj"
        }
      ]
    },
    {
      "name": "clone",
      "module": "spec",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\spec.py",
      "line_number": 206,
      "end_line_number": 207,
      "source_code": "def clone(self):\n        return type(self)(copy.deepcopy(self._spec))",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "copy",
        "json",
        "os",
        "pathlib",
        "pkgutil",
        "typing",
        "collections.abc.Mapping",
        "urllib.parse.urlsplit",
        "jinja2",
        "jsonschema",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.validators.extend",
        "exceptions.InvalidSpecification",
        "json_schema.NullableTypeValidator",
        "json_schema.URLHandler",
        "json_schema.resolve_refs",
        "operations.AbstractOperation",
        "operations.OpenAPIOperation",
        "operations.Swagger2Operation",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "load",
      "module": "spec",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\spec.py",
      "line_number": 210,
      "end_line_number": 218,
      "source_code": "def load(cls, spec, *, arguments=None):\n        if isinstance(spec, str) and (\n            spec.startswith(\"http://\") or spec.startswith(\"https://\")\n        ):\n            return cls.from_url(spec)\n        if not isinstance(spec, dict):\n            base_uri = f\"{pathlib.Path(spec).parent}{os.sep}\"\n            return cls.from_file(spec, arguments=arguments, base_uri=base_uri)\n        return cls.from_dict(spec)",
      "docstring": null,
      "decorators": [
        "classmethod"
      ],
      "arguments": [
        "cls",
        "spec"
      ],
      "imports": [
        "abc",
        "copy",
        "json",
        "os",
        "pathlib",
        "pkgutil",
        "typing",
        "collections.abc.Mapping",
        "urllib.parse.urlsplit",
        "jinja2",
        "jsonschema",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.validators.extend",
        "exceptions.InvalidSpecification",
        "json_schema.NullableTypeValidator",
        "json_schema.URLHandler",
        "json_schema.resolve_refs",
        "operations.AbstractOperation",
        "operations.OpenAPIOperation",
        "operations.Swagger2Operation",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "cls.from_dict",
          "body": "@classmethod\ndef from_dict(cls, spec, *, base_uri=''):\n    \"\"\"\n        Takes in a dictionary, and returns a Specification\n        \"\"\"\n\n    def enforce_string_keys(obj):\n        if isinstance(obj, dict):\n            return {str(k): enforce_string_keys(v) for k, v in obj.items()}\n        return obj\n    spec = enforce_string_keys(spec)\n    version = cls._get_spec_version(spec)\n    if version < (3, 0, 0):\n        return Swagger2Specification(spec, base_uri=base_uri)\n    return OpenAPISpecification(spec, base_uri=base_uri)"
        },
        {
          "name": "cls.from_url",
          "body": "@classmethod\ndef from_url(cls, spec, *, base_uri=''):\n    \"\"\"\n        Takes in a path to a YAML file, and returns a Specification\n        \"\"\"\n    spec = URLHandler()(spec)\n    return cls.from_dict(spec, base_uri=base_uri)"
        },
        {
          "name": "cls.from_file",
          "body": "@classmethod\ndef from_file(cls, spec, *, arguments=None, base_uri=''):\n    \"\"\"\n        Takes in a path to a YAML file, and returns a Specification\n        \"\"\"\n    specification_path = pathlib.Path(spec)\n    spec = cls._load_spec_from_file(arguments, specification_path)\n    return cls.from_dict(spec, base_uri=base_uri)"
        }
      ]
    },
    {
      "name": "with_base_path",
      "module": "spec",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\spec.py",
      "line_number": 220,
      "end_line_number": 223,
      "source_code": "def with_base_path(self, base_path):\n        new_spec = self.clone()\n        new_spec.base_path = base_path\n        return new_spec",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "base_path"
      ],
      "imports": [
        "abc",
        "copy",
        "json",
        "os",
        "pathlib",
        "pkgutil",
        "typing",
        "collections.abc.Mapping",
        "urllib.parse.urlsplit",
        "jinja2",
        "jsonschema",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.validators.extend",
        "exceptions.InvalidSpecification",
        "json_schema.NullableTypeValidator",
        "json_schema.URLHandler",
        "json_schema.resolve_refs",
        "operations.AbstractOperation",
        "operations.OpenAPIOperation",
        "operations.Swagger2Operation",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.clone",
          "body": "def clone(self):\n    return type(self)(copy.deepcopy(self._spec))"
        }
      ]
    },
    {
      "name": "base_path",
      "module": "spec",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\spec.py",
      "line_number": 227,
      "end_line_number": 228,
      "source_code": "def base_path(self):\n        pass",
      "docstring": null,
      "decorators": [
        "property",
        "abc.abstractmethod"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "copy",
        "json",
        "os",
        "pathlib",
        "pkgutil",
        "typing",
        "collections.abc.Mapping",
        "urllib.parse.urlsplit",
        "jinja2",
        "jsonschema",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.validators.extend",
        "exceptions.InvalidSpecification",
        "json_schema.NullableTypeValidator",
        "json_schema.URLHandler",
        "json_schema.resolve_refs",
        "operations.AbstractOperation",
        "operations.OpenAPIOperation",
        "operations.Swagger2Operation",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "base_path",
      "module": "spec",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\spec.py",
      "line_number": 232,
      "end_line_number": 233,
      "source_code": "def base_path(self, base_path):\n        pass",
      "docstring": null,
      "decorators": [
        "base_path.setter",
        "abc.abstractmethod"
      ],
      "arguments": [
        "self",
        "base_path"
      ],
      "imports": [
        "abc",
        "copy",
        "json",
        "os",
        "pathlib",
        "pkgutil",
        "typing",
        "collections.abc.Mapping",
        "urllib.parse.urlsplit",
        "jinja2",
        "jsonschema",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.validators.extend",
        "exceptions.InvalidSpecification",
        "json_schema.NullableTypeValidator",
        "json_schema.URLHandler",
        "json_schema.resolve_refs",
        "operations.AbstractOperation",
        "operations.OpenAPIOperation",
        "operations.Swagger2Operation",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_set_defaults",
      "module": "spec",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\spec.py",
      "line_number": 247,
      "end_line_number": 252,
      "source_code": "def _set_defaults(cls, spec):\n        spec.setdefault(\"produces\", [])\n        spec.setdefault(\"consumes\", [\"application/json\"])\n        spec.setdefault(\"definitions\", {})\n        spec.setdefault(\"parameters\", {})\n        spec.setdefault(\"responses\", {})",
      "docstring": null,
      "decorators": [
        "classmethod"
      ],
      "arguments": [
        "cls",
        "spec"
      ],
      "imports": [
        "abc",
        "copy",
        "json",
        "os",
        "pathlib",
        "pkgutil",
        "typing",
        "collections.abc.Mapping",
        "urllib.parse.urlsplit",
        "jinja2",
        "jsonschema",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.validators.extend",
        "exceptions.InvalidSpecification",
        "json_schema.NullableTypeValidator",
        "json_schema.URLHandler",
        "json_schema.resolve_refs",
        "operations.AbstractOperation",
        "operations.OpenAPIOperation",
        "operations.Swagger2Operation",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "produces",
      "module": "spec",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\spec.py",
      "line_number": 255,
      "end_line_number": 256,
      "source_code": "def produces(self):\n        return self._spec[\"produces\"]",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "copy",
        "json",
        "os",
        "pathlib",
        "pkgutil",
        "typing",
        "collections.abc.Mapping",
        "urllib.parse.urlsplit",
        "jinja2",
        "jsonschema",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.validators.extend",
        "exceptions.InvalidSpecification",
        "json_schema.NullableTypeValidator",
        "json_schema.URLHandler",
        "json_schema.resolve_refs",
        "operations.AbstractOperation",
        "operations.OpenAPIOperation",
        "operations.Swagger2Operation",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "consumes",
      "module": "spec",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\spec.py",
      "line_number": 259,
      "end_line_number": 260,
      "source_code": "def consumes(self):\n        return self._spec[\"consumes\"]",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "copy",
        "json",
        "os",
        "pathlib",
        "pkgutil",
        "typing",
        "collections.abc.Mapping",
        "urllib.parse.urlsplit",
        "jinja2",
        "jsonschema",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.validators.extend",
        "exceptions.InvalidSpecification",
        "json_schema.NullableTypeValidator",
        "json_schema.URLHandler",
        "json_schema.resolve_refs",
        "operations.AbstractOperation",
        "operations.OpenAPIOperation",
        "operations.Swagger2Operation",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "definitions",
      "module": "spec",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\spec.py",
      "line_number": 263,
      "end_line_number": 264,
      "source_code": "def definitions(self):\n        return self._spec[\"definitions\"]",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "copy",
        "json",
        "os",
        "pathlib",
        "pkgutil",
        "typing",
        "collections.abc.Mapping",
        "urllib.parse.urlsplit",
        "jinja2",
        "jsonschema",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.validators.extend",
        "exceptions.InvalidSpecification",
        "json_schema.NullableTypeValidator",
        "json_schema.URLHandler",
        "json_schema.resolve_refs",
        "operations.AbstractOperation",
        "operations.OpenAPIOperation",
        "operations.Swagger2Operation",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "parameter_definitions",
      "module": "spec",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\spec.py",
      "line_number": 267,
      "end_line_number": 268,
      "source_code": "def parameter_definitions(self):\n        return self._spec[\"parameters\"]",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "copy",
        "json",
        "os",
        "pathlib",
        "pkgutil",
        "typing",
        "collections.abc.Mapping",
        "urllib.parse.urlsplit",
        "jinja2",
        "jsonschema",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.validators.extend",
        "exceptions.InvalidSpecification",
        "json_schema.NullableTypeValidator",
        "json_schema.URLHandler",
        "json_schema.resolve_refs",
        "operations.AbstractOperation",
        "operations.OpenAPIOperation",
        "operations.Swagger2Operation",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "response_definitions",
      "module": "spec",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\spec.py",
      "line_number": 271,
      "end_line_number": 272,
      "source_code": "def response_definitions(self):\n        return self._spec[\"responses\"]",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "copy",
        "json",
        "os",
        "pathlib",
        "pkgutil",
        "typing",
        "collections.abc.Mapping",
        "urllib.parse.urlsplit",
        "jinja2",
        "jsonschema",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.validators.extend",
        "exceptions.InvalidSpecification",
        "json_schema.NullableTypeValidator",
        "json_schema.URLHandler",
        "json_schema.resolve_refs",
        "operations.AbstractOperation",
        "operations.OpenAPIOperation",
        "operations.Swagger2Operation",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "security_schemes",
      "module": "spec",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\spec.py",
      "line_number": 275,
      "end_line_number": 276,
      "source_code": "def security_schemes(self):\n        return self._spec.get(\"securityDefinitions\", {})",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "copy",
        "json",
        "os",
        "pathlib",
        "pkgutil",
        "typing",
        "collections.abc.Mapping",
        "urllib.parse.urlsplit",
        "jinja2",
        "jsonschema",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.validators.extend",
        "exceptions.InvalidSpecification",
        "json_schema.NullableTypeValidator",
        "json_schema.URLHandler",
        "json_schema.resolve_refs",
        "operations.AbstractOperation",
        "operations.OpenAPIOperation",
        "operations.Swagger2Operation",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._spec.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "base_path",
      "module": "spec",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\spec.py",
      "line_number": 279,
      "end_line_number": 280,
      "source_code": "def base_path(self):\n        return canonical_base_path(self._spec.get(\"basePath\", \"\"))",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "copy",
        "json",
        "os",
        "pathlib",
        "pkgutil",
        "typing",
        "collections.abc.Mapping",
        "urllib.parse.urlsplit",
        "jinja2",
        "jsonschema",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.validators.extend",
        "exceptions.InvalidSpecification",
        "json_schema.NullableTypeValidator",
        "json_schema.URLHandler",
        "json_schema.resolve_refs",
        "operations.AbstractOperation",
        "operations.OpenAPIOperation",
        "operations.Swagger2Operation",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "canonical_base_path",
          "body": "def canonical_base_path(base_path):\n    \"\"\"\n    Make given \"basePath\" a canonical base URL which can be prepended to paths starting with \"/\".\n    \"\"\"\n    return base_path.rstrip('/')"
        },
        {
          "name": "self._spec.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "base_path",
      "module": "spec",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\spec.py",
      "line_number": 283,
      "end_line_number": 286,
      "source_code": "def base_path(self, base_path):\n        base_path = canonical_base_path(base_path)\n        self._raw_spec[\"basePath\"] = base_path\n        self._spec[\"basePath\"] = base_path",
      "docstring": null,
      "decorators": [
        "base_path.setter"
      ],
      "arguments": [
        "self",
        "base_path"
      ],
      "imports": [
        "abc",
        "copy",
        "json",
        "os",
        "pathlib",
        "pkgutil",
        "typing",
        "collections.abc.Mapping",
        "urllib.parse.urlsplit",
        "jinja2",
        "jsonschema",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.validators.extend",
        "exceptions.InvalidSpecification",
        "json_schema.NullableTypeValidator",
        "json_schema.URLHandler",
        "json_schema.resolve_refs",
        "operations.AbstractOperation",
        "operations.OpenAPIOperation",
        "operations.Swagger2Operation",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "canonical_base_path",
          "body": "def canonical_base_path(base_path):\n    \"\"\"\n    Make given \"basePath\" a canonical base URL which can be prepended to paths starting with \"/\".\n    \"\"\"\n    return base_path.rstrip('/')"
        }
      ]
    },
    {
      "name": "_set_defaults",
      "module": "spec",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\spec.py",
      "line_number": 300,
      "end_line_number": 301,
      "source_code": "def _set_defaults(cls, spec):\n        spec.setdefault(\"components\", {})",
      "docstring": null,
      "decorators": [
        "classmethod"
      ],
      "arguments": [
        "cls",
        "spec"
      ],
      "imports": [
        "abc",
        "copy",
        "json",
        "os",
        "pathlib",
        "pkgutil",
        "typing",
        "collections.abc.Mapping",
        "urllib.parse.urlsplit",
        "jinja2",
        "jsonschema",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.validators.extend",
        "exceptions.InvalidSpecification",
        "json_schema.NullableTypeValidator",
        "json_schema.URLHandler",
        "json_schema.resolve_refs",
        "operations.AbstractOperation",
        "operations.OpenAPIOperation",
        "operations.Swagger2Operation",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "security_schemes",
      "module": "spec",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\spec.py",
      "line_number": 304,
      "end_line_number": 305,
      "source_code": "def security_schemes(self):\n        return self._spec[\"components\"].get(\"securitySchemes\", {})",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "copy",
        "json",
        "os",
        "pathlib",
        "pkgutil",
        "typing",
        "collections.abc.Mapping",
        "urllib.parse.urlsplit",
        "jinja2",
        "jsonschema",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.validators.extend",
        "exceptions.InvalidSpecification",
        "json_schema.NullableTypeValidator",
        "json_schema.URLHandler",
        "json_schema.resolve_refs",
        "operations.AbstractOperation",
        "operations.OpenAPIOperation",
        "operations.Swagger2Operation",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "components",
      "module": "spec",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\spec.py",
      "line_number": 308,
      "end_line_number": 309,
      "source_code": "def components(self):\n        return self._spec[\"components\"]",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "copy",
        "json",
        "os",
        "pathlib",
        "pkgutil",
        "typing",
        "collections.abc.Mapping",
        "urllib.parse.urlsplit",
        "jinja2",
        "jsonschema",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.validators.extend",
        "exceptions.InvalidSpecification",
        "json_schema.NullableTypeValidator",
        "json_schema.URLHandler",
        "json_schema.resolve_refs",
        "operations.AbstractOperation",
        "operations.OpenAPIOperation",
        "operations.Swagger2Operation",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "base_path",
      "module": "spec",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\spec.py",
      "line_number": 312,
      "end_line_number": 324,
      "source_code": "def base_path(self):\n        servers = self._spec.get(\"servers\", [])\n        try:\n            # assume we're the first server in list\n            server = copy.deepcopy(servers[0])\n            server_vars = server.pop(\"variables\", {})\n            server[\"url\"] = server[\"url\"].format(\n                **{k: v[\"default\"] for k, v in server_vars.items()}\n            )\n            base_path = urlsplit(server[\"url\"]).path\n        except IndexError:\n            base_path = \"\"\n        return canonical_base_path(base_path)",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "copy",
        "json",
        "os",
        "pathlib",
        "pkgutil",
        "typing",
        "collections.abc.Mapping",
        "urllib.parse.urlsplit",
        "jinja2",
        "jsonschema",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.validators.extend",
        "exceptions.InvalidSpecification",
        "json_schema.NullableTypeValidator",
        "json_schema.URLHandler",
        "json_schema.resolve_refs",
        "operations.AbstractOperation",
        "operations.OpenAPIOperation",
        "operations.Swagger2Operation",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._spec.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "canonical_base_path",
          "body": "def canonical_base_path(base_path):\n    \"\"\"\n    Make given \"basePath\" a canonical base URL which can be prepended to paths starting with \"/\".\n    \"\"\"\n    return base_path.rstrip('/')"
        }
      ]
    },
    {
      "name": "base_path",
      "module": "spec",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\spec.py",
      "line_number": 327,
      "end_line_number": 331,
      "source_code": "def base_path(self, base_path):\n        base_path = canonical_base_path(base_path)\n        user_servers = [{\"url\": base_path}]\n        self._raw_spec[\"servers\"] = user_servers\n        self._spec[\"servers\"] = user_servers",
      "docstring": null,
      "decorators": [
        "base_path.setter"
      ],
      "arguments": [
        "self",
        "base_path"
      ],
      "imports": [
        "abc",
        "copy",
        "json",
        "os",
        "pathlib",
        "pkgutil",
        "typing",
        "collections.abc.Mapping",
        "urllib.parse.urlsplit",
        "jinja2",
        "jsonschema",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.validators.extend",
        "exceptions.InvalidSpecification",
        "json_schema.NullableTypeValidator",
        "json_schema.URLHandler",
        "json_schema.resolve_refs",
        "operations.AbstractOperation",
        "operations.OpenAPIOperation",
        "operations.Swagger2Operation",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "canonical_base_path",
          "body": "def canonical_base_path(base_path):\n    \"\"\"\n    Make given \"basePath\" a canonical base URL which can be prepended to paths starting with \"/\".\n    \"\"\"\n    return base_path.rstrip('/')"
        }
      ]
    },
    {
      "name": "enforce_string_keys",
      "module": "spec",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\spec.py",
      "line_number": 194,
      "end_line_number": 198,
      "source_code": "def enforce_string_keys(obj):\n            # YAML supports integer keys, but JSON does not\n            if isinstance(obj, dict):\n                return {str(k): enforce_string_keys(v) for k, v in obj.items()}\n            return obj",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "obj"
      ],
      "imports": [
        "abc",
        "copy",
        "json",
        "os",
        "pathlib",
        "pkgutil",
        "typing",
        "collections.abc.Mapping",
        "urllib.parse.urlsplit",
        "jinja2",
        "jsonschema",
        "yaml",
        "jsonschema.Draft4Validator",
        "jsonschema.validators.extend",
        "exceptions.InvalidSpecification",
        "json_schema.NullableTypeValidator",
        "json_schema.URLHandler",
        "json_schema.resolve_refs",
        "operations.AbstractOperation",
        "operations.OpenAPIOperation",
        "operations.Swagger2Operation",
        "utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "enforce_string_keys",
          "body": "def enforce_string_keys(obj):\n    if isinstance(obj, dict):\n        return {str(k): enforce_string_keys(v) for k, v in obj.items()}\n    return obj"
        }
      ]
    },
    {
      "name": "__init__",
      "module": "testing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\testing.py",
      "line_number": 14,
      "end_line_number": 27,
      "source_code": "def __init__(\n        self,\n        *,\n        context: t.Optional[dict] = None,\n        operation: t.Optional[AbstractOperation] = None,\n        receive: t.Optional[Receive] = None,\n        scope: t.Optional[Scope] = None,\n    ) -> None:\n        self.context = context if context is not None else self.build_context()\n        self.operation = operation if operation is not None else self.build_operation()\n        self.receive = receive if receive is not None else self.build_receive()\n        self.scope = scope if scope is not None else self.build_scope()\n\n        self.tokens: t.Dict[str, contextvars.Token] = {}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "contextvars",
        "typing",
        "unittest.mock.MagicMock",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "connexion.context._context",
        "connexion.context._operation",
        "connexion.context._receive",
        "connexion.context._scope",
        "connexion.operations.AbstractOperation"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.build_context",
          "body": "@staticmethod\ndef build_context() -> dict:\n    return {}"
        },
        {
          "name": "self.build_operation",
          "body": "@staticmethod\ndef build_operation() -> AbstractOperation:\n    return MagicMock(name='operation')"
        },
        {
          "name": "self.build_receive",
          "body": "@staticmethod\ndef build_receive() -> Receive:\n\n    async def receive() -> t.MutableMapping[str, t.Any]:\n        return {'type': 'http.request', 'body': b''}\n    return receive"
        },
        {
          "name": "self.build_scope",
          "body": "@staticmethod\ndef build_scope(**kwargs) -> Scope:\n    scope = {'type': 'http', 'query_string': b'', 'headers': [(b'Content-Type', b'application/octet-stream')]}\n    for key, value in kwargs.items():\n        scope[key] = value\n    return scope"
        }
      ]
    },
    {
      "name": "__enter__",
      "module": "testing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\testing.py",
      "line_number": 29,
      "end_line_number": 34,
      "source_code": "def __enter__(self) -> None:\n        self.tokens[\"context\"] = _context.set(self.context)\n        self.tokens[\"operation\"] = _operation.set(self.operation)\n        self.tokens[\"receive\"] = _receive.set(self.receive)\n        self.tokens[\"scope\"] = _scope.set(self.scope)\n        return",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "contextvars",
        "typing",
        "unittest.mock.MagicMock",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "connexion.context._context",
        "connexion.context._operation",
        "connexion.context._receive",
        "connexion.context._scope",
        "connexion.operations.AbstractOperation"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__exit__",
      "module": "testing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\testing.py",
      "line_number": 36,
      "end_line_number": 41,
      "source_code": "def __exit__(self, type, value, traceback):\n        _context.reset(self.tokens[\"context\"])\n        _operation.reset(self.tokens[\"operation\"])\n        _receive.reset(self.tokens[\"receive\"])\n        _scope.reset(self.tokens[\"scope\"])\n        return False",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "type",
        "value",
        "traceback"
      ],
      "imports": [
        "contextvars",
        "typing",
        "unittest.mock.MagicMock",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "connexion.context._context",
        "connexion.context._operation",
        "connexion.context._receive",
        "connexion.context._scope",
        "connexion.operations.AbstractOperation"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "build_context",
      "module": "testing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\testing.py",
      "line_number": 44,
      "end_line_number": 45,
      "source_code": "def build_context() -> dict:\n        return {}",
      "docstring": null,
      "decorators": [
        "staticmethod"
      ],
      "arguments": [],
      "imports": [
        "contextvars",
        "typing",
        "unittest.mock.MagicMock",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "connexion.context._context",
        "connexion.context._operation",
        "connexion.context._receive",
        "connexion.context._scope",
        "connexion.operations.AbstractOperation"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "build_operation",
      "module": "testing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\testing.py",
      "line_number": 48,
      "end_line_number": 49,
      "source_code": "def build_operation() -> AbstractOperation:\n        return MagicMock(name=\"operation\")",
      "docstring": null,
      "decorators": [
        "staticmethod"
      ],
      "arguments": [],
      "imports": [
        "contextvars",
        "typing",
        "unittest.mock.MagicMock",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "connexion.context._context",
        "connexion.context._operation",
        "connexion.context._receive",
        "connexion.context._scope",
        "connexion.operations.AbstractOperation"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "build_receive",
      "module": "testing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\testing.py",
      "line_number": 52,
      "end_line_number": 59,
      "source_code": "def build_receive() -> Receive:\n        async def receive() -> t.MutableMapping[str, t.Any]:\n            return {\n                \"type\": \"http.request\",\n                \"body\": b\"\",\n            }\n\n        return receive",
      "docstring": null,
      "decorators": [
        "staticmethod"
      ],
      "arguments": [],
      "imports": [
        "contextvars",
        "typing",
        "unittest.mock.MagicMock",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "connexion.context._context",
        "connexion.context._operation",
        "connexion.context._receive",
        "connexion.context._scope",
        "connexion.operations.AbstractOperation"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "build_scope",
      "module": "testing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\testing.py",
      "line_number": 62,
      "end_line_number": 72,
      "source_code": "def build_scope(**kwargs) -> Scope:\n        scope = {\n            \"type\": \"http\",\n            \"query_string\": b\"\",\n            \"headers\": [(b\"Content-Type\", b\"application/octet-stream\")],\n        }\n\n        for key, value in kwargs.items():\n            scope[key] = value\n\n        return scope",
      "docstring": null,
      "decorators": [
        "staticmethod"
      ],
      "arguments": [],
      "imports": [
        "contextvars",
        "typing",
        "unittest.mock.MagicMock",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "connexion.context._context",
        "connexion.context._operation",
        "connexion.context._receive",
        "connexion.context._scope",
        "connexion.operations.AbstractOperation"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "uri_parsing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\uri_parsing.py",
      "line_number": 27,
      "end_line_number": 42,
      "source_code": "def __init__(self, param_defns, body_defn):\n        \"\"\"\n        a URI parser is initialized with parameter definitions.\n        When called with a request object, it handles array types in the URI\n        both in the path and query according to the spec.\n        Some examples include:\n        - https://mysite.fake/in/path/1,2,3/            # path parameters\n        - https://mysite.fake/?in_query=a,b,c           # simple query params\n        - https://mysite.fake/?in_query=a|b|c           # various separators\n        - https://mysite.fake/?in_query=a&in_query=b,c  # complex query params\n        \"\"\"\n        self._param_defns = {\n            p[\"name\"]: p for p in param_defns if p[\"in\"] in self.parsable_parameters\n        }\n        self._body_schema = body_defn.get(\"schema\", {})\n        self._body_encoding = body_defn.get(\"encoding\", {})",
      "docstring": "a URI parser is initialized with parameter definitions.\nWhen called with a request object, it handles array types in the URI\nboth in the path and query according to the spec.\nSome examples include:\n- https://mysite.fake/in/path/1,2,3/            # path parameters\n- https://mysite.fake/?in_query=a,b,c           # simple query params\n- https://mysite.fake/?in_query=a|b|c           # various separators\n- https://mysite.fake/?in_query=a&in_query=b,c  # complex query params",
      "decorators": [],
      "arguments": [
        "self",
        "param_defns",
        "body_defn"
      ],
      "imports": [
        "abc",
        "json",
        "logging",
        "re",
        "connexion.exceptions.TypeValidationError",
        "connexion.utils.all_json",
        "connexion.utils.coerce_type",
        "connexion.utils.deep_merge"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "body_defn.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "body_defn.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "param_defns",
      "module": "uri_parsing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\uri_parsing.py",
      "line_number": 46,
      "end_line_number": 49,
      "source_code": "def param_defns(self):\n        \"\"\"\n        returns the parameter definitions by name\n        \"\"\"",
      "docstring": "returns the parameter definitions by name",
      "decorators": [
        "property",
        "abc.abstractmethod"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "json",
        "logging",
        "re",
        "connexion.exceptions.TypeValidationError",
        "connexion.utils.all_json",
        "connexion.utils.coerce_type",
        "connexion.utils.deep_merge"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "param_schemas",
      "module": "uri_parsing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\uri_parsing.py",
      "line_number": 53,
      "end_line_number": 56,
      "source_code": "def param_schemas(self):\n        \"\"\"\n        returns the parameter schemas by name\n        \"\"\"",
      "docstring": "returns the parameter schemas by name",
      "decorators": [
        "property",
        "abc.abstractmethod"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "json",
        "logging",
        "re",
        "connexion.exceptions.TypeValidationError",
        "connexion.utils.all_json",
        "connexion.utils.coerce_type",
        "connexion.utils.deep_merge"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__repr__",
      "module": "uri_parsing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\uri_parsing.py",
      "line_number": 58,
      "end_line_number": 64,
      "source_code": "def __repr__(self):\n        \"\"\"\n        :rtype: str\n        \"\"\"\n        return \"<{classname}>\".format(\n            classname=self.__class__.__name__\n        )",
      "docstring": ":rtype: str",
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "json",
        "logging",
        "re",
        "connexion.exceptions.TypeValidationError",
        "connexion.utils.all_json",
        "connexion.utils.coerce_type",
        "connexion.utils.deep_merge"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "resolve_form",
      "module": "uri_parsing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\uri_parsing.py",
      "line_number": 67,
      "end_line_number": 68,
      "source_code": "def resolve_form(self, form_data):\n        \"\"\"Resolve cases where form parameters are provided multiple times.\"\"\"",
      "docstring": "Resolve cases where form parameters are provided multiple times.",
      "decorators": [
        "abc.abstractmethod"
      ],
      "arguments": [
        "self",
        "form_data"
      ],
      "imports": [
        "abc",
        "json",
        "logging",
        "re",
        "connexion.exceptions.TypeValidationError",
        "connexion.utils.all_json",
        "connexion.utils.coerce_type",
        "connexion.utils.deep_merge"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "resolve_query",
      "module": "uri_parsing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\uri_parsing.py",
      "line_number": 71,
      "end_line_number": 72,
      "source_code": "def resolve_query(self, query_data):\n        \"\"\"Resolve cases where query parameters are provided multiple times.\"\"\"",
      "docstring": "Resolve cases where query parameters are provided multiple times.",
      "decorators": [
        "abc.abstractmethod"
      ],
      "arguments": [
        "self",
        "query_data"
      ],
      "imports": [
        "abc",
        "json",
        "logging",
        "re",
        "connexion.exceptions.TypeValidationError",
        "connexion.utils.all_json",
        "connexion.utils.coerce_type",
        "connexion.utils.deep_merge"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "resolve_path",
      "module": "uri_parsing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\uri_parsing.py",
      "line_number": 75,
      "end_line_number": 76,
      "source_code": "def resolve_path(self, path):\n        \"\"\"Resolve cases where path parameters include lists\"\"\"",
      "docstring": "Resolve cases where path parameters include lists",
      "decorators": [
        "abc.abstractmethod"
      ],
      "arguments": [
        "self",
        "path"
      ],
      "imports": [
        "abc",
        "json",
        "logging",
        "re",
        "connexion.exceptions.TypeValidationError",
        "connexion.utils.all_json",
        "connexion.utils.coerce_type",
        "connexion.utils.deep_merge"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_resolve_param_duplicates",
      "module": "uri_parsing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\uri_parsing.py",
      "line_number": 79,
      "end_line_number": 84,
      "source_code": "def _resolve_param_duplicates(self, values, param_defn, _in):\n        \"\"\"Resolve cases where query parameters are provided multiple times.\n        For example, if the query string is '?a=1,2,3&a=4,5,6' the value of\n        `a` could be \"4,5,6\", or \"1,2,3\" or \"1,2,3,4,5,6\" depending on the\n        implementation.\n        \"\"\"",
      "docstring": "Resolve cases where query parameters are provided multiple times.\nFor example, if the query string is '?a=1,2,3&a=4,5,6' the value of\n`a` could be \"4,5,6\", or \"1,2,3\" or \"1,2,3,4,5,6\" depending on the\nimplementation.",
      "decorators": [
        "abc.abstractmethod"
      ],
      "arguments": [
        "self",
        "values",
        "param_defn",
        "_in"
      ],
      "imports": [
        "abc",
        "json",
        "logging",
        "re",
        "connexion.exceptions.TypeValidationError",
        "connexion.utils.all_json",
        "connexion.utils.coerce_type",
        "connexion.utils.deep_merge"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_split",
      "module": "uri_parsing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\uri_parsing.py",
      "line_number": 87,
      "end_line_number": 92,
      "source_code": "def _split(self, value, param_defn, _in):\n        \"\"\"\n        takes a string, a parameter definition, and a parameter type\n        and returns an array that has been constructed according to\n        the parameter definition.\n        \"\"\"",
      "docstring": "takes a string, a parameter definition, and a parameter type\nand returns an array that has been constructed according to\nthe parameter definition.",
      "decorators": [
        "abc.abstractmethod"
      ],
      "arguments": [
        "self",
        "value",
        "param_defn",
        "_in"
      ],
      "imports": [
        "abc",
        "json",
        "logging",
        "re",
        "connexion.exceptions.TypeValidationError",
        "connexion.utils.all_json",
        "connexion.utils.coerce_type",
        "connexion.utils.deep_merge"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "resolve_params",
      "module": "uri_parsing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\uri_parsing.py",
      "line_number": 94,
      "end_line_number": 129,
      "source_code": "def resolve_params(self, params, _in):\n        \"\"\"\n        takes a dict of parameters, and resolves the values into\n        the correct array type handling duplicate values, and splitting\n        based on the collectionFormat defined in the spec.\n        \"\"\"\n        resolved_param = {}\n        for k, values in params.items():\n            param_defn = self.param_defns.get(k)\n            param_schema = self.param_schemas.get(k)\n\n            if not (param_defn or param_schema):\n                # rely on validation\n                resolved_param[k] = values\n                continue\n\n            if _in == \"path\":\n                # multiple values in a path is impossible\n                values = [values]\n\n            if param_schema and param_schema[\"type\"] == \"array\":\n                # resolve variable re-assignment, handle explode\n                values = self._resolve_param_duplicates(values, param_defn, _in)\n                # handle array styles\n                resolved_param[k] = self._split(values, param_defn, _in)\n            else:\n                resolved_param[k] = values[-1]\n\n            try:\n                resolved_param[k] = coerce_type(\n                    param_defn, resolved_param[k], \"parameter\", k\n                )\n            except TypeValidationError:\n                pass\n\n        return resolved_param",
      "docstring": "takes a dict of parameters, and resolves the values into\nthe correct array type handling duplicate values, and splitting\nbased on the collectionFormat defined in the spec.",
      "decorators": [],
      "arguments": [
        "self",
        "params",
        "_in"
      ],
      "imports": [
        "abc",
        "json",
        "logging",
        "re",
        "connexion.exceptions.TypeValidationError",
        "connexion.utils.all_json",
        "connexion.utils.coerce_type",
        "connexion.utils.deep_merge"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.param_defns.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "self.param_schemas.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "self._resolve_param_duplicates",
          "body": "@abc.abstractmethod\ndef _resolve_param_duplicates(self, values, param_defn, _in):\n    \"\"\"Resolve cases where query parameters are provided multiple times.\n        For example, if the query string is '?a=1,2,3&a=4,5,6' the value of\n        `a` could be \"4,5,6\", or \"1,2,3\" or \"1,2,3,4,5,6\" depending on the\n        implementation.\n        \"\"\""
        },
        {
          "name": "self._split",
          "body": "@abc.abstractmethod\ndef _split(self, value, param_defn, _in):\n    \"\"\"\n        takes a string, a parameter definition, and a parameter type\n        and returns an array that has been constructed according to\n        the parameter definition.\n        \"\"\""
        },
        {
          "name": "coerce_type",
          "body": "def coerce_type(param, value, parameter_type, parameter_name=None):\n    TYPE_MAP = {'integer': int, 'number': float, 'boolean': boolean, 'object': dict}\n\n    def make_type(value, type_literal):\n        type_func = TYPE_MAP.get(type_literal)\n        return type_func(value)\n    param_schema = param.get('schema', param)\n    if is_nullable(param_schema) and is_null(value):\n        return None\n    param_type = param_schema.get('type')\n    parameter_name = parameter_name if parameter_name else param.get('name')\n    if param_type == 'array':\n        converted_params = []\n        if parameter_type == 'header':\n            value = value.split(',')\n        for v in value:\n            try:\n                converted = make_type(v, param_schema['items']['type'])\n            except (ValueError, TypeError):\n                converted = v\n            converted_params.append(converted)\n        return converted_params\n    elif param_type == 'object':\n        if param_schema.get('properties'):\n\n            def cast_leaves(d, schema):\n                if type(d) is not dict:\n                    try:\n                        return make_type(d, schema['type'])\n                    except (ValueError, TypeError):\n                        return d\n                for k, v in d.items():\n                    if k in schema['properties']:\n                        d[k] = cast_leaves(v, schema['properties'][k])\n                return d\n            return cast_leaves(value, param_schema)\n        return value\n    else:\n        try:\n            return make_type(value, param_type)\n        except ValueError:\n            raise TypeValidationError(param_type, parameter_type, parameter_name)\n        except TypeError:\n            return value"
        }
      ]
    },
    {
      "name": "param_defns",
      "module": "uri_parsing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\uri_parsing.py",
      "line_number": 142,
      "end_line_number": 143,
      "source_code": "def param_defns(self):\n        return self._param_defns",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "json",
        "logging",
        "re",
        "connexion.exceptions.TypeValidationError",
        "connexion.utils.all_json",
        "connexion.utils.coerce_type",
        "connexion.utils.deep_merge"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "form_defns",
      "module": "uri_parsing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\uri_parsing.py",
      "line_number": 146,
      "end_line_number": 147,
      "source_code": "def form_defns(self):\n        return {k: v for k, v in self._body_schema.get(\"properties\", {}).items()}",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "json",
        "logging",
        "re",
        "connexion.exceptions.TypeValidationError",
        "connexion.utils.all_json",
        "connexion.utils.coerce_type",
        "connexion.utils.deep_merge"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._body_schema.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "param_schemas",
      "module": "uri_parsing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\uri_parsing.py",
      "line_number": 150,
      "end_line_number": 151,
      "source_code": "def param_schemas(self):\n        return {k: v.get(\"schema\", {}) for k, v in self.param_defns.items()}",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "json",
        "logging",
        "re",
        "connexion.exceptions.TypeValidationError",
        "connexion.utils.all_json",
        "connexion.utils.coerce_type",
        "connexion.utils.deep_merge"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "v.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "resolve_form",
      "module": "uri_parsing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\uri_parsing.py",
      "line_number": 153,
      "end_line_number": 168,
      "source_code": "def resolve_form(self, form_data):\n        if self._body_schema is None or self._body_schema.get(\"type\") != \"object\":\n            return form_data\n        for k in form_data:\n            encoding = self._body_encoding.get(k, {\"style\": \"form\"})\n            defn = self.form_defns.get(k, {})\n            # TODO support more form encoding styles\n            form_data[k] = self._resolve_param_duplicates(\n                form_data[k], encoding, \"form\"\n            )\n            if \"contentType\" in encoding and all_json([encoding.get(\"contentType\")]):\n                form_data[k] = json.loads(form_data[k])\n            elif defn and defn[\"type\"] == \"array\":\n                form_data[k] = self._split(form_data[k], encoding, \"form\")\n            form_data[k] = coerce_type(defn, form_data[k], \"requestBody\", k)\n        return form_data",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "form_data"
      ],
      "imports": [
        "abc",
        "json",
        "logging",
        "re",
        "connexion.exceptions.TypeValidationError",
        "connexion.utils.all_json",
        "connexion.utils.coerce_type",
        "connexion.utils.deep_merge"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._body_encoding.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "self.form_defns.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "self._resolve_param_duplicates",
          "body": "@abc.abstractmethod\ndef _resolve_param_duplicates(self, values, param_defn, _in):\n    \"\"\"Resolve cases where query parameters are provided multiple times.\n        For example, if the query string is '?a=1,2,3&a=4,5,6' the value of\n        `a` could be \"4,5,6\", or \"1,2,3\" or \"1,2,3,4,5,6\" depending on the\n        implementation.\n        \"\"\""
        },
        {
          "name": "coerce_type",
          "body": "def coerce_type(param, value, parameter_type, parameter_name=None):\n    TYPE_MAP = {'integer': int, 'number': float, 'boolean': boolean, 'object': dict}\n\n    def make_type(value, type_literal):\n        type_func = TYPE_MAP.get(type_literal)\n        return type_func(value)\n    param_schema = param.get('schema', param)\n    if is_nullable(param_schema) and is_null(value):\n        return None\n    param_type = param_schema.get('type')\n    parameter_name = parameter_name if parameter_name else param.get('name')\n    if param_type == 'array':\n        converted_params = []\n        if parameter_type == 'header':\n            value = value.split(',')\n        for v in value:\n            try:\n                converted = make_type(v, param_schema['items']['type'])\n            except (ValueError, TypeError):\n                converted = v\n            converted_params.append(converted)\n        return converted_params\n    elif param_type == 'object':\n        if param_schema.get('properties'):\n\n            def cast_leaves(d, schema):\n                if type(d) is not dict:\n                    try:\n                        return make_type(d, schema['type'])\n                    except (ValueError, TypeError):\n                        return d\n                for k, v in d.items():\n                    if k in schema['properties']:\n                        d[k] = cast_leaves(v, schema['properties'][k])\n                return d\n            return cast_leaves(value, param_schema)\n        return value\n    else:\n        try:\n            return make_type(value, param_type)\n        except ValueError:\n            raise TypeValidationError(param_type, parameter_type, parameter_name)\n        except TypeError:\n            return value"
        },
        {
          "name": "self._body_schema.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "all_json",
          "body": "def all_json(mimetypes):\n    \"\"\"\n    Returns True if all mimetypes are serialized with json\n\n    :type mimetypes: list\n    :rtype: bool\n\n    >>> all_json(['application/json'])\n    True\n    >>> all_json(['application/x.custom+json'])\n    True\n    >>> all_json([])\n    True\n    >>> all_json(['application/xml'])\n    False\n    >>> all_json(['text/json'])\n    False\n    >>> all_json(['application/json', 'other/type'])\n    False\n    >>> all_json(['application/json', 'application/x.custom+json'])\n    True\n    \"\"\"\n    return all((is_json_mimetype(mimetype) for mimetype in mimetypes))"
        },
        {
          "name": "self._split",
          "body": "@abc.abstractmethod\ndef _split(self, value, param_defn, _in):\n    \"\"\"\n        takes a string, a parameter definition, and a parameter type\n        and returns an array that has been constructed according to\n        the parameter definition.\n        \"\"\""
        },
        {
          "name": "encoding.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "_make_deep_object",
      "module": "uri_parsing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\uri_parsing.py",
      "line_number": 170,
      "end_line_number": 197,
      "source_code": "def _make_deep_object(self, k, v):\n        \"\"\"consumes keys, value pairs like (a[foo][bar], \"baz\")\n        returns (a, {\"foo\": {\"bar\": \"baz\"}}}, is_deep_object)\n        \"\"\"\n        root_key = None\n        if k in self.param_schemas.keys():\n            return k, v, False\n        else:\n            for key in self.param_schemas.keys():\n                if k.startswith(key) and \"[\" in k:\n                    root_key = key.replace(k, \"\")\n\n        if not root_key:\n            root_key = k.split(\"[\", 1)[0]\n            if k == root_key:\n                return k, v, False\n\n        if not self._is_deep_object_style_param(root_key):\n            return k, v, False\n\n        key_path = re.findall(r\"\\[([^\\[\\]]*)\\]\", k)\n        root = prev = node = {}\n        for k in key_path:\n            node[k] = {}\n            prev = node\n            node = node[k]\n        prev[k] = v[0]\n        return root_key, [root], True",
      "docstring": "consumes keys, value pairs like (a[foo][bar], \"baz\")\nreturns (a, {\"foo\": {\"bar\": \"baz\"}}}, is_deep_object)",
      "decorators": [],
      "arguments": [
        "self",
        "k",
        "v"
      ],
      "imports": [
        "abc",
        "json",
        "logging",
        "re",
        "connexion.exceptions.TypeValidationError",
        "connexion.utils.all_json",
        "connexion.utils.coerce_type",
        "connexion.utils.deep_merge"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._is_deep_object_style_param",
          "body": "def _is_deep_object_style_param(self, param_name):\n    default_style = self.style_defaults['query']\n    style = self.param_defns.get(param_name, {}).get('style', default_style)\n    return style == 'deepObject'"
        },
        {
          "name": "key.replace",
          "body": "def replace(self, **changes) -> '_Options':\n    \"\"\"Update mechanism to overwrite the options. None values are discarded.\n\n        :param changes: Arguments accepted by the __init__ method of this class.\n\n        :return: An new _Options object with updated arguments.\n        \"\"\"\n    changes = {key: value for key, value in changes.items() if value is not None}\n    return dataclasses.replace(self, **changes)"
        }
      ]
    },
    {
      "name": "_is_deep_object_style_param",
      "module": "uri_parsing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\uri_parsing.py",
      "line_number": 199,
      "end_line_number": 202,
      "source_code": "def _is_deep_object_style_param(self, param_name):\n        default_style = self.style_defaults[\"query\"]\n        style = self.param_defns.get(param_name, {}).get(\"style\", default_style)\n        return style == \"deepObject\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "param_name"
      ],
      "imports": [
        "abc",
        "json",
        "logging",
        "re",
        "connexion.exceptions.TypeValidationError",
        "connexion.utils.all_json",
        "connexion.utils.coerce_type",
        "connexion.utils.deep_merge"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.param_defns.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "_preprocess_deep_objects",
      "module": "uri_parsing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\uri_parsing.py",
      "line_number": 204,
      "end_line_number": 216,
      "source_code": "def _preprocess_deep_objects(self, query_data):\n        \"\"\"deep objects provide a way of rendering nested objects using query\n        parameters.\n        \"\"\"\n        deep = [self._make_deep_object(k, v) for k, v in query_data.items()]\n        root_keys = [k for k, v, is_deep_object in deep]\n        ret = dict.fromkeys(root_keys, [{}])\n        for k, v, is_deep_object in deep:\n            if is_deep_object:\n                ret[k] = [deep_merge(v[0], ret[k][0])]\n            else:\n                ret[k] = v\n        return ret",
      "docstring": "deep objects provide a way of rendering nested objects using query\nparameters.",
      "decorators": [],
      "arguments": [
        "self",
        "query_data"
      ],
      "imports": [
        "abc",
        "json",
        "logging",
        "re",
        "connexion.exceptions.TypeValidationError",
        "connexion.utils.all_json",
        "connexion.utils.coerce_type",
        "connexion.utils.deep_merge"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._make_deep_object",
          "body": "def _make_deep_object(self, k, v):\n    \"\"\"consumes keys, value pairs like (a[foo][bar], \"baz\")\n        returns (a, {\"foo\": {\"bar\": \"baz\"}}}, is_deep_object)\n        \"\"\"\n    root_key = None\n    if k in self.param_schemas.keys():\n        return (k, v, False)\n    else:\n        for key in self.param_schemas.keys():\n            if k.startswith(key) and '[' in k:\n                root_key = key.replace(k, '')\n    if not root_key:\n        root_key = k.split('[', 1)[0]\n        if k == root_key:\n            return (k, v, False)\n    if not self._is_deep_object_style_param(root_key):\n        return (k, v, False)\n    key_path = re.findall('\\\\[([^\\\\[\\\\]]*)\\\\]', k)\n    root = prev = node = {}\n    for k in key_path:\n        node[k] = {}\n        prev = node\n        node = node[k]\n    prev[k] = v[0]\n    return (root_key, [root], True)"
        },
        {
          "name": "deep_merge",
          "body": "def deep_merge(a, b):\n    \"\"\"merges b into a\n    in case of conflict the value from b is used\n    \"\"\"\n    for key in b:\n        if key in a:\n            if isinstance(a[key], dict) and isinstance(b[key], dict):\n                deep_merge(a[key], b[key])\n            elif a[key] == b[key]:\n                pass\n            else:\n                a[key] = b[key]\n        else:\n            a[key] = b[key]\n    return a"
        }
      ]
    },
    {
      "name": "resolve_query",
      "module": "uri_parsing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\uri_parsing.py",
      "line_number": 218,
      "end_line_number": 220,
      "source_code": "def resolve_query(self, query_data):\n        query_data = self._preprocess_deep_objects(query_data)\n        return self.resolve_params(query_data, \"query\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "query_data"
      ],
      "imports": [
        "abc",
        "json",
        "logging",
        "re",
        "connexion.exceptions.TypeValidationError",
        "connexion.utils.all_json",
        "connexion.utils.coerce_type",
        "connexion.utils.deep_merge"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._preprocess_deep_objects",
          "body": "def _preprocess_deep_objects(self, query_data):\n    \"\"\"deep objects provide a way of rendering nested objects using query\n        parameters.\n        \"\"\"\n    deep = [self._make_deep_object(k, v) for k, v in query_data.items()]\n    root_keys = [k for k, v, is_deep_object in deep]\n    ret = dict.fromkeys(root_keys, [{}])\n    for k, v, is_deep_object in deep:\n        if is_deep_object:\n            ret[k] = [deep_merge(v[0], ret[k][0])]\n        else:\n            ret[k] = v\n    return ret"
        },
        {
          "name": "self.resolve_params",
          "body": "def resolve_params(self, params, _in):\n    \"\"\"\n        takes a dict of parameters, and resolves the values into\n        the correct array type handling duplicate values, and splitting\n        based on the collectionFormat defined in the spec.\n        \"\"\"\n    resolved_param = {}\n    for k, values in params.items():\n        param_defn = self.param_defns.get(k)\n        param_schema = self.param_schemas.get(k)\n        if not (param_defn or param_schema):\n            resolved_param[k] = values\n            continue\n        if _in == 'path':\n            values = [values]\n        if param_schema and param_schema['type'] == 'array':\n            values = self._resolve_param_duplicates(values, param_defn, _in)\n            resolved_param[k] = self._split(values, param_defn, _in)\n        else:\n            resolved_param[k] = values[-1]\n        try:\n            resolved_param[k] = coerce_type(param_defn, resolved_param[k], 'parameter', k)\n        except TypeValidationError:\n            pass\n    return resolved_param"
        }
      ]
    },
    {
      "name": "resolve_path",
      "module": "uri_parsing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\uri_parsing.py",
      "line_number": 222,
      "end_line_number": 223,
      "source_code": "def resolve_path(self, path_data):\n        return self.resolve_params(path_data, \"path\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "path_data"
      ],
      "imports": [
        "abc",
        "json",
        "logging",
        "re",
        "connexion.exceptions.TypeValidationError",
        "connexion.utils.all_json",
        "connexion.utils.coerce_type",
        "connexion.utils.deep_merge"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.resolve_params",
          "body": "def resolve_params(self, params, _in):\n    \"\"\"\n        takes a dict of parameters, and resolves the values into\n        the correct array type handling duplicate values, and splitting\n        based on the collectionFormat defined in the spec.\n        \"\"\"\n    resolved_param = {}\n    for k, values in params.items():\n        param_defn = self.param_defns.get(k)\n        param_schema = self.param_schemas.get(k)\n        if not (param_defn or param_schema):\n            resolved_param[k] = values\n            continue\n        if _in == 'path':\n            values = [values]\n        if param_schema and param_schema['type'] == 'array':\n            values = self._resolve_param_duplicates(values, param_defn, _in)\n            resolved_param[k] = self._split(values, param_defn, _in)\n        else:\n            resolved_param[k] = values[-1]\n        try:\n            resolved_param[k] = coerce_type(param_defn, resolved_param[k], 'parameter', k)\n        except TypeValidationError:\n            pass\n    return resolved_param"
        }
      ]
    },
    {
      "name": "_resolve_param_duplicates",
      "module": "uri_parsing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\uri_parsing.py",
      "line_number": 226,
      "end_line_number": 243,
      "source_code": "def _resolve_param_duplicates(values, param_defn, _in):\n        \"\"\"Resolve cases where query parameters are provided multiple times.\n        The default behavior is to use the first-defined value.\n        For example, if the query string is '?a=1,2,3&a=4,5,6' the value of\n        `a` would be \"4,5,6\".\n        However, if 'explode' is 'True' then the duplicate values\n        are concatenated together and `a` would be \"1,2,3,4,5,6\".\n        \"\"\"\n        default_style = OpenAPIURIParser.style_defaults[_in]\n        style = param_defn.get(\"style\", default_style)\n        delimiter = QUERY_STRING_DELIMITERS.get(style, \",\")\n        is_form = style == \"form\"\n        explode = param_defn.get(\"explode\", is_form)\n        if explode:\n            return delimiter.join(values)\n\n        # default to last defined value\n        return values[-1]",
      "docstring": "Resolve cases where query parameters are provided multiple times.\nThe default behavior is to use the first-defined value.\nFor example, if the query string is '?a=1,2,3&a=4,5,6' the value of\n`a` would be \"4,5,6\".\nHowever, if 'explode' is 'True' then the duplicate values\nare concatenated together and `a` would be \"1,2,3,4,5,6\".",
      "decorators": [
        "staticmethod"
      ],
      "arguments": [
        "values",
        "param_defn",
        "_in"
      ],
      "imports": [
        "abc",
        "json",
        "logging",
        "re",
        "connexion.exceptions.TypeValidationError",
        "connexion.utils.all_json",
        "connexion.utils.coerce_type",
        "connexion.utils.deep_merge"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "param_defn.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "QUERY_STRING_DELIMITERS.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "param_defn.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "_split",
      "module": "uri_parsing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\uri_parsing.py",
      "line_number": 246,
      "end_line_number": 250,
      "source_code": "def _split(value, param_defn, _in):\n        default_style = OpenAPIURIParser.style_defaults[_in]\n        style = param_defn.get(\"style\", default_style)\n        delimiter = QUERY_STRING_DELIMITERS.get(style, \",\")\n        return value.split(delimiter)",
      "docstring": null,
      "decorators": [
        "staticmethod"
      ],
      "arguments": [
        "value",
        "param_defn",
        "_in"
      ],
      "imports": [
        "abc",
        "json",
        "logging",
        "re",
        "connexion.exceptions.TypeValidationError",
        "connexion.utils.all_json",
        "connexion.utils.coerce_type",
        "connexion.utils.deep_merge"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "param_defn.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "QUERY_STRING_DELIMITERS.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "param_defns",
      "module": "uri_parsing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\uri_parsing.py",
      "line_number": 262,
      "end_line_number": 263,
      "source_code": "def param_defns(self):\n        return self._param_defns",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "json",
        "logging",
        "re",
        "connexion.exceptions.TypeValidationError",
        "connexion.utils.all_json",
        "connexion.utils.coerce_type",
        "connexion.utils.deep_merge"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "param_schemas",
      "module": "uri_parsing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\uri_parsing.py",
      "line_number": 266,
      "end_line_number": 267,
      "source_code": "def param_schemas(self):\n        return self._param_defns",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "json",
        "logging",
        "re",
        "connexion.exceptions.TypeValidationError",
        "connexion.utils.all_json",
        "connexion.utils.coerce_type",
        "connexion.utils.deep_merge"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "resolve_form",
      "module": "uri_parsing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\uri_parsing.py",
      "line_number": 269,
      "end_line_number": 270,
      "source_code": "def resolve_form(self, form_data):\n        return self.resolve_params(form_data, \"form\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "form_data"
      ],
      "imports": [
        "abc",
        "json",
        "logging",
        "re",
        "connexion.exceptions.TypeValidationError",
        "connexion.utils.all_json",
        "connexion.utils.coerce_type",
        "connexion.utils.deep_merge"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.resolve_params",
          "body": "def resolve_params(self, params, _in):\n    \"\"\"\n        takes a dict of parameters, and resolves the values into\n        the correct array type handling duplicate values, and splitting\n        based on the collectionFormat defined in the spec.\n        \"\"\"\n    resolved_param = {}\n    for k, values in params.items():\n        param_defn = self.param_defns.get(k)\n        param_schema = self.param_schemas.get(k)\n        if not (param_defn or param_schema):\n            resolved_param[k] = values\n            continue\n        if _in == 'path':\n            values = [values]\n        if param_schema and param_schema['type'] == 'array':\n            values = self._resolve_param_duplicates(values, param_defn, _in)\n            resolved_param[k] = self._split(values, param_defn, _in)\n        else:\n            resolved_param[k] = values[-1]\n        try:\n            resolved_param[k] = coerce_type(param_defn, resolved_param[k], 'parameter', k)\n        except TypeValidationError:\n            pass\n    return resolved_param"
        }
      ]
    },
    {
      "name": "resolve_query",
      "module": "uri_parsing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\uri_parsing.py",
      "line_number": 272,
      "end_line_number": 273,
      "source_code": "def resolve_query(self, query_data):\n        return self.resolve_params(query_data, \"query\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "query_data"
      ],
      "imports": [
        "abc",
        "json",
        "logging",
        "re",
        "connexion.exceptions.TypeValidationError",
        "connexion.utils.all_json",
        "connexion.utils.coerce_type",
        "connexion.utils.deep_merge"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.resolve_params",
          "body": "def resolve_params(self, params, _in):\n    \"\"\"\n        takes a dict of parameters, and resolves the values into\n        the correct array type handling duplicate values, and splitting\n        based on the collectionFormat defined in the spec.\n        \"\"\"\n    resolved_param = {}\n    for k, values in params.items():\n        param_defn = self.param_defns.get(k)\n        param_schema = self.param_schemas.get(k)\n        if not (param_defn or param_schema):\n            resolved_param[k] = values\n            continue\n        if _in == 'path':\n            values = [values]\n        if param_schema and param_schema['type'] == 'array':\n            values = self._resolve_param_duplicates(values, param_defn, _in)\n            resolved_param[k] = self._split(values, param_defn, _in)\n        else:\n            resolved_param[k] = values[-1]\n        try:\n            resolved_param[k] = coerce_type(param_defn, resolved_param[k], 'parameter', k)\n        except TypeValidationError:\n            pass\n    return resolved_param"
        }
      ]
    },
    {
      "name": "resolve_path",
      "module": "uri_parsing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\uri_parsing.py",
      "line_number": 275,
      "end_line_number": 276,
      "source_code": "def resolve_path(self, path_data):\n        return self.resolve_params(path_data, \"path\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "path_data"
      ],
      "imports": [
        "abc",
        "json",
        "logging",
        "re",
        "connexion.exceptions.TypeValidationError",
        "connexion.utils.all_json",
        "connexion.utils.coerce_type",
        "connexion.utils.deep_merge"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.resolve_params",
          "body": "def resolve_params(self, params, _in):\n    \"\"\"\n        takes a dict of parameters, and resolves the values into\n        the correct array type handling duplicate values, and splitting\n        based on the collectionFormat defined in the spec.\n        \"\"\"\n    resolved_param = {}\n    for k, values in params.items():\n        param_defn = self.param_defns.get(k)\n        param_schema = self.param_schemas.get(k)\n        if not (param_defn or param_schema):\n            resolved_param[k] = values\n            continue\n        if _in == 'path':\n            values = [values]\n        if param_schema and param_schema['type'] == 'array':\n            values = self._resolve_param_duplicates(values, param_defn, _in)\n            resolved_param[k] = self._split(values, param_defn, _in)\n        else:\n            resolved_param[k] = values[-1]\n        try:\n            resolved_param[k] = coerce_type(param_defn, resolved_param[k], 'parameter', k)\n        except TypeValidationError:\n            pass\n    return resolved_param"
        }
      ]
    },
    {
      "name": "_resolve_param_duplicates",
      "module": "uri_parsing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\uri_parsing.py",
      "line_number": 279,
      "end_line_number": 290,
      "source_code": "def _resolve_param_duplicates(values, param_defn, _in):\n        \"\"\"Resolve cases where query parameters are provided multiple times.\n        The default behavior is to use the first-defined value.\n        For example, if the query string is '?a=1,2,3&a=4,5,6' the value of\n        `a` would be \"4,5,6\".\n        However, if 'collectionFormat' is 'multi' then the duplicate values\n        are concatenated together and `a` would be \"1,2,3,4,5,6\".\n        \"\"\"\n        if param_defn.get(\"collectionFormat\") == \"multi\":\n            return \",\".join(values)\n        # default to last defined value\n        return values[-1]",
      "docstring": "Resolve cases where query parameters are provided multiple times.\nThe default behavior is to use the first-defined value.\nFor example, if the query string is '?a=1,2,3&a=4,5,6' the value of\n`a` would be \"4,5,6\".\nHowever, if 'collectionFormat' is 'multi' then the duplicate values\nare concatenated together and `a` would be \"1,2,3,4,5,6\".",
      "decorators": [
        "staticmethod"
      ],
      "arguments": [
        "values",
        "param_defn",
        "_in"
      ],
      "imports": [
        "abc",
        "json",
        "logging",
        "re",
        "connexion.exceptions.TypeValidationError",
        "connexion.utils.all_json",
        "connexion.utils.coerce_type",
        "connexion.utils.deep_merge"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "param_defn.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "_split",
      "module": "uri_parsing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\uri_parsing.py",
      "line_number": 293,
      "end_line_number": 296,
      "source_code": "def _split(value, param_defn, _in):\n        if param_defn.get(\"collectionFormat\") == \"pipes\":\n            return value.split(\"|\")\n        return value.split(\",\")",
      "docstring": null,
      "decorators": [
        "staticmethod"
      ],
      "arguments": [
        "value",
        "param_defn",
        "_in"
      ],
      "imports": [
        "abc",
        "json",
        "logging",
        "re",
        "connexion.exceptions.TypeValidationError",
        "connexion.utils.all_json",
        "connexion.utils.coerce_type",
        "connexion.utils.deep_merge"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "param_defn.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "_resolve_param_duplicates",
      "module": "uri_parsing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\uri_parsing.py",
      "line_number": 306,
      "end_line_number": 317,
      "source_code": "def _resolve_param_duplicates(values, param_defn, _in):\n        \"\"\"Resolve cases where query parameters are provided multiple times.\n        The default behavior is to use the first-defined value.\n        For example, if the query string is '?a=1,2,3&a=4,5,6' the value of\n        `a` would be \"1,2,3\".\n        However, if 'collectionFormat' is 'multi' then the duplicate values\n        are concatenated together and `a` would be \"1,2,3,4,5,6\".\n        \"\"\"\n        if param_defn.get(\"collectionFormat\") == \"multi\":\n            return \",\".join(values)\n        # default to first defined value\n        return values[0]",
      "docstring": "Resolve cases where query parameters are provided multiple times.\nThe default behavior is to use the first-defined value.\nFor example, if the query string is '?a=1,2,3&a=4,5,6' the value of\n`a` would be \"1,2,3\".\nHowever, if 'collectionFormat' is 'multi' then the duplicate values\nare concatenated together and `a` would be \"1,2,3,4,5,6\".",
      "decorators": [
        "staticmethod"
      ],
      "arguments": [
        "values",
        "param_defn",
        "_in"
      ],
      "imports": [
        "abc",
        "json",
        "logging",
        "re",
        "connexion.exceptions.TypeValidationError",
        "connexion.utils.all_json",
        "connexion.utils.coerce_type",
        "connexion.utils.deep_merge"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "param_defn.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "_resolve_param_duplicates",
      "module": "uri_parsing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\uri_parsing.py",
      "line_number": 327,
      "end_line_number": 335,
      "source_code": "def _resolve_param_duplicates(values, param_defn, _in):\n        \"\"\"Resolve cases where query parameters are provided multiple times.\n        The default behavior is to join all provided parameters together.\n        For example, if the query string is '?a=1,2,3&a=4,5,6' the value of\n        `a` would be \"1,2,3,4,5,6\".\n        \"\"\"\n        if param_defn.get(\"collectionFormat\") == \"pipes\":\n            return \"|\".join(values)\n        return \",\".join(values)",
      "docstring": "Resolve cases where query parameters are provided multiple times.\nThe default behavior is to join all provided parameters together.\nFor example, if the query string is '?a=1,2,3&a=4,5,6' the value of\n`a` would be \"1,2,3,4,5,6\".",
      "decorators": [
        "staticmethod"
      ],
      "arguments": [
        "values",
        "param_defn",
        "_in"
      ],
      "imports": [
        "abc",
        "json",
        "logging",
        "re",
        "connexion.exceptions.TypeValidationError",
        "connexion.utils.all_json",
        "connexion.utils.coerce_type",
        "connexion.utils.deep_merge"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "param_defn.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "boolean",
      "module": "utils",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\utils.py",
      "line_number": 23,
      "end_line_number": 42,
      "source_code": "def boolean(s):\n    \"\"\"\n    Convert JSON/Swagger boolean value to Python, raise ValueError otherwise\n\n    >>> boolean('true')\n    True\n\n    >>> boolean('false')\n    False\n    \"\"\"\n    if isinstance(s, bool):\n        return s\n    elif not hasattr(s, \"lower\"):\n        raise ValueError(\"Invalid boolean value\")\n    elif s.lower() == \"true\":\n        return True\n    elif s.lower() == \"false\":\n        return False\n    else:\n        raise ValueError(\"Invalid boolean value\")",
      "docstring": "Convert JSON/Swagger boolean value to Python, raise ValueError otherwise\n\n>>> boolean('true')\nTrue\n\n>>> boolean('false')\nFalse",
      "decorators": [],
      "arguments": [
        "s"
      ],
      "imports": [
        "asyncio",
        "functools",
        "importlib",
        "inspect",
        "os",
        "pkgutil",
        "sys",
        "typing",
        "yaml",
        "starlette.routing.compile_path",
        "connexion.exceptions.TypeValidationError",
        "connexion.middleware.main.API",
        "jsf.JSF"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "make_type",
      "module": "utils",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\utils.py",
      "line_number": 57,
      "end_line_number": 64,
      "source_code": "def make_type(value: t.Any, type_: str, format_: t.Optional[str]) -> t.Any:\n    \"\"\"Cast a value to the type defined in the specification.\"\"\"\n    # In OpenAPI, files are represented with string type and binary format\n    if type_ == \"string\" and format_ == \"binary\":\n        type_ = \"file\"\n\n    type_func = TYPE_MAP[type_]\n    return type_func(value)",
      "docstring": "Cast a value to the type defined in the specification.",
      "decorators": [],
      "arguments": [
        "value",
        "type_",
        "format_"
      ],
      "imports": [
        "asyncio",
        "functools",
        "importlib",
        "inspect",
        "os",
        "pkgutil",
        "sys",
        "typing",
        "yaml",
        "starlette.routing.compile_path",
        "connexion.exceptions.TypeValidationError",
        "connexion.middleware.main.API",
        "jsf.JSF"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "deep_merge",
      "module": "utils",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\utils.py",
      "line_number": 67,
      "end_line_number": 82,
      "source_code": "def deep_merge(a, b):\n    \"\"\"merges b into a\n    in case of conflict the value from b is used\n    \"\"\"\n    for key in b:\n        if key in a:\n            if isinstance(a[key], dict) and isinstance(b[key], dict):\n                deep_merge(a[key], b[key])\n            elif a[key] == b[key]:\n                pass\n            else:\n                # b overwrites a\n                a[key] = b[key]\n        else:\n            a[key] = b[key]\n    return a",
      "docstring": "merges b into a\nin case of conflict the value from b is used",
      "decorators": [],
      "arguments": [
        "a",
        "b"
      ],
      "imports": [
        "asyncio",
        "functools",
        "importlib",
        "inspect",
        "os",
        "pkgutil",
        "sys",
        "typing",
        "yaml",
        "starlette.routing.compile_path",
        "connexion.exceptions.TypeValidationError",
        "connexion.middleware.main.API",
        "jsf.JSF"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "deep_merge",
          "body": "def deep_merge(a, b):\n    \"\"\"merges b into a\n    in case of conflict the value from b is used\n    \"\"\"\n    for key in b:\n        if key in a:\n            if isinstance(a[key], dict) and isinstance(b[key], dict):\n                deep_merge(a[key], b[key])\n            elif a[key] == b[key]:\n                pass\n            else:\n                a[key] = b[key]\n        else:\n            a[key] = b[key]\n    return a"
        }
      ]
    },
    {
      "name": "deep_getattr",
      "module": "utils",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\utils.py",
      "line_number": 85,
      "end_line_number": 92,
      "source_code": "def deep_getattr(obj, attr):\n    \"\"\"\n    Recurses through an attribute chain to get the ultimate value.\n    \"\"\"\n\n    attrs = attr.split(\".\")\n\n    return functools.reduce(getattr, attrs, obj)",
      "docstring": "Recurses through an attribute chain to get the ultimate value.",
      "decorators": [],
      "arguments": [
        "obj",
        "attr"
      ],
      "imports": [
        "asyncio",
        "functools",
        "importlib",
        "inspect",
        "os",
        "pkgutil",
        "sys",
        "typing",
        "yaml",
        "starlette.routing.compile_path",
        "connexion.exceptions.TypeValidationError",
        "connexion.middleware.main.API",
        "jsf.JSF"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "deep_get",
      "module": "utils",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\utils.py",
      "line_number": 95,
      "end_line_number": 112,
      "source_code": "def deep_get(obj, keys):\n    \"\"\"\n    Recurses through a nested object get a leaf value.\n\n    There are cases where the use of inheritance or polymorphism-- the use of allOf or\n    oneOf keywords-- will cause the obj to be a list. In this case the keys will\n    contain one or more strings containing integers.\n\n    :type obj: list or dict\n    :type keys: list of strings\n    \"\"\"\n    if not keys:\n        return obj\n\n    if isinstance(obj, list):\n        return deep_get(obj[int(keys[0])], keys[1:])\n    else:\n        return deep_get(obj[keys[0]], keys[1:])",
      "docstring": "Recurses through a nested object get a leaf value.\n\nThere are cases where the use of inheritance or polymorphism-- the use of allOf or\noneOf keywords-- will cause the obj to be a list. In this case the keys will\ncontain one or more strings containing integers.\n\n:type obj: list or dict\n:type keys: list of strings",
      "decorators": [],
      "arguments": [
        "obj",
        "keys"
      ],
      "imports": [
        "asyncio",
        "functools",
        "importlib",
        "inspect",
        "os",
        "pkgutil",
        "sys",
        "typing",
        "yaml",
        "starlette.routing.compile_path",
        "connexion.exceptions.TypeValidationError",
        "connexion.middleware.main.API",
        "jsf.JSF"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "deep_get",
          "body": "def deep_get(obj, keys):\n    \"\"\"\n    Recurses through a nested object get a leaf value.\n\n    There are cases where the use of inheritance or polymorphism-- the use of allOf or\n    oneOf keywords-- will cause the obj to be a list. In this case the keys will\n    contain one or more strings containing integers.\n\n    :type obj: list or dict\n    :type keys: list of strings\n    \"\"\"\n    if not keys:\n        return obj\n    if isinstance(obj, list):\n        return deep_get(obj[int(keys[0])], keys[1:])\n    else:\n        return deep_get(obj[keys[0]], keys[1:])"
        },
        {
          "name": "deep_get",
          "body": "def deep_get(obj, keys):\n    \"\"\"\n    Recurses through a nested object get a leaf value.\n\n    There are cases where the use of inheritance or polymorphism-- the use of allOf or\n    oneOf keywords-- will cause the obj to be a list. In this case the keys will\n    contain one or more strings containing integers.\n\n    :type obj: list or dict\n    :type keys: list of strings\n    \"\"\"\n    if not keys:\n        return obj\n    if isinstance(obj, list):\n        return deep_get(obj[int(keys[0])], keys[1:])\n    else:\n        return deep_get(obj[keys[0]], keys[1:])"
        }
      ]
    },
    {
      "name": "get_function_from_name",
      "module": "utils",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\utils.py",
      "line_number": 115,
      "end_line_number": 150,
      "source_code": "def get_function_from_name(function_name):\n    \"\"\"\n    Tries to get function by fully qualified name (e.g. \"mymodule.myobj.myfunc\")\n\n    :type function_name: str\n    \"\"\"\n    if function_name is None:\n        raise ValueError(\"Empty function name\")\n\n    if \".\" in function_name:\n        module_name, attr_path = function_name.rsplit(\".\", 1)\n    else:\n        module_name = \"\"\n        attr_path = function_name\n\n    module = None\n    last_import_error = None\n\n    while not module:\n        try:\n            module = importlib.import_module(module_name)\n        except ImportError as import_error:\n            last_import_error = import_error\n            if \".\" in module_name:\n                module_name, attr_path1 = module_name.rsplit(\".\", 1)\n                attr_path = f\"{attr_path1}.{attr_path}\"\n            else:\n                raise\n    try:\n        function = deep_getattr(module, attr_path)\n    except AttributeError:\n        if last_import_error:\n            raise last_import_error\n        else:\n            raise\n    return function",
      "docstring": "Tries to get function by fully qualified name (e.g. \"mymodule.myobj.myfunc\")\n\n:type function_name: str",
      "decorators": [],
      "arguments": [
        "function_name"
      ],
      "imports": [
        "asyncio",
        "functools",
        "importlib",
        "inspect",
        "os",
        "pkgutil",
        "sys",
        "typing",
        "yaml",
        "starlette.routing.compile_path",
        "connexion.exceptions.TypeValidationError",
        "connexion.middleware.main.API",
        "jsf.JSF"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "deep_getattr",
          "body": "def deep_getattr(obj, attr):\n    \"\"\"\n    Recurses through an attribute chain to get the ultimate value.\n    \"\"\"\n    attrs = attr.split('.')\n    return functools.reduce(getattr, attrs, obj)"
        }
      ]
    },
    {
      "name": "is_json_mimetype",
      "module": "utils",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\utils.py",
      "line_number": 153,
      "end_line_number": 166,
      "source_code": "def is_json_mimetype(mimetype):\n    \"\"\"\n    :type mimetype: str\n    :rtype: bool\n    \"\"\"\n    if mimetype is None:\n        return False\n\n    maintype, subtype = mimetype.split(\"/\")  # type: str, str\n    if \";\" in subtype:\n        subtype, parameter = subtype.split(\";\", maxsplit=1)\n    return maintype == \"application\" and (\n        subtype == \"json\" or subtype.endswith(\"+json\")\n    )",
      "docstring": ":type mimetype: str\n:rtype: bool",
      "decorators": [],
      "arguments": [
        "mimetype"
      ],
      "imports": [
        "asyncio",
        "functools",
        "importlib",
        "inspect",
        "os",
        "pkgutil",
        "sys",
        "typing",
        "yaml",
        "starlette.routing.compile_path",
        "connexion.exceptions.TypeValidationError",
        "connexion.middleware.main.API",
        "jsf.JSF"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "all_json",
      "module": "utils",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\utils.py",
      "line_number": 169,
      "end_line_number": 191,
      "source_code": "def all_json(mimetypes):\n    \"\"\"\n    Returns True if all mimetypes are serialized with json\n\n    :type mimetypes: list\n    :rtype: bool\n\n    >>> all_json(['application/json'])\n    True\n    >>> all_json(['application/x.custom+json'])\n    True\n    >>> all_json([])\n    True\n    >>> all_json(['application/xml'])\n    False\n    >>> all_json(['text/json'])\n    False\n    >>> all_json(['application/json', 'other/type'])\n    False\n    >>> all_json(['application/json', 'application/x.custom+json'])\n    True\n    \"\"\"\n    return all(is_json_mimetype(mimetype) for mimetype in mimetypes)",
      "docstring": "Returns True if all mimetypes are serialized with json\n\n:type mimetypes: list\n:rtype: bool\n\n>>> all_json(['application/json'])\nTrue\n>>> all_json(['application/x.custom+json'])\nTrue\n>>> all_json([])\nTrue\n>>> all_json(['application/xml'])\nFalse\n>>> all_json(['text/json'])\nFalse\n>>> all_json(['application/json', 'other/type'])\nFalse\n>>> all_json(['application/json', 'application/x.custom+json'])\nTrue",
      "decorators": [],
      "arguments": [
        "mimetypes"
      ],
      "imports": [
        "asyncio",
        "functools",
        "importlib",
        "inspect",
        "os",
        "pkgutil",
        "sys",
        "typing",
        "yaml",
        "starlette.routing.compile_path",
        "connexion.exceptions.TypeValidationError",
        "connexion.middleware.main.API",
        "jsf.JSF"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "is_json_mimetype",
          "body": "def is_json_mimetype(mimetype):\n    \"\"\"\n    :type mimetype: str\n    :rtype: bool\n    \"\"\"\n    if mimetype is None:\n        return False\n    maintype, subtype = mimetype.split('/')\n    if ';' in subtype:\n        subtype, parameter = subtype.split(';', maxsplit=1)\n    return maintype == 'application' and (subtype == 'json' or subtype.endswith('+json'))"
        }
      ]
    },
    {
      "name": "is_nullable",
      "module": "utils",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\utils.py",
      "line_number": 194,
      "end_line_number": 197,
      "source_code": "def is_nullable(param_def):\n    return param_def.get(\"schema\", param_def).get(\"nullable\", False) or param_def.get(\n        \"x-nullable\", False\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "param_def"
      ],
      "imports": [
        "asyncio",
        "functools",
        "importlib",
        "inspect",
        "os",
        "pkgutil",
        "sys",
        "typing",
        "yaml",
        "starlette.routing.compile_path",
        "connexion.exceptions.TypeValidationError",
        "connexion.middleware.main.API",
        "jsf.JSF"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "param_def.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "param_def.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "is_null",
      "module": "utils",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\utils.py",
      "line_number": 200,
      "end_line_number": 207,
      "source_code": "def is_null(value):\n    if hasattr(value, \"strip\") and value.strip() in [\"null\", \"None\"]:\n        return True\n\n    if value is None:\n        return True\n\n    return False",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "value"
      ],
      "imports": [
        "asyncio",
        "functools",
        "importlib",
        "inspect",
        "os",
        "pkgutil",
        "sys",
        "typing",
        "yaml",
        "starlette.routing.compile_path",
        "connexion.exceptions.TypeValidationError",
        "connexion.middleware.main.API",
        "jsf.JSF"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "has_coroutine",
      "module": "utils",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\utils.py",
      "line_number": 210,
      "end_line_number": 228,
      "source_code": "def has_coroutine(function, api=None):\n    \"\"\"\n    Checks if function is a coroutine.\n    If ``function`` is a decorator (has a ``__wrapped__`` attribute)\n    this function will also look at the wrapped function.\n    \"\"\"\n\n    def iscorofunc(func):\n        iscorofunc = asyncio.iscoroutinefunction(func)\n        while not iscorofunc and hasattr(func, \"__wrapped__\"):\n            func = func.__wrapped__\n            iscorofunc = asyncio.iscoroutinefunction(func)\n        return iscorofunc\n\n    if api is None:\n        return iscorofunc(function)\n\n    else:\n        return any(iscorofunc(func) for func in (function, api.get_response))",
      "docstring": "Checks if function is a coroutine.\nIf ``function`` is a decorator (has a ``__wrapped__`` attribute)\nthis function will also look at the wrapped function.",
      "decorators": [],
      "arguments": [
        "function",
        "api"
      ],
      "imports": [
        "asyncio",
        "functools",
        "importlib",
        "inspect",
        "os",
        "pkgutil",
        "sys",
        "typing",
        "yaml",
        "starlette.routing.compile_path",
        "connexion.exceptions.TypeValidationError",
        "connexion.middleware.main.API",
        "jsf.JSF"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "iscorofunc",
          "body": "def iscorofunc(func):\n    iscorofunc = asyncio.iscoroutinefunction(func)\n    while not iscorofunc and hasattr(func, '__wrapped__'):\n        func = func.__wrapped__\n        iscorofunc = asyncio.iscoroutinefunction(func)\n    return iscorofunc"
        },
        {
          "name": "iscorofunc",
          "body": "def iscorofunc(func):\n    iscorofunc = asyncio.iscoroutinefunction(func)\n    while not iscorofunc and hasattr(func, '__wrapped__'):\n        func = func.__wrapped__\n        iscorofunc = asyncio.iscoroutinefunction(func)\n    return iscorofunc"
        }
      ]
    },
    {
      "name": "yamldumper",
      "module": "utils",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\utils.py",
      "line_number": 231,
      "end_line_number": 276,
      "source_code": "def yamldumper(openapi):\n    \"\"\"\n    Returns a nicely-formatted yaml spec.\n    :param openapi: a spec dictionary.\n    :return: a nicely-formatted, serialized yaml spec.\n    \"\"\"\n\n    def should_use_block(value):\n        char_list = (\n            \"\\u000a\"  # line feed\n            \"\\u000d\"  # carriage return\n            \"\\u001c\"  # file separator\n            \"\\u001d\"  # group separator\n            \"\\u001e\"  # record separator\n            \"\\u0085\"  # next line\n            \"\\u2028\"  # line separator\n            \"\\u2029\"  # paragraph separator\n        )\n        for c in char_list:\n            if c in value:\n                return True\n        return False\n\n    def my_represent_scalar(self, tag, value, style=None):\n        if should_use_block(value):\n            style = \"|\"\n        else:\n            style = self.default_style\n\n        node = yaml.representer.ScalarNode(tag, value, style=style)\n        if self.alias_key is not None:\n            self.represented_objects[self.alias_key] = node\n        return node\n\n    class NoAnchorDumper(yaml.dumper.SafeDumper):\n        \"\"\"A yaml Dumper that does not replace duplicate entries\n        with yaml anchors.\n        \"\"\"\n\n        def ignore_aliases(self, *args):\n            return True\n\n    # Dump long lines as \"|\".\n    yaml.representer.SafeRepresenter.represent_scalar = my_represent_scalar\n\n    return yaml.dump(openapi, allow_unicode=True, Dumper=NoAnchorDumper)",
      "docstring": "Returns a nicely-formatted yaml spec.\n:param openapi: a spec dictionary.\n:return: a nicely-formatted, serialized yaml spec.",
      "decorators": [],
      "arguments": [
        "openapi"
      ],
      "imports": [
        "asyncio",
        "functools",
        "importlib",
        "inspect",
        "os",
        "pkgutil",
        "sys",
        "typing",
        "yaml",
        "starlette.routing.compile_path",
        "connexion.exceptions.TypeValidationError",
        "connexion.middleware.main.API",
        "jsf.JSF"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "should_use_block",
          "body": "def should_use_block(value):\n    char_list = '\\n\\r\\x1c\\x1d\\x1e\\x85\\u2028\\u2029'\n    for c in char_list:\n        if c in value:\n            return True\n    return False"
        }
      ]
    },
    {
      "name": "not_installed_error",
      "module": "utils",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\utils.py",
      "line_number": 279,
      "end_line_number": 287,
      "source_code": "def not_installed_error(exc, *, msg=None):  # pragma: no cover\n    \"\"\"Raises the ImportError when the module/object is actually called with a custom message.\"\"\"\n\n    def _delayed_error(*args, **kwargs):\n        if msg is not None:\n            raise type(exc)(msg).with_traceback(exc.__traceback__)\n        raise exc\n\n    return _delayed_error",
      "docstring": "Raises the ImportError when the module/object is actually called with a custom message.",
      "decorators": [],
      "arguments": [
        "exc"
      ],
      "imports": [
        "asyncio",
        "functools",
        "importlib",
        "inspect",
        "os",
        "pkgutil",
        "sys",
        "typing",
        "yaml",
        "starlette.routing.compile_path",
        "connexion.exceptions.TypeValidationError",
        "connexion.middleware.main.API",
        "jsf.JSF"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "extract_content_type",
      "module": "utils",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\utils.py",
      "line_number": 290,
      "end_line_number": 318,
      "source_code": "def extract_content_type(\n    headers: t.Union[t.List[t.Tuple[bytes, bytes]], t.Dict[str, str]]\n) -> t.Optional[str]:\n    \"\"\"Extract the mime type and encoding from the content type headers.\n\n    :param headers: Headers from ASGI scope\n\n    :return: The content type if available in headers, otherwise None\n    \"\"\"\n    content_type: t.Optional[str] = None\n\n    header_pairs_type = t.Collection[t.Tuple[t.Union[str, bytes], t.Union[str, bytes]]]\n    header_pairs: header_pairs_type = headers.items() if isinstance(headers, dict) else headers  # type: ignore\n    for key, value in header_pairs:\n        # Headers can always be decoded using latin-1:\n        # https://stackoverflow.com/a/27357138/4098821\n        if isinstance(key, bytes):\n            decoded_key: str = key.decode(\"latin-1\")\n        else:\n            decoded_key = key\n\n        if decoded_key.lower() == \"content-type\":\n            if isinstance(value, bytes):\n                content_type = value.decode(\"latin-1\")\n            else:\n                content_type = value\n            break\n\n    return content_type",
      "docstring": "Extract the mime type and encoding from the content type headers.\n\n:param headers: Headers from ASGI scope\n\n:return: The content type if available in headers, otherwise None",
      "decorators": [],
      "arguments": [
        "headers"
      ],
      "imports": [
        "asyncio",
        "functools",
        "importlib",
        "inspect",
        "os",
        "pkgutil",
        "sys",
        "typing",
        "yaml",
        "starlette.routing.compile_path",
        "connexion.exceptions.TypeValidationError",
        "connexion.middleware.main.API",
        "jsf.JSF"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "split_content_type",
      "module": "utils",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\utils.py",
      "line_number": 321,
      "end_line_number": 341,
      "source_code": "def split_content_type(\n    content_type: t.Optional[str],\n) -> t.Tuple[t.Optional[str], t.Optional[str]]:\n    \"\"\"Split the content type in mime_type and encoding. Other parameters are ignored.\"\"\"\n    mime_type, encoding = None, None\n\n    if content_type is None:\n        return mime_type, encoding\n\n    # Check for parameters\n    if \";\" in content_type:\n        mime_type, parameters = content_type.split(\";\", maxsplit=1)\n\n        # Find parameter describing the charset\n        prefix = \"charset=\"\n        for parameter in parameters.split(\";\"):\n            if parameter.startswith(prefix):\n                encoding = parameter[len(prefix) :]\n    else:\n        mime_type = content_type\n    return mime_type, encoding",
      "docstring": "Split the content type in mime_type and encoding. Other parameters are ignored.",
      "decorators": [],
      "arguments": [
        "content_type"
      ],
      "imports": [
        "asyncio",
        "functools",
        "importlib",
        "inspect",
        "os",
        "pkgutil",
        "sys",
        "typing",
        "yaml",
        "starlette.routing.compile_path",
        "connexion.exceptions.TypeValidationError",
        "connexion.middleware.main.API",
        "jsf.JSF"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "coerce_type",
      "module": "utils",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\utils.py",
      "line_number": 344,
      "end_line_number": 391,
      "source_code": "def coerce_type(param, value, parameter_type, parameter_name=None):\n    # TODO: clean up\n    TYPE_MAP = {\"integer\": int, \"number\": float, \"boolean\": boolean, \"object\": dict}\n\n    def make_type(value, type_literal):\n        type_func = TYPE_MAP.get(type_literal)\n        return type_func(value)\n\n    param_schema = param.get(\"schema\", param)\n    if is_nullable(param_schema) and is_null(value):\n        return None\n\n    param_type = param_schema.get(\"type\")\n    parameter_name = parameter_name if parameter_name else param.get(\"name\")\n    if param_type == \"array\":\n        converted_params = []\n        if parameter_type == \"header\":\n            value = value.split(\",\")\n        for v in value:\n            try:\n                converted = make_type(v, param_schema[\"items\"][\"type\"])\n            except (ValueError, TypeError):\n                converted = v\n            converted_params.append(converted)\n        return converted_params\n    elif param_type == \"object\":\n        if param_schema.get(\"properties\"):\n\n            def cast_leaves(d, schema):\n                if type(d) is not dict:\n                    try:\n                        return make_type(d, schema[\"type\"])\n                    except (ValueError, TypeError):\n                        return d\n                for k, v in d.items():\n                    if k in schema[\"properties\"]:\n                        d[k] = cast_leaves(v, schema[\"properties\"][k])\n                return d\n\n            return cast_leaves(value, param_schema)\n        return value\n    else:\n        try:\n            return make_type(value, param_type)\n        except ValueError:\n            raise TypeValidationError(param_type, parameter_type, parameter_name)\n        except TypeError:\n            return value",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "param",
        "value",
        "parameter_type",
        "parameter_name"
      ],
      "imports": [
        "asyncio",
        "functools",
        "importlib",
        "inspect",
        "os",
        "pkgutil",
        "sys",
        "typing",
        "yaml",
        "starlette.routing.compile_path",
        "connexion.exceptions.TypeValidationError",
        "connexion.middleware.main.API",
        "jsf.JSF"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "param.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "param_schema.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "TYPE_MAP.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "is_nullable",
          "body": "def is_nullable(param_def):\n    return param_def.get('schema', param_def).get('nullable', False) or param_def.get('x-nullable', False)"
        },
        {
          "name": "is_null",
          "body": "def is_null(value):\n    if hasattr(value, 'strip') and value.strip() in ['null', 'None']:\n        return True\n    if value is None:\n        return True\n    return False"
        },
        {
          "name": "param.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "param_schema.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "make_type",
          "body": "def make_type(value: t.Any, type_: str, format_: t.Optional[str]) -> t.Any:\n    \"\"\"Cast a value to the type defined in the specification.\"\"\"\n    if type_ == 'string' and format_ == 'binary':\n        type_ = 'file'\n    type_func = TYPE_MAP[type_]\n    return type_func(value)"
        },
        {
          "name": "cast_leaves",
          "body": "def cast_leaves(d, schema):\n    if type(d) is not dict:\n        try:\n            return make_type(d, schema['type'])\n        except (ValueError, TypeError):\n            return d\n    for k, v in d.items():\n        if k in schema['properties']:\n            d[k] = cast_leaves(v, schema['properties'][k])\n    return d"
        },
        {
          "name": "make_type",
          "body": "def make_type(value: t.Any, type_: str, format_: t.Optional[str]) -> t.Any:\n    \"\"\"Cast a value to the type defined in the specification.\"\"\"\n    if type_ == 'string' and format_ == 'binary':\n        type_ = 'file'\n    type_func = TYPE_MAP[type_]\n    return type_func(value)"
        },
        {
          "name": "make_type",
          "body": "def make_type(value: t.Any, type_: str, format_: t.Optional[str]) -> t.Any:\n    \"\"\"Cast a value to the type defined in the specification.\"\"\"\n    if type_ == 'string' and format_ == 'binary':\n        type_ = 'file'\n    type_func = TYPE_MAP[type_]\n    return type_func(value)"
        },
        {
          "name": "cast_leaves",
          "body": "def cast_leaves(d, schema):\n    if type(d) is not dict:\n        try:\n            return make_type(d, schema['type'])\n        except (ValueError, TypeError):\n            return d\n    for k, v in d.items():\n        if k in schema['properties']:\n            d[k] = cast_leaves(v, schema['properties'][k])\n    return d"
        }
      ]
    },
    {
      "name": "get_root_path",
      "module": "utils",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\utils.py",
      "line_number": 394,
      "end_line_number": 439,
      "source_code": "def get_root_path(import_name: str) -> str:\n    \"\"\"Copied from Flask:\n    https://github.com/pallets/flask/blob/836866dc19218832cf02f8b04911060ac92bfc0b/src/flask/helpers.py#L595\n\n    Find the root path of a package, or the path that contains a\n    module. If it cannot be found, returns the current working\n    directory.\n    \"\"\"\n    # Module already imported and has a file attribute. Use that first.\n    mod = sys.modules.get(import_name)\n\n    if mod is not None and hasattr(mod, \"__file__\") and mod.__file__ is not None:\n        return os.path.dirname(os.path.abspath(mod.__file__))\n\n    # Next attempt: check the loader.\n    loader = pkgutil.get_loader(import_name)\n\n    # Loader does not exist or we're referring to an unloaded main\n    # module or a main module without path (interactive sessions), go\n    # with the current working directory.\n    if loader is None or import_name == \"__main__\":\n        return os.getcwd()\n\n    if hasattr(loader, \"get_filename\"):\n        filepath = loader.get_filename(import_name)  # type: ignore\n    else:\n        # Fall back to imports.\n        __import__(import_name)\n        mod = sys.modules[import_name]\n        filepath = getattr(mod, \"__file__\", None)\n\n        # If we don't have a file path it might be because it is a\n        # namespace package. In this case pick the root path from the\n        # first module that is contained in the package.\n        if filepath is None:\n            raise RuntimeError(\n                \"No root path can be found for the provided module\"\n                f\" {import_name!r}. This can happen because the module\"\n                \" came from an import hook that does not provide file\"\n                \" name information or because it's a namespace package.\"\n                \" In this case the root path needs to be explicitly\"\n                \" provided.\"\n            )\n\n    # filepath is import_name.py for a module, or __init__.py for a package.\n    return os.path.dirname(os.path.abspath(filepath))",
      "docstring": "Copied from Flask:\nhttps://github.com/pallets/flask/blob/836866dc19218832cf02f8b04911060ac92bfc0b/src/flask/helpers.py#L595\n\nFind the root path of a package, or the path that contains a\nmodule. If it cannot be found, returns the current working\ndirectory.",
      "decorators": [],
      "arguments": [
        "import_name"
      ],
      "imports": [
        "asyncio",
        "functools",
        "importlib",
        "inspect",
        "os",
        "pkgutil",
        "sys",
        "typing",
        "yaml",
        "starlette.routing.compile_path",
        "connexion.exceptions.TypeValidationError",
        "connexion.middleware.main.API",
        "jsf.JSF"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "inspect_function_arguments",
      "module": "utils",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\utils.py",
      "line_number": 442,
      "end_line_number": 454,
      "source_code": "def inspect_function_arguments(function: t.Callable) -> t.Tuple[t.List[str], bool]:\n    \"\"\"\n    Returns the list of variables names of a function and if it\n    accepts keyword arguments.\n    \"\"\"\n    parameters = inspect.signature(function).parameters\n    bound_arguments = [\n        name\n        for name, p in parameters.items()\n        if p.kind not in (p.VAR_POSITIONAL, p.VAR_KEYWORD)\n    ]\n    has_kwargs = any(p.kind == p.VAR_KEYWORD for p in parameters.values())\n    return list(bound_arguments), has_kwargs",
      "docstring": "Returns the list of variables names of a function and if it\naccepts keyword arguments.",
      "decorators": [],
      "arguments": [
        "function"
      ],
      "imports": [
        "asyncio",
        "functools",
        "importlib",
        "inspect",
        "os",
        "pkgutil",
        "sys",
        "typing",
        "yaml",
        "starlette.routing.compile_path",
        "connexion.exceptions.TypeValidationError",
        "connexion.middleware.main.API",
        "jsf.JSF"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "sort_routes",
      "module": "utils",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\utils.py",
      "line_number": 461,
      "end_line_number": 462,
      "source_code": "def sort_routes(routes: t.List[str], *, key: None = None) -> t.List[str]:\n    ...",
      "docstring": null,
      "decorators": [
        "t.overload"
      ],
      "arguments": [
        "routes"
      ],
      "imports": [
        "asyncio",
        "functools",
        "importlib",
        "inspect",
        "os",
        "pkgutil",
        "sys",
        "typing",
        "yaml",
        "starlette.routing.compile_path",
        "connexion.exceptions.TypeValidationError",
        "connexion.middleware.main.API",
        "jsf.JSF"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "sort_routes",
      "module": "utils",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\utils.py",
      "line_number": 466,
      "end_line_number": 467,
      "source_code": "def sort_routes(routes: t.List[T], *, key: t.Callable[[T], str]) -> t.List[T]:\n    ...",
      "docstring": null,
      "decorators": [
        "t.overload"
      ],
      "arguments": [
        "routes"
      ],
      "imports": [
        "asyncio",
        "functools",
        "importlib",
        "inspect",
        "os",
        "pkgutil",
        "sys",
        "typing",
        "yaml",
        "starlette.routing.compile_path",
        "connexion.exceptions.TypeValidationError",
        "connexion.middleware.main.API",
        "jsf.JSF"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "sort_routes",
      "module": "utils",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\utils.py",
      "line_number": 470,
      "end_line_number": 504,
      "source_code": "def sort_routes(routes, *, key=None):\n    \"\"\"Sorts a list of routes from most specific to least specific.\n\n    See Starlette routing documentation and implementation as this function\n    is aimed to sort according to that logic.\n    - https://www.starlette.io/routing/#route-priority\n\n    The only difference is that a `path` component is appended to each route\n    such that `/` is less specific than `/basepath` while they are technically\n    not comparable.\n    This is because it is also done by the `Mount` class internally:\n    https://github.com/encode/starlette/blob/1c1043ca0ab7126419948b27f9d0a78270fd74e6/starlette/routing.py#L388\n\n    For example, from most to least specific:\n    - /users/me\n    - /users/{username}/projects/{project}\n    - /users/{username}\n\n    :param routes: List of routes to sort\n    :param key: Function to extract the path from a route if it is not a string\n\n    :return: List of routes sorted from most specific to least specific\n    \"\"\"\n\n    class SortableRoute:\n        def __init__(self, path: str) -> None:\n            self.path = path.rstrip(\"/\")\n            if not self.path.endswith(\"/{path:path}\"):\n                self.path += \"/{path:path}\"\n            self.path_regex, _, _ = compile_path(self.path)\n\n        def __lt__(self, other: \"SortableRoute\") -> bool:\n            return bool(other.path_regex.match(self.path))\n\n    return sorted(routes, key=lambda r: SortableRoute(key(r) if key else r))",
      "docstring": "Sorts a list of routes from most specific to least specific.\n\nSee Starlette routing documentation and implementation as this function\nis aimed to sort according to that logic.\n- https://www.starlette.io/routing/#route-priority\n\nThe only difference is that a `path` component is appended to each route\nsuch that `/` is less specific than `/basepath` while they are technically\nnot comparable.\nThis is because it is also done by the `Mount` class internally:\nhttps://github.com/encode/starlette/blob/1c1043ca0ab7126419948b27f9d0a78270fd74e6/starlette/routing.py#L388\n\nFor example, from most to least specific:\n- /users/me\n- /users/{username}/projects/{project}\n- /users/{username}\n\n:param routes: List of routes to sort\n:param key: Function to extract the path from a route if it is not a string\n\n:return: List of routes sorted from most specific to least specific",
      "decorators": [],
      "arguments": [
        "routes"
      ],
      "imports": [
        "asyncio",
        "functools",
        "importlib",
        "inspect",
        "os",
        "pkgutil",
        "sys",
        "typing",
        "yaml",
        "starlette.routing.compile_path",
        "connexion.exceptions.TypeValidationError",
        "connexion.middleware.main.API",
        "jsf.JSF"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "sort_apis_by_basepath",
      "module": "utils",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\utils.py",
      "line_number": 507,
      "end_line_number": 514,
      "source_code": "def sort_apis_by_basepath(apis: t.List[\"API\"]) -> t.List[\"API\"]:\n    \"\"\"Sorts a list of APIs by basepath.\n\n    :param apis: List of APIs to sort\n\n    :return: List of APIs sorted by basepath\n    \"\"\"\n    return sort_routes(apis, key=lambda api: api.base_path or \"/\")",
      "docstring": "Sorts a list of APIs by basepath.\n\n:param apis: List of APIs to sort\n\n:return: List of APIs sorted by basepath",
      "decorators": [],
      "arguments": [
        "apis"
      ],
      "imports": [
        "asyncio",
        "functools",
        "importlib",
        "inspect",
        "os",
        "pkgutil",
        "sys",
        "typing",
        "yaml",
        "starlette.routing.compile_path",
        "connexion.exceptions.TypeValidationError",
        "connexion.middleware.main.API",
        "jsf.JSF"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "sort_routes",
          "body": "@t.overload\ndef sort_routes(routes: t.List[str], *, key: None=None) -> t.List[str]:\n    ..."
        }
      ]
    },
    {
      "name": "build_example_from_schema",
      "module": "utils",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\utils.py",
      "line_number": 517,
      "end_line_number": 546,
      "source_code": "def build_example_from_schema(schema):\n    if \"example\" in schema:\n        return schema[\"example\"]\n\n    if \"properties\" in schema:\n        # Recurse if schema is an object\n        return {\n            key: build_example_from_schema(value)\n            for (key, value) in schema[\"properties\"].items()\n        }\n\n    if \"items\" in schema:\n        # Recurse if schema is an array\n        min_item_count = schema.get(\"minItems\", 0)\n        max_item_count = schema.get(\"maxItems\")\n\n        if max_item_count is None or max_item_count >= min_item_count + 1:\n            item_count = min_item_count + 1\n        else:\n            item_count = min_item_count\n\n        return [build_example_from_schema(schema[\"items\"]) for n in range(item_count)]\n\n    try:\n        from jsf import JSF\n    except ImportError:\n        return None\n\n    faker = JSF(schema)\n    return faker.generate()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "schema"
      ],
      "imports": [
        "asyncio",
        "functools",
        "importlib",
        "inspect",
        "os",
        "pkgutil",
        "sys",
        "typing",
        "yaml",
        "starlette.routing.compile_path",
        "connexion.exceptions.TypeValidationError",
        "connexion.middleware.main.API",
        "jsf.JSF"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "schema.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "schema.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "build_example_from_schema",
          "body": "def build_example_from_schema(schema):\n    if 'example' in schema:\n        return schema['example']\n    if 'properties' in schema:\n        return {key: build_example_from_schema(value) for key, value in schema['properties'].items()}\n    if 'items' in schema:\n        min_item_count = schema.get('minItems', 0)\n        max_item_count = schema.get('maxItems')\n        if max_item_count is None or max_item_count >= min_item_count + 1:\n            item_count = min_item_count + 1\n        else:\n            item_count = min_item_count\n        return [build_example_from_schema(schema['items']) for n in range(item_count)]\n    try:\n        from jsf import JSF\n    except ImportError:\n        return None\n    faker = JSF(schema)\n    return faker.generate()"
        },
        {
          "name": "build_example_from_schema",
          "body": "def build_example_from_schema(schema):\n    if 'example' in schema:\n        return schema['example']\n    if 'properties' in schema:\n        return {key: build_example_from_schema(value) for key, value in schema['properties'].items()}\n    if 'items' in schema:\n        min_item_count = schema.get('minItems', 0)\n        max_item_count = schema.get('maxItems')\n        if max_item_count is None or max_item_count >= min_item_count + 1:\n            item_count = min_item_count + 1\n        else:\n            item_count = min_item_count\n        return [build_example_from_schema(schema['items']) for n in range(item_count)]\n    try:\n        from jsf import JSF\n    except ImportError:\n        return None\n    faker = JSF(schema)\n    return faker.generate()"
        }
      ]
    },
    {
      "name": "iscorofunc",
      "module": "utils",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\utils.py",
      "line_number": 217,
      "end_line_number": 222,
      "source_code": "def iscorofunc(func):\n        iscorofunc = asyncio.iscoroutinefunction(func)\n        while not iscorofunc and hasattr(func, \"__wrapped__\"):\n            func = func.__wrapped__\n            iscorofunc = asyncio.iscoroutinefunction(func)\n        return iscorofunc",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "func"
      ],
      "imports": [
        "asyncio",
        "functools",
        "importlib",
        "inspect",
        "os",
        "pkgutil",
        "sys",
        "typing",
        "yaml",
        "starlette.routing.compile_path",
        "connexion.exceptions.TypeValidationError",
        "connexion.middleware.main.API",
        "jsf.JSF"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "should_use_block",
      "module": "utils",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\utils.py",
      "line_number": 238,
      "end_line_number": 252,
      "source_code": "def should_use_block(value):\n        char_list = (\n            \"\\u000a\"  # line feed\n            \"\\u000d\"  # carriage return\n            \"\\u001c\"  # file separator\n            \"\\u001d\"  # group separator\n            \"\\u001e\"  # record separator\n            \"\\u0085\"  # next line\n            \"\\u2028\"  # line separator\n            \"\\u2029\"  # paragraph separator\n        )\n        for c in char_list:\n            if c in value:\n                return True\n        return False",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "value"
      ],
      "imports": [
        "asyncio",
        "functools",
        "importlib",
        "inspect",
        "os",
        "pkgutil",
        "sys",
        "typing",
        "yaml",
        "starlette.routing.compile_path",
        "connexion.exceptions.TypeValidationError",
        "connexion.middleware.main.API",
        "jsf.JSF"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "my_represent_scalar",
      "module": "utils",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\utils.py",
      "line_number": 254,
      "end_line_number": 263,
      "source_code": "def my_represent_scalar(self, tag, value, style=None):\n        if should_use_block(value):\n            style = \"|\"\n        else:\n            style = self.default_style\n\n        node = yaml.representer.ScalarNode(tag, value, style=style)\n        if self.alias_key is not None:\n            self.represented_objects[self.alias_key] = node\n        return node",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "tag",
        "value",
        "style"
      ],
      "imports": [
        "asyncio",
        "functools",
        "importlib",
        "inspect",
        "os",
        "pkgutil",
        "sys",
        "typing",
        "yaml",
        "starlette.routing.compile_path",
        "connexion.exceptions.TypeValidationError",
        "connexion.middleware.main.API",
        "jsf.JSF"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "should_use_block",
          "body": "def should_use_block(value):\n    char_list = '\\n\\r\\x1c\\x1d\\x1e\\x85\\u2028\\u2029'\n    for c in char_list:\n        if c in value:\n            return True\n    return False"
        }
      ]
    },
    {
      "name": "_delayed_error",
      "module": "utils",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\utils.py",
      "line_number": 282,
      "end_line_number": 285,
      "source_code": "def _delayed_error(*args, **kwargs):\n        if msg is not None:\n            raise type(exc)(msg).with_traceback(exc.__traceback__)\n        raise exc",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "functools",
        "importlib",
        "inspect",
        "os",
        "pkgutil",
        "sys",
        "typing",
        "yaml",
        "starlette.routing.compile_path",
        "connexion.exceptions.TypeValidationError",
        "connexion.middleware.main.API",
        "jsf.JSF"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "make_type",
      "module": "utils",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\utils.py",
      "line_number": 348,
      "end_line_number": 350,
      "source_code": "def make_type(value, type_literal):\n        type_func = TYPE_MAP.get(type_literal)\n        return type_func(value)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "value",
        "type_literal"
      ],
      "imports": [
        "asyncio",
        "functools",
        "importlib",
        "inspect",
        "os",
        "pkgutil",
        "sys",
        "typing",
        "yaml",
        "starlette.routing.compile_path",
        "connexion.exceptions.TypeValidationError",
        "connexion.middleware.main.API",
        "jsf.JSF"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "TYPE_MAP.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "ignore_aliases",
      "module": "utils",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\utils.py",
      "line_number": 270,
      "end_line_number": 271,
      "source_code": "def ignore_aliases(self, *args):\n            return True",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "functools",
        "importlib",
        "inspect",
        "os",
        "pkgutil",
        "sys",
        "typing",
        "yaml",
        "starlette.routing.compile_path",
        "connexion.exceptions.TypeValidationError",
        "connexion.middleware.main.API",
        "jsf.JSF"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "utils",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\utils.py",
      "line_number": 495,
      "end_line_number": 499,
      "source_code": "def __init__(self, path: str) -> None:\n            self.path = path.rstrip(\"/\")\n            if not self.path.endswith(\"/{path:path}\"):\n                self.path += \"/{path:path}\"\n            self.path_regex, _, _ = compile_path(self.path)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "path"
      ],
      "imports": [
        "asyncio",
        "functools",
        "importlib",
        "inspect",
        "os",
        "pkgutil",
        "sys",
        "typing",
        "yaml",
        "starlette.routing.compile_path",
        "connexion.exceptions.TypeValidationError",
        "connexion.middleware.main.API",
        "jsf.JSF"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__lt__",
      "module": "utils",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\utils.py",
      "line_number": 501,
      "end_line_number": 502,
      "source_code": "def __lt__(self, other: \"SortableRoute\") -> bool:\n            return bool(other.path_regex.match(self.path))",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "other"
      ],
      "imports": [
        "asyncio",
        "functools",
        "importlib",
        "inspect",
        "os",
        "pkgutil",
        "sys",
        "typing",
        "yaml",
        "starlette.routing.compile_path",
        "connexion.exceptions.TypeValidationError",
        "connexion.middleware.main.API",
        "jsf.JSF"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "cast_leaves",
      "module": "utils",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\utils.py",
      "line_number": 372,
      "end_line_number": 381,
      "source_code": "def cast_leaves(d, schema):\n                if type(d) is not dict:\n                    try:\n                        return make_type(d, schema[\"type\"])\n                    except (ValueError, TypeError):\n                        return d\n                for k, v in d.items():\n                    if k in schema[\"properties\"]:\n                        d[k] = cast_leaves(v, schema[\"properties\"][k])\n                return d",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "d",
        "schema"
      ],
      "imports": [
        "asyncio",
        "functools",
        "importlib",
        "inspect",
        "os",
        "pkgutil",
        "sys",
        "typing",
        "yaml",
        "starlette.routing.compile_path",
        "connexion.exceptions.TypeValidationError",
        "connexion.middleware.main.API",
        "jsf.JSF"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_type",
          "body": "def make_type(value: t.Any, type_: str, format_: t.Optional[str]) -> t.Any:\n    \"\"\"Cast a value to the type defined in the specification.\"\"\"\n    if type_ == 'string' and format_ == 'binary':\n        type_ = 'file'\n    type_func = TYPE_MAP[type_]\n    return type_func(value)"
        },
        {
          "name": "cast_leaves",
          "body": "def cast_leaves(d, schema):\n    if type(d) is not dict:\n        try:\n            return make_type(d, schema['type'])\n        except (ValueError, TypeError):\n            return d\n    for k, v in d.items():\n        if k in schema['properties']:\n            d[k] = cast_leaves(v, schema['properties'][k])\n    return d"
        }
      ]
    },
    {
      "name": "test_client",
      "module": "abstract",
      "class_name": "AbstractApp",
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\abstract.py",
      "line_number": 273,
      "end_line_number": 276,
      "source_code": "def test_client(self, **kwargs):\n        \"\"\"Creates a test client for this application. The keywords arguments passed in are\n        passed to the ``StarletteClient``.\"\"\"\n        return TestClient(self, **kwargs)",
      "docstring": "Creates a test client for this application. The keywords arguments passed in are\npassed to the ``StarletteClient``.",
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "pathlib",
        "typing",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.ConnexionMiddleware",
        "connexion.middleware.MiddlewarePosition",
        "connexion.middleware.SpecMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\abstract.py",
      "line_number": 35,
      "end_line_number": 106,
      "source_code": "def __init__(\n        self,\n        import_name: str,\n        *,\n        lifespan: t.Optional[Lifespan] = None,\n        middlewares: t.Optional[list] = None,\n        specification_dir: t.Union[pathlib.Path, str] = \"\",\n        arguments: t.Optional[dict] = None,\n        auth_all_paths: t.Optional[bool] = None,\n        jsonifier: t.Optional[Jsonifier] = None,\n        pythonic_params: t.Optional[bool] = None,\n        resolver: t.Optional[t.Union[Resolver, t.Callable]] = None,\n        resolver_error: t.Optional[int] = None,\n        strict_validation: t.Optional[bool] = None,\n        swagger_ui_options: t.Optional[SwaggerUIOptions] = None,\n        uri_parser_class: t.Optional[AbstractURIParser] = None,\n        validate_responses: t.Optional[bool] = None,\n        validator_map: t.Optional[dict] = None,\n        security_map: t.Optional[dict] = None,\n    ) -> None:\n        \"\"\"\n        :param import_name: The name of the package or module that this object belongs to. If you\n            are using a single module, __name__ is always the correct value. If you however are\n            using a package, it\u2019s usually recommended to hardcode the name of your package there.\n        :param lifespan: A lifespan context function, which can be used to perform startup and\n        :param middlewares: The list of middlewares to wrap around the application. Defaults to\n            :obj:`middleware.main.ConnexionMiddleware.default_middlewares`\n        :param specification_dir: The directory holding the specification(s). The provided path\n            should either be absolute or relative to the root path of the application. Defaults to\n            the root path.\n        :param arguments: Arguments to substitute the specification using Jinja.\n        :param auth_all_paths: whether to authenticate not paths not defined in the specification.\n            Defaults to False.\n        :param jsonifier: Custom jsonifier to overwrite json encoding for json responses.\n        :param pythonic_params: When True, CamelCase parameters are converted to snake_case and an\n            underscore is appended to any shadowed built-ins. Defaults to False.\n        :param resolver: Callable that maps operationId to a function or instance of\n            :class:`resolver.Resolver`.\n        :param resolver_error: Error code to return for operations for which the operationId could\n            not be resolved. If no error code is provided, the application will fail when trying to\n            start.\n        :param strict_validation: When True, extra form or query parameters not defined in the\n            specification result in a validation error. Defaults to False.\n        :param swagger_ui_options: Instance of :class:`options.SwaggerUIOptions` with\n            configuration options for the swagger ui.\n        :param uri_parser_class: Class to use for uri parsing. See :mod:`uri_parsing`.\n        :param validate_responses: Whether to validate responses against the specification. This has\n            an impact on performance. Defaults to False.\n        :param validator_map: A dictionary of validators to use. Defaults to\n            :obj:`validators.VALIDATOR_MAP`.\n        :param security_map: A dictionary of security handlers to use. Defaults to\n            :obj:`security.SECURITY_HANDLERS`\n        \"\"\"\n        self.middleware = ConnexionMiddleware(\n            self._middleware_app,\n            import_name=import_name,\n            lifespan=lifespan,\n            middlewares=middlewares,\n            specification_dir=specification_dir,\n            arguments=arguments,\n            auth_all_paths=auth_all_paths,\n            jsonifier=jsonifier,\n            swagger_ui_options=swagger_ui_options,\n            pythonic_params=pythonic_params,\n            resolver=resolver,\n            resolver_error=resolver_error,\n            strict_validation=strict_validation,\n            uri_parser_class=uri_parser_class,\n            validate_responses=validate_responses,\n            validator_map=validator_map,\n            security_map=security_map,\n        )",
      "docstring": ":param import_name: The name of the package or module that this object belongs to. If you\n    are using a single module, __name__ is always the correct value. If you however are\n    using a package, it\u2019s usually recommended to hardcode the name of your package there.\n:param lifespan: A lifespan context function, which can be used to perform startup and\n:param middlewares: The list of middlewares to wrap around the application. Defaults to\n    :obj:`middleware.main.ConnexionMiddleware.default_middlewares`\n:param specification_dir: The directory holding the specification(s). The provided path\n    should either be absolute or relative to the root path of the application. Defaults to\n    the root path.\n:param arguments: Arguments to substitute the specification using Jinja.\n:param auth_all_paths: whether to authenticate not paths not defined in the specification.\n    Defaults to False.\n:param jsonifier: Custom jsonifier to overwrite json encoding for json responses.\n:param pythonic_params: When True, CamelCase parameters are converted to snake_case and an\n    underscore is appended to any shadowed built-ins. Defaults to False.\n:param resolver: Callable that maps operationId to a function or instance of\n    :class:`resolver.Resolver`.\n:param resolver_error: Error code to return for operations for which the operationId could\n    not be resolved. If no error code is provided, the application will fail when trying to\n    start.\n:param strict_validation: When True, extra form or query parameters not defined in the\n    specification result in a validation error. Defaults to False.\n:param swagger_ui_options: Instance of :class:`options.SwaggerUIOptions` with\n    configuration options for the swagger ui.\n:param uri_parser_class: Class to use for uri parsing. See :mod:`uri_parsing`.\n:param validate_responses: Whether to validate responses against the specification. This has\n    an impact on performance. Defaults to False.\n:param validator_map: A dictionary of validators to use. Defaults to\n    :obj:`validators.VALIDATOR_MAP`.\n:param security_map: A dictionary of security handlers to use. Defaults to\n    :obj:`security.SECURITY_HANDLERS`",
      "decorators": [],
      "arguments": [
        "self",
        "import_name"
      ],
      "imports": [
        "abc",
        "pathlib",
        "typing",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.ConnexionMiddleware",
        "connexion.middleware.MiddlewarePosition",
        "connexion.middleware.SpecMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "add_middleware",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\abstract.py",
      "line_number": 108,
      "end_line_number": 120,
      "source_code": "def add_middleware(\n        self,\n        middleware_class: t.Type[ASGIApp],\n        position: MiddlewarePosition = MiddlewarePosition.BEFORE_CONTEXT,\n        **options: t.Any,\n    ) -> None:\n        \"\"\"Add a middleware to the stack on the specified position.\n\n        :param middleware_class: Middleware class to add\n        :param position: Position to add the middleware, one of the MiddlewarePosition Enum\n        :param options: Options to pass to the middleware_class on initialization\n        \"\"\"\n        self.middleware.add_middleware(middleware_class, position=position, **options)",
      "docstring": "Add a middleware to the stack on the specified position.\n\n:param middleware_class: Middleware class to add\n:param position: Position to add the middleware, one of the MiddlewarePosition Enum\n:param options: Options to pass to the middleware_class on initialization",
      "decorators": [],
      "arguments": [
        "self",
        "middleware_class",
        "position"
      ],
      "imports": [
        "abc",
        "pathlib",
        "typing",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.ConnexionMiddleware",
        "connexion.middleware.MiddlewarePosition",
        "connexion.middleware.SpecMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.middleware.add_middleware",
          "body": "def add_middleware(self, middleware_class: t.Type[ASGIApp], position: MiddlewarePosition=MiddlewarePosition.BEFORE_CONTEXT, **options: t.Any) -> None:\n    \"\"\"Add a middleware to the stack on the specified position.\n\n        :param middleware_class: Middleware class to add\n        :param position: Position to add the middleware, one of the MiddlewarePosition Enum\n        :param options: Options to pass to the middleware_class on initialization\n        \"\"\"\n    self.middleware.add_middleware(middleware_class, position=position, **options)"
        }
      ]
    },
    {
      "name": "add_api",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\abstract.py",
      "line_number": 122,
      "end_line_number": 197,
      "source_code": "def add_api(\n        self,\n        specification: t.Union[pathlib.Path, str, dict],\n        *,\n        base_path: t.Optional[str] = None,\n        name: t.Optional[str] = None,\n        arguments: t.Optional[dict] = None,\n        auth_all_paths: t.Optional[bool] = None,\n        jsonifier: t.Optional[Jsonifier] = None,\n        pythonic_params: t.Optional[bool] = None,\n        resolver: t.Optional[t.Union[Resolver, t.Callable]] = None,\n        resolver_error: t.Optional[int] = None,\n        strict_validation: t.Optional[bool] = None,\n        swagger_ui_options: t.Optional[SwaggerUIOptions] = None,\n        uri_parser_class: t.Optional[AbstractURIParser] = None,\n        validate_responses: t.Optional[bool] = None,\n        validator_map: t.Optional[dict] = None,\n        security_map: t.Optional[dict] = None,\n        **kwargs,\n    ) -> t.Any:\n        \"\"\"\n        Register an API represented by a single OpenAPI specification on this application.\n        Multiple APIs can be registered on a single application.\n\n        :param specification: OpenAPI specification. Can be provided either as dict, a path\n            to file, or a URL.\n        :param base_path: Base path to host the API. This overrides the basePath / servers in the\n            specification.\n        :param name: Name to register the API with. If no name is passed, the base_path is used\n            as name instead.\n        :param arguments: Arguments to substitute the specification using Jinja.\n        :param auth_all_paths: whether to authenticate not paths not defined in the specification.\n            Defaults to False.\n        :param jsonifier: Custom jsonifier to overwrite json encoding for json responses.\n        :param pythonic_params: When True, CamelCase parameters are converted to snake_case and an\n            underscore is appended to any shadowed built-ins. Defaults to False.\n        :param resolver: Callable that maps operationId to a function or instance of\n            :class:`resolver.Resolver`.\n        :param resolver_error: Error code to return for operations for which the operationId could\n            not be resolved. If no error code is provided, the application will fail when trying to\n            start.\n        :param strict_validation: When True, extra form or query parameters not defined in the\n            specification result in a validation error. Defaults to False.\n        :param swagger_ui_options: A :class:`options.SwaggerUIOptions` instance with configuration\n            options for the swagger ui.\n        :param uri_parser_class: Class to use for uri parsing. See :mod:`uri_parsing`.\n        :param validate_responses: Whether to validate responses against the specification. This has\n            an impact on performance. Defaults to False.\n        :param validator_map: A dictionary of validators to use. Defaults to\n            :obj:`validators.VALIDATOR_MAP`\n        :param security_map: A dictionary of security handlers to use. Defaults to\n            :obj:`security.SECURITY_HANDLERS`\n        :param kwargs: Additional keyword arguments to pass to the `add_api` method of the managed\n            middlewares. This can be used to pass arguments to middlewares added beyond the default\n            ones.\n\n        :return: The Api registered on the middleware application wrapping the framework.\n        \"\"\"\n        return self.middleware.add_api(\n            specification,\n            base_path=base_path,\n            name=name,\n            arguments=arguments,\n            auth_all_paths=auth_all_paths,\n            jsonifier=jsonifier,\n            pythonic_params=pythonic_params,\n            resolver=resolver,\n            resolver_error=resolver_error,\n            strict_validation=strict_validation,\n            swagger_ui_options=swagger_ui_options,\n            uri_parser_class=uri_parser_class,\n            validate_responses=validate_responses,\n            validator_map=validator_map,\n            security_map=security_map,\n            **kwargs,\n        )",
      "docstring": "Register an API represented by a single OpenAPI specification on this application.\nMultiple APIs can be registered on a single application.\n\n:param specification: OpenAPI specification. Can be provided either as dict, a path\n    to file, or a URL.\n:param base_path: Base path to host the API. This overrides the basePath / servers in the\n    specification.\n:param name: Name to register the API with. If no name is passed, the base_path is used\n    as name instead.\n:param arguments: Arguments to substitute the specification using Jinja.\n:param auth_all_paths: whether to authenticate not paths not defined in the specification.\n    Defaults to False.\n:param jsonifier: Custom jsonifier to overwrite json encoding for json responses.\n:param pythonic_params: When True, CamelCase parameters are converted to snake_case and an\n    underscore is appended to any shadowed built-ins. Defaults to False.\n:param resolver: Callable that maps operationId to a function or instance of\n    :class:`resolver.Resolver`.\n:param resolver_error: Error code to return for operations for which the operationId could\n    not be resolved. If no error code is provided, the application will fail when trying to\n    start.\n:param strict_validation: When True, extra form or query parameters not defined in the\n    specification result in a validation error. Defaults to False.\n:param swagger_ui_options: A :class:`options.SwaggerUIOptions` instance with configuration\n    options for the swagger ui.\n:param uri_parser_class: Class to use for uri parsing. See :mod:`uri_parsing`.\n:param validate_responses: Whether to validate responses against the specification. This has\n    an impact on performance. Defaults to False.\n:param validator_map: A dictionary of validators to use. Defaults to\n    :obj:`validators.VALIDATOR_MAP`\n:param security_map: A dictionary of security handlers to use. Defaults to\n    :obj:`security.SECURITY_HANDLERS`\n:param kwargs: Additional keyword arguments to pass to the `add_api` method of the managed\n    middlewares. This can be used to pass arguments to middlewares added beyond the default\n    ones.\n\n:return: The Api registered on the middleware application wrapping the framework.",
      "decorators": [],
      "arguments": [
        "self",
        "specification"
      ],
      "imports": [
        "abc",
        "pathlib",
        "typing",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.ConnexionMiddleware",
        "connexion.middleware.MiddlewarePosition",
        "connexion.middleware.SpecMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.middleware.add_api",
          "body": "def add_api(self, specification: t.Union[pathlib.Path, str, dict], *, base_path: t.Optional[str]=None, name: t.Optional[str]=None, arguments: t.Optional[dict]=None, auth_all_paths: t.Optional[bool]=None, jsonifier: t.Optional[Jsonifier]=None, pythonic_params: t.Optional[bool]=None, resolver: t.Optional[t.Union[Resolver, t.Callable]]=None, resolver_error: t.Optional[int]=None, strict_validation: t.Optional[bool]=None, swagger_ui_options: t.Optional[SwaggerUIOptions]=None, uri_parser_class: t.Optional[AbstractURIParser]=None, validate_responses: t.Optional[bool]=None, validator_map: t.Optional[dict]=None, security_map: t.Optional[dict]=None, **kwargs) -> t.Any:\n    \"\"\"\n        Register an API represented by a single OpenAPI specification on this application.\n        Multiple APIs can be registered on a single application.\n\n        :param specification: OpenAPI specification. Can be provided either as dict, a path\n            to file, or a URL.\n        :param base_path: Base path to host the API. This overrides the basePath / servers in the\n            specification.\n        :param name: Name to register the API with. If no name is passed, the base_path is used\n            as name instead.\n        :param arguments: Arguments to substitute the specification using Jinja.\n        :param auth_all_paths: whether to authenticate not paths not defined in the specification.\n            Defaults to False.\n        :param jsonifier: Custom jsonifier to overwrite json encoding for json responses.\n        :param pythonic_params: When True, CamelCase parameters are converted to snake_case and an\n            underscore is appended to any shadowed built-ins. Defaults to False.\n        :param resolver: Callable that maps operationId to a function or instance of\n            :class:`resolver.Resolver`.\n        :param resolver_error: Error code to return for operations for which the operationId could\n            not be resolved. If no error code is provided, the application will fail when trying to\n            start.\n        :param strict_validation: When True, extra form or query parameters not defined in the\n            specification result in a validation error. Defaults to False.\n        :param swagger_ui_options: A :class:`options.SwaggerUIOptions` instance with configuration\n            options for the swagger ui.\n        :param uri_parser_class: Class to use for uri parsing. See :mod:`uri_parsing`.\n        :param validate_responses: Whether to validate responses against the specification. This has\n            an impact on performance. Defaults to False.\n        :param validator_map: A dictionary of validators to use. Defaults to\n            :obj:`validators.VALIDATOR_MAP`\n        :param security_map: A dictionary of security handlers to use. Defaults to\n            :obj:`security.SECURITY_HANDLERS`\n        :param kwargs: Additional keyword arguments to pass to the `add_api` method of the managed\n            middlewares. This can be used to pass arguments to middlewares added beyond the default\n            ones.\n\n        :return: The Api registered on the middleware application wrapping the framework.\n        \"\"\"\n    return self.middleware.add_api(specification, base_path=base_path, name=name, arguments=arguments, auth_all_paths=auth_all_paths, jsonifier=jsonifier, pythonic_params=pythonic_params, resolver=resolver, resolver_error=resolver_error, strict_validation=strict_validation, swagger_ui_options=swagger_ui_options, uri_parser_class=uri_parser_class, validate_responses=validate_responses, validator_map=validator_map, security_map=security_map, **kwargs)"
        }
      ]
    },
    {
      "name": "add_url_rule",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\abstract.py",
      "line_number": 199,
      "end_line_number": 232,
      "source_code": "def add_url_rule(\n        self,\n        rule,\n        endpoint: t.Optional[str] = None,\n        view_func: t.Optional[t.Callable] = None,\n        **options,\n    ):\n        \"\"\"\n        Connects a URL rule.  Works exactly like the `route` decorator.\n\n        Basically this example::\n\n            @app.route('/')\n            def index():\n                pass\n\n        Is equivalent to the following::\n\n            def index():\n                pass\n            app.add_url_rule('/', 'index', index)\n\n        Internally`route` invokes `add_url_rule` so if you want to customize the behavior via\n        subclassing you only need to change this method.\n\n        :param rule: the URL rule as string.\n        :param endpoint: the name of the endpoint for the registered URL rule, which is used for\n            reverse lookup. Flask defaults to the name of the view function.\n        :param view_func: the function to call when serving a request to the provided endpoint.\n        :param options: the options to be forwarded to the underlying ``werkzeug.routing.Rule``\n            object.  A change to Werkzeug is handling of method options. methods is a list of\n            methods this rule should be limited to (`GET`, `POST` etc.).  By default a rule just\n            listens for `GET` (and implicitly `HEAD`).\n        \"\"\"",
      "docstring": "Connects a URL rule.  Works exactly like the `route` decorator.\n\nBasically this example::\n\n    @app.route('/')\n    def index():\n        pass\n\nIs equivalent to the following::\n\n    def index():\n        pass\n    app.add_url_rule('/', 'index', index)\n\nInternally`route` invokes `add_url_rule` so if you want to customize the behavior via\nsubclassing you only need to change this method.\n\n:param rule: the URL rule as string.\n:param endpoint: the name of the endpoint for the registered URL rule, which is used for\n    reverse lookup. Flask defaults to the name of the view function.\n:param view_func: the function to call when serving a request to the provided endpoint.\n:param options: the options to be forwarded to the underlying ``werkzeug.routing.Rule``\n    object.  A change to Werkzeug is handling of method options. methods is a list of\n    methods this rule should be limited to (`GET`, `POST` etc.).  By default a rule just\n    listens for `GET` (and implicitly `HEAD`).",
      "decorators": [],
      "arguments": [
        "self",
        "rule",
        "endpoint",
        "view_func"
      ],
      "imports": [
        "abc",
        "pathlib",
        "typing",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.ConnexionMiddleware",
        "connexion.middleware.MiddlewarePosition",
        "connexion.middleware.SpecMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "route",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\abstract.py",
      "line_number": 234,
      "end_line_number": 255,
      "source_code": "def route(self, rule: str, **options):\n        \"\"\"\n        A decorator that is used to register a view function for a\n        given URL rule.  This does the same thing as `add_url_rule`\n        but is intended for decorator usage::\n\n            @app.route('/')\n            def index():\n                return 'Hello World'\n\n        :param rule: the URL rule as string\n        :param options: the options to be forwarded to the underlying ``werkzeug.routing.Rule``\n                        object. A change to Werkzeug is handling of method options. methods is a\n                        list of methods this rule should be limited to (`GET`, `POST` etc.).\n                        By default a rule just listens for `GET` (and implicitly `HEAD`).\n        \"\"\"\n\n        def decorator(func: t.Callable) -> t.Callable:\n            self.add_url_rule(rule, view_func=func, **options)\n            return func\n\n        return decorator",
      "docstring": "A decorator that is used to register a view function for a\ngiven URL rule.  This does the same thing as `add_url_rule`\nbut is intended for decorator usage::\n\n    @app.route('/')\n    def index():\n        return 'Hello World'\n\n:param rule: the URL rule as string\n:param options: the options to be forwarded to the underlying ``werkzeug.routing.Rule``\n                object. A change to Werkzeug is handling of method options. methods is a\n                list of methods this rule should be limited to (`GET`, `POST` etc.).\n                By default a rule just listens for `GET` (and implicitly `HEAD`).",
      "decorators": [],
      "arguments": [
        "self",
        "rule"
      ],
      "imports": [
        "abc",
        "pathlib",
        "typing",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.ConnexionMiddleware",
        "connexion.middleware.MiddlewarePosition",
        "connexion.middleware.SpecMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.add_url_rule",
          "body": "def add_url_rule(self, rule, endpoint: t.Optional[str]=None, view_func: t.Optional[t.Callable]=None, **options):\n    \"\"\"\n        Connects a URL rule.  Works exactly like the `route` decorator.\n\n        Basically this example::\n\n            @app.route('/')\n            def index():\n                pass\n\n        Is equivalent to the following::\n\n            def index():\n                pass\n            app.add_url_rule('/', 'index', index)\n\n        Internally`route` invokes `add_url_rule` so if you want to customize the behavior via\n        subclassing you only need to change this method.\n\n        :param rule: the URL rule as string.\n        :param endpoint: the name of the endpoint for the registered URL rule, which is used for\n            reverse lookup. Flask defaults to the name of the view function.\n        :param view_func: the function to call when serving a request to the provided endpoint.\n        :param options: the options to be forwarded to the underlying ``werkzeug.routing.Rule``\n            object.  A change to Werkzeug is handling of method options. methods is a list of\n            methods this rule should be limited to (`GET`, `POST` etc.).  By default a rule just\n            listens for `GET` (and implicitly `HEAD`).\n        \"\"\""
        }
      ]
    },
    {
      "name": "add_error_handler",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\abstract.py",
      "line_number": 258,
      "end_line_number": 271,
      "source_code": "def add_error_handler(\n        self,\n        code_or_exception: t.Union[int, t.Type[Exception]],\n        function: t.Callable[\n            [ConnexionRequest, Exception], MaybeAwaitable[ConnexionResponse]\n        ],\n    ) -> None:\n        \"\"\"\n        Register a callable to handle application errors.\n\n        :param code_or_exception: An exception class or the status code of HTTP exceptions to\n            handle.\n        :param function: Callable that will handle exception, may be async.\n        \"\"\"",
      "docstring": "Register a callable to handle application errors.\n\n:param code_or_exception: An exception class or the status code of HTTP exceptions to\n    handle.\n:param function: Callable that will handle exception, may be async.",
      "decorators": [
        "abc.abstractmethod"
      ],
      "arguments": [
        "self",
        "code_or_exception",
        "function"
      ],
      "imports": [
        "abc",
        "pathlib",
        "typing",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.ConnexionMiddleware",
        "connexion.middleware.MiddlewarePosition",
        "connexion.middleware.SpecMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_client",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\abstract.py",
      "line_number": 273,
      "end_line_number": 276,
      "source_code": "def test_client(self, **kwargs):\n        \"\"\"Creates a test client for this application. The keywords arguments passed in are\n        passed to the ``StarletteClient``.\"\"\"\n        return TestClient(self, **kwargs)",
      "docstring": "Creates a test client for this application. The keywords arguments passed in are\npassed to the ``StarletteClient``.",
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "pathlib",
        "typing",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.ConnexionMiddleware",
        "connexion.middleware.MiddlewarePosition",
        "connexion.middleware.SpecMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "run",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\abstract.py",
      "line_number": 278,
      "end_line_number": 285,
      "source_code": "def run(self, import_string: t.Optional[str] = None, **kwargs):\n        \"\"\"Run the application using uvicorn.\n\n        :param import_string: application as import string (eg. \"main:app\"). This is needed to run\n                              using reload.\n        :param kwargs: kwargs to pass to `uvicorn.run`.\n        \"\"\"\n        self.middleware.run(import_string, **kwargs)",
      "docstring": "Run the application using uvicorn.\n\n:param import_string: application as import string (eg. \"main:app\"). This is needed to run\n                      using reload.\n:param kwargs: kwargs to pass to `uvicorn.run`.",
      "decorators": [],
      "arguments": [
        "self",
        "import_string"
      ],
      "imports": [
        "abc",
        "pathlib",
        "typing",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.ConnexionMiddleware",
        "connexion.middleware.MiddlewarePosition",
        "connexion.middleware.SpecMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.middleware.run",
          "body": "def run(app: AbstractApp, args: argparse.Namespace):\n    app.run('connexion.cli:create_app', port=args.port, host=args.host, factory=True)"
        }
      ]
    },
    {
      "name": "decorator",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\abstract.py",
      "line_number": 251,
      "end_line_number": 253,
      "source_code": "def decorator(func: t.Callable) -> t.Callable:\n            self.add_url_rule(rule, view_func=func, **options)\n            return func",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "func"
      ],
      "imports": [
        "abc",
        "pathlib",
        "typing",
        "starlette.testclient.TestClient",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.ConnexionMiddleware",
        "connexion.middleware.MiddlewarePosition",
        "connexion.middleware.SpecMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.add_url_rule",
          "body": "def add_url_rule(self, rule, endpoint: t.Optional[str]=None, view_func: t.Optional[t.Callable]=None, **options):\n    \"\"\"\n        Connects a URL rule.  Works exactly like the `route` decorator.\n\n        Basically this example::\n\n            @app.route('/')\n            def index():\n                pass\n\n        Is equivalent to the following::\n\n            def index():\n                pass\n            app.add_url_rule('/', 'index', index)\n\n        Internally`route` invokes `add_url_rule` so if you want to customize the behavior via\n        subclassing you only need to change this method.\n\n        :param rule: the URL rule as string.\n        :param endpoint: the name of the endpoint for the registered URL rule, which is used for\n            reverse lookup. Flask defaults to the name of the view function.\n        :param view_func: the function to call when serving a request to the provided endpoint.\n        :param options: the options to be forwarded to the underlying ``werkzeug.routing.Rule``\n            object.  A change to Werkzeug is handling of method options. methods is a list of\n            methods this rule should be limited to (`GET`, `POST` etc.).  By default a rule just\n            listens for `GET` (and implicitly `HEAD`).\n        \"\"\""
        }
      ]
    },
    {
      "name": "__init__",
      "module": "asynchronous",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\asynchronous.py",
      "line_number": 30,
      "end_line_number": 41,
      "source_code": "def __init__(\n        self,\n        fn: t.Callable,\n        jsonifier: Jsonifier,\n        operation_id: str,\n        pythonic_params: bool,\n    ) -> None:\n        self._fn = fn\n        self.jsonifier = jsonifier\n        self.operation_id = operation_id\n        self.pythonic_params = pythonic_params\n        functools.update_wrapper(self, fn)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "fn",
        "jsonifier",
        "operation_id",
        "pythonic_params"
      ],
      "imports": [
        "functools",
        "logging",
        "pathlib",
        "typing",
        "starlette.responses.Response",
        "starlette.routing.Router",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.apps.abstract.AbstractApp",
        "connexion.decorators.StarletteDecorator",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.RoutedAPI",
        "connexion.middleware.abstract.RoutedMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.operations.AbstractOperation",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "from_operation",
      "module": "asynchronous",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\asynchronous.py",
      "line_number": 44,
      "end_line_number": 56,
      "source_code": "def from_operation(\n        cls,\n        operation: AbstractOperation,\n        *,\n        pythonic_params: bool,\n        jsonifier: Jsonifier,\n    ) -> \"AsyncOperation\":\n        return cls(\n            operation.function,\n            jsonifier=jsonifier,\n            operation_id=operation.operation_id,\n            pythonic_params=pythonic_params,\n        )",
      "docstring": null,
      "decorators": [
        "classmethod"
      ],
      "arguments": [
        "cls",
        "operation"
      ],
      "imports": [
        "functools",
        "logging",
        "pathlib",
        "typing",
        "starlette.responses.Response",
        "starlette.routing.Router",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.apps.abstract.AbstractApp",
        "connexion.decorators.StarletteDecorator",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.RoutedAPI",
        "connexion.middleware.abstract.RoutedMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.operations.AbstractOperation",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "fn",
      "module": "asynchronous",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\asynchronous.py",
      "line_number": 59,
      "end_line_number": 64,
      "source_code": "def fn(self) -> t.Callable:\n        decorator = StarletteDecorator(\n            pythonic_params=self.pythonic_params,\n            jsonifier=self.jsonifier,\n        )\n        return decorator(self._fn)",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "functools",
        "logging",
        "pathlib",
        "typing",
        "starlette.responses.Response",
        "starlette.routing.Router",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.apps.abstract.AbstractApp",
        "connexion.decorators.StarletteDecorator",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.RoutedAPI",
        "connexion.middleware.abstract.RoutedMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.operations.AbstractOperation",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "asynchronous",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\asynchronous.py",
      "line_number": 74,
      "end_line_number": 85,
      "source_code": "def __init__(\n        self,\n        *args,\n        pythonic_params: bool,\n        jsonifier: t.Optional[Jsonifier] = None,\n        **kwargs,\n    ) -> None:\n        super().__init__(*args, **kwargs)\n        self.pythonic_params = pythonic_params\n        self.jsonifier = jsonifier or Jsonifier()\n        self.router = Router()\n        self.add_paths()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "functools",
        "logging",
        "pathlib",
        "typing",
        "starlette.responses.Response",
        "starlette.routing.Router",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.apps.abstract.AbstractApp",
        "connexion.decorators.StarletteDecorator",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.RoutedAPI",
        "connexion.middleware.abstract.RoutedMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.operations.AbstractOperation",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.add_paths",
          "body": "def add_paths(self, paths: t.Optional[dict]=None) -> None:\n    \"\"\"\n        Adds the paths defined in the specification as operations.\n        \"\"\"\n    paths = t.cast(dict, paths or self.specification.get('paths', dict()))\n    for path, methods in paths.items():\n        logger.debug('Adding %s%s...', self.base_path, path)\n        for method in methods:\n            if method not in METHODS:\n                continue\n            try:\n                self.add_operation(path, method)\n            except ResolverError as err:\n                if self.resolver_error_handler is not None:\n                    self._add_resolver_error_handler(method, path, err)\n                else:\n                    self._handle_add_operation_error(path, method, err)\n            except Exception as e:\n                self._handle_add_operation_error(path, method, e)"
        }
      ]
    },
    {
      "name": "make_operation",
      "module": "asynchronous",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\asynchronous.py",
      "line_number": 87,
      "end_line_number": 90,
      "source_code": "def make_operation(self, operation: AbstractOperation) -> AsyncOperation:\n        return AsyncOperation.from_operation(\n            operation, pythonic_params=self.pythonic_params, jsonifier=self.jsonifier\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "operation"
      ],
      "imports": [
        "functools",
        "logging",
        "pathlib",
        "typing",
        "starlette.responses.Response",
        "starlette.routing.Router",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.apps.abstract.AbstractApp",
        "connexion.decorators.StarletteDecorator",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.RoutedAPI",
        "connexion.middleware.abstract.RoutedMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.operations.AbstractOperation",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "AsyncOperation.from_operation",
          "body": "@classmethod\ndef from_operation(cls, operation: AbstractOperation, *, pythonic_params: bool, jsonifier: Jsonifier) -> 'AsyncOperation':\n    return cls(operation.function, jsonifier=jsonifier, operation_id=operation.operation_id, pythonic_params=pythonic_params)"
        }
      ]
    },
    {
      "name": "__init__",
      "module": "asynchronous",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\asynchronous.py",
      "line_number": 97,
      "end_line_number": 101,
      "source_code": "def __init__(self) -> None:\n        self.apis: t.Dict[str, t.List[AsyncApi]] = {}\n        self.operations: t.Dict[str, AsyncOperation] = {}\n        self.router = Router()\n        super().__init__(self.router)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "functools",
        "logging",
        "pathlib",
        "typing",
        "starlette.responses.Response",
        "starlette.routing.Router",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.apps.abstract.AbstractApp",
        "connexion.decorators.StarletteDecorator",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.RoutedAPI",
        "connexion.middleware.abstract.RoutedMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.operations.AbstractOperation",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "add_api",
      "module": "asynchronous",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\asynchronous.py",
      "line_number": 103,
      "end_line_number": 110,
      "source_code": "def add_api(self, *args, name: t.Optional[str] = None, **kwargs):\n        api = super().add_api(*args, **kwargs)\n\n        if name is not None:\n            self.router.mount(api.base_path, api.router, name=name)\n        else:\n            self.router.mount(api.base_path, api.router)\n        return api",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "functools",
        "logging",
        "pathlib",
        "typing",
        "starlette.responses.Response",
        "starlette.routing.Router",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.apps.abstract.AbstractApp",
        "connexion.decorators.StarletteDecorator",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.RoutedAPI",
        "connexion.middleware.abstract.RoutedMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.operations.AbstractOperation",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "add_url_rule",
      "module": "asynchronous",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\asynchronous.py",
      "line_number": 112,
      "end_line_number": 120,
      "source_code": "def add_url_rule(\n        self,\n        rule,\n        endpoint: t.Optional[str] = None,\n        view_func: t.Optional[t.Callable] = None,\n        methods: t.List[str] = None,\n        **options,\n    ):\n        self.router.add_route(rule, endpoint=view_func, name=endpoint, methods=methods)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "rule",
        "endpoint",
        "view_func",
        "methods"
      ],
      "imports": [
        "functools",
        "logging",
        "pathlib",
        "typing",
        "starlette.responses.Response",
        "starlette.routing.Router",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.apps.abstract.AbstractApp",
        "connexion.decorators.StarletteDecorator",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.RoutedAPI",
        "connexion.middleware.abstract.RoutedMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.operations.AbstractOperation",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "asynchronous",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\asynchronous.py",
      "line_number": 127,
      "end_line_number": 200,
      "source_code": "def __init__(\n        self,\n        import_name: str,\n        *,\n        lifespan: t.Optional[Lifespan] = None,\n        middlewares: t.Optional[list] = None,\n        specification_dir: t.Union[pathlib.Path, str] = \"\",\n        arguments: t.Optional[dict] = None,\n        auth_all_paths: t.Optional[bool] = None,\n        jsonifier: t.Optional[Jsonifier] = None,\n        pythonic_params: t.Optional[bool] = None,\n        resolver: t.Optional[t.Union[Resolver, t.Callable]] = None,\n        resolver_error: t.Optional[int] = None,\n        strict_validation: t.Optional[bool] = None,\n        swagger_ui_options: t.Optional[SwaggerUIOptions] = None,\n        uri_parser_class: t.Optional[AbstractURIParser] = None,\n        validate_responses: t.Optional[bool] = None,\n        validator_map: t.Optional[dict] = None,\n        security_map: t.Optional[dict] = None,\n    ) -> None:\n        \"\"\"\n        :param import_name: The name of the package or module that this object belongs to. If you\n            are using a single module, __name__ is always the correct value. If you however are\n            using a package, it\u2019s usually recommended to hardcode the name of your package there.\n        :param lifespan: A lifespan context function, which can be used to perform startup and\n            shutdown tasks.\n        :param middlewares: The list of middlewares to wrap around the application. Defaults to\n            :obj:`middleware.main.ConnexionMiddleware.default_middlewares`\n        :param specification_dir: The directory holding the specification(s). The provided path\n            should either be absolute or relative to the root path of the application. Defaults to\n            the root path.\n        :param arguments: Arguments to substitute the specification using Jinja.\n        :param auth_all_paths: whether to authenticate not paths not defined in the specification.\n            Defaults to False.\n        :param jsonifier: Custom jsonifier to overwrite json encoding for json responses.\n        :param pythonic_params: When True, CamelCase parameters are converted to snake_case and an\n            underscore is appended to any shadowed built-ins. Defaults to False.\n        :param resolver: Callable that maps operationId to a function or instance of\n            :class:`resolver.Resolver`.\n        :param resolver_error: Error code to return for operations for which the operationId could\n            not be resolved. If no error code is provided, the application will fail when trying to\n            start.\n        :param strict_validation: When True, extra form or query parameters not defined in the\n            specification result in a validation error. Defaults to False.\n        :param swagger_ui_options: Instance of :class:`options.SwaggerUIOptions` with\n            configuration options for the swagger ui.\n        :param uri_parser_class: Class to use for uri parsing. See :mod:`uri_parsing`.\n        :param validate_responses: Whether to validate responses against the specification. This has\n            an impact on performance. Defaults to False.\n        :param validator_map: A dictionary of validators to use. Defaults to\n            :obj:`validators.VALIDATOR_MAP`.\n        :param security_map: A dictionary of security handlers to use. Defaults to\n            :obj:`security.SECURITY_HANDLERS`\n        \"\"\"\n        self._middleware_app: AsyncASGIApp = AsyncASGIApp()\n\n        super().__init__(\n            import_name,\n            lifespan=lifespan,\n            middlewares=middlewares,\n            specification_dir=specification_dir,\n            arguments=arguments,\n            auth_all_paths=auth_all_paths,\n            jsonifier=jsonifier,\n            pythonic_params=pythonic_params,\n            resolver=resolver,\n            resolver_error=resolver_error,\n            strict_validation=strict_validation,\n            swagger_ui_options=swagger_ui_options,\n            uri_parser_class=uri_parser_class,\n            validate_responses=validate_responses,\n            validator_map=validator_map,\n            security_map=security_map,\n        )",
      "docstring": ":param import_name: The name of the package or module that this object belongs to. If you\n    are using a single module, __name__ is always the correct value. If you however are\n    using a package, it\u2019s usually recommended to hardcode the name of your package there.\n:param lifespan: A lifespan context function, which can be used to perform startup and\n    shutdown tasks.\n:param middlewares: The list of middlewares to wrap around the application. Defaults to\n    :obj:`middleware.main.ConnexionMiddleware.default_middlewares`\n:param specification_dir: The directory holding the specification(s). The provided path\n    should either be absolute or relative to the root path of the application. Defaults to\n    the root path.\n:param arguments: Arguments to substitute the specification using Jinja.\n:param auth_all_paths: whether to authenticate not paths not defined in the specification.\n    Defaults to False.\n:param jsonifier: Custom jsonifier to overwrite json encoding for json responses.\n:param pythonic_params: When True, CamelCase parameters are converted to snake_case and an\n    underscore is appended to any shadowed built-ins. Defaults to False.\n:param resolver: Callable that maps operationId to a function or instance of\n    :class:`resolver.Resolver`.\n:param resolver_error: Error code to return for operations for which the operationId could\n    not be resolved. If no error code is provided, the application will fail when trying to\n    start.\n:param strict_validation: When True, extra form or query parameters not defined in the\n    specification result in a validation error. Defaults to False.\n:param swagger_ui_options: Instance of :class:`options.SwaggerUIOptions` with\n    configuration options for the swagger ui.\n:param uri_parser_class: Class to use for uri parsing. See :mod:`uri_parsing`.\n:param validate_responses: Whether to validate responses against the specification. This has\n    an impact on performance. Defaults to False.\n:param validator_map: A dictionary of validators to use. Defaults to\n    :obj:`validators.VALIDATOR_MAP`.\n:param security_map: A dictionary of security handlers to use. Defaults to\n    :obj:`security.SECURITY_HANDLERS`",
      "decorators": [],
      "arguments": [
        "self",
        "import_name"
      ],
      "imports": [
        "functools",
        "logging",
        "pathlib",
        "typing",
        "starlette.responses.Response",
        "starlette.routing.Router",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.apps.abstract.AbstractApp",
        "connexion.decorators.StarletteDecorator",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.RoutedAPI",
        "connexion.middleware.abstract.RoutedMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.operations.AbstractOperation",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "add_url_rule",
      "module": "asynchronous",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\asynchronous.py",
      "line_number": 202,
      "end_line_number": 211,
      "source_code": "def add_url_rule(\n        self,\n        rule,\n        endpoint: t.Optional[str] = None,\n        view_func: t.Optional[t.Callable] = None,\n        **options,\n    ):\n        self._middleware_app.add_url_rule(\n            rule, endpoint=endpoint, view_func=view_func, **options\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "rule",
        "endpoint",
        "view_func"
      ],
      "imports": [
        "functools",
        "logging",
        "pathlib",
        "typing",
        "starlette.responses.Response",
        "starlette.routing.Router",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.apps.abstract.AbstractApp",
        "connexion.decorators.StarletteDecorator",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.RoutedAPI",
        "connexion.middleware.abstract.RoutedMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.operations.AbstractOperation",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._middleware_app.add_url_rule",
          "body": "def add_url_rule(self, rule, endpoint: t.Optional[str]=None, view_func: t.Optional[t.Callable]=None, **options):\n    \"\"\"\n        Connects a URL rule.  Works exactly like the `route` decorator.\n\n        Basically this example::\n\n            @app.route('/')\n            def index():\n                pass\n\n        Is equivalent to the following::\n\n            def index():\n                pass\n            app.add_url_rule('/', 'index', index)\n\n        Internally`route` invokes `add_url_rule` so if you want to customize the behavior via\n        subclassing you only need to change this method.\n\n        :param rule: the URL rule as string.\n        :param endpoint: the name of the endpoint for the registered URL rule, which is used for\n            reverse lookup. Flask defaults to the name of the view function.\n        :param view_func: the function to call when serving a request to the provided endpoint.\n        :param options: the options to be forwarded to the underlying ``werkzeug.routing.Rule``\n            object.  A change to Werkzeug is handling of method options. methods is a list of\n            methods this rule should be limited to (`GET`, `POST` etc.).  By default a rule just\n            listens for `GET` (and implicitly `HEAD`).\n        \"\"\""
        }
      ]
    },
    {
      "name": "add_error_handler",
      "module": "asynchronous",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\asynchronous.py",
      "line_number": 213,
      "end_line_number": 220,
      "source_code": "def add_error_handler(\n        self,\n        code_or_exception: t.Union[int, t.Type[Exception]],\n        function: t.Callable[\n            [ConnexionRequest, Exception], MaybeAwaitable[ConnexionResponse]\n        ],\n    ) -> None:\n        self.middleware.add_error_handler(code_or_exception, function)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "code_or_exception",
        "function"
      ],
      "imports": [
        "functools",
        "logging",
        "pathlib",
        "typing",
        "starlette.responses.Response",
        "starlette.routing.Router",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.apps.abstract.AbstractApp",
        "connexion.decorators.StarletteDecorator",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.RoutedAPI",
        "connexion.middleware.abstract.RoutedMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.operations.AbstractOperation",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.middleware.add_error_handler",
          "body": "@abc.abstractmethod\ndef add_error_handler(self, code_or_exception: t.Union[int, t.Type[Exception]], function: t.Callable[[ConnexionRequest, Exception], MaybeAwaitable[ConnexionResponse]]) -> None:\n    \"\"\"\n        Register a callable to handle application errors.\n\n        :param code_or_exception: An exception class or the status code of HTTP exceptions to\n            handle.\n        :param function: Callable that will handle exception, may be async.\n        \"\"\""
        }
      ]
    },
    {
      "name": "__init__",
      "module": "flask",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\flask.py",
      "line_number": 31,
      "end_line_number": 42,
      "source_code": "def __init__(\n        self,\n        fn: t.Callable,\n        jsonifier: Jsonifier,\n        operation_id: str,\n        pythonic_params: bool,\n    ) -> None:\n        self._fn = fn\n        self.jsonifier = jsonifier\n        self.operation_id = operation_id\n        self.pythonic_params = pythonic_params\n        functools.update_wrapper(self, fn)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "fn",
        "jsonifier",
        "operation_id",
        "pythonic_params"
      ],
      "imports": [
        "functools",
        "pathlib",
        "typing",
        "flask",
        "starlette.exceptions",
        "werkzeug.exceptions",
        "a2wsgi.WSGIMiddleware",
        "flask.Response",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.apps.abstract.AbstractApp",
        "connexion.decorators.FlaskDecorator",
        "connexion.exceptions.ResolverError",
        "connexion.frameworks.flask",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.middleware.abstract.SpecMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.operations.AbstractOperation",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.types.WSGIApp",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "from_operation",
      "module": "flask",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\flask.py",
      "line_number": 45,
      "end_line_number": 57,
      "source_code": "def from_operation(\n        cls,\n        operation: AbstractOperation,\n        *,\n        pythonic_params: bool,\n        jsonifier: Jsonifier,\n    ) -> \"FlaskOperation\":\n        return cls(\n            fn=operation.function,\n            jsonifier=jsonifier,\n            operation_id=operation.operation_id,\n            pythonic_params=pythonic_params,\n        )",
      "docstring": null,
      "decorators": [
        "classmethod"
      ],
      "arguments": [
        "cls",
        "operation"
      ],
      "imports": [
        "functools",
        "pathlib",
        "typing",
        "flask",
        "starlette.exceptions",
        "werkzeug.exceptions",
        "a2wsgi.WSGIMiddleware",
        "flask.Response",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.apps.abstract.AbstractApp",
        "connexion.decorators.FlaskDecorator",
        "connexion.exceptions.ResolverError",
        "connexion.frameworks.flask",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.middleware.abstract.SpecMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.operations.AbstractOperation",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.types.WSGIApp",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "fn",
      "module": "flask",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\flask.py",
      "line_number": 60,
      "end_line_number": 65,
      "source_code": "def fn(self) -> t.Callable:\n        decorator = FlaskDecorator(\n            pythonic_params=self.pythonic_params,\n            jsonifier=self.jsonifier,\n        )\n        return decorator(self._fn)",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "functools",
        "pathlib",
        "typing",
        "flask",
        "starlette.exceptions",
        "werkzeug.exceptions",
        "a2wsgi.WSGIMiddleware",
        "flask.Response",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.apps.abstract.AbstractApp",
        "connexion.decorators.FlaskDecorator",
        "connexion.exceptions.ResolverError",
        "connexion.frameworks.flask",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.middleware.abstract.SpecMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.operations.AbstractOperation",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.types.WSGIApp",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__call__",
      "module": "flask",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\flask.py",
      "line_number": 67,
      "end_line_number": 68,
      "source_code": "def __call__(self, *args, **kwargs) -> FlaskResponse:\n        return self.fn(*args, **kwargs)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "functools",
        "pathlib",
        "typing",
        "flask",
        "starlette.exceptions",
        "werkzeug.exceptions",
        "a2wsgi.WSGIMiddleware",
        "flask.Response",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.apps.abstract.AbstractApp",
        "connexion.decorators.FlaskDecorator",
        "connexion.exceptions.ResolverError",
        "connexion.frameworks.flask",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.middleware.abstract.SpecMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.operations.AbstractOperation",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.types.WSGIApp",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.fn",
          "body": "@property\ndef fn(self) -> t.Callable:\n    decorator = StarletteDecorator(pythonic_params=self.pythonic_params, jsonifier=self.jsonifier)\n    return decorator(self._fn)"
        }
      ]
    },
    {
      "name": "__init__",
      "module": "flask",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\flask.py",
      "line_number": 72,
      "end_line_number": 76,
      "source_code": "def __init__(\n        self, *args, jsonifier: t.Optional[Jsonifier] = None, **kwargs\n    ) -> None:\n        self.jsonifier = jsonifier or Jsonifier(flask.json, indent=2)\n        super().__init__(*args, **kwargs)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "functools",
        "pathlib",
        "typing",
        "flask",
        "starlette.exceptions",
        "werkzeug.exceptions",
        "a2wsgi.WSGIMiddleware",
        "flask.Response",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.apps.abstract.AbstractApp",
        "connexion.decorators.FlaskDecorator",
        "connexion.exceptions.ResolverError",
        "connexion.frameworks.flask",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.middleware.abstract.SpecMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.operations.AbstractOperation",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.types.WSGIApp",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_set_base_path",
      "module": "flask",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\flask.py",
      "line_number": 78,
      "end_line_number": 80,
      "source_code": "def _set_base_path(self, base_path: t.Optional[str] = None) -> None:\n        super()._set_base_path(base_path)\n        self._set_blueprint()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "base_path"
      ],
      "imports": [
        "functools",
        "pathlib",
        "typing",
        "flask",
        "starlette.exceptions",
        "werkzeug.exceptions",
        "a2wsgi.WSGIMiddleware",
        "flask.Response",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.apps.abstract.AbstractApp",
        "connexion.decorators.FlaskDecorator",
        "connexion.exceptions.ResolverError",
        "connexion.frameworks.flask",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.middleware.abstract.SpecMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.operations.AbstractOperation",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.types.WSGIApp",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._set_blueprint",
          "body": "def _set_blueprint(self):\n    endpoint = flask_utils.flaskify_endpoint(self.base_path) or '/'\n    self.blueprint = flask.Blueprint(endpoint, __name__, url_prefix=self.base_path)"
        }
      ]
    },
    {
      "name": "_set_blueprint",
      "module": "flask",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\flask.py",
      "line_number": 82,
      "end_line_number": 88,
      "source_code": "def _set_blueprint(self):\n        endpoint = flask_utils.flaskify_endpoint(self.base_path) or \"/\"\n        self.blueprint = flask.Blueprint(\n            endpoint,\n            __name__,\n            url_prefix=self.base_path,\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "functools",
        "pathlib",
        "typing",
        "flask",
        "starlette.exceptions",
        "werkzeug.exceptions",
        "a2wsgi.WSGIMiddleware",
        "flask.Response",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.apps.abstract.AbstractApp",
        "connexion.decorators.FlaskDecorator",
        "connexion.exceptions.ResolverError",
        "connexion.frameworks.flask",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.middleware.abstract.SpecMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.operations.AbstractOperation",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.types.WSGIApp",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "flask_utils.flaskify_endpoint",
          "body": "def flaskify_endpoint(identifier, randomize=None):\n    \"\"\"\n    Converts the provided identifier in a valid flask endpoint name\n\n    :type identifier: str\n    :param randomize: If specified, add this many random characters (upper case\n        and digits) to the endpoint name, separated by a pipe character.\n    :type randomize: int | None\n    :rtype: str\n\n    \"\"\"\n    result = identifier.replace('.', '_')\n    if randomize is None:\n        return result\n    chars = string.ascii_uppercase + string.digits\n    return '{result}|{random_string}'.format(result=result, random_string=''.join((random.SystemRandom().choice(chars) for _ in range(randomize))))"
        }
      ]
    },
    {
      "name": "_add_resolver_error_handler",
      "module": "flask",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\flask.py",
      "line_number": 90,
      "end_line_number": 91,
      "source_code": "def _add_resolver_error_handler(self, method: str, path: str, err: ResolverError):\n        pass",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "method",
        "path",
        "err"
      ],
      "imports": [
        "functools",
        "pathlib",
        "typing",
        "flask",
        "starlette.exceptions",
        "werkzeug.exceptions",
        "a2wsgi.WSGIMiddleware",
        "flask.Response",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.apps.abstract.AbstractApp",
        "connexion.decorators.FlaskDecorator",
        "connexion.exceptions.ResolverError",
        "connexion.frameworks.flask",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.middleware.abstract.SpecMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.operations.AbstractOperation",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.types.WSGIApp",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "make_operation",
      "module": "flask",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\flask.py",
      "line_number": 93,
      "end_line_number": 96,
      "source_code": "def make_operation(self, operation):\n        return FlaskOperation.from_operation(\n            operation, pythonic_params=self.pythonic_params, jsonifier=self.jsonifier\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "operation"
      ],
      "imports": [
        "functools",
        "pathlib",
        "typing",
        "flask",
        "starlette.exceptions",
        "werkzeug.exceptions",
        "a2wsgi.WSGIMiddleware",
        "flask.Response",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.apps.abstract.AbstractApp",
        "connexion.decorators.FlaskDecorator",
        "connexion.exceptions.ResolverError",
        "connexion.frameworks.flask",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.middleware.abstract.SpecMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.operations.AbstractOperation",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.types.WSGIApp",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "FlaskOperation.from_operation",
          "body": "@classmethod\ndef from_operation(cls, operation: AbstractOperation, *, pythonic_params: bool, jsonifier: Jsonifier) -> 'AsyncOperation':\n    return cls(operation.function, jsonifier=jsonifier, operation_id=operation.operation_id, pythonic_params=pythonic_params)"
        }
      ]
    },
    {
      "name": "_framework_path_and_name",
      "module": "flask",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\flask.py",
      "line_number": 99,
      "end_line_number": 108,
      "source_code": "def _framework_path_and_name(\n        operation: AbstractOperation, path: str\n    ) -> t.Tuple[str, str]:\n        flask_path = flask_utils.flaskify_path(\n            path, operation.get_path_parameter_types()\n        )\n        endpoint_name = flask_utils.flaskify_endpoint(\n            operation.operation_id, operation.randomize_endpoint\n        )\n        return flask_path, endpoint_name",
      "docstring": null,
      "decorators": [
        "staticmethod"
      ],
      "arguments": [
        "operation",
        "path"
      ],
      "imports": [
        "functools",
        "pathlib",
        "typing",
        "flask",
        "starlette.exceptions",
        "werkzeug.exceptions",
        "a2wsgi.WSGIMiddleware",
        "flask.Response",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.apps.abstract.AbstractApp",
        "connexion.decorators.FlaskDecorator",
        "connexion.exceptions.ResolverError",
        "connexion.frameworks.flask",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.middleware.abstract.SpecMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.operations.AbstractOperation",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.types.WSGIApp",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "flask_utils.flaskify_path",
          "body": "def flaskify_path(swagger_path, types=None):\n    \"\"\"\n    Convert swagger path templates to flask path templates\n\n    :type swagger_path: str\n    :type types: dict\n    :rtype: str\n\n    >>> flaskify_path('/foo-bar/{my-param}')\n    '/foo-bar/<my_param>'\n\n    >>> flaskify_path('/foo/{someint}', {'someint': 'int'})\n    '/foo/<int:someint>'\n    \"\"\"\n    if types is None:\n        types = {}\n    convert_match = functools.partial(convert_path_parameter, types=types)\n    return PATH_PARAMETER.sub(convert_match, swagger_path)"
        },
        {
          "name": "flask_utils.flaskify_endpoint",
          "body": "def flaskify_endpoint(identifier, randomize=None):\n    \"\"\"\n    Converts the provided identifier in a valid flask endpoint name\n\n    :type identifier: str\n    :param randomize: If specified, add this many random characters (upper case\n        and digits) to the endpoint name, separated by a pipe character.\n    :type randomize: int | None\n    :rtype: str\n\n    \"\"\"\n    result = identifier.replace('.', '_')\n    if randomize is None:\n        return result\n    chars = string.ascii_uppercase + string.digits\n    return '{result}|{random_string}'.format(result=result, random_string=''.join((random.SystemRandom().choice(chars) for _ in range(randomize))))"
        },
        {
          "name": "operation.get_path_parameter_types",
          "body": "def get_path_parameter_types(self):\n    return {}"
        }
      ]
    },
    {
      "name": "_add_operation_internal",
      "module": "flask",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\flask.py",
      "line_number": 110,
      "end_line_number": 117,
      "source_code": "def _add_operation_internal(\n        self,\n        method: str,\n        path: str,\n        operation: t.Callable,\n        name: t.Optional[str] = None,\n    ) -> None:\n        self.blueprint.add_url_rule(path, name, operation, methods=[method])",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "method",
        "path",
        "operation",
        "name"
      ],
      "imports": [
        "functools",
        "pathlib",
        "typing",
        "flask",
        "starlette.exceptions",
        "werkzeug.exceptions",
        "a2wsgi.WSGIMiddleware",
        "flask.Response",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.apps.abstract.AbstractApp",
        "connexion.decorators.FlaskDecorator",
        "connexion.exceptions.ResolverError",
        "connexion.frameworks.flask",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.middleware.abstract.SpecMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.operations.AbstractOperation",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.types.WSGIApp",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.blueprint.add_url_rule",
          "body": "def add_url_rule(self, rule, endpoint: t.Optional[str]=None, view_func: t.Optional[t.Callable]=None, **options):\n    \"\"\"\n        Connects a URL rule.  Works exactly like the `route` decorator.\n\n        Basically this example::\n\n            @app.route('/')\n            def index():\n                pass\n\n        Is equivalent to the following::\n\n            def index():\n                pass\n            app.add_url_rule('/', 'index', index)\n\n        Internally`route` invokes `add_url_rule` so if you want to customize the behavior via\n        subclassing you only need to change this method.\n\n        :param rule: the URL rule as string.\n        :param endpoint: the name of the endpoint for the registered URL rule, which is used for\n            reverse lookup. Flask defaults to the name of the view function.\n        :param view_func: the function to call when serving a request to the provided endpoint.\n        :param options: the options to be forwarded to the underlying ``werkzeug.routing.Rule``\n            object.  A change to Werkzeug is handling of method options. methods is a list of\n            methods this rule should be limited to (`GET`, `POST` etc.).  By default a rule just\n            listens for `GET` (and implicitly `HEAD`).\n        \"\"\""
        }
      ]
    },
    {
      "name": "add_url_rule",
      "module": "flask",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\flask.py",
      "line_number": 119,
      "end_line_number": 126,
      "source_code": "def add_url_rule(\n        self,\n        rule,\n        endpoint: t.Optional[str] = None,\n        view_func: t.Optional[t.Callable] = None,\n        **options,\n    ):\n        return self.blueprint.add_url_rule(rule, endpoint, view_func, **options)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "rule",
        "endpoint",
        "view_func"
      ],
      "imports": [
        "functools",
        "pathlib",
        "typing",
        "flask",
        "starlette.exceptions",
        "werkzeug.exceptions",
        "a2wsgi.WSGIMiddleware",
        "flask.Response",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.apps.abstract.AbstractApp",
        "connexion.decorators.FlaskDecorator",
        "connexion.exceptions.ResolverError",
        "connexion.frameworks.flask",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.middleware.abstract.SpecMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.operations.AbstractOperation",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.types.WSGIApp",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.blueprint.add_url_rule",
          "body": "def add_url_rule(self, rule, endpoint: t.Optional[str]=None, view_func: t.Optional[t.Callable]=None, **options):\n    \"\"\"\n        Connects a URL rule.  Works exactly like the `route` decorator.\n\n        Basically this example::\n\n            @app.route('/')\n            def index():\n                pass\n\n        Is equivalent to the following::\n\n            def index():\n                pass\n            app.add_url_rule('/', 'index', index)\n\n        Internally`route` invokes `add_url_rule` so if you want to customize the behavior via\n        subclassing you only need to change this method.\n\n        :param rule: the URL rule as string.\n        :param endpoint: the name of the endpoint for the registered URL rule, which is used for\n            reverse lookup. Flask defaults to the name of the view function.\n        :param view_func: the function to call when serving a request to the provided endpoint.\n        :param options: the options to be forwarded to the underlying ``werkzeug.routing.Rule``\n            object.  A change to Werkzeug is handling of method options. methods is a list of\n            methods this rule should be limited to (`GET`, `POST` etc.).  By default a rule just\n            listens for `GET` (and implicitly `HEAD`).\n        \"\"\""
        }
      ]
    },
    {
      "name": "__init__",
      "module": "flask",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\flask.py",
      "line_number": 130,
      "end_line_number": 141,
      "source_code": "def __init__(self, import_name, server_args: dict, **kwargs):\n        self.app = flask.Flask(import_name, **server_args)\n        self.app.json = flask_utils.FlaskJSONProvider(self.app)\n        self.app.url_map.converters[\"float\"] = flask_utils.NumberConverter\n        self.app.url_map.converters[\"int\"] = flask_utils.IntegerConverter\n\n        # Propagate Errors so we can handle them in the middleware\n        self.app.config[\"PROPAGATE_EXCEPTIONS\"] = True\n        self.app.config[\"TRAP_BAD_REQUEST_ERRORS\"] = True\n        self.app.config[\"TRAP_HTTP_EXCEPTIONS\"] = True\n\n        self.asgi_app = WSGIMiddleware(self.app.wsgi_app)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "import_name",
        "server_args"
      ],
      "imports": [
        "functools",
        "pathlib",
        "typing",
        "flask",
        "starlette.exceptions",
        "werkzeug.exceptions",
        "a2wsgi.WSGIMiddleware",
        "flask.Response",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.apps.abstract.AbstractApp",
        "connexion.decorators.FlaskDecorator",
        "connexion.exceptions.ResolverError",
        "connexion.frameworks.flask",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.middleware.abstract.SpecMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.operations.AbstractOperation",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.types.WSGIApp",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "add_api",
      "module": "flask",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\flask.py",
      "line_number": 143,
      "end_line_number": 151,
      "source_code": "def add_api(self, specification, *, name: t.Optional[str] = None, **kwargs):\n        api = FlaskApi(specification, **kwargs)\n\n        if name is not None:\n            self.app.register_blueprint(api.blueprint, name=name)\n        else:\n            self.app.register_blueprint(api.blueprint)\n\n        return api",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "specification"
      ],
      "imports": [
        "functools",
        "pathlib",
        "typing",
        "flask",
        "starlette.exceptions",
        "werkzeug.exceptions",
        "a2wsgi.WSGIMiddleware",
        "flask.Response",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.apps.abstract.AbstractApp",
        "connexion.decorators.FlaskDecorator",
        "connexion.exceptions.ResolverError",
        "connexion.frameworks.flask",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.middleware.abstract.SpecMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.operations.AbstractOperation",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.types.WSGIApp",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "add_url_rule",
      "module": "flask",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\flask.py",
      "line_number": 153,
      "end_line_number": 160,
      "source_code": "def add_url_rule(\n        self,\n        rule,\n        endpoint: t.Optional[str] = None,\n        view_func: t.Optional[t.Callable] = None,\n        **options,\n    ):\n        return self.app.add_url_rule(rule, endpoint, view_func, **options)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "rule",
        "endpoint",
        "view_func"
      ],
      "imports": [
        "functools",
        "pathlib",
        "typing",
        "flask",
        "starlette.exceptions",
        "werkzeug.exceptions",
        "a2wsgi.WSGIMiddleware",
        "flask.Response",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.apps.abstract.AbstractApp",
        "connexion.decorators.FlaskDecorator",
        "connexion.exceptions.ResolverError",
        "connexion.frameworks.flask",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.middleware.abstract.SpecMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.operations.AbstractOperation",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.types.WSGIApp",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.app.add_url_rule",
          "body": "def add_url_rule(self, rule, endpoint: t.Optional[str]=None, view_func: t.Optional[t.Callable]=None, **options):\n    \"\"\"\n        Connects a URL rule.  Works exactly like the `route` decorator.\n\n        Basically this example::\n\n            @app.route('/')\n            def index():\n                pass\n\n        Is equivalent to the following::\n\n            def index():\n                pass\n            app.add_url_rule('/', 'index', index)\n\n        Internally`route` invokes `add_url_rule` so if you want to customize the behavior via\n        subclassing you only need to change this method.\n\n        :param rule: the URL rule as string.\n        :param endpoint: the name of the endpoint for the registered URL rule, which is used for\n            reverse lookup. Flask defaults to the name of the view function.\n        :param view_func: the function to call when serving a request to the provided endpoint.\n        :param options: the options to be forwarded to the underlying ``werkzeug.routing.Rule``\n            object.  A change to Werkzeug is handling of method options. methods is a list of\n            methods this rule should be limited to (`GET`, `POST` etc.).  By default a rule just\n            listens for `GET` (and implicitly `HEAD`).\n        \"\"\""
        }
      ]
    },
    {
      "name": "__init__",
      "module": "flask",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\flask.py",
      "line_number": 171,
      "end_line_number": 251,
      "source_code": "def __init__(\n        self,\n        import_name: str,\n        *,\n        lifespan: t.Optional[Lifespan] = None,\n        middlewares: t.Optional[list] = None,\n        server_args: t.Optional[dict] = None,\n        specification_dir: t.Union[pathlib.Path, str] = \"\",\n        arguments: t.Optional[dict] = None,\n        auth_all_paths: t.Optional[bool] = None,\n        jsonifier: t.Optional[Jsonifier] = None,\n        pythonic_params: t.Optional[bool] = None,\n        resolver: t.Optional[t.Union[Resolver, t.Callable]] = None,\n        resolver_error: t.Optional[int] = None,\n        strict_validation: t.Optional[bool] = None,\n        swagger_ui_options: t.Optional[SwaggerUIOptions] = None,\n        uri_parser_class: t.Optional[AbstractURIParser] = None,\n        validate_responses: t.Optional[bool] = None,\n        validator_map: t.Optional[dict] = None,\n        security_map: t.Optional[dict] = None,\n    ):\n        \"\"\"\n        :param import_name: The name of the package or module that this object belongs to. If you\n            are using a single module, __name__ is always the correct value. If you however are\n            using a package, it\u2019s usually recommended to hardcode the name of your package there.\n        :param lifespan: A lifespan context function, which can be used to perform startup and\n            shutdown tasks.\n        :param middlewares: The list of middlewares to wrap around the application. Defaults to\n            :obj:`middleware.main.ConnexionMiddleware.default_middlewares`\n        :param server_args: Arguments to pass to the Flask application.\n        :param specification_dir: The directory holding the specification(s). The provided path\n            should either be absolute or relative to the root path of the application. Defaults to\n            the root path.\n        :param arguments: Arguments to substitute the specification using Jinja.\n        :param auth_all_paths: whether to authenticate all paths not defined in the specification.\n            Defaults to False.\n        :param jsonifier: Custom jsonifier to overwrite json encoding for json responses.\n        :param pythonic_params: When True, CamelCase parameters are converted to snake_case and an\n            underscore is appended to any shadowed built-ins. Defaults to False.\n        :param resolver: Callable that maps operationId to a function or instance of\n            :class:`resolver.Resolver`.\n        :param resolver_error: Error code to return for operations for which the operationId could\n            not be resolved. If no error code is provided, the application will fail when trying to\n            start.\n        :param strict_validation: When True, extra form or query parameters not defined in the\n            specification result in a validation error. Defaults to False.\n        :param swagger_ui_options: Instance of :class:`options.SwaggerUIOptions` with\n            configuration options for the swagger ui.\n        :param uri_parser_class: Class to use for uri parsing. See :mod:`uri_parsing`.\n        :param validate_responses: Whether to validate responses against the specification. This has\n            an impact on performance. Defaults to False.\n        :param validator_map: A dictionary of validators to use. Defaults to\n            :obj:`validators.VALIDATOR_MAP`.\n        :param security_map: A dictionary of security handlers to use. Defaults to\n            :obj:`security.SECURITY_HANDLERS`\n        \"\"\"\n        self._middleware_app = FlaskASGIApp(import_name, server_args or {})\n\n        super().__init__(\n            import_name,\n            lifespan=lifespan,\n            middlewares=middlewares,\n            specification_dir=specification_dir,\n            arguments=arguments,\n            auth_all_paths=auth_all_paths,\n            jsonifier=jsonifier,\n            pythonic_params=pythonic_params,\n            resolver=resolver,\n            resolver_error=resolver_error,\n            strict_validation=strict_validation,\n            swagger_ui_options=swagger_ui_options,\n            uri_parser_class=uri_parser_class,\n            validate_responses=validate_responses,\n            validator_map=validator_map,\n            security_map=security_map,\n        )\n\n        self.app = self._middleware_app.app\n        self.app.register_error_handler(\n            werkzeug.exceptions.HTTPException, self._http_exception\n        )",
      "docstring": ":param import_name: The name of the package or module that this object belongs to. If you\n    are using a single module, __name__ is always the correct value. If you however are\n    using a package, it\u2019s usually recommended to hardcode the name of your package there.\n:param lifespan: A lifespan context function, which can be used to perform startup and\n    shutdown tasks.\n:param middlewares: The list of middlewares to wrap around the application. Defaults to\n    :obj:`middleware.main.ConnexionMiddleware.default_middlewares`\n:param server_args: Arguments to pass to the Flask application.\n:param specification_dir: The directory holding the specification(s). The provided path\n    should either be absolute or relative to the root path of the application. Defaults to\n    the root path.\n:param arguments: Arguments to substitute the specification using Jinja.\n:param auth_all_paths: whether to authenticate all paths not defined in the specification.\n    Defaults to False.\n:param jsonifier: Custom jsonifier to overwrite json encoding for json responses.\n:param pythonic_params: When True, CamelCase parameters are converted to snake_case and an\n    underscore is appended to any shadowed built-ins. Defaults to False.\n:param resolver: Callable that maps operationId to a function or instance of\n    :class:`resolver.Resolver`.\n:param resolver_error: Error code to return for operations for which the operationId could\n    not be resolved. If no error code is provided, the application will fail when trying to\n    start.\n:param strict_validation: When True, extra form or query parameters not defined in the\n    specification result in a validation error. Defaults to False.\n:param swagger_ui_options: Instance of :class:`options.SwaggerUIOptions` with\n    configuration options for the swagger ui.\n:param uri_parser_class: Class to use for uri parsing. See :mod:`uri_parsing`.\n:param validate_responses: Whether to validate responses against the specification. This has\n    an impact on performance. Defaults to False.\n:param validator_map: A dictionary of validators to use. Defaults to\n    :obj:`validators.VALIDATOR_MAP`.\n:param security_map: A dictionary of security handlers to use. Defaults to\n    :obj:`security.SECURITY_HANDLERS`",
      "decorators": [],
      "arguments": [
        "self",
        "import_name"
      ],
      "imports": [
        "functools",
        "pathlib",
        "typing",
        "flask",
        "starlette.exceptions",
        "werkzeug.exceptions",
        "a2wsgi.WSGIMiddleware",
        "flask.Response",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.apps.abstract.AbstractApp",
        "connexion.decorators.FlaskDecorator",
        "connexion.exceptions.ResolverError",
        "connexion.frameworks.flask",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.middleware.abstract.SpecMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.operations.AbstractOperation",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.types.WSGIApp",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_http_exception",
      "module": "flask",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\flask.py",
      "line_number": 253,
      "end_line_number": 255,
      "source_code": "def _http_exception(self, exc: werkzeug.exceptions.HTTPException):\n        \"\"\"Reraise werkzeug HTTPExceptions as starlette HTTPExceptions\"\"\"\n        raise starlette.exceptions.HTTPException(exc.code, detail=exc.description)",
      "docstring": "Reraise werkzeug HTTPExceptions as starlette HTTPExceptions",
      "decorators": [],
      "arguments": [
        "self",
        "exc"
      ],
      "imports": [
        "functools",
        "pathlib",
        "typing",
        "flask",
        "starlette.exceptions",
        "werkzeug.exceptions",
        "a2wsgi.WSGIMiddleware",
        "flask.Response",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.apps.abstract.AbstractApp",
        "connexion.decorators.FlaskDecorator",
        "connexion.exceptions.ResolverError",
        "connexion.frameworks.flask",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.middleware.abstract.SpecMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.operations.AbstractOperation",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.types.WSGIApp",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "add_url_rule",
      "module": "flask",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\flask.py",
      "line_number": 257,
      "end_line_number": 266,
      "source_code": "def add_url_rule(\n        self,\n        rule,\n        endpoint: t.Optional[str] = None,\n        view_func: t.Optional[t.Callable] = None,\n        **options,\n    ):\n        self._middleware_app.add_url_rule(\n            rule, endpoint=endpoint, view_func=view_func, **options\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "rule",
        "endpoint",
        "view_func"
      ],
      "imports": [
        "functools",
        "pathlib",
        "typing",
        "flask",
        "starlette.exceptions",
        "werkzeug.exceptions",
        "a2wsgi.WSGIMiddleware",
        "flask.Response",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.apps.abstract.AbstractApp",
        "connexion.decorators.FlaskDecorator",
        "connexion.exceptions.ResolverError",
        "connexion.frameworks.flask",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.middleware.abstract.SpecMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.operations.AbstractOperation",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.types.WSGIApp",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._middleware_app.add_url_rule",
          "body": "def add_url_rule(self, rule, endpoint: t.Optional[str]=None, view_func: t.Optional[t.Callable]=None, **options):\n    \"\"\"\n        Connects a URL rule.  Works exactly like the `route` decorator.\n\n        Basically this example::\n\n            @app.route('/')\n            def index():\n                pass\n\n        Is equivalent to the following::\n\n            def index():\n                pass\n            app.add_url_rule('/', 'index', index)\n\n        Internally`route` invokes `add_url_rule` so if you want to customize the behavior via\n        subclassing you only need to change this method.\n\n        :param rule: the URL rule as string.\n        :param endpoint: the name of the endpoint for the registered URL rule, which is used for\n            reverse lookup. Flask defaults to the name of the view function.\n        :param view_func: the function to call when serving a request to the provided endpoint.\n        :param options: the options to be forwarded to the underlying ``werkzeug.routing.Rule``\n            object.  A change to Werkzeug is handling of method options. methods is a list of\n            methods this rule should be limited to (`GET`, `POST` etc.).  By default a rule just\n            listens for `GET` (and implicitly `HEAD`).\n        \"\"\""
        }
      ]
    },
    {
      "name": "add_error_handler",
      "module": "flask",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\flask.py",
      "line_number": 268,
      "end_line_number": 275,
      "source_code": "def add_error_handler(\n        self,\n        code_or_exception: t.Union[int, t.Type[Exception]],\n        function: t.Callable[\n            [ConnexionRequest, Exception], MaybeAwaitable[ConnexionResponse]\n        ],\n    ) -> None:\n        self.middleware.add_error_handler(code_or_exception, function)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "code_or_exception",
        "function"
      ],
      "imports": [
        "functools",
        "pathlib",
        "typing",
        "flask",
        "starlette.exceptions",
        "werkzeug.exceptions",
        "a2wsgi.WSGIMiddleware",
        "flask.Response",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.apps.abstract.AbstractApp",
        "connexion.decorators.FlaskDecorator",
        "connexion.exceptions.ResolverError",
        "connexion.frameworks.flask",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.middleware.abstract.SpecMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.operations.AbstractOperation",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.types.WSGIApp",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.middleware.add_error_handler",
          "body": "@abc.abstractmethod\ndef add_error_handler(self, code_or_exception: t.Union[int, t.Type[Exception]], function: t.Callable[[ConnexionRequest, Exception], MaybeAwaitable[ConnexionResponse]]) -> None:\n    \"\"\"\n        Register a callable to handle application errors.\n\n        :param code_or_exception: An exception class or the status code of HTTP exceptions to\n            handle.\n        :param function: Callable that will handle exception, may be async.\n        \"\"\""
        }
      ]
    },
    {
      "name": "add_wsgi_middleware",
      "module": "flask",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\apps\\flask.py",
      "line_number": 277,
      "end_line_number": 291,
      "source_code": "def add_wsgi_middleware(\n        self, middleware: t.Type[WSGIApp], **options: t.Any\n    ) -> None:\n        \"\"\"Wrap the underlying Flask application with a WSGI middleware. Note that it will only be\n        called at the end of the middleware stack. Middleware that needs to act sooner, needs to\n        be added as ASGI middleware instead.\n\n        Adding multiple middleware using this method wraps each middleware around the previous one.\n\n        :param middleware: Middleware class to add\n        :param options: Options to pass to the middleware_class on initialization\n        \"\"\"\n        self._middleware_app.asgi_app.app = middleware(\n            self._middleware_app.asgi_app.app, **options  # type: ignore\n        )",
      "docstring": "Wrap the underlying Flask application with a WSGI middleware. Note that it will only be\ncalled at the end of the middleware stack. Middleware that needs to act sooner, needs to\nbe added as ASGI middleware instead.\n\nAdding multiple middleware using this method wraps each middleware around the previous one.\n\n:param middleware: Middleware class to add\n:param options: Options to pass to the middleware_class on initialization",
      "decorators": [],
      "arguments": [
        "self",
        "middleware"
      ],
      "imports": [
        "functools",
        "pathlib",
        "typing",
        "flask",
        "starlette.exceptions",
        "werkzeug.exceptions",
        "a2wsgi.WSGIMiddleware",
        "flask.Response",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.apps.abstract.AbstractApp",
        "connexion.decorators.FlaskDecorator",
        "connexion.exceptions.ResolverError",
        "connexion.frameworks.flask",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.middleware.abstract.SpecMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.operations.AbstractOperation",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.types.MaybeAwaitable",
        "connexion.types.WSGIApp",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "main",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\main.py",
      "line_number": 41,
      "end_line_number": 52,
      "source_code": "def __init__(\n        self,\n        *,\n        pythonic_params: bool = False,\n        uri_parser_class: AbstractURIParser = None,\n        jsonifier=json,\n    ) -> None:\n        self.pythonic_params = pythonic_params\n        self.uri_parser_class = uri_parser_class\n        self.jsonifier = jsonifier\n\n        self.arguments, self.has_kwargs = None, None",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "asyncio",
        "functools",
        "json",
        "typing",
        "asgiref.sync.async_to_sync",
        "starlette.concurrency.run_in_threadpool",
        "connexion.context.operation",
        "connexion.context.receive",
        "connexion.context.scope",
        "connexion.decorators.parameter.AsyncParameterDecorator",
        "connexion.decorators.parameter.BaseParameterDecorator",
        "connexion.decorators.parameter.SyncParameterDecorator",
        "connexion.decorators.response.AsyncResponseDecorator",
        "connexion.decorators.response.BaseResponseDecorator",
        "connexion.decorators.response.NoResponseDecorator",
        "connexion.decorators.response.SyncResponseDecorator",
        "connexion.frameworks.abstract.Framework",
        "connexion.frameworks.starlette.Starlette",
        "connexion.uri_parsing.AbstractURIParser",
        "connexion.utils.not_installed_error",
        "connexion.frameworks.flask.Flask"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_parameter_decorator_cls",
      "module": "main",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\main.py",
      "line_number": 56,
      "end_line_number": 57,
      "source_code": "def _parameter_decorator_cls(self) -> t.Type[BaseParameterDecorator]:\n        raise NotImplementedError",
      "docstring": null,
      "decorators": [
        "property",
        "abc.abstractmethod"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "asyncio",
        "functools",
        "json",
        "typing",
        "asgiref.sync.async_to_sync",
        "starlette.concurrency.run_in_threadpool",
        "connexion.context.operation",
        "connexion.context.receive",
        "connexion.context.scope",
        "connexion.decorators.parameter.AsyncParameterDecorator",
        "connexion.decorators.parameter.BaseParameterDecorator",
        "connexion.decorators.parameter.SyncParameterDecorator",
        "connexion.decorators.response.AsyncResponseDecorator",
        "connexion.decorators.response.BaseResponseDecorator",
        "connexion.decorators.response.NoResponseDecorator",
        "connexion.decorators.response.SyncResponseDecorator",
        "connexion.frameworks.abstract.Framework",
        "connexion.frameworks.starlette.Starlette",
        "connexion.uri_parsing.AbstractURIParser",
        "connexion.utils.not_installed_error",
        "connexion.frameworks.flask.Flask"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_response_decorator_cls",
      "module": "main",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\main.py",
      "line_number": 61,
      "end_line_number": 62,
      "source_code": "def _response_decorator_cls(self) -> t.Type[BaseResponseDecorator]:\n        raise NotImplementedError",
      "docstring": null,
      "decorators": [
        "property",
        "abc.abstractmethod"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "asyncio",
        "functools",
        "json",
        "typing",
        "asgiref.sync.async_to_sync",
        "starlette.concurrency.run_in_threadpool",
        "connexion.context.operation",
        "connexion.context.receive",
        "connexion.context.scope",
        "connexion.decorators.parameter.AsyncParameterDecorator",
        "connexion.decorators.parameter.BaseParameterDecorator",
        "connexion.decorators.parameter.SyncParameterDecorator",
        "connexion.decorators.response.AsyncResponseDecorator",
        "connexion.decorators.response.BaseResponseDecorator",
        "connexion.decorators.response.NoResponseDecorator",
        "connexion.decorators.response.SyncResponseDecorator",
        "connexion.frameworks.abstract.Framework",
        "connexion.frameworks.starlette.Starlette",
        "connexion.uri_parsing.AbstractURIParser",
        "connexion.utils.not_installed_error",
        "connexion.frameworks.flask.Flask"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_sync_async_decorator",
      "module": "main",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\main.py",
      "line_number": 66,
      "end_line_number": 68,
      "source_code": "def _sync_async_decorator(self) -> t.Callable[[t.Callable], t.Callable]:\n        \"\"\"Decorator to translate between sync and async functions.\"\"\"\n        raise NotImplementedError",
      "docstring": "Decorator to translate between sync and async functions.",
      "decorators": [
        "property",
        "abc.abstractmethod"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "asyncio",
        "functools",
        "json",
        "typing",
        "asgiref.sync.async_to_sync",
        "starlette.concurrency.run_in_threadpool",
        "connexion.context.operation",
        "connexion.context.receive",
        "connexion.context.scope",
        "connexion.decorators.parameter.AsyncParameterDecorator",
        "connexion.decorators.parameter.BaseParameterDecorator",
        "connexion.decorators.parameter.SyncParameterDecorator",
        "connexion.decorators.response.AsyncResponseDecorator",
        "connexion.decorators.response.BaseResponseDecorator",
        "connexion.decorators.response.NoResponseDecorator",
        "connexion.decorators.response.SyncResponseDecorator",
        "connexion.frameworks.abstract.Framework",
        "connexion.frameworks.starlette.Starlette",
        "connexion.uri_parsing.AbstractURIParser",
        "connexion.utils.not_installed_error",
        "connexion.frameworks.flask.Flask"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "uri_parser",
      "module": "main",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\main.py",
      "line_number": 71,
      "end_line_number": 73,
      "source_code": "def uri_parser(self):\n        uri_parser_class = self.uri_parser_class or operation.uri_parser_class\n        return uri_parser_class(operation.parameters, operation.body_definition())",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "asyncio",
        "functools",
        "json",
        "typing",
        "asgiref.sync.async_to_sync",
        "starlette.concurrency.run_in_threadpool",
        "connexion.context.operation",
        "connexion.context.receive",
        "connexion.context.scope",
        "connexion.decorators.parameter.AsyncParameterDecorator",
        "connexion.decorators.parameter.BaseParameterDecorator",
        "connexion.decorators.parameter.SyncParameterDecorator",
        "connexion.decorators.response.AsyncResponseDecorator",
        "connexion.decorators.response.BaseResponseDecorator",
        "connexion.decorators.response.NoResponseDecorator",
        "connexion.decorators.response.SyncResponseDecorator",
        "connexion.frameworks.abstract.Framework",
        "connexion.frameworks.starlette.Starlette",
        "connexion.uri_parsing.AbstractURIParser",
        "connexion.utils.not_installed_error",
        "connexion.frameworks.flask.Flask"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "uri_parser_class",
          "body": "@property\ndef uri_parser_class(self):\n    return 'dummy'"
        },
        {
          "name": "operation.body_definition",
          "body": "@abc.abstractmethod\ndef body_definition(self, content_type: t.Optional[str]=None) -> dict:\n    \"\"\"\n        The body definition for this operation.\n        :rtype: dict\n        \"\"\""
        }
      ]
    },
    {
      "name": "decorate",
      "module": "main",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\main.py",
      "line_number": 75,
      "end_line_number": 91,
      "source_code": "def decorate(self, function: t.Callable) -> t.Callable:\n        \"\"\"Decorate a function with decorators based on the operation.\"\"\"\n        function = self._sync_async_decorator(function)\n\n        parameter_decorator = self._parameter_decorator_cls(\n            framework=self.framework,\n            pythonic_params=self.pythonic_params,\n        )\n        function = parameter_decorator(function)\n\n        response_decorator = self._response_decorator_cls(\n            framework=self.framework,\n            jsonifier=self.jsonifier,\n        )\n        function = response_decorator(function)\n\n        return function",
      "docstring": "Decorate a function with decorators based on the operation.",
      "decorators": [],
      "arguments": [
        "self",
        "function"
      ],
      "imports": [
        "abc",
        "asyncio",
        "functools",
        "json",
        "typing",
        "asgiref.sync.async_to_sync",
        "starlette.concurrency.run_in_threadpool",
        "connexion.context.operation",
        "connexion.context.receive",
        "connexion.context.scope",
        "connexion.decorators.parameter.AsyncParameterDecorator",
        "connexion.decorators.parameter.BaseParameterDecorator",
        "connexion.decorators.parameter.SyncParameterDecorator",
        "connexion.decorators.response.AsyncResponseDecorator",
        "connexion.decorators.response.BaseResponseDecorator",
        "connexion.decorators.response.NoResponseDecorator",
        "connexion.decorators.response.SyncResponseDecorator",
        "connexion.frameworks.abstract.Framework",
        "connexion.frameworks.starlette.Starlette",
        "connexion.uri_parsing.AbstractURIParser",
        "connexion.utils.not_installed_error",
        "connexion.frameworks.flask.Flask"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._sync_async_decorator",
          "body": "@property\n@abc.abstractmethod\ndef _sync_async_decorator(self) -> t.Callable[[t.Callable], t.Callable]:\n    \"\"\"Decorator to translate between sync and async functions.\"\"\"\n    raise NotImplementedError"
        },
        {
          "name": "self._parameter_decorator_cls",
          "body": "@property\n@abc.abstractmethod\ndef _parameter_decorator_cls(self) -> t.Type[BaseParameterDecorator]:\n    raise NotImplementedError"
        },
        {
          "name": "self._response_decorator_cls",
          "body": "@property\n@abc.abstractmethod\ndef _response_decorator_cls(self) -> t.Type[BaseResponseDecorator]:\n    raise NotImplementedError"
        }
      ]
    },
    {
      "name": "__call__",
      "module": "main",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\main.py",
      "line_number": 94,
      "end_line_number": 95,
      "source_code": "def __call__(self, function: t.Callable) -> t.Callable:\n        raise NotImplementedError",
      "docstring": null,
      "decorators": [
        "abc.abstractmethod"
      ],
      "arguments": [
        "self",
        "function"
      ],
      "imports": [
        "abc",
        "asyncio",
        "functools",
        "json",
        "typing",
        "asgiref.sync.async_to_sync",
        "starlette.concurrency.run_in_threadpool",
        "connexion.context.operation",
        "connexion.context.receive",
        "connexion.context.scope",
        "connexion.decorators.parameter.AsyncParameterDecorator",
        "connexion.decorators.parameter.BaseParameterDecorator",
        "connexion.decorators.parameter.SyncParameterDecorator",
        "connexion.decorators.response.AsyncResponseDecorator",
        "connexion.decorators.response.BaseResponseDecorator",
        "connexion.decorators.response.NoResponseDecorator",
        "connexion.decorators.response.SyncResponseDecorator",
        "connexion.frameworks.abstract.Framework",
        "connexion.frameworks.starlette.Starlette",
        "connexion.uri_parsing.AbstractURIParser",
        "connexion.utils.not_installed_error",
        "connexion.frameworks.flask.Flask"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_parameter_decorator_cls",
      "module": "main",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\main.py",
      "line_number": 108,
      "end_line_number": 109,
      "source_code": "def _parameter_decorator_cls(self) -> t.Type[SyncParameterDecorator]:\n        return SyncParameterDecorator",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "asyncio",
        "functools",
        "json",
        "typing",
        "asgiref.sync.async_to_sync",
        "starlette.concurrency.run_in_threadpool",
        "connexion.context.operation",
        "connexion.context.receive",
        "connexion.context.scope",
        "connexion.decorators.parameter.AsyncParameterDecorator",
        "connexion.decorators.parameter.BaseParameterDecorator",
        "connexion.decorators.parameter.SyncParameterDecorator",
        "connexion.decorators.response.AsyncResponseDecorator",
        "connexion.decorators.response.BaseResponseDecorator",
        "connexion.decorators.response.NoResponseDecorator",
        "connexion.decorators.response.SyncResponseDecorator",
        "connexion.frameworks.abstract.Framework",
        "connexion.frameworks.starlette.Starlette",
        "connexion.uri_parsing.AbstractURIParser",
        "connexion.utils.not_installed_error",
        "connexion.frameworks.flask.Flask"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_response_decorator_cls",
      "module": "main",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\main.py",
      "line_number": 112,
      "end_line_number": 113,
      "source_code": "def _response_decorator_cls(self) -> t.Type[BaseResponseDecorator]:\n        return NoResponseDecorator",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "asyncio",
        "functools",
        "json",
        "typing",
        "asgiref.sync.async_to_sync",
        "starlette.concurrency.run_in_threadpool",
        "connexion.context.operation",
        "connexion.context.receive",
        "connexion.context.scope",
        "connexion.decorators.parameter.AsyncParameterDecorator",
        "connexion.decorators.parameter.BaseParameterDecorator",
        "connexion.decorators.parameter.SyncParameterDecorator",
        "connexion.decorators.response.AsyncResponseDecorator",
        "connexion.decorators.response.BaseResponseDecorator",
        "connexion.decorators.response.NoResponseDecorator",
        "connexion.decorators.response.SyncResponseDecorator",
        "connexion.frameworks.abstract.Framework",
        "connexion.frameworks.starlette.Starlette",
        "connexion.uri_parsing.AbstractURIParser",
        "connexion.utils.not_installed_error",
        "connexion.frameworks.flask.Flask"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_sync_async_decorator",
      "module": "main",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\main.py",
      "line_number": 116,
      "end_line_number": 127,
      "source_code": "def _sync_async_decorator(self) -> t.Callable[[t.Callable], t.Callable]:\n        def decorator(function: t.Callable) -> t.Callable:\n            @functools.wraps(function)\n            def wrapper(*args, **kwargs) -> t.Callable:\n                if asyncio.iscoroutinefunction(function):\n                    return async_to_sync(function)(*args, **kwargs)\n                else:\n                    return function(*args, **kwargs)\n\n            return wrapper\n\n        return decorator",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "asyncio",
        "functools",
        "json",
        "typing",
        "asgiref.sync.async_to_sync",
        "starlette.concurrency.run_in_threadpool",
        "connexion.context.operation",
        "connexion.context.receive",
        "connexion.context.scope",
        "connexion.decorators.parameter.AsyncParameterDecorator",
        "connexion.decorators.parameter.BaseParameterDecorator",
        "connexion.decorators.parameter.SyncParameterDecorator",
        "connexion.decorators.response.AsyncResponseDecorator",
        "connexion.decorators.response.BaseResponseDecorator",
        "connexion.decorators.response.NoResponseDecorator",
        "connexion.decorators.response.SyncResponseDecorator",
        "connexion.frameworks.abstract.Framework",
        "connexion.frameworks.starlette.Starlette",
        "connexion.uri_parsing.AbstractURIParser",
        "connexion.utils.not_installed_error",
        "connexion.frameworks.flask.Flask"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "function",
          "body": "@property\ndef function(self):\n    return self.handle"
        }
      ]
    },
    {
      "name": "__call__",
      "module": "main",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\main.py",
      "line_number": 129,
      "end_line_number": 136,
      "source_code": "def __call__(self, function: t.Callable) -> t.Callable:\n        @functools.wraps(function)\n        def wrapper(*args, **kwargs):\n            request = self.framework.get_request(uri_parser=self.uri_parser)\n            decorated_function = self.decorate(function)\n            return decorated_function(request)\n\n        return wrapper",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "function"
      ],
      "imports": [
        "abc",
        "asyncio",
        "functools",
        "json",
        "typing",
        "asgiref.sync.async_to_sync",
        "starlette.concurrency.run_in_threadpool",
        "connexion.context.operation",
        "connexion.context.receive",
        "connexion.context.scope",
        "connexion.decorators.parameter.AsyncParameterDecorator",
        "connexion.decorators.parameter.BaseParameterDecorator",
        "connexion.decorators.parameter.SyncParameterDecorator",
        "connexion.decorators.response.AsyncResponseDecorator",
        "connexion.decorators.response.BaseResponseDecorator",
        "connexion.decorators.response.NoResponseDecorator",
        "connexion.decorators.response.SyncResponseDecorator",
        "connexion.frameworks.abstract.Framework",
        "connexion.frameworks.starlette.Starlette",
        "connexion.uri_parsing.AbstractURIParser",
        "connexion.utils.not_installed_error",
        "connexion.frameworks.flask.Flask"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.framework.get_request",
          "body": "@staticmethod\n@abc.abstractmethod\ndef get_request(*args, **kwargs):\n    \"\"\"Return a framework request from the context.\"\"\"\n    raise NotImplementedError"
        },
        {
          "name": "self.decorate",
          "body": "def decorate(self, function: t.Callable) -> t.Callable:\n    \"\"\"Decorate a function with decorators based on the operation.\"\"\"\n    function = self._sync_async_decorator(function)\n    parameter_decorator = self._parameter_decorator_cls(framework=self.framework, pythonic_params=self.pythonic_params)\n    function = parameter_decorator(function)\n    response_decorator = self._response_decorator_cls(framework=self.framework, jsonifier=self.jsonifier)\n    function = response_decorator(function)\n    return function"
        }
      ]
    },
    {
      "name": "_response_decorator_cls",
      "module": "main",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\main.py",
      "line_number": 146,
      "end_line_number": 147,
      "source_code": "def _response_decorator_cls(self) -> t.Type[SyncResponseDecorator]:\n        return SyncResponseDecorator",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "asyncio",
        "functools",
        "json",
        "typing",
        "asgiref.sync.async_to_sync",
        "starlette.concurrency.run_in_threadpool",
        "connexion.context.operation",
        "connexion.context.receive",
        "connexion.context.scope",
        "connexion.decorators.parameter.AsyncParameterDecorator",
        "connexion.decorators.parameter.BaseParameterDecorator",
        "connexion.decorators.parameter.SyncParameterDecorator",
        "connexion.decorators.response.AsyncResponseDecorator",
        "connexion.decorators.response.BaseResponseDecorator",
        "connexion.decorators.response.NoResponseDecorator",
        "connexion.decorators.response.SyncResponseDecorator",
        "connexion.frameworks.abstract.Framework",
        "connexion.frameworks.starlette.Starlette",
        "connexion.uri_parsing.AbstractURIParser",
        "connexion.utils.not_installed_error",
        "connexion.frameworks.flask.Flask"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_parameter_decorator_cls",
      "module": "main",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\main.py",
      "line_number": 160,
      "end_line_number": 161,
      "source_code": "def _parameter_decorator_cls(self) -> t.Type[AsyncParameterDecorator]:\n        return AsyncParameterDecorator",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "asyncio",
        "functools",
        "json",
        "typing",
        "asgiref.sync.async_to_sync",
        "starlette.concurrency.run_in_threadpool",
        "connexion.context.operation",
        "connexion.context.receive",
        "connexion.context.scope",
        "connexion.decorators.parameter.AsyncParameterDecorator",
        "connexion.decorators.parameter.BaseParameterDecorator",
        "connexion.decorators.parameter.SyncParameterDecorator",
        "connexion.decorators.response.AsyncResponseDecorator",
        "connexion.decorators.response.BaseResponseDecorator",
        "connexion.decorators.response.NoResponseDecorator",
        "connexion.decorators.response.SyncResponseDecorator",
        "connexion.frameworks.abstract.Framework",
        "connexion.frameworks.starlette.Starlette",
        "connexion.uri_parsing.AbstractURIParser",
        "connexion.utils.not_installed_error",
        "connexion.frameworks.flask.Flask"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_response_decorator_cls",
      "module": "main",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\main.py",
      "line_number": 164,
      "end_line_number": 165,
      "source_code": "def _response_decorator_cls(self) -> t.Type[BaseResponseDecorator]:\n        return NoResponseDecorator",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "asyncio",
        "functools",
        "json",
        "typing",
        "asgiref.sync.async_to_sync",
        "starlette.concurrency.run_in_threadpool",
        "connexion.context.operation",
        "connexion.context.receive",
        "connexion.context.scope",
        "connexion.decorators.parameter.AsyncParameterDecorator",
        "connexion.decorators.parameter.BaseParameterDecorator",
        "connexion.decorators.parameter.SyncParameterDecorator",
        "connexion.decorators.response.AsyncResponseDecorator",
        "connexion.decorators.response.BaseResponseDecorator",
        "connexion.decorators.response.NoResponseDecorator",
        "connexion.decorators.response.SyncResponseDecorator",
        "connexion.frameworks.abstract.Framework",
        "connexion.frameworks.starlette.Starlette",
        "connexion.uri_parsing.AbstractURIParser",
        "connexion.utils.not_installed_error",
        "connexion.frameworks.flask.Flask"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_sync_async_decorator",
      "module": "main",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\main.py",
      "line_number": 168,
      "end_line_number": 179,
      "source_code": "def _sync_async_decorator(self) -> t.Callable[[t.Callable], t.Callable]:\n        def decorator(function: t.Callable) -> t.Callable:\n            @functools.wraps(function)\n            async def wrapper(*args, **kwargs):\n                if asyncio.iscoroutinefunction(function):\n                    return await function(*args, **kwargs)\n                else:\n                    return await run_in_threadpool(function, *args, **kwargs)\n\n            return wrapper\n\n        return decorator",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "asyncio",
        "functools",
        "json",
        "typing",
        "asgiref.sync.async_to_sync",
        "starlette.concurrency.run_in_threadpool",
        "connexion.context.operation",
        "connexion.context.receive",
        "connexion.context.scope",
        "connexion.decorators.parameter.AsyncParameterDecorator",
        "connexion.decorators.parameter.BaseParameterDecorator",
        "connexion.decorators.parameter.SyncParameterDecorator",
        "connexion.decorators.response.AsyncResponseDecorator",
        "connexion.decorators.response.BaseResponseDecorator",
        "connexion.decorators.response.NoResponseDecorator",
        "connexion.decorators.response.SyncResponseDecorator",
        "connexion.frameworks.abstract.Framework",
        "connexion.frameworks.starlette.Starlette",
        "connexion.uri_parsing.AbstractURIParser",
        "connexion.utils.not_installed_error",
        "connexion.frameworks.flask.Flask"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "function",
          "body": "@property\ndef function(self):\n    return self.handle"
        }
      ]
    },
    {
      "name": "__call__",
      "module": "main",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\main.py",
      "line_number": 181,
      "end_line_number": 190,
      "source_code": "def __call__(self, function: t.Callable) -> t.Callable:\n        @functools.wraps(function)\n        async def wrapper(*args, **kwargs):\n            request = self.framework.get_request(\n                uri_parser=self.uri_parser, scope=scope, receive=receive\n            )\n            decorated_function = self.decorate(function)\n            return await decorated_function(request)\n\n        return wrapper",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "function"
      ],
      "imports": [
        "abc",
        "asyncio",
        "functools",
        "json",
        "typing",
        "asgiref.sync.async_to_sync",
        "starlette.concurrency.run_in_threadpool",
        "connexion.context.operation",
        "connexion.context.receive",
        "connexion.context.scope",
        "connexion.decorators.parameter.AsyncParameterDecorator",
        "connexion.decorators.parameter.BaseParameterDecorator",
        "connexion.decorators.parameter.SyncParameterDecorator",
        "connexion.decorators.response.AsyncResponseDecorator",
        "connexion.decorators.response.BaseResponseDecorator",
        "connexion.decorators.response.NoResponseDecorator",
        "connexion.decorators.response.SyncResponseDecorator",
        "connexion.frameworks.abstract.Framework",
        "connexion.frameworks.starlette.Starlette",
        "connexion.uri_parsing.AbstractURIParser",
        "connexion.utils.not_installed_error",
        "connexion.frameworks.flask.Flask"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.framework.get_request",
          "body": "@staticmethod\n@abc.abstractmethod\ndef get_request(*args, **kwargs):\n    \"\"\"Return a framework request from the context.\"\"\"\n    raise NotImplementedError"
        },
        {
          "name": "self.decorate",
          "body": "def decorate(self, function: t.Callable) -> t.Callable:\n    \"\"\"Decorate a function with decorators based on the operation.\"\"\"\n    function = self._sync_async_decorator(function)\n    parameter_decorator = self._parameter_decorator_cls(framework=self.framework, pythonic_params=self.pythonic_params)\n    function = parameter_decorator(function)\n    response_decorator = self._response_decorator_cls(framework=self.framework, jsonifier=self.jsonifier)\n    function = response_decorator(function)\n    return function"
        }
      ]
    },
    {
      "name": "_response_decorator_cls",
      "module": "main",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\main.py",
      "line_number": 200,
      "end_line_number": 201,
      "source_code": "def _response_decorator_cls(self) -> t.Type[AsyncResponseDecorator]:\n        return AsyncResponseDecorator",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "asyncio",
        "functools",
        "json",
        "typing",
        "asgiref.sync.async_to_sync",
        "starlette.concurrency.run_in_threadpool",
        "connexion.context.operation",
        "connexion.context.receive",
        "connexion.context.scope",
        "connexion.decorators.parameter.AsyncParameterDecorator",
        "connexion.decorators.parameter.BaseParameterDecorator",
        "connexion.decorators.parameter.SyncParameterDecorator",
        "connexion.decorators.response.AsyncResponseDecorator",
        "connexion.decorators.response.BaseResponseDecorator",
        "connexion.decorators.response.NoResponseDecorator",
        "connexion.decorators.response.SyncResponseDecorator",
        "connexion.frameworks.abstract.Framework",
        "connexion.frameworks.starlette.Starlette",
        "connexion.uri_parsing.AbstractURIParser",
        "connexion.utils.not_installed_error",
        "connexion.frameworks.flask.Flask"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "decorator",
      "module": "main",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\main.py",
      "line_number": 117,
      "end_line_number": 125,
      "source_code": "def decorator(function: t.Callable) -> t.Callable:\n            @functools.wraps(function)\n            def wrapper(*args, **kwargs) -> t.Callable:\n                if asyncio.iscoroutinefunction(function):\n                    return async_to_sync(function)(*args, **kwargs)\n                else:\n                    return function(*args, **kwargs)\n\n            return wrapper",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "function"
      ],
      "imports": [
        "abc",
        "asyncio",
        "functools",
        "json",
        "typing",
        "asgiref.sync.async_to_sync",
        "starlette.concurrency.run_in_threadpool",
        "connexion.context.operation",
        "connexion.context.receive",
        "connexion.context.scope",
        "connexion.decorators.parameter.AsyncParameterDecorator",
        "connexion.decorators.parameter.BaseParameterDecorator",
        "connexion.decorators.parameter.SyncParameterDecorator",
        "connexion.decorators.response.AsyncResponseDecorator",
        "connexion.decorators.response.BaseResponseDecorator",
        "connexion.decorators.response.NoResponseDecorator",
        "connexion.decorators.response.SyncResponseDecorator",
        "connexion.frameworks.abstract.Framework",
        "connexion.frameworks.starlette.Starlette",
        "connexion.uri_parsing.AbstractURIParser",
        "connexion.utils.not_installed_error",
        "connexion.frameworks.flask.Flask"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "function",
          "body": "@property\ndef function(self):\n    return self.handle"
        }
      ]
    },
    {
      "name": "wrapper",
      "module": "main",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\main.py",
      "line_number": 131,
      "end_line_number": 134,
      "source_code": "def wrapper(*args, **kwargs):\n            request = self.framework.get_request(uri_parser=self.uri_parser)\n            decorated_function = self.decorate(function)\n            return decorated_function(request)",
      "docstring": null,
      "decorators": [
        "functools.wraps(function)"
      ],
      "arguments": [],
      "imports": [
        "abc",
        "asyncio",
        "functools",
        "json",
        "typing",
        "asgiref.sync.async_to_sync",
        "starlette.concurrency.run_in_threadpool",
        "connexion.context.operation",
        "connexion.context.receive",
        "connexion.context.scope",
        "connexion.decorators.parameter.AsyncParameterDecorator",
        "connexion.decorators.parameter.BaseParameterDecorator",
        "connexion.decorators.parameter.SyncParameterDecorator",
        "connexion.decorators.response.AsyncResponseDecorator",
        "connexion.decorators.response.BaseResponseDecorator",
        "connexion.decorators.response.NoResponseDecorator",
        "connexion.decorators.response.SyncResponseDecorator",
        "connexion.frameworks.abstract.Framework",
        "connexion.frameworks.starlette.Starlette",
        "connexion.uri_parsing.AbstractURIParser",
        "connexion.utils.not_installed_error",
        "connexion.frameworks.flask.Flask"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.framework.get_request",
          "body": "@staticmethod\n@abc.abstractmethod\ndef get_request(*args, **kwargs):\n    \"\"\"Return a framework request from the context.\"\"\"\n    raise NotImplementedError"
        },
        {
          "name": "self.decorate",
          "body": "def decorate(self, function: t.Callable) -> t.Callable:\n    \"\"\"Decorate a function with decorators based on the operation.\"\"\"\n    function = self._sync_async_decorator(function)\n    parameter_decorator = self._parameter_decorator_cls(framework=self.framework, pythonic_params=self.pythonic_params)\n    function = parameter_decorator(function)\n    response_decorator = self._response_decorator_cls(framework=self.framework, jsonifier=self.jsonifier)\n    function = response_decorator(function)\n    return function"
        }
      ]
    },
    {
      "name": "decorator",
      "module": "main",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\main.py",
      "line_number": 169,
      "end_line_number": 177,
      "source_code": "def decorator(function: t.Callable) -> t.Callable:\n            @functools.wraps(function)\n            async def wrapper(*args, **kwargs):\n                if asyncio.iscoroutinefunction(function):\n                    return await function(*args, **kwargs)\n                else:\n                    return await run_in_threadpool(function, *args, **kwargs)\n\n            return wrapper",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "function"
      ],
      "imports": [
        "abc",
        "asyncio",
        "functools",
        "json",
        "typing",
        "asgiref.sync.async_to_sync",
        "starlette.concurrency.run_in_threadpool",
        "connexion.context.operation",
        "connexion.context.receive",
        "connexion.context.scope",
        "connexion.decorators.parameter.AsyncParameterDecorator",
        "connexion.decorators.parameter.BaseParameterDecorator",
        "connexion.decorators.parameter.SyncParameterDecorator",
        "connexion.decorators.response.AsyncResponseDecorator",
        "connexion.decorators.response.BaseResponseDecorator",
        "connexion.decorators.response.NoResponseDecorator",
        "connexion.decorators.response.SyncResponseDecorator",
        "connexion.frameworks.abstract.Framework",
        "connexion.frameworks.starlette.Starlette",
        "connexion.uri_parsing.AbstractURIParser",
        "connexion.utils.not_installed_error",
        "connexion.frameworks.flask.Flask"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "function",
          "body": "@property\ndef function(self):\n    return self.handle"
        }
      ]
    },
    {
      "name": "wrapper",
      "module": "main",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\main.py",
      "line_number": 119,
      "end_line_number": 123,
      "source_code": "def wrapper(*args, **kwargs) -> t.Callable:\n                if asyncio.iscoroutinefunction(function):\n                    return async_to_sync(function)(*args, **kwargs)\n                else:\n                    return function(*args, **kwargs)",
      "docstring": null,
      "decorators": [
        "functools.wraps(function)"
      ],
      "arguments": [],
      "imports": [
        "abc",
        "asyncio",
        "functools",
        "json",
        "typing",
        "asgiref.sync.async_to_sync",
        "starlette.concurrency.run_in_threadpool",
        "connexion.context.operation",
        "connexion.context.receive",
        "connexion.context.scope",
        "connexion.decorators.parameter.AsyncParameterDecorator",
        "connexion.decorators.parameter.BaseParameterDecorator",
        "connexion.decorators.parameter.SyncParameterDecorator",
        "connexion.decorators.response.AsyncResponseDecorator",
        "connexion.decorators.response.BaseResponseDecorator",
        "connexion.decorators.response.NoResponseDecorator",
        "connexion.decorators.response.SyncResponseDecorator",
        "connexion.frameworks.abstract.Framework",
        "connexion.frameworks.starlette.Starlette",
        "connexion.uri_parsing.AbstractURIParser",
        "connexion.utils.not_installed_error",
        "connexion.frameworks.flask.Flask"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "function",
          "body": "@property\ndef function(self):\n    return self.handle"
        }
      ]
    },
    {
      "name": "prep_kwargs",
      "module": "parameter",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\parameter.py",
      "line_number": 120,
      "end_line_number": 154,
      "source_code": "def prep_kwargs(\n    request: t.Union[WSGIRequest, ConnexionRequest],\n    *,\n    request_body: t.Any,\n    files: t.Dict[str, t.Any],\n    arguments: t.List[str],\n    has_kwargs: bool,\n    sanitize: t.Callable,\n) -> dict:\n    kwargs = get_arguments(\n        operation,\n        path_params=request.path_params,\n        query_params=request.query_params,\n        body=request_body,\n        files=files,\n        arguments=arguments,\n        has_kwargs=has_kwargs,\n        sanitize=sanitize,\n        content_type=request.mimetype,\n    )\n\n    # optionally convert parameter variable names to un-shadowed, snake_case form\n    kwargs = {sanitize(k): v for k, v in kwargs.items()}\n\n    # add context info (e.g. from security decorator)\n    for key, value in context.items():\n        if has_kwargs or key in arguments:\n            kwargs[key] = value\n        else:\n            logger.debug(\"Context parameter '%s' not in function arguments\", key)\n    # attempt to provide the request context to the function\n    if CONTEXT_NAME in arguments:\n        kwargs[CONTEXT_NAME] = context\n\n    return kwargs",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "request"
      ],
      "imports": [
        "abc",
        "asyncio",
        "builtins",
        "functools",
        "keyword",
        "logging",
        "re",
        "typing",
        "copy.copy",
        "copy.deepcopy",
        "inflection",
        "connexion.context.context",
        "connexion.context.operation",
        "connexion.frameworks.abstract.Framework",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.WSGIRequest",
        "connexion.operations.AbstractOperation",
        "connexion.operations.Swagger2Operation",
        "connexion.utils.deep_merge",
        "connexion.utils.inspect_function_arguments",
        "connexion.utils.is_null",
        "connexion.utils.is_nullable",
        "connexion.utils.make_type"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_arguments",
          "body": "def get_arguments(operation: AbstractOperation, *, path_params: dict, query_params: dict, body: t.Any, files: dict, arguments: t.List[str], has_kwargs: bool, sanitize: t.Callable, content_type: str) -> t.Dict[str, t.Any]:\n    \"\"\"\n    get arguments for handler function\n    \"\"\"\n    ret = {}\n    ret.update(_get_path_arguments(path_params, operation=operation, sanitize=sanitize))\n    ret.update(_get_query_arguments(query_params, operation=operation, arguments=arguments, has_kwargs=has_kwargs, sanitize=sanitize))\n    if operation.method.upper() == 'TRACE':\n        return ret\n    ret.update(_get_body_argument(body, operation=operation, arguments=arguments, has_kwargs=has_kwargs, sanitize=sanitize, content_type=content_type))\n    body_schema = operation.body_schema(content_type)\n    ret.update(_get_file_arguments(files, arguments, body_schema, has_kwargs))\n    return ret"
        }
      ]
    },
    {
      "name": "unwrap_decorators",
      "module": "parameter",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\parameter.py",
      "line_number": 157,
      "end_line_number": 161,
      "source_code": "def unwrap_decorators(function: t.Callable) -> t.Callable:\n    \"\"\"Unwrap decorators to return the original function.\"\"\"\n    while hasattr(function, \"__wrapped__\"):\n        function = function.__wrapped__  # type: ignore\n    return function",
      "docstring": "Unwrap decorators to return the original function.",
      "decorators": [],
      "arguments": [
        "function"
      ],
      "imports": [
        "abc",
        "asyncio",
        "builtins",
        "functools",
        "keyword",
        "logging",
        "re",
        "typing",
        "copy.copy",
        "copy.deepcopy",
        "inflection",
        "connexion.context.context",
        "connexion.context.operation",
        "connexion.frameworks.abstract.Framework",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.WSGIRequest",
        "connexion.operations.AbstractOperation",
        "connexion.operations.Swagger2Operation",
        "connexion.utils.deep_merge",
        "connexion.utils.inspect_function_arguments",
        "connexion.utils.is_null",
        "connexion.utils.is_nullable",
        "connexion.utils.make_type"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "snake_and_shadow",
      "module": "parameter",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\parameter.py",
      "line_number": 164,
      "end_line_number": 173,
      "source_code": "def snake_and_shadow(name: str) -> str:\n    \"\"\"\n    Converts the given name into Pythonic form. Firstly it converts CamelCase names to snake_case. Secondly it looks to\n    see if the name matches a known built-in and if it does it appends an underscore to the name.\n    :param name: The parameter name\n    \"\"\"\n    snake = inflection.underscore(name)\n    if snake in builtins.__dict__ or keyword.iskeyword(snake):\n        return f\"{snake}_\"\n    return snake",
      "docstring": "Converts the given name into Pythonic form. Firstly it converts CamelCase names to snake_case. Secondly it looks to\nsee if the name matches a known built-in and if it does it appends an underscore to the name.\n:param name: The parameter name",
      "decorators": [],
      "arguments": [
        "name"
      ],
      "imports": [
        "abc",
        "asyncio",
        "builtins",
        "functools",
        "keyword",
        "logging",
        "re",
        "typing",
        "copy.copy",
        "copy.deepcopy",
        "inflection",
        "connexion.context.context",
        "connexion.context.operation",
        "connexion.frameworks.abstract.Framework",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.WSGIRequest",
        "connexion.operations.AbstractOperation",
        "connexion.operations.Swagger2Operation",
        "connexion.utils.deep_merge",
        "connexion.utils.inspect_function_arguments",
        "connexion.utils.is_null",
        "connexion.utils.is_nullable",
        "connexion.utils.make_type"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "sanitized",
      "module": "parameter",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\parameter.py",
      "line_number": 176,
      "end_line_number": 179,
      "source_code": "def sanitized(name: str) -> str:\n    return name and re.sub(\n        \"^[^a-zA-Z_]+\", \"\", re.sub(\"[^0-9a-zA-Z_]\", \"\", re.sub(r\"\\[(?!])\", \"_\", name))\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "name"
      ],
      "imports": [
        "abc",
        "asyncio",
        "builtins",
        "functools",
        "keyword",
        "logging",
        "re",
        "typing",
        "copy.copy",
        "copy.deepcopy",
        "inflection",
        "connexion.context.context",
        "connexion.context.operation",
        "connexion.frameworks.abstract.Framework",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.WSGIRequest",
        "connexion.operations.AbstractOperation",
        "connexion.operations.Swagger2Operation",
        "connexion.utils.deep_merge",
        "connexion.utils.inspect_function_arguments",
        "connexion.utils.is_null",
        "connexion.utils.is_nullable",
        "connexion.utils.make_type"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "pythonic",
      "module": "parameter",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\parameter.py",
      "line_number": 182,
      "end_line_number": 184,
      "source_code": "def pythonic(name: str) -> str:\n    name = name and snake_and_shadow(name)\n    return sanitized(name)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "name"
      ],
      "imports": [
        "abc",
        "asyncio",
        "builtins",
        "functools",
        "keyword",
        "logging",
        "re",
        "typing",
        "copy.copy",
        "copy.deepcopy",
        "inflection",
        "connexion.context.context",
        "connexion.context.operation",
        "connexion.frameworks.abstract.Framework",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.WSGIRequest",
        "connexion.operations.AbstractOperation",
        "connexion.operations.Swagger2Operation",
        "connexion.utils.deep_merge",
        "connexion.utils.inspect_function_arguments",
        "connexion.utils.is_null",
        "connexion.utils.is_nullable",
        "connexion.utils.make_type"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "sanitized",
          "body": "def sanitized(name: str) -> str:\n    return name and re.sub('^[^a-zA-Z_]+', '', re.sub('[^0-9a-zA-Z_]', '', re.sub('\\\\[(?!])', '_', name)))"
        },
        {
          "name": "snake_and_shadow",
          "body": "def snake_and_shadow(name: str) -> str:\n    \"\"\"\n    Converts the given name into Pythonic form. Firstly it converts CamelCase names to snake_case. Secondly it looks to\n    see if the name matches a known built-in and if it does it appends an underscore to the name.\n    :param name: The parameter name\n    \"\"\"\n    snake = inflection.underscore(name)\n    if snake in builtins.__dict__ or keyword.iskeyword(snake):\n        return f'{snake}_'\n    return snake"
        }
      ]
    },
    {
      "name": "get_arguments",
      "module": "parameter",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\parameter.py",
      "line_number": 187,
      "end_line_number": 230,
      "source_code": "def get_arguments(\n    operation: AbstractOperation,\n    *,\n    path_params: dict,\n    query_params: dict,\n    body: t.Any,\n    files: dict,\n    arguments: t.List[str],\n    has_kwargs: bool,\n    sanitize: t.Callable,\n    content_type: str,\n) -> t.Dict[str, t.Any]:\n    \"\"\"\n    get arguments for handler function\n    \"\"\"\n    ret = {}\n    ret.update(_get_path_arguments(path_params, operation=operation, sanitize=sanitize))\n    ret.update(\n        _get_query_arguments(\n            query_params,\n            operation=operation,\n            arguments=arguments,\n            has_kwargs=has_kwargs,\n            sanitize=sanitize,\n        )\n    )\n\n    if operation.method.upper() == \"TRACE\":\n        # TRACE requests MUST NOT include a body (RFC7231 section 4.3.8)\n        return ret\n\n    ret.update(\n        _get_body_argument(\n            body,\n            operation=operation,\n            arguments=arguments,\n            has_kwargs=has_kwargs,\n            sanitize=sanitize,\n            content_type=content_type,\n        )\n    )\n    body_schema = operation.body_schema(content_type)\n    ret.update(_get_file_arguments(files, arguments, body_schema, has_kwargs))\n    return ret",
      "docstring": "get arguments for handler function",
      "decorators": [],
      "arguments": [
        "operation"
      ],
      "imports": [
        "abc",
        "asyncio",
        "builtins",
        "functools",
        "keyword",
        "logging",
        "re",
        "typing",
        "copy.copy",
        "copy.deepcopy",
        "inflection",
        "connexion.context.context",
        "connexion.context.operation",
        "connexion.frameworks.abstract.Framework",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.WSGIRequest",
        "connexion.operations.AbstractOperation",
        "connexion.operations.Swagger2Operation",
        "connexion.utils.deep_merge",
        "connexion.utils.inspect_function_arguments",
        "connexion.utils.is_null",
        "connexion.utils.is_nullable",
        "connexion.utils.make_type"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "operation.body_schema",
          "body": "@abc.abstractmethod\ndef body_schema(self, content_type: t.Optional[str]=None) -> dict:\n    \"\"\"\n        The body schema definition for this operation.\n        \"\"\""
        },
        {
          "name": "_get_path_arguments",
          "body": "def _get_path_arguments(path_params: dict, *, operation: AbstractOperation, sanitize: t.Callable) -> dict:\n    \"\"\"\n    Extract handler function arguments from path parameters\n    \"\"\"\n    kwargs = {}\n    path_definitions = {parameter['name']: parameter for parameter in operation.parameters if parameter['in'] == 'path'}\n    for name, value in path_params.items():\n        sanitized_key = sanitize(name)\n        if name in path_definitions:\n            kwargs[sanitized_key] = _get_val_from_param(value, path_definitions[name])\n        else:\n            kwargs[sanitized_key] = value\n    return kwargs"
        },
        {
          "name": "_get_query_arguments",
          "body": "def _get_query_arguments(query_params: dict, *, operation: AbstractOperation, arguments: t.List[str], has_kwargs: bool, sanitize: t.Callable) -> dict:\n    \"\"\"\n    extract handler function arguments from the query parameters\n    \"\"\"\n    query_definitions = {parameter['name']: parameter for parameter in operation.parameters if parameter['in'] == 'query'}\n    default_query_params = _get_query_defaults(query_definitions)\n    query_arguments = deepcopy(default_query_params)\n    query_arguments = deep_merge(query_arguments, query_params)\n    return _query_args_helper(query_definitions, query_arguments, arguments, has_kwargs, sanitize)"
        },
        {
          "name": "_get_body_argument",
          "body": "def _get_body_argument(body: t.Any, *, operation: AbstractOperation, arguments: t.List[str], has_kwargs: bool, sanitize: t.Callable, content_type: str) -> dict:\n    if len(arguments) <= 0 and (not has_kwargs):\n        return {}\n    if not operation.is_request_body_defined:\n        return {}\n    body_name = sanitize(operation.body_name(content_type))\n    if content_type in FORM_CONTENT_TYPES:\n        result = _get_body_argument_form(body, operation=operation, content_type=content_type)\n        if content_type in FORM_CONTENT_TYPES and isinstance(operation, Swagger2Operation):\n            if has_kwargs:\n                return result\n            else:\n                return {sanitize(name): value for name, value in result.items() if sanitize(name) in arguments}\n    else:\n        result = _get_body_argument_json(body, operation=operation, content_type=content_type)\n    if body_name in arguments or has_kwargs:\n        return {body_name: result}\n    return {}"
        },
        {
          "name": "_get_file_arguments",
          "body": "def _get_file_arguments(files, arguments, body_schema: dict, has_kwargs=False):\n    results = {}\n    for k, v in files.items():\n        if not (k in arguments or has_kwargs):\n            continue\n        if body_schema.get('properties', {}).get(k, {}).get('type') != 'array':\n            v = v[0]\n        results[k] = v\n    return results"
        }
      ]
    },
    {
      "name": "_get_path_arguments",
      "module": "parameter",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\parameter.py",
      "line_number": 233,
      "end_line_number": 253,
      "source_code": "def _get_path_arguments(\n    path_params: dict, *, operation: AbstractOperation, sanitize: t.Callable\n) -> dict:\n    \"\"\"\n    Extract handler function arguments from path parameters\n    \"\"\"\n    kwargs = {}\n\n    path_definitions = {\n        parameter[\"name\"]: parameter\n        for parameter in operation.parameters\n        if parameter[\"in\"] == \"path\"\n    }\n\n    for name, value in path_params.items():\n        sanitized_key = sanitize(name)\n        if name in path_definitions:\n            kwargs[sanitized_key] = _get_val_from_param(value, path_definitions[name])\n        else:  # Assume path params mechanism used for injection\n            kwargs[sanitized_key] = value\n    return kwargs",
      "docstring": "Extract handler function arguments from path parameters",
      "decorators": [],
      "arguments": [
        "path_params"
      ],
      "imports": [
        "abc",
        "asyncio",
        "builtins",
        "functools",
        "keyword",
        "logging",
        "re",
        "typing",
        "copy.copy",
        "copy.deepcopy",
        "inflection",
        "connexion.context.context",
        "connexion.context.operation",
        "connexion.frameworks.abstract.Framework",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.WSGIRequest",
        "connexion.operations.AbstractOperation",
        "connexion.operations.Swagger2Operation",
        "connexion.utils.deep_merge",
        "connexion.utils.inspect_function_arguments",
        "connexion.utils.is_null",
        "connexion.utils.is_nullable",
        "connexion.utils.make_type"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "_get_val_from_param",
          "body": "def _get_val_from_param(value: t.Any, param_definitions: t.Dict[str, dict]) -> t.Any:\n    \"\"\"Cast a value according to its definition in the specification.\"\"\"\n    param_schema = param_definitions.get('schema', param_definitions)\n    if is_nullable(param_schema) and is_null(value):\n        return None\n    if param_schema['type'] == 'array':\n        type_ = param_schema['items']['type']\n        format_ = param_schema['items'].get('format')\n        return [make_type(part, type_, format_) for part in value]\n    else:\n        type_ = param_schema['type']\n        format_ = param_schema.get('format')\n        return make_type(value, type_, format_)"
        }
      ]
    },
    {
      "name": "_get_val_from_param",
      "module": "parameter",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\parameter.py",
      "line_number": 256,
      "end_line_number": 270,
      "source_code": "def _get_val_from_param(value: t.Any, param_definitions: t.Dict[str, dict]) -> t.Any:\n    \"\"\"Cast a value according to its definition in the specification.\"\"\"\n    param_schema = param_definitions.get(\"schema\", param_definitions)\n\n    if is_nullable(param_schema) and is_null(value):\n        return None\n\n    if param_schema[\"type\"] == \"array\":\n        type_ = param_schema[\"items\"][\"type\"]\n        format_ = param_schema[\"items\"].get(\"format\")\n        return [make_type(part, type_, format_) for part in value]\n    else:\n        type_ = param_schema[\"type\"]\n        format_ = param_schema.get(\"format\")\n        return make_type(value, type_, format_)",
      "docstring": "Cast a value according to its definition in the specification.",
      "decorators": [],
      "arguments": [
        "value",
        "param_definitions"
      ],
      "imports": [
        "abc",
        "asyncio",
        "builtins",
        "functools",
        "keyword",
        "logging",
        "re",
        "typing",
        "copy.copy",
        "copy.deepcopy",
        "inflection",
        "connexion.context.context",
        "connexion.context.operation",
        "connexion.frameworks.abstract.Framework",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.WSGIRequest",
        "connexion.operations.AbstractOperation",
        "connexion.operations.Swagger2Operation",
        "connexion.utils.deep_merge",
        "connexion.utils.inspect_function_arguments",
        "connexion.utils.is_null",
        "connexion.utils.is_nullable",
        "connexion.utils.make_type"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "param_definitions.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "is_nullable",
          "body": "def is_nullable(param_def):\n    return param_def.get('schema', param_def).get('nullable', False) or param_def.get('x-nullable', False)"
        },
        {
          "name": "is_null",
          "body": "def is_null(value):\n    if hasattr(value, 'strip') and value.strip() in ['null', 'None']:\n        return True\n    if value is None:\n        return True\n    return False"
        },
        {
          "name": "param_schema.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "make_type",
          "body": "def make_type(value: t.Any, type_: str, format_: t.Optional[str]) -> t.Any:\n    \"\"\"Cast a value to the type defined in the specification.\"\"\"\n    if type_ == 'string' and format_ == 'binary':\n        type_ = 'file'\n    type_func = TYPE_MAP[type_]\n    return type_func(value)"
        },
        {
          "name": "make_type",
          "body": "def make_type(value: t.Any, type_: str, format_: t.Optional[str]) -> t.Any:\n    \"\"\"Cast a value to the type defined in the specification.\"\"\"\n    if type_ == 'string' and format_ == 'binary':\n        type_ = 'file'\n    type_func = TYPE_MAP[type_]\n    return type_func(value)"
        }
      ]
    },
    {
      "name": "_get_query_arguments",
      "module": "parameter",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\parameter.py",
      "line_number": 273,
      "end_line_number": 296,
      "source_code": "def _get_query_arguments(\n    query_params: dict,\n    *,\n    operation: AbstractOperation,\n    arguments: t.List[str],\n    has_kwargs: bool,\n    sanitize: t.Callable,\n) -> dict:\n    \"\"\"\n    extract handler function arguments from the query parameters\n    \"\"\"\n    query_definitions = {\n        parameter[\"name\"]: parameter\n        for parameter in operation.parameters\n        if parameter[\"in\"] == \"query\"\n    }\n\n    default_query_params = _get_query_defaults(query_definitions)\n\n    query_arguments = deepcopy(default_query_params)\n    query_arguments = deep_merge(query_arguments, query_params)\n    return _query_args_helper(\n        query_definitions, query_arguments, arguments, has_kwargs, sanitize\n    )",
      "docstring": "extract handler function arguments from the query parameters",
      "decorators": [],
      "arguments": [
        "query_params"
      ],
      "imports": [
        "abc",
        "asyncio",
        "builtins",
        "functools",
        "keyword",
        "logging",
        "re",
        "typing",
        "copy.copy",
        "copy.deepcopy",
        "inflection",
        "connexion.context.context",
        "connexion.context.operation",
        "connexion.frameworks.abstract.Framework",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.WSGIRequest",
        "connexion.operations.AbstractOperation",
        "connexion.operations.Swagger2Operation",
        "connexion.utils.deep_merge",
        "connexion.utils.inspect_function_arguments",
        "connexion.utils.is_null",
        "connexion.utils.is_nullable",
        "connexion.utils.make_type"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "_get_query_defaults",
          "body": "def _get_query_defaults(query_definitions: t.Dict[str, dict]) -> t.Dict[str, t.Any]:\n    \"\"\"Get the default values for the query parameter from the parameter definition.\"\"\"\n    defaults = {}\n    for k, v in query_definitions.items():\n        try:\n            if 'default' in v:\n                defaults[k] = v['default']\n            elif v['schema']['type'] == 'object':\n                defaults[k] = _get_default_obj(v['schema'])\n            else:\n                defaults[k] = v['schema']['default']\n        except KeyError:\n            pass\n    return defaults"
        },
        {
          "name": "deep_merge",
          "body": "def deep_merge(a, b):\n    \"\"\"merges b into a\n    in case of conflict the value from b is used\n    \"\"\"\n    for key in b:\n        if key in a:\n            if isinstance(a[key], dict) and isinstance(b[key], dict):\n                deep_merge(a[key], b[key])\n            elif a[key] == b[key]:\n                pass\n            else:\n                a[key] = b[key]\n        else:\n            a[key] = b[key]\n    return a"
        },
        {
          "name": "_query_args_helper",
          "body": "def _query_args_helper(query_definitions: dict, query_arguments: dict, function_arguments: t.List[str], has_kwargs: bool, sanitize: t.Callable) -> dict:\n    result = {}\n    for key, value in query_arguments.items():\n        sanitized_key = sanitize(key)\n        if not has_kwargs and sanitized_key not in function_arguments:\n            logger.debug(\"Query Parameter '%s' (sanitized: '%s') not in function arguments\", key, sanitized_key)\n        else:\n            logger.debug(\"Query Parameter '%s' (sanitized: '%s') in function arguments\", key, sanitized_key)\n            try:\n                query_defn = query_definitions[key]\n            except KeyError:\n                logger.error(\"Function argument '%s' (non-sanitized: %s) not defined in specification\", sanitized_key, key)\n            else:\n                logger.debug('%s is a %s', key, query_defn)\n                result.update({sanitized_key: _get_val_from_param(value, query_defn)})\n    return result"
        }
      ]
    },
    {
      "name": "_get_query_defaults",
      "module": "parameter",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\parameter.py",
      "line_number": 299,
      "end_line_number": 312,
      "source_code": "def _get_query_defaults(query_definitions: t.Dict[str, dict]) -> t.Dict[str, t.Any]:\n    \"\"\"Get the default values for the query parameter from the parameter definition.\"\"\"\n    defaults = {}\n    for k, v in query_definitions.items():\n        try:\n            if \"default\" in v:\n                defaults[k] = v[\"default\"]\n            elif v[\"schema\"][\"type\"] == \"object\":\n                defaults[k] = _get_default_obj(v[\"schema\"])\n            else:\n                defaults[k] = v[\"schema\"][\"default\"]\n        except KeyError:\n            pass\n    return defaults",
      "docstring": "Get the default values for the query parameter from the parameter definition.",
      "decorators": [],
      "arguments": [
        "query_definitions"
      ],
      "imports": [
        "abc",
        "asyncio",
        "builtins",
        "functools",
        "keyword",
        "logging",
        "re",
        "typing",
        "copy.copy",
        "copy.deepcopy",
        "inflection",
        "connexion.context.context",
        "connexion.context.operation",
        "connexion.frameworks.abstract.Framework",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.WSGIRequest",
        "connexion.operations.AbstractOperation",
        "connexion.operations.Swagger2Operation",
        "connexion.utils.deep_merge",
        "connexion.utils.inspect_function_arguments",
        "connexion.utils.is_null",
        "connexion.utils.is_nullable",
        "connexion.utils.make_type"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "_get_default_obj",
          "body": "def _get_default_obj(schema: dict) -> dict:\n    try:\n        return deepcopy(schema['default'])\n    except KeyError:\n        properties = schema.get('properties', {})\n        return _build_default_obj_recursive(properties, {})"
        }
      ]
    },
    {
      "name": "_get_default_obj",
      "module": "parameter",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\parameter.py",
      "line_number": 315,
      "end_line_number": 320,
      "source_code": "def _get_default_obj(schema: dict) -> dict:\n    try:\n        return deepcopy(schema[\"default\"])\n    except KeyError:\n        properties = schema.get(\"properties\", {})\n        return _build_default_obj_recursive(properties, {})",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "schema"
      ],
      "imports": [
        "abc",
        "asyncio",
        "builtins",
        "functools",
        "keyword",
        "logging",
        "re",
        "typing",
        "copy.copy",
        "copy.deepcopy",
        "inflection",
        "connexion.context.context",
        "connexion.context.operation",
        "connexion.frameworks.abstract.Framework",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.WSGIRequest",
        "connexion.operations.AbstractOperation",
        "connexion.operations.Swagger2Operation",
        "connexion.utils.deep_merge",
        "connexion.utils.inspect_function_arguments",
        "connexion.utils.is_null",
        "connexion.utils.is_nullable",
        "connexion.utils.make_type"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "schema.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "_build_default_obj_recursive",
          "body": "def _build_default_obj_recursive(properties: dict, default_object: dict) -> dict:\n    \"\"\"takes disparate and nested default keys, and builds up a default object\"\"\"\n    for name, property_ in properties.items():\n        if 'default' in property_ and name not in default_object:\n            default_object[name] = copy(property_['default'])\n        elif property_.get('type') == 'object' and 'properties' in property_:\n            default_object.setdefault(name, {})\n            default_object[name] = _build_default_obj_recursive(property_['properties'], default_object[name])\n    return default_object"
        }
      ]
    },
    {
      "name": "_build_default_obj_recursive",
      "module": "parameter",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\parameter.py",
      "line_number": 323,
      "end_line_number": 333,
      "source_code": "def _build_default_obj_recursive(properties: dict, default_object: dict) -> dict:\n    \"\"\"takes disparate and nested default keys, and builds up a default object\"\"\"\n    for name, property_ in properties.items():\n        if \"default\" in property_ and name not in default_object:\n            default_object[name] = copy(property_[\"default\"])\n        elif property_.get(\"type\") == \"object\" and \"properties\" in property_:\n            default_object.setdefault(name, {})\n            default_object[name] = _build_default_obj_recursive(\n                property_[\"properties\"], default_object[name]\n            )\n    return default_object",
      "docstring": "takes disparate and nested default keys, and builds up a default object",
      "decorators": [],
      "arguments": [
        "properties",
        "default_object"
      ],
      "imports": [
        "abc",
        "asyncio",
        "builtins",
        "functools",
        "keyword",
        "logging",
        "re",
        "typing",
        "copy.copy",
        "copy.deepcopy",
        "inflection",
        "connexion.context.context",
        "connexion.context.operation",
        "connexion.frameworks.abstract.Framework",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.WSGIRequest",
        "connexion.operations.AbstractOperation",
        "connexion.operations.Swagger2Operation",
        "connexion.utils.deep_merge",
        "connexion.utils.inspect_function_arguments",
        "connexion.utils.is_null",
        "connexion.utils.is_nullable",
        "connexion.utils.make_type"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "_build_default_obj_recursive",
          "body": "def _build_default_obj_recursive(properties: dict, default_object: dict) -> dict:\n    \"\"\"takes disparate and nested default keys, and builds up a default object\"\"\"\n    for name, property_ in properties.items():\n        if 'default' in property_ and name not in default_object:\n            default_object[name] = copy(property_['default'])\n        elif property_.get('type') == 'object' and 'properties' in property_:\n            default_object.setdefault(name, {})\n            default_object[name] = _build_default_obj_recursive(property_['properties'], default_object[name])\n    return default_object"
        },
        {
          "name": "property_.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "_query_args_helper",
      "module": "parameter",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\parameter.py",
      "line_number": 336,
      "end_line_number": 369,
      "source_code": "def _query_args_helper(\n    query_definitions: dict,\n    query_arguments: dict,\n    function_arguments: t.List[str],\n    has_kwargs: bool,\n    sanitize: t.Callable,\n) -> dict:\n    result = {}\n    for key, value in query_arguments.items():\n        sanitized_key = sanitize(key)\n        if not has_kwargs and sanitized_key not in function_arguments:\n            logger.debug(\n                \"Query Parameter '%s' (sanitized: '%s') not in function arguments\",\n                key,\n                sanitized_key,\n            )\n        else:\n            logger.debug(\n                \"Query Parameter '%s' (sanitized: '%s') in function arguments\",\n                key,\n                sanitized_key,\n            )\n            try:\n                query_defn = query_definitions[key]\n            except KeyError:  # pragma: no cover\n                logger.error(\n                    \"Function argument '%s' (non-sanitized: %s) not defined in specification\",\n                    sanitized_key,\n                    key,\n                )\n            else:\n                logger.debug(\"%s is a %s\", key, query_defn)\n                result.update({sanitized_key: _get_val_from_param(value, query_defn)})\n    return result",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "query_definitions",
        "query_arguments",
        "function_arguments",
        "has_kwargs",
        "sanitize"
      ],
      "imports": [
        "abc",
        "asyncio",
        "builtins",
        "functools",
        "keyword",
        "logging",
        "re",
        "typing",
        "copy.copy",
        "copy.deepcopy",
        "inflection",
        "connexion.context.context",
        "connexion.context.operation",
        "connexion.frameworks.abstract.Framework",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.WSGIRequest",
        "connexion.operations.AbstractOperation",
        "connexion.operations.Swagger2Operation",
        "connexion.utils.deep_merge",
        "connexion.utils.inspect_function_arguments",
        "connexion.utils.is_null",
        "connexion.utils.is_nullable",
        "connexion.utils.make_type"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "_get_val_from_param",
          "body": "def _get_val_from_param(value: t.Any, param_definitions: t.Dict[str, dict]) -> t.Any:\n    \"\"\"Cast a value according to its definition in the specification.\"\"\"\n    param_schema = param_definitions.get('schema', param_definitions)\n    if is_nullable(param_schema) and is_null(value):\n        return None\n    if param_schema['type'] == 'array':\n        type_ = param_schema['items']['type']\n        format_ = param_schema['items'].get('format')\n        return [make_type(part, type_, format_) for part in value]\n    else:\n        type_ = param_schema['type']\n        format_ = param_schema.get('format')\n        return make_type(value, type_, format_)"
        }
      ]
    },
    {
      "name": "_get_body_argument",
      "module": "parameter",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\parameter.py",
      "line_number": 372,
      "end_line_number": 414,
      "source_code": "def _get_body_argument(\n    body: t.Any,\n    *,\n    operation: AbstractOperation,\n    arguments: t.List[str],\n    has_kwargs: bool,\n    sanitize: t.Callable,\n    content_type: str,\n) -> dict:\n    if len(arguments) <= 0 and not has_kwargs:\n        return {}\n\n    if not operation.is_request_body_defined:\n        return {}\n\n    body_name = sanitize(operation.body_name(content_type))\n\n    if content_type in FORM_CONTENT_TYPES:\n        result = _get_body_argument_form(\n            body, operation=operation, content_type=content_type\n        )\n\n        # Unpack form values for Swagger for compatibility with Connexion 2 behavior\n        if content_type in FORM_CONTENT_TYPES and isinstance(\n            operation, Swagger2Operation\n        ):\n            if has_kwargs:\n                return result\n            else:\n                return {\n                    sanitize(name): value\n                    for name, value in result.items()\n                    if sanitize(name) in arguments\n                }\n    else:\n        result = _get_body_argument_json(\n            body, operation=operation, content_type=content_type\n        )\n\n    if body_name in arguments or has_kwargs:\n        return {body_name: result}\n\n    return {}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "body"
      ],
      "imports": [
        "abc",
        "asyncio",
        "builtins",
        "functools",
        "keyword",
        "logging",
        "re",
        "typing",
        "copy.copy",
        "copy.deepcopy",
        "inflection",
        "connexion.context.context",
        "connexion.context.operation",
        "connexion.frameworks.abstract.Framework",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.WSGIRequest",
        "connexion.operations.AbstractOperation",
        "connexion.operations.Swagger2Operation",
        "connexion.utils.deep_merge",
        "connexion.utils.inspect_function_arguments",
        "connexion.utils.is_null",
        "connexion.utils.is_nullable",
        "connexion.utils.make_type"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "operation.body_name",
          "body": "@abc.abstractmethod\ndef body_name(self, content_type: str) -> str:\n    \"\"\"\n        Name of the body in the spec.\n        \"\"\""
        },
        {
          "name": "_get_body_argument_form",
          "body": "def _get_body_argument_form(body: dict, *, operation: AbstractOperation, content_type: str) -> dict:\n    default_body = operation.body_schema(content_type).get('default', {})\n    body_props = {k: {'schema': v} for k, v in operation.body_schema(content_type).get('properties', {}).items()}\n    additional_props = operation.body_schema().get('additionalProperties', True)\n    body_arg = deepcopy(default_body)\n    body_arg.update(body or {})\n    if body_props or additional_props:\n        return _get_typed_body_values(body_arg, body_props, additional_props)\n    return {}"
        },
        {
          "name": "_get_body_argument_json",
          "body": "def _get_body_argument_json(body: t.Any, *, operation: AbstractOperation, content_type: str) -> t.Any:\n    if is_nullable(operation.body_schema(content_type)) and is_null(body):\n        return None\n    if body is None:\n        default_body = operation.body_schema(content_type).get('default', {})\n        return deepcopy(default_body)\n    return body"
        }
      ]
    },
    {
      "name": "_get_body_argument_json",
      "module": "parameter",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\parameter.py",
      "line_number": 417,
      "end_line_number": 429,
      "source_code": "def _get_body_argument_json(\n    body: t.Any, *, operation: AbstractOperation, content_type: str\n) -> t.Any:\n    # if the body came in null, and the schema says it can be null, we decide\n    # to include no value for the body argument, rather than the default body\n    if is_nullable(operation.body_schema(content_type)) and is_null(body):\n        return None\n\n    if body is None:\n        default_body = operation.body_schema(content_type).get(\"default\", {})\n        return deepcopy(default_body)\n\n    return body",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "body"
      ],
      "imports": [
        "abc",
        "asyncio",
        "builtins",
        "functools",
        "keyword",
        "logging",
        "re",
        "typing",
        "copy.copy",
        "copy.deepcopy",
        "inflection",
        "connexion.context.context",
        "connexion.context.operation",
        "connexion.frameworks.abstract.Framework",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.WSGIRequest",
        "connexion.operations.AbstractOperation",
        "connexion.operations.Swagger2Operation",
        "connexion.utils.deep_merge",
        "connexion.utils.inspect_function_arguments",
        "connexion.utils.is_null",
        "connexion.utils.is_nullable",
        "connexion.utils.make_type"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "is_nullable",
          "body": "def is_nullable(param_def):\n    return param_def.get('schema', param_def).get('nullable', False) or param_def.get('x-nullable', False)"
        },
        {
          "name": "is_null",
          "body": "def is_null(value):\n    if hasattr(value, 'strip') and value.strip() in ['null', 'None']:\n        return True\n    if value is None:\n        return True\n    return False"
        },
        {
          "name": "operation.body_schema",
          "body": "@abc.abstractmethod\ndef body_schema(self, content_type: t.Optional[str]=None) -> dict:\n    \"\"\"\n        The body schema definition for this operation.\n        \"\"\""
        },
        {
          "name": "operation.body_schema",
          "body": "@abc.abstractmethod\ndef body_schema(self, content_type: t.Optional[str]=None) -> dict:\n    \"\"\"\n        The body schema definition for this operation.\n        \"\"\""
        }
      ]
    },
    {
      "name": "_get_body_argument_form",
      "module": "parameter",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\parameter.py",
      "line_number": 432,
      "end_line_number": 452,
      "source_code": "def _get_body_argument_form(\n    body: dict, *, operation: AbstractOperation, content_type: str\n) -> dict:\n    # now determine the actual value for the body (whether it came in or is default)\n    default_body = operation.body_schema(content_type).get(\"default\", {})\n    body_props = {\n        k: {\"schema\": v}\n        for k, v in operation.body_schema(content_type).get(\"properties\", {}).items()\n    }\n\n    # by OpenAPI specification `additionalProperties` defaults to `true`\n    # see: https://github.com/OAI/OpenAPI-Specification/blame/3.0.2/versions/3.0.2.md#L2305\n    additional_props = operation.body_schema().get(\"additionalProperties\", True)\n\n    body_arg = deepcopy(default_body)\n    body_arg.update(body or {})\n\n    if body_props or additional_props:\n        return _get_typed_body_values(body_arg, body_props, additional_props)\n\n    return {}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "body"
      ],
      "imports": [
        "abc",
        "asyncio",
        "builtins",
        "functools",
        "keyword",
        "logging",
        "re",
        "typing",
        "copy.copy",
        "copy.deepcopy",
        "inflection",
        "connexion.context.context",
        "connexion.context.operation",
        "connexion.frameworks.abstract.Framework",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.WSGIRequest",
        "connexion.operations.AbstractOperation",
        "connexion.operations.Swagger2Operation",
        "connexion.utils.deep_merge",
        "connexion.utils.inspect_function_arguments",
        "connexion.utils.is_null",
        "connexion.utils.is_nullable",
        "connexion.utils.make_type"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "_get_typed_body_values",
          "body": "def _get_typed_body_values(body_arg, body_props, additional_props):\n    \"\"\"\n    Return a copy of the provided body_arg dictionary\n    whose values will have the appropriate types\n    as defined in the provided schemas.\n\n    :type body_arg: type dict\n    :type body_props: dict\n    :type additional_props: dict|bool\n    :rtype: dict\n    \"\"\"\n    additional_props_defn = {'schema': additional_props} if isinstance(additional_props, dict) else None\n    res = {}\n    for key, value in body_arg.items():\n        try:\n            prop_defn = body_props[key]\n            res[key] = _get_val_from_param(value, prop_defn)\n        except KeyError:\n            if not additional_props:\n                logger.error(f\"Body property '{key}' not defined in body schema\")\n                continue\n            if additional_props_defn is not None:\n                value = _get_val_from_param(value, additional_props_defn)\n            res[key] = value\n    return res"
        },
        {
          "name": "operation.body_schema",
          "body": "@abc.abstractmethod\ndef body_schema(self, content_type: t.Optional[str]=None) -> dict:\n    \"\"\"\n        The body schema definition for this operation.\n        \"\"\""
        },
        {
          "name": "operation.body_schema",
          "body": "@abc.abstractmethod\ndef body_schema(self, content_type: t.Optional[str]=None) -> dict:\n    \"\"\"\n        The body schema definition for this operation.\n        \"\"\""
        },
        {
          "name": "operation.body_schema",
          "body": "@abc.abstractmethod\ndef body_schema(self, content_type: t.Optional[str]=None) -> dict:\n    \"\"\"\n        The body schema definition for this operation.\n        \"\"\""
        }
      ]
    },
    {
      "name": "_get_typed_body_values",
      "module": "parameter",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\parameter.py",
      "line_number": 455,
      "end_line_number": 483,
      "source_code": "def _get_typed_body_values(body_arg, body_props, additional_props):\n    \"\"\"\n    Return a copy of the provided body_arg dictionary\n    whose values will have the appropriate types\n    as defined in the provided schemas.\n\n    :type body_arg: type dict\n    :type body_props: dict\n    :type additional_props: dict|bool\n    :rtype: dict\n    \"\"\"\n    additional_props_defn = (\n        {\"schema\": additional_props} if isinstance(additional_props, dict) else None\n    )\n    res = {}\n\n    for key, value in body_arg.items():\n        try:\n            prop_defn = body_props[key]\n            res[key] = _get_val_from_param(value, prop_defn)\n        except KeyError:  # pragma: no cover\n            if not additional_props:\n                logger.error(f\"Body property '{key}' not defined in body schema\")\n                continue\n            if additional_props_defn is not None:\n                value = _get_val_from_param(value, additional_props_defn)\n            res[key] = value\n\n    return res",
      "docstring": "Return a copy of the provided body_arg dictionary\nwhose values will have the appropriate types\nas defined in the provided schemas.\n\n:type body_arg: type dict\n:type body_props: dict\n:type additional_props: dict|bool\n:rtype: dict",
      "decorators": [],
      "arguments": [
        "body_arg",
        "body_props",
        "additional_props"
      ],
      "imports": [
        "abc",
        "asyncio",
        "builtins",
        "functools",
        "keyword",
        "logging",
        "re",
        "typing",
        "copy.copy",
        "copy.deepcopy",
        "inflection",
        "connexion.context.context",
        "connexion.context.operation",
        "connexion.frameworks.abstract.Framework",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.WSGIRequest",
        "connexion.operations.AbstractOperation",
        "connexion.operations.Swagger2Operation",
        "connexion.utils.deep_merge",
        "connexion.utils.inspect_function_arguments",
        "connexion.utils.is_null",
        "connexion.utils.is_nullable",
        "connexion.utils.make_type"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "_get_val_from_param",
          "body": "def _get_val_from_param(value: t.Any, param_definitions: t.Dict[str, dict]) -> t.Any:\n    \"\"\"Cast a value according to its definition in the specification.\"\"\"\n    param_schema = param_definitions.get('schema', param_definitions)\n    if is_nullable(param_schema) and is_null(value):\n        return None\n    if param_schema['type'] == 'array':\n        type_ = param_schema['items']['type']\n        format_ = param_schema['items'].get('format')\n        return [make_type(part, type_, format_) for part in value]\n    else:\n        type_ = param_schema['type']\n        format_ = param_schema.get('format')\n        return make_type(value, type_, format_)"
        },
        {
          "name": "_get_val_from_param",
          "body": "def _get_val_from_param(value: t.Any, param_definitions: t.Dict[str, dict]) -> t.Any:\n    \"\"\"Cast a value according to its definition in the specification.\"\"\"\n    param_schema = param_definitions.get('schema', param_definitions)\n    if is_nullable(param_schema) and is_null(value):\n        return None\n    if param_schema['type'] == 'array':\n        type_ = param_schema['items']['type']\n        format_ = param_schema['items'].get('format')\n        return [make_type(part, type_, format_) for part in value]\n    else:\n        type_ = param_schema['type']\n        format_ = param_schema.get('format')\n        return make_type(value, type_, format_)"
        }
      ]
    },
    {
      "name": "_get_file_arguments",
      "module": "parameter",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\parameter.py",
      "line_number": 486,
      "end_line_number": 495,
      "source_code": "def _get_file_arguments(files, arguments, body_schema: dict, has_kwargs=False):\n    results = {}\n    for k, v in files.items():\n        if not (k in arguments or has_kwargs):\n            continue\n        if body_schema.get(\"properties\", {}).get(k, {}).get(\"type\") != \"array\":\n            v = v[0]\n        results[k] = v\n\n    return results",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "files",
        "arguments",
        "body_schema",
        "has_kwargs"
      ],
      "imports": [
        "abc",
        "asyncio",
        "builtins",
        "functools",
        "keyword",
        "logging",
        "re",
        "typing",
        "copy.copy",
        "copy.deepcopy",
        "inflection",
        "connexion.context.context",
        "connexion.context.operation",
        "connexion.frameworks.abstract.Framework",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.WSGIRequest",
        "connexion.operations.AbstractOperation",
        "connexion.operations.Swagger2Operation",
        "connexion.utils.deep_merge",
        "connexion.utils.inspect_function_arguments",
        "connexion.utils.is_null",
        "connexion.utils.is_nullable",
        "connexion.utils.make_type"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "body_schema.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "__init__",
      "module": "parameter",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\parameter.py",
      "line_number": 35,
      "end_line_number": 42,
      "source_code": "def __init__(\n        self,\n        *,\n        framework: t.Type[Framework],\n        pythonic_params: bool = False,\n    ) -> None:\n        self.framework = framework\n        self.sanitize_fn = pythonic if pythonic_params else sanitized",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "asyncio",
        "builtins",
        "functools",
        "keyword",
        "logging",
        "re",
        "typing",
        "copy.copy",
        "copy.deepcopy",
        "inflection",
        "connexion.context.context",
        "connexion.context.operation",
        "connexion.frameworks.abstract.Framework",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.WSGIRequest",
        "connexion.operations.AbstractOperation",
        "connexion.operations.Swagger2Operation",
        "connexion.utils.deep_merge",
        "connexion.utils.inspect_function_arguments",
        "connexion.utils.is_null",
        "connexion.utils.is_nullable",
        "connexion.utils.make_type"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_maybe_get_body",
      "module": "parameter",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\parameter.py",
      "line_number": 44,
      "end_line_number": 60,
      "source_code": "def _maybe_get_body(\n        self,\n        request: t.Union[WSGIRequest, ConnexionRequest],\n        *,\n        arguments: t.List[str],\n        has_kwargs: bool,\n    ) -> t.Any:\n        body_name = self.sanitize_fn(operation.body_name(request.content_type))\n        # Pass form contents separately for Swagger2 for backward compatibility with\n        # Connexion 2 Checking for body_name is not enough\n        if (body_name in arguments or has_kwargs) or (\n            request.mimetype in FORM_CONTENT_TYPES\n            and isinstance(operation, Swagger2Operation)\n        ):\n            return request.get_body()\n        else:\n            return None",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "request"
      ],
      "imports": [
        "abc",
        "asyncio",
        "builtins",
        "functools",
        "keyword",
        "logging",
        "re",
        "typing",
        "copy.copy",
        "copy.deepcopy",
        "inflection",
        "connexion.context.context",
        "connexion.context.operation",
        "connexion.frameworks.abstract.Framework",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.WSGIRequest",
        "connexion.operations.AbstractOperation",
        "connexion.operations.Swagger2Operation",
        "connexion.utils.deep_merge",
        "connexion.utils.inspect_function_arguments",
        "connexion.utils.is_null",
        "connexion.utils.is_nullable",
        "connexion.utils.make_type"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "operation.body_name",
          "body": "@abc.abstractmethod\ndef body_name(self, content_type: str) -> str:\n    \"\"\"\n        Name of the body in the spec.\n        \"\"\""
        },
        {
          "name": "request.get_body",
          "body": "def get_body(self) -> t.Any:\n    \"\"\"Get body based on the content type. This returns json data for json content types,\n        form data for form content types, and bytes for all others. If the bytes data is empty,\n        :code:`None` is returned instead.\"\"\"\n    raise NotImplementedError"
        }
      ]
    },
    {
      "name": "__call__",
      "module": "parameter",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\parameter.py",
      "line_number": 63,
      "end_line_number": 64,
      "source_code": "def __call__(self, function: t.Callable) -> t.Callable:\n        raise NotImplementedError",
      "docstring": null,
      "decorators": [
        "abc.abstractmethod"
      ],
      "arguments": [
        "self",
        "function"
      ],
      "imports": [
        "abc",
        "asyncio",
        "builtins",
        "functools",
        "keyword",
        "logging",
        "re",
        "typing",
        "copy.copy",
        "copy.deepcopy",
        "inflection",
        "connexion.context.context",
        "connexion.context.operation",
        "connexion.frameworks.abstract.Framework",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.WSGIRequest",
        "connexion.operations.AbstractOperation",
        "connexion.operations.Swagger2Operation",
        "connexion.utils.deep_merge",
        "connexion.utils.inspect_function_arguments",
        "connexion.utils.is_null",
        "connexion.utils.is_nullable",
        "connexion.utils.make_type"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__call__",
      "module": "parameter",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\parameter.py",
      "line_number": 68,
      "end_line_number": 89,
      "source_code": "def __call__(self, function: t.Callable) -> t.Callable:\n        unwrapped_function = unwrap_decorators(function)\n        arguments, has_kwargs = inspect_function_arguments(unwrapped_function)\n\n        @functools.wraps(function)\n        def wrapper(request: WSGIRequest) -> t.Any:\n            request_body = self._maybe_get_body(\n                request, arguments=arguments, has_kwargs=has_kwargs\n            )\n\n            kwargs = prep_kwargs(\n                request,\n                request_body=request_body,\n                files=request.files(),\n                arguments=arguments,\n                has_kwargs=has_kwargs,\n                sanitize=self.sanitize_fn,\n            )\n\n            return function(**kwargs)\n\n        return wrapper",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "function"
      ],
      "imports": [
        "abc",
        "asyncio",
        "builtins",
        "functools",
        "keyword",
        "logging",
        "re",
        "typing",
        "copy.copy",
        "copy.deepcopy",
        "inflection",
        "connexion.context.context",
        "connexion.context.operation",
        "connexion.frameworks.abstract.Framework",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.WSGIRequest",
        "connexion.operations.AbstractOperation",
        "connexion.operations.Swagger2Operation",
        "connexion.utils.deep_merge",
        "connexion.utils.inspect_function_arguments",
        "connexion.utils.is_null",
        "connexion.utils.is_nullable",
        "connexion.utils.make_type"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "unwrap_decorators",
          "body": "def unwrap_decorators(function: t.Callable) -> t.Callable:\n    \"\"\"Unwrap decorators to return the original function.\"\"\"\n    while hasattr(function, '__wrapped__'):\n        function = function.__wrapped__\n    return function"
        },
        {
          "name": "inspect_function_arguments",
          "body": "def inspect_function_arguments(function: t.Callable) -> t.Tuple[t.List[str], bool]:\n    \"\"\"\n    Returns the list of variables names of a function and if it\n    accepts keyword arguments.\n    \"\"\"\n    parameters = inspect.signature(function).parameters\n    bound_arguments = [name for name, p in parameters.items() if p.kind not in (p.VAR_POSITIONAL, p.VAR_KEYWORD)]\n    has_kwargs = any((p.kind == p.VAR_KEYWORD for p in parameters.values()))\n    return (list(bound_arguments), has_kwargs)"
        },
        {
          "name": "self._maybe_get_body",
          "body": "def _maybe_get_body(self, request: t.Union[WSGIRequest, ConnexionRequest], *, arguments: t.List[str], has_kwargs: bool) -> t.Any:\n    body_name = self.sanitize_fn(operation.body_name(request.content_type))\n    if (body_name in arguments or has_kwargs) or (request.mimetype in FORM_CONTENT_TYPES and isinstance(operation, Swagger2Operation)):\n        return request.get_body()\n    else:\n        return None"
        },
        {
          "name": "prep_kwargs",
          "body": "def prep_kwargs(request: t.Union[WSGIRequest, ConnexionRequest], *, request_body: t.Any, files: t.Dict[str, t.Any], arguments: t.List[str], has_kwargs: bool, sanitize: t.Callable) -> dict:\n    kwargs = get_arguments(operation, path_params=request.path_params, query_params=request.query_params, body=request_body, files=files, arguments=arguments, has_kwargs=has_kwargs, sanitize=sanitize, content_type=request.mimetype)\n    kwargs = {sanitize(k): v for k, v in kwargs.items()}\n    for key, value in context.items():\n        if has_kwargs or key in arguments:\n            kwargs[key] = value\n        else:\n            logger.debug(\"Context parameter '%s' not in function arguments\", key)\n    if CONTEXT_NAME in arguments:\n        kwargs[CONTEXT_NAME] = context\n    return kwargs"
        },
        {
          "name": "function",
          "body": "@property\ndef function(self):\n    return self.handle"
        },
        {
          "name": "request.files",
          "body": "def files(self) -> t.Dict[str, t.Any]:\n    \"\"\"Files included in the request.\"\"\"\n    raise NotImplementedError"
        }
      ]
    },
    {
      "name": "__call__",
      "module": "parameter",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\parameter.py",
      "line_number": 93,
      "end_line_number": 117,
      "source_code": "def __call__(self, function: t.Callable) -> t.Callable:\n        unwrapped_function = unwrap_decorators(function)\n        arguments, has_kwargs = inspect_function_arguments(unwrapped_function)\n\n        @functools.wraps(function)\n        async def wrapper(request: ConnexionRequest) -> t.Any:\n            request_body = self._maybe_get_body(\n                request, arguments=arguments, has_kwargs=has_kwargs\n            )\n\n            while asyncio.iscoroutine(request_body):\n                request_body = await request_body\n\n            kwargs = prep_kwargs(\n                request,\n                request_body=request_body,\n                files=await request.files(),\n                arguments=arguments,\n                has_kwargs=has_kwargs,\n                sanitize=self.sanitize_fn,\n            )\n\n            return await function(**kwargs)\n\n        return wrapper",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "function"
      ],
      "imports": [
        "abc",
        "asyncio",
        "builtins",
        "functools",
        "keyword",
        "logging",
        "re",
        "typing",
        "copy.copy",
        "copy.deepcopy",
        "inflection",
        "connexion.context.context",
        "connexion.context.operation",
        "connexion.frameworks.abstract.Framework",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.WSGIRequest",
        "connexion.operations.AbstractOperation",
        "connexion.operations.Swagger2Operation",
        "connexion.utils.deep_merge",
        "connexion.utils.inspect_function_arguments",
        "connexion.utils.is_null",
        "connexion.utils.is_nullable",
        "connexion.utils.make_type"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "unwrap_decorators",
          "body": "def unwrap_decorators(function: t.Callable) -> t.Callable:\n    \"\"\"Unwrap decorators to return the original function.\"\"\"\n    while hasattr(function, '__wrapped__'):\n        function = function.__wrapped__\n    return function"
        },
        {
          "name": "inspect_function_arguments",
          "body": "def inspect_function_arguments(function: t.Callable) -> t.Tuple[t.List[str], bool]:\n    \"\"\"\n    Returns the list of variables names of a function and if it\n    accepts keyword arguments.\n    \"\"\"\n    parameters = inspect.signature(function).parameters\n    bound_arguments = [name for name, p in parameters.items() if p.kind not in (p.VAR_POSITIONAL, p.VAR_KEYWORD)]\n    has_kwargs = any((p.kind == p.VAR_KEYWORD for p in parameters.values()))\n    return (list(bound_arguments), has_kwargs)"
        },
        {
          "name": "self._maybe_get_body",
          "body": "def _maybe_get_body(self, request: t.Union[WSGIRequest, ConnexionRequest], *, arguments: t.List[str], has_kwargs: bool) -> t.Any:\n    body_name = self.sanitize_fn(operation.body_name(request.content_type))\n    if (body_name in arguments or has_kwargs) or (request.mimetype in FORM_CONTENT_TYPES and isinstance(operation, Swagger2Operation)):\n        return request.get_body()\n    else:\n        return None"
        },
        {
          "name": "prep_kwargs",
          "body": "def prep_kwargs(request: t.Union[WSGIRequest, ConnexionRequest], *, request_body: t.Any, files: t.Dict[str, t.Any], arguments: t.List[str], has_kwargs: bool, sanitize: t.Callable) -> dict:\n    kwargs = get_arguments(operation, path_params=request.path_params, query_params=request.query_params, body=request_body, files=files, arguments=arguments, has_kwargs=has_kwargs, sanitize=sanitize, content_type=request.mimetype)\n    kwargs = {sanitize(k): v for k, v in kwargs.items()}\n    for key, value in context.items():\n        if has_kwargs or key in arguments:\n            kwargs[key] = value\n        else:\n            logger.debug(\"Context parameter '%s' not in function arguments\", key)\n    if CONTEXT_NAME in arguments:\n        kwargs[CONTEXT_NAME] = context\n    return kwargs"
        },
        {
          "name": "function",
          "body": "@property\ndef function(self):\n    return self.handle"
        },
        {
          "name": "request.files",
          "body": "def files(self) -> t.Dict[str, t.Any]:\n    \"\"\"Files included in the request.\"\"\"\n    raise NotImplementedError"
        }
      ]
    },
    {
      "name": "wrapper",
      "module": "parameter",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\parameter.py",
      "line_number": 73,
      "end_line_number": 87,
      "source_code": "def wrapper(request: WSGIRequest) -> t.Any:\n            request_body = self._maybe_get_body(\n                request, arguments=arguments, has_kwargs=has_kwargs\n            )\n\n            kwargs = prep_kwargs(\n                request,\n                request_body=request_body,\n                files=request.files(),\n                arguments=arguments,\n                has_kwargs=has_kwargs,\n                sanitize=self.sanitize_fn,\n            )\n\n            return function(**kwargs)",
      "docstring": null,
      "decorators": [
        "functools.wraps(function)"
      ],
      "arguments": [
        "request"
      ],
      "imports": [
        "abc",
        "asyncio",
        "builtins",
        "functools",
        "keyword",
        "logging",
        "re",
        "typing",
        "copy.copy",
        "copy.deepcopy",
        "inflection",
        "connexion.context.context",
        "connexion.context.operation",
        "connexion.frameworks.abstract.Framework",
        "connexion.http_facts.FORM_CONTENT_TYPES",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.WSGIRequest",
        "connexion.operations.AbstractOperation",
        "connexion.operations.Swagger2Operation",
        "connexion.utils.deep_merge",
        "connexion.utils.inspect_function_arguments",
        "connexion.utils.is_null",
        "connexion.utils.is_nullable",
        "connexion.utils.make_type"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._maybe_get_body",
          "body": "def _maybe_get_body(self, request: t.Union[WSGIRequest, ConnexionRequest], *, arguments: t.List[str], has_kwargs: bool) -> t.Any:\n    body_name = self.sanitize_fn(operation.body_name(request.content_type))\n    if (body_name in arguments or has_kwargs) or (request.mimetype in FORM_CONTENT_TYPES and isinstance(operation, Swagger2Operation)):\n        return request.get_body()\n    else:\n        return None"
        },
        {
          "name": "prep_kwargs",
          "body": "def prep_kwargs(request: t.Union[WSGIRequest, ConnexionRequest], *, request_body: t.Any, files: t.Dict[str, t.Any], arguments: t.List[str], has_kwargs: bool, sanitize: t.Callable) -> dict:\n    kwargs = get_arguments(operation, path_params=request.path_params, query_params=request.query_params, body=request_body, files=files, arguments=arguments, has_kwargs=has_kwargs, sanitize=sanitize, content_type=request.mimetype)\n    kwargs = {sanitize(k): v for k, v in kwargs.items()}\n    for key, value in context.items():\n        if has_kwargs or key in arguments:\n            kwargs[key] = value\n        else:\n            logger.debug(\"Context parameter '%s' not in function arguments\", key)\n    if CONTEXT_NAME in arguments:\n        kwargs[CONTEXT_NAME] = context\n    return kwargs"
        },
        {
          "name": "function",
          "body": "@property\ndef function(self):\n    return self.handle"
        },
        {
          "name": "request.files",
          "body": "def files(self) -> t.Dict[str, t.Any]:\n    \"\"\"Files included in the request.\"\"\"\n    raise NotImplementedError"
        }
      ]
    },
    {
      "name": "__init__",
      "module": "response",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\response.py",
      "line_number": 20,
      "end_line_number": 22,
      "source_code": "def __init__(self, *, framework: t.Type[Framework], jsonifier):\n        self.framework = framework\n        self.jsonifier = jsonifier",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "collections.abc",
        "functools",
        "logging",
        "types",
        "typing",
        "enum.Enum",
        "connexion.utils",
        "connexion.context.operation",
        "connexion.datastructures.NoContent",
        "connexion.exceptions.NonConformingResponseHeaders",
        "connexion.frameworks.abstract.Framework",
        "connexion.lifecycle.ConnexionResponse"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__call__",
      "module": "response",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\response.py",
      "line_number": 25,
      "end_line_number": 26,
      "source_code": "def __call__(self, function: t.Callable) -> t.Callable:\n        raise NotImplementedError",
      "docstring": null,
      "decorators": [
        "abc.abstractmethod"
      ],
      "arguments": [
        "self",
        "function"
      ],
      "imports": [
        "abc",
        "collections.abc",
        "functools",
        "logging",
        "types",
        "typing",
        "enum.Enum",
        "connexion.utils",
        "connexion.context.operation",
        "connexion.datastructures.NoContent",
        "connexion.exceptions.NonConformingResponseHeaders",
        "connexion.frameworks.abstract.Framework",
        "connexion.lifecycle.ConnexionResponse"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "build_framework_response",
      "module": "response",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\response.py",
      "line_number": 28,
      "end_line_number": 37,
      "source_code": "def build_framework_response(self, handler_response):\n        data, status_code, headers = self._unpack_handler_response(handler_response)\n        content_type = self._infer_content_type(data, headers)\n        if not self.framework.is_framework_response(data):\n            data = self._serialize_data(data, content_type=content_type)\n            status_code = status_code or self._infer_status_code(data)\n            headers = self._update_headers(headers, content_type=content_type)\n        return self.framework.build_response(\n            data, content_type=content_type, status_code=status_code, headers=headers\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "handler_response"
      ],
      "imports": [
        "abc",
        "collections.abc",
        "functools",
        "logging",
        "types",
        "typing",
        "enum.Enum",
        "connexion.utils",
        "connexion.context.operation",
        "connexion.datastructures.NoContent",
        "connexion.exceptions.NonConformingResponseHeaders",
        "connexion.frameworks.abstract.Framework",
        "connexion.lifecycle.ConnexionResponse"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._unpack_handler_response",
          "body": "@staticmethod\ndef _unpack_handler_response(handler_response: t.Union[str, bytes, dict, list, tuple]) -> t.Tuple[t.Union[str, bytes, dict, list, None], t.Optional[int], dict]:\n    \"\"\"Unpack the handler response into data, status_code and headers.\n\n        :param handler_response: The response returned from the handler function if it was not a\n            response class.\n\n        :return: A tuple of data, status_code and headers\n        \"\"\"\n    data, status_code, headers = (None, None, {})\n    if not isinstance(handler_response, tuple):\n        data = handler_response\n    elif len(handler_response) == 1:\n        data, = handler_response\n    elif len(handler_response) == 2:\n        data, status_code_or_headers = handler_response\n        if isinstance(status_code_or_headers, int):\n            status_code = int(status_code_or_headers)\n        elif isinstance(status_code_or_headers, Enum) and isinstance(status_code_or_headers.value, int):\n            status_code = status_code_or_headers.value\n        else:\n            headers = status_code_or_headers\n    elif len(handler_response) == 3:\n        data, status_code, headers = handler_response\n    else:\n        raise TypeError('The view function did not return a valid response tuple. The tuple must have the form (body), (body, status, headers), (body, status), or (body, headers).')\n    return (data, status_code, headers)"
        },
        {
          "name": "self._infer_content_type",
          "body": "@staticmethod\ndef _infer_content_type(data: t.Any, headers: dict) -> t.Optional[str]:\n    \"\"\"Infer the response content type from the returned data, headers and operation spec.\n\n        :param data: Response data\n        :param headers: Headers returned by the handler.\n\n        :return: Inferred content type\n\n        :raises: NonConformingResponseHeaders if content type cannot be deducted.\n        \"\"\"\n    content_type = utils.extract_content_type(headers)\n    produces = list(set(operation.produces))\n    if data is not None and (not produces):\n        produces = ['application/json']\n    if content_type:\n        if content_type not in produces:\n            raise NonConformingResponseHeaders(f'Returned content type ({content_type}) is not defined in operation spec ({operation.produces}).')\n    elif not produces:\n        pass\n    elif len(produces) == 1:\n        content_type = produces[0]\n    else:\n        if isinstance(data, str):\n            for produced_content_type in produces:\n                if 'text/plain' in produced_content_type:\n                    content_type = produced_content_type\n        elif isinstance(data, bytes) or isinstance(data, (types.GeneratorType, collections.abc.Iterator)):\n            for produced_content_type in produces:\n                if 'application/octet-stream' in produced_content_type:\n                    content_type = produced_content_type\n        if content_type is None:\n            raise NonConformingResponseHeaders('Multiple response content types are defined in the operation spec, but the handler response did not specify which one to return.')\n    return content_type"
        },
        {
          "name": "self.framework.build_response",
          "body": "@classmethod\n@abc.abstractmethod\ndef build_response(cls, data: t.Any, *, content_type: t.Optional[str]=None, headers: t.Optional[dict]=None, status_code: int=None):\n    raise NotImplementedError"
        },
        {
          "name": "self.framework.is_framework_response",
          "body": "@staticmethod\n@abc.abstractmethod\ndef is_framework_response(response: t.Any) -> bool:\n    \"\"\"Return True if provided response is a framework type\"\"\"\n    raise NotImplementedError"
        },
        {
          "name": "self._serialize_data",
          "body": "def _serialize_data(self, data: t.Any, *, content_type: str) -> t.Any:\n    \"\"\"Serialize the data based on the content type.\"\"\"\n    if data is None or data is NoContent:\n        return None\n    mime_type, _ = utils.split_content_type(content_type)\n    if utils.is_json_mimetype(mime_type):\n        return self.jsonifier.dumps(data)\n    return data"
        },
        {
          "name": "self._update_headers",
          "body": "@staticmethod\ndef _update_headers(headers: t.Dict[str, str], *, content_type: str) -> t.Dict[str, str]:\n    for key, value in headers.items():\n        if key.lower() == 'content-type':\n            return headers\n    if content_type:\n        headers['Content-Type'] = content_type\n    return headers"
        },
        {
          "name": "self._infer_status_code",
          "body": "@staticmethod\ndef _infer_status_code(data: t.Any) -> int:\n    \"\"\"Infer the status code from the returned data.\"\"\"\n    if data is None:\n        return 204\n    return 200"
        }
      ]
    },
    {
      "name": "_infer_content_type",
      "module": "response",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\response.py",
      "line_number": 40,
      "end_line_number": 87,
      "source_code": "def _infer_content_type(data: t.Any, headers: dict) -> t.Optional[str]:\n        \"\"\"Infer the response content type from the returned data, headers and operation spec.\n\n        :param data: Response data\n        :param headers: Headers returned by the handler.\n\n        :return: Inferred content type\n\n        :raises: NonConformingResponseHeaders if content type cannot be deducted.\n        \"\"\"\n        content_type = utils.extract_content_type(headers)\n\n        # TODO: don't default\n        produces = list(set(operation.produces))\n        if data is not None and not produces:\n            produces = [\"application/json\"]\n\n        if content_type:\n            if content_type not in produces:\n                raise NonConformingResponseHeaders(\n                    f\"Returned content type ({content_type}) is not defined in operation spec \"\n                    f\"({operation.produces}).\"\n                )\n        else:\n            if not produces:\n                # Produces can be empty/ for empty responses\n                pass\n            elif len(produces) == 1:\n                content_type = produces[0]\n            else:\n                if isinstance(data, str):\n                    for produced_content_type in produces:\n                        if \"text/plain\" in produced_content_type:\n                            content_type = produced_content_type\n                elif isinstance(data, bytes) or isinstance(\n                    data, (types.GeneratorType, collections.abc.Iterator)\n                ):\n                    for produced_content_type in produces:\n                        if \"application/octet-stream\" in produced_content_type:\n                            content_type = produced_content_type\n\n                if content_type is None:\n                    raise NonConformingResponseHeaders(\n                        \"Multiple response content types are defined in the operation spec, but \"\n                        \"the handler response did not specify which one to return.\"\n                    )\n\n        return content_type",
      "docstring": "Infer the response content type from the returned data, headers and operation spec.\n\n:param data: Response data\n:param headers: Headers returned by the handler.\n\n:return: Inferred content type\n\n:raises: NonConformingResponseHeaders if content type cannot be deducted.",
      "decorators": [
        "staticmethod"
      ],
      "arguments": [
        "data",
        "headers"
      ],
      "imports": [
        "abc",
        "collections.abc",
        "functools",
        "logging",
        "types",
        "typing",
        "enum.Enum",
        "connexion.utils",
        "connexion.context.operation",
        "connexion.datastructures.NoContent",
        "connexion.exceptions.NonConformingResponseHeaders",
        "connexion.frameworks.abstract.Framework",
        "connexion.lifecycle.ConnexionResponse"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "utils.extract_content_type",
          "body": "def extract_content_type(headers: t.Union[t.List[t.Tuple[bytes, bytes]], t.Dict[str, str]]) -> t.Optional[str]:\n    \"\"\"Extract the mime type and encoding from the content type headers.\n\n    :param headers: Headers from ASGI scope\n\n    :return: The content type if available in headers, otherwise None\n    \"\"\"\n    content_type: t.Optional[str] = None\n    header_pairs_type = t.Collection[t.Tuple[t.Union[str, bytes], t.Union[str, bytes]]]\n    header_pairs: header_pairs_type = headers.items() if isinstance(headers, dict) else headers\n    for key, value in header_pairs:\n        if isinstance(key, bytes):\n            decoded_key: str = key.decode('latin-1')\n        else:\n            decoded_key = key\n        if decoded_key.lower() == 'content-type':\n            if isinstance(value, bytes):\n                content_type = value.decode('latin-1')\n            else:\n                content_type = value\n            break\n    return content_type"
        }
      ]
    },
    {
      "name": "_serialize_data",
      "module": "response",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\response.py",
      "line_number": 89,
      "end_line_number": 97,
      "source_code": "def _serialize_data(self, data: t.Any, *, content_type: str) -> t.Any:\n        \"\"\"Serialize the data based on the content type.\"\"\"\n        if data is None or data is NoContent:\n            return None\n        # TODO: encode responses\n        mime_type, _ = utils.split_content_type(content_type)\n        if utils.is_json_mimetype(mime_type):\n            return self.jsonifier.dumps(data)\n        return data",
      "docstring": "Serialize the data based on the content type.",
      "decorators": [],
      "arguments": [
        "self",
        "data"
      ],
      "imports": [
        "abc",
        "collections.abc",
        "functools",
        "logging",
        "types",
        "typing",
        "enum.Enum",
        "connexion.utils",
        "connexion.context.operation",
        "connexion.datastructures.NoContent",
        "connexion.exceptions.NonConformingResponseHeaders",
        "connexion.frameworks.abstract.Framework",
        "connexion.lifecycle.ConnexionResponse"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "utils.split_content_type",
          "body": "def split_content_type(content_type: t.Optional[str]) -> t.Tuple[t.Optional[str], t.Optional[str]]:\n    \"\"\"Split the content type in mime_type and encoding. Other parameters are ignored.\"\"\"\n    mime_type, encoding = (None, None)\n    if content_type is None:\n        return (mime_type, encoding)\n    if ';' in content_type:\n        mime_type, parameters = content_type.split(';', maxsplit=1)\n        prefix = 'charset='\n        for parameter in parameters.split(';'):\n            if parameter.startswith(prefix):\n                encoding = parameter[len(prefix):]\n    else:\n        mime_type = content_type\n    return (mime_type, encoding)"
        },
        {
          "name": "utils.is_json_mimetype",
          "body": "def is_json_mimetype(mimetype):\n    \"\"\"\n    :type mimetype: str\n    :rtype: bool\n    \"\"\"\n    if mimetype is None:\n        return False\n    maintype, subtype = mimetype.split('/')\n    if ';' in subtype:\n        subtype, parameter = subtype.split(';', maxsplit=1)\n    return maintype == 'application' and (subtype == 'json' or subtype.endswith('+json'))"
        },
        {
          "name": "self.jsonifier.dumps",
          "body": "def dumps(self, data, **kwargs):\n    \"\"\"Central point where JSON serialization happens inside\n        Connexion.\n        \"\"\"\n    for k, v in self.dumps_args.items():\n        kwargs.setdefault(k, v)\n    return self.json.dumps(data, **kwargs) + '\\n'"
        }
      ]
    },
    {
      "name": "_infer_status_code",
      "module": "response",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\response.py",
      "line_number": 100,
      "end_line_number": 104,
      "source_code": "def _infer_status_code(data: t.Any) -> int:\n        \"\"\"Infer the status code from the returned data.\"\"\"\n        if data is None:\n            return 204\n        return 200",
      "docstring": "Infer the status code from the returned data.",
      "decorators": [
        "staticmethod"
      ],
      "arguments": [
        "data"
      ],
      "imports": [
        "abc",
        "collections.abc",
        "functools",
        "logging",
        "types",
        "typing",
        "enum.Enum",
        "connexion.utils",
        "connexion.context.operation",
        "connexion.datastructures.NoContent",
        "connexion.exceptions.NonConformingResponseHeaders",
        "connexion.frameworks.abstract.Framework",
        "connexion.lifecycle.ConnexionResponse"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_update_headers",
      "module": "response",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\response.py",
      "line_number": 107,
      "end_line_number": 117,
      "source_code": "def _update_headers(\n        headers: t.Dict[str, str], *, content_type: str\n    ) -> t.Dict[str, str]:\n        # Check if Content-Type is in headers, taking into account case-insensitivity\n        for key, value in headers.items():\n            if key.lower() == \"content-type\":\n                return headers\n\n        if content_type:\n            headers[\"Content-Type\"] = content_type\n        return headers",
      "docstring": null,
      "decorators": [
        "staticmethod"
      ],
      "arguments": [
        "headers"
      ],
      "imports": [
        "abc",
        "collections.abc",
        "functools",
        "logging",
        "types",
        "typing",
        "enum.Enum",
        "connexion.utils",
        "connexion.context.operation",
        "connexion.datastructures.NoContent",
        "connexion.exceptions.NonConformingResponseHeaders",
        "connexion.frameworks.abstract.Framework",
        "connexion.lifecycle.ConnexionResponse"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_unpack_handler_response",
      "module": "response",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\response.py",
      "line_number": 120,
      "end_line_number": 160,
      "source_code": "def _unpack_handler_response(\n        handler_response: t.Union[str, bytes, dict, list, tuple]\n    ) -> t.Tuple[t.Union[str, bytes, dict, list, None], t.Optional[int], dict]:\n        \"\"\"Unpack the handler response into data, status_code and headers.\n\n        :param handler_response: The response returned from the handler function if it was not a\n            response class.\n\n        :return: A tuple of data, status_code and headers\n        \"\"\"\n        data, status_code, headers = None, None, {}\n\n        if not isinstance(handler_response, tuple):\n            data = handler_response\n\n        elif len(handler_response) == 1:\n            (data,) = handler_response\n\n        elif len(handler_response) == 2:\n            data, status_code_or_headers = handler_response\n            if isinstance(status_code_or_headers, int):\n                # Extra int call because of int subclasses such as http.HTTPStatus (IntEnum)\n                status_code = int(status_code_or_headers)\n            elif isinstance(status_code_or_headers, Enum) and isinstance(\n                status_code_or_headers.value, int\n            ):\n                status_code = status_code_or_headers.value\n            else:\n                headers = status_code_or_headers\n\n        elif len(handler_response) == 3:\n            data, status_code, headers = handler_response\n\n        else:\n            raise TypeError(\n                \"The view function did not return a valid response tuple.\"\n                \" The tuple must have the form (body), (body, status, headers),\"\n                \" (body, status), or (body, headers).\"\n            )\n\n        return data, status_code, headers",
      "docstring": "Unpack the handler response into data, status_code and headers.\n\n:param handler_response: The response returned from the handler function if it was not a\n    response class.\n\n:return: A tuple of data, status_code and headers",
      "decorators": [
        "staticmethod"
      ],
      "arguments": [
        "handler_response"
      ],
      "imports": [
        "abc",
        "collections.abc",
        "functools",
        "logging",
        "types",
        "typing",
        "enum.Enum",
        "connexion.utils",
        "connexion.context.operation",
        "connexion.datastructures.NoContent",
        "connexion.exceptions.NonConformingResponseHeaders",
        "connexion.frameworks.abstract.Framework",
        "connexion.lifecycle.ConnexionResponse"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__call__",
      "module": "response",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\response.py",
      "line_number": 164,
      "end_line_number": 180,
      "source_code": "def __call__(self, function: t.Callable) -> t.Callable:\n        @functools.wraps(function)\n        def wrapper(*args, **kwargs):\n            \"\"\"\n            This method converts a handler response to a framework response.\n            The handler response can be a ConnexionResponse, a framework response, a tuple or an\n            object.\n            \"\"\"\n            handler_response = function(*args, **kwargs)\n            if self.framework.is_framework_response(handler_response):\n                return handler_response\n            elif isinstance(handler_response, ConnexionResponse):\n                return self.framework.connexion_to_framework_response(handler_response)\n            else:\n                return self.build_framework_response(handler_response)\n\n        return wrapper",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "function"
      ],
      "imports": [
        "abc",
        "collections.abc",
        "functools",
        "logging",
        "types",
        "typing",
        "enum.Enum",
        "connexion.utils",
        "connexion.context.operation",
        "connexion.datastructures.NoContent",
        "connexion.exceptions.NonConformingResponseHeaders",
        "connexion.frameworks.abstract.Framework",
        "connexion.lifecycle.ConnexionResponse"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "function",
          "body": "@property\ndef function(self):\n    return self.handle"
        },
        {
          "name": "self.framework.is_framework_response",
          "body": "@staticmethod\n@abc.abstractmethod\ndef is_framework_response(response: t.Any) -> bool:\n    \"\"\"Return True if provided response is a framework type\"\"\"\n    raise NotImplementedError"
        },
        {
          "name": "self.framework.connexion_to_framework_response",
          "body": "@classmethod\n@abc.abstractmethod\ndef connexion_to_framework_response(cls, response):\n    \"\"\"Cast ConnexionResponse to framework response class\"\"\"\n    raise NotImplementedError"
        },
        {
          "name": "self.build_framework_response",
          "body": "def build_framework_response(self, handler_response):\n    data, status_code, headers = self._unpack_handler_response(handler_response)\n    content_type = self._infer_content_type(data, headers)\n    if not self.framework.is_framework_response(data):\n        data = self._serialize_data(data, content_type=content_type)\n        status_code = status_code or self._infer_status_code(data)\n        headers = self._update_headers(headers, content_type=content_type)\n    return self.framework.build_response(data, content_type=content_type, status_code=status_code, headers=headers)"
        }
      ]
    },
    {
      "name": "__call__",
      "module": "response",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\response.py",
      "line_number": 184,
      "end_line_number": 200,
      "source_code": "def __call__(self, function: t.Callable) -> t.Callable:\n        @functools.wraps(function)\n        async def wrapper(*args, **kwargs):\n            \"\"\"\n            This method converts a handler response to a framework response.\n            The handler response can be a ConnexionResponse, a framework response, a tuple or an\n            object.\n            \"\"\"\n            handler_response = await function(*args, **kwargs)\n            if self.framework.is_framework_response(handler_response):\n                return handler_response\n            elif isinstance(handler_response, ConnexionResponse):\n                return self.framework.connexion_to_framework_response(handler_response)\n            else:\n                return self.build_framework_response(handler_response)\n\n        return wrapper",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "function"
      ],
      "imports": [
        "abc",
        "collections.abc",
        "functools",
        "logging",
        "types",
        "typing",
        "enum.Enum",
        "connexion.utils",
        "connexion.context.operation",
        "connexion.datastructures.NoContent",
        "connexion.exceptions.NonConformingResponseHeaders",
        "connexion.frameworks.abstract.Framework",
        "connexion.lifecycle.ConnexionResponse"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.framework.is_framework_response",
          "body": "@staticmethod\n@abc.abstractmethod\ndef is_framework_response(response: t.Any) -> bool:\n    \"\"\"Return True if provided response is a framework type\"\"\"\n    raise NotImplementedError"
        },
        {
          "name": "function",
          "body": "@property\ndef function(self):\n    return self.handle"
        },
        {
          "name": "self.framework.connexion_to_framework_response",
          "body": "@classmethod\n@abc.abstractmethod\ndef connexion_to_framework_response(cls, response):\n    \"\"\"Cast ConnexionResponse to framework response class\"\"\"\n    raise NotImplementedError"
        },
        {
          "name": "self.build_framework_response",
          "body": "def build_framework_response(self, handler_response):\n    data, status_code, headers = self._unpack_handler_response(handler_response)\n    content_type = self._infer_content_type(data, headers)\n    if not self.framework.is_framework_response(data):\n        data = self._serialize_data(data, content_type=content_type)\n        status_code = status_code or self._infer_status_code(data)\n        headers = self._update_headers(headers, content_type=content_type)\n    return self.framework.build_response(data, content_type=content_type, status_code=status_code, headers=headers)"
        }
      ]
    },
    {
      "name": "__call__",
      "module": "response",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\response.py",
      "line_number": 206,
      "end_line_number": 207,
      "source_code": "def __call__(self, function: t.Callable) -> t.Callable:\n        return lambda request: function(request)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "function"
      ],
      "imports": [
        "abc",
        "collections.abc",
        "functools",
        "logging",
        "types",
        "typing",
        "enum.Enum",
        "connexion.utils",
        "connexion.context.operation",
        "connexion.datastructures.NoContent",
        "connexion.exceptions.NonConformingResponseHeaders",
        "connexion.frameworks.abstract.Framework",
        "connexion.lifecycle.ConnexionResponse"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "function",
          "body": "@property\ndef function(self):\n    return self.handle"
        }
      ]
    },
    {
      "name": "wrapper",
      "module": "response",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\decorators\\response.py",
      "line_number": 166,
      "end_line_number": 178,
      "source_code": "def wrapper(*args, **kwargs):\n            \"\"\"\n            This method converts a handler response to a framework response.\n            The handler response can be a ConnexionResponse, a framework response, a tuple or an\n            object.\n            \"\"\"\n            handler_response = function(*args, **kwargs)\n            if self.framework.is_framework_response(handler_response):\n                return handler_response\n            elif isinstance(handler_response, ConnexionResponse):\n                return self.framework.connexion_to_framework_response(handler_response)\n            else:\n                return self.build_framework_response(handler_response)",
      "docstring": "This method converts a handler response to a framework response.\nThe handler response can be a ConnexionResponse, a framework response, a tuple or an\nobject.",
      "decorators": [
        "functools.wraps(function)"
      ],
      "arguments": [],
      "imports": [
        "abc",
        "collections.abc",
        "functools",
        "logging",
        "types",
        "typing",
        "enum.Enum",
        "connexion.utils",
        "connexion.context.operation",
        "connexion.datastructures.NoContent",
        "connexion.exceptions.NonConformingResponseHeaders",
        "connexion.frameworks.abstract.Framework",
        "connexion.lifecycle.ConnexionResponse"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "function",
          "body": "@property\ndef function(self):\n    return self.handle"
        },
        {
          "name": "self.framework.is_framework_response",
          "body": "@staticmethod\n@abc.abstractmethod\ndef is_framework_response(response: t.Any) -> bool:\n    \"\"\"Return True if provided response is a framework type\"\"\"\n    raise NotImplementedError"
        },
        {
          "name": "self.framework.connexion_to_framework_response",
          "body": "@classmethod\n@abc.abstractmethod\ndef connexion_to_framework_response(cls, response):\n    \"\"\"Cast ConnexionResponse to framework response class\"\"\"\n    raise NotImplementedError"
        },
        {
          "name": "self.build_framework_response",
          "body": "def build_framework_response(self, handler_response):\n    data, status_code, headers = self._unpack_handler_response(handler_response)\n    content_type = self._infer_content_type(data, headers)\n    if not self.framework.is_framework_response(data):\n        data = self._serialize_data(data, content_type=content_type)\n        status_code = status_code or self._infer_status_code(data)\n        headers = self._update_headers(headers, content_type=content_type)\n    return self.framework.build_response(data, content_type=content_type, status_code=status_code, headers=headers)"
        }
      ]
    },
    {
      "name": "is_framework_response",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\frameworks\\abstract.py",
      "line_number": 10,
      "end_line_number": 12,
      "source_code": "def is_framework_response(response: t.Any) -> bool:\n        \"\"\"Return True if provided response is a framework type\"\"\"\n        raise NotImplementedError",
      "docstring": "Return True if provided response is a framework type",
      "decorators": [
        "staticmethod",
        "abc.abstractmethod"
      ],
      "arguments": [
        "response"
      ],
      "imports": [
        "abc",
        "typing",
        "typing_extensions.Protocol"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "connexion_to_framework_response",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\frameworks\\abstract.py",
      "line_number": 16,
      "end_line_number": 18,
      "source_code": "def connexion_to_framework_response(cls, response):\n        \"\"\"Cast ConnexionResponse to framework response class\"\"\"\n        raise NotImplementedError",
      "docstring": "Cast ConnexionResponse to framework response class",
      "decorators": [
        "classmethod",
        "abc.abstractmethod"
      ],
      "arguments": [
        "cls",
        "response"
      ],
      "imports": [
        "abc",
        "typing",
        "typing_extensions.Protocol"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "build_response",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\frameworks\\abstract.py",
      "line_number": 22,
      "end_line_number": 30,
      "source_code": "def build_response(\n        cls,\n        data: t.Any,\n        *,\n        content_type: t.Optional[str] = None,\n        headers: t.Optional[dict] = None,\n        status_code: int = None\n    ):\n        raise NotImplementedError",
      "docstring": null,
      "decorators": [
        "classmethod",
        "abc.abstractmethod"
      ],
      "arguments": [
        "cls",
        "data"
      ],
      "imports": [
        "abc",
        "typing",
        "typing_extensions.Protocol"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "get_request",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\frameworks\\abstract.py",
      "line_number": 34,
      "end_line_number": 36,
      "source_code": "def get_request(*args, **kwargs):\n        \"\"\"Return a framework request from the context.\"\"\"\n        raise NotImplementedError",
      "docstring": "Return a framework request from the context.",
      "decorators": [
        "staticmethod",
        "abc.abstractmethod"
      ],
      "arguments": [],
      "imports": [
        "abc",
        "typing",
        "typing_extensions.Protocol"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "get_body",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\frameworks\\abstract.py",
      "line_number": 40,
      "end_line_number": 42,
      "source_code": "def get_body(request):\n        \"\"\"Get body from a framework request\"\"\"\n        raise NotImplementedError",
      "docstring": "Get body from a framework request",
      "decorators": [
        "staticmethod",
        "abc.abstractmethod"
      ],
      "arguments": [
        "request"
      ],
      "imports": [
        "abc",
        "typing",
        "typing_extensions.Protocol"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "flaskify_endpoint",
      "module": "flask",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\frameworks\\flask.py",
      "line_number": 70,
      "end_line_number": 91,
      "source_code": "def flaskify_endpoint(identifier, randomize=None):\n    \"\"\"\n    Converts the provided identifier in a valid flask endpoint name\n\n    :type identifier: str\n    :param randomize: If specified, add this many random characters (upper case\n        and digits) to the endpoint name, separated by a pipe character.\n    :type randomize: int | None\n    :rtype: str\n\n    \"\"\"\n    result = identifier.replace(\".\", \"_\")\n    if randomize is None:\n        return result\n\n    chars = string.ascii_uppercase + string.digits\n    return \"{result}|{random_string}\".format(\n        result=result,\n        random_string=\"\".join(\n            random.SystemRandom().choice(chars) for _ in range(randomize)\n        ),\n    )",
      "docstring": "Converts the provided identifier in a valid flask endpoint name\n\n:type identifier: str\n:param randomize: If specified, add this many random characters (upper case\n    and digits) to the endpoint name, separated by a pipe character.\n:type randomize: int | None\n:rtype: str",
      "decorators": [],
      "arguments": [
        "identifier",
        "randomize"
      ],
      "imports": [
        "functools",
        "random",
        "re",
        "string",
        "typing",
        "flask",
        "werkzeug.routing",
        "connexion.jsonifier",
        "connexion.frameworks.abstract.Framework",
        "connexion.lifecycle.WSGIRequest",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "identifier.replace",
          "body": "def replace(self, **changes) -> '_Options':\n    \"\"\"Update mechanism to overwrite the options. None values are discarded.\n\n        :param changes: Arguments accepted by the __init__ method of this class.\n\n        :return: An new _Options object with updated arguments.\n        \"\"\"\n    changes = {key: value for key, value in changes.items() if value is not None}\n    return dataclasses.replace(self, **changes)"
        }
      ]
    },
    {
      "name": "convert_path_parameter",
      "module": "flask",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\frameworks\\flask.py",
      "line_number": 94,
      "end_line_number": 100,
      "source_code": "def convert_path_parameter(match, types):\n    name = match.group(1)\n    swagger_type = types.get(name)\n    converter = PATH_PARAMETER_CONVERTERS.get(swagger_type)\n    return \"<{}{}{}>\".format(\n        converter or \"\", \":\" if converter else \"\", name.replace(\"-\", \"_\")\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "match",
        "types"
      ],
      "imports": [
        "functools",
        "random",
        "re",
        "string",
        "typing",
        "flask",
        "werkzeug.routing",
        "connexion.jsonifier",
        "connexion.frameworks.abstract.Framework",
        "connexion.lifecycle.WSGIRequest",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "PATH_PARAMETER_CONVERTERS.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "name.replace",
          "body": "def replace(self, **changes) -> '_Options':\n    \"\"\"Update mechanism to overwrite the options. None values are discarded.\n\n        :param changes: Arguments accepted by the __init__ method of this class.\n\n        :return: An new _Options object with updated arguments.\n        \"\"\"\n    changes = {key: value for key, value in changes.items() if value is not None}\n    return dataclasses.replace(self, **changes)"
        }
      ]
    },
    {
      "name": "flaskify_path",
      "module": "flask",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\frameworks\\flask.py",
      "line_number": 103,
      "end_line_number": 120,
      "source_code": "def flaskify_path(swagger_path, types=None):\n    \"\"\"\n    Convert swagger path templates to flask path templates\n\n    :type swagger_path: str\n    :type types: dict\n    :rtype: str\n\n    >>> flaskify_path('/foo-bar/{my-param}')\n    '/foo-bar/<my_param>'\n\n    >>> flaskify_path('/foo/{someint}', {'someint': 'int'})\n    '/foo/<int:someint>'\n    \"\"\"\n    if types is None:\n        types = {}\n    convert_match = functools.partial(convert_path_parameter, types=types)\n    return PATH_PARAMETER.sub(convert_match, swagger_path)",
      "docstring": "Convert swagger path templates to flask path templates\n\n:type swagger_path: str\n:type types: dict\n:rtype: str\n\n>>> flaskify_path('/foo-bar/{my-param}')\n'/foo-bar/<my_param>'\n\n>>> flaskify_path('/foo/{someint}', {'someint': 'int'})\n'/foo/<int:someint>'",
      "decorators": [],
      "arguments": [
        "swagger_path",
        "types"
      ],
      "imports": [
        "functools",
        "random",
        "re",
        "string",
        "typing",
        "flask",
        "werkzeug.routing",
        "connexion.jsonifier",
        "connexion.frameworks.abstract.Framework",
        "connexion.lifecycle.WSGIRequest",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "is_framework_response",
      "module": "flask",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\frameworks\\flask.py",
      "line_number": 21,
      "end_line_number": 24,
      "source_code": "def is_framework_response(response: t.Any) -> bool:\n        return isinstance(response, flask.Response) or isinstance(\n            response, werkzeug.wrappers.Response\n        )",
      "docstring": null,
      "decorators": [
        "staticmethod"
      ],
      "arguments": [
        "response"
      ],
      "imports": [
        "functools",
        "random",
        "re",
        "string",
        "typing",
        "flask",
        "werkzeug.routing",
        "connexion.jsonifier",
        "connexion.frameworks.abstract.Framework",
        "connexion.lifecycle.WSGIRequest",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "connexion_to_framework_response",
      "module": "flask",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\frameworks\\flask.py",
      "line_number": 27,
      "end_line_number": 33,
      "source_code": "def connexion_to_framework_response(cls, response):\n        return cls.build_response(\n            content_type=response.content_type,\n            headers=response.headers,\n            status_code=response.status_code,\n            data=response.body,\n        )",
      "docstring": null,
      "decorators": [
        "classmethod"
      ],
      "arguments": [
        "cls",
        "response"
      ],
      "imports": [
        "functools",
        "random",
        "re",
        "string",
        "typing",
        "flask",
        "werkzeug.routing",
        "connexion.jsonifier",
        "connexion.frameworks.abstract.Framework",
        "connexion.lifecycle.WSGIRequest",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "cls.build_response",
          "body": "@classmethod\n@abc.abstractmethod\ndef build_response(cls, data: t.Any, *, content_type: t.Optional[str]=None, headers: t.Optional[dict]=None, status_code: int=None):\n    raise NotImplementedError"
        }
      ]
    },
    {
      "name": "build_response",
      "module": "flask",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\frameworks\\flask.py",
      "line_number": 36,
      "end_line_number": 54,
      "source_code": "def build_response(\n        cls,\n        data: t.Any,\n        *,\n        content_type: t.Optional[str] = None,\n        headers: t.Optional[dict] = None,\n        status_code: int = None\n    ):\n        if cls.is_framework_response(data):\n            return flask.current_app.make_response((data, status_code, headers))\n\n        kwargs = {\n            \"mimetype\": content_type,\n            \"headers\": headers,\n            \"response\": data,\n            \"status\": status_code,\n        }\n        kwargs = {k: v for k, v in kwargs.items() if v is not None}\n        return flask.current_app.response_class(**kwargs)",
      "docstring": null,
      "decorators": [
        "classmethod"
      ],
      "arguments": [
        "cls",
        "data"
      ],
      "imports": [
        "functools",
        "random",
        "re",
        "string",
        "typing",
        "flask",
        "werkzeug.routing",
        "connexion.jsonifier",
        "connexion.frameworks.abstract.Framework",
        "connexion.lifecycle.WSGIRequest",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "cls.is_framework_response",
          "body": "@staticmethod\n@abc.abstractmethod\ndef is_framework_response(response: t.Any) -> bool:\n    \"\"\"Return True if provided response is a framework type\"\"\"\n    raise NotImplementedError"
        }
      ]
    },
    {
      "name": "get_request",
      "module": "flask",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\frameworks\\flask.py",
      "line_number": 57,
      "end_line_number": 60,
      "source_code": "def get_request(*, uri_parser: AbstractURIParser, **kwargs) -> WSGIRequest:  # type: ignore\n        return WSGIRequest(\n            flask.request, uri_parser=uri_parser, view_args=flask.request.view_args\n        )",
      "docstring": null,
      "decorators": [
        "staticmethod"
      ],
      "arguments": [],
      "imports": [
        "functools",
        "random",
        "re",
        "string",
        "typing",
        "flask",
        "werkzeug.routing",
        "connexion.jsonifier",
        "connexion.frameworks.abstract.Framework",
        "connexion.lifecycle.WSGIRequest",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "default",
      "module": "flask",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\frameworks\\flask.py",
      "line_number": 127,
      "end_line_number": 128,
      "source_code": "def default(self, o):\n        return super().default(o)",
      "docstring": null,
      "decorators": [
        "jsonifier.wrap_default"
      ],
      "arguments": [
        "self",
        "o"
      ],
      "imports": [
        "functools",
        "random",
        "re",
        "string",
        "typing",
        "flask",
        "werkzeug.routing",
        "connexion.jsonifier",
        "connexion.frameworks.abstract.Framework",
        "connexion.lifecycle.WSGIRequest",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "to_python",
      "module": "flask",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\frameworks\\flask.py",
      "line_number": 136,
      "end_line_number": 137,
      "source_code": "def to_python(self, value):\n        return float(value)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "value"
      ],
      "imports": [
        "functools",
        "random",
        "re",
        "string",
        "typing",
        "flask",
        "werkzeug.routing",
        "connexion.jsonifier",
        "connexion.frameworks.abstract.Framework",
        "connexion.lifecycle.WSGIRequest",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "to_python",
      "module": "flask",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\frameworks\\flask.py",
      "line_number": 145,
      "end_line_number": 146,
      "source_code": "def to_python(self, value):\n        return int(value)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "value"
      ],
      "imports": [
        "functools",
        "random",
        "re",
        "string",
        "typing",
        "flask",
        "werkzeug.routing",
        "connexion.jsonifier",
        "connexion.frameworks.abstract.Framework",
        "connexion.lifecycle.WSGIRequest",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "convert_path_parameter",
      "module": "starlette",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\frameworks\\starlette.py",
      "line_number": 59,
      "end_line_number": 63,
      "source_code": "def convert_path_parameter(match, types):\n    name = match.group(1)\n    swagger_type = types.get(name)\n    converter = PATH_PARAMETER_CONVERTERS.get(swagger_type)\n    return f'{{{name.replace(\"-\", \"_\")}{\":\" if converter else \"\"}{converter or \"\"}}}'",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "match",
        "types"
      ],
      "imports": [
        "functools",
        "re",
        "typing",
        "starlette.convertors",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "connexion.frameworks.abstract.Framework",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "PATH_PARAMETER_CONVERTERS.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "name.replace",
          "body": "def replace(self, **changes) -> '_Options':\n    \"\"\"Update mechanism to overwrite the options. None values are discarded.\n\n        :param changes: Arguments accepted by the __init__ method of this class.\n\n        :return: An new _Options object with updated arguments.\n        \"\"\"\n    changes = {key: value for key, value in changes.items() if value is not None}\n    return dataclasses.replace(self, **changes)"
        }
      ]
    },
    {
      "name": "starlettify_path",
      "module": "starlette",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\frameworks\\starlette.py",
      "line_number": 66,
      "end_line_number": 83,
      "source_code": "def starlettify_path(swagger_path, types=None):\n    \"\"\"\n    Convert swagger path templates to flask path templates\n\n    :type swagger_path: str\n    :type types: dict\n    :rtype: str\n\n    >>> starlettify_path('/foo-bar/{my-param}')\n    '/foo-bar/{my_param}'\n\n    >>> starlettify_path('/foo/{someint}', {'someint': 'int'})\n    '/foo/{someint:int}'\n    \"\"\"\n    if types is None:\n        types = {}\n    convert_match = functools.partial(convert_path_parameter, types=types)\n    return PATH_PARAMETER.sub(convert_match, swagger_path)",
      "docstring": "Convert swagger path templates to flask path templates\n\n:type swagger_path: str\n:type types: dict\n:rtype: str\n\n>>> starlettify_path('/foo-bar/{my-param}')\n'/foo-bar/{my_param}'\n\n>>> starlettify_path('/foo/{someint}', {'someint': 'int'})\n'/foo/{someint:int}'",
      "decorators": [],
      "arguments": [
        "swagger_path",
        "types"
      ],
      "imports": [
        "functools",
        "re",
        "typing",
        "starlette.convertors",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "connexion.frameworks.abstract.Framework",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "is_framework_response",
      "module": "starlette",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\frameworks\\starlette.py",
      "line_number": 17,
      "end_line_number": 18,
      "source_code": "def is_framework_response(response: t.Any) -> bool:\n        return isinstance(response, StarletteResponse)",
      "docstring": null,
      "decorators": [
        "staticmethod"
      ],
      "arguments": [
        "response"
      ],
      "imports": [
        "functools",
        "re",
        "typing",
        "starlette.convertors",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "connexion.frameworks.abstract.Framework",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "connexion_to_framework_response",
      "module": "starlette",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\frameworks\\starlette.py",
      "line_number": 21,
      "end_line_number": 27,
      "source_code": "def connexion_to_framework_response(cls, response):\n        return cls.build_response(\n            status_code=response.status_code,\n            content_type=response.content_type,\n            headers=response.headers,\n            data=response.body,\n        )",
      "docstring": null,
      "decorators": [
        "classmethod"
      ],
      "arguments": [
        "cls",
        "response"
      ],
      "imports": [
        "functools",
        "re",
        "typing",
        "starlette.convertors",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "connexion.frameworks.abstract.Framework",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "cls.build_response",
          "body": "@classmethod\n@abc.abstractmethod\ndef build_response(cls, data: t.Any, *, content_type: t.Optional[str]=None, headers: t.Optional[dict]=None, status_code: int=None):\n    raise NotImplementedError"
        }
      ]
    },
    {
      "name": "build_response",
      "module": "starlette",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\frameworks\\starlette.py",
      "line_number": 30,
      "end_line_number": 48,
      "source_code": "def build_response(\n        cls,\n        data: t.Any,\n        *,\n        content_type: t.Optional[str] = None,\n        headers: t.Optional[dict] = None,\n        status_code: int = None,\n    ):\n        if isinstance(data, dict) or isinstance(data, list):\n            response_cls = StarletteJSONResponse\n        else:\n            response_cls = StarletteResponse\n\n        return response_cls(\n            content=data,\n            status_code=status_code,\n            media_type=content_type,\n            headers=headers,\n        )",
      "docstring": null,
      "decorators": [
        "classmethod"
      ],
      "arguments": [
        "cls",
        "data"
      ],
      "imports": [
        "functools",
        "re",
        "typing",
        "starlette.convertors",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "connexion.frameworks.abstract.Framework",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "get_request",
      "module": "starlette",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\frameworks\\starlette.py",
      "line_number": 51,
      "end_line_number": 52,
      "source_code": "def get_request(*, scope: Scope, receive: Receive, uri_parser: AbstractURIParser, **kwargs) -> ConnexionRequest:  # type: ignore\n        return ConnexionRequest(scope, receive, uri_parser=uri_parser)",
      "docstring": null,
      "decorators": [
        "staticmethod"
      ],
      "arguments": [],
      "imports": [
        "functools",
        "re",
        "typing",
        "starlette.convertors",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "connexion.frameworks.abstract.Framework",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.uri_parsing.AbstractURIParser"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "add_api",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\abstract.py",
      "line_number": 24,
      "end_line_number": 28,
      "source_code": "def add_api(self, specification: Specification, **kwargs) -> t.Any:\n        \"\"\"\n        Register an API represented by a single OpenAPI specification on this middleware.\n        Multiple APIs can be registered on a single middleware.\n        \"\"\"",
      "docstring": "Register an API represented by a single OpenAPI specification on this middleware.\nMultiple APIs can be registered on a single middleware.",
      "decorators": [
        "abc.abstractmethod"
      ],
      "arguments": [
        "self",
        "specification"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "collections.defaultdict",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.exceptions.MissingMiddleware",
        "connexion.exceptions.ResolverError",
        "connexion.http_facts.METHODS",
        "connexion.operations.AbstractOperation",
        "connexion.resolver.Resolver",
        "connexion.spec.Specification"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\abstract.py",
      "line_number": 38,
      "end_line_number": 52,
      "source_code": "def __init__(\n        self,\n        specification: Specification,\n        base_path: t.Optional[str] = None,\n        resolver: t.Optional[Resolver] = None,\n        uri_parser_class=None,\n        *args,\n        **kwargs,\n    ):\n        self.specification = specification\n        self.uri_parser_class = uri_parser_class\n\n        self._set_base_path(base_path)\n\n        self.resolver = resolver or Resolver()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "specification",
        "base_path",
        "resolver",
        "uri_parser_class"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "collections.defaultdict",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.exceptions.MissingMiddleware",
        "connexion.exceptions.ResolverError",
        "connexion.http_facts.METHODS",
        "connexion.operations.AbstractOperation",
        "connexion.resolver.Resolver",
        "connexion.spec.Specification"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._set_base_path",
          "body": "def _set_base_path(self, base_path: t.Optional[str]=None) -> None:\n    super()._set_base_path(base_path)\n    self._set_blueprint()"
        }
      ]
    },
    {
      "name": "_set_base_path",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\abstract.py",
      "line_number": 54,
      "end_line_number": 60,
      "source_code": "def _set_base_path(self, base_path: t.Optional[str] = None) -> None:\n        if base_path is not None:\n            # update spec to include user-provided base_path\n            self.specification.base_path = base_path\n            self.base_path = base_path\n        else:\n            self.base_path = self.specification.base_path",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "base_path"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "collections.defaultdict",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.exceptions.MissingMiddleware",
        "connexion.exceptions.ResolverError",
        "connexion.http_facts.METHODS",
        "connexion.operations.AbstractOperation",
        "connexion.resolver.Resolver",
        "connexion.spec.Specification"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\abstract.py",
      "line_number": 70,
      "end_line_number": 81,
      "source_code": "def __init__(\n        self,\n        *args,\n        pythonic_params=False,\n        resolver_error_handler: t.Optional[t.Callable] = None,\n        **kwargs,\n    ) -> None:\n        super().__init__(*args, **kwargs)\n        self.pythonic_params = pythonic_params\n        self.resolver_error_handler = resolver_error_handler\n\n        self.add_paths()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "collections.defaultdict",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.exceptions.MissingMiddleware",
        "connexion.exceptions.ResolverError",
        "connexion.http_facts.METHODS",
        "connexion.operations.AbstractOperation",
        "connexion.resolver.Resolver",
        "connexion.spec.Specification"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.add_paths",
          "body": "def add_paths(self, paths: t.Optional[dict]=None) -> None:\n    \"\"\"\n        Adds the paths defined in the specification as operations.\n        \"\"\"\n    paths = t.cast(dict, paths or self.specification.get('paths', dict()))\n    for path, methods in paths.items():\n        logger.debug('Adding %s%s...', self.base_path, path)\n        for method in methods:\n            if method not in METHODS:\n                continue\n            try:\n                self.add_operation(path, method)\n            except ResolverError as err:\n                if self.resolver_error_handler is not None:\n                    self._add_resolver_error_handler(method, path, err)\n                else:\n                    self._handle_add_operation_error(path, method, err)\n            except Exception as e:\n                self._handle_add_operation_error(path, method, e)"
        }
      ]
    },
    {
      "name": "add_paths",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\abstract.py",
      "line_number": 83,
      "end_line_number": 105,
      "source_code": "def add_paths(self, paths: t.Optional[dict] = None) -> None:\n        \"\"\"\n        Adds the paths defined in the specification as operations.\n        \"\"\"\n        paths = t.cast(dict, paths or self.specification.get(\"paths\", dict()))\n        for path, methods in paths.items():\n            logger.debug(\"Adding %s%s...\", self.base_path, path)\n\n            for method in methods:\n                if method not in METHODS:\n                    continue\n                try:\n                    self.add_operation(path, method)\n                except ResolverError as err:\n                    # If we have an error handler for resolver errors, add it as an operation.\n                    # Otherwise treat it as any other error.\n                    if self.resolver_error_handler is not None:\n                        self._add_resolver_error_handler(method, path, err)\n                    else:\n                        self._handle_add_operation_error(path, method, err)\n                except Exception as e:\n                    # All other relevant exceptions should be handled as well.\n                    self._handle_add_operation_error(path, method, e)",
      "docstring": "Adds the paths defined in the specification as operations.",
      "decorators": [],
      "arguments": [
        "self",
        "paths"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "collections.defaultdict",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.exceptions.MissingMiddleware",
        "connexion.exceptions.ResolverError",
        "connexion.http_facts.METHODS",
        "connexion.operations.AbstractOperation",
        "connexion.resolver.Resolver",
        "connexion.spec.Specification"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.specification.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "self.add_operation",
          "body": "def add_operation(self, path: str, method: str) -> None:\n    \"\"\"\n        Adds one operation to the api.\n\n        This method uses the OperationID identify the module and function that will handle the operation\n\n        From Swagger Specification:\n\n        **OperationID**\n\n        A friendly name for the operation. The id MUST be unique among all operations described in the API.\n        Tools and libraries MAY use the operation id to uniquely identify an operation.\n        \"\"\"\n    spec_operation_cls = self.specification.operation_cls\n    spec_operation = spec_operation_cls.from_spec(self.specification, path=path, method=method, resolver=self.resolver, uri_parser_class=self.uri_parser_class)\n    operation = self.make_operation(spec_operation)\n    path, name = self._framework_path_and_name(spec_operation, path)\n    self._add_operation_internal(method, path, operation, name=name)"
        },
        {
          "name": "self._handle_add_operation_error",
          "body": "def _handle_add_operation_error(self, path: str, method: str, exc: Exception) -> None:\n    url = f'{self.base_path}{path}'\n    error_msg = f'Failed to add operation for {method.upper()} {url}'\n    logger.error(error_msg)\n    raise exc from None"
        },
        {
          "name": "self._add_resolver_error_handler",
          "body": "def _add_resolver_error_handler(self, method: str, path: str, err: ResolverError):\n    pass"
        },
        {
          "name": "self._handle_add_operation_error",
          "body": "def _handle_add_operation_error(self, path: str, method: str, exc: Exception) -> None:\n    url = f'{self.base_path}{path}'\n    error_msg = f'Failed to add operation for {method.upper()} {url}'\n    logger.error(error_msg)\n    raise exc from None"
        }
      ]
    },
    {
      "name": "add_operation",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\abstract.py",
      "line_number": 107,
      "end_line_number": 130,
      "source_code": "def add_operation(self, path: str, method: str) -> None:\n        \"\"\"\n        Adds one operation to the api.\n\n        This method uses the OperationID identify the module and function that will handle the operation\n\n        From Swagger Specification:\n\n        **OperationID**\n\n        A friendly name for the operation. The id MUST be unique among all operations described in the API.\n        Tools and libraries MAY use the operation id to uniquely identify an operation.\n        \"\"\"\n        spec_operation_cls = self.specification.operation_cls\n        spec_operation = spec_operation_cls.from_spec(\n            self.specification,\n            path=path,\n            method=method,\n            resolver=self.resolver,\n            uri_parser_class=self.uri_parser_class,\n        )\n        operation = self.make_operation(spec_operation)\n        path, name = self._framework_path_and_name(spec_operation, path)\n        self._add_operation_internal(method, path, operation, name=name)",
      "docstring": "Adds one operation to the api.\n\nThis method uses the OperationID identify the module and function that will handle the operation\n\nFrom Swagger Specification:\n\n**OperationID**\n\nA friendly name for the operation. The id MUST be unique among all operations described in the API.\nTools and libraries MAY use the operation id to uniquely identify an operation.",
      "decorators": [],
      "arguments": [
        "self",
        "path",
        "method"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "collections.defaultdict",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.exceptions.MissingMiddleware",
        "connexion.exceptions.ResolverError",
        "connexion.http_facts.METHODS",
        "connexion.operations.AbstractOperation",
        "connexion.resolver.Resolver",
        "connexion.spec.Specification"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "spec_operation_cls.from_spec",
          "body": "@classmethod\n@abc.abstractmethod\ndef from_spec(cls, spec, *args, path, method, resolver, **kwargs):\n    pass"
        },
        {
          "name": "self.make_operation",
          "body": "def make_operation(self, operation: AbstractOperation) -> AsyncOperation:\n    return AsyncOperation.from_operation(operation, pythonic_params=self.pythonic_params, jsonifier=self.jsonifier)"
        },
        {
          "name": "self._framework_path_and_name",
          "body": "@staticmethod\ndef _framework_path_and_name(operation: AbstractOperation, path: str) -> t.Tuple[str, str]:\n    flask_path = flask_utils.flaskify_path(path, operation.get_path_parameter_types())\n    endpoint_name = flask_utils.flaskify_endpoint(operation.operation_id, operation.randomize_endpoint)\n    return (flask_path, endpoint_name)"
        },
        {
          "name": "self._add_operation_internal",
          "body": "def _add_operation_internal(self, method: str, path: str, operation: t.Callable, name: t.Optional[str]=None) -> None:\n    self.blueprint.add_url_rule(path, name, operation, methods=[method])"
        }
      ]
    },
    {
      "name": "make_operation",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\abstract.py",
      "line_number": 133,
      "end_line_number": 134,
      "source_code": "def make_operation(self, operation: AbstractOperation) -> OP:\n        \"\"\"Build an operation to register on the API.\"\"\"",
      "docstring": "Build an operation to register on the API.",
      "decorators": [
        "abc.abstractmethod"
      ],
      "arguments": [
        "self",
        "operation"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "collections.defaultdict",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.exceptions.MissingMiddleware",
        "connexion.exceptions.ResolverError",
        "connexion.http_facts.METHODS",
        "connexion.operations.AbstractOperation",
        "connexion.resolver.Resolver",
        "connexion.spec.Specification"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_framework_path_and_name",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\abstract.py",
      "line_number": 137,
      "end_line_number": 140,
      "source_code": "def _framework_path_and_name(\n        operation: AbstractOperation, path: str\n    ) -> t.Tuple[str, str]:\n        \"\"\"Prepare the framework path & name to register the operation on the API.\"\"\"",
      "docstring": "Prepare the framework path & name to register the operation on the API.",
      "decorators": [
        "staticmethod"
      ],
      "arguments": [
        "operation",
        "path"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "collections.defaultdict",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.exceptions.MissingMiddleware",
        "connexion.exceptions.ResolverError",
        "connexion.http_facts.METHODS",
        "connexion.operations.AbstractOperation",
        "connexion.resolver.Resolver",
        "connexion.spec.Specification"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_add_operation_internal",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\abstract.py",
      "line_number": 143,
      "end_line_number": 149,
      "source_code": "def _add_operation_internal(\n        self, method: str, path: str, operation: OP, name: t.Optional[str] = None\n    ) -> None:\n        \"\"\"\n        Adds the operation according to the user framework in use.\n        It will be used to register the operation on the user framework router.\n        \"\"\"",
      "docstring": "Adds the operation according to the user framework in use.\nIt will be used to register the operation on the user framework router.",
      "decorators": [
        "abc.abstractmethod"
      ],
      "arguments": [
        "self",
        "method",
        "path",
        "operation",
        "name"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "collections.defaultdict",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.exceptions.MissingMiddleware",
        "connexion.exceptions.ResolverError",
        "connexion.http_facts.METHODS",
        "connexion.operations.AbstractOperation",
        "connexion.resolver.Resolver",
        "connexion.spec.Specification"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_add_resolver_error_handler",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\abstract.py",
      "line_number": 151,
      "end_line_number": 161,
      "source_code": "def _add_resolver_error_handler(\n        self, method: str, path: str, err: ResolverError\n    ) -> None:\n        \"\"\"\n        Adds a handler for ResolverError for the given method and path.\n        \"\"\"\n        self.resolver_error_handler = t.cast(t.Callable, self.resolver_error_handler)\n        operation = self.resolver_error_handler(\n            err,\n        )\n        self._add_operation_internal(method, path, operation)",
      "docstring": "Adds a handler for ResolverError for the given method and path.",
      "decorators": [],
      "arguments": [
        "self",
        "method",
        "path",
        "err"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "collections.defaultdict",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.exceptions.MissingMiddleware",
        "connexion.exceptions.ResolverError",
        "connexion.http_facts.METHODS",
        "connexion.operations.AbstractOperation",
        "connexion.resolver.Resolver",
        "connexion.spec.Specification"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.resolver_error_handler",
          "body": "def resolver_error_handler(*args, **kwargs) -> ResolverErrorHandler:\n    return ResolverErrorHandler(self.resolver_error, *args, **kwargs)"
        },
        {
          "name": "self._add_operation_internal",
          "body": "def _add_operation_internal(self, method: str, path: str, operation: t.Callable, name: t.Optional[str]=None) -> None:\n    self.blueprint.add_url_rule(path, name, operation, methods=[method])"
        }
      ]
    },
    {
      "name": "_handle_add_operation_error",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\abstract.py",
      "line_number": 163,
      "end_line_number": 169,
      "source_code": "def _handle_add_operation_error(\n        self, path: str, method: str, exc: Exception\n    ) -> None:\n        url = f\"{self.base_path}{path}\"\n        error_msg = f\"Failed to add operation for {method.upper()} {url}\"\n        logger.error(error_msg)\n        raise exc from None",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "path",
        "method",
        "exc"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "collections.defaultdict",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.exceptions.MissingMiddleware",
        "connexion.exceptions.ResolverError",
        "connexion.http_facts.METHODS",
        "connexion.operations.AbstractOperation",
        "connexion.resolver.Resolver",
        "connexion.spec.Specification"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\abstract.py",
      "line_number": 173,
      "end_line_number": 182,
      "source_code": "def __init__(\n        self,\n        specification: Specification,\n        *args,\n        next_app: ASGIApp,\n        **kwargs,\n    ) -> None:\n        super().__init__(specification, *args, **kwargs)\n        self.next_app = next_app\n        self.operations: t.MutableMapping[t.Optional[str], OP] = {}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "specification"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "collections.defaultdict",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.exceptions.MissingMiddleware",
        "connexion.exceptions.ResolverError",
        "connexion.http_facts.METHODS",
        "connexion.operations.AbstractOperation",
        "connexion.resolver.Resolver",
        "connexion.spec.Specification"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "add_paths",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\abstract.py",
      "line_number": 184,
      "end_line_number": 194,
      "source_code": "def add_paths(self) -> None:\n        paths = self.specification.get(\"paths\", {})\n        for path, methods in paths.items():\n            for method in methods:\n                if method not in METHODS:\n                    continue\n                try:\n                    self.add_operation(path, method)\n                except ResolverError:\n                    # ResolverErrors are either raised or handled in routing middleware.\n                    pass",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "collections.defaultdict",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.exceptions.MissingMiddleware",
        "connexion.exceptions.ResolverError",
        "connexion.http_facts.METHODS",
        "connexion.operations.AbstractOperation",
        "connexion.resolver.Resolver",
        "connexion.spec.Specification"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.specification.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "self.add_operation",
          "body": "def add_operation(self, path: str, method: str) -> None:\n    \"\"\"\n        Adds one operation to the api.\n\n        This method uses the OperationID identify the module and function that will handle the operation\n\n        From Swagger Specification:\n\n        **OperationID**\n\n        A friendly name for the operation. The id MUST be unique among all operations described in the API.\n        Tools and libraries MAY use the operation id to uniquely identify an operation.\n        \"\"\"\n    spec_operation_cls = self.specification.operation_cls\n    spec_operation = spec_operation_cls.from_spec(self.specification, path=path, method=method, resolver=self.resolver, uri_parser_class=self.uri_parser_class)\n    operation = self.make_operation(spec_operation)\n    path, name = self._framework_path_and_name(spec_operation, path)\n    self._add_operation_internal(method, path, operation, name=name)"
        }
      ]
    },
    {
      "name": "add_operation",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\abstract.py",
      "line_number": 196,
      "end_line_number": 206,
      "source_code": "def add_operation(self, path: str, method: str) -> None:\n        operation_spec_cls = self.specification.operation_cls\n        operation = operation_spec_cls.from_spec(\n            self.specification,\n            path=path,\n            method=method,\n            resolver=self.resolver,\n            uri_parser_class=self.uri_parser_class,\n        )\n        routed_operation = self.make_operation(operation)\n        self.operations[operation.operation_id] = routed_operation",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "path",
        "method"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "collections.defaultdict",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.exceptions.MissingMiddleware",
        "connexion.exceptions.ResolverError",
        "connexion.http_facts.METHODS",
        "connexion.operations.AbstractOperation",
        "connexion.resolver.Resolver",
        "connexion.spec.Specification"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "operation_spec_cls.from_spec",
          "body": "@classmethod\n@abc.abstractmethod\ndef from_spec(cls, spec, *args, path, method, resolver, **kwargs):\n    pass"
        },
        {
          "name": "self.make_operation",
          "body": "def make_operation(self, operation: AbstractOperation) -> AsyncOperation:\n    return AsyncOperation.from_operation(operation, pythonic_params=self.pythonic_params, jsonifier=self.jsonifier)"
        }
      ]
    },
    {
      "name": "make_operation",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\abstract.py",
      "line_number": 209,
      "end_line_number": 211,
      "source_code": "def make_operation(self, operation: AbstractOperation) -> OP:\n        \"\"\"Create an operation of the `operation_cls` type.\"\"\"\n        raise NotImplementedError",
      "docstring": "Create an operation of the `operation_cls` type.",
      "decorators": [
        "abc.abstractmethod"
      ],
      "arguments": [
        "self",
        "operation"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "collections.defaultdict",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.exceptions.MissingMiddleware",
        "connexion.exceptions.ResolverError",
        "connexion.http_facts.METHODS",
        "connexion.operations.AbstractOperation",
        "connexion.resolver.Resolver",
        "connexion.spec.Specification"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\abstract.py",
      "line_number": 230,
      "end_line_number": 232,
      "source_code": "def __init__(self, app: ASGIApp) -> None:\n        self.app = app\n        self.apis: t.Dict[str, t.List[API]] = defaultdict(list)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "app"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "collections.defaultdict",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.exceptions.MissingMiddleware",
        "connexion.exceptions.ResolverError",
        "connexion.http_facts.METHODS",
        "connexion.operations.AbstractOperation",
        "connexion.resolver.Resolver",
        "connexion.spec.Specification"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "add_api",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\abstract.py",
      "line_number": 234,
      "end_line_number": 237,
      "source_code": "def add_api(self, specification: Specification, **kwargs) -> API:\n        api = self.api_cls(specification, next_app=self.app, **kwargs)\n        self.apis[api.base_path].append(api)\n        return api",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "specification"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "collections.defaultdict",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.exceptions.MissingMiddleware",
        "connexion.exceptions.ResolverError",
        "connexion.http_facts.METHODS",
        "connexion.operations.AbstractOperation",
        "connexion.resolver.Resolver",
        "connexion.spec.Specification"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "context",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\context.py",
      "line_number": 11,
      "end_line_number": 18,
      "source_code": "def __init__(\n        self,\n        next_app: ASGIApp,\n        *,\n        operation: AbstractOperation,\n    ) -> None:\n        self.next_app = next_app\n        self.operation = operation",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "next_app"
      ],
      "imports": [
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.context._context",
        "connexion.context._operation",
        "connexion.context._receive",
        "connexion.context._scope",
        "connexion.middleware.abstract.RoutedAPI",
        "connexion.middleware.abstract.RoutedMiddleware",
        "connexion.operations.AbstractOperation"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "context",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\context.py",
      "line_number": 29,
      "end_line_number": 31,
      "source_code": "def __init__(self, *args, **kwargs) -> None:\n        super().__init__(*args, **kwargs)\n        self.add_paths()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.context._context",
        "connexion.context._operation",
        "connexion.context._receive",
        "connexion.context._scope",
        "connexion.middleware.abstract.RoutedAPI",
        "connexion.middleware.abstract.RoutedMiddleware",
        "connexion.operations.AbstractOperation"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.add_paths",
          "body": "def add_paths(self, paths: t.Optional[dict]=None) -> None:\n    \"\"\"\n        Adds the paths defined in the specification as operations.\n        \"\"\"\n    paths = t.cast(dict, paths or self.specification.get('paths', dict()))\n    for path, methods in paths.items():\n        logger.debug('Adding %s%s...', self.base_path, path)\n        for method in methods:\n            if method not in METHODS:\n                continue\n            try:\n                self.add_operation(path, method)\n            except ResolverError as err:\n                if self.resolver_error_handler is not None:\n                    self._add_resolver_error_handler(method, path, err)\n                else:\n                    self._handle_add_operation_error(path, method, err)\n            except Exception as e:\n                self._handle_add_operation_error(path, method, e)"
        }
      ]
    },
    {
      "name": "make_operation",
      "module": "context",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\context.py",
      "line_number": 33,
      "end_line_number": 34,
      "source_code": "def make_operation(self, operation: AbstractOperation) -> ContextOperation:\n        return ContextOperation(self.next_app, operation=operation)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "operation"
      ],
      "imports": [
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.context._context",
        "connexion.context._operation",
        "connexion.context._receive",
        "connexion.context._scope",
        "connexion.middleware.abstract.RoutedAPI",
        "connexion.middleware.abstract.RoutedMiddleware",
        "connexion.operations.AbstractOperation"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "connexion_wrapper",
      "module": "exceptions",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\exceptions.py",
      "line_number": 23,
      "end_line_number": 51,
      "source_code": "def connexion_wrapper(\n    handler: t.Callable[\n        [ConnexionRequest, Exception], MaybeAwaitable[ConnexionResponse]\n    ]\n) -> t.Callable[[StarletteRequest, Exception], t.Awaitable[StarletteResponse]]:\n    \"\"\"Wrapper that translates Starlette requests to Connexion requests before passing\n    them to the error handler, and translates the returned Connexion responses to\n    Starlette responses.\"\"\"\n\n    @functools.wraps(handler)\n    async def wrapper(request: StarletteRequest, exc: Exception) -> StarletteResponse:\n        request = ConnexionRequest.from_starlette_request(request)\n\n        if asyncio.iscoroutinefunction(handler):\n            response = await handler(request, exc)  # type: ignore\n        else:\n            response = await run_in_threadpool(handler, request, exc)\n\n        while asyncio.iscoroutine(response):\n            response = await response\n\n        return StarletteResponse(\n            content=response.body,\n            status_code=response.status_code,\n            media_type=response.mimetype,\n            headers=response.headers,\n        )\n\n    return wrapper",
      "docstring": "Wrapper that translates Starlette requests to Connexion requests before passing\nthem to the error handler, and translates the returned Connexion responses to\nStarlette responses.",
      "decorators": [],
      "arguments": [
        "handler"
      ],
      "imports": [
        "asyncio",
        "functools",
        "logging",
        "typing",
        "starlette.concurrency.run_in_threadpool",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.exceptions.ExceptionMiddleware",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.http_facts",
        "connexion.exceptions.InternalServerError",
        "connexion.exceptions.ProblemException",
        "connexion.exceptions.problem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.types.MaybeAwaitable"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "ConnexionRequest.from_starlette_request",
          "body": "@classmethod\ndef from_starlette_request(cls, request: StarletteRequest, uri_parser=None) -> 'ConnexionRequest':\n    self = cls.__new__(cls)\n    self._starlette_request = request\n    self.__init__(uri_parser=uri_parser)\n    return self"
        }
      ]
    },
    {
      "name": "__init__",
      "module": "exceptions",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\exceptions.py",
      "line_number": 58,
      "end_line_number": 61,
      "source_code": "def __init__(self, next_app: ASGIApp):\n        super().__init__(next_app)\n        self.add_exception_handler(ProblemException, self.problem_handler)  # type: ignore\n        self.add_exception_handler(Exception, self.common_error_handler)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "next_app"
      ],
      "imports": [
        "asyncio",
        "functools",
        "logging",
        "typing",
        "starlette.concurrency.run_in_threadpool",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.exceptions.ExceptionMiddleware",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.http_facts",
        "connexion.exceptions.InternalServerError",
        "connexion.exceptions.ProblemException",
        "connexion.exceptions.problem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.types.MaybeAwaitable"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.add_exception_handler",
          "body": "def add_exception_handler(self, exc_class_or_status_code: t.Union[int, t.Type[Exception]], handler: t.Callable[[ConnexionRequest, Exception], StarletteResponse]) -> None:\n    super().add_exception_handler(exc_class_or_status_code, handler=connexion_wrapper(handler))"
        },
        {
          "name": "self.add_exception_handler",
          "body": "def add_exception_handler(self, exc_class_or_status_code: t.Union[int, t.Type[Exception]], handler: t.Callable[[ConnexionRequest, Exception], StarletteResponse]) -> None:\n    super().add_exception_handler(exc_class_or_status_code, handler=connexion_wrapper(handler))"
        }
      ]
    },
    {
      "name": "add_exception_handler",
      "module": "exceptions",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\exceptions.py",
      "line_number": 63,
      "end_line_number": 70,
      "source_code": "def add_exception_handler(\n        self,\n        exc_class_or_status_code: t.Union[int, t.Type[Exception]],\n        handler: t.Callable[[ConnexionRequest, Exception], StarletteResponse],\n    ) -> None:\n        super().add_exception_handler(\n            exc_class_or_status_code, handler=connexion_wrapper(handler)\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "exc_class_or_status_code",
        "handler"
      ],
      "imports": [
        "asyncio",
        "functools",
        "logging",
        "typing",
        "starlette.concurrency.run_in_threadpool",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.exceptions.ExceptionMiddleware",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.http_facts",
        "connexion.exceptions.InternalServerError",
        "connexion.exceptions.ProblemException",
        "connexion.exceptions.problem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.types.MaybeAwaitable"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "connexion_wrapper",
          "body": "def connexion_wrapper(handler: t.Callable[[ConnexionRequest, Exception], MaybeAwaitable[ConnexionResponse]]) -> t.Callable[[StarletteRequest, Exception], t.Awaitable[StarletteResponse]]:\n    \"\"\"Wrapper that translates Starlette requests to Connexion requests before passing\n    them to the error handler, and translates the returned Connexion responses to\n    Starlette responses.\"\"\"\n\n    @functools.wraps(handler)\n    async def wrapper(request: StarletteRequest, exc: Exception) -> StarletteResponse:\n        request = ConnexionRequest.from_starlette_request(request)\n        if asyncio.iscoroutinefunction(handler):\n            response = await handler(request, exc)\n        else:\n            response = await run_in_threadpool(handler, request, exc)\n        while asyncio.iscoroutine(response):\n            response = await response\n        return StarletteResponse(content=response.body, status_code=response.status_code, media_type=response.mimetype, headers=response.headers)\n    return wrapper"
        }
      ]
    },
    {
      "name": "problem_handler",
      "module": "exceptions",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\exceptions.py",
      "line_number": 73,
      "end_line_number": 81,
      "source_code": "def problem_handler(_request: ConnexionRequest, exc: ProblemException):\n        \"\"\"Default handler for Connexion ProblemExceptions\"\"\"\n\n        if 400 <= exc.status <= 499:\n            logger.warning(\"%r\", exc)\n        else:\n            logger.error(\"%r\", exc)\n\n        return exc.to_problem()",
      "docstring": "Default handler for Connexion ProblemExceptions",
      "decorators": [
        "staticmethod"
      ],
      "arguments": [
        "_request",
        "exc"
      ],
      "imports": [
        "asyncio",
        "functools",
        "logging",
        "typing",
        "starlette.concurrency.run_in_threadpool",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.exceptions.ExceptionMiddleware",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.http_facts",
        "connexion.exceptions.InternalServerError",
        "connexion.exceptions.ProblemException",
        "connexion.exceptions.problem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.types.MaybeAwaitable"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exc.to_problem",
          "body": "def to_problem(self):\n    return problem(status=self.status, title=self.title, detail=self.detail, type=self.type, instance=self.instance, headers=self.headers, ext=self.ext)"
        }
      ]
    },
    {
      "name": "http_exception",
      "module": "exceptions",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\exceptions.py",
      "line_number": 85,
      "end_line_number": 100,
      "source_code": "def http_exception(\n        _request: StarletteRequest, exc: HTTPException, **kwargs\n    ) -> StarletteResponse:\n        \"\"\"Default handler for Starlette HTTPException\"\"\"\n\n        if 400 <= exc.status_code <= 499:\n            logger.warning(\"%r\", exc)\n        else:\n            logger.error(\"%r\", exc)\n\n        return problem(\n            title=http_facts.HTTP_STATUS_CODES.get(exc.status_code),\n            detail=exc.detail,\n            status=exc.status_code,\n            headers=exc.headers,\n        )",
      "docstring": "Default handler for Starlette HTTPException",
      "decorators": [
        "staticmethod",
        "connexion_wrapper"
      ],
      "arguments": [
        "_request",
        "exc"
      ],
      "imports": [
        "asyncio",
        "functools",
        "logging",
        "typing",
        "starlette.concurrency.run_in_threadpool",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.exceptions.ExceptionMiddleware",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.http_facts",
        "connexion.exceptions.InternalServerError",
        "connexion.exceptions.ProblemException",
        "connexion.exceptions.problem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.types.MaybeAwaitable"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "problem",
          "body": "def problem(status, title, detail, type=None, instance=None, headers=None, ext=None):\n    \"\"\"\n    Returns a `Problem Details <https://tools.ietf.org/html/draft-ietf-appsawg-http-problem-00>`_ error response.\n\n\n    :param status: The HTTP status code generated by the origin server for this occurrence of the problem.\n    :type status: int\n    :param title: A short, human-readable summary of the problem type.  It SHOULD NOT change from occurrence to\n                  occurrence of the problem, except for purposes of localisation.\n    :type title: str\n    :param detail: An human readable explanation specific to this occurrence of the problem.\n    :type detail: str\n    :param type: An absolute URI that identifies the problem type.  When dereferenced, it SHOULD provide human-readable\n                 documentation for the problem type (e.g., using HTML).  When this member is not present its value is\n                 assumed to be \"about:blank\".\n    :type: type: str\n    :param instance: An absolute URI that identifies the specific occurrence of the problem.  It may or may not yield\n                     further information if dereferenced.\n    :type instance: str\n    :param headers: HTTP headers to include in the response\n    :type headers: dict | None\n    :param ext: Extension members to include in the body\n    :type ext: dict | None\n    :return: error response\n    :rtype: ConnexionResponse\n    \"\"\"\n    from .lifecycle import ConnexionResponse\n    if not type:\n        type = 'about:blank'\n    problem_response = {'type': type, 'title': title, 'detail': detail, 'status': status}\n    if instance:\n        problem_response['instance'] = instance\n    if ext:\n        problem_response.update(ext)\n    mimetype = content_type = 'application/problem+json'\n    return ConnexionResponse(status, mimetype, content_type, body=json.dumps(problem_response), headers=headers)"
        },
        {
          "name": "http_facts.HTTP_STATUS_CODES.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "common_error_handler",
      "module": "exceptions",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\exceptions.py",
      "line_number": 103,
      "end_line_number": 108,
      "source_code": "def common_error_handler(\n        _request: StarletteRequest, exc: Exception\n    ) -> ConnexionResponse:\n        \"\"\"Default handler for any unhandled Exception\"\"\"\n        logger.error(\"%r\", exc, exc_info=exc)\n        return InternalServerError().to_problem()",
      "docstring": "Default handler for any unhandled Exception",
      "decorators": [
        "staticmethod"
      ],
      "arguments": [
        "_request",
        "exc"
      ],
      "imports": [
        "asyncio",
        "functools",
        "logging",
        "typing",
        "starlette.concurrency.run_in_threadpool",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.exceptions.ExceptionMiddleware",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.http_facts",
        "connexion.exceptions.InternalServerError",
        "connexion.exceptions.ProblemException",
        "connexion.exceptions.problem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.types.MaybeAwaitable"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "lifespan",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\lifespan.py",
      "line_number": 15,
      "end_line_number": 19,
      "source_code": "def __init__(self, next_app: ASGIApp, *, lifespan: t.Optional[Lifespan]) -> None:\n        self.next_app = next_app\n        self._lifespan = lifespan\n        # Leverage a Starlette Router for lifespan handling only\n        self.router = Router(lifespan=lifespan)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "next_app"
      ],
      "imports": [
        "typing",
        "starlette.routing.Router",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__post_init__",
      "module": "main",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\main.py",
      "line_number": 65,
      "end_line_number": 69,
      "source_code": "def __post_init__(self):\n        self.resolver = (\n            Resolver(self.resolver) if callable(self.resolver) else self.resolver\n        )\n        self.resolver_error_handler = self._resolver_error_handler_factory()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "copy",
        "dataclasses",
        "enum",
        "logging",
        "pathlib",
        "typing",
        "dataclasses.dataclass",
        "dataclasses.field",
        "functools.partial",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.utils",
        "connexion.handlers.ResolverErrorHandler",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.SpecMiddleware",
        "connexion.middleware.context.ContextMiddleware",
        "connexion.middleware.exceptions.ExceptionMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.middleware.lifespan.LifespanMiddleware",
        "connexion.middleware.request_validation.RequestValidationMiddleware",
        "connexion.middleware.response_validation.ResponseValidationMiddleware",
        "connexion.middleware.routing.RoutingMiddleware",
        "connexion.middleware.security.SecurityMiddleware",
        "connexion.middleware.server_error.ServerErrorMiddleware",
        "connexion.middleware.swagger_ui.SwaggerUIMiddleware",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.spec.Specification",
        "connexion.types.MaybeAwaitable",
        "connexion.uri_parsing.AbstractURIParser",
        "connexion.utils.inspect_function_arguments",
        "uvicorn"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._resolver_error_handler_factory",
          "body": "def _resolver_error_handler_factory(self) -> t.Optional[t.Callable[[], ResolverErrorHandler]]:\n    \"\"\"Returns a factory to create a ResolverErrorHandler.\"\"\"\n    if self.resolver_error is not None:\n\n        def resolver_error_handler(*args, **kwargs) -> ResolverErrorHandler:\n            return ResolverErrorHandler(self.resolver_error, *args, **kwargs)\n        return resolver_error_handler\n    return None"
        }
      ]
    },
    {
      "name": "_resolver_error_handler_factory",
      "module": "main",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\main.py",
      "line_number": 71,
      "end_line_number": 81,
      "source_code": "def _resolver_error_handler_factory(\n        self,\n    ) -> t.Optional[t.Callable[[], ResolverErrorHandler]]:\n        \"\"\"Returns a factory to create a ResolverErrorHandler.\"\"\"\n        if self.resolver_error is not None:\n\n            def resolver_error_handler(*args, **kwargs) -> ResolverErrorHandler:\n                return ResolverErrorHandler(self.resolver_error, *args, **kwargs)\n\n            return resolver_error_handler\n        return None",
      "docstring": "Returns a factory to create a ResolverErrorHandler.",
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "copy",
        "dataclasses",
        "enum",
        "logging",
        "pathlib",
        "typing",
        "dataclasses.dataclass",
        "dataclasses.field",
        "functools.partial",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.utils",
        "connexion.handlers.ResolverErrorHandler",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.SpecMiddleware",
        "connexion.middleware.context.ContextMiddleware",
        "connexion.middleware.exceptions.ExceptionMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.middleware.lifespan.LifespanMiddleware",
        "connexion.middleware.request_validation.RequestValidationMiddleware",
        "connexion.middleware.response_validation.ResponseValidationMiddleware",
        "connexion.middleware.routing.RoutingMiddleware",
        "connexion.middleware.security.SecurityMiddleware",
        "connexion.middleware.server_error.ServerErrorMiddleware",
        "connexion.middleware.swagger_ui.SwaggerUIMiddleware",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.spec.Specification",
        "connexion.types.MaybeAwaitable",
        "connexion.uri_parsing.AbstractURIParser",
        "connexion.utils.inspect_function_arguments",
        "uvicorn"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "replace",
      "module": "main",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\main.py",
      "line_number": 83,
      "end_line_number": 91,
      "source_code": "def replace(self, **changes) -> \"_Options\":\n        \"\"\"Update mechanism to overwrite the options. None values are discarded.\n\n        :param changes: Arguments accepted by the __init__ method of this class.\n\n        :return: An new _Options object with updated arguments.\n        \"\"\"\n        changes = {key: value for key, value in changes.items() if value is not None}\n        return dataclasses.replace(self, **changes)",
      "docstring": "Update mechanism to overwrite the options. None values are discarded.\n\n:param changes: Arguments accepted by the __init__ method of this class.\n\n:return: An new _Options object with updated arguments.",
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "copy",
        "dataclasses",
        "enum",
        "logging",
        "pathlib",
        "typing",
        "dataclasses.dataclass",
        "dataclasses.field",
        "functools.partial",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.utils",
        "connexion.handlers.ResolverErrorHandler",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.SpecMiddleware",
        "connexion.middleware.context.ContextMiddleware",
        "connexion.middleware.exceptions.ExceptionMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.middleware.lifespan.LifespanMiddleware",
        "connexion.middleware.request_validation.RequestValidationMiddleware",
        "connexion.middleware.response_validation.ResponseValidationMiddleware",
        "connexion.middleware.routing.RoutingMiddleware",
        "connexion.middleware.security.SecurityMiddleware",
        "connexion.middleware.server_error.ServerErrorMiddleware",
        "connexion.middleware.swagger_ui.SwaggerUIMiddleware",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.spec.Specification",
        "connexion.types.MaybeAwaitable",
        "connexion.uri_parsing.AbstractURIParser",
        "connexion.utils.inspect_function_arguments",
        "uvicorn"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "main",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\main.py",
      "line_number": 173,
      "end_line_number": 176,
      "source_code": "def __init__(self, specification, *, base_path, **kwargs) -> None:\n        self.specification = specification\n        self.base_path = base_path\n        self.kwargs = kwargs",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "specification"
      ],
      "imports": [
        "copy",
        "dataclasses",
        "enum",
        "logging",
        "pathlib",
        "typing",
        "dataclasses.dataclass",
        "dataclasses.field",
        "functools.partial",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.utils",
        "connexion.handlers.ResolverErrorHandler",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.SpecMiddleware",
        "connexion.middleware.context.ContextMiddleware",
        "connexion.middleware.exceptions.ExceptionMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.middleware.lifespan.LifespanMiddleware",
        "connexion.middleware.request_validation.RequestValidationMiddleware",
        "connexion.middleware.response_validation.ResponseValidationMiddleware",
        "connexion.middleware.routing.RoutingMiddleware",
        "connexion.middleware.security.SecurityMiddleware",
        "connexion.middleware.server_error.ServerErrorMiddleware",
        "connexion.middleware.swagger_ui.SwaggerUIMiddleware",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.spec.Specification",
        "connexion.types.MaybeAwaitable",
        "connexion.uri_parsing.AbstractURIParser",
        "connexion.utils.inspect_function_arguments",
        "uvicorn"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "main",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\main.py",
      "line_number": 195,
      "end_line_number": 282,
      "source_code": "def __init__(\n        self,\n        app: ASGIApp,\n        *,\n        import_name: t.Optional[str] = None,\n        lifespan: t.Optional[Lifespan] = None,\n        middlewares: t.Optional[t.List[ASGIApp]] = None,\n        specification_dir: t.Union[pathlib.Path, str] = \"\",\n        arguments: t.Optional[dict] = None,\n        auth_all_paths: t.Optional[bool] = None,\n        jsonifier: t.Optional[Jsonifier] = None,\n        pythonic_params: t.Optional[bool] = None,\n        resolver: t.Optional[t.Union[Resolver, t.Callable]] = None,\n        resolver_error: t.Optional[int] = None,\n        strict_validation: t.Optional[bool] = None,\n        swagger_ui_options: t.Optional[SwaggerUIOptions] = None,\n        uri_parser_class: t.Optional[AbstractURIParser] = None,\n        validate_responses: t.Optional[bool] = None,\n        validator_map: t.Optional[dict] = None,\n        security_map: t.Optional[dict] = None,\n    ):\n        \"\"\"\n        :param import_name: The name of the package or module that this object belongs to. If you\n            are using a single module, __name__ is always the correct value. If you however are\n            using a package, it\u2019s usually recommended to hardcode the name of your package there.\n        :param middlewares: The list of middlewares to wrap around the application. Defaults to\n            :obj:`middleware.main.ConnexionmMiddleware.default_middlewares`\n        :param specification_dir: The directory holding the specification(s). The provided path\n            should either be absolute or relative to the root path of the application. Defaults to\n            the root path.\n        :param arguments: Arguments to substitute the specification using Jinja.\n        :param auth_all_paths: whether to authenticate not paths not defined in the specification.\n            Defaults to False.\n        :param jsonifier: Custom jsonifier to overwrite json encoding for json responses.\n        :param pythonic_params: When True, CamelCase parameters are converted to snake_case and an\n            underscore is appended to any shadowed built-ins. Defaults to False.\n        :param resolver: Callable that maps operationId to a function or instance of\n            :class:`resolver.Resolver`.\n        :param resolver_error: Error code to return for operations for which the operationId could\n            not be resolved. If no error code is provided, the application will fail when trying to\n            start.\n        :param strict_validation: When True, extra form or query parameters not defined in the\n            specification result in a validation error. Defaults to False.\n        :param swagger_ui_options: Instance of :class:`options.SwaggerUIOptions` with\n            configuration options for the swagger ui.\n        :param uri_parser_class: Class to use for uri parsing. See :mod:`uri_parsing`.\n        :param validate_responses: Whether to validate responses against the specification. This has\n            an impact on performance. Defaults to False.\n        :param validator_map: A dictionary of validators to use. Defaults to\n            :obj:`validators.VALIDATOR_MAP`.\n        :param security_map: A dictionary of security handlers to use. Defaults to\n            :obj:`security.SECURITY_HANDLERS`.\n        \"\"\"\n        import_name = import_name or str(pathlib.Path.cwd())\n        self.root_path = utils.get_root_path(import_name)\n\n        spec_dir = pathlib.Path(specification_dir)\n        self.specification_dir = (\n            spec_dir if spec_dir.is_absolute() else self.root_path / spec_dir\n        )\n\n        self.app = app\n        self.lifespan = lifespan\n        self.middlewares = (\n            middlewares\n            if middlewares is not None\n            else copy.copy(self.default_middlewares)\n        )\n        self.middleware_stack: t.Optional[t.Iterable[ASGIApp]] = None\n        self.apis: t.List[API] = []\n        self.error_handlers: t.List[tuple] = []\n\n        self.options = _Options(\n            arguments=arguments,\n            auth_all_paths=auth_all_paths,\n            jsonifier=jsonifier,\n            pythonic_params=pythonic_params,\n            resolver=resolver,\n            resolver_error=resolver_error,\n            strict_validation=strict_validation,\n            swagger_ui_options=swagger_ui_options,\n            uri_parser_class=uri_parser_class,\n            validate_responses=validate_responses,\n            validator_map=validator_map,\n            security_map=security_map,\n        )\n\n        self.extra_files: t.List[str] = []",
      "docstring": ":param import_name: The name of the package or module that this object belongs to. If you\n    are using a single module, __name__ is always the correct value. If you however are\n    using a package, it\u2019s usually recommended to hardcode the name of your package there.\n:param middlewares: The list of middlewares to wrap around the application. Defaults to\n    :obj:`middleware.main.ConnexionmMiddleware.default_middlewares`\n:param specification_dir: The directory holding the specification(s). The provided path\n    should either be absolute or relative to the root path of the application. Defaults to\n    the root path.\n:param arguments: Arguments to substitute the specification using Jinja.\n:param auth_all_paths: whether to authenticate not paths not defined in the specification.\n    Defaults to False.\n:param jsonifier: Custom jsonifier to overwrite json encoding for json responses.\n:param pythonic_params: When True, CamelCase parameters are converted to snake_case and an\n    underscore is appended to any shadowed built-ins. Defaults to False.\n:param resolver: Callable that maps operationId to a function or instance of\n    :class:`resolver.Resolver`.\n:param resolver_error: Error code to return for operations for which the operationId could\n    not be resolved. If no error code is provided, the application will fail when trying to\n    start.\n:param strict_validation: When True, extra form or query parameters not defined in the\n    specification result in a validation error. Defaults to False.\n:param swagger_ui_options: Instance of :class:`options.SwaggerUIOptions` with\n    configuration options for the swagger ui.\n:param uri_parser_class: Class to use for uri parsing. See :mod:`uri_parsing`.\n:param validate_responses: Whether to validate responses against the specification. This has\n    an impact on performance. Defaults to False.\n:param validator_map: A dictionary of validators to use. Defaults to\n    :obj:`validators.VALIDATOR_MAP`.\n:param security_map: A dictionary of security handlers to use. Defaults to\n    :obj:`security.SECURITY_HANDLERS`.",
      "decorators": [],
      "arguments": [
        "self",
        "app"
      ],
      "imports": [
        "copy",
        "dataclasses",
        "enum",
        "logging",
        "pathlib",
        "typing",
        "dataclasses.dataclass",
        "dataclasses.field",
        "functools.partial",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.utils",
        "connexion.handlers.ResolverErrorHandler",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.SpecMiddleware",
        "connexion.middleware.context.ContextMiddleware",
        "connexion.middleware.exceptions.ExceptionMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.middleware.lifespan.LifespanMiddleware",
        "connexion.middleware.request_validation.RequestValidationMiddleware",
        "connexion.middleware.response_validation.ResponseValidationMiddleware",
        "connexion.middleware.routing.RoutingMiddleware",
        "connexion.middleware.security.SecurityMiddleware",
        "connexion.middleware.server_error.ServerErrorMiddleware",
        "connexion.middleware.swagger_ui.SwaggerUIMiddleware",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.spec.Specification",
        "connexion.types.MaybeAwaitable",
        "connexion.uri_parsing.AbstractURIParser",
        "connexion.utils.inspect_function_arguments",
        "uvicorn"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "utils.get_root_path",
          "body": "def get_root_path(import_name: str) -> str:\n    \"\"\"Copied from Flask:\n    https://github.com/pallets/flask/blob/836866dc19218832cf02f8b04911060ac92bfc0b/src/flask/helpers.py#L595\n\n    Find the root path of a package, or the path that contains a\n    module. If it cannot be found, returns the current working\n    directory.\n    \"\"\"\n    mod = sys.modules.get(import_name)\n    if mod is not None and hasattr(mod, '__file__') and (mod.__file__ is not None):\n        return os.path.dirname(os.path.abspath(mod.__file__))\n    loader = pkgutil.get_loader(import_name)\n    if loader is None or import_name == '__main__':\n        return os.getcwd()\n    if hasattr(loader, 'get_filename'):\n        filepath = loader.get_filename(import_name)\n    else:\n        __import__(import_name)\n        mod = sys.modules[import_name]\n        filepath = getattr(mod, '__file__', None)\n        if filepath is None:\n            raise RuntimeError(f\"No root path can be found for the provided module {import_name!r}. This can happen because the module came from an import hook that does not provide file name information or because it's a namespace package. In this case the root path needs to be explicitly provided.\")\n    return os.path.dirname(os.path.abspath(filepath))"
        }
      ]
    },
    {
      "name": "add_middleware",
      "module": "main",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\main.py",
      "line_number": 284,
      "end_line_number": 313,
      "source_code": "def add_middleware(\n        self,\n        middleware_class: t.Type[ASGIApp],\n        *,\n        position: MiddlewarePosition = MiddlewarePosition.BEFORE_CONTEXT,\n        **options: t.Any,\n    ) -> None:\n        \"\"\"Add a middleware to the stack on the specified position.\n\n        :param middleware_class: Middleware class to add\n        :param position: Position to add the middleware, one of the MiddlewarePosition Enum\n        :param options: Options to pass to the middleware_class on initialization\n        \"\"\"\n        if self.middleware_stack is not None:\n            raise RuntimeError(\"Cannot add middleware after an application has started\")\n\n        for m, middleware in enumerate(self.middlewares):\n            if isinstance(middleware, partial):\n                middleware = middleware.func\n\n            if middleware == position.value:\n                self.middlewares.insert(\n                    m, t.cast(ASGIApp, partial(middleware_class, **options))\n                )\n                break\n        else:\n            raise ValueError(\n                f\"Could not insert middleware at position {position.name}. \"\n                f\"Please make sure you have a {position.value} in your stack.\"\n            )",
      "docstring": "Add a middleware to the stack on the specified position.\n\n:param middleware_class: Middleware class to add\n:param position: Position to add the middleware, one of the MiddlewarePosition Enum\n:param options: Options to pass to the middleware_class on initialization",
      "decorators": [],
      "arguments": [
        "self",
        "middleware_class"
      ],
      "imports": [
        "copy",
        "dataclasses",
        "enum",
        "logging",
        "pathlib",
        "typing",
        "dataclasses.dataclass",
        "dataclasses.field",
        "functools.partial",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.utils",
        "connexion.handlers.ResolverErrorHandler",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.SpecMiddleware",
        "connexion.middleware.context.ContextMiddleware",
        "connexion.middleware.exceptions.ExceptionMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.middleware.lifespan.LifespanMiddleware",
        "connexion.middleware.request_validation.RequestValidationMiddleware",
        "connexion.middleware.response_validation.ResponseValidationMiddleware",
        "connexion.middleware.routing.RoutingMiddleware",
        "connexion.middleware.security.SecurityMiddleware",
        "connexion.middleware.server_error.ServerErrorMiddleware",
        "connexion.middleware.swagger_ui.SwaggerUIMiddleware",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.spec.Specification",
        "connexion.types.MaybeAwaitable",
        "connexion.uri_parsing.AbstractURIParser",
        "connexion.utils.inspect_function_arguments",
        "uvicorn"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_build_middleware_stack",
      "module": "main",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\main.py",
      "line_number": 315,
      "end_line_number": 348,
      "source_code": "def _build_middleware_stack(self) -> t.Tuple[ASGIApp, t.Iterable[ASGIApp]]:\n        \"\"\"Apply all middlewares to the provided app.\n\n        :return: Tuple of the outer middleware wrapping the application and a list of the wrapped\n            middlewares, including the wrapped application.\n        \"\"\"\n        # Include the wrapped application in the returned list.\n        app = self.app\n        apps = [app]\n        for middleware in reversed(self.middlewares):\n            arguments, _ = inspect_function_arguments(middleware)\n            if \"lifespan\" in arguments:\n                app = middleware(app, lifespan=self.lifespan)  # type: ignore\n            else:\n                app = middleware(app)  # type: ignore\n            apps.append(app)\n\n        # We sort the APIs by base path so that the most specific APIs are registered first.\n        # This is due to the way Starlette matches routes.\n        self.apis = utils.sort_apis_by_basepath(self.apis)\n        for app in apps:\n            if isinstance(app, SpecMiddleware):\n                for api in self.apis:\n                    app.add_api(\n                        api.specification,\n                        base_path=api.base_path,\n                        **api.kwargs,\n                    )\n\n            if isinstance(app, ExceptionMiddleware):\n                for error_handler in self.error_handlers:\n                    app.add_exception_handler(*error_handler)\n\n        return app, list(reversed(apps))",
      "docstring": "Apply all middlewares to the provided app.\n\n:return: Tuple of the outer middleware wrapping the application and a list of the wrapped\n    middlewares, including the wrapped application.",
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "copy",
        "dataclasses",
        "enum",
        "logging",
        "pathlib",
        "typing",
        "dataclasses.dataclass",
        "dataclasses.field",
        "functools.partial",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.utils",
        "connexion.handlers.ResolverErrorHandler",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.SpecMiddleware",
        "connexion.middleware.context.ContextMiddleware",
        "connexion.middleware.exceptions.ExceptionMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.middleware.lifespan.LifespanMiddleware",
        "connexion.middleware.request_validation.RequestValidationMiddleware",
        "connexion.middleware.response_validation.ResponseValidationMiddleware",
        "connexion.middleware.routing.RoutingMiddleware",
        "connexion.middleware.security.SecurityMiddleware",
        "connexion.middleware.server_error.ServerErrorMiddleware",
        "connexion.middleware.swagger_ui.SwaggerUIMiddleware",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.spec.Specification",
        "connexion.types.MaybeAwaitable",
        "connexion.uri_parsing.AbstractURIParser",
        "connexion.utils.inspect_function_arguments",
        "uvicorn"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "utils.sort_apis_by_basepath",
          "body": "def sort_apis_by_basepath(apis: t.List['API']) -> t.List['API']:\n    \"\"\"Sorts a list of APIs by basepath.\n\n    :param apis: List of APIs to sort\n\n    :return: List of APIs sorted by basepath\n    \"\"\"\n    return sort_routes(apis, key=lambda api: api.base_path or '/')"
        },
        {
          "name": "inspect_function_arguments",
          "body": "def inspect_function_arguments(function: t.Callable) -> t.Tuple[t.List[str], bool]:\n    \"\"\"\n    Returns the list of variables names of a function and if it\n    accepts keyword arguments.\n    \"\"\"\n    parameters = inspect.signature(function).parameters\n    bound_arguments = [name for name, p in parameters.items() if p.kind not in (p.VAR_POSITIONAL, p.VAR_KEYWORD)]\n    has_kwargs = any((p.kind == p.VAR_KEYWORD for p in parameters.values()))\n    return (list(bound_arguments), has_kwargs)"
        },
        {
          "name": "app.add_api",
          "body": "def add_api(self, specification: t.Union[pathlib.Path, str, dict], *, base_path: t.Optional[str]=None, name: t.Optional[str]=None, arguments: t.Optional[dict]=None, auth_all_paths: t.Optional[bool]=None, jsonifier: t.Optional[Jsonifier]=None, pythonic_params: t.Optional[bool]=None, resolver: t.Optional[t.Union[Resolver, t.Callable]]=None, resolver_error: t.Optional[int]=None, strict_validation: t.Optional[bool]=None, swagger_ui_options: t.Optional[SwaggerUIOptions]=None, uri_parser_class: t.Optional[AbstractURIParser]=None, validate_responses: t.Optional[bool]=None, validator_map: t.Optional[dict]=None, security_map: t.Optional[dict]=None, **kwargs) -> t.Any:\n    \"\"\"\n        Register an API represented by a single OpenAPI specification on this application.\n        Multiple APIs can be registered on a single application.\n\n        :param specification: OpenAPI specification. Can be provided either as dict, a path\n            to file, or a URL.\n        :param base_path: Base path to host the API. This overrides the basePath / servers in the\n            specification.\n        :param name: Name to register the API with. If no name is passed, the base_path is used\n            as name instead.\n        :param arguments: Arguments to substitute the specification using Jinja.\n        :param auth_all_paths: whether to authenticate not paths not defined in the specification.\n            Defaults to False.\n        :param jsonifier: Custom jsonifier to overwrite json encoding for json responses.\n        :param pythonic_params: When True, CamelCase parameters are converted to snake_case and an\n            underscore is appended to any shadowed built-ins. Defaults to False.\n        :param resolver: Callable that maps operationId to a function or instance of\n            :class:`resolver.Resolver`.\n        :param resolver_error: Error code to return for operations for which the operationId could\n            not be resolved. If no error code is provided, the application will fail when trying to\n            start.\n        :param strict_validation: When True, extra form or query parameters not defined in the\n            specification result in a validation error. Defaults to False.\n        :param swagger_ui_options: A :class:`options.SwaggerUIOptions` instance with configuration\n            options for the swagger ui.\n        :param uri_parser_class: Class to use for uri parsing. See :mod:`uri_parsing`.\n        :param validate_responses: Whether to validate responses against the specification. This has\n            an impact on performance. Defaults to False.\n        :param validator_map: A dictionary of validators to use. Defaults to\n            :obj:`validators.VALIDATOR_MAP`\n        :param security_map: A dictionary of security handlers to use. Defaults to\n            :obj:`security.SECURITY_HANDLERS`\n        :param kwargs: Additional keyword arguments to pass to the `add_api` method of the managed\n            middlewares. This can be used to pass arguments to middlewares added beyond the default\n            ones.\n\n        :return: The Api registered on the middleware application wrapping the framework.\n        \"\"\"\n    return self.middleware.add_api(specification, base_path=base_path, name=name, arguments=arguments, auth_all_paths=auth_all_paths, jsonifier=jsonifier, pythonic_params=pythonic_params, resolver=resolver, resolver_error=resolver_error, strict_validation=strict_validation, swagger_ui_options=swagger_ui_options, uri_parser_class=uri_parser_class, validate_responses=validate_responses, validator_map=validator_map, security_map=security_map, **kwargs)"
        },
        {
          "name": "app.add_exception_handler",
          "body": "def add_exception_handler(self, exc_class_or_status_code: t.Union[int, t.Type[Exception]], handler: t.Callable[[ConnexionRequest, Exception], StarletteResponse]) -> None:\n    super().add_exception_handler(exc_class_or_status_code, handler=connexion_wrapper(handler))"
        }
      ]
    },
    {
      "name": "add_api",
      "module": "main",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\main.py",
      "line_number": 350,
      "end_line_number": 443,
      "source_code": "def add_api(\n        self,\n        specification: t.Union[pathlib.Path, str, dict],\n        *,\n        base_path: t.Optional[str] = None,\n        name: t.Optional[str] = None,\n        arguments: t.Optional[dict] = None,\n        auth_all_paths: t.Optional[bool] = None,\n        jsonifier: t.Optional[Jsonifier] = None,\n        pythonic_params: t.Optional[bool] = None,\n        resolver: t.Optional[t.Union[Resolver, t.Callable]] = None,\n        resolver_error: t.Optional[int] = None,\n        strict_validation: t.Optional[bool] = None,\n        swagger_ui_options: t.Optional[SwaggerUIOptions] = None,\n        uri_parser_class: t.Optional[AbstractURIParser] = None,\n        validate_responses: t.Optional[bool] = None,\n        validator_map: t.Optional[dict] = None,\n        security_map: t.Optional[dict] = None,\n        **kwargs,\n    ) -> None:\n        \"\"\"\n        Register een API represented by a single OpenAPI specification on this middleware.\n        Multiple APIs can be registered on a single middleware.\n\n        :param specification: OpenAPI specification. Can be provided either as dict, a path\n            to file, or a URL.\n        :param base_path: Base path to host the API. This overrides the basePath / servers in the\n            specification.\n        :param name: Name to register the API with. If no name is passed, the base_path is used\n            as name instead.\n        :param arguments: Arguments to substitute the specification using Jinja.\n        :param auth_all_paths: whether to authenticate not paths not defined in the specification.\n            Defaults to False.\n        :param jsonifier: Custom jsonifier to overwrite json encoding for json responses.\n        :param pythonic_params: When True, CamelCase parameters are converted to snake_case and an\n            underscore is appended to any shadowed built-ins. Defaults to False.\n        :param resolver: Callable that maps operationId to a function or instance of\n            :class:`resolver.Resolver`.\n        :param resolver_error: Error code to return for operations for which the operationId could\n            not be resolved. If no error code is provided, the application will fail when trying to\n            start.\n        :param strict_validation: When True, extra form or query parameters not defined in the\n            specification result in a validation error. Defaults to False.\n        :param swagger_ui_options: A dict with configuration options for the swagger ui. See\n            :class:`options.SwaggerUIOptions`.\n        :param uri_parser_class: Class to use for uri parsing. See :mod:`uri_parsing`.\n        :param validate_responses: Whether to validate responses against the specification. This has\n            an impact on performance. Defaults to False.\n        :param validator_map: A dictionary of validators to use. Defaults to\n            :obj:`validators.VALIDATOR_MAP`\n        :param security_map: A dictionary of security handlers to use. Defaults to\n            :obj:`security.SECURITY_HANDLERS`\n        :param kwargs: Additional keyword arguments to pass to the `add_api` method of the managed\n            middlewares. This can be used to pass arguments to middlewares added beyond the default\n            ones.\n\n        :return: The Api registered on the wrapped application.\n        \"\"\"\n        if self.middleware_stack is not None:\n            raise RuntimeError(\"Cannot add api after an application has started\")\n\n        if isinstance(specification, str) and (\n            specification.startswith(\"http://\") or specification.startswith(\"https://\")\n        ):\n            pass\n        elif isinstance(specification, (pathlib.Path, str)):\n            specification = t.cast(pathlib.Path, self.specification_dir / specification)\n\n            # Add specification as file to watch for reloading\n            if pathlib.Path.cwd() in specification.parents:\n                self.extra_files.append(\n                    str(specification.relative_to(pathlib.Path.cwd()))\n                )\n\n        specification = Specification.load(specification, arguments=arguments)\n\n        options = self.options.replace(\n            auth_all_paths=auth_all_paths,\n            jsonifier=jsonifier,\n            swagger_ui_options=swagger_ui_options,\n            pythonic_params=pythonic_params,\n            resolver=resolver,\n            resolver_error=resolver_error,\n            strict_validation=strict_validation,\n            uri_parser_class=uri_parser_class,\n            validate_responses=validate_responses,\n            validator_map=validator_map,\n            security_map=security_map,\n        )\n\n        api = API(\n            specification, base_path=base_path, name=name, **options.__dict__, **kwargs\n        )\n        self.apis.append(api)",
      "docstring": "Register een API represented by a single OpenAPI specification on this middleware.\nMultiple APIs can be registered on a single middleware.\n\n:param specification: OpenAPI specification. Can be provided either as dict, a path\n    to file, or a URL.\n:param base_path: Base path to host the API. This overrides the basePath / servers in the\n    specification.\n:param name: Name to register the API with. If no name is passed, the base_path is used\n    as name instead.\n:param arguments: Arguments to substitute the specification using Jinja.\n:param auth_all_paths: whether to authenticate not paths not defined in the specification.\n    Defaults to False.\n:param jsonifier: Custom jsonifier to overwrite json encoding for json responses.\n:param pythonic_params: When True, CamelCase parameters are converted to snake_case and an\n    underscore is appended to any shadowed built-ins. Defaults to False.\n:param resolver: Callable that maps operationId to a function or instance of\n    :class:`resolver.Resolver`.\n:param resolver_error: Error code to return for operations for which the operationId could\n    not be resolved. If no error code is provided, the application will fail when trying to\n    start.\n:param strict_validation: When True, extra form or query parameters not defined in the\n    specification result in a validation error. Defaults to False.\n:param swagger_ui_options: A dict with configuration options for the swagger ui. See\n    :class:`options.SwaggerUIOptions`.\n:param uri_parser_class: Class to use for uri parsing. See :mod:`uri_parsing`.\n:param validate_responses: Whether to validate responses against the specification. This has\n    an impact on performance. Defaults to False.\n:param validator_map: A dictionary of validators to use. Defaults to\n    :obj:`validators.VALIDATOR_MAP`\n:param security_map: A dictionary of security handlers to use. Defaults to\n    :obj:`security.SECURITY_HANDLERS`\n:param kwargs: Additional keyword arguments to pass to the `add_api` method of the managed\n    middlewares. This can be used to pass arguments to middlewares added beyond the default\n    ones.\n\n:return: The Api registered on the wrapped application.",
      "decorators": [],
      "arguments": [
        "self",
        "specification"
      ],
      "imports": [
        "copy",
        "dataclasses",
        "enum",
        "logging",
        "pathlib",
        "typing",
        "dataclasses.dataclass",
        "dataclasses.field",
        "functools.partial",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.utils",
        "connexion.handlers.ResolverErrorHandler",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.SpecMiddleware",
        "connexion.middleware.context.ContextMiddleware",
        "connexion.middleware.exceptions.ExceptionMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.middleware.lifespan.LifespanMiddleware",
        "connexion.middleware.request_validation.RequestValidationMiddleware",
        "connexion.middleware.response_validation.ResponseValidationMiddleware",
        "connexion.middleware.routing.RoutingMiddleware",
        "connexion.middleware.security.SecurityMiddleware",
        "connexion.middleware.server_error.ServerErrorMiddleware",
        "connexion.middleware.swagger_ui.SwaggerUIMiddleware",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.spec.Specification",
        "connexion.types.MaybeAwaitable",
        "connexion.uri_parsing.AbstractURIParser",
        "connexion.utils.inspect_function_arguments",
        "uvicorn"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "Specification.load",
          "body": "@classmethod\ndef load(cls, spec, *, arguments=None):\n    if isinstance(spec, str) and (spec.startswith('http://') or spec.startswith('https://')):\n        return cls.from_url(spec)\n    if not isinstance(spec, dict):\n        base_uri = f'{pathlib.Path(spec).parent}{os.sep}'\n        return cls.from_file(spec, arguments=arguments, base_uri=base_uri)\n    return cls.from_dict(spec)"
        },
        {
          "name": "self.options.replace",
          "body": "def replace(self, **changes) -> '_Options':\n    \"\"\"Update mechanism to overwrite the options. None values are discarded.\n\n        :param changes: Arguments accepted by the __init__ method of this class.\n\n        :return: An new _Options object with updated arguments.\n        \"\"\"\n    changes = {key: value for key, value in changes.items() if value is not None}\n    return dataclasses.replace(self, **changes)"
        }
      ]
    },
    {
      "name": "add_error_handler",
      "module": "main",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\main.py",
      "line_number": 445,
      "end_line_number": 465,
      "source_code": "def add_error_handler(\n        self,\n        code_or_exception: t.Union[int, t.Type[Exception]],\n        function: t.Callable[\n            [ConnexionRequest, Exception], MaybeAwaitable[ConnexionResponse]\n        ],\n    ) -> None:\n        \"\"\"\n        Register a callable to handle application errors.\n\n        :param code_or_exception: An exception class or the status code of HTTP exceptions to\n            handle.\n        :param function: Callable that will handle exception, may be async.\n        \"\"\"\n        if self.middleware_stack is not None:\n            raise RuntimeError(\n                \"Cannot add error handler after an application has started\"\n            )\n\n        error_handler = (code_or_exception, function)\n        self.error_handlers.append(error_handler)",
      "docstring": "Register a callable to handle application errors.\n\n:param code_or_exception: An exception class or the status code of HTTP exceptions to\n    handle.\n:param function: Callable that will handle exception, may be async.",
      "decorators": [],
      "arguments": [
        "self",
        "code_or_exception",
        "function"
      ],
      "imports": [
        "copy",
        "dataclasses",
        "enum",
        "logging",
        "pathlib",
        "typing",
        "dataclasses.dataclass",
        "dataclasses.field",
        "functools.partial",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.utils",
        "connexion.handlers.ResolverErrorHandler",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.SpecMiddleware",
        "connexion.middleware.context.ContextMiddleware",
        "connexion.middleware.exceptions.ExceptionMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.middleware.lifespan.LifespanMiddleware",
        "connexion.middleware.request_validation.RequestValidationMiddleware",
        "connexion.middleware.response_validation.ResponseValidationMiddleware",
        "connexion.middleware.routing.RoutingMiddleware",
        "connexion.middleware.security.SecurityMiddleware",
        "connexion.middleware.server_error.ServerErrorMiddleware",
        "connexion.middleware.swagger_ui.SwaggerUIMiddleware",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.spec.Specification",
        "connexion.types.MaybeAwaitable",
        "connexion.uri_parsing.AbstractURIParser",
        "connexion.utils.inspect_function_arguments",
        "uvicorn"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "run",
      "module": "main",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\main.py",
      "line_number": 467,
      "end_line_number": 497,
      "source_code": "def run(self, import_string: t.Optional[str] = None, **kwargs):\n        \"\"\"Run the application using uvicorn.\n\n        :param import_string: application as import string (eg. \"main:app\"). This is needed to run\n                              using reload.\n        :param kwargs: kwargs to pass to `uvicorn.run`.\n        \"\"\"\n        try:\n            import uvicorn\n        except ImportError:\n            raise RuntimeError(\n                \"uvicorn is not installed. Please install connexion using the uvicorn extra \"\n                \"(connexion[uvicorn])\"\n            )\n\n        logger.warning(\n            f\"`{self.__class__.__name__}.run` is optimized for development. \"\n            \"For production, run using a dedicated ASGI server.\"\n        )\n\n        app: t.Union[str, ConnexionMiddleware]\n        if import_string is not None:\n            app = import_string\n            kwargs.setdefault(\"reload\", True)\n            kwargs[\"reload_includes\"] = self.extra_files + kwargs.get(\n                \"reload_includes\", []\n            )\n        else:\n            app = self\n\n        uvicorn.run(app, **kwargs)",
      "docstring": "Run the application using uvicorn.\n\n:param import_string: application as import string (eg. \"main:app\"). This is needed to run\n                      using reload.\n:param kwargs: kwargs to pass to `uvicorn.run`.",
      "decorators": [],
      "arguments": [
        "self",
        "import_string"
      ],
      "imports": [
        "copy",
        "dataclasses",
        "enum",
        "logging",
        "pathlib",
        "typing",
        "dataclasses.dataclass",
        "dataclasses.field",
        "functools.partial",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.utils",
        "connexion.handlers.ResolverErrorHandler",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.SpecMiddleware",
        "connexion.middleware.context.ContextMiddleware",
        "connexion.middleware.exceptions.ExceptionMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.middleware.lifespan.LifespanMiddleware",
        "connexion.middleware.request_validation.RequestValidationMiddleware",
        "connexion.middleware.response_validation.ResponseValidationMiddleware",
        "connexion.middleware.routing.RoutingMiddleware",
        "connexion.middleware.security.SecurityMiddleware",
        "connexion.middleware.server_error.ServerErrorMiddleware",
        "connexion.middleware.swagger_ui.SwaggerUIMiddleware",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.spec.Specification",
        "connexion.types.MaybeAwaitable",
        "connexion.uri_parsing.AbstractURIParser",
        "connexion.utils.inspect_function_arguments",
        "uvicorn"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "kwargs.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "resolver_error_handler",
      "module": "main",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\main.py",
      "line_number": 77,
      "end_line_number": 78,
      "source_code": "def resolver_error_handler(*args, **kwargs) -> ResolverErrorHandler:\n                return ResolverErrorHandler(self.resolver_error, *args, **kwargs)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "copy",
        "dataclasses",
        "enum",
        "logging",
        "pathlib",
        "typing",
        "dataclasses.dataclass",
        "dataclasses.field",
        "functools.partial",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.utils",
        "connexion.handlers.ResolverErrorHandler",
        "connexion.jsonifier.Jsonifier",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.abstract.SpecMiddleware",
        "connexion.middleware.context.ContextMiddleware",
        "connexion.middleware.exceptions.ExceptionMiddleware",
        "connexion.middleware.lifespan.Lifespan",
        "connexion.middleware.lifespan.LifespanMiddleware",
        "connexion.middleware.request_validation.RequestValidationMiddleware",
        "connexion.middleware.response_validation.ResponseValidationMiddleware",
        "connexion.middleware.routing.RoutingMiddleware",
        "connexion.middleware.security.SecurityMiddleware",
        "connexion.middleware.server_error.ServerErrorMiddleware",
        "connexion.middleware.swagger_ui.SwaggerUIMiddleware",
        "connexion.options.SwaggerUIOptions",
        "connexion.resolver.Resolver",
        "connexion.spec.Specification",
        "connexion.types.MaybeAwaitable",
        "connexion.uri_parsing.AbstractURIParser",
        "connexion.utils.inspect_function_arguments",
        "uvicorn"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "request_validation",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\request_validation.py",
      "line_number": 20,
      "end_line_number": 32,
      "source_code": "def __init__(\n        self,\n        next_app: ASGIApp,\n        *,\n        operation: AbstractOperation,\n        strict_validation: bool = False,\n        validator_map: t.Optional[dict] = None,\n    ) -> None:\n        self.next_app = next_app\n        self._operation = operation\n        self.strict_validation = strict_validation\n        self._validator_map = VALIDATOR_MAP.copy()\n        self._validator_map.update(validator_map or {})",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "next_app"
      ],
      "imports": [
        "logging",
        "typing",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.utils",
        "connexion.datastructures.MediaTypeDict",
        "connexion.exceptions.UnsupportedMediaTypeProblem",
        "connexion.middleware.abstract.RoutedAPI",
        "connexion.middleware.abstract.RoutedMiddleware",
        "connexion.operations.AbstractOperation",
        "connexion.validators.VALIDATOR_MAP"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "extract_content_type",
      "module": "request_validation",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\request_validation.py",
      "line_number": 34,
      "end_line_number": 54,
      "source_code": "def extract_content_type(\n        self, headers: t.List[t.Tuple[bytes, bytes]]\n    ) -> t.Tuple[str, str]:\n        \"\"\"Extract the mime type and encoding from the content type headers.\n\n        :param headers: Headers from ASGI scope\n\n        :return: A tuple of mime type, encoding\n        \"\"\"\n        content_type = utils.extract_content_type(headers)\n        mime_type, encoding = utils.split_content_type(content_type)\n        if mime_type is None:\n            # Content-type header is not required. Take a best guess.\n            try:\n                mime_type = self._operation.consumes[0]\n            except IndexError:\n                mime_type = \"application/octet-stream\"\n        if encoding is None:\n            encoding = \"utf-8\"\n\n        return mime_type, encoding",
      "docstring": "Extract the mime type and encoding from the content type headers.\n\n:param headers: Headers from ASGI scope\n\n:return: A tuple of mime type, encoding",
      "decorators": [],
      "arguments": [
        "self",
        "headers"
      ],
      "imports": [
        "logging",
        "typing",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.utils",
        "connexion.datastructures.MediaTypeDict",
        "connexion.exceptions.UnsupportedMediaTypeProblem",
        "connexion.middleware.abstract.RoutedAPI",
        "connexion.middleware.abstract.RoutedMiddleware",
        "connexion.operations.AbstractOperation",
        "connexion.validators.VALIDATOR_MAP"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "utils.extract_content_type",
          "body": "def extract_content_type(headers: t.Union[t.List[t.Tuple[bytes, bytes]], t.Dict[str, str]]) -> t.Optional[str]:\n    \"\"\"Extract the mime type and encoding from the content type headers.\n\n    :param headers: Headers from ASGI scope\n\n    :return: The content type if available in headers, otherwise None\n    \"\"\"\n    content_type: t.Optional[str] = None\n    header_pairs_type = t.Collection[t.Tuple[t.Union[str, bytes], t.Union[str, bytes]]]\n    header_pairs: header_pairs_type = headers.items() if isinstance(headers, dict) else headers\n    for key, value in header_pairs:\n        if isinstance(key, bytes):\n            decoded_key: str = key.decode('latin-1')\n        else:\n            decoded_key = key\n        if decoded_key.lower() == 'content-type':\n            if isinstance(value, bytes):\n                content_type = value.decode('latin-1')\n            else:\n                content_type = value\n            break\n    return content_type"
        },
        {
          "name": "utils.split_content_type",
          "body": "def split_content_type(content_type: t.Optional[str]) -> t.Tuple[t.Optional[str], t.Optional[str]]:\n    \"\"\"Split the content type in mime_type and encoding. Other parameters are ignored.\"\"\"\n    mime_type, encoding = (None, None)\n    if content_type is None:\n        return (mime_type, encoding)\n    if ';' in content_type:\n        mime_type, parameters = content_type.split(';', maxsplit=1)\n        prefix = 'charset='\n        for parameter in parameters.split(';'):\n            if parameter.startswith(prefix):\n                encoding = parameter[len(prefix):]\n    else:\n        mime_type = content_type\n    return (mime_type, encoding)"
        }
      ]
    },
    {
      "name": "validate_mime_type",
      "module": "request_validation",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\request_validation.py",
      "line_number": 56,
      "end_line_number": 72,
      "source_code": "def validate_mime_type(self, mime_type: str) -> None:\n        \"\"\"Validate the mime type against the spec if it defines which mime types are accepted.\n\n        :param mime_type: mime type from content type header\n        \"\"\"\n        if not self._operation.consumes:\n            return\n\n        # Convert to MediaTypeDict to handle media-ranges\n        media_type_dict = MediaTypeDict(\n            [(c.lower(), None) for c in self._operation.consumes]\n        )\n        if mime_type.lower() not in media_type_dict:\n            raise UnsupportedMediaTypeProblem(\n                detail=f\"Invalid Content-type ({mime_type}), \"\n                f\"expected {self._operation.consumes}\"\n            )",
      "docstring": "Validate the mime type against the spec if it defines which mime types are accepted.\n\n:param mime_type: mime type from content type header",
      "decorators": [],
      "arguments": [
        "self",
        "mime_type"
      ],
      "imports": [
        "logging",
        "typing",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.utils",
        "connexion.datastructures.MediaTypeDict",
        "connexion.exceptions.UnsupportedMediaTypeProblem",
        "connexion.middleware.abstract.RoutedAPI",
        "connexion.middleware.abstract.RoutedMiddleware",
        "connexion.operations.AbstractOperation",
        "connexion.validators.VALIDATOR_MAP"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "security_query_params",
      "module": "request_validation",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\request_validation.py",
      "line_number": 75,
      "end_line_number": 95,
      "source_code": "def security_query_params(self) -> t.List[str]:\n        \"\"\"Get the names of query parameters that are used for security.\"\"\"\n        if not hasattr(self, \"_security_query_params\"):\n            security_query_params: t.List[str] = []\n            if self._operation.security is None:\n                self._security_query_params = security_query_params\n                return self._security_query_params\n\n            for security_req in self._operation.security:\n                for scheme_name in security_req:\n                    security_scheme = self._operation.security_schemes[scheme_name]\n\n                    if (\n                        security_scheme[\"type\"] == \"apiKey\"\n                        and security_scheme[\"in\"] == \"query\"\n                    ):\n                        # Only query parameters need to be considered for strict_validation\n                        security_query_params.append(security_scheme[\"name\"])\n            self._security_query_params = security_query_params\n\n        return self._security_query_params",
      "docstring": "Get the names of query parameters that are used for security.",
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "logging",
        "typing",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.utils",
        "connexion.datastructures.MediaTypeDict",
        "connexion.exceptions.UnsupportedMediaTypeProblem",
        "connexion.middleware.abstract.RoutedAPI",
        "connexion.middleware.abstract.RoutedMiddleware",
        "connexion.operations.AbstractOperation",
        "connexion.validators.VALIDATOR_MAP"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "request_validation",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\request_validation.py",
      "line_number": 148,
      "end_line_number": 164,
      "source_code": "def __init__(\n        self,\n        *args,\n        strict_validation=False,\n        validator_map=None,\n        uri_parser_class=None,\n        **kwargs,\n    ):\n        super().__init__(*args, **kwargs)\n        self.validator_map = validator_map\n\n        logger.debug(\"Strict Request Validation: %s\", str(strict_validation))\n        self.strict_validation = strict_validation\n\n        self.uri_parser_class = uri_parser_class\n\n        self.add_paths()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "logging",
        "typing",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.utils",
        "connexion.datastructures.MediaTypeDict",
        "connexion.exceptions.UnsupportedMediaTypeProblem",
        "connexion.middleware.abstract.RoutedAPI",
        "connexion.middleware.abstract.RoutedMiddleware",
        "connexion.operations.AbstractOperation",
        "connexion.validators.VALIDATOR_MAP"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.add_paths",
          "body": "def add_paths(self, paths: t.Optional[dict]=None) -> None:\n    \"\"\"\n        Adds the paths defined in the specification as operations.\n        \"\"\"\n    paths = t.cast(dict, paths or self.specification.get('paths', dict()))\n    for path, methods in paths.items():\n        logger.debug('Adding %s%s...', self.base_path, path)\n        for method in methods:\n            if method not in METHODS:\n                continue\n            try:\n                self.add_operation(path, method)\n            except ResolverError as err:\n                if self.resolver_error_handler is not None:\n                    self._add_resolver_error_handler(method, path, err)\n                else:\n                    self._handle_add_operation_error(path, method, err)\n            except Exception as e:\n                self._handle_add_operation_error(path, method, e)"
        }
      ]
    },
    {
      "name": "make_operation",
      "module": "request_validation",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\request_validation.py",
      "line_number": 166,
      "end_line_number": 174,
      "source_code": "def make_operation(\n        self, operation: AbstractOperation\n    ) -> RequestValidationOperation:\n        return RequestValidationOperation(\n            self.next_app,\n            operation=operation,\n            strict_validation=self.strict_validation,\n            validator_map=self.validator_map,\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "operation"
      ],
      "imports": [
        "logging",
        "typing",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.utils",
        "connexion.datastructures.MediaTypeDict",
        "connexion.exceptions.UnsupportedMediaTypeProblem",
        "connexion.middleware.abstract.RoutedAPI",
        "connexion.middleware.abstract.RoutedMiddleware",
        "connexion.operations.AbstractOperation",
        "connexion.validators.VALIDATOR_MAP"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "response_validation",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\response_validation.py",
      "line_number": 20,
      "end_line_number": 30,
      "source_code": "def __init__(\n        self,\n        next_app: ASGIApp,\n        *,\n        operation: AbstractOperation,\n        validator_map: t.Optional[dict] = None,\n    ) -> None:\n        self.next_app = next_app\n        self._operation = operation\n        self._validator_map = VALIDATOR_MAP.copy()\n        self._validator_map.update(validator_map or {})",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "next_app"
      ],
      "imports": [
        "logging",
        "typing",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.utils",
        "connexion.datastructures.MediaTypeDict",
        "connexion.exceptions.NonConformingResponseHeaders",
        "connexion.middleware.abstract.RoutedAPI",
        "connexion.middleware.abstract.RoutedMiddleware",
        "connexion.operations.AbstractOperation",
        "connexion.validators.VALIDATOR_MAP"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "extract_content_type",
      "module": "response_validation",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\response_validation.py",
      "line_number": 32,
      "end_line_number": 52,
      "source_code": "def extract_content_type(\n        self, headers: t.List[t.Tuple[bytes, bytes]]\n    ) -> t.Tuple[str, str]:\n        \"\"\"Extract the mime type and encoding from the content type headers.\n\n        :param headers: Headers from ASGI scope\n\n        :return: A tuple of mime type, encoding\n        \"\"\"\n        content_type = utils.extract_content_type(headers)\n        mime_type, encoding = utils.split_content_type(content_type)\n        if mime_type is None:\n            # Content-type header is not required. Take a best guess.\n            try:\n                mime_type = self._operation.produces[0]\n            except IndexError:\n                mime_type = \"application/octet-stream\"\n        if encoding is None:\n            encoding = \"utf-8\"\n\n        return mime_type, encoding",
      "docstring": "Extract the mime type and encoding from the content type headers.\n\n:param headers: Headers from ASGI scope\n\n:return: A tuple of mime type, encoding",
      "decorators": [],
      "arguments": [
        "self",
        "headers"
      ],
      "imports": [
        "logging",
        "typing",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.utils",
        "connexion.datastructures.MediaTypeDict",
        "connexion.exceptions.NonConformingResponseHeaders",
        "connexion.middleware.abstract.RoutedAPI",
        "connexion.middleware.abstract.RoutedMiddleware",
        "connexion.operations.AbstractOperation",
        "connexion.validators.VALIDATOR_MAP"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "utils.extract_content_type",
          "body": "def extract_content_type(headers: t.Union[t.List[t.Tuple[bytes, bytes]], t.Dict[str, str]]) -> t.Optional[str]:\n    \"\"\"Extract the mime type and encoding from the content type headers.\n\n    :param headers: Headers from ASGI scope\n\n    :return: The content type if available in headers, otherwise None\n    \"\"\"\n    content_type: t.Optional[str] = None\n    header_pairs_type = t.Collection[t.Tuple[t.Union[str, bytes], t.Union[str, bytes]]]\n    header_pairs: header_pairs_type = headers.items() if isinstance(headers, dict) else headers\n    for key, value in header_pairs:\n        if isinstance(key, bytes):\n            decoded_key: str = key.decode('latin-1')\n        else:\n            decoded_key = key\n        if decoded_key.lower() == 'content-type':\n            if isinstance(value, bytes):\n                content_type = value.decode('latin-1')\n            else:\n                content_type = value\n            break\n    return content_type"
        },
        {
          "name": "utils.split_content_type",
          "body": "def split_content_type(content_type: t.Optional[str]) -> t.Tuple[t.Optional[str], t.Optional[str]]:\n    \"\"\"Split the content type in mime_type and encoding. Other parameters are ignored.\"\"\"\n    mime_type, encoding = (None, None)\n    if content_type is None:\n        return (mime_type, encoding)\n    if ';' in content_type:\n        mime_type, parameters = content_type.split(';', maxsplit=1)\n        prefix = 'charset='\n        for parameter in parameters.split(';'):\n            if parameter.startswith(prefix):\n                encoding = parameter[len(prefix):]\n    else:\n        mime_type = content_type\n    return (mime_type, encoding)"
        }
      ]
    },
    {
      "name": "validate_mime_type",
      "module": "response_validation",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\response_validation.py",
      "line_number": 54,
      "end_line_number": 69,
      "source_code": "def validate_mime_type(self, mime_type: str) -> None:\n        \"\"\"Validate the mime type against the spec if it defines which mime types are produced.\n\n        :param mime_type: mime type from content type header\n        \"\"\"\n        if not self._operation.produces:\n            return\n\n        media_type_dict = MediaTypeDict(\n            [(p.lower(), None) for p in self._operation.produces]\n        )\n        if mime_type.lower() not in media_type_dict:\n            raise NonConformingResponseHeaders(\n                detail=f\"Invalid Response Content-type ({mime_type}), \"\n                f\"expected {self._operation.produces}\",\n            )",
      "docstring": "Validate the mime type against the spec if it defines which mime types are produced.\n\n:param mime_type: mime type from content type header",
      "decorators": [],
      "arguments": [
        "self",
        "mime_type"
      ],
      "imports": [
        "logging",
        "typing",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.utils",
        "connexion.datastructures.MediaTypeDict",
        "connexion.exceptions.NonConformingResponseHeaders",
        "connexion.middleware.abstract.RoutedAPI",
        "connexion.middleware.abstract.RoutedMiddleware",
        "connexion.operations.AbstractOperation",
        "connexion.validators.VALIDATOR_MAP"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "validate_required_headers",
      "module": "response_validation",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\response_validation.py",
      "line_number": 72,
      "end_line_number": 87,
      "source_code": "def validate_required_headers(\n        headers: t.List[tuple], response_definition: dict\n    ) -> None:\n        required_header_keys = {\n            k.lower()\n            for (k, v) in response_definition.get(\"headers\", {}).items()\n            if v.get(\"required\", False)\n        }\n        header_keys = set(header[0].decode(\"latin-1\").lower() for header in headers)\n        missing_keys = required_header_keys - header_keys\n        if missing_keys:\n            pretty_list = \", \".join(missing_keys)\n            msg = (\n                \"Keys in response header don't match response specification. Difference: {}\"\n            ).format(pretty_list)\n            raise NonConformingResponseHeaders(detail=msg)",
      "docstring": null,
      "decorators": [
        "staticmethod"
      ],
      "arguments": [
        "headers",
        "response_definition"
      ],
      "imports": [
        "logging",
        "typing",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.utils",
        "connexion.datastructures.MediaTypeDict",
        "connexion.exceptions.NonConformingResponseHeaders",
        "connexion.middleware.abstract.RoutedAPI",
        "connexion.middleware.abstract.RoutedMiddleware",
        "connexion.operations.AbstractOperation",
        "connexion.validators.VALIDATOR_MAP"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "v.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "response_definition.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "__init__",
      "module": "response_validation",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\response_validation.py",
      "line_number": 133,
      "end_line_number": 143,
      "source_code": "def __init__(\n        self,\n        *args,\n        validator_map=None,\n        validate_responses=False,\n        **kwargs,\n    ):\n        super().__init__(*args, **kwargs)\n        self.validator_map = validator_map\n        self.validate_responses = validate_responses\n        self.add_paths()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "logging",
        "typing",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.utils",
        "connexion.datastructures.MediaTypeDict",
        "connexion.exceptions.NonConformingResponseHeaders",
        "connexion.middleware.abstract.RoutedAPI",
        "connexion.middleware.abstract.RoutedMiddleware",
        "connexion.operations.AbstractOperation",
        "connexion.validators.VALIDATOR_MAP"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.add_paths",
          "body": "def add_paths(self, paths: t.Optional[dict]=None) -> None:\n    \"\"\"\n        Adds the paths defined in the specification as operations.\n        \"\"\"\n    paths = t.cast(dict, paths or self.specification.get('paths', dict()))\n    for path, methods in paths.items():\n        logger.debug('Adding %s%s...', self.base_path, path)\n        for method in methods:\n            if method not in METHODS:\n                continue\n            try:\n                self.add_operation(path, method)\n            except ResolverError as err:\n                if self.resolver_error_handler is not None:\n                    self._add_resolver_error_handler(method, path, err)\n                else:\n                    self._handle_add_operation_error(path, method, err)\n            except Exception as e:\n                self._handle_add_operation_error(path, method, e)"
        }
      ]
    },
    {
      "name": "make_operation",
      "module": "response_validation",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\response_validation.py",
      "line_number": 145,
      "end_line_number": 155,
      "source_code": "def make_operation(\n        self, operation: AbstractOperation\n    ) -> ResponseValidationOperation:\n        if self.validate_responses:\n            return ResponseValidationOperation(\n                self.next_app,\n                operation=operation,\n                validator_map=self.validator_map,\n            )\n        else:\n            return self.next_app",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "operation"
      ],
      "imports": [
        "logging",
        "typing",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.utils",
        "connexion.datastructures.MediaTypeDict",
        "connexion.exceptions.NonConformingResponseHeaders",
        "connexion.middleware.abstract.RoutedAPI",
        "connexion.middleware.abstract.RoutedMiddleware",
        "connexion.operations.AbstractOperation",
        "connexion.validators.VALIDATOR_MAP"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "routing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\routing.py",
      "line_number": 22,
      "end_line_number": 24,
      "source_code": "def __init__(self, operation_id: t.Optional[str], next_app: ASGIApp) -> None:\n        self.operation_id = operation_id\n        self.next_app = next_app",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "operation_id",
        "next_app"
      ],
      "imports": [
        "typing",
        "contextvars.ContextVar",
        "starlette.convertors",
        "starlette.routing.Router",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.frameworks.starlette",
        "connexion.middleware.abstract.ROUTING_CONTEXT",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.middleware.abstract.SpecMiddleware",
        "connexion.operations.AbstractOperation",
        "connexion.resolver.Resolver",
        "connexion.spec.Specification"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "from_operation",
      "module": "routing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\routing.py",
      "line_number": 27,
      "end_line_number": 28,
      "source_code": "def from_operation(cls, operation: AbstractOperation, next_app: ASGIApp):\n        return cls(operation.operation_id, next_app)",
      "docstring": null,
      "decorators": [
        "classmethod"
      ],
      "arguments": [
        "cls",
        "operation",
        "next_app"
      ],
      "imports": [
        "typing",
        "contextvars.ContextVar",
        "starlette.convertors",
        "starlette.routing.Router",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.frameworks.starlette",
        "connexion.middleware.abstract.ROUTING_CONTEXT",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.middleware.abstract.SpecMiddleware",
        "connexion.operations.AbstractOperation",
        "connexion.resolver.Resolver",
        "connexion.spec.Specification"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "routing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\routing.py",
      "line_number": 52,
      "end_line_number": 76,
      "source_code": "def __init__(\n        self,\n        specification: Specification,\n        *,\n        next_app: ASGIApp,\n        base_path: t.Optional[str] = None,\n        arguments: t.Optional[dict] = None,\n        resolver: t.Optional[Resolver] = None,\n        resolver_error_handler: t.Optional[t.Callable] = None,\n        debug: bool = False,\n        **kwargs,\n    ) -> None:\n        \"\"\"API implementation on top of Starlette Router for Connexion middleware.\"\"\"\n        self.next_app = next_app\n        self.router = Router(default=RoutingOperation(None, next_app))\n\n        super().__init__(\n            specification,\n            base_path=base_path,\n            arguments=arguments,\n            resolver=resolver,\n            resolver_error_handler=resolver_error_handler,\n            debug=debug,\n            **kwargs,\n        )",
      "docstring": "API implementation on top of Starlette Router for Connexion middleware.",
      "decorators": [],
      "arguments": [
        "self",
        "specification"
      ],
      "imports": [
        "typing",
        "contextvars.ContextVar",
        "starlette.convertors",
        "starlette.routing.Router",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.frameworks.starlette",
        "connexion.middleware.abstract.ROUTING_CONTEXT",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.middleware.abstract.SpecMiddleware",
        "connexion.operations.AbstractOperation",
        "connexion.resolver.Resolver",
        "connexion.spec.Specification"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "make_operation",
      "module": "routing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\routing.py",
      "line_number": 78,
      "end_line_number": 79,
      "source_code": "def make_operation(self, operation: AbstractOperation) -> RoutingOperation:\n        return RoutingOperation.from_operation(operation, next_app=self.next_app)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "operation"
      ],
      "imports": [
        "typing",
        "contextvars.ContextVar",
        "starlette.convertors",
        "starlette.routing.Router",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.frameworks.starlette",
        "connexion.middleware.abstract.ROUTING_CONTEXT",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.middleware.abstract.SpecMiddleware",
        "connexion.operations.AbstractOperation",
        "connexion.resolver.Resolver",
        "connexion.spec.Specification"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "RoutingOperation.from_operation",
          "body": "@classmethod\ndef from_operation(cls, operation: AbstractOperation, *, pythonic_params: bool, jsonifier: Jsonifier) -> 'AsyncOperation':\n    return cls(operation.function, jsonifier=jsonifier, operation_id=operation.operation_id, pythonic_params=pythonic_params)"
        }
      ]
    },
    {
      "name": "_framework_path_and_name",
      "module": "routing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\routing.py",
      "line_number": 82,
      "end_line_number": 87,
      "source_code": "def _framework_path_and_name(\n        operation: AbstractOperation, path: str\n    ) -> t.Tuple[str, str]:\n        types = operation.get_path_parameter_types()\n        starlette_path = starlette_utils.starlettify_path(path, types)\n        return starlette_path, starlette_path",
      "docstring": null,
      "decorators": [
        "staticmethod"
      ],
      "arguments": [
        "operation",
        "path"
      ],
      "imports": [
        "typing",
        "contextvars.ContextVar",
        "starlette.convertors",
        "starlette.routing.Router",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.frameworks.starlette",
        "connexion.middleware.abstract.ROUTING_CONTEXT",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.middleware.abstract.SpecMiddleware",
        "connexion.operations.AbstractOperation",
        "connexion.resolver.Resolver",
        "connexion.spec.Specification"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "operation.get_path_parameter_types",
          "body": "def get_path_parameter_types(self):\n    return {}"
        },
        {
          "name": "starlette_utils.starlettify_path",
          "body": "def starlettify_path(swagger_path, types=None):\n    \"\"\"\n    Convert swagger path templates to flask path templates\n\n    :type swagger_path: str\n    :type types: dict\n    :rtype: str\n\n    >>> starlettify_path('/foo-bar/{my-param}')\n    '/foo-bar/{my_param}'\n\n    >>> starlettify_path('/foo/{someint}', {'someint': 'int'})\n    '/foo/{someint:int}'\n    \"\"\"\n    if types is None:\n        types = {}\n    convert_match = functools.partial(convert_path_parameter, types=types)\n    return PATH_PARAMETER.sub(convert_match, swagger_path)"
        }
      ]
    },
    {
      "name": "_add_operation_internal",
      "module": "routing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\routing.py",
      "line_number": 89,
      "end_line_number": 96,
      "source_code": "def _add_operation_internal(\n        self,\n        method: str,\n        path: str,\n        operation: RoutingOperation,\n        name: t.Optional[str] = None,\n    ) -> None:\n        self.router.add_route(path, operation, methods=[method])",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "method",
        "path",
        "operation",
        "name"
      ],
      "imports": [
        "typing",
        "contextvars.ContextVar",
        "starlette.convertors",
        "starlette.routing.Router",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.frameworks.starlette",
        "connexion.middleware.abstract.ROUTING_CONTEXT",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.middleware.abstract.SpecMiddleware",
        "connexion.operations.AbstractOperation",
        "connexion.resolver.Resolver",
        "connexion.spec.Specification"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "routing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\routing.py",
      "line_number": 100,
      "end_line_number": 114,
      "source_code": "def __init__(self, app: ASGIApp) -> None:\n        \"\"\"Middleware that resolves the Operation for an incoming request and attaches it to the\n        scope.\n\n        :param app: app to wrap in middleware.\n        \"\"\"\n        self.app = app\n        # Pass unknown routes to next app\n        self.router = Router(default=RoutingOperation(None, self.app))\n        starlette.convertors.register_url_convertor(\n            \"float\", starlette_utils.FloatConverter()\n        )\n        starlette.convertors.register_url_convertor(\n            \"int\", starlette_utils.IntegerConverter()\n        )",
      "docstring": "Middleware that resolves the Operation for an incoming request and attaches it to the\nscope.\n\n:param app: app to wrap in middleware.",
      "decorators": [],
      "arguments": [
        "self",
        "app"
      ],
      "imports": [
        "typing",
        "contextvars.ContextVar",
        "starlette.convertors",
        "starlette.routing.Router",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.frameworks.starlette",
        "connexion.middleware.abstract.ROUTING_CONTEXT",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.middleware.abstract.SpecMiddleware",
        "connexion.operations.AbstractOperation",
        "connexion.resolver.Resolver",
        "connexion.spec.Specification"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "add_api",
      "module": "routing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\routing.py",
      "line_number": 116,
      "end_line_number": 147,
      "source_code": "def add_api(\n        self,\n        specification: Specification,\n        base_path: t.Optional[str] = None,\n        arguments: t.Optional[dict] = None,\n        **kwargs,\n    ) -> None:\n        \"\"\"Add an API to the router based on a OpenAPI spec.\n\n        :param specification: OpenAPI spec.\n        :param base_path: Base path where to add this API.\n        :param arguments: Jinja arguments to replace in the spec.\n        \"\"\"\n        api = RoutingAPI(\n            specification,\n            base_path=base_path,\n            arguments=arguments,\n            next_app=self.app,\n            **kwargs,\n        )\n\n        # If an API with the same base_path was already registered, chain the new API as its\n        # default. This way, if no matching route is found on the first API, the request is\n        # forwarded to the new API.\n        for route in self.router.routes:\n            if (\n                isinstance(route, starlette.routing.Mount)\n                and route.path == api.base_path\n            ):\n                route.app.default = api.router\n\n        self.router.mount(api.base_path, app=api.router)",
      "docstring": "Add an API to the router based on a OpenAPI spec.\n\n:param specification: OpenAPI spec.\n:param base_path: Base path where to add this API.\n:param arguments: Jinja arguments to replace in the spec.",
      "decorators": [],
      "arguments": [
        "self",
        "specification",
        "base_path",
        "arguments"
      ],
      "imports": [
        "typing",
        "contextvars.ContextVar",
        "starlette.convertors",
        "starlette.routing.Router",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.frameworks.starlette",
        "connexion.middleware.abstract.ROUTING_CONTEXT",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.middleware.abstract.SpecMiddleware",
        "connexion.operations.AbstractOperation",
        "connexion.resolver.Resolver",
        "connexion.spec.Specification"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "get_root_path",
      "module": "routing",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\routing.py",
      "line_number": 38,
      "end_line_number": 39,
      "source_code": "def get_root_path(scope: Scope) -> str:\n            return scope.get(\"route_root_path\", scope.get(\"root_path\", \"\"))",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "scope"
      ],
      "imports": [
        "typing",
        "contextvars.ContextVar",
        "starlette.convertors",
        "starlette.routing.Router",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.frameworks.starlette",
        "connexion.middleware.abstract.ROUTING_CONTEXT",
        "connexion.middleware.abstract.AbstractRoutingAPI",
        "connexion.middleware.abstract.SpecMiddleware",
        "connexion.operations.AbstractOperation",
        "connexion.resolver.Resolver",
        "connexion.spec.Specification"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "scope.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "scope.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "__init__",
      "module": "security",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\security.py",
      "line_number": 18,
      "end_line_number": 30,
      "source_code": "def __init__(\n        self,\n        next_app: ASGIApp,\n        *,\n        security_handler_factory: SecurityHandlerFactory,\n        security: list,\n        security_schemes: dict,\n    ):\n        self.next_app = next_app\n        self.security_handler_factory = security_handler_factory\n        self.security = security\n        self.security_schemes = security_schemes\n        self.verification_fn = self._get_verification_fn()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "next_app"
      ],
      "imports": [
        "logging",
        "typing",
        "collections.defaultdict",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.exceptions.ProblemException",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.middleware.abstract.RoutedAPI",
        "connexion.middleware.abstract.RoutedMiddleware",
        "connexion.operations.AbstractOperation",
        "connexion.security.SecurityHandlerFactory",
        "connexion.spec.Specification"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._get_verification_fn",
          "body": "def _get_verification_fn(self):\n    logger.debug('... Security: %s', self.security, extra=vars(self))\n    if not self.security:\n        return self.security_handler_factory.security_passthrough\n    auth_funcs = []\n    for security_req in self.security:\n        if not security_req:\n            auth_funcs.append(self.security_handler_factory.verify_none)\n            continue\n        sec_req_funcs = {}\n        oauth = False\n        for scheme_name, required_scopes in security_req.items():\n            security_scheme = self.security_schemes[scheme_name]\n            if security_scheme['type'] == 'oauth2':\n                if oauth:\n                    logger.warning('... multiple OAuth2 security schemes in AND fashion not supported', extra=vars(self))\n                    break\n                oauth = True\n            sec_req_func = self.security_handler_factory.parse_security_scheme(security_scheme, required_scopes)\n            if sec_req_func is None:\n                break\n            sec_req_funcs[scheme_name] = sec_req_func\n        else:\n            if len(sec_req_funcs) == 1:\n                func, = sec_req_funcs.values()\n                auth_funcs.append(func)\n            else:\n                auth_funcs.append(self.security_handler_factory.verify_multiple_schemes(sec_req_funcs))\n    return self.security_handler_factory.verify_security(auth_funcs)"
        }
      ]
    },
    {
      "name": "from_operation",
      "module": "security",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\security.py",
      "line_number": 33,
      "end_line_number": 55,
      "source_code": "def from_operation(\n        cls,\n        operation: t.Union[AbstractOperation, Specification],\n        *,\n        next_app: ASGIApp,\n        security_handler_factory: SecurityHandlerFactory,\n    ) -> \"SecurityOperation\":\n        \"\"\"Create a SecurityOperation from an Operation of Specification instance\n\n        :param operation: The operation can be both an Operation or Specification instance here\n            since security is defined at both levels in the OpenAPI spec. Creating a\n            SecurityOperation based on a Specification can be used to create a SecurityOperation\n            for routes not explicitly defined in the specification.\n        :param next_app: The next ASGI app to call.\n        :param security_handler_factory: The factory to be used to generate security handlers for\n            the different security schemes.\n        \"\"\"\n        return cls(\n            next_app=next_app,\n            security_handler_factory=security_handler_factory,\n            security=operation.security,\n            security_schemes=operation.security_schemes,\n        )",
      "docstring": "Create a SecurityOperation from an Operation of Specification instance\n\n:param operation: The operation can be both an Operation or Specification instance here\n    since security is defined at both levels in the OpenAPI spec. Creating a\n    SecurityOperation based on a Specification can be used to create a SecurityOperation\n    for routes not explicitly defined in the specification.\n:param next_app: The next ASGI app to call.\n:param security_handler_factory: The factory to be used to generate security handlers for\n    the different security schemes.",
      "decorators": [
        "classmethod"
      ],
      "arguments": [
        "cls",
        "operation"
      ],
      "imports": [
        "logging",
        "typing",
        "collections.defaultdict",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.exceptions.ProblemException",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.middleware.abstract.RoutedAPI",
        "connexion.middleware.abstract.RoutedMiddleware",
        "connexion.operations.AbstractOperation",
        "connexion.security.SecurityHandlerFactory",
        "connexion.spec.Specification"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_get_verification_fn",
      "module": "security",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\security.py",
      "line_number": 57,
      "end_line_number": 102,
      "source_code": "def _get_verification_fn(self):\n        logger.debug(\"... Security: %s\", self.security, extra=vars(self))\n        if not self.security:\n            return self.security_handler_factory.security_passthrough\n\n        auth_funcs = []\n        for security_req in self.security:\n            if not security_req:\n                auth_funcs.append(self.security_handler_factory.verify_none)\n                continue\n\n            sec_req_funcs = {}\n            oauth = False\n            for scheme_name, required_scopes in security_req.items():\n                security_scheme = self.security_schemes[scheme_name]\n\n                if security_scheme[\"type\"] == \"oauth2\":\n                    if oauth:\n                        logger.warning(\n                            \"... multiple OAuth2 security schemes in AND fashion not supported\",\n                            extra=vars(self),\n                        )\n                        break\n                    oauth = True\n\n                sec_req_func = self.security_handler_factory.parse_security_scheme(\n                    security_scheme, required_scopes\n                )\n                if sec_req_func is None:\n                    break\n\n                sec_req_funcs[scheme_name] = sec_req_func\n\n            else:\n                # No break encountered: no missing funcs\n                if len(sec_req_funcs) == 1:\n                    (func,) = sec_req_funcs.values()\n                    auth_funcs.append(func)\n                else:\n                    auth_funcs.append(\n                        self.security_handler_factory.verify_multiple_schemes(\n                            sec_req_funcs\n                        )\n                    )\n\n        return self.security_handler_factory.verify_security(auth_funcs)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "logging",
        "typing",
        "collections.defaultdict",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.exceptions.ProblemException",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.middleware.abstract.RoutedAPI",
        "connexion.middleware.abstract.RoutedMiddleware",
        "connexion.operations.AbstractOperation",
        "connexion.security.SecurityHandlerFactory",
        "connexion.spec.Specification"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.security_handler_factory.verify_security",
          "body": "@classmethod\ndef verify_security(cls, auth_funcs):\n\n    async def verify_fn(request):\n        token_info = NO_VALUE\n        errors = []\n        for func in auth_funcs:\n            try:\n                token_info = func(request)\n                while asyncio.iscoroutine(token_info):\n                    token_info = await token_info\n                if token_info is not NO_VALUE:\n                    break\n            except Exception as err:\n                errors.append(err)\n        else:\n            if errors != []:\n                cls._raise_most_specific(errors)\n            else:\n                logger.info('... No auth provided. Aborting with 401.')\n                raise OAuthProblem(detail='No authorization token provided')\n        request.context.update({'user': token_info.get('sub', token_info.get('uid')), 'token_info': token_info})\n    return verify_fn"
        },
        {
          "name": "self.security_handler_factory.parse_security_scheme",
          "body": "def parse_security_scheme(self, security_scheme: dict, required_scopes: t.List[str]) -> t.Optional[t.Callable]:\n    \"\"\"Parses the security scheme and returns the function for verifying it.\n\n        :param security_scheme: The security scheme from the spec.\n        :param required_scopes: List of scopes for this security scheme.\n        \"\"\"\n    security_type = security_scheme['type']\n    if security_type in ('basic', 'oauth2'):\n        security_handler = self.security_handlers[security_type]\n        return security_handler().get_fn(security_scheme, required_scopes)\n    elif security_type == 'http':\n        scheme = security_scheme['scheme'].lower()\n        if scheme in self.security_handlers:\n            security_handler = self.security_handlers[scheme]\n            return security_handler().get_fn(security_scheme, required_scopes)\n        else:\n            logger.warning('... Unsupported http authorization scheme %s', scheme)\n            return None\n    elif security_type == 'apiKey':\n        scheme = security_scheme.get('x-authentication-scheme', '').lower()\n        if scheme == 'bearer':\n            return BearerSecurityHandler().get_fn(security_scheme, required_scopes)\n        else:\n            security_handler = self.security_handlers['apiKey']\n            return security_handler().get_fn(security_scheme, required_scopes)\n    elif (scheme := security_scheme['scheme'].lower()) in self.security_handlers:\n        security_handler = self.security_handlers[scheme]\n        return security_handler().get_fn(security_scheme, required_scopes)\n    else:\n        logger.warning('... Unsupported security scheme type %s', security_type)\n        return None"
        },
        {
          "name": "self.security_handler_factory.verify_multiple_schemes",
          "body": "def verify_multiple_schemes(self, schemes):\n    \"\"\"\n        Verifies multiple authentication schemes in AND fashion.\n        If any scheme fails, the entire authentication fails.\n\n        :param schemes: mapping scheme_name to auth function\n        :type schemes: dict\n        :rtype: types.FunctionType\n        \"\"\"\n\n    async def wrapper(request):\n        token_info = {}\n        for scheme_name, func in schemes.items():\n            result = func(request)\n            while asyncio.iscoroutine(result):\n                result = await result\n            if result is NO_VALUE:\n                return NO_VALUE\n            token_info[scheme_name] = result\n        return token_info\n    return wrapper"
        }
      ]
    },
    {
      "name": "__init__",
      "module": "security",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\security.py",
      "line_number": 115,
      "end_line_number": 131,
      "source_code": "def __init__(\n        self,\n        *args,\n        auth_all_paths: bool = False,\n        security_map: t.Optional[dict] = None,\n        **kwargs,\n    ):\n        super().__init__(*args, **kwargs)\n\n        self.security_handler_factory = SecurityHandlerFactory(security_map)\n\n        if auth_all_paths:\n            self.add_auth_on_not_found()\n        else:\n            self.operations: t.MutableMapping[t.Optional[str], SecurityOperation] = {}\n\n        self.add_paths()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "logging",
        "typing",
        "collections.defaultdict",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.exceptions.ProblemException",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.middleware.abstract.RoutedAPI",
        "connexion.middleware.abstract.RoutedMiddleware",
        "connexion.operations.AbstractOperation",
        "connexion.security.SecurityHandlerFactory",
        "connexion.spec.Specification"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.add_paths",
          "body": "def add_paths(self, paths: t.Optional[dict]=None) -> None:\n    \"\"\"\n        Adds the paths defined in the specification as operations.\n        \"\"\"\n    paths = t.cast(dict, paths or self.specification.get('paths', dict()))\n    for path, methods in paths.items():\n        logger.debug('Adding %s%s...', self.base_path, path)\n        for method in methods:\n            if method not in METHODS:\n                continue\n            try:\n                self.add_operation(path, method)\n            except ResolverError as err:\n                if self.resolver_error_handler is not None:\n                    self._add_resolver_error_handler(method, path, err)\n                else:\n                    self._handle_add_operation_error(path, method, err)\n            except Exception as e:\n                self._handle_add_operation_error(path, method, e)"
        },
        {
          "name": "self.add_auth_on_not_found",
          "body": "def add_auth_on_not_found(self) -> None:\n    \"\"\"Register a default SecurityOperation for routes that are not found.\"\"\"\n    default_operation = self.make_operation(self.specification)\n    self.operations = defaultdict(lambda: default_operation)"
        }
      ]
    },
    {
      "name": "add_auth_on_not_found",
      "module": "security",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\security.py",
      "line_number": 133,
      "end_line_number": 136,
      "source_code": "def add_auth_on_not_found(self) -> None:\n        \"\"\"Register a default SecurityOperation for routes that are not found.\"\"\"\n        default_operation = self.make_operation(self.specification)\n        self.operations = defaultdict(lambda: default_operation)",
      "docstring": "Register a default SecurityOperation for routes that are not found.",
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "logging",
        "typing",
        "collections.defaultdict",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.exceptions.ProblemException",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.middleware.abstract.RoutedAPI",
        "connexion.middleware.abstract.RoutedMiddleware",
        "connexion.operations.AbstractOperation",
        "connexion.security.SecurityHandlerFactory",
        "connexion.spec.Specification"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.make_operation",
          "body": "def make_operation(self, operation: AbstractOperation) -> AsyncOperation:\n    return AsyncOperation.from_operation(operation, pythonic_params=self.pythonic_params, jsonifier=self.jsonifier)"
        }
      ]
    },
    {
      "name": "make_operation",
      "module": "security",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\security.py",
      "line_number": 138,
      "end_line_number": 152,
      "source_code": "def make_operation(\n        self, operation: t.Union[AbstractOperation, Specification]\n    ) -> SecurityOperation:\n        \"\"\"Create a SecurityOperation from an Operation of Specification instance\n\n        :param operation: The operation can be both an Operation or Specification instance here\n            since security is defined at both levels in the OpenAPI spec. Creating a\n            SecurityOperation based on a Specification can be used to create a SecurityOperation\n            for routes not explicitly defined in the specification.\n        \"\"\"\n        return SecurityOperation.from_operation(\n            operation,\n            next_app=self.next_app,\n            security_handler_factory=self.security_handler_factory,\n        )",
      "docstring": "Create a SecurityOperation from an Operation of Specification instance\n\n:param operation: The operation can be both an Operation or Specification instance here\n    since security is defined at both levels in the OpenAPI spec. Creating a\n    SecurityOperation based on a Specification can be used to create a SecurityOperation\n    for routes not explicitly defined in the specification.",
      "decorators": [],
      "arguments": [
        "self",
        "operation"
      ],
      "imports": [
        "logging",
        "typing",
        "collections.defaultdict",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.exceptions.ProblemException",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.middleware.abstract.RoutedAPI",
        "connexion.middleware.abstract.RoutedMiddleware",
        "connexion.operations.AbstractOperation",
        "connexion.security.SecurityHandlerFactory",
        "connexion.spec.Specification"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "SecurityOperation.from_operation",
          "body": "@classmethod\ndef from_operation(cls, operation: AbstractOperation, *, pythonic_params: bool, jsonifier: Jsonifier) -> 'AsyncOperation':\n    return cls(operation.function, jsonifier=jsonifier, operation_id=operation.operation_id, pythonic_params=pythonic_params)"
        }
      ]
    },
    {
      "name": "__init__",
      "module": "server_error",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\server_error.py",
      "line_number": 21,
      "end_line_number": 29,
      "source_code": "def __init__(\n        self,\n        next_app: ASGIApp,\n        handler: t.Optional[\n            t.Callable[[ConnexionRequest, Exception], MaybeAwaitable[ConnexionResponse]]\n        ] = None,\n    ):\n        handler = connexion_wrapper(handler) if handler else None\n        super().__init__(next_app, handler=handler)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "next_app",
        "handler"
      ],
      "imports": [
        "logging",
        "typing",
        "starlette.middleware.errors.ServerErrorMiddleware",
        "starlette.types.ASGIApp",
        "connexion.exceptions.InternalServerError",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.exceptions.connexion_wrapper",
        "connexion.types.MaybeAwaitable"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "connexion_wrapper",
          "body": "def connexion_wrapper(handler: t.Callable[[ConnexionRequest, Exception], MaybeAwaitable[ConnexionResponse]]) -> t.Callable[[StarletteRequest, Exception], t.Awaitable[StarletteResponse]]:\n    \"\"\"Wrapper that translates Starlette requests to Connexion requests before passing\n    them to the error handler, and translates the returned Connexion responses to\n    Starlette responses.\"\"\"\n\n    @functools.wraps(handler)\n    async def wrapper(request: StarletteRequest, exc: Exception) -> StarletteResponse:\n        request = ConnexionRequest.from_starlette_request(request)\n        if asyncio.iscoroutinefunction(handler):\n            response = await handler(request, exc)\n        else:\n            response = await run_in_threadpool(handler, request, exc)\n        while asyncio.iscoroutine(response):\n            response = await response\n        return StarletteResponse(content=response.body, status_code=response.status_code, media_type=response.mimetype, headers=response.headers)\n    return wrapper"
        }
      ]
    },
    {
      "name": "error_response",
      "module": "server_error",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\server_error.py",
      "line_number": 33,
      "end_line_number": 36,
      "source_code": "def error_response(_request: ConnexionRequest, exc: Exception) -> ConnexionResponse:\n        \"\"\"Default handler for any unhandled Exception\"\"\"\n        logger.error(\"%r\", exc, exc_info=exc)\n        return InternalServerError().to_problem()",
      "docstring": "Default handler for any unhandled Exception",
      "decorators": [
        "staticmethod",
        "connexion_wrapper"
      ],
      "arguments": [
        "_request",
        "exc"
      ],
      "imports": [
        "logging",
        "typing",
        "starlette.middleware.errors.ServerErrorMiddleware",
        "starlette.types.ASGIApp",
        "connexion.exceptions.InternalServerError",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.lifecycle.ConnexionResponse",
        "connexion.middleware.exceptions.connexion_wrapper",
        "connexion.types.MaybeAwaitable"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "swagger_ui",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\swagger_ui.py",
      "line_number": 29,
      "end_line_number": 52,
      "source_code": "def __init__(\n        self,\n        *args,\n        default: ASGIApp,\n        swagger_ui_options: t.Optional[SwaggerUIOptions] = None,\n        **kwargs\n    ):\n        super().__init__(*args, **kwargs)\n\n        self.router = Router(default=default)\n        self.options = SwaggerUIConfig(\n            swagger_ui_options, oas_version=self.specification.version\n        )\n\n        if self.options.openapi_spec_available:\n            self.add_openapi_json()\n            self.add_openapi_yaml()\n\n        if self.options.swagger_ui_available:\n            self.add_swagger_ui()\n\n        self._templates = Jinja2Templates(\n            directory=str(self.options.swagger_ui_template_dir)\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "json",
        "logging",
        "re",
        "typing",
        "contextvars.ContextVar",
        "starlette.requests.Request",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.routing.Router",
        "starlette.staticfiles.StaticFiles",
        "starlette.templating.Jinja2Templates",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.jsonifier.Jsonifier",
        "connexion.middleware.SpecMiddleware",
        "connexion.middleware.abstract.AbstractSpecAPI",
        "connexion.options.SwaggerUIConfig",
        "connexion.options.SwaggerUIOptions",
        "connexion.spec.Specification",
        "connexion.utils.yamldumper"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.add_openapi_json",
          "body": "def add_openapi_json(self):\n    \"\"\"\n        Adds openapi json to {base_path}/openapi.json\n             (or {base_path}/swagger.json for swagger2)\n        \"\"\"\n    logger.info('Adding spec json: %s%s', self.base_path, self.options.openapi_spec_path)\n    self.router.add_route(methods=['GET'], path=self.options.openapi_spec_path, endpoint=self._get_openapi_json)"
        },
        {
          "name": "self.add_openapi_yaml",
          "body": "def add_openapi_yaml(self):\n    \"\"\"\n        Adds openapi json to {base_path}/openapi.json\n             (or {base_path}/swagger.json for swagger2)\n        \"\"\"\n    if not self.options.openapi_spec_path.endswith('json'):\n        return\n    openapi_spec_path_yaml = self.options.openapi_spec_path[:-len('json')] + 'yaml'\n    logger.debug('Adding spec yaml: %s/%s', self.base_path, openapi_spec_path_yaml)\n    self.router.add_route(methods=['GET'], path=openapi_spec_path_yaml, endpoint=self._get_openapi_yaml)"
        },
        {
          "name": "self.add_swagger_ui",
          "body": "def add_swagger_ui(self):\n    \"\"\"\n        Adds swagger ui to {base_path}/ui/\n        \"\"\"\n    console_ui_path = self.options.swagger_ui_path.strip().rstrip('/')\n    logger.debug('Adding swagger-ui: %s%s/', self.base_path, console_ui_path)\n    for path in (console_ui_path + '/', console_ui_path + '/index.html'):\n        self.router.add_route(methods=['GET'], path=path, endpoint=self._get_swagger_ui_home)\n    if self.options.swagger_ui_config:\n        self.router.add_route(methods=['GET'], path=console_ui_path + '/swagger-ui-config.json', endpoint=self._get_swagger_ui_config)\n\n    async def redirect(request):\n        url = request.scope.get('root_path', '').rstrip('/')\n        url += console_ui_path\n        url += '/'\n        return RedirectResponse(url=url)\n    self.router.add_route(methods=['GET'], path=console_ui_path, endpoint=redirect)\n    self.router.mount(path=console_ui_path, app=StaticFiles(directory=str(self.options.swagger_ui_template_dir)), name='swagger_ui_static')"
        }
      ]
    },
    {
      "name": "normalize_string",
      "module": "swagger_ui",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\swagger_ui.py",
      "line_number": 55,
      "end_line_number": 56,
      "source_code": "def normalize_string(string):\n        return re.sub(r\"[^a-zA-Z0-9]\", \"_\", string.strip(\"/\"))",
      "docstring": null,
      "decorators": [
        "staticmethod"
      ],
      "arguments": [
        "string"
      ],
      "imports": [
        "json",
        "logging",
        "re",
        "typing",
        "contextvars.ContextVar",
        "starlette.requests.Request",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.routing.Router",
        "starlette.staticfiles.StaticFiles",
        "starlette.templating.Jinja2Templates",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.jsonifier.Jsonifier",
        "connexion.middleware.SpecMiddleware",
        "connexion.middleware.abstract.AbstractSpecAPI",
        "connexion.options.SwaggerUIConfig",
        "connexion.options.SwaggerUIOptions",
        "connexion.spec.Specification",
        "connexion.utils.yamldumper"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_base_path_for_prefix",
      "module": "swagger_ui",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\swagger_ui.py",
      "line_number": 58,
      "end_line_number": 64,
      "source_code": "def _base_path_for_prefix(self, request: StarletteRequest) -> str:\n        \"\"\"\n        returns a modified basePath which includes the incoming root_path.\n        \"\"\"\n        return request.scope.get(\n            \"route_root_path\", request.scope.get(\"root_path\", \"\")\n        ).rstrip(\"/\")",
      "docstring": "returns a modified basePath which includes the incoming root_path.",
      "decorators": [],
      "arguments": [
        "self",
        "request"
      ],
      "imports": [
        "json",
        "logging",
        "re",
        "typing",
        "contextvars.ContextVar",
        "starlette.requests.Request",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.routing.Router",
        "starlette.staticfiles.StaticFiles",
        "starlette.templating.Jinja2Templates",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.jsonifier.Jsonifier",
        "connexion.middleware.SpecMiddleware",
        "connexion.middleware.abstract.AbstractSpecAPI",
        "connexion.options.SwaggerUIConfig",
        "connexion.options.SwaggerUIOptions",
        "connexion.spec.Specification",
        "connexion.utils.yamldumper"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "request.scope.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "request.scope.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "_spec_for_prefix",
      "module": "swagger_ui",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\swagger_ui.py",
      "line_number": 66,
      "end_line_number": 73,
      "source_code": "def _spec_for_prefix(self, request) -> dict:\n        \"\"\"\n        returns a spec with a modified basePath / servers block\n        which corresponds to the incoming request path.\n        This is needed when behind a path-altering reverse proxy.\n        \"\"\"\n        base_path = self._base_path_for_prefix(request)\n        return self.specification.with_base_path(base_path).raw",
      "docstring": "returns a spec with a modified basePath / servers block\nwhich corresponds to the incoming request path.\nThis is needed when behind a path-altering reverse proxy.",
      "decorators": [],
      "arguments": [
        "self",
        "request"
      ],
      "imports": [
        "json",
        "logging",
        "re",
        "typing",
        "contextvars.ContextVar",
        "starlette.requests.Request",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.routing.Router",
        "starlette.staticfiles.StaticFiles",
        "starlette.templating.Jinja2Templates",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.jsonifier.Jsonifier",
        "connexion.middleware.SpecMiddleware",
        "connexion.middleware.abstract.AbstractSpecAPI",
        "connexion.options.SwaggerUIConfig",
        "connexion.options.SwaggerUIOptions",
        "connexion.spec.Specification",
        "connexion.utils.yamldumper"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._base_path_for_prefix",
          "body": "def _base_path_for_prefix(self, request: StarletteRequest) -> str:\n    \"\"\"\n        returns a modified basePath which includes the incoming root_path.\n        \"\"\"\n    return request.scope.get('route_root_path', request.scope.get('root_path', '')).rstrip('/')"
        },
        {
          "name": "self.specification.with_base_path",
          "body": "def with_base_path(self, base_path):\n    new_spec = self.clone()\n    new_spec.base_path = base_path\n    return new_spec"
        }
      ]
    },
    {
      "name": "add_openapi_json",
      "module": "swagger_ui",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\swagger_ui.py",
      "line_number": 75,
      "end_line_number": 87,
      "source_code": "def add_openapi_json(self):\n        \"\"\"\n        Adds openapi json to {base_path}/openapi.json\n             (or {base_path}/swagger.json for swagger2)\n        \"\"\"\n        logger.info(\n            \"Adding spec json: %s%s\", self.base_path, self.options.openapi_spec_path\n        )\n        self.router.add_route(\n            methods=[\"GET\"],\n            path=self.options.openapi_spec_path,\n            endpoint=self._get_openapi_json,\n        )",
      "docstring": "Adds openapi json to {base_path}/openapi.json\n     (or {base_path}/swagger.json for swagger2)",
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "json",
        "logging",
        "re",
        "typing",
        "contextvars.ContextVar",
        "starlette.requests.Request",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.routing.Router",
        "starlette.staticfiles.StaticFiles",
        "starlette.templating.Jinja2Templates",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.jsonifier.Jsonifier",
        "connexion.middleware.SpecMiddleware",
        "connexion.middleware.abstract.AbstractSpecAPI",
        "connexion.options.SwaggerUIConfig",
        "connexion.options.SwaggerUIOptions",
        "connexion.spec.Specification",
        "connexion.utils.yamldumper"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "add_openapi_yaml",
      "module": "swagger_ui",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\swagger_ui.py",
      "line_number": 89,
      "end_line_number": 103,
      "source_code": "def add_openapi_yaml(self):\n        \"\"\"\n        Adds openapi json to {base_path}/openapi.json\n             (or {base_path}/swagger.json for swagger2)\n        \"\"\"\n        if not self.options.openapi_spec_path.endswith(\"json\"):\n            return\n\n        openapi_spec_path_yaml = self.options.openapi_spec_path[: -len(\"json\")] + \"yaml\"\n        logger.debug(\"Adding spec yaml: %s/%s\", self.base_path, openapi_spec_path_yaml)\n        self.router.add_route(\n            methods=[\"GET\"],\n            path=openapi_spec_path_yaml,\n            endpoint=self._get_openapi_yaml,\n        )",
      "docstring": "Adds openapi json to {base_path}/openapi.json\n     (or {base_path}/swagger.json for swagger2)",
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "json",
        "logging",
        "re",
        "typing",
        "contextvars.ContextVar",
        "starlette.requests.Request",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.routing.Router",
        "starlette.staticfiles.StaticFiles",
        "starlette.templating.Jinja2Templates",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.jsonifier.Jsonifier",
        "connexion.middleware.SpecMiddleware",
        "connexion.middleware.abstract.AbstractSpecAPI",
        "connexion.options.SwaggerUIConfig",
        "connexion.options.SwaggerUIOptions",
        "connexion.spec.Specification",
        "connexion.utils.yamldumper"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "add_swagger_ui",
      "module": "swagger_ui",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\swagger_ui.py",
      "line_number": 122,
      "end_line_number": 162,
      "source_code": "def add_swagger_ui(self):\n        \"\"\"\n        Adds swagger ui to {base_path}/ui/\n        \"\"\"\n        console_ui_path = self.options.swagger_ui_path.strip().rstrip(\"/\")\n        logger.debug(\"Adding swagger-ui: %s%s/\", self.base_path, console_ui_path)\n\n        for path in (\n            console_ui_path + \"/\",\n            console_ui_path + \"/index.html\",\n        ):\n            self.router.add_route(\n                methods=[\"GET\"], path=path, endpoint=self._get_swagger_ui_home\n            )\n\n        if self.options.swagger_ui_config:\n            self.router.add_route(\n                methods=[\"GET\"],\n                path=console_ui_path + \"/swagger-ui-config.json\",\n                endpoint=self._get_swagger_ui_config,\n            )\n\n        # we have to add an explicit redirect instead of relying on the\n        # normalize_path_middleware because we also serve static files\n        # from this dir (below)\n\n        async def redirect(request):\n            url = request.scope.get(\"root_path\", \"\").rstrip(\"/\")\n            url += console_ui_path\n            url += \"/\"\n            return RedirectResponse(url=url)\n\n        self.router.add_route(methods=[\"GET\"], path=console_ui_path, endpoint=redirect)\n\n        # this route will match and get a permission error when trying to\n        # serve index.html, so we add the redirect above.\n        self.router.mount(\n            path=console_ui_path,\n            app=StaticFiles(directory=str(self.options.swagger_ui_template_dir)),\n            name=\"swagger_ui_static\",\n        )",
      "docstring": "Adds swagger ui to {base_path}/ui/",
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "json",
        "logging",
        "re",
        "typing",
        "contextvars.ContextVar",
        "starlette.requests.Request",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.routing.Router",
        "starlette.staticfiles.StaticFiles",
        "starlette.templating.Jinja2Templates",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.jsonifier.Jsonifier",
        "connexion.middleware.SpecMiddleware",
        "connexion.middleware.abstract.AbstractSpecAPI",
        "connexion.options.SwaggerUIConfig",
        "connexion.options.SwaggerUIOptions",
        "connexion.spec.Specification",
        "connexion.utils.yamldumper"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "request.scope.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "__init__",
      "module": "swagger_ui",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\swagger_ui.py",
      "line_number": 186,
      "end_line_number": 193,
      "source_code": "def __init__(self, app: ASGIApp) -> None:\n        \"\"\"Middleware that hosts a swagger UI.\n\n        :param app: app to wrap in middleware.\n        \"\"\"\n        self.app = app\n        # Set default to pass unknown routes to next app\n        self.router = Router(default=self.default_fn)",
      "docstring": "Middleware that hosts a swagger UI.\n\n:param app: app to wrap in middleware.",
      "decorators": [],
      "arguments": [
        "self",
        "app"
      ],
      "imports": [
        "json",
        "logging",
        "re",
        "typing",
        "contextvars.ContextVar",
        "starlette.requests.Request",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.routing.Router",
        "starlette.staticfiles.StaticFiles",
        "starlette.templating.Jinja2Templates",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.jsonifier.Jsonifier",
        "connexion.middleware.SpecMiddleware",
        "connexion.middleware.abstract.AbstractSpecAPI",
        "connexion.options.SwaggerUIConfig",
        "connexion.options.SwaggerUIOptions",
        "connexion.spec.Specification",
        "connexion.utils.yamldumper"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "add_api",
      "module": "swagger_ui",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\middleware\\swagger_ui.py",
      "line_number": 195,
      "end_line_number": 215,
      "source_code": "def add_api(\n        self,\n        specification: Specification,\n        base_path: t.Optional[str] = None,\n        arguments: t.Optional[dict] = None,\n        **kwargs\n    ) -> None:\n        \"\"\"Add an API to the router based on a OpenAPI spec.\n\n        :param specification: OpenAPI spec.\n        :param base_path: Base path where to add this API.\n        :param arguments: Jinja arguments to replace in the spec.\n        \"\"\"\n        api = SwaggerUIAPI(\n            specification,\n            base_path=base_path,\n            arguments=arguments,\n            default=self.default_fn,\n            **kwargs\n        )\n        self.router.mount(api.base_path, app=api.router)",
      "docstring": "Add an API to the router based on a OpenAPI spec.\n\n:param specification: OpenAPI spec.\n:param base_path: Base path where to add this API.\n:param arguments: Jinja arguments to replace in the spec.",
      "decorators": [],
      "arguments": [
        "self",
        "specification",
        "base_path",
        "arguments"
      ],
      "imports": [
        "json",
        "logging",
        "re",
        "typing",
        "contextvars.ContextVar",
        "starlette.requests.Request",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.routing.Router",
        "starlette.staticfiles.StaticFiles",
        "starlette.templating.Jinja2Templates",
        "starlette.types.ASGIApp",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.jsonifier.Jsonifier",
        "connexion.middleware.SpecMiddleware",
        "connexion.middleware.abstract.AbstractSpecAPI",
        "connexion.options.SwaggerUIConfig",
        "connexion.options.SwaggerUIOptions",
        "connexion.spec.Specification",
        "connexion.utils.yamldumper"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\abstract.py",
      "line_number": 36,
      "end_line_number": 78,
      "source_code": "def __init__(\n        self,\n        method,\n        path,\n        operation,\n        resolver,\n        app_security=None,\n        security_schemes=None,\n        randomize_endpoint=None,\n        uri_parser_class=None,\n    ):\n        \"\"\"\n        :param method: HTTP method\n        :type method: str\n        :param path:\n        :type path: str\n        :param operation: swagger operation object\n        :type operation: dict\n        :param resolver: Callable that maps operationID to a function\n        :param app_security: list of security rules the application uses by default\n        :type app_security: list\n        :param security_schemes: `Security Definitions Object\n            <https://github.com/swagger-api/swagger-spec/blob/master/versions/2.0.md#security-definitions-object>`_\n        :type security_schemes: dict\n        :param randomize_endpoint: number of random characters to append to operation name\n        :type randomize_endpoint: integer\n        :param uri_parser_class: class to use for uri parsing\n        :type uri_parser_class: AbstractURIParser\n        \"\"\"\n        self._method = method\n        self._path = path\n        self._operation = operation\n        self._resolver = resolver\n        self._security = operation.get(\"security\", app_security)\n        self._security_schemes = security_schemes\n        self._uri_parser_class = uri_parser_class\n        self._randomize_endpoint = randomize_endpoint\n        self._operation_id = self._operation.get(\"operationId\")\n\n        self._resolution = resolver.resolve(self)\n        self._operation_id = self._resolution.operation_id\n\n        self._responses = self._operation.get(\"responses\", {})",
      "docstring": ":param method: HTTP method\n:type method: str\n:param path:\n:type path: str\n:param operation: swagger operation object\n:type operation: dict\n:param resolver: Callable that maps operationID to a function\n:param app_security: list of security rules the application uses by default\n:type app_security: list\n:param security_schemes: `Security Definitions Object\n    <https://github.com/swagger-api/swagger-spec/blob/master/versions/2.0.md#security-definitions-object>`_\n:type security_schemes: dict\n:param randomize_endpoint: number of random characters to append to operation name\n:type randomize_endpoint: integer\n:param uri_parser_class: class to use for uri parsing\n:type uri_parser_class: AbstractURIParser",
      "decorators": [],
      "arguments": [
        "self",
        "method",
        "path",
        "operation",
        "resolver",
        "app_security",
        "security_schemes",
        "randomize_endpoint",
        "uri_parser_class"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "connexion.utils.all_json"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "operation.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "self._operation.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "resolver.resolve",
          "body": "def resolve(self, operation):\n    \"\"\"\n        Mock operation resolver\n\n        :type operation: connexion.operations.AbstractOperation\n        \"\"\"\n    operation_id = self.resolve_operation_id(operation)\n    if not operation_id:\n        operation_id = f'mock-{self._operation_id_counter}'\n        self._operation_id_counter += 1\n    mock_func = functools.partial(self.mock_operation, operation=operation)\n    if self.mock_all:\n        func = mock_func\n    else:\n        try:\n            func = self.resolve_function_from_operation_id(operation_id)\n            msg = \"... Successfully resolved operationId '{}'! Mock is *not* used for this operation.\".format(operation_id)\n            logger.debug(msg)\n        except ResolverError as resolution_error:\n            logger.debug('... {}! Mock function is used for this operation.'.format(resolution_error.args[0].capitalize()))\n            func = mock_func\n    return Resolution(func, operation_id)"
        },
        {
          "name": "self._operation.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "from_spec",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\abstract.py",
      "line_number": 82,
      "end_line_number": 83,
      "source_code": "def from_spec(cls, spec, *args, path, method, resolver, **kwargs):\n        pass",
      "docstring": null,
      "decorators": [
        "classmethod",
        "abc.abstractmethod"
      ],
      "arguments": [
        "cls",
        "spec"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "connexion.utils.all_json"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "method",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\abstract.py",
      "line_number": 86,
      "end_line_number": 90,
      "source_code": "def method(self):\n        \"\"\"\n        The HTTP method for this operation (ex. GET, POST)\n        \"\"\"\n        return self._method",
      "docstring": "The HTTP method for this operation (ex. GET, POST)",
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "connexion.utils.all_json"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "request_body",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\abstract.py",
      "line_number": 93,
      "end_line_number": 94,
      "source_code": "def request_body(self):\n        \"\"\"The request body for this operation\"\"\"",
      "docstring": "The request body for this operation",
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "connexion.utils.all_json"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "is_request_body_defined",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\abstract.py",
      "line_number": 97,
      "end_line_number": 99,
      "source_code": "def is_request_body_defined(self) -> bool:\n        \"\"\"Whether the request body is defined for this operation\"\"\"\n        return self.request_body != {}",
      "docstring": "Whether the request body is defined for this operation",
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "connexion.utils.all_json"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "path",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\abstract.py",
      "line_number": 102,
      "end_line_number": 106,
      "source_code": "def path(self):\n        \"\"\"\n        The path of the operation, relative to the API base path\n        \"\"\"\n        return self._path",
      "docstring": "The path of the operation, relative to the API base path",
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "connexion.utils.all_json"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "security",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\abstract.py",
      "line_number": 109,
      "end_line_number": 110,
      "source_code": "def security(self):\n        return self._security",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "connexion.utils.all_json"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "security_schemes",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\abstract.py",
      "line_number": 113,
      "end_line_number": 114,
      "source_code": "def security_schemes(self):\n        return self._security_schemes",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "connexion.utils.all_json"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "responses",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\abstract.py",
      "line_number": 117,
      "end_line_number": 121,
      "source_code": "def responses(self):\n        \"\"\"\n        Returns the responses for this operation\n        \"\"\"\n        return self._responses",
      "docstring": "Returns the responses for this operation",
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "connexion.utils.all_json"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "operation_id",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\abstract.py",
      "line_number": 124,
      "end_line_number": 128,
      "source_code": "def operation_id(self):\n        \"\"\"\n        The operation id used to identify the operation internally to the app\n        \"\"\"\n        return self._operation_id",
      "docstring": "The operation id used to identify the operation internally to the app",
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "connexion.utils.all_json"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "randomize_endpoint",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\abstract.py",
      "line_number": 131,
      "end_line_number": 135,
      "source_code": "def randomize_endpoint(self):\n        \"\"\"\n        number of random digits to generate and append to the operation_id.\n        \"\"\"\n        return self._randomize_endpoint",
      "docstring": "number of random digits to generate and append to the operation_id.",
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "connexion.utils.all_json"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "router_controller",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\abstract.py",
      "line_number": 138,
      "end_line_number": 142,
      "source_code": "def router_controller(self):\n        \"\"\"\n        The router controller to use (python module where handler functions live)\n        \"\"\"\n        return self._router_controller",
      "docstring": "The router controller to use (python module where handler functions live)",
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "connexion.utils.all_json"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "parameters",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\abstract.py",
      "line_number": 146,
      "end_line_number": 149,
      "source_code": "def parameters(self):\n        \"\"\"\n        Returns the parameters for this operation\n        \"\"\"",
      "docstring": "Returns the parameters for this operation",
      "decorators": [
        "property",
        "abc.abstractmethod"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "connexion.utils.all_json"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "produces",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\abstract.py",
      "line_number": 153,
      "end_line_number": 156,
      "source_code": "def produces(self):\n        \"\"\"\n        Content-Types that the operation produces\n        \"\"\"",
      "docstring": "Content-Types that the operation produces",
      "decorators": [
        "property",
        "abc.abstractmethod"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "connexion.utils.all_json"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "consumes",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\abstract.py",
      "line_number": 160,
      "end_line_number": 163,
      "source_code": "def consumes(self):\n        \"\"\"\n        Content-Types that the operation consumes\n        \"\"\"",
      "docstring": "Content-Types that the operation consumes",
      "decorators": [
        "property",
        "abc.abstractmethod"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "connexion.utils.all_json"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "body_name",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\abstract.py",
      "line_number": 166,
      "end_line_number": 169,
      "source_code": "def body_name(self, content_type: str) -> str:\n        \"\"\"\n        Name of the body in the spec.\n        \"\"\"",
      "docstring": "Name of the body in the spec.",
      "decorators": [
        "abc.abstractmethod"
      ],
      "arguments": [
        "self",
        "content_type"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "connexion.utils.all_json"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "body_schema",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\abstract.py",
      "line_number": 172,
      "end_line_number": 175,
      "source_code": "def body_schema(self, content_type: t.Optional[str] = None) -> dict:\n        \"\"\"\n        The body schema definition for this operation.\n        \"\"\"",
      "docstring": "The body schema definition for this operation.",
      "decorators": [
        "abc.abstractmethod"
      ],
      "arguments": [
        "self",
        "content_type"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "connexion.utils.all_json"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "body_definition",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\abstract.py",
      "line_number": 178,
      "end_line_number": 182,
      "source_code": "def body_definition(self, content_type: t.Optional[str] = None) -> dict:\n        \"\"\"\n        The body definition for this operation.\n        :rtype: dict\n        \"\"\"",
      "docstring": "The body definition for this operation.\n:rtype: dict",
      "decorators": [
        "abc.abstractmethod"
      ],
      "arguments": [
        "self",
        "content_type"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "connexion.utils.all_json"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "response_definition",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\abstract.py",
      "line_number": 184,
      "end_line_number": 191,
      "source_code": "def response_definition(self, status_code=None, content_type=None):\n        \"\"\"\n        response definition for this endpoint\n        \"\"\"\n        response_definition = self.responses.get(\n            str(status_code), self.responses.get(\"default\", {})\n        )\n        return response_definition",
      "docstring": "response definition for this endpoint",
      "decorators": [],
      "arguments": [
        "self",
        "status_code",
        "content_type"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "connexion.utils.all_json"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.responses.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "self.responses.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "response_schema",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\abstract.py",
      "line_number": 194,
      "end_line_number": 197,
      "source_code": "def response_schema(self, status_code=None, content_type=None):\n        \"\"\"\n        response schema for this endpoint\n        \"\"\"",
      "docstring": "response schema for this endpoint",
      "decorators": [
        "abc.abstractmethod"
      ],
      "arguments": [
        "self",
        "status_code",
        "content_type"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "connexion.utils.all_json"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "example_response",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\abstract.py",
      "line_number": 200,
      "end_line_number": 203,
      "source_code": "def example_response(self, status_code=None, content_type=None):\n        \"\"\"\n        Returns an example from the spec\n        \"\"\"",
      "docstring": "Returns an example from the spec",
      "decorators": [
        "abc.abstractmethod"
      ],
      "arguments": [
        "self",
        "status_code",
        "content_type"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "connexion.utils.all_json"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "get_path_parameter_types",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\abstract.py",
      "line_number": 206,
      "end_line_number": 209,
      "source_code": "def get_path_parameter_types(self):\n        \"\"\"\n        Returns the types for parameters in the path\n        \"\"\"",
      "docstring": "Returns the types for parameters in the path",
      "decorators": [
        "abc.abstractmethod"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "connexion.utils.all_json"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "with_definitions",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\abstract.py",
      "line_number": 212,
      "end_line_number": 217,
      "source_code": "def with_definitions(self, schema):\n        \"\"\"\n        Returns the given schema, but with the definitions from the spec\n        attached. This allows any remaining references to be resolved by a\n        validator (for example).\n        \"\"\"",
      "docstring": "Returns the given schema, but with the definitions from the spec\nattached. This allows any remaining references to be resolved by a\nvalidator (for example).",
      "decorators": [
        "abc.abstractmethod"
      ],
      "arguments": [
        "self",
        "schema"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "connexion.utils.all_json"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "get_mimetype",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\abstract.py",
      "line_number": 219,
      "end_line_number": 235,
      "source_code": "def get_mimetype(self):\n        \"\"\"\n        If the endpoint has no 'produces' then the default is\n        'application/json'.\n\n        :rtype str\n        \"\"\"\n        # TODO: don't default\n        if all_json(self.produces):\n            try:\n                return self.produces[0]\n            except IndexError:\n                return DEFAULT_MIMETYPE\n        elif len(self.produces) == 1:\n            return self.produces[0]\n        else:\n            return DEFAULT_MIMETYPE",
      "docstring": "If the endpoint has no 'produces' then the default is\n'application/json'.\n\n:rtype str",
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "connexion.utils.all_json"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "all_json",
          "body": "def all_json(mimetypes):\n    \"\"\"\n    Returns True if all mimetypes are serialized with json\n\n    :type mimetypes: list\n    :rtype: bool\n\n    >>> all_json(['application/json'])\n    True\n    >>> all_json(['application/x.custom+json'])\n    True\n    >>> all_json([])\n    True\n    >>> all_json(['application/xml'])\n    False\n    >>> all_json(['text/json'])\n    False\n    >>> all_json(['application/json', 'other/type'])\n    False\n    >>> all_json(['application/json', 'application/x.custom+json'])\n    True\n    \"\"\"\n    return all((is_json_mimetype(mimetype) for mimetype in mimetypes))"
        }
      ]
    },
    {
      "name": "uri_parser_class",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\abstract.py",
      "line_number": 238,
      "end_line_number": 242,
      "source_code": "def uri_parser_class(self):\n        \"\"\"\n        The uri parser class for this operation.\n        \"\"\"\n        return self._uri_parser_class",
      "docstring": "The uri parser class for this operation.",
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "connexion.utils.all_json"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "function",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\abstract.py",
      "line_number": 245,
      "end_line_number": 251,
      "source_code": "def function(self):\n        \"\"\"\n        Resolved function.\n\n        :rtype: types.FunctionType\n        \"\"\"\n        return self._resolution.function",
      "docstring": "Resolved function.\n\n:rtype: types.FunctionType",
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "abc",
        "logging",
        "typing",
        "connexion.utils.all_json"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "openapi",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\openapi.py",
      "line_number": 23,
      "end_line_number": 101,
      "source_code": "def __init__(\n        self,\n        method,\n        path,\n        operation,\n        resolver,\n        path_parameters=None,\n        app_security=None,\n        security_schemes=None,\n        components=None,\n        randomize_endpoint=None,\n        uri_parser_class=None,\n    ):\n        \"\"\"\n        This class uses the OperationID identify the module and function that will handle the operation\n\n        From Swagger Specification:\n\n        **OperationID**\n\n        A friendly name for the operation. The id MUST be unique among all operations described in the API.\n        Tools and libraries MAY use the operation id to uniquely identify an operation.\n\n        :param method: HTTP method\n        :type method: str\n        :param path:\n        :type path: str\n        :param operation: swagger operation object\n        :type operation: dict\n        :param resolver: Callable that maps operationID to a function\n        :param path_parameters: Parameters defined in the path level\n        :type path_parameters: list\n        :param app_security: list of security rules the application uses by default\n        :type app_security: list\n        :param security_schemes: `Security Definitions Object\n            <https://github.com/swagger-api/swagger-spec/blob/master/versions/2.0.md#security-definitions-object>`_\n        :type security_schemes: dict\n        :param components: `Components Object\n            <https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.1.md#componentsObject>`_\n        :type components: dict\n        :param randomize_endpoint: number of random characters to append to operation name\n        :type randomize_endpoint: integer\n        :param uri_parser_class: class to use for uri parsing\n        :type uri_parser_class: AbstractURIParser\n        \"\"\"\n        self.components = components or {}\n\n        uri_parser_class = uri_parser_class or OpenAPIURIParser\n\n        self._router_controller = operation.get(\"x-openapi-router-controller\")\n\n        super().__init__(\n            method=method,\n            path=path,\n            operation=operation,\n            resolver=resolver,\n            app_security=app_security,\n            security_schemes=security_schemes,\n            randomize_endpoint=randomize_endpoint,\n            uri_parser_class=uri_parser_class,\n        )\n\n        self._parameters = operation.get(\"parameters\", [])\n        if path_parameters:\n            self._parameters += path_parameters\n\n        self._responses = operation.get(\"responses\", {})\n\n        # TODO figure out how to support multiple mimetypes\n        # NOTE we currently just combine all of the possible mimetypes,\n        #      but we need to refactor to support mimetypes by response code\n        response_content_types = []\n        for _, defn in self._responses.items():\n            response_content_types += defn.get(\"content\", {}).keys()\n        self._produces = response_content_types\n        self._consumes = None\n\n        logger.debug(\"consumes: %s\" % self.consumes)\n        logger.debug(\"produces: %s\" % self.produces)",
      "docstring": "This class uses the OperationID identify the module and function that will handle the operation\n\nFrom Swagger Specification:\n\n**OperationID**\n\nA friendly name for the operation. The id MUST be unique among all operations described in the API.\nTools and libraries MAY use the operation id to uniquely identify an operation.\n\n:param method: HTTP method\n:type method: str\n:param path:\n:type path: str\n:param operation: swagger operation object\n:type operation: dict\n:param resolver: Callable that maps operationID to a function\n:param path_parameters: Parameters defined in the path level\n:type path_parameters: list\n:param app_security: list of security rules the application uses by default\n:type app_security: list\n:param security_schemes: `Security Definitions Object\n    <https://github.com/swagger-api/swagger-spec/blob/master/versions/2.0.md#security-definitions-object>`_\n:type security_schemes: dict\n:param components: `Components Object\n    <https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.1.md#componentsObject>`_\n:type components: dict\n:param randomize_endpoint: number of random characters to append to operation name\n:type randomize_endpoint: integer\n:param uri_parser_class: class to use for uri parsing\n:type uri_parser_class: AbstractURIParser",
      "decorators": [],
      "arguments": [
        "self",
        "method",
        "path",
        "operation",
        "resolver",
        "path_parameters",
        "app_security",
        "security_schemes",
        "components",
        "randomize_endpoint",
        "uri_parser_class"
      ],
      "imports": [
        "logging",
        "typing",
        "http.HTTPStatus",
        "connexion.datastructures.MediaTypeDict",
        "connexion.datastructures.NoContent",
        "connexion.operations.abstract.AbstractOperation",
        "connexion.uri_parsing.OpenAPIURIParser",
        "connexion.utils.build_example_from_schema",
        "connexion.utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "operation.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "operation.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "operation.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "defn.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "from_spec",
      "module": "openapi",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\openapi.py",
      "line_number": 104,
      "end_line_number": 116,
      "source_code": "def from_spec(cls, spec, *args, path, method, resolver, **kwargs):\n        return cls(\n            method,\n            path,\n            spec.get_operation(path, method),\n            resolver=resolver,\n            path_parameters=spec.get_path_params(path),\n            app_security=spec.security,\n            security_schemes=spec.security_schemes,\n            components=spec.components,\n            *args,\n            **kwargs,\n        )",
      "docstring": null,
      "decorators": [
        "classmethod"
      ],
      "arguments": [
        "cls",
        "spec"
      ],
      "imports": [
        "logging",
        "typing",
        "http.HTTPStatus",
        "connexion.datastructures.MediaTypeDict",
        "connexion.datastructures.NoContent",
        "connexion.operations.abstract.AbstractOperation",
        "connexion.uri_parsing.OpenAPIURIParser",
        "connexion.utils.build_example_from_schema",
        "connexion.utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "spec.get_operation",
          "body": "def get_operation(self, path, method):\n    return deep_get(self._spec, ['paths', path, method])"
        },
        {
          "name": "spec.get_path_params",
          "body": "def get_path_params(self, path):\n    return deep_get(self._spec, ['paths', path]).get('parameters', [])"
        }
      ]
    },
    {
      "name": "request_body",
      "module": "openapi",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\openapi.py",
      "line_number": 119,
      "end_line_number": 120,
      "source_code": "def request_body(self):\n        return self._operation.get(\"requestBody\", {})",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "logging",
        "typing",
        "http.HTTPStatus",
        "connexion.datastructures.MediaTypeDict",
        "connexion.datastructures.NoContent",
        "connexion.operations.abstract.AbstractOperation",
        "connexion.uri_parsing.OpenAPIURIParser",
        "connexion.utils.build_example_from_schema",
        "connexion.utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._operation.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "parameters",
      "module": "openapi",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\openapi.py",
      "line_number": 123,
      "end_line_number": 124,
      "source_code": "def parameters(self):\n        return self._parameters",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "logging",
        "typing",
        "http.HTTPStatus",
        "connexion.datastructures.MediaTypeDict",
        "connexion.datastructures.NoContent",
        "connexion.operations.abstract.AbstractOperation",
        "connexion.uri_parsing.OpenAPIURIParser",
        "connexion.utils.build_example_from_schema",
        "connexion.utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "consumes",
      "module": "openapi",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\openapi.py",
      "line_number": 127,
      "end_line_number": 131,
      "source_code": "def consumes(self):\n        if self._consumes is None:\n            request_content = self.request_body.get(\"content\", {})\n            self._consumes = list(request_content.keys())\n        return self._consumes",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "logging",
        "typing",
        "http.HTTPStatus",
        "connexion.datastructures.MediaTypeDict",
        "connexion.datastructures.NoContent",
        "connexion.operations.abstract.AbstractOperation",
        "connexion.uri_parsing.OpenAPIURIParser",
        "connexion.utils.build_example_from_schema",
        "connexion.utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.request_body.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "produces",
      "module": "openapi",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\openapi.py",
      "line_number": 134,
      "end_line_number": 135,
      "source_code": "def produces(self):\n        return self._produces",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "logging",
        "typing",
        "http.HTTPStatus",
        "connexion.datastructures.MediaTypeDict",
        "connexion.datastructures.NoContent",
        "connexion.operations.abstract.AbstractOperation",
        "connexion.uri_parsing.OpenAPIURIParser",
        "connexion.utils.build_example_from_schema",
        "connexion.utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "with_definitions",
      "module": "openapi",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\openapi.py",
      "line_number": 137,
      "end_line_number": 141,
      "source_code": "def with_definitions(self, schema: dict):\n        if self.components:\n            schema.setdefault(\"schema\", {})\n            schema[\"schema\"][\"components\"] = self.components\n        return schema",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "schema"
      ],
      "imports": [
        "logging",
        "typing",
        "http.HTTPStatus",
        "connexion.datastructures.MediaTypeDict",
        "connexion.datastructures.NoContent",
        "connexion.operations.abstract.AbstractOperation",
        "connexion.uri_parsing.OpenAPIURIParser",
        "connexion.utils.build_example_from_schema",
        "connexion.utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "response_schema",
      "module": "openapi",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\openapi.py",
      "line_number": 143,
      "end_line_number": 149,
      "source_code": "def response_schema(self, status_code=None, content_type=None):\n        response_definition = self.response_definition(status_code, content_type)\n        content_definition = response_definition.get(\"content\", response_definition)\n        content_definition = content_definition.get(content_type, content_definition)\n        if \"schema\" in content_definition:\n            return self.with_definitions(content_definition).get(\"schema\", {})\n        return {}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "status_code",
        "content_type"
      ],
      "imports": [
        "logging",
        "typing",
        "http.HTTPStatus",
        "connexion.datastructures.MediaTypeDict",
        "connexion.datastructures.NoContent",
        "connexion.operations.abstract.AbstractOperation",
        "connexion.uri_parsing.OpenAPIURIParser",
        "connexion.utils.build_example_from_schema",
        "connexion.utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.response_definition",
          "body": "def response_definition(self, status_code=None, content_type=None):\n    \"\"\"\n        response definition for this endpoint\n        \"\"\"\n    response_definition = self.responses.get(str(status_code), self.responses.get('default', {}))\n    return response_definition"
        },
        {
          "name": "response_definition.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "content_definition.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "self.with_definitions",
          "body": "@abc.abstractmethod\ndef with_definitions(self, schema):\n    \"\"\"\n        Returns the given schema, but with the definitions from the spec\n        attached. This allows any remaining references to be resolved by a\n        validator (for example).\n        \"\"\""
        }
      ]
    },
    {
      "name": "example_response",
      "module": "openapi",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\openapi.py",
      "line_number": 151,
      "end_line_number": 200,
      "source_code": "def example_response(self, status_code=None, content_type=None):\n        \"\"\"\n        Returns example response from spec\n        \"\"\"\n        # simply use the first/lowest status code, this is probably 200 or 201\n        status_code = status_code or sorted(self._responses.keys())[0]\n\n        content_type = content_type or self.get_mimetype()\n        examples_path = [str(status_code), \"content\", content_type, \"examples\"]\n        example_path = [str(status_code), \"content\", content_type, \"example\"]\n        schema_example_path = [\n            str(status_code),\n            \"content\",\n            content_type,\n            \"schema\",\n            \"example\",\n        ]\n        schema_path = [str(status_code), \"content\", content_type, \"schema\"]\n\n        try:\n            status_code = int(status_code)\n        except ValueError:\n            status_code = 200\n\n        if status_code == HTTPStatus.NO_CONTENT:\n            return NoContent, status_code\n\n        try:\n            # TODO also use example header?\n            return (\n                list(deep_get(self._responses, examples_path).values())[0][\"value\"],\n                status_code,\n            )\n        except (KeyError, IndexError):\n            pass\n        try:\n            return (deep_get(self._responses, example_path), status_code)\n        except KeyError:\n            pass\n        try:\n            return (deep_get(self._responses, schema_example_path), status_code)\n        except KeyError:\n            pass\n\n        try:\n            schema = deep_get(self._responses, schema_path)\n        except KeyError:\n            return (\"No example response or response schema defined.\", status_code)\n\n        return (build_example_from_schema(schema), status_code)",
      "docstring": "Returns example response from spec",
      "decorators": [],
      "arguments": [
        "self",
        "status_code",
        "content_type"
      ],
      "imports": [
        "logging",
        "typing",
        "http.HTTPStatus",
        "connexion.datastructures.MediaTypeDict",
        "connexion.datastructures.NoContent",
        "connexion.operations.abstract.AbstractOperation",
        "connexion.uri_parsing.OpenAPIURIParser",
        "connexion.utils.build_example_from_schema",
        "connexion.utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.get_mimetype",
          "body": "def get_mimetype(self):\n    return 'dummy'"
        },
        {
          "name": "deep_get",
          "body": "def deep_get(obj, keys):\n    \"\"\"\n    Recurses through a nested object get a leaf value.\n\n    There are cases where the use of inheritance or polymorphism-- the use of allOf or\n    oneOf keywords-- will cause the obj to be a list. In this case the keys will\n    contain one or more strings containing integers.\n\n    :type obj: list or dict\n    :type keys: list of strings\n    \"\"\"\n    if not keys:\n        return obj\n    if isinstance(obj, list):\n        return deep_get(obj[int(keys[0])], keys[1:])\n    else:\n        return deep_get(obj[keys[0]], keys[1:])"
        },
        {
          "name": "build_example_from_schema",
          "body": "def build_example_from_schema(schema):\n    if 'example' in schema:\n        return schema['example']\n    if 'properties' in schema:\n        return {key: build_example_from_schema(value) for key, value in schema['properties'].items()}\n    if 'items' in schema:\n        min_item_count = schema.get('minItems', 0)\n        max_item_count = schema.get('maxItems')\n        if max_item_count is None or max_item_count >= min_item_count + 1:\n            item_count = min_item_count + 1\n        else:\n            item_count = min_item_count\n        return [build_example_from_schema(schema['items']) for n in range(item_count)]\n    try:\n        from jsf import JSF\n    except ImportError:\n        return None\n    faker = JSF(schema)\n    return faker.generate()"
        },
        {
          "name": "deep_get",
          "body": "def deep_get(obj, keys):\n    \"\"\"\n    Recurses through a nested object get a leaf value.\n\n    There are cases where the use of inheritance or polymorphism-- the use of allOf or\n    oneOf keywords-- will cause the obj to be a list. In this case the keys will\n    contain one or more strings containing integers.\n\n    :type obj: list or dict\n    :type keys: list of strings\n    \"\"\"\n    if not keys:\n        return obj\n    if isinstance(obj, list):\n        return deep_get(obj[int(keys[0])], keys[1:])\n    else:\n        return deep_get(obj[keys[0]], keys[1:])"
        },
        {
          "name": "deep_get",
          "body": "def deep_get(obj, keys):\n    \"\"\"\n    Recurses through a nested object get a leaf value.\n\n    There are cases where the use of inheritance or polymorphism-- the use of allOf or\n    oneOf keywords-- will cause the obj to be a list. In this case the keys will\n    contain one or more strings containing integers.\n\n    :type obj: list or dict\n    :type keys: list of strings\n    \"\"\"\n    if not keys:\n        return obj\n    if isinstance(obj, list):\n        return deep_get(obj[int(keys[0])], keys[1:])\n    else:\n        return deep_get(obj[keys[0]], keys[1:])"
        },
        {
          "name": "deep_get",
          "body": "def deep_get(obj, keys):\n    \"\"\"\n    Recurses through a nested object get a leaf value.\n\n    There are cases where the use of inheritance or polymorphism-- the use of allOf or\n    oneOf keywords-- will cause the obj to be a list. In this case the keys will\n    contain one or more strings containing integers.\n\n    :type obj: list or dict\n    :type keys: list of strings\n    \"\"\"\n    if not keys:\n        return obj\n    if isinstance(obj, list):\n        return deep_get(obj[int(keys[0])], keys[1:])\n    else:\n        return deep_get(obj[keys[0]], keys[1:])"
        }
      ]
    },
    {
      "name": "get_path_parameter_types",
      "module": "openapi",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\openapi.py",
      "line_number": 202,
      "end_line_number": 216,
      "source_code": "def get_path_parameter_types(self):\n        types = {}\n        path_parameters = (p for p in self.parameters if p[\"in\"] == \"path\")\n        for path_defn in path_parameters:\n            path_schema = path_defn[\"schema\"]\n            if (\n                path_schema.get(\"type\") == \"string\"\n                and path_schema.get(\"format\") == \"path\"\n            ):\n                # path is special case for type 'string'\n                path_type = \"path\"\n            else:\n                path_type = path_schema.get(\"type\")\n            types[path_defn[\"name\"]] = path_type\n        return types",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "logging",
        "typing",
        "http.HTTPStatus",
        "connexion.datastructures.MediaTypeDict",
        "connexion.datastructures.NoContent",
        "connexion.operations.abstract.AbstractOperation",
        "connexion.uri_parsing.OpenAPIURIParser",
        "connexion.utils.build_example_from_schema",
        "connexion.utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "path_schema.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "path_schema.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "path_schema.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "body_name",
      "module": "openapi",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\openapi.py",
      "line_number": 218,
      "end_line_number": 219,
      "source_code": "def body_name(self, _content_type: str) -> str:\n        return self.request_body.get(\"x-body-name\", \"body\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "_content_type"
      ],
      "imports": [
        "logging",
        "typing",
        "http.HTTPStatus",
        "connexion.datastructures.MediaTypeDict",
        "connexion.datastructures.NoContent",
        "connexion.operations.abstract.AbstractOperation",
        "connexion.uri_parsing.OpenAPIURIParser",
        "connexion.utils.build_example_from_schema",
        "connexion.utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.request_body.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "body_schema",
      "module": "openapi",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\openapi.py",
      "line_number": 221,
      "end_line_number": 225,
      "source_code": "def body_schema(self, content_type: t.Optional[str] = None) -> dict:\n        \"\"\"\n        The body schema definition for this operation.\n        \"\"\"\n        return self.body_definition(content_type).get(\"schema\", {})",
      "docstring": "The body schema definition for this operation.",
      "decorators": [],
      "arguments": [
        "self",
        "content_type"
      ],
      "imports": [
        "logging",
        "typing",
        "http.HTTPStatus",
        "connexion.datastructures.MediaTypeDict",
        "connexion.datastructures.NoContent",
        "connexion.operations.abstract.AbstractOperation",
        "connexion.uri_parsing.OpenAPIURIParser",
        "connexion.utils.build_example_from_schema",
        "connexion.utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.body_definition",
          "body": "@abc.abstractmethod\ndef body_definition(self, content_type: t.Optional[str]=None) -> dict:\n    \"\"\"\n        The body definition for this operation.\n        :rtype: dict\n        \"\"\""
        }
      ]
    },
    {
      "name": "body_definition",
      "module": "openapi",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\openapi.py",
      "line_number": 227,
      "end_line_number": 245,
      "source_code": "def body_definition(self, content_type: t.Optional[str] = None) -> dict:\n        \"\"\"\n        The body complete definition for this operation.\n\n        **There can be one \"body\" parameter at most.**\n        \"\"\"\n        if self.request_body:\n            if content_type is None:\n                # TODO: make content type required\n                content_type = self.consumes[0]\n            if len(self.consumes) > 1:\n                logger.warning(\n                    \"this operation accepts multiple content types, using %s\",\n                    content_type,\n                )\n            content_type_dict = MediaTypeDict(self.request_body.get(\"content\", {}))\n            res = content_type_dict.get(content_type, {})\n            return self.with_definitions(res)\n        return {}",
      "docstring": "The body complete definition for this operation.\n\n**There can be one \"body\" parameter at most.**",
      "decorators": [],
      "arguments": [
        "self",
        "content_type"
      ],
      "imports": [
        "logging",
        "typing",
        "http.HTTPStatus",
        "connexion.datastructures.MediaTypeDict",
        "connexion.datastructures.NoContent",
        "connexion.operations.abstract.AbstractOperation",
        "connexion.uri_parsing.OpenAPIURIParser",
        "connexion.utils.build_example_from_schema",
        "connexion.utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "content_type_dict.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "self.with_definitions",
          "body": "@abc.abstractmethod\ndef with_definitions(self, schema):\n    \"\"\"\n        Returns the given schema, but with the definitions from the spec\n        attached. This allows any remaining references to be resolved by a\n        validator (for example).\n        \"\"\""
        },
        {
          "name": "self.request_body.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "__init__",
      "module": "swagger2",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\swagger2.py",
      "line_number": 38,
      "end_line_number": 105,
      "source_code": "def __init__(\n        self,\n        method,\n        path,\n        operation,\n        resolver,\n        app_produces,\n        app_consumes,\n        path_parameters=None,\n        app_security=None,\n        security_schemes=None,\n        definitions=None,\n        randomize_endpoint=None,\n        uri_parser_class=None,\n    ):\n        \"\"\"\n        :param method: HTTP method\n        :type method: str\n        :param path: relative path to this operation\n        :type path: str\n        :param operation: swagger operation object\n        :type operation: dict\n        :param resolver: Callable that maps operationID to a function\n        :type resolver: resolver.Resolver\n        :param app_produces: list of content types the application can return by default\n        :type app_produces: list\n        :param app_consumes: list of content types the application consumes by default\n        :type app_consumes: list\n        :param path_parameters: Parameters defined in the path level\n        :type path_parameters: list\n        :param app_security: list of security rules the application uses by default\n        :type app_security: list\n        :param security_schemes: `Security Definitions Object\n            <https://github.com/swagger-api/swagger-spec/blob/master/versions/2.0.md#security-definitions-object>`_\n        :type security_schemes: dict\n        :param definitions: `Definitions Object\n            <https://github.com/swagger-api/swagger-spec/blob/master/versions/2.0.md#definitionsObject>`_\n        :type definitions: dict\n        :param randomize_endpoint: number of random characters to append to operation name\n        :type randomize_endpoint: integer\n        :param uri_parser_class: class to use for uri parsing\n        :type uri_parser_class: AbstractURIParser\n        \"\"\"\n        uri_parser_class = uri_parser_class or Swagger2URIParser\n\n        self._router_controller = operation.get(\"x-swagger-router-controller\")\n\n        super().__init__(\n            method=method,\n            path=path,\n            operation=operation,\n            resolver=resolver,\n            app_security=app_security,\n            security_schemes=security_schemes,\n            randomize_endpoint=randomize_endpoint,\n            uri_parser_class=uri_parser_class,\n        )\n\n        self._produces = operation.get(\"produces\", app_produces)\n        self._consumes = operation.get(\"consumes\", app_consumes)\n\n        self.definitions = definitions or {}\n\n        self._parameters = operation.get(\"parameters\", [])\n        if path_parameters:\n            self._parameters += path_parameters\n\n        self._responses = operation.get(\"responses\", {})",
      "docstring": ":param method: HTTP method\n:type method: str\n:param path: relative path to this operation\n:type path: str\n:param operation: swagger operation object\n:type operation: dict\n:param resolver: Callable that maps operationID to a function\n:type resolver: resolver.Resolver\n:param app_produces: list of content types the application can return by default\n:type app_produces: list\n:param app_consumes: list of content types the application consumes by default\n:type app_consumes: list\n:param path_parameters: Parameters defined in the path level\n:type path_parameters: list\n:param app_security: list of security rules the application uses by default\n:type app_security: list\n:param security_schemes: `Security Definitions Object\n    <https://github.com/swagger-api/swagger-spec/blob/master/versions/2.0.md#security-definitions-object>`_\n:type security_schemes: dict\n:param definitions: `Definitions Object\n    <https://github.com/swagger-api/swagger-spec/blob/master/versions/2.0.md#definitionsObject>`_\n:type definitions: dict\n:param randomize_endpoint: number of random characters to append to operation name\n:type randomize_endpoint: integer\n:param uri_parser_class: class to use for uri parsing\n:type uri_parser_class: AbstractURIParser",
      "decorators": [],
      "arguments": [
        "self",
        "method",
        "path",
        "operation",
        "resolver",
        "app_produces",
        "app_consumes",
        "path_parameters",
        "app_security",
        "security_schemes",
        "definitions",
        "randomize_endpoint",
        "uri_parser_class"
      ],
      "imports": [
        "logging",
        "typing",
        "http.HTTPStatus",
        "connexion.datastructures.NoContent",
        "connexion.exceptions.InvalidSpecification",
        "connexion.operations.abstract.AbstractOperation",
        "connexion.uri_parsing.Swagger2URIParser",
        "connexion.utils.build_example_from_schema",
        "connexion.utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "operation.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "operation.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "operation.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "operation.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "operation.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "from_spec",
      "module": "swagger2",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\swagger2.py",
      "line_number": 108,
      "end_line_number": 122,
      "source_code": "def from_spec(cls, spec, *args, path, method, resolver, **kwargs):\n        return cls(\n            method,\n            path,\n            spec.get_operation(path, method),\n            resolver=resolver,\n            path_parameters=spec.get_path_params(path),\n            app_produces=spec.produces,\n            app_consumes=spec.consumes,\n            app_security=spec.security,\n            security_schemes=spec.security_schemes,\n            definitions=spec.definitions,\n            *args,\n            **kwargs,\n        )",
      "docstring": null,
      "decorators": [
        "classmethod"
      ],
      "arguments": [
        "cls",
        "spec"
      ],
      "imports": [
        "logging",
        "typing",
        "http.HTTPStatus",
        "connexion.datastructures.NoContent",
        "connexion.exceptions.InvalidSpecification",
        "connexion.operations.abstract.AbstractOperation",
        "connexion.uri_parsing.Swagger2URIParser",
        "connexion.utils.build_example_from_schema",
        "connexion.utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "spec.get_operation",
          "body": "def get_operation(self, path, method):\n    return deep_get(self._spec, ['paths', path, method])"
        },
        {
          "name": "spec.get_path_params",
          "body": "def get_path_params(self, path):\n    return deep_get(self._spec, ['paths', path]).get('parameters', [])"
        }
      ]
    },
    {
      "name": "request_body",
      "module": "swagger2",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\swagger2.py",
      "line_number": 125,
      "end_line_number": 152,
      "source_code": "def request_body(self) -> dict:\n        if not hasattr(self, \"_request_body\"):\n            body_params = []\n            form_params = []\n            for parameter in self.parameters:\n                if parameter[\"in\"] == \"body\":\n                    body_params.append(parameter)\n                elif parameter[\"in\"] == \"formData\":\n                    form_params.append(parameter)\n\n            if len(body_params) > 1:\n                raise InvalidSpecification(\n                    f\"{self.method} {self.path}: There can be one 'body' parameter at most\"\n                )\n\n            if body_params and form_params:\n                raise InvalidSpecification(\n                    f\"{self.method} {self.path}: 'body' and 'formData' parameters are mutually exclusive\"\n                )\n\n            if body_params:\n                self._request_body = self._transform_json(body_params[0])\n            elif form_params:\n                self._request_body = self._transform_form(form_params)\n            else:\n                self._request_body = {}\n\n        return self._request_body",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "logging",
        "typing",
        "http.HTTPStatus",
        "connexion.datastructures.NoContent",
        "connexion.exceptions.InvalidSpecification",
        "connexion.operations.abstract.AbstractOperation",
        "connexion.uri_parsing.Swagger2URIParser",
        "connexion.utils.build_example_from_schema",
        "connexion.utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._transform_json",
          "body": "def _transform_json(self, body_parameter: dict) -> dict:\n    \"\"\"Translate Swagger2 json parameters into OpenAPI 3 jsonschema spec.\"\"\"\n    nullable = body_parameter.get('x-nullable')\n    if nullable is not None:\n        body_parameter['schema']['nullable'] = nullable\n    return body_parameter"
        },
        {
          "name": "self._transform_form",
          "body": "def _transform_form(self, form_parameters: t.List[dict]) -> dict:\n    \"\"\"Translate Swagger2 form parameters into OpenAPI 3 jsonschema spec.\"\"\"\n    properties = {}\n    defaults = {}\n    required = []\n    encoding = {}\n    for param in form_parameters:\n        prop = {}\n        if param['type'] == 'file':\n            prop.update({'type': 'string', 'format': 'binary'})\n        else:\n            prop['type'] = param['type']\n            format_ = param.get('format')\n            if format_ is not None:\n                prop['format'] = format_\n        default = param.get('default')\n        if default is not None:\n            prop['default'] = default\n            defaults[param['name']] = default\n        nullable = param.get('x-nullable')\n        if nullable is not None:\n            prop['nullable'] = nullable\n        if param['type'] == 'array':\n            prop['items'] = param.get('items', {})\n            collection_format = param.get('collectionFormat', 'csv')\n            try:\n                encoding[param['name']] = COLLECTION_FORMAT_MAPPING[collection_format]\n            except KeyError:\n                raise InvalidSpecification(f'The collection format ({collection_format}) is not supported by Connexion as it cannot be mapped to OpenAPI 3.')\n        properties[param['name']] = prop\n        if param.get('required', False):\n            required.append(param['name'])\n    definition: t.Dict[str, t.Any] = {'schema': {'type': 'object', 'properties': properties, 'required': required}}\n    if defaults:\n        definition['schema']['default'] = defaults\n    if encoding:\n        definition['encoding'] = encoding\n    return definition"
        }
      ]
    },
    {
      "name": "parameters",
      "module": "swagger2",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\swagger2.py",
      "line_number": 155,
      "end_line_number": 156,
      "source_code": "def parameters(self):\n        return self._parameters",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "logging",
        "typing",
        "http.HTTPStatus",
        "connexion.datastructures.NoContent",
        "connexion.exceptions.InvalidSpecification",
        "connexion.operations.abstract.AbstractOperation",
        "connexion.uri_parsing.Swagger2URIParser",
        "connexion.utils.build_example_from_schema",
        "connexion.utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "consumes",
      "module": "swagger2",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\swagger2.py",
      "line_number": 159,
      "end_line_number": 160,
      "source_code": "def consumes(self):\n        return self._consumes",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "logging",
        "typing",
        "http.HTTPStatus",
        "connexion.datastructures.NoContent",
        "connexion.exceptions.InvalidSpecification",
        "connexion.operations.abstract.AbstractOperation",
        "connexion.uri_parsing.Swagger2URIParser",
        "connexion.utils.build_example_from_schema",
        "connexion.utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "produces",
      "module": "swagger2",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\swagger2.py",
      "line_number": 163,
      "end_line_number": 164,
      "source_code": "def produces(self):\n        return self._produces",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "logging",
        "typing",
        "http.HTTPStatus",
        "connexion.datastructures.NoContent",
        "connexion.exceptions.InvalidSpecification",
        "connexion.operations.abstract.AbstractOperation",
        "connexion.uri_parsing.Swagger2URIParser",
        "connexion.utils.build_example_from_schema",
        "connexion.utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "get_path_parameter_types",
      "module": "swagger2",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\swagger2.py",
      "line_number": 166,
      "end_line_number": 176,
      "source_code": "def get_path_parameter_types(self):\n        types = {}\n        path_parameters = (p for p in self.parameters if p[\"in\"] == \"path\")\n        for path_defn in path_parameters:\n            if path_defn.get(\"type\") == \"string\" and path_defn.get(\"format\") == \"path\":\n                # path is special case for type 'string'\n                path_type = \"path\"\n            else:\n                path_type = path_defn.get(\"type\")\n            types[path_defn[\"name\"]] = path_type\n        return types",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "logging",
        "typing",
        "http.HTTPStatus",
        "connexion.datastructures.NoContent",
        "connexion.exceptions.InvalidSpecification",
        "connexion.operations.abstract.AbstractOperation",
        "connexion.uri_parsing.Swagger2URIParser",
        "connexion.utils.build_example_from_schema",
        "connexion.utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "path_defn.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "path_defn.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "path_defn.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "with_definitions",
      "module": "swagger2",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\swagger2.py",
      "line_number": 178,
      "end_line_number": 181,
      "source_code": "def with_definitions(self, schema):\n        if \"schema\" in schema:\n            schema[\"schema\"][\"definitions\"] = self.definitions\n        return schema",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "schema"
      ],
      "imports": [
        "logging",
        "typing",
        "http.HTTPStatus",
        "connexion.datastructures.NoContent",
        "connexion.exceptions.InvalidSpecification",
        "connexion.operations.abstract.AbstractOperation",
        "connexion.uri_parsing.Swagger2URIParser",
        "connexion.utils.build_example_from_schema",
        "connexion.utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "response_schema",
      "module": "swagger2",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\swagger2.py",
      "line_number": 183,
      "end_line_number": 185,
      "source_code": "def response_schema(self, status_code=None, content_type=None):\n        response_definition = self.response_definition(status_code, content_type)\n        return self.with_definitions(response_definition.get(\"schema\", {}))",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "status_code",
        "content_type"
      ],
      "imports": [
        "logging",
        "typing",
        "http.HTTPStatus",
        "connexion.datastructures.NoContent",
        "connexion.exceptions.InvalidSpecification",
        "connexion.operations.abstract.AbstractOperation",
        "connexion.uri_parsing.Swagger2URIParser",
        "connexion.utils.build_example_from_schema",
        "connexion.utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.response_definition",
          "body": "def response_definition(self, status_code=None, content_type=None):\n    \"\"\"\n        response definition for this endpoint\n        \"\"\"\n    response_definition = self.responses.get(str(status_code), self.responses.get('default', {}))\n    return response_definition"
        },
        {
          "name": "self.with_definitions",
          "body": "@abc.abstractmethod\ndef with_definitions(self, schema):\n    \"\"\"\n        Returns the given schema, but with the definitions from the spec\n        attached. This allows any remaining references to be resolved by a\n        validator (for example).\n        \"\"\""
        },
        {
          "name": "response_definition.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "example_response",
      "module": "swagger2",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\swagger2.py",
      "line_number": 187,
      "end_line_number": 222,
      "source_code": "def example_response(self, status_code=None, *args, **kwargs):\n        \"\"\"\n        Returns example response from spec\n        \"\"\"\n        # simply use the first/lowest status code, this is probably 200 or 201\n        status_code = status_code or sorted(self._responses.keys())[0]\n        examples_path = [str(status_code), \"examples\"]\n        schema_example_path = [str(status_code), \"schema\", \"example\"]\n        schema_path = [str(status_code), \"schema\"]\n\n        try:\n            status_code = int(status_code)\n        except ValueError:\n            status_code = 200\n\n        if status_code == HTTPStatus.NO_CONTENT:\n            return NoContent, status_code\n\n        try:\n            return (\n                list(deep_get(self._responses, examples_path).values())[0],\n                status_code,\n            )\n        except KeyError:\n            pass\n        try:\n            return (deep_get(self._responses, schema_example_path), status_code)\n        except KeyError:\n            pass\n\n        try:\n            schema = deep_get(self._responses, schema_path)\n        except KeyError:\n            return (\"No example response or response schema defined.\", status_code)\n\n        return (build_example_from_schema(schema), status_code)",
      "docstring": "Returns example response from spec",
      "decorators": [],
      "arguments": [
        "self",
        "status_code"
      ],
      "imports": [
        "logging",
        "typing",
        "http.HTTPStatus",
        "connexion.datastructures.NoContent",
        "connexion.exceptions.InvalidSpecification",
        "connexion.operations.abstract.AbstractOperation",
        "connexion.uri_parsing.Swagger2URIParser",
        "connexion.utils.build_example_from_schema",
        "connexion.utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "deep_get",
          "body": "def deep_get(obj, keys):\n    \"\"\"\n    Recurses through a nested object get a leaf value.\n\n    There are cases where the use of inheritance or polymorphism-- the use of allOf or\n    oneOf keywords-- will cause the obj to be a list. In this case the keys will\n    contain one or more strings containing integers.\n\n    :type obj: list or dict\n    :type keys: list of strings\n    \"\"\"\n    if not keys:\n        return obj\n    if isinstance(obj, list):\n        return deep_get(obj[int(keys[0])], keys[1:])\n    else:\n        return deep_get(obj[keys[0]], keys[1:])"
        },
        {
          "name": "build_example_from_schema",
          "body": "def build_example_from_schema(schema):\n    if 'example' in schema:\n        return schema['example']\n    if 'properties' in schema:\n        return {key: build_example_from_schema(value) for key, value in schema['properties'].items()}\n    if 'items' in schema:\n        min_item_count = schema.get('minItems', 0)\n        max_item_count = schema.get('maxItems')\n        if max_item_count is None or max_item_count >= min_item_count + 1:\n            item_count = min_item_count + 1\n        else:\n            item_count = min_item_count\n        return [build_example_from_schema(schema['items']) for n in range(item_count)]\n    try:\n        from jsf import JSF\n    except ImportError:\n        return None\n    faker = JSF(schema)\n    return faker.generate()"
        },
        {
          "name": "deep_get",
          "body": "def deep_get(obj, keys):\n    \"\"\"\n    Recurses through a nested object get a leaf value.\n\n    There are cases where the use of inheritance or polymorphism-- the use of allOf or\n    oneOf keywords-- will cause the obj to be a list. In this case the keys will\n    contain one or more strings containing integers.\n\n    :type obj: list or dict\n    :type keys: list of strings\n    \"\"\"\n    if not keys:\n        return obj\n    if isinstance(obj, list):\n        return deep_get(obj[int(keys[0])], keys[1:])\n    else:\n        return deep_get(obj[keys[0]], keys[1:])"
        },
        {
          "name": "deep_get",
          "body": "def deep_get(obj, keys):\n    \"\"\"\n    Recurses through a nested object get a leaf value.\n\n    There are cases where the use of inheritance or polymorphism-- the use of allOf or\n    oneOf keywords-- will cause the obj to be a list. In this case the keys will\n    contain one or more strings containing integers.\n\n    :type obj: list or dict\n    :type keys: list of strings\n    \"\"\"\n    if not keys:\n        return obj\n    if isinstance(obj, list):\n        return deep_get(obj[int(keys[0])], keys[1:])\n    else:\n        return deep_get(obj[keys[0]], keys[1:])"
        }
      ]
    },
    {
      "name": "body_name",
      "module": "swagger2",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\swagger2.py",
      "line_number": 224,
      "end_line_number": 225,
      "source_code": "def body_name(self, content_type: t.Optional[str] = None) -> str:\n        return self.body_definition(content_type).get(\"name\", \"body\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "content_type"
      ],
      "imports": [
        "logging",
        "typing",
        "http.HTTPStatus",
        "connexion.datastructures.NoContent",
        "connexion.exceptions.InvalidSpecification",
        "connexion.operations.abstract.AbstractOperation",
        "connexion.uri_parsing.Swagger2URIParser",
        "connexion.utils.build_example_from_schema",
        "connexion.utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.body_definition",
          "body": "@abc.abstractmethod\ndef body_definition(self, content_type: t.Optional[str]=None) -> dict:\n    \"\"\"\n        The body definition for this operation.\n        :rtype: dict\n        \"\"\""
        }
      ]
    },
    {
      "name": "body_schema",
      "module": "swagger2",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\swagger2.py",
      "line_number": 227,
      "end_line_number": 232,
      "source_code": "def body_schema(self, content_type: t.Optional[str] = None) -> dict:\n        \"\"\"\n        The body schema definition for this operation.\n        \"\"\"\n        body_definition = self.body_definition(content_type)\n        return self.with_definitions(body_definition).get(\"schema\", {})",
      "docstring": "The body schema definition for this operation.",
      "decorators": [],
      "arguments": [
        "self",
        "content_type"
      ],
      "imports": [
        "logging",
        "typing",
        "http.HTTPStatus",
        "connexion.datastructures.NoContent",
        "connexion.exceptions.InvalidSpecification",
        "connexion.operations.abstract.AbstractOperation",
        "connexion.uri_parsing.Swagger2URIParser",
        "connexion.utils.build_example_from_schema",
        "connexion.utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.body_definition",
          "body": "@abc.abstractmethod\ndef body_definition(self, content_type: t.Optional[str]=None) -> dict:\n    \"\"\"\n        The body definition for this operation.\n        :rtype: dict\n        \"\"\""
        },
        {
          "name": "self.with_definitions",
          "body": "@abc.abstractmethod\ndef with_definitions(self, schema):\n    \"\"\"\n        Returns the given schema, but with the definitions from the spec\n        attached. This allows any remaining references to be resolved by a\n        validator (for example).\n        \"\"\""
        }
      ]
    },
    {
      "name": "body_definition",
      "module": "swagger2",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\swagger2.py",
      "line_number": 234,
      "end_line_number": 240,
      "source_code": "def body_definition(self, content_type: t.Optional[str] = None) -> dict:\n        \"\"\"\n        The body complete definition for this operation.\n\n        **There can be one \"body\" parameter at most.**\n        \"\"\"\n        return self.request_body",
      "docstring": "The body complete definition for this operation.\n\n**There can be one \"body\" parameter at most.**",
      "decorators": [],
      "arguments": [
        "self",
        "content_type"
      ],
      "imports": [
        "logging",
        "typing",
        "http.HTTPStatus",
        "connexion.datastructures.NoContent",
        "connexion.exceptions.InvalidSpecification",
        "connexion.operations.abstract.AbstractOperation",
        "connexion.uri_parsing.Swagger2URIParser",
        "connexion.utils.build_example_from_schema",
        "connexion.utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_transform_json",
      "module": "swagger2",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\swagger2.py",
      "line_number": 242,
      "end_line_number": 247,
      "source_code": "def _transform_json(self, body_parameter: dict) -> dict:\n        \"\"\"Translate Swagger2 json parameters into OpenAPI 3 jsonschema spec.\"\"\"\n        nullable = body_parameter.get(\"x-nullable\")\n        if nullable is not None:\n            body_parameter[\"schema\"][\"nullable\"] = nullable\n        return body_parameter",
      "docstring": "Translate Swagger2 json parameters into OpenAPI 3 jsonschema spec.",
      "decorators": [],
      "arguments": [
        "self",
        "body_parameter"
      ],
      "imports": [
        "logging",
        "typing",
        "http.HTTPStatus",
        "connexion.datastructures.NoContent",
        "connexion.exceptions.InvalidSpecification",
        "connexion.operations.abstract.AbstractOperation",
        "connexion.uri_parsing.Swagger2URIParser",
        "connexion.utils.build_example_from_schema",
        "connexion.utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "body_parameter.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "_transform_form",
      "module": "swagger2",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\operations\\swagger2.py",
      "line_number": 249,
      "end_line_number": 313,
      "source_code": "def _transform_form(self, form_parameters: t.List[dict]) -> dict:\n        \"\"\"Translate Swagger2 form parameters into OpenAPI 3 jsonschema spec.\"\"\"\n        properties = {}\n        defaults = {}\n        required = []\n        encoding = {}\n\n        for param in form_parameters:\n            prop = {}\n\n            if param[\"type\"] == \"file\":\n                prop.update(\n                    {\n                        \"type\": \"string\",\n                        \"format\": \"binary\",\n                    }\n                )\n            else:\n                prop[\"type\"] = param[\"type\"]\n\n                format_ = param.get(\"format\")\n                if format_ is not None:\n                    prop[\"format\"] = format_\n\n            default = param.get(\"default\")\n            if default is not None:\n                prop[\"default\"] = default\n                defaults[param[\"name\"]] = default\n\n            nullable = param.get(\"x-nullable\")\n            if nullable is not None:\n                prop[\"nullable\"] = nullable\n\n            if param[\"type\"] == \"array\":\n                prop[\"items\"] = param.get(\"items\", {})\n\n                collection_format = param.get(\"collectionFormat\", \"csv\")\n                try:\n                    encoding[param[\"name\"]] = COLLECTION_FORMAT_MAPPING[\n                        collection_format\n                    ]\n                except KeyError:\n                    raise InvalidSpecification(\n                        f\"The collection format ({collection_format}) is not supported by \"\n                        f\"Connexion as it cannot be mapped to OpenAPI 3.\"\n                    )\n\n            properties[param[\"name\"]] = prop\n\n            if param.get(\"required\", False):\n                required.append(param[\"name\"])\n\n        definition: t.Dict[str, t.Any] = {\n            \"schema\": {\n                \"type\": \"object\",\n                \"properties\": properties,\n                \"required\": required,\n            }\n        }\n        if defaults:\n            definition[\"schema\"][\"default\"] = defaults\n        if encoding:\n            definition[\"encoding\"] = encoding\n\n        return definition",
      "docstring": "Translate Swagger2 form parameters into OpenAPI 3 jsonschema spec.",
      "decorators": [],
      "arguments": [
        "self",
        "form_parameters"
      ],
      "imports": [
        "logging",
        "typing",
        "http.HTTPStatus",
        "connexion.datastructures.NoContent",
        "connexion.exceptions.InvalidSpecification",
        "connexion.operations.abstract.AbstractOperation",
        "connexion.uri_parsing.Swagger2URIParser",
        "connexion.utils.build_example_from_schema",
        "connexion.utils.deep_get"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "param.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "param.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "param.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "param.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "param.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "param.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "__init__",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\validators\\abstract.py",
      "line_number": 31,
      "end_line_number": 53,
      "source_code": "def __init__(\n        self,\n        *,\n        schema: dict,\n        required: bool = False,\n        nullable: bool = False,\n        encoding: str,\n        strict_validation: bool,\n        **kwargs,\n    ):\n        \"\"\"\n        :param schema: Schema of operation to validate\n        :param required: Whether RequestBody is required\n        :param nullable: Whether RequestBody is nullable\n        :param encoding: Encoding of body (passed via Content-Type header)\n        :param kwargs: Additional arguments for subclasses\n        :param strict_validation: Whether to allow parameters not defined in the spec\n        \"\"\"\n        self._schema = schema\n        self._nullable = nullable\n        self._required = required\n        self._encoding = encoding\n        self._strict_validation = strict_validation",
      "docstring": ":param schema: Schema of operation to validate\n:param required: Whether RequestBody is required\n:param nullable: Whether RequestBody is nullable\n:param encoding: Encoding of body (passed via Content-Type header)\n:param kwargs: Additional arguments for subclasses\n:param strict_validation: Whether to allow parameters not defined in the spec",
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "copy",
        "json",
        "typing",
        "starlette.datastructures.Headers",
        "starlette.datastructures.MutableHeaders",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.exceptions.BadRequestProblem"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_validate",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\validators\\abstract.py",
      "line_number": 60,
      "end_line_number": 65,
      "source_code": "def _validate(self, body: t.Any) -> t.Optional[dict]:\n        \"\"\"\n        Validate the parsed body.\n\n        :raises: :class:`connexion.exceptions.BadRequestProblem`\n        \"\"\"",
      "docstring": "Validate the parsed body.\n\n:raises: :class:`connexion.exceptions.BadRequestProblem`",
      "decorators": [],
      "arguments": [
        "self",
        "body"
      ],
      "imports": [
        "copy",
        "json",
        "typing",
        "starlette.datastructures.Headers",
        "starlette.datastructures.MutableHeaders",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.exceptions.BadRequestProblem"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_insert_body",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\validators\\abstract.py",
      "line_number": 67,
      "end_line_number": 98,
      "source_code": "def _insert_body(\n        self, receive: Receive, *, body: t.Any, scope: Scope\n    ) -> t.Tuple[Receive, Scope]:\n        \"\"\"\n        Insert messages transmitting the body at the start of the `receive` channel.\n\n        This method updates the provided `scope` in place with the right `Content-Length` header.\n        \"\"\"\n        if body is None:\n            return receive, scope\n\n        bytes_body = json.dumps(body).encode(self._encoding)\n\n        # Update the content-length header\n        new_scope = scope.copy()\n        new_scope[\"headers\"] = copy.deepcopy(scope[\"headers\"])\n        headers = MutableHeaders(scope=new_scope)\n        headers[\"content-length\"] = str(len(bytes_body))\n\n        # Wrap in new receive channel\n        messages = (\n            {\n                \"type\": \"http.request\",\n                \"body\": bytes_body[i : i + self.MAX_MESSAGE_LENGTH],\n                \"more_body\": i + self.MAX_MESSAGE_LENGTH < len(bytes_body),\n            }\n            for i in range(0, len(bytes_body), self.MAX_MESSAGE_LENGTH)\n        )\n\n        receive = self._insert_messages(receive, messages=messages)\n\n        return receive, new_scope",
      "docstring": "Insert messages transmitting the body at the start of the `receive` channel.\n\nThis method updates the provided `scope` in place with the right `Content-Length` header.",
      "decorators": [],
      "arguments": [
        "self",
        "receive"
      ],
      "imports": [
        "copy",
        "json",
        "typing",
        "starlette.datastructures.Headers",
        "starlette.datastructures.MutableHeaders",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.exceptions.BadRequestProblem"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._insert_messages",
          "body": "@staticmethod\ndef _insert_messages(receive: Receive, *, messages: t.Iterable[t.MutableMapping[str, t.Any]]) -> Receive:\n    \"\"\"Insert messages at the start of the `receive` channel.\"\"\"\n    message_iterator = iter(messages)\n\n    async def receive_() -> t.MutableMapping[str, t.Any]:\n        try:\n            return next(message_iterator)\n        except StopIteration:\n            return await receive()\n    return receive_"
        }
      ]
    },
    {
      "name": "_insert_messages",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\validators\\abstract.py",
      "line_number": 101,
      "end_line_number": 114,
      "source_code": "def _insert_messages(\n        receive: Receive, *, messages: t.Iterable[t.MutableMapping[str, t.Any]]\n    ) -> Receive:\n        \"\"\"Insert messages at the start of the `receive` channel.\"\"\"\n        # Ensure that messages is an iterator so each message is replayed once.\n        message_iterator = iter(messages)\n\n        async def receive_() -> t.MutableMapping[str, t.Any]:\n            try:\n                return next(message_iterator)\n            except StopIteration:\n                return await receive()\n\n        return receive_",
      "docstring": "Insert messages at the start of the `receive` channel.",
      "decorators": [
        "staticmethod"
      ],
      "arguments": [
        "receive"
      ],
      "imports": [
        "copy",
        "json",
        "typing",
        "starlette.datastructures.Headers",
        "starlette.datastructures.MutableHeaders",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.exceptions.BadRequestProblem"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\validators\\abstract.py",
      "line_number": 168,
      "end_line_number": 179,
      "source_code": "def __init__(\n        self,\n        scope: Scope,\n        *,\n        schema: dict,\n        nullable: bool = False,\n        encoding: str,\n    ) -> None:\n        self._scope = scope\n        self._schema = schema\n        self._nullable = nullable\n        self._encoding = encoding",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "scope"
      ],
      "imports": [
        "copy",
        "json",
        "typing",
        "starlette.datastructures.Headers",
        "starlette.datastructures.MutableHeaders",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.exceptions.BadRequestProblem"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_parse",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\validators\\abstract.py",
      "line_number": 181,
      "end_line_number": 182,
      "source_code": "def _parse(self, stream: t.Generator[bytes, None, None]) -> t.Any:\n        \"\"\"Parse the incoming stream.\"\"\"",
      "docstring": "Parse the incoming stream.",
      "decorators": [],
      "arguments": [
        "self",
        "stream"
      ],
      "imports": [
        "copy",
        "json",
        "typing",
        "starlette.datastructures.Headers",
        "starlette.datastructures.MutableHeaders",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.exceptions.BadRequestProblem"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_validate",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\validators\\abstract.py",
      "line_number": 184,
      "end_line_number": 189,
      "source_code": "def _validate(self, body: t.Any) -> t.Optional[dict]:\n        \"\"\"\n        Validate the body.\n\n        :raises: :class:`connexion.exceptions.NonConformingResponse`\n        \"\"\"",
      "docstring": "Validate the body.\n\n:raises: :class:`connexion.exceptions.NonConformingResponse`",
      "decorators": [],
      "arguments": [
        "self",
        "body"
      ],
      "imports": [
        "copy",
        "json",
        "typing",
        "starlette.datastructures.Headers",
        "starlette.datastructures.MutableHeaders",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.exceptions.BadRequestProblem"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "wrap_send",
      "module": "abstract",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\validators\\abstract.py",
      "line_number": 191,
      "end_line_number": 213,
      "source_code": "def wrap_send(self, send: Send) -> Send:\n        \"\"\"Wrap the provided send channel with response body validation\"\"\"\n\n        messages = []\n\n        async def send_(message: t.MutableMapping[str, t.Any]) -> None:\n            messages.append(message)\n\n            if message[\"type\"] == \"http.response.start\" or message.get(\n                \"more_body\", False\n            ):\n                return\n\n            stream = (message.get(\"body\", b\"\") for message in messages)\n            body = self._parse(stream)\n\n            if not (body is None and self._nullable):\n                self._validate(body)\n\n            while messages:\n                await send(messages.pop(0))\n\n        return send_",
      "docstring": "Wrap the provided send channel with response body validation",
      "decorators": [],
      "arguments": [
        "self",
        "send"
      ],
      "imports": [
        "copy",
        "json",
        "typing",
        "starlette.datastructures.Headers",
        "starlette.datastructures.MutableHeaders",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "connexion.exceptions.BadRequestProblem"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._parse",
          "body": "def _parse(self, stream: t.Generator[bytes, None, None]) -> t.Any:\n    \"\"\"Parse the incoming stream.\"\"\""
        },
        {
          "name": "message.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "message.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "self._validate",
          "body": "def _validate(self, body: t.Any) -> t.Optional[dict]:\n    \"\"\"\n        Validate the parsed body.\n\n        :raises: :class:`connexion.exceptions.BadRequestProblem`\n        \"\"\""
        }
      ]
    },
    {
      "name": "__init__",
      "module": "form_data",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\validators\\form_data.py",
      "line_number": 20,
      "end_line_number": 37,
      "source_code": "def __init__(\n        self,\n        *,\n        schema: dict,\n        required=False,\n        nullable=False,\n        encoding: str,\n        strict_validation: bool,\n        uri_parser: t.Optional[AbstractURIParser] = None,\n    ) -> None:\n        super().__init__(\n            schema=schema,\n            required=required,\n            nullable=nullable,\n            encoding=encoding,\n            strict_validation=strict_validation,\n        )\n        self._uri_parser = uri_parser",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "logging",
        "typing",
        "jsonschema.Draft4Validator",
        "jsonschema.ValidationError",
        "starlette.datastructures.Headers",
        "starlette.datastructures.UploadFile",
        "starlette.formparsers.FormParser",
        "starlette.formparsers.MultiPartParser",
        "starlette.types.Scope",
        "connexion.exceptions.BadRequestProblem",
        "connexion.exceptions.ExtraParameterProblem",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.json_schema.format_error_with_path",
        "connexion.uri_parsing.AbstractURIParser",
        "connexion.validators.AbstractRequestBodyValidator"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_validator",
      "module": "form_data",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\validators\\form_data.py",
      "line_number": 40,
      "end_line_number": 43,
      "source_code": "def _validator(self):\n        return Draft4RequestValidator(\n            self._schema, format_checker=Draft4Validator.FORMAT_CHECKER\n        )",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "logging",
        "typing",
        "jsonschema.Draft4Validator",
        "jsonschema.ValidationError",
        "starlette.datastructures.Headers",
        "starlette.datastructures.UploadFile",
        "starlette.formparsers.FormParser",
        "starlette.formparsers.MultiPartParser",
        "starlette.types.Scope",
        "connexion.exceptions.BadRequestProblem",
        "connexion.exceptions.ExtraParameterProblem",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.json_schema.format_error_with_path",
        "connexion.uri_parsing.AbstractURIParser",
        "connexion.validators.AbstractRequestBodyValidator"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_form_parser_cls",
      "module": "form_data",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\validators\\form_data.py",
      "line_number": 46,
      "end_line_number": 47,
      "source_code": "def _form_parser_cls(self):\n        return FormParser",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "logging",
        "typing",
        "jsonschema.Draft4Validator",
        "jsonschema.ValidationError",
        "starlette.datastructures.Headers",
        "starlette.datastructures.UploadFile",
        "starlette.formparsers.FormParser",
        "starlette.formparsers.MultiPartParser",
        "starlette.types.Scope",
        "connexion.exceptions.BadRequestProblem",
        "connexion.exceptions.ExtraParameterProblem",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.json_schema.format_error_with_path",
        "connexion.uri_parsing.AbstractURIParser",
        "connexion.validators.AbstractRequestBodyValidator"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_validate",
      "module": "form_data",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\validators\\form_data.py",
      "line_number": 96,
      "end_line_number": 109,
      "source_code": "def _validate(self, body: t.Any) -> t.Optional[dict]:  # type: ignore[return]\n        if not isinstance(body, dict):\n            raise BadRequestProblem(\"Parsed body must be a mapping\")\n        if self._strict_validation:\n            self._validate_params_strictly(body)\n        try:\n            self._validator.validate(body)\n        except ValidationError as exception:\n            error_path_msg = format_error_with_path(exception=exception)\n            logger.error(\n                f\"Validation error: {exception.message}{error_path_msg}\",\n                extra={\"validator\": \"body\"},\n            )\n            raise BadRequestProblem(detail=f\"{exception.message}{error_path_msg}\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "body"
      ],
      "imports": [
        "logging",
        "typing",
        "jsonschema.Draft4Validator",
        "jsonschema.ValidationError",
        "starlette.datastructures.Headers",
        "starlette.datastructures.UploadFile",
        "starlette.formparsers.FormParser",
        "starlette.formparsers.MultiPartParser",
        "starlette.types.Scope",
        "connexion.exceptions.BadRequestProblem",
        "connexion.exceptions.ExtraParameterProblem",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.json_schema.format_error_with_path",
        "connexion.uri_parsing.AbstractURIParser",
        "connexion.validators.AbstractRequestBodyValidator"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._validate_params_strictly",
          "body": "def _validate_params_strictly(self, data: dict) -> None:\n    form_params = data.keys()\n    spec_params = self._schema.get('properties', {}).keys()\n    errors = set(form_params).difference(set(spec_params))\n    if errors:\n        raise ExtraParameterProblem(param_type='formData', extra_params=errors)"
        },
        {
          "name": "self._validator.validate",
          "body": "def validate(self, scope):\n    logger.debug('%s validating parameters...', scope.get('path'))\n    request = ConnexionRequest(scope, uri_parser=self.uri_parser)\n    self.validate_request(request)"
        },
        {
          "name": "format_error_with_path",
          "body": "def format_error_with_path(exception: ValidationError) -> str:\n    \"\"\"Format a `ValidationError` with path to error.\"\"\"\n    error_path = '.'.join((str(item) for item in exception.path))\n    error_path_msg = f\" - '{error_path}'\" if error_path else ''\n    return error_path_msg"
        }
      ]
    },
    {
      "name": "_validate_params_strictly",
      "module": "form_data",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\validators\\form_data.py",
      "line_number": 111,
      "end_line_number": 116,
      "source_code": "def _validate_params_strictly(self, data: dict) -> None:\n        form_params = data.keys()\n        spec_params = self._schema.get(\"properties\", {}).keys()\n        errors = set(form_params).difference(set(spec_params))\n        if errors:\n            raise ExtraParameterProblem(param_type=\"formData\", extra_params=errors)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "data"
      ],
      "imports": [
        "logging",
        "typing",
        "jsonschema.Draft4Validator",
        "jsonschema.ValidationError",
        "starlette.datastructures.Headers",
        "starlette.datastructures.UploadFile",
        "starlette.formparsers.FormParser",
        "starlette.formparsers.MultiPartParser",
        "starlette.types.Scope",
        "connexion.exceptions.BadRequestProblem",
        "connexion.exceptions.ExtraParameterProblem",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.json_schema.format_error_with_path",
        "connexion.uri_parsing.AbstractURIParser",
        "connexion.validators.AbstractRequestBodyValidator"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._schema.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "_form_parser_cls",
      "module": "form_data",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\validators\\form_data.py",
      "line_number": 121,
      "end_line_number": 122,
      "source_code": "def _form_parser_cls(self):\n        return MultiPartParser",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "logging",
        "typing",
        "jsonschema.Draft4Validator",
        "jsonschema.ValidationError",
        "starlette.datastructures.Headers",
        "starlette.datastructures.UploadFile",
        "starlette.formparsers.FormParser",
        "starlette.formparsers.MultiPartParser",
        "starlette.types.Scope",
        "connexion.exceptions.BadRequestProblem",
        "connexion.exceptions.ExtraParameterProblem",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.json_schema.format_error_with_path",
        "connexion.uri_parsing.AbstractURIParser",
        "connexion.validators.AbstractRequestBodyValidator"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "is_file",
      "module": "form_data",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\validators\\form_data.py",
      "line_number": 63,
      "end_line_number": 67,
      "source_code": "def is_file(schema):\n                    return schema.get(\"type\") == \"string\" and schema.get(\"format\") in [\n                        \"binary\",\n                        \"base64\",\n                    ]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "schema"
      ],
      "imports": [
        "logging",
        "typing",
        "jsonschema.Draft4Validator",
        "jsonschema.ValidationError",
        "starlette.datastructures.Headers",
        "starlette.datastructures.UploadFile",
        "starlette.formparsers.FormParser",
        "starlette.formparsers.MultiPartParser",
        "starlette.types.Scope",
        "connexion.exceptions.BadRequestProblem",
        "connexion.exceptions.ExtraParameterProblem",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.json_schema.format_error_with_path",
        "connexion.uri_parsing.AbstractURIParser",
        "connexion.validators.AbstractRequestBodyValidator"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "schema.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "schema.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "__init__",
      "module": "json",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\validators\\json.py",
      "line_number": 26,
      "end_line_number": 42,
      "source_code": "def __init__(\n        self,\n        *,\n        schema: dict,\n        required=False,\n        nullable=False,\n        encoding: str,\n        strict_validation: bool,\n        **kwargs,\n    ) -> None:\n        super().__init__(\n            schema=schema,\n            required=required,\n            nullable=nullable,\n            encoding=encoding,\n            strict_validation=strict_validation,\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "json",
        "logging",
        "typing",
        "jsonschema",
        "jsonschema.Draft4Validator",
        "jsonschema.ValidationError",
        "starlette.types.Scope",
        "connexion.exceptions.BadRequestProblem",
        "connexion.exceptions.NonConformingResponseBody",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.json_schema.Draft4ResponseValidator",
        "connexion.json_schema.format_error_with_path",
        "connexion.validators.AbstractRequestBodyValidator",
        "connexion.validators.AbstractResponseBodyValidator"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_validator",
      "module": "json",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\validators\\json.py",
      "line_number": 45,
      "end_line_number": 48,
      "source_code": "def _validator(self):\n        return Draft4RequestValidator(\n            self._schema, format_checker=Draft4Validator.FORMAT_CHECKER\n        )",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "json",
        "logging",
        "typing",
        "jsonschema",
        "jsonschema.Draft4Validator",
        "jsonschema.ValidationError",
        "starlette.types.Scope",
        "connexion.exceptions.BadRequestProblem",
        "connexion.exceptions.NonConformingResponseBody",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.json_schema.Draft4ResponseValidator",
        "connexion.json_schema.format_error_with_path",
        "connexion.validators.AbstractRequestBodyValidator",
        "connexion.validators.AbstractResponseBodyValidator"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_validate",
      "module": "json",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\validators\\json.py",
      "line_number": 64,
      "end_line_number": 75,
      "source_code": "def _validate(self, body: t.Any) -> t.Optional[dict]:\n        if not self._nullable and body is None:\n            raise BadRequestProblem(\"Request body must not be empty\")\n        try:\n            return self._validator.validate(body)\n        except ValidationError as exception:\n            error_path_msg = format_error_with_path(exception=exception)\n            logger.info(\n                f\"Validation error: {exception.message}{error_path_msg}\",\n                extra={\"validator\": \"body\"},\n            )\n            raise BadRequestProblem(detail=f\"{exception.message}{error_path_msg}\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "body"
      ],
      "imports": [
        "json",
        "logging",
        "typing",
        "jsonschema",
        "jsonschema.Draft4Validator",
        "jsonschema.ValidationError",
        "starlette.types.Scope",
        "connexion.exceptions.BadRequestProblem",
        "connexion.exceptions.NonConformingResponseBody",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.json_schema.Draft4ResponseValidator",
        "connexion.json_schema.format_error_with_path",
        "connexion.validators.AbstractRequestBodyValidator",
        "connexion.validators.AbstractResponseBodyValidator"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self._validator.validate",
          "body": "def validate(self, scope):\n    logger.debug('%s validating parameters...', scope.get('path'))\n    request = ConnexionRequest(scope, uri_parser=self.uri_parser)\n    self.validate_request(request)"
        },
        {
          "name": "format_error_with_path",
          "body": "def format_error_with_path(exception: ValidationError) -> str:\n    \"\"\"Format a `ValidationError` with path to error.\"\"\"\n    error_path = '.'.join((str(item) for item in exception.path))\n    error_path_msg = f\" - '{error_path}'\" if error_path else ''\n    return error_path_msg"
        }
      ]
    },
    {
      "name": "_validator",
      "module": "json",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\validators\\json.py",
      "line_number": 87,
      "end_line_number": 91,
      "source_code": "def _validator(self):\n        validator_cls = self.extend_with_set_default(Draft4RequestValidator)\n        return validator_cls(\n            self._schema, format_checker=Draft4Validator.FORMAT_CHECKER\n        )",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "json",
        "logging",
        "typing",
        "jsonschema",
        "jsonschema.Draft4Validator",
        "jsonschema.ValidationError",
        "starlette.types.Scope",
        "connexion.exceptions.BadRequestProblem",
        "connexion.exceptions.NonConformingResponseBody",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.json_schema.Draft4ResponseValidator",
        "connexion.json_schema.format_error_with_path",
        "connexion.validators.AbstractRequestBodyValidator",
        "connexion.validators.AbstractResponseBodyValidator"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.extend_with_set_default",
          "body": "@staticmethod\ndef extend_with_set_default(validator_class):\n    validate_properties = validator_class.VALIDATORS['properties']\n\n    def set_defaults(validator, properties, instance, schema):\n        for property, subschema in properties.items():\n            if 'default' in subschema:\n                instance.setdefault(property, subschema['default'])\n        yield from validate_properties(validator, properties, instance, schema)\n    return jsonschema.validators.extend(validator_class, {'properties': set_defaults})"
        }
      ]
    },
    {
      "name": "extend_with_set_default",
      "module": "json",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\validators\\json.py",
      "line_number": 95,
      "end_line_number": 107,
      "source_code": "def extend_with_set_default(validator_class):\n        validate_properties = validator_class.VALIDATORS[\"properties\"]\n\n        def set_defaults(validator, properties, instance, schema):\n            for property, subschema in properties.items():\n                if \"default\" in subschema:\n                    instance.setdefault(property, subschema[\"default\"])\n\n            yield from validate_properties(validator, properties, instance, schema)\n\n        return jsonschema.validators.extend(\n            validator_class, {\"properties\": set_defaults}\n        )",
      "docstring": null,
      "decorators": [
        "staticmethod"
      ],
      "arguments": [
        "validator_class"
      ],
      "imports": [
        "json",
        "logging",
        "typing",
        "jsonschema",
        "jsonschema.Draft4Validator",
        "jsonschema.ValidationError",
        "starlette.types.Scope",
        "connexion.exceptions.BadRequestProblem",
        "connexion.exceptions.NonConformingResponseBody",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.json_schema.Draft4ResponseValidator",
        "connexion.json_schema.format_error_with_path",
        "connexion.validators.AbstractRequestBodyValidator",
        "connexion.validators.AbstractResponseBodyValidator"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "validator",
      "module": "json",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\validators\\json.py",
      "line_number": 114,
      "end_line_number": 117,
      "source_code": "def validator(self) -> Draft4Validator:\n        return Draft4ResponseValidator(\n            self._schema, format_checker=Draft4Validator.FORMAT_CHECKER\n        )",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "json",
        "logging",
        "typing",
        "jsonschema",
        "jsonschema.Draft4Validator",
        "jsonschema.ValidationError",
        "starlette.types.Scope",
        "connexion.exceptions.BadRequestProblem",
        "connexion.exceptions.NonConformingResponseBody",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.json_schema.Draft4ResponseValidator",
        "connexion.json_schema.format_error_with_path",
        "connexion.validators.AbstractRequestBodyValidator",
        "connexion.validators.AbstractResponseBodyValidator"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_parse",
      "module": "json",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\validators\\json.py",
      "line_number": 119,
      "end_line_number": 128,
      "source_code": "def _parse(self, stream: t.Generator[bytes, None, None]) -> t.Any:\n        body = b\"\".join(stream).decode(self._encoding)\n\n        if not body:\n            return None\n\n        try:\n            return json.loads(body)\n        except json.decoder.JSONDecodeError as e:\n            raise NonConformingResponseBody(str(e))",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "stream"
      ],
      "imports": [
        "json",
        "logging",
        "typing",
        "jsonschema",
        "jsonschema.Draft4Validator",
        "jsonschema.ValidationError",
        "starlette.types.Scope",
        "connexion.exceptions.BadRequestProblem",
        "connexion.exceptions.NonConformingResponseBody",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.json_schema.Draft4ResponseValidator",
        "connexion.json_schema.format_error_with_path",
        "connexion.validators.AbstractRequestBodyValidator",
        "connexion.validators.AbstractResponseBodyValidator"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_validate",
      "module": "json",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\validators\\json.py",
      "line_number": 130,
      "end_line_number": 141,
      "source_code": "def _validate(self, body: dict):\n        try:\n            self.validator.validate(body)\n        except ValidationError as exception:\n            error_path_msg = format_error_with_path(exception=exception)\n            logger.warning(\n                f\"Validation error: {exception.message}{error_path_msg}\",\n                extra={\"validator\": \"body\"},\n            )\n            raise NonConformingResponseBody(\n                detail=f\"Response body does not conform to specification. {exception.message}{error_path_msg}\"\n            )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "body"
      ],
      "imports": [
        "json",
        "logging",
        "typing",
        "jsonschema",
        "jsonschema.Draft4Validator",
        "jsonschema.ValidationError",
        "starlette.types.Scope",
        "connexion.exceptions.BadRequestProblem",
        "connexion.exceptions.NonConformingResponseBody",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.json_schema.Draft4ResponseValidator",
        "connexion.json_schema.format_error_with_path",
        "connexion.validators.AbstractRequestBodyValidator",
        "connexion.validators.AbstractResponseBodyValidator"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.validator.validate",
          "body": "def validate(self, scope):\n    logger.debug('%s validating parameters...', scope.get('path'))\n    request = ConnexionRequest(scope, uri_parser=self.uri_parser)\n    self.validate_request(request)"
        },
        {
          "name": "format_error_with_path",
          "body": "def format_error_with_path(exception: ValidationError) -> str:\n    \"\"\"Format a `ValidationError` with path to error.\"\"\"\n    error_path = '.'.join((str(item) for item in exception.path))\n    error_path_msg = f\" - '{error_path}'\" if error_path else ''\n    return error_path_msg"
        }
      ]
    },
    {
      "name": "_parse",
      "module": "json",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\validators\\json.py",
      "line_number": 145,
      "end_line_number": 151,
      "source_code": "def _parse(self, stream: t.Generator[bytes, None, None]) -> str:  # type: ignore\n        body = b\"\".join(stream).decode(self._encoding)\n\n        try:\n            return json.loads(body)\n        except json.decoder.JSONDecodeError:\n            return body",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "stream"
      ],
      "imports": [
        "json",
        "logging",
        "typing",
        "jsonschema",
        "jsonschema.Draft4Validator",
        "jsonschema.ValidationError",
        "starlette.types.Scope",
        "connexion.exceptions.BadRequestProblem",
        "connexion.exceptions.NonConformingResponseBody",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.json_schema.Draft4ResponseValidator",
        "connexion.json_schema.format_error_with_path",
        "connexion.validators.AbstractRequestBodyValidator",
        "connexion.validators.AbstractResponseBodyValidator"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "set_defaults",
      "module": "json",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\validators\\json.py",
      "line_number": 98,
      "end_line_number": 103,
      "source_code": "def set_defaults(validator, properties, instance, schema):\n            for property, subschema in properties.items():\n                if \"default\" in subschema:\n                    instance.setdefault(property, subschema[\"default\"])\n\n            yield from validate_properties(validator, properties, instance, schema)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "validator",
        "properties",
        "instance",
        "schema"
      ],
      "imports": [
        "json",
        "logging",
        "typing",
        "jsonschema",
        "jsonschema.Draft4Validator",
        "jsonschema.ValidationError",
        "starlette.types.Scope",
        "connexion.exceptions.BadRequestProblem",
        "connexion.exceptions.NonConformingResponseBody",
        "connexion.json_schema.Draft4RequestValidator",
        "connexion.json_schema.Draft4ResponseValidator",
        "connexion.json_schema.format_error_with_path",
        "connexion.validators.AbstractRequestBodyValidator",
        "connexion.validators.AbstractResponseBodyValidator"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "parameter",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\validators\\parameter.py",
      "line_number": 22,
      "end_line_number": 43,
      "source_code": "def __init__(\n        self,\n        parameters,\n        uri_parser,\n        strict_validation=False,\n        security_query_params=None,\n    ):\n        \"\"\"\n        :param parameters: List of request parameter dictionaries\n        :param uri_parser: class to use for uri parsing\n        :param strict_validation: Flag indicating if parameters not in spec are allowed\n        :param security_query_params: List of query parameter names used for security.\n            These parameters will be ignored when checking for extra parameters in case of\n            strict validation.\n        \"\"\"\n        self.parameters = collections.defaultdict(list)\n        for p in parameters:\n            self.parameters[p[\"in\"]].append(p)\n\n        self.uri_parser = uri_parser\n        self.strict_validation = strict_validation\n        self.security_query_params = set(security_query_params or [])",
      "docstring": ":param parameters: List of request parameter dictionaries\n:param uri_parser: class to use for uri parsing\n:param strict_validation: Flag indicating if parameters not in spec are allowed\n:param security_query_params: List of query parameter names used for security.\n    These parameters will be ignored when checking for extra parameters in case of\n    strict validation.",
      "decorators": [],
      "arguments": [
        "self",
        "parameters",
        "uri_parser",
        "strict_validation",
        "security_query_params"
      ],
      "imports": [
        "collections",
        "copy",
        "logging",
        "jsonschema.Draft4Validator",
        "jsonschema.ValidationError",
        "connexion.exceptions.BadRequestProblem",
        "connexion.exceptions.ExtraParameterProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.boolean",
        "connexion.utils.is_null",
        "connexion.utils.is_nullable",
        "jsonschema.draft4_format_checker"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "validate_parameter",
      "module": "parameter",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\validators\\parameter.py",
      "line_number": 46,
      "end_line_number": 63,
      "source_code": "def validate_parameter(parameter_type, value, param, param_name=None):\n        if is_nullable(param) and is_null(value):\n            return\n\n        elif value is not None:\n            param = copy.deepcopy(param)\n            param = param.get(\"schema\", param)\n            try:\n                Draft4Validator(param, format_checker=draft4_format_checker).validate(\n                    value\n                )\n            except ValidationError as exception:\n                return str(exception)\n\n        elif param.get(\"required\"):\n            return \"Missing {parameter_type} parameter '{param[name]}'\".format(\n                **locals()\n            )",
      "docstring": null,
      "decorators": [
        "staticmethod"
      ],
      "arguments": [
        "parameter_type",
        "value",
        "param",
        "param_name"
      ],
      "imports": [
        "collections",
        "copy",
        "logging",
        "jsonschema.Draft4Validator",
        "jsonschema.ValidationError",
        "connexion.exceptions.BadRequestProblem",
        "connexion.exceptions.ExtraParameterProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.boolean",
        "connexion.utils.is_null",
        "connexion.utils.is_nullable",
        "jsonschema.draft4_format_checker"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "is_nullable",
          "body": "def is_nullable(param_def):\n    return param_def.get('schema', param_def).get('nullable', False) or param_def.get('x-nullable', False)"
        },
        {
          "name": "is_null",
          "body": "def is_null(value):\n    if hasattr(value, 'strip') and value.strip() in ['null', 'None']:\n        return True\n    if value is None:\n        return True\n    return False"
        },
        {
          "name": "param.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "param.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "validate_parameter_list",
      "module": "parameter",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\validators\\parameter.py",
      "line_number": 66,
      "end_line_number": 70,
      "source_code": "def validate_parameter_list(request_params, spec_params):\n        request_params = set(request_params)\n        spec_params = set(spec_params)\n\n        return request_params.difference(spec_params)",
      "docstring": null,
      "decorators": [
        "staticmethod"
      ],
      "arguments": [
        "request_params",
        "spec_params"
      ],
      "imports": [
        "collections",
        "copy",
        "logging",
        "jsonschema.Draft4Validator",
        "jsonschema.ValidationError",
        "connexion.exceptions.BadRequestProblem",
        "connexion.exceptions.ExtraParameterProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.boolean",
        "connexion.utils.is_null",
        "connexion.utils.is_nullable",
        "jsonschema.draft4_format_checker"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "validate_query_parameter_list",
      "module": "parameter",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\validators\\parameter.py",
      "line_number": 72,
      "end_line_number": 76,
      "source_code": "def validate_query_parameter_list(self, request, security_params=None):\n        request_params = request.query_params.keys()\n        spec_params = [x[\"name\"] for x in self.parameters.get(\"query\", [])]\n        spec_params.extend(security_params or [])\n        return self.validate_parameter_list(request_params, spec_params)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "request",
        "security_params"
      ],
      "imports": [
        "collections",
        "copy",
        "logging",
        "jsonschema.Draft4Validator",
        "jsonschema.ValidationError",
        "connexion.exceptions.BadRequestProblem",
        "connexion.exceptions.ExtraParameterProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.boolean",
        "connexion.utils.is_null",
        "connexion.utils.is_nullable",
        "jsonschema.draft4_format_checker"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.validate_parameter_list",
          "body": "@staticmethod\ndef validate_parameter_list(request_params, spec_params):\n    request_params = set(request_params)\n    spec_params = set(spec_params)\n    return request_params.difference(spec_params)"
        },
        {
          "name": "self.parameters.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "validate_query_parameter",
      "module": "parameter",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\validators\\parameter.py",
      "line_number": 78,
      "end_line_number": 86,
      "source_code": "def validate_query_parameter(self, param, request):\n        \"\"\"\n        Validate a single query parameter (request.args in Flask)\n\n        :type param: dict\n        :rtype: str\n        \"\"\"\n        val = request.query_params.get(param[\"name\"])\n        return self.validate_parameter(\"query\", val, param)",
      "docstring": "Validate a single query parameter (request.args in Flask)\n\n:type param: dict\n:rtype: str",
      "decorators": [],
      "arguments": [
        "self",
        "param",
        "request"
      ],
      "imports": [
        "collections",
        "copy",
        "logging",
        "jsonschema.Draft4Validator",
        "jsonschema.ValidationError",
        "connexion.exceptions.BadRequestProblem",
        "connexion.exceptions.ExtraParameterProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.boolean",
        "connexion.utils.is_null",
        "connexion.utils.is_nullable",
        "jsonschema.draft4_format_checker"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "request.query_params.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "self.validate_parameter",
          "body": "@staticmethod\ndef validate_parameter(parameter_type, value, param, param_name=None):\n    if is_nullable(param) and is_null(value):\n        return\n    elif value is not None:\n        param = copy.deepcopy(param)\n        param = param.get('schema', param)\n        try:\n            Draft4Validator(param, format_checker=draft4_format_checker).validate(value)\n        except ValidationError as exception:\n            return str(exception)\n    elif param.get('required'):\n        return \"Missing {parameter_type} parameter '{param[name]}'\".format(**locals())"
        }
      ]
    },
    {
      "name": "validate_path_parameter",
      "module": "parameter",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\validators\\parameter.py",
      "line_number": 88,
      "end_line_number": 90,
      "source_code": "def validate_path_parameter(self, param, request):\n        val = request.path_params.get(param[\"name\"].replace(\"-\", \"_\"))\n        return self.validate_parameter(\"path\", val, param)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "param",
        "request"
      ],
      "imports": [
        "collections",
        "copy",
        "logging",
        "jsonschema.Draft4Validator",
        "jsonschema.ValidationError",
        "connexion.exceptions.BadRequestProblem",
        "connexion.exceptions.ExtraParameterProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.boolean",
        "connexion.utils.is_null",
        "connexion.utils.is_nullable",
        "jsonschema.draft4_format_checker"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "request.path_params.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "self.validate_parameter",
          "body": "@staticmethod\ndef validate_parameter(parameter_type, value, param, param_name=None):\n    if is_nullable(param) and is_null(value):\n        return\n    elif value is not None:\n        param = copy.deepcopy(param)\n        param = param.get('schema', param)\n        try:\n            Draft4Validator(param, format_checker=draft4_format_checker).validate(value)\n        except ValidationError as exception:\n            return str(exception)\n    elif param.get('required'):\n        return \"Missing {parameter_type} parameter '{param[name]}'\".format(**locals())"
        }
      ]
    },
    {
      "name": "validate_header_parameter",
      "module": "parameter",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\validators\\parameter.py",
      "line_number": 92,
      "end_line_number": 94,
      "source_code": "def validate_header_parameter(self, param, request):\n        val = request.headers.get(param[\"name\"])\n        return self.validate_parameter(\"header\", val, param)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "param",
        "request"
      ],
      "imports": [
        "collections",
        "copy",
        "logging",
        "jsonschema.Draft4Validator",
        "jsonschema.ValidationError",
        "connexion.exceptions.BadRequestProblem",
        "connexion.exceptions.ExtraParameterProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.boolean",
        "connexion.utils.is_null",
        "connexion.utils.is_nullable",
        "jsonschema.draft4_format_checker"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "request.headers.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "self.validate_parameter",
          "body": "@staticmethod\ndef validate_parameter(parameter_type, value, param, param_name=None):\n    if is_nullable(param) and is_null(value):\n        return\n    elif value is not None:\n        param = copy.deepcopy(param)\n        param = param.get('schema', param)\n        try:\n            Draft4Validator(param, format_checker=draft4_format_checker).validate(value)\n        except ValidationError as exception:\n            return str(exception)\n    elif param.get('required'):\n        return \"Missing {parameter_type} parameter '{param[name]}'\".format(**locals())"
        }
      ]
    },
    {
      "name": "validate_cookie_parameter",
      "module": "parameter",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\validators\\parameter.py",
      "line_number": 96,
      "end_line_number": 98,
      "source_code": "def validate_cookie_parameter(self, param, request):\n        val = request.cookies.get(param[\"name\"])\n        return self.validate_parameter(\"cookie\", val, param)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "param",
        "request"
      ],
      "imports": [
        "collections",
        "copy",
        "logging",
        "jsonschema.Draft4Validator",
        "jsonschema.ValidationError",
        "connexion.exceptions.BadRequestProblem",
        "connexion.exceptions.ExtraParameterProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.boolean",
        "connexion.utils.is_null",
        "connexion.utils.is_nullable",
        "jsonschema.draft4_format_checker"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "request.cookies.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "self.validate_parameter",
          "body": "@staticmethod\ndef validate_parameter(parameter_type, value, param, param_name=None):\n    if is_nullable(param) and is_null(value):\n        return\n    elif value is not None:\n        param = copy.deepcopy(param)\n        param = param.get('schema', param)\n        try:\n            Draft4Validator(param, format_checker=draft4_format_checker).validate(value)\n        except ValidationError as exception:\n            return str(exception)\n    elif param.get('required'):\n        return \"Missing {parameter_type} parameter '{param[name]}'\".format(**locals())"
        }
      ]
    },
    {
      "name": "validate",
      "module": "parameter",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\validators\\parameter.py",
      "line_number": 100,
      "end_line_number": 104,
      "source_code": "def validate(self, scope):\n        logger.debug(\"%s validating parameters...\", scope.get(\"path\"))\n\n        request = ConnexionRequest(scope, uri_parser=self.uri_parser)\n        self.validate_request(request)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "scope"
      ],
      "imports": [
        "collections",
        "copy",
        "logging",
        "jsonschema.Draft4Validator",
        "jsonschema.ValidationError",
        "connexion.exceptions.BadRequestProblem",
        "connexion.exceptions.ExtraParameterProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.boolean",
        "connexion.utils.is_null",
        "connexion.utils.is_nullable",
        "jsonschema.draft4_format_checker"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.validate_request",
          "body": "def validate_request(self, request):\n    if self.strict_validation:\n        query_errors = self.validate_query_parameter_list(request, security_params=self.security_query_params)\n        if query_errors:\n            raise ExtraParameterProblem(param_type='query', extra_params=query_errors)\n    for param in self.parameters.get('query', []):\n        error = self.validate_query_parameter(param, request)\n        if error:\n            raise BadRequestProblem(detail=error)\n    for param in self.parameters.get('path', []):\n        error = self.validate_path_parameter(param, request)\n        if error:\n            raise BadRequestProblem(detail=error)\n    for param in self.parameters.get('header', []):\n        error = self.validate_header_parameter(param, request)\n        if error:\n            raise BadRequestProblem(detail=error)\n    for param in self.parameters.get('cookie', []):\n        error = self.validate_cookie_parameter(param, request)\n        if error:\n            raise BadRequestProblem(detail=error)"
        },
        {
          "name": "scope.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        }
      ]
    },
    {
      "name": "validate_request",
      "module": "parameter",
      "class_name": null,
      "file_path": "__internal__\\_data\\connexion\\connexion\\validators\\parameter.py",
      "line_number": 106,
      "end_line_number": 135,
      "source_code": "def validate_request(self, request):\n        if self.strict_validation:\n            query_errors = self.validate_query_parameter_list(\n                request, security_params=self.security_query_params\n            )\n\n            if query_errors:\n                raise ExtraParameterProblem(\n                    param_type=\"query\", extra_params=query_errors\n                )\n\n        for param in self.parameters.get(\"query\", []):\n            error = self.validate_query_parameter(param, request)\n            if error:\n                raise BadRequestProblem(detail=error)\n\n        for param in self.parameters.get(\"path\", []):\n            error = self.validate_path_parameter(param, request)\n            if error:\n                raise BadRequestProblem(detail=error)\n\n        for param in self.parameters.get(\"header\", []):\n            error = self.validate_header_parameter(param, request)\n            if error:\n                raise BadRequestProblem(detail=error)\n\n        for param in self.parameters.get(\"cookie\", []):\n            error = self.validate_cookie_parameter(param, request)\n            if error:\n                raise BadRequestProblem(detail=error)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "request"
      ],
      "imports": [
        "collections",
        "copy",
        "logging",
        "jsonschema.Draft4Validator",
        "jsonschema.ValidationError",
        "connexion.exceptions.BadRequestProblem",
        "connexion.exceptions.ExtraParameterProblem",
        "connexion.lifecycle.ConnexionRequest",
        "connexion.utils.boolean",
        "connexion.utils.is_null",
        "connexion.utils.is_nullable",
        "jsonschema.draft4_format_checker"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.parameters.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "self.parameters.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "self.parameters.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "self.parameters.get",
          "body": "def get(self, item, default=None):\n    try:\n        return self[item]\n    except KeyError:\n        return default"
        },
        {
          "name": "self.validate_query_parameter_list",
          "body": "def validate_query_parameter_list(self, request, security_params=None):\n    request_params = request.query_params.keys()\n    spec_params = [x['name'] for x in self.parameters.get('query', [])]\n    spec_params.extend(security_params or [])\n    return self.validate_parameter_list(request_params, spec_params)"
        },
        {
          "name": "self.validate_query_parameter",
          "body": "def validate_query_parameter(self, param, request):\n    \"\"\"\n        Validate a single query parameter (request.args in Flask)\n\n        :type param: dict\n        :rtype: str\n        \"\"\"\n    val = request.query_params.get(param['name'])\n    return self.validate_parameter('query', val, param)"
        },
        {
          "name": "self.validate_path_parameter",
          "body": "def validate_path_parameter(self, param, request):\n    val = request.path_params.get(param['name'].replace('-', '_'))\n    return self.validate_parameter('path', val, param)"
        },
        {
          "name": "self.validate_header_parameter",
          "body": "def validate_header_parameter(self, param, request):\n    val = request.headers.get(param['name'])\n    return self.validate_parameter('header', val, param)"
        },
        {
          "name": "self.validate_cookie_parameter",
          "body": "def validate_cookie_parameter(self, param, request):\n    val = request.cookies.get(param['name'])\n    return self.validate_parameter('cookie', val, param)"
        }
      ]
    }
  ]
}