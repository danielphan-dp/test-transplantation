{
  "tests": [
    {
      "name": "__init__",
      "module": "applications",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\applications.py",
      "line_number": 64,
      "end_line_number": 964,
      "source_code": "def __init__(\n        self: AppType,\n        *,\n        debug: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Boolean indicating if debug tracebacks should be returned on server\n                errors.\n\n                Read more in the\n                [Starlette docs for Applications](https://www.starlette.io/applications/#instantiating-the-application).\n                \"\"\"\n            ),\n        ] = False,\n        routes: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                **Note**: you probably shouldn't use this parameter, it is inherited\n                from Starlette and supported for compatibility.\n\n                ---\n\n                A list of routes to serve incoming HTTP and WebSocket requests.\n                \"\"\"\n            ),\n            deprecated(\n                \"\"\"\n                You normally wouldn't use this parameter with FastAPI, it is inherited\n                from Starlette and supported for compatibility.\n\n                In FastAPI, you normally would use the *path operation methods*,\n                like `app.get()`, `app.post()`, etc.\n                \"\"\"\n            ),\n        ] = None,\n        title: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The title of the API.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more in the\n                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).\n\n                **Example**\n\n                ```python\n                from fastapi import FastAPI\n\n                app = FastAPI(title=\"ChimichangApp\")\n                ```\n                \"\"\"\n            ),\n        ] = \"FastAPI\",\n        summary: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A short summary of the API.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more in the\n                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).\n\n                **Example**\n\n                ```python\n                from fastapi import FastAPI\n\n                app = FastAPI(summary=\"Deadpond's favorite app. Nuff said.\")\n                ```\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            str,\n            Doc(\n                '''\n                A description of the API. Supports Markdown (using\n                [CommonMark syntax](https://commonmark.org/)).\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more in the\n                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).\n\n                **Example**\n\n                ```python\n                from fastapi import FastAPI\n\n                app = FastAPI(\n                    description=\"\"\"\n                                ChimichangApp API helps you do awesome stuff. \ud83d\ude80\n\n                                ## Items\n\n                                You can **read items**.\n\n                                ## Users\n\n                                You will be able to:\n\n                                * **Create users** (_not implemented_).\n                                * **Read users** (_not implemented_).\n\n                                \"\"\"\n                )\n                ```\n                '''\n            ),\n        ] = \"\",\n        version: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The version of the API.\n\n                **Note** This is the version of your application, not the version of\n                the OpenAPI specification nor the version of FastAPI being used.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more in the\n                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).\n\n                **Example**\n\n                ```python\n                from fastapi import FastAPI\n\n                app = FastAPI(version=\"0.0.1\")\n                ```\n                \"\"\"\n            ),\n        ] = \"0.1.0\",\n        openapi_url: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                The URL where the OpenAPI schema will be served from.\n\n                If you set it to `None`, no OpenAPI schema will be served publicly, and\n                the default automatic endpoints `/docs` and `/redoc` will also be\n                disabled.\n\n                Read more in the\n                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#openapi-url).\n\n                **Example**\n\n                ```python\n                from fastapi import FastAPI\n\n                app = FastAPI(openapi_url=\"/api/v1/openapi.json\")\n                ```\n                \"\"\"\n            ),\n        ] = \"/openapi.json\",\n        openapi_tags: Annotated[\n            Optional[List[Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                A list of tags used by OpenAPI, these are the same `tags` you can set\n                in the *path operations*, like:\n\n                * `@app.get(\"/users/\", tags=[\"users\"])`\n                * `@app.get(\"/items/\", tags=[\"items\"])`\n\n                The order of the tags can be used to specify the order shown in\n                tools like Swagger UI, used in the automatic path `/docs`.\n\n                It's not required to specify all the tags used.\n\n                The tags that are not declared MAY be organized randomly or based\n                on the tools' logic. Each tag name in the list MUST be unique.\n\n                The value of each item is a `dict` containing:\n\n                * `name`: The name of the tag.\n                * `description`: A short description of the tag.\n                    [CommonMark syntax](https://commonmark.org/) MAY be used for rich\n                    text representation.\n                * `externalDocs`: Additional external documentation for this tag. If\n                    provided, it would contain a `dict` with:\n                    * `description`: A short description of the target documentation.\n                        [CommonMark syntax](https://commonmark.org/) MAY be used for\n                        rich text representation.\n                    * `url`: The URL for the target documentation. Value MUST be in\n                        the form of a URL.\n\n                Read more in the\n                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-tags).\n\n                **Example**\n\n                ```python\n                from fastapi import FastAPI\n\n                tags_metadata = [\n                    {\n                        \"name\": \"users\",\n                        \"description\": \"Operations with users. The **login** logic is also here.\",\n                    },\n                    {\n                        \"name\": \"items\",\n                        \"description\": \"Manage items. So _fancy_ they have their own docs.\",\n                        \"externalDocs\": {\n                            \"description\": \"Items external docs\",\n                            \"url\": \"https://fastapi.tiangolo.com/\",\n                        },\n                    },\n                ]\n\n                app = FastAPI(openapi_tags=tags_metadata)\n                ```\n                \"\"\"\n            ),\n        ] = None,\n        servers: Annotated[\n            Optional[List[Dict[str, Union[str, Any]]]],\n            Doc(\n                \"\"\"\n                A `list` of `dict`s with connectivity information to a target server.\n\n                You would use it, for example, if your application is served from\n                different domains and you want to use the same Swagger UI in the\n                browser to interact with each of them (instead of having multiple\n                browser tabs open). Or if you want to leave fixed the possible URLs.\n\n                If the servers `list` is not provided, or is an empty `list`, the\n                default value would be a `dict` with a `url` value of `/`.\n\n                Each item in the `list` is a `dict` containing:\n\n                * `url`: A URL to the target host. This URL supports Server Variables\n                and MAY be relative, to indicate that the host location is relative\n                to the location where the OpenAPI document is being served. Variable\n                substitutions will be made when a variable is named in `{`brackets`}`.\n                * `description`: An optional string describing the host designated by\n                the URL. [CommonMark syntax](https://commonmark.org/) MAY be used for\n                rich text representation.\n                * `variables`: A `dict` between a variable name and its value. The value\n                    is used for substitution in the server's URL template.\n\n                Read more in the\n                [FastAPI docs for Behind a Proxy](https://fastapi.tiangolo.com/advanced/behind-a-proxy/#additional-servers).\n\n                **Example**\n\n                ```python\n                from fastapi import FastAPI\n\n                app = FastAPI(\n                    servers=[\n                        {\"url\": \"https://stag.example.com\", \"description\": \"Staging environment\"},\n                        {\"url\": \"https://prod.example.com\", \"description\": \"Production environment\"},\n                    ]\n                )\n                ```\n                \"\"\"\n            ),\n        ] = None,\n        dependencies: Annotated[\n            Optional[Sequence[Depends]],\n            Doc(\n                \"\"\"\n                A list of global dependencies, they will be applied to each\n                *path operation*, including in sub-routers.\n\n                Read more about it in the\n                [FastAPI docs for Global Dependencies](https://fastapi.tiangolo.com/tutorial/dependencies/global-dependencies/).\n\n                **Example**\n\n                ```python\n                from fastapi import Depends, FastAPI\n\n                from .dependencies import func_dep_1, func_dep_2\n\n                app = FastAPI(dependencies=[Depends(func_dep_1), Depends(func_dep_2)])\n                ```\n                \"\"\"\n            ),\n        ] = None,\n        default_response_class: Annotated[\n            Type[Response],\n            Doc(\n                \"\"\"\n                The default response class to be used.\n\n                Read more in the\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#default-response-class).\n\n                **Example**\n\n                ```python\n                from fastapi import FastAPI\n                from fastapi.responses import ORJSONResponse\n\n                app = FastAPI(default_response_class=ORJSONResponse)\n                ```\n                \"\"\"\n            ),\n        ] = Default(JSONResponse),\n        redirect_slashes: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Whether to detect and redirect slashes in URLs when the client doesn't\n                use the same format.\n\n                **Example**\n\n                ```python\n                from fastapi import FastAPI\n\n                app = FastAPI(redirect_slashes=True)  # the default\n\n                @app.get(\"/items/\")\n                async def read_items():\n                    return [{\"item_id\": \"Foo\"}]\n                ```\n\n                With this app, if a client goes to `/items` (without a trailing slash),\n                they will be automatically redirected with an HTTP status code of 307\n                to `/items/`.\n                \"\"\"\n            ),\n        ] = True,\n        docs_url: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                The path to the automatic interactive API documentation.\n                It is handled in the browser by Swagger UI.\n\n                The default URL is `/docs`. You can disable it by setting it to `None`.\n\n                If `openapi_url` is set to `None`, this will be automatically disabled.\n\n                Read more in the\n                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#docs-urls).\n\n                **Example**\n\n                ```python\n                from fastapi import FastAPI\n\n                app = FastAPI(docs_url=\"/documentation\", redoc_url=None)\n                ```\n                \"\"\"\n            ),\n        ] = \"/docs\",\n        redoc_url: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                The path to the alternative automatic interactive API documentation\n                provided by ReDoc.\n\n                The default URL is `/redoc`. You can disable it by setting it to `None`.\n\n                If `openapi_url` is set to `None`, this will be automatically disabled.\n\n                Read more in the\n                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#docs-urls).\n\n                **Example**\n\n                ```python\n                from fastapi import FastAPI\n\n                app = FastAPI(docs_url=\"/documentation\", redoc_url=\"redocumentation\")\n                ```\n                \"\"\"\n            ),\n        ] = \"/redoc\",\n        swagger_ui_oauth2_redirect_url: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                The OAuth2 redirect endpoint for the Swagger UI.\n\n                By default it is `/docs/oauth2-redirect`.\n\n                This is only used if you use OAuth2 (with the \"Authorize\" button)\n                with Swagger UI.\n                \"\"\"\n            ),\n        ] = \"/docs/oauth2-redirect\",\n        swagger_ui_init_oauth: Annotated[\n            Optional[Dict[str, Any]],\n            Doc(\n                \"\"\"\n                OAuth2 configuration for the Swagger UI, by default shown at `/docs`.\n\n                Read more about the available configuration options in the\n                [Swagger UI docs](https://swagger.io/docs/open-source-tools/swagger-ui/usage/oauth2/).\n                \"\"\"\n            ),\n        ] = None,\n        middleware: Annotated[\n            Optional[Sequence[Middleware]],\n            Doc(\n                \"\"\"\n                List of middleware to be added when creating the application.\n\n                In FastAPI you would normally do this with `app.add_middleware()`\n                instead.\n\n                Read more in the\n                [FastAPI docs for Middleware](https://fastapi.tiangolo.com/tutorial/middleware/).\n                \"\"\"\n            ),\n        ] = None,\n        exception_handlers: Annotated[\n            Optional[\n                Dict[\n                    Union[int, Type[Exception]],\n                    Callable[[Request, Any], Coroutine[Any, Any, Response]],\n                ]\n            ],\n            Doc(\n                \"\"\"\n                A dictionary with handlers for exceptions.\n\n                In FastAPI, you would normally use the decorator\n                `@app.exception_handler()`.\n\n                Read more in the\n                [FastAPI docs for Handling Errors](https://fastapi.tiangolo.com/tutorial/handling-errors/).\n                \"\"\"\n            ),\n        ] = None,\n        on_startup: Annotated[\n            Optional[Sequence[Callable[[], Any]]],\n            Doc(\n                \"\"\"\n                A list of startup event handler functions.\n\n                You should instead use the `lifespan` handlers.\n\n                Read more in the [FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).\n                \"\"\"\n            ),\n        ] = None,\n        on_shutdown: Annotated[\n            Optional[Sequence[Callable[[], Any]]],\n            Doc(\n                \"\"\"\n                A list of shutdown event handler functions.\n\n                You should instead use the `lifespan` handlers.\n\n                Read more in the\n                [FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).\n                \"\"\"\n            ),\n        ] = None,\n        lifespan: Annotated[\n            Optional[Lifespan[AppType]],\n            Doc(\n                \"\"\"\n                A `Lifespan` context manager handler. This replaces `startup` and\n                `shutdown` functions with a single context manager.\n\n                Read more in the\n                [FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).\n                \"\"\"\n            ),\n        ] = None,\n        terms_of_service: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A URL to the Terms of Service for your API.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more at the\n                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).\n\n                **Example**\n\n                ```python\n                app = FastAPI(terms_of_service=\"http://example.com/terms/\")\n                ```\n                \"\"\"\n            ),\n        ] = None,\n        contact: Annotated[\n            Optional[Dict[str, Union[str, Any]]],\n            Doc(\n                \"\"\"\n                A dictionary with the contact information for the exposed API.\n\n                It can contain several fields.\n\n                * `name`: (`str`) The name of the contact person/organization.\n                * `url`: (`str`) A URL pointing to the contact information. MUST be in\n                    the format of a URL.\n                * `email`: (`str`) The email address of the contact person/organization.\n                    MUST be in the format of an email address.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more at the\n                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).\n\n                **Example**\n\n                ```python\n                app = FastAPI(\n                    contact={\n                        \"name\": \"Deadpoolio the Amazing\",\n                        \"url\": \"http://x-force.example.com/contact/\",\n                        \"email\": \"dp@x-force.example.com\",\n                    }\n                )\n                ```\n                \"\"\"\n            ),\n        ] = None,\n        license_info: Annotated[\n            Optional[Dict[str, Union[str, Any]]],\n            Doc(\n                \"\"\"\n                A dictionary with the license information for the exposed API.\n\n                It can contain several fields.\n\n                * `name`: (`str`) **REQUIRED** (if a `license_info` is set). The\n                    license name used for the API.\n                * `identifier`: (`str`) An [SPDX](https://spdx.dev/) license expression\n                    for the API. The `identifier` field is mutually exclusive of the `url`\n                    field. Available since OpenAPI 3.1.0, FastAPI 0.99.0.\n                * `url`: (`str`) A URL to the license used for the API. This MUST be\n                    the format of a URL.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more at the\n                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).\n\n                **Example**\n\n                ```python\n                app = FastAPI(\n                    license_info={\n                        \"name\": \"Apache 2.0\",\n                        \"url\": \"https://www.apache.org/licenses/LICENSE-2.0.html\",\n                    }\n                )\n                ```\n                \"\"\"\n            ),\n        ] = None,\n        openapi_prefix: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                A URL prefix for the OpenAPI URL.\n                \"\"\"\n            ),\n            deprecated(\n                \"\"\"\n                \"openapi_prefix\" has been deprecated in favor of \"root_path\", which\n                follows more closely the ASGI standard, is simpler, and more\n                automatic.\n                \"\"\"\n            ),\n        ] = \"\",\n        root_path: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                A path prefix handled by a proxy that is not seen by the application\n                but is seen by external clients, which affects things like Swagger UI.\n\n                Read more about it at the\n                [FastAPI docs for Behind a Proxy](https://fastapi.tiangolo.com/advanced/behind-a-proxy/).\n\n                **Example**\n\n                ```python\n                from fastapi import FastAPI\n\n                app = FastAPI(root_path=\"/api/v1\")\n                ```\n                \"\"\"\n            ),\n        ] = \"\",\n        root_path_in_servers: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                To disable automatically generating the URLs in the `servers` field\n                in the autogenerated OpenAPI using the `root_path`.\n\n                Read more about it in the\n                [FastAPI docs for Behind a Proxy](https://fastapi.tiangolo.com/advanced/behind-a-proxy/#disable-automatic-server-from-root_path).\n\n                **Example**\n\n                ```python\n                from fastapi import FastAPI\n\n                app = FastAPI(root_path_in_servers=False)\n                ```\n                \"\"\"\n            ),\n        ] = True,\n        responses: Annotated[\n            Optional[Dict[Union[int, str], Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                Additional responses to be shown in OpenAPI.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Additional Responses in OpenAPI](https://fastapi.tiangolo.com/advanced/additional-responses/).\n\n                And in the\n                [FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).\n                \"\"\"\n            ),\n        ] = None,\n        callbacks: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                OpenAPI callbacks that should apply to all *path operations*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\n                \"\"\"\n            ),\n        ] = None,\n        webhooks: Annotated[\n            Optional[routing.APIRouter],\n            Doc(\n                \"\"\"\n                Add OpenAPI webhooks. This is similar to `callbacks` but it doesn't\n                depend on specific *path operations*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                **Note**: This is available since OpenAPI 3.1.0, FastAPI 0.99.0.\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Webhooks](https://fastapi.tiangolo.com/advanced/openapi-webhooks/).\n                \"\"\"\n            ),\n        ] = None,\n        deprecated: Annotated[\n            Optional[bool],\n            Doc(\n                \"\"\"\n                Mark all *path operations* as deprecated. You probably don't need it,\n                but it's available.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        include_in_schema: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                To include (or not) all the *path operations* in the generated OpenAPI.\n                You probably don't need it, but it's available.\n\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\n                \"\"\"\n            ),\n        ] = True,\n        swagger_ui_parameters: Annotated[\n            Optional[Dict[str, Any]],\n            Doc(\n                \"\"\"\n                Parameters to configure Swagger UI, the autogenerated interactive API\n                documentation (by default at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs about how to Configure Swagger UI](https://fastapi.tiangolo.com/how-to/configure-swagger-ui/).\n                \"\"\"\n            ),\n        ] = None,\n        generate_unique_id_function: Annotated[\n            Callable[[routing.APIRoute], str],\n            Doc(\n                \"\"\"\n                Customize the function used to generate unique IDs for the *path\n                operations* shown in the generated OpenAPI.\n\n                This is particularly useful when automatically generating clients or\n                SDKs for your API.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = Default(generate_unique_id),\n        separate_input_output_schemas: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Whether to generate separate OpenAPI schemas for request body and\n                response body when the results would be more precise.\n\n                This is particularly useful when automatically generating clients.\n\n                For example, if you have a model like:\n\n                ```python\n                from pydantic import BaseModel\n\n                class Item(BaseModel):\n                    name: str\n                    tags: list[str] = []\n                ```\n\n                When `Item` is used for input, a request body, `tags` is not required,\n                the client doesn't have to provide it.\n\n                But when using `Item` for output, for a response body, `tags` is always\n                available because it has a default value, even if it's just an empty\n                list. So, the client should be able to always expect it.\n\n                In this case, there would be two different schemas, one for input and\n                another one for output.\n                \"\"\"\n            ),\n        ] = True,\n        **extra: Annotated[\n            Any,\n            Doc(\n                \"\"\"\n                Extra keyword arguments to be stored in the app, not used by FastAPI\n                anywhere.\n                \"\"\"\n            ),\n        ],\n    ) -> None:\n        self.debug = debug\n        self.title = title\n        self.summary = summary\n        self.description = description\n        self.version = version\n        self.terms_of_service = terms_of_service\n        self.contact = contact\n        self.license_info = license_info\n        self.openapi_url = openapi_url\n        self.openapi_tags = openapi_tags\n        self.root_path_in_servers = root_path_in_servers\n        self.docs_url = docs_url\n        self.redoc_url = redoc_url\n        self.swagger_ui_oauth2_redirect_url = swagger_ui_oauth2_redirect_url\n        self.swagger_ui_init_oauth = swagger_ui_init_oauth\n        self.swagger_ui_parameters = swagger_ui_parameters\n        self.servers = servers or []\n        self.separate_input_output_schemas = separate_input_output_schemas\n        self.extra = extra\n        self.openapi_version: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The version string of OpenAPI.\n\n                FastAPI will generate OpenAPI version 3.1.0, and will output that as\n                the OpenAPI version. But some tools, even though they might be\n                compatible with OpenAPI 3.1.0, might not recognize it as a valid.\n\n                So you could override this value to trick those tools into using\n                the generated OpenAPI. Have in mind that this is a hack. But if you\n                avoid using features added in OpenAPI 3.1.0, it might work for your\n                use case.\n\n                This is not passed as a parameter to the `FastAPI` class to avoid\n                giving the false idea that FastAPI would generate a different OpenAPI\n                schema. It is only available as an attribute.\n\n                **Example**\n\n                ```python\n                from fastapi import FastAPI\n\n                app = FastAPI()\n\n                app.openapi_version = \"3.0.2\"\n                ```\n                \"\"\"\n            ),\n        ] = \"3.1.0\"\n        self.openapi_schema: Optional[Dict[str, Any]] = None\n        if self.openapi_url:\n            assert self.title, \"A title must be provided for OpenAPI, e.g.: 'My API'\"\n            assert self.version, \"A version must be provided for OpenAPI, e.g.: '2.1.0'\"\n        # TODO: remove when discarding the openapi_prefix parameter\n        if openapi_prefix:\n            logger.warning(\n                '\"openapi_prefix\" has been deprecated in favor of \"root_path\", which '\n                \"follows more closely the ASGI standard, is simpler, and more \"\n                \"automatic. Check the docs at \"\n                \"https://fastapi.tiangolo.com/advanced/sub-applications/\"\n            )\n        self.webhooks: Annotated[\n            routing.APIRouter,\n            Doc(\n                \"\"\"\n                The `app.webhooks` attribute is an `APIRouter` with the *path\n                operations* that will be used just for documentation of webhooks.\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Webhooks](https://fastapi.tiangolo.com/advanced/openapi-webhooks/).\n                \"\"\"\n            ),\n        ] = webhooks or routing.APIRouter()\n        self.root_path = root_path or openapi_prefix\n        self.state: Annotated[\n            State,\n            Doc(\n                \"\"\"\n                A state object for the application. This is the same object for the\n                entire application, it doesn't change from request to request.\n\n                You normally wouldn't use this in FastAPI, for most of the cases you\n                would instead use FastAPI dependencies.\n\n                This is simply inherited from Starlette.\n\n                Read more about it in the\n                [Starlette docs for Applications](https://www.starlette.io/applications/#storing-state-on-the-app-instance).\n                \"\"\"\n            ),\n        ] = State()\n        self.dependency_overrides: Annotated[\n            Dict[Callable[..., Any], Callable[..., Any]],\n            Doc(\n                \"\"\"\n                A dictionary with overrides for the dependencies.\n\n                Each key is the original dependency callable, and the value is the\n                actual dependency that should be called.\n\n                This is for testing, to replace expensive dependencies with testing\n                versions.\n\n                Read more about it in the\n                [FastAPI docs for Testing Dependencies with Overrides](https://fastapi.tiangolo.com/advanced/testing-dependencies/).\n                \"\"\"\n            ),\n        ] = {}\n        self.router: routing.APIRouter = routing.APIRouter(\n            routes=routes,\n            redirect_slashes=redirect_slashes,\n            dependency_overrides_provider=self,\n            on_startup=on_startup,\n            on_shutdown=on_shutdown,\n            lifespan=lifespan,\n            default_response_class=default_response_class,\n            dependencies=dependencies,\n            callbacks=callbacks,\n            deprecated=deprecated,\n            include_in_schema=include_in_schema,\n            responses=responses,\n            generate_unique_id_function=generate_unique_id_function,\n        )\n        self.exception_handlers: Dict[\n            Any, Callable[[Request, Any], Union[Response, Awaitable[Response]]]\n        ] = {} if exception_handlers is None else dict(exception_handlers)\n        self.exception_handlers.setdefault(HTTPException, http_exception_handler)\n        self.exception_handlers.setdefault(\n            RequestValidationError, request_validation_exception_handler\n        )\n        self.exception_handlers.setdefault(\n            WebSocketRequestValidationError,\n            # Starlette still has incorrect type specification for the handlers\n            websocket_request_validation_exception_handler,  # type: ignore\n        )\n\n        self.user_middleware: List[Middleware] = (\n            [] if middleware is None else list(middleware)\n        )\n        self.middleware_stack: Union[ASGIApp, None] = None\n        self.setup()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "enum.Enum",
        "typing.Any",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Type",
        "typing.TypeVar",
        "typing.Union",
        "fastapi.routing",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.exception_handlers.http_exception_handler",
        "fastapi.exception_handlers.request_validation_exception_handler",
        "fastapi.exception_handlers.websocket_request_validation_exception_handler",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.logger.logger",
        "fastapi.openapi.docs.get_redoc_html",
        "fastapi.openapi.docs.get_swagger_ui_html",
        "fastapi.openapi.docs.get_swagger_ui_oauth2_redirect_html",
        "fastapi.openapi.utils.get_openapi",
        "fastapi.params.Depends",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.generate_unique_id",
        "starlette.applications.Starlette",
        "starlette.datastructures.State",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.requests.Request",
        "starlette.responses.HTMLResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [
        "assert self.title, \"A title must be provided for OpenAPI, e.g.: 'My API'\"",
        "assert self.version, \"A version must be provided for OpenAPI, e.g.: '2.1.0'\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "self.setup",
          "body": "def setup(self) -> None:\n    if self.openapi_url:\n        urls = (server_data.get('url') for server_data in self.servers)\n        server_urls = {url for url in urls if url}\n\n        async def openapi(req: Request) -> JSONResponse:\n            root_path = req.scope.get('root_path', '').rstrip('/')\n            if root_path not in server_urls:\n                if root_path and self.root_path_in_servers:\n                    self.servers.insert(0, {'url': root_path})\n                    server_urls.add(root_path)\n            return JSONResponse(self.openapi())\n        self.add_route(self.openapi_url, openapi, include_in_schema=False)\n    if self.openapi_url and self.docs_url:\n\n        async def swagger_ui_html(req: Request) -> HTMLResponse:\n            root_path = req.scope.get('root_path', '').rstrip('/')\n            openapi_url = root_path + self.openapi_url\n            oauth2_redirect_url = self.swagger_ui_oauth2_redirect_url\n            if oauth2_redirect_url:\n                oauth2_redirect_url = root_path + oauth2_redirect_url\n            return get_swagger_ui_html(openapi_url=openapi_url, title=f'{self.title} - Swagger UI', oauth2_redirect_url=oauth2_redirect_url, init_oauth=self.swagger_ui_init_oauth, swagger_ui_parameters=self.swagger_ui_parameters)\n        self.add_route(self.docs_url, swagger_ui_html, include_in_schema=False)\n        if self.swagger_ui_oauth2_redirect_url:\n\n            async def swagger_ui_redirect(req: Request) -> HTMLResponse:\n                return get_swagger_ui_oauth2_redirect_html()\n            self.add_route(self.swagger_ui_oauth2_redirect_url, swagger_ui_redirect, include_in_schema=False)\n    if self.openapi_url and self.redoc_url:\n\n        async def redoc_html(req: Request) -> HTMLResponse:\n            root_path = req.scope.get('root_path', '').rstrip('/')\n            openapi_url = root_path + self.openapi_url\n            return get_redoc_html(openapi_url=openapi_url, title=f'{self.title} - ReDoc')\n        self.add_route(self.redoc_url, redoc_html, include_in_schema=False)"
        }
      ]
    },
    {
      "name": "openapi",
      "module": "applications",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\applications.py",
      "line_number": 966,
      "end_line_number": 996,
      "source_code": "def openapi(self) -> Dict[str, Any]:\n        \"\"\"\n        Generate the OpenAPI schema of the application. This is called by FastAPI\n        internally.\n\n        The first time it is called it stores the result in the attribute\n        `app.openapi_schema`, and next times it is called, it just returns that same\n        result. To avoid the cost of generating the schema every time.\n\n        If you need to modify the generated OpenAPI schema, you could modify it.\n\n        Read more in the\n        [FastAPI docs for OpenAPI](https://fastapi.tiangolo.com/how-to/extending-openapi/).\n        \"\"\"\n        if not self.openapi_schema:\n            self.openapi_schema = get_openapi(\n                title=self.title,\n                version=self.version,\n                openapi_version=self.openapi_version,\n                summary=self.summary,\n                description=self.description,\n                terms_of_service=self.terms_of_service,\n                contact=self.contact,\n                license_info=self.license_info,\n                routes=self.routes,\n                webhooks=self.webhooks.routes,\n                tags=self.openapi_tags,\n                servers=self.servers,\n                separate_input_output_schemas=self.separate_input_output_schemas,\n            )\n        return self.openapi_schema",
      "docstring": "Generate the OpenAPI schema of the application. This is called by FastAPI\ninternally.\n\nThe first time it is called it stores the result in the attribute\n`app.openapi_schema`, and next times it is called, it just returns that same\nresult. To avoid the cost of generating the schema every time.\n\nIf you need to modify the generated OpenAPI schema, you could modify it.\n\nRead more in the\n[FastAPI docs for OpenAPI](https://fastapi.tiangolo.com/how-to/extending-openapi/).",
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "enum.Enum",
        "typing.Any",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Type",
        "typing.TypeVar",
        "typing.Union",
        "fastapi.routing",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.exception_handlers.http_exception_handler",
        "fastapi.exception_handlers.request_validation_exception_handler",
        "fastapi.exception_handlers.websocket_request_validation_exception_handler",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.logger.logger",
        "fastapi.openapi.docs.get_redoc_html",
        "fastapi.openapi.docs.get_swagger_ui_html",
        "fastapi.openapi.docs.get_swagger_ui_oauth2_redirect_html",
        "fastapi.openapi.utils.get_openapi",
        "fastapi.params.Depends",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.generate_unique_id",
        "starlette.applications.Starlette",
        "starlette.datastructures.State",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.requests.Request",
        "starlette.responses.HTMLResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_openapi",
          "body": "def get_openapi(*, title: str, version: str, openapi_version: str='3.1.0', summary: Optional[str]=None, description: Optional[str]=None, routes: Sequence[BaseRoute], webhooks: Optional[Sequence[BaseRoute]]=None, tags: Optional[List[Dict[str, Any]]]=None, servers: Optional[List[Dict[str, Union[str, Any]]]]=None, terms_of_service: Optional[str]=None, contact: Optional[Dict[str, Union[str, Any]]]=None, license_info: Optional[Dict[str, Union[str, Any]]]=None, separate_input_output_schemas: bool=True) -> Dict[str, Any]:\n    info: Dict[str, Any] = {'title': title, 'version': version}\n    if summary:\n        info['summary'] = summary\n    if description:\n        info['description'] = description\n    if terms_of_service:\n        info['termsOfService'] = terms_of_service\n    if contact:\n        info['contact'] = contact\n    if license_info:\n        info['license'] = license_info\n    output: Dict[str, Any] = {'openapi': openapi_version, 'info': info}\n    if servers:\n        output['servers'] = servers\n    components: Dict[str, Dict[str, Any]] = {}\n    paths: Dict[str, Dict[str, Any]] = {}\n    webhook_paths: Dict[str, Dict[str, Any]] = {}\n    operation_ids: Set[str] = set()\n    all_fields = get_fields_from_routes(list(routes or []) + list(webhooks or []))\n    model_name_map = get_compat_model_name_map(all_fields)\n    schema_generator = GenerateJsonSchema(ref_template=REF_TEMPLATE)\n    field_mapping, definitions = get_definitions(fields=all_fields, schema_generator=schema_generator, model_name_map=model_name_map, separate_input_output_schemas=separate_input_output_schemas)\n    for route in routes or []:\n        if isinstance(route, routing.APIRoute):\n            result = get_openapi_path(route=route, operation_ids=operation_ids, schema_generator=schema_generator, model_name_map=model_name_map, field_mapping=field_mapping, separate_input_output_schemas=separate_input_output_schemas)\n            if result:\n                path, security_schemes, path_definitions = result\n                if path:\n                    paths.setdefault(route.path_format, {}).update(path)\n                if security_schemes:\n                    components.setdefault('securitySchemes', {}).update(security_schemes)\n                if path_definitions:\n                    definitions.update(path_definitions)\n    for webhook in webhooks or []:\n        if isinstance(webhook, routing.APIRoute):\n            result = get_openapi_path(route=webhook, operation_ids=operation_ids, schema_generator=schema_generator, model_name_map=model_name_map, field_mapping=field_mapping, separate_input_output_schemas=separate_input_output_schemas)\n            if result:\n                path, security_schemes, path_definitions = result\n                if path:\n                    webhook_paths.setdefault(webhook.path_format, {}).update(path)\n                if security_schemes:\n                    components.setdefault('securitySchemes', {}).update(security_schemes)\n                if path_definitions:\n                    definitions.update(path_definitions)\n    if definitions:\n        components['schemas'] = {k: definitions[k] for k in sorted(definitions)}\n    if components:\n        output['components'] = components\n    output['paths'] = paths\n    if webhook_paths:\n        output['webhooks'] = webhook_paths\n    if tags:\n        output['tags'] = tags\n    return jsonable_encoder(OpenAPI(**output), by_alias=True, exclude_none=True)"
        }
      ]
    },
    {
      "name": "setup",
      "module": "applications",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\applications.py",
      "line_number": 998,
      "end_line_number": 1049,
      "source_code": "def setup(self) -> None:\n        if self.openapi_url:\n            urls = (server_data.get(\"url\") for server_data in self.servers)\n            server_urls = {url for url in urls if url}\n\n            async def openapi(req: Request) -> JSONResponse:\n                root_path = req.scope.get(\"root_path\", \"\").rstrip(\"/\")\n                if root_path not in server_urls:\n                    if root_path and self.root_path_in_servers:\n                        self.servers.insert(0, {\"url\": root_path})\n                        server_urls.add(root_path)\n                return JSONResponse(self.openapi())\n\n            self.add_route(self.openapi_url, openapi, include_in_schema=False)\n        if self.openapi_url and self.docs_url:\n\n            async def swagger_ui_html(req: Request) -> HTMLResponse:\n                root_path = req.scope.get(\"root_path\", \"\").rstrip(\"/\")\n                openapi_url = root_path + self.openapi_url\n                oauth2_redirect_url = self.swagger_ui_oauth2_redirect_url\n                if oauth2_redirect_url:\n                    oauth2_redirect_url = root_path + oauth2_redirect_url\n                return get_swagger_ui_html(\n                    openapi_url=openapi_url,\n                    title=f\"{self.title} - Swagger UI\",\n                    oauth2_redirect_url=oauth2_redirect_url,\n                    init_oauth=self.swagger_ui_init_oauth,\n                    swagger_ui_parameters=self.swagger_ui_parameters,\n                )\n\n            self.add_route(self.docs_url, swagger_ui_html, include_in_schema=False)\n\n            if self.swagger_ui_oauth2_redirect_url:\n\n                async def swagger_ui_redirect(req: Request) -> HTMLResponse:\n                    return get_swagger_ui_oauth2_redirect_html()\n\n                self.add_route(\n                    self.swagger_ui_oauth2_redirect_url,\n                    swagger_ui_redirect,\n                    include_in_schema=False,\n                )\n        if self.openapi_url and self.redoc_url:\n\n            async def redoc_html(req: Request) -> HTMLResponse:\n                root_path = req.scope.get(\"root_path\", \"\").rstrip(\"/\")\n                openapi_url = root_path + self.openapi_url\n                return get_redoc_html(\n                    openapi_url=openapi_url, title=f\"{self.title} - ReDoc\"\n                )\n\n            self.add_route(self.redoc_url, redoc_html, include_in_schema=False)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "enum.Enum",
        "typing.Any",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Type",
        "typing.TypeVar",
        "typing.Union",
        "fastapi.routing",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.exception_handlers.http_exception_handler",
        "fastapi.exception_handlers.request_validation_exception_handler",
        "fastapi.exception_handlers.websocket_request_validation_exception_handler",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.logger.logger",
        "fastapi.openapi.docs.get_redoc_html",
        "fastapi.openapi.docs.get_swagger_ui_html",
        "fastapi.openapi.docs.get_swagger_ui_oauth2_redirect_html",
        "fastapi.openapi.utils.get_openapi",
        "fastapi.params.Depends",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.generate_unique_id",
        "starlette.applications.Starlette",
        "starlette.datastructures.State",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.requests.Request",
        "starlette.responses.HTMLResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "server_data.get",
          "body": "def get(self, path: Annotated[str, Doc('\\n                The URL path to be used for this *path operation*.\\n\\n                For example, in `http://example.com/items`, the path is `/items`.\\n                ')], *, response_model: Annotated[Any, Doc(\"\\n                The type to use for the response.\\n\\n                It could be any valid Pydantic *field* type. So, it doesn't have to\\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\\n                etc.\\n\\n                It will be used for:\\n\\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\\n                    show it as the response (JSON Schema).\\n                * Serialization: you could return an arbitrary object and the\\n                    `response_model` would be used to serialize that object into the\\n                    corresponding JSON.\\n                * Filtering: the JSON sent to the client will only contain the data\\n                    (fields) defined in the `response_model`. If you returned an object\\n                    that contains an attribute `password` but the `response_model` does\\n                    not include that field, the JSON sent to the client would not have\\n                    that `password`.\\n                * Validation: whatever you return will be serialized with the\\n                    `response_model`, converting any data as necessary to generate the\\n                    corresponding JSON. But if the data in the object returned is not\\n                    valid, that would mean a violation of the contract with the client,\\n                    so it's an error from the API developer. So, FastAPI will raise an\\n                    error and return a 500 error code (Internal Server Error).\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\\n                \")]=Default(None), status_code: Annotated[Optional[int], Doc('\\n                The default status code to be used for the response.\\n\\n                You could override the status code by returning a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\\n                ')]=None, tags: Annotated[Optional[List[Union[str, Enum]]], Doc('\\n                A list of tags to be applied to the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\\n                ')]=None, dependencies: Annotated[Optional[Sequence[Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to the\\n                *path operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\\n                ')]=None, summary: Annotated[Optional[str], Doc('\\n                A summary for the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, description: Annotated[Optional[str], Doc('\\n                A description for the *path operation*.\\n\\n                If not provided, it will be extracted automatically from the docstring\\n                of the *path operation function*.\\n\\n                It can contain Markdown.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, response_description: Annotated[str, Doc('\\n                The description for the default response.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]='Successful Response', responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses that could be returned by this *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark this *path operation* as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, operation_id: Annotated[Optional[str], Doc('\\n                Custom operation ID to be used by this *path operation*.\\n\\n                By default, it is generated automatically.\\n\\n                If you provide a custom operation ID, you need to make sure it is\\n                unique for the whole API.\\n\\n                You can customize the\\n                operation ID generation with the parameter\\n                `generate_unique_id_function` in the `FastAPI` class.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=None, response_model_include: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to include only certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_exclude: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to exclude certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_by_alias: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response model\\n                should be serialized by alias when an alias is used.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=True, response_model_exclude_unset: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that were not set and\\n                have their default values. This is different from\\n                `response_model_exclude_defaults` in that if the fields are set,\\n                they will be included in the response, even if the value is the same\\n                as the default.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_defaults: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that have the same value\\n                as the default. This is different from `response_model_exclude_unset`\\n                in that if the fields are set but contain the same default values,\\n                they will be excluded from the response.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_none: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data should\\n                exclude fields set to `None`.\\n\\n                This is much simpler (less smart) than `response_model_exclude_unset`\\n                and `response_model_exclude_defaults`. You probably want to use one of\\n                those two instead of this one, as those allow returning `None` values\\n                when it makes sense.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\\n                ')]=False, include_in_schema: Annotated[bool, Doc('\\n                Include this *path operation* in the generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\\n                ')]=True, response_class: Annotated[Type[Response], Doc('\\n                Response class to be used for this *path operation*.\\n\\n                This will not be used if you return a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\\n                ')]=Default(JSONResponse), name: Annotated[Optional[str], Doc('\\n                Name for this *path operation*. Only used internally.\\n                ')]=None, callbacks: Annotated[Optional[List[BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")]=None, openapi_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n                Extra metadata to be included in the OpenAPI schema for this *path\\n                operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\\n                ')]=None, generate_unique_id_function: Annotated[Callable[[routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=Default(generate_unique_id)) -> Callable[[DecoratedCallable], DecoratedCallable]:\n    \"\"\"\n        Add a *path operation* using an HTTP GET operation.\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI\n\n        app = FastAPI()\n\n        @app.get(\"/items/\")\n        def read_items():\n            return [{\"name\": \"Empanada\"}, {\"name\": \"Arepa\"}]\n        ```\n        \"\"\"\n    return self.router.get(path, response_model=response_model, status_code=status_code, tags=tags, dependencies=dependencies, summary=summary, description=description, response_description=response_description, responses=responses, deprecated=deprecated, operation_id=operation_id, response_model_include=response_model_include, response_model_exclude=response_model_exclude, response_model_by_alias=response_model_by_alias, response_model_exclude_unset=response_model_exclude_unset, response_model_exclude_defaults=response_model_exclude_defaults, response_model_exclude_none=response_model_exclude_none, include_in_schema=include_in_schema, response_class=response_class, name=name, callbacks=callbacks, openapi_extra=openapi_extra, generate_unique_id_function=generate_unique_id_function)"
        },
        {
          "name": "get_swagger_ui_html",
          "body": "def get_swagger_ui_html(*, openapi_url: Annotated[str, Doc('\\n            The OpenAPI URL that Swagger UI should load and use.\\n\\n            This is normally done automatically by FastAPI using the default URL\\n            `/openapi.json`.\\n            ')], title: Annotated[str, Doc('\\n            The HTML `<title>` content, normally shown in the browser tab.\\n            ')], swagger_js_url: Annotated[str, Doc('\\n            The URL to use to load the Swagger UI JavaScript.\\n\\n            It is normally set to a CDN URL.\\n            ')]='https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui-bundle.js', swagger_css_url: Annotated[str, Doc('\\n            The URL to use to load the Swagger UI CSS.\\n\\n            It is normally set to a CDN URL.\\n            ')]='https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui.css', swagger_favicon_url: Annotated[str, Doc('\\n            The URL of the favicon to use. It is normally shown in the browser tab.\\n            ')]='https://fastapi.tiangolo.com/img/favicon.png', oauth2_redirect_url: Annotated[Optional[str], Doc('\\n            The OAuth2 redirect URL, it is normally automatically handled by FastAPI.\\n            ')]=None, init_oauth: Annotated[Optional[Dict[str, Any]], Doc('\\n            A dictionary with Swagger UI OAuth2 initialization configurations.\\n            ')]=None, swagger_ui_parameters: Annotated[Optional[Dict[str, Any]], Doc('\\n            Configuration parameters for Swagger UI.\\n\\n            It defaults to [swagger_ui_default_parameters][fastapi.openapi.docs.swagger_ui_default_parameters].\\n            ')]=None) -> HTMLResponse:\n    \"\"\"\n    Generate and return the HTML  that loads Swagger UI for the interactive\n    API docs (normally served at `/docs`).\n\n    You would only call this function yourself if you needed to override some parts,\n    for example the URLs to use to load Swagger UI's JavaScript and CSS.\n\n    Read more about it in the\n    [FastAPI docs for Configure Swagger UI](https://fastapi.tiangolo.com/how-to/configure-swagger-ui/)\n    and the [FastAPI docs for Custom Docs UI Static Assets (Self-Hosting)](https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/).\n    \"\"\"\n    current_swagger_ui_parameters = swagger_ui_default_parameters.copy()\n    if swagger_ui_parameters:\n        current_swagger_ui_parameters.update(swagger_ui_parameters)\n    html = f\"\"\"\\n    <!DOCTYPE html>\\n    <html>\\n    <head>\\n    <link type=\"text/css\" rel=\"stylesheet\" href=\"{swagger_css_url}\">\\n    <link rel=\"shortcut icon\" href=\"{swagger_favicon_url}\">\\n    <title>{title}</title>\\n    </head>\\n    <body>\\n    <div id=\"swagger-ui\">\\n    </div>\\n    <script src=\"{swagger_js_url}\"></script>\\n    <!-- `SwaggerUIBundle` is now available on the page -->\\n    <script>\\n    const ui = SwaggerUIBundle({{\\n        url: '{openapi_url}',\\n    \"\"\"\n    for key, value in current_swagger_ui_parameters.items():\n        html += f'{json.dumps(key)}: {json.dumps(jsonable_encoder(value))},\\n'\n    if oauth2_redirect_url:\n        html += f\"oauth2RedirectUrl: window.location.origin + '{oauth2_redirect_url}',\"\n    html += '\\n    presets: [\\n        SwaggerUIBundle.presets.apis,\\n        SwaggerUIBundle.SwaggerUIStandalonePreset\\n        ],\\n    })'\n    if init_oauth:\n        html += f'\\n        ui.initOAuth({json.dumps(jsonable_encoder(init_oauth))})\\n        '\n    html += '\\n    </script>\\n    </body>\\n    </html>\\n    '\n    return HTMLResponse(html)"
        },
        {
          "name": "get_redoc_html",
          "body": "def get_redoc_html(*, openapi_url: Annotated[str, Doc('\\n            The OpenAPI URL that ReDoc should load and use.\\n\\n            This is normally done automatically by FastAPI using the default URL\\n            `/openapi.json`.\\n            ')], title: Annotated[str, Doc('\\n            The HTML `<title>` content, normally shown in the browser tab.\\n            ')], redoc_js_url: Annotated[str, Doc('\\n            The URL to use to load the ReDoc JavaScript.\\n\\n            It is normally set to a CDN URL.\\n            ')]='https://cdn.jsdelivr.net/npm/redoc@next/bundles/redoc.standalone.js', redoc_favicon_url: Annotated[str, Doc('\\n            The URL of the favicon to use. It is normally shown in the browser tab.\\n            ')]='https://fastapi.tiangolo.com/img/favicon.png', with_google_fonts: Annotated[bool, Doc('\\n            Load and use Google Fonts.\\n            ')]=True) -> HTMLResponse:\n    \"\"\"\n    Generate and return the HTML response that loads ReDoc for the alternative\n    API docs (normally served at `/redoc`).\n\n    You would only call this function yourself if you needed to override some parts,\n    for example the URLs to use to load ReDoc's JavaScript and CSS.\n\n    Read more about it in the\n    [FastAPI docs for Custom Docs UI Static Assets (Self-Hosting)](https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/).\n    \"\"\"\n    html = f'\\n    <!DOCTYPE html>\\n    <html>\\n    <head>\\n    <title>{title}</title>\\n    <!-- needed for adaptive design -->\\n    <meta charset=\"utf-8\"/>\\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n    '\n    if with_google_fonts:\n        html += '\\n    <link href=\"https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:300,400,700\" rel=\"stylesheet\">\\n    '\n    html += f'''\\n    <link rel=\"shortcut icon\" href=\"{redoc_favicon_url}\">\\n    <!--\\n    ReDoc doesn't change outer page styles\\n    -->\\n    <style>\\n      body {{\\n        margin: 0;\\n        padding: 0;\\n      }}\\n    </style>\\n    </head>\\n    <body>\\n    <noscript>\\n        ReDoc requires Javascript to function. Please enable it to browse the documentation.\\n    </noscript>\\n    <redoc spec-url=\"{openapi_url}\"></redoc>\\n    <script src=\"{redoc_js_url}\"> </script>\\n    </body>\\n    </html>\\n    '''\n    return HTMLResponse(html)"
        },
        {
          "name": "self.openapi",
          "body": "def openapi(self) -> Dict[str, Any]:\n    \"\"\"\n        Generate the OpenAPI schema of the application. This is called by FastAPI\n        internally.\n\n        The first time it is called it stores the result in the attribute\n        `app.openapi_schema`, and next times it is called, it just returns that same\n        result. To avoid the cost of generating the schema every time.\n\n        If you need to modify the generated OpenAPI schema, you could modify it.\n\n        Read more in the\n        [FastAPI docs for OpenAPI](https://fastapi.tiangolo.com/how-to/extending-openapi/).\n        \"\"\"\n    if not self.openapi_schema:\n        self.openapi_schema = get_openapi(title=self.title, version=self.version, openapi_version=self.openapi_version, summary=self.summary, description=self.description, terms_of_service=self.terms_of_service, contact=self.contact, license_info=self.license_info, routes=self.routes, webhooks=self.webhooks.routes, tags=self.openapi_tags, servers=self.servers, separate_input_output_schemas=self.separate_input_output_schemas)\n    return self.openapi_schema"
        },
        {
          "name": "get_swagger_ui_oauth2_redirect_html",
          "body": "def get_swagger_ui_oauth2_redirect_html() -> HTMLResponse:\n    \"\"\"\n    Generate the HTML response with the OAuth2 redirection for Swagger UI.\n\n    You normally don't need to use or change this.\n    \"\"\"\n    html = '\\n    <!doctype html>\\n    <html lang=\"en-US\">\\n    <head>\\n        <title>Swagger UI: OAuth2 Redirect</title>\\n    </head>\\n    <body>\\n    <script>\\n        \\'use strict\\';\\n        function run () {\\n            var oauth2 = window.opener.swaggerUIRedirectOauth2;\\n            var sentState = oauth2.state;\\n            var redirectUrl = oauth2.redirectUrl;\\n            var isValid, qp, arr;\\n\\n            if (/code|token|error/.test(window.location.hash)) {\\n                qp = window.location.hash.substring(1).replace(\\'?\\', \\'&\\');\\n            } else {\\n                qp = location.search.substring(1);\\n            }\\n\\n            arr = qp.split(\"&\");\\n            arr.forEach(function (v,i,_arr) { _arr[i] = \\'\"\\' + v.replace(\\'=\\', \\'\":\"\\') + \\'\"\\';});\\n            qp = qp ? JSON.parse(\\'{\\' + arr.join() + \\'}\\',\\n                    function (key, value) {\\n                        return key === \"\" ? value : decodeURIComponent(value);\\n                    }\\n            ) : {};\\n\\n            isValid = qp.state === sentState;\\n\\n            if ((\\n              oauth2.auth.schema.get(\"flow\") === \"accessCode\" ||\\n              oauth2.auth.schema.get(\"flow\") === \"authorizationCode\" ||\\n              oauth2.auth.schema.get(\"flow\") === \"authorization_code\"\\n            ) && !oauth2.auth.code) {\\n                if (!isValid) {\\n                    oauth2.errCb({\\n                        authId: oauth2.auth.name,\\n                        source: \"auth\",\\n                        level: \"warning\",\\n                        message: \"Authorization may be unsafe, passed state was changed in server. The passed state wasn\\'t returned from auth server.\"\\n                    });\\n                }\\n\\n                if (qp.code) {\\n                    delete oauth2.state;\\n                    oauth2.auth.code = qp.code;\\n                    oauth2.callback({auth: oauth2.auth, redirectUrl: redirectUrl});\\n                } else {\\n                    let oauthErrorMsg;\\n                    if (qp.error) {\\n                        oauthErrorMsg = \"[\"+qp.error+\"]: \" +\\n                            (qp.error_description ? qp.error_description+ \". \" : \"no accessCode received from the server. \") +\\n                            (qp.error_uri ? \"More info: \"+qp.error_uri : \"\");\\n                    }\\n\\n                    oauth2.errCb({\\n                        authId: oauth2.auth.name,\\n                        source: \"auth\",\\n                        level: \"error\",\\n                        message: oauthErrorMsg || \"[Authorization failed]: no accessCode received from the server.\"\\n                    });\\n                }\\n            } else {\\n                oauth2.callback({auth: oauth2.auth, token: qp, isValid: isValid, redirectUrl: redirectUrl});\\n            }\\n            window.close();\\n        }\\n\\n        if (document.readyState !== \\'loading\\') {\\n            run();\\n        } else {\\n            document.addEventListener(\\'DOMContentLoaded\\', function () {\\n                run();\\n            });\\n        }\\n    </script>\\n    </body>\\n    </html>\\n        '\n    return HTMLResponse(content=html)"
        },
        {
          "name": "req.scope.get",
          "body": "def get(self, path: Annotated[str, Doc('\\n                The URL path to be used for this *path operation*.\\n\\n                For example, in `http://example.com/items`, the path is `/items`.\\n                ')], *, response_model: Annotated[Any, Doc(\"\\n                The type to use for the response.\\n\\n                It could be any valid Pydantic *field* type. So, it doesn't have to\\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\\n                etc.\\n\\n                It will be used for:\\n\\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\\n                    show it as the response (JSON Schema).\\n                * Serialization: you could return an arbitrary object and the\\n                    `response_model` would be used to serialize that object into the\\n                    corresponding JSON.\\n                * Filtering: the JSON sent to the client will only contain the data\\n                    (fields) defined in the `response_model`. If you returned an object\\n                    that contains an attribute `password` but the `response_model` does\\n                    not include that field, the JSON sent to the client would not have\\n                    that `password`.\\n                * Validation: whatever you return will be serialized with the\\n                    `response_model`, converting any data as necessary to generate the\\n                    corresponding JSON. But if the data in the object returned is not\\n                    valid, that would mean a violation of the contract with the client,\\n                    so it's an error from the API developer. So, FastAPI will raise an\\n                    error and return a 500 error code (Internal Server Error).\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\\n                \")]=Default(None), status_code: Annotated[Optional[int], Doc('\\n                The default status code to be used for the response.\\n\\n                You could override the status code by returning a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\\n                ')]=None, tags: Annotated[Optional[List[Union[str, Enum]]], Doc('\\n                A list of tags to be applied to the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\\n                ')]=None, dependencies: Annotated[Optional[Sequence[Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to the\\n                *path operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\\n                ')]=None, summary: Annotated[Optional[str], Doc('\\n                A summary for the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, description: Annotated[Optional[str], Doc('\\n                A description for the *path operation*.\\n\\n                If not provided, it will be extracted automatically from the docstring\\n                of the *path operation function*.\\n\\n                It can contain Markdown.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, response_description: Annotated[str, Doc('\\n                The description for the default response.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]='Successful Response', responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses that could be returned by this *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark this *path operation* as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, operation_id: Annotated[Optional[str], Doc('\\n                Custom operation ID to be used by this *path operation*.\\n\\n                By default, it is generated automatically.\\n\\n                If you provide a custom operation ID, you need to make sure it is\\n                unique for the whole API.\\n\\n                You can customize the\\n                operation ID generation with the parameter\\n                `generate_unique_id_function` in the `FastAPI` class.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=None, response_model_include: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to include only certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_exclude: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to exclude certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_by_alias: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response model\\n                should be serialized by alias when an alias is used.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=True, response_model_exclude_unset: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that were not set and\\n                have their default values. This is different from\\n                `response_model_exclude_defaults` in that if the fields are set,\\n                they will be included in the response, even if the value is the same\\n                as the default.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_defaults: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that have the same value\\n                as the default. This is different from `response_model_exclude_unset`\\n                in that if the fields are set but contain the same default values,\\n                they will be excluded from the response.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_none: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data should\\n                exclude fields set to `None`.\\n\\n                This is much simpler (less smart) than `response_model_exclude_unset`\\n                and `response_model_exclude_defaults`. You probably want to use one of\\n                those two instead of this one, as those allow returning `None` values\\n                when it makes sense.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\\n                ')]=False, include_in_schema: Annotated[bool, Doc('\\n                Include this *path operation* in the generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\\n                ')]=True, response_class: Annotated[Type[Response], Doc('\\n                Response class to be used for this *path operation*.\\n\\n                This will not be used if you return a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\\n                ')]=Default(JSONResponse), name: Annotated[Optional[str], Doc('\\n                Name for this *path operation*. Only used internally.\\n                ')]=None, callbacks: Annotated[Optional[List[BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")]=None, openapi_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n                Extra metadata to be included in the OpenAPI schema for this *path\\n                operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\\n                ')]=None, generate_unique_id_function: Annotated[Callable[[routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=Default(generate_unique_id)) -> Callable[[DecoratedCallable], DecoratedCallable]:\n    \"\"\"\n        Add a *path operation* using an HTTP GET operation.\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI\n\n        app = FastAPI()\n\n        @app.get(\"/items/\")\n        def read_items():\n            return [{\"name\": \"Empanada\"}, {\"name\": \"Arepa\"}]\n        ```\n        \"\"\"\n    return self.router.get(path, response_model=response_model, status_code=status_code, tags=tags, dependencies=dependencies, summary=summary, description=description, response_description=response_description, responses=responses, deprecated=deprecated, operation_id=operation_id, response_model_include=response_model_include, response_model_exclude=response_model_exclude, response_model_by_alias=response_model_by_alias, response_model_exclude_unset=response_model_exclude_unset, response_model_exclude_defaults=response_model_exclude_defaults, response_model_exclude_none=response_model_exclude_none, include_in_schema=include_in_schema, response_class=response_class, name=name, callbacks=callbacks, openapi_extra=openapi_extra, generate_unique_id_function=generate_unique_id_function)"
        },
        {
          "name": "req.scope.get",
          "body": "def get(self, path: Annotated[str, Doc('\\n                The URL path to be used for this *path operation*.\\n\\n                For example, in `http://example.com/items`, the path is `/items`.\\n                ')], *, response_model: Annotated[Any, Doc(\"\\n                The type to use for the response.\\n\\n                It could be any valid Pydantic *field* type. So, it doesn't have to\\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\\n                etc.\\n\\n                It will be used for:\\n\\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\\n                    show it as the response (JSON Schema).\\n                * Serialization: you could return an arbitrary object and the\\n                    `response_model` would be used to serialize that object into the\\n                    corresponding JSON.\\n                * Filtering: the JSON sent to the client will only contain the data\\n                    (fields) defined in the `response_model`. If you returned an object\\n                    that contains an attribute `password` but the `response_model` does\\n                    not include that field, the JSON sent to the client would not have\\n                    that `password`.\\n                * Validation: whatever you return will be serialized with the\\n                    `response_model`, converting any data as necessary to generate the\\n                    corresponding JSON. But if the data in the object returned is not\\n                    valid, that would mean a violation of the contract with the client,\\n                    so it's an error from the API developer. So, FastAPI will raise an\\n                    error and return a 500 error code (Internal Server Error).\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\\n                \")]=Default(None), status_code: Annotated[Optional[int], Doc('\\n                The default status code to be used for the response.\\n\\n                You could override the status code by returning a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\\n                ')]=None, tags: Annotated[Optional[List[Union[str, Enum]]], Doc('\\n                A list of tags to be applied to the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\\n                ')]=None, dependencies: Annotated[Optional[Sequence[Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to the\\n                *path operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\\n                ')]=None, summary: Annotated[Optional[str], Doc('\\n                A summary for the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, description: Annotated[Optional[str], Doc('\\n                A description for the *path operation*.\\n\\n                If not provided, it will be extracted automatically from the docstring\\n                of the *path operation function*.\\n\\n                It can contain Markdown.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, response_description: Annotated[str, Doc('\\n                The description for the default response.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]='Successful Response', responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses that could be returned by this *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark this *path operation* as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, operation_id: Annotated[Optional[str], Doc('\\n                Custom operation ID to be used by this *path operation*.\\n\\n                By default, it is generated automatically.\\n\\n                If you provide a custom operation ID, you need to make sure it is\\n                unique for the whole API.\\n\\n                You can customize the\\n                operation ID generation with the parameter\\n                `generate_unique_id_function` in the `FastAPI` class.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=None, response_model_include: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to include only certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_exclude: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to exclude certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_by_alias: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response model\\n                should be serialized by alias when an alias is used.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=True, response_model_exclude_unset: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that were not set and\\n                have their default values. This is different from\\n                `response_model_exclude_defaults` in that if the fields are set,\\n                they will be included in the response, even if the value is the same\\n                as the default.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_defaults: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that have the same value\\n                as the default. This is different from `response_model_exclude_unset`\\n                in that if the fields are set but contain the same default values,\\n                they will be excluded from the response.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_none: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data should\\n                exclude fields set to `None`.\\n\\n                This is much simpler (less smart) than `response_model_exclude_unset`\\n                and `response_model_exclude_defaults`. You probably want to use one of\\n                those two instead of this one, as those allow returning `None` values\\n                when it makes sense.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\\n                ')]=False, include_in_schema: Annotated[bool, Doc('\\n                Include this *path operation* in the generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\\n                ')]=True, response_class: Annotated[Type[Response], Doc('\\n                Response class to be used for this *path operation*.\\n\\n                This will not be used if you return a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\\n                ')]=Default(JSONResponse), name: Annotated[Optional[str], Doc('\\n                Name for this *path operation*. Only used internally.\\n                ')]=None, callbacks: Annotated[Optional[List[BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")]=None, openapi_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n                Extra metadata to be included in the OpenAPI schema for this *path\\n                operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\\n                ')]=None, generate_unique_id_function: Annotated[Callable[[routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=Default(generate_unique_id)) -> Callable[[DecoratedCallable], DecoratedCallable]:\n    \"\"\"\n        Add a *path operation* using an HTTP GET operation.\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI\n\n        app = FastAPI()\n\n        @app.get(\"/items/\")\n        def read_items():\n            return [{\"name\": \"Empanada\"}, {\"name\": \"Arepa\"}]\n        ```\n        \"\"\"\n    return self.router.get(path, response_model=response_model, status_code=status_code, tags=tags, dependencies=dependencies, summary=summary, description=description, response_description=response_description, responses=responses, deprecated=deprecated, operation_id=operation_id, response_model_include=response_model_include, response_model_exclude=response_model_exclude, response_model_by_alias=response_model_by_alias, response_model_exclude_unset=response_model_exclude_unset, response_model_exclude_defaults=response_model_exclude_defaults, response_model_exclude_none=response_model_exclude_none, include_in_schema=include_in_schema, response_class=response_class, name=name, callbacks=callbacks, openapi_extra=openapi_extra, generate_unique_id_function=generate_unique_id_function)"
        },
        {
          "name": "req.scope.get",
          "body": "def get(self, path: Annotated[str, Doc('\\n                The URL path to be used for this *path operation*.\\n\\n                For example, in `http://example.com/items`, the path is `/items`.\\n                ')], *, response_model: Annotated[Any, Doc(\"\\n                The type to use for the response.\\n\\n                It could be any valid Pydantic *field* type. So, it doesn't have to\\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\\n                etc.\\n\\n                It will be used for:\\n\\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\\n                    show it as the response (JSON Schema).\\n                * Serialization: you could return an arbitrary object and the\\n                    `response_model` would be used to serialize that object into the\\n                    corresponding JSON.\\n                * Filtering: the JSON sent to the client will only contain the data\\n                    (fields) defined in the `response_model`. If you returned an object\\n                    that contains an attribute `password` but the `response_model` does\\n                    not include that field, the JSON sent to the client would not have\\n                    that `password`.\\n                * Validation: whatever you return will be serialized with the\\n                    `response_model`, converting any data as necessary to generate the\\n                    corresponding JSON. But if the data in the object returned is not\\n                    valid, that would mean a violation of the contract with the client,\\n                    so it's an error from the API developer. So, FastAPI will raise an\\n                    error and return a 500 error code (Internal Server Error).\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\\n                \")]=Default(None), status_code: Annotated[Optional[int], Doc('\\n                The default status code to be used for the response.\\n\\n                You could override the status code by returning a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\\n                ')]=None, tags: Annotated[Optional[List[Union[str, Enum]]], Doc('\\n                A list of tags to be applied to the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\\n                ')]=None, dependencies: Annotated[Optional[Sequence[Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to the\\n                *path operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\\n                ')]=None, summary: Annotated[Optional[str], Doc('\\n                A summary for the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, description: Annotated[Optional[str], Doc('\\n                A description for the *path operation*.\\n\\n                If not provided, it will be extracted automatically from the docstring\\n                of the *path operation function*.\\n\\n                It can contain Markdown.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, response_description: Annotated[str, Doc('\\n                The description for the default response.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]='Successful Response', responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses that could be returned by this *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark this *path operation* as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, operation_id: Annotated[Optional[str], Doc('\\n                Custom operation ID to be used by this *path operation*.\\n\\n                By default, it is generated automatically.\\n\\n                If you provide a custom operation ID, you need to make sure it is\\n                unique for the whole API.\\n\\n                You can customize the\\n                operation ID generation with the parameter\\n                `generate_unique_id_function` in the `FastAPI` class.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=None, response_model_include: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to include only certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_exclude: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to exclude certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_by_alias: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response model\\n                should be serialized by alias when an alias is used.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=True, response_model_exclude_unset: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that were not set and\\n                have their default values. This is different from\\n                `response_model_exclude_defaults` in that if the fields are set,\\n                they will be included in the response, even if the value is the same\\n                as the default.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_defaults: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that have the same value\\n                as the default. This is different from `response_model_exclude_unset`\\n                in that if the fields are set but contain the same default values,\\n                they will be excluded from the response.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_none: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data should\\n                exclude fields set to `None`.\\n\\n                This is much simpler (less smart) than `response_model_exclude_unset`\\n                and `response_model_exclude_defaults`. You probably want to use one of\\n                those two instead of this one, as those allow returning `None` values\\n                when it makes sense.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\\n                ')]=False, include_in_schema: Annotated[bool, Doc('\\n                Include this *path operation* in the generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\\n                ')]=True, response_class: Annotated[Type[Response], Doc('\\n                Response class to be used for this *path operation*.\\n\\n                This will not be used if you return a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\\n                ')]=Default(JSONResponse), name: Annotated[Optional[str], Doc('\\n                Name for this *path operation*. Only used internally.\\n                ')]=None, callbacks: Annotated[Optional[List[BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")]=None, openapi_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n                Extra metadata to be included in the OpenAPI schema for this *path\\n                operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\\n                ')]=None, generate_unique_id_function: Annotated[Callable[[routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=Default(generate_unique_id)) -> Callable[[DecoratedCallable], DecoratedCallable]:\n    \"\"\"\n        Add a *path operation* using an HTTP GET operation.\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI\n\n        app = FastAPI()\n\n        @app.get(\"/items/\")\n        def read_items():\n            return [{\"name\": \"Empanada\"}, {\"name\": \"Arepa\"}]\n        ```\n        \"\"\"\n    return self.router.get(path, response_model=response_model, status_code=status_code, tags=tags, dependencies=dependencies, summary=summary, description=description, response_description=response_description, responses=responses, deprecated=deprecated, operation_id=operation_id, response_model_include=response_model_include, response_model_exclude=response_model_exclude, response_model_by_alias=response_model_by_alias, response_model_exclude_unset=response_model_exclude_unset, response_model_exclude_defaults=response_model_exclude_defaults, response_model_exclude_none=response_model_exclude_none, include_in_schema=include_in_schema, response_class=response_class, name=name, callbacks=callbacks, openapi_extra=openapi_extra, generate_unique_id_function=generate_unique_id_function)"
        }
      ]
    },
    {
      "name": "add_api_route",
      "module": "applications",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\applications.py",
      "line_number": 1056,
      "end_line_number": 1113,
      "source_code": "def add_api_route(\n        self,\n        path: str,\n        endpoint: Callable[..., Any],\n        *,\n        response_model: Any = Default(None),\n        status_code: Optional[int] = None,\n        tags: Optional[List[Union[str, Enum]]] = None,\n        dependencies: Optional[Sequence[Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        methods: Optional[List[str]] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[IncEx] = None,\n        response_model_exclude: Optional[IncEx] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Union[Type[Response], DefaultPlaceholder] = Default(\n            JSONResponse\n        ),\n        name: Optional[str] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n        generate_unique_id_function: Callable[[routing.APIRoute], str] = Default(\n            generate_unique_id\n        ),\n    ) -> None:\n        self.router.add_api_route(\n            path,\n            endpoint=endpoint,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=methods,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            openapi_extra=openapi_extra,\n            generate_unique_id_function=generate_unique_id_function,\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "path",
        "endpoint"
      ],
      "imports": [
        "enum.Enum",
        "typing.Any",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Type",
        "typing.TypeVar",
        "typing.Union",
        "fastapi.routing",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.exception_handlers.http_exception_handler",
        "fastapi.exception_handlers.request_validation_exception_handler",
        "fastapi.exception_handlers.websocket_request_validation_exception_handler",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.logger.logger",
        "fastapi.openapi.docs.get_redoc_html",
        "fastapi.openapi.docs.get_swagger_ui_html",
        "fastapi.openapi.docs.get_swagger_ui_oauth2_redirect_html",
        "fastapi.openapi.utils.get_openapi",
        "fastapi.params.Depends",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.generate_unique_id",
        "starlette.applications.Starlette",
        "starlette.datastructures.State",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.requests.Request",
        "starlette.responses.HTMLResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "self.router.add_api_route",
          "body": "def add_api_route(self, path: str, endpoint: Callable[..., Any], *, response_model: Any=Default(None), status_code: Optional[int]=None, tags: Optional[List[Union[str, Enum]]]=None, dependencies: Optional[Sequence[Depends]]=None, summary: Optional[str]=None, description: Optional[str]=None, response_description: str='Successful Response', responses: Optional[Dict[Union[int, str], Dict[str, Any]]]=None, deprecated: Optional[bool]=None, methods: Optional[List[str]]=None, operation_id: Optional[str]=None, response_model_include: Optional[IncEx]=None, response_model_exclude: Optional[IncEx]=None, response_model_by_alias: bool=True, response_model_exclude_unset: bool=False, response_model_exclude_defaults: bool=False, response_model_exclude_none: bool=False, include_in_schema: bool=True, response_class: Union[Type[Response], DefaultPlaceholder]=Default(JSONResponse), name: Optional[str]=None, openapi_extra: Optional[Dict[str, Any]]=None, generate_unique_id_function: Callable[[routing.APIRoute], str]=Default(generate_unique_id)) -> None:\n    self.router.add_api_route(path, endpoint=endpoint, response_model=response_model, status_code=status_code, tags=tags, dependencies=dependencies, summary=summary, description=description, response_description=response_description, responses=responses, deprecated=deprecated, methods=methods, operation_id=operation_id, response_model_include=response_model_include, response_model_exclude=response_model_exclude, response_model_by_alias=response_model_by_alias, response_model_exclude_unset=response_model_exclude_unset, response_model_exclude_defaults=response_model_exclude_defaults, response_model_exclude_none=response_model_exclude_none, include_in_schema=include_in_schema, response_class=response_class, name=name, openapi_extra=openapi_extra, generate_unique_id_function=generate_unique_id_function)"
        }
      ]
    },
    {
      "name": "api_route",
      "module": "applications",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\applications.py",
      "line_number": 1115,
      "end_line_number": 1173,
      "source_code": "def api_route(\n        self,\n        path: str,\n        *,\n        response_model: Any = Default(None),\n        status_code: Optional[int] = None,\n        tags: Optional[List[Union[str, Enum]]] = None,\n        dependencies: Optional[Sequence[Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        methods: Optional[List[str]] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[IncEx] = None,\n        response_model_exclude: Optional[IncEx] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n        generate_unique_id_function: Callable[[routing.APIRoute], str] = Default(\n            generate_unique_id\n        ),\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.router.add_api_route(\n                path,\n                func,\n                response_model=response_model,\n                status_code=status_code,\n                tags=tags,\n                dependencies=dependencies,\n                summary=summary,\n                description=description,\n                response_description=response_description,\n                responses=responses,\n                deprecated=deprecated,\n                methods=methods,\n                operation_id=operation_id,\n                response_model_include=response_model_include,\n                response_model_exclude=response_model_exclude,\n                response_model_by_alias=response_model_by_alias,\n                response_model_exclude_unset=response_model_exclude_unset,\n                response_model_exclude_defaults=response_model_exclude_defaults,\n                response_model_exclude_none=response_model_exclude_none,\n                include_in_schema=include_in_schema,\n                response_class=response_class,\n                name=name,\n                openapi_extra=openapi_extra,\n                generate_unique_id_function=generate_unique_id_function,\n            )\n            return func\n\n        return decorator",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "path"
      ],
      "imports": [
        "enum.Enum",
        "typing.Any",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Type",
        "typing.TypeVar",
        "typing.Union",
        "fastapi.routing",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.exception_handlers.http_exception_handler",
        "fastapi.exception_handlers.request_validation_exception_handler",
        "fastapi.exception_handlers.websocket_request_validation_exception_handler",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.logger.logger",
        "fastapi.openapi.docs.get_redoc_html",
        "fastapi.openapi.docs.get_swagger_ui_html",
        "fastapi.openapi.docs.get_swagger_ui_oauth2_redirect_html",
        "fastapi.openapi.utils.get_openapi",
        "fastapi.params.Depends",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.generate_unique_id",
        "starlette.applications.Starlette",
        "starlette.datastructures.State",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.requests.Request",
        "starlette.responses.HTMLResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "self.router.add_api_route",
          "body": "def add_api_route(self, path: str, endpoint: Callable[..., Any], *, response_model: Any=Default(None), status_code: Optional[int]=None, tags: Optional[List[Union[str, Enum]]]=None, dependencies: Optional[Sequence[Depends]]=None, summary: Optional[str]=None, description: Optional[str]=None, response_description: str='Successful Response', responses: Optional[Dict[Union[int, str], Dict[str, Any]]]=None, deprecated: Optional[bool]=None, methods: Optional[List[str]]=None, operation_id: Optional[str]=None, response_model_include: Optional[IncEx]=None, response_model_exclude: Optional[IncEx]=None, response_model_by_alias: bool=True, response_model_exclude_unset: bool=False, response_model_exclude_defaults: bool=False, response_model_exclude_none: bool=False, include_in_schema: bool=True, response_class: Union[Type[Response], DefaultPlaceholder]=Default(JSONResponse), name: Optional[str]=None, openapi_extra: Optional[Dict[str, Any]]=None, generate_unique_id_function: Callable[[routing.APIRoute], str]=Default(generate_unique_id)) -> None:\n    self.router.add_api_route(path, endpoint=endpoint, response_model=response_model, status_code=status_code, tags=tags, dependencies=dependencies, summary=summary, description=description, response_description=response_description, responses=responses, deprecated=deprecated, methods=methods, operation_id=operation_id, response_model_include=response_model_include, response_model_exclude=response_model_exclude, response_model_by_alias=response_model_by_alias, response_model_exclude_unset=response_model_exclude_unset, response_model_exclude_defaults=response_model_exclude_defaults, response_model_exclude_none=response_model_exclude_none, include_in_schema=include_in_schema, response_class=response_class, name=name, openapi_extra=openapi_extra, generate_unique_id_function=generate_unique_id_function)"
        }
      ]
    },
    {
      "name": "add_api_websocket_route",
      "module": "applications",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\applications.py",
      "line_number": 1175,
      "end_line_number": 1188,
      "source_code": "def add_api_websocket_route(\n        self,\n        path: str,\n        endpoint: Callable[..., Any],\n        name: Optional[str] = None,\n        *,\n        dependencies: Optional[Sequence[Depends]] = None,\n    ) -> None:\n        self.router.add_api_websocket_route(\n            path,\n            endpoint,\n            name=name,\n            dependencies=dependencies,\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "path",
        "endpoint",
        "name"
      ],
      "imports": [
        "enum.Enum",
        "typing.Any",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Type",
        "typing.TypeVar",
        "typing.Union",
        "fastapi.routing",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.exception_handlers.http_exception_handler",
        "fastapi.exception_handlers.request_validation_exception_handler",
        "fastapi.exception_handlers.websocket_request_validation_exception_handler",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.logger.logger",
        "fastapi.openapi.docs.get_redoc_html",
        "fastapi.openapi.docs.get_swagger_ui_html",
        "fastapi.openapi.docs.get_swagger_ui_oauth2_redirect_html",
        "fastapi.openapi.utils.get_openapi",
        "fastapi.params.Depends",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.generate_unique_id",
        "starlette.applications.Starlette",
        "starlette.datastructures.State",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.requests.Request",
        "starlette.responses.HTMLResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.router.add_api_websocket_route",
          "body": "def add_api_websocket_route(self, path: str, endpoint: Callable[..., Any], name: Optional[str]=None, *, dependencies: Optional[Sequence[Depends]]=None) -> None:\n    self.router.add_api_websocket_route(path, endpoint, name=name, dependencies=dependencies)"
        }
      ]
    },
    {
      "name": "websocket",
      "module": "applications",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\applications.py",
      "line_number": 1190,
      "end_line_number": 1253,
      "source_code": "def websocket(\n        self,\n        path: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                WebSocket path.\n                \"\"\"\n            ),\n        ],\n        name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A name for the WebSocket. Only used internally.\n                \"\"\"\n            ),\n        ] = None,\n        *,\n        dependencies: Annotated[\n            Optional[Sequence[Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be used for this\n                WebSocket.\n\n                Read more about it in the\n                [FastAPI docs for WebSockets](https://fastapi.tiangolo.com/advanced/websockets/).\n                \"\"\"\n            ),\n        ] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Decorate a WebSocket function.\n\n        Read more about it in the\n        [FastAPI docs for WebSockets](https://fastapi.tiangolo.com/advanced/websockets/).\n\n        **Example**\n\n        ```python\n        from fastapi import FastAPI, WebSocket\n\n        app = FastAPI()\n\n        @app.websocket(\"/ws\")\n        async def websocket_endpoint(websocket: WebSocket):\n            await websocket.accept()\n            while True:\n                data = await websocket.receive_text()\n                await websocket.send_text(f\"Message text was: {data}\")\n        ```\n        \"\"\"\n\n        def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.add_api_websocket_route(\n                path,\n                func,\n                name=name,\n                dependencies=dependencies,\n            )\n            return func\n\n        return decorator",
      "docstring": "Decorate a WebSocket function.\n\nRead more about it in the\n[FastAPI docs for WebSockets](https://fastapi.tiangolo.com/advanced/websockets/).\n\n**Example**\n\n```python\nfrom fastapi import FastAPI, WebSocket\n\napp = FastAPI()\n\n@app.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    while True:\n        data = await websocket.receive_text()\n        await websocket.send_text(f\"Message text was: {data}\")\n```",
      "decorators": [],
      "arguments": [
        "self",
        "path",
        "name"
      ],
      "imports": [
        "enum.Enum",
        "typing.Any",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Type",
        "typing.TypeVar",
        "typing.Union",
        "fastapi.routing",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.exception_handlers.http_exception_handler",
        "fastapi.exception_handlers.request_validation_exception_handler",
        "fastapi.exception_handlers.websocket_request_validation_exception_handler",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.logger.logger",
        "fastapi.openapi.docs.get_redoc_html",
        "fastapi.openapi.docs.get_swagger_ui_html",
        "fastapi.openapi.docs.get_swagger_ui_oauth2_redirect_html",
        "fastapi.openapi.utils.get_openapi",
        "fastapi.params.Depends",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.generate_unique_id",
        "starlette.applications.Starlette",
        "starlette.datastructures.State",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.requests.Request",
        "starlette.responses.HTMLResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.add_api_websocket_route",
          "body": "def add_api_websocket_route(self, path: str, endpoint: Callable[..., Any], name: Optional[str]=None, *, dependencies: Optional[Sequence[Depends]]=None) -> None:\n    self.router.add_api_websocket_route(path, endpoint, name=name, dependencies=dependencies)"
        }
      ]
    },
    {
      "name": "include_router",
      "module": "applications",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\applications.py",
      "line_number": 1255,
      "end_line_number": 1458,
      "source_code": "def include_router(\n        self,\n        router: Annotated[routing.APIRouter, Doc(\"The `APIRouter` to include.\")],\n        *,\n        prefix: Annotated[str, Doc(\"An optional path prefix for the router.\")] = \"\",\n        tags: Annotated[\n            Optional[List[Union[str, Enum]]],\n            Doc(\n                \"\"\"\n                A list of tags to be applied to all the *path operations* in this\n                router.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        dependencies: Annotated[\n            Optional[Sequence[Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be applied to all the\n                *path operations* in this router.\n\n                Read more about it in the\n                [FastAPI docs for Bigger Applications - Multiple Files](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).\n\n                **Example**\n\n                ```python\n                from fastapi import Depends, FastAPI\n\n                from .dependencies import get_token_header\n                from .internal import admin\n\n                app = FastAPI()\n\n                app.include_router(\n                    admin.router,\n                    dependencies=[Depends(get_token_header)],\n                )\n                ```\n                \"\"\"\n            ),\n        ] = None,\n        responses: Annotated[\n            Optional[Dict[Union[int, str], Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                Additional responses to be shown in OpenAPI.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Additional Responses in OpenAPI](https://fastapi.tiangolo.com/advanced/additional-responses/).\n\n                And in the\n                [FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).\n                \"\"\"\n            ),\n        ] = None,\n        deprecated: Annotated[\n            Optional[bool],\n            Doc(\n                \"\"\"\n                Mark all the *path operations* in this router as deprecated.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                **Example**\n\n                ```python\n                from fastapi import FastAPI\n\n                from .internal import old_api\n\n                app = FastAPI()\n\n                app.include_router(\n                    old_api.router,\n                    deprecated=True,\n                )\n                ```\n                \"\"\"\n            ),\n        ] = None,\n        include_in_schema: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Include (or not) all the *path operations* in this router in the\n                generated OpenAPI schema.\n\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\n\n                **Example**\n\n                ```python\n                from fastapi import FastAPI\n\n                from .internal import old_api\n\n                app = FastAPI()\n\n                app.include_router(\n                    old_api.router,\n                    include_in_schema=False,\n                )\n                ```\n                \"\"\"\n            ),\n        ] = True,\n        default_response_class: Annotated[\n            Type[Response],\n            Doc(\n                \"\"\"\n                Default response class to be used for the *path operations* in this\n                router.\n\n                Read more in the\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#default-response-class).\n\n                **Example**\n\n                ```python\n                from fastapi import FastAPI\n                from fastapi.responses import ORJSONResponse\n\n                from .internal import old_api\n\n                app = FastAPI()\n\n                app.include_router(\n                    old_api.router,\n                    default_response_class=ORJSONResponse,\n                )\n                ```\n                \"\"\"\n            ),\n        ] = Default(JSONResponse),\n        callbacks: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                List of *path operations* that will be used as OpenAPI callbacks.\n\n                This is only for OpenAPI documentation, the callbacks won't be used\n                directly.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\n                \"\"\"\n            ),\n        ] = None,\n        generate_unique_id_function: Annotated[\n            Callable[[routing.APIRoute], str],\n            Doc(\n                \"\"\"\n                Customize the function used to generate unique IDs for the *path\n                operations* shown in the generated OpenAPI.\n\n                This is particularly useful when automatically generating clients or\n                SDKs for your API.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = Default(generate_unique_id),\n    ) -> None:\n        \"\"\"\n        Include an `APIRouter` in the same app.\n\n        Read more about it in the\n        [FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/).\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI\n\n        from .users import users_router\n\n        app = FastAPI()\n\n        app.include_router(users_router)\n        ```\n        \"\"\"\n        self.router.include_router(\n            router,\n            prefix=prefix,\n            tags=tags,\n            dependencies=dependencies,\n            responses=responses,\n            deprecated=deprecated,\n            include_in_schema=include_in_schema,\n            default_response_class=default_response_class,\n            callbacks=callbacks,\n            generate_unique_id_function=generate_unique_id_function,\n        )",
      "docstring": "Include an `APIRouter` in the same app.\n\nRead more about it in the\n[FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/).\n\n## Example\n\n```python\nfrom fastapi import FastAPI\n\nfrom .users import users_router\n\napp = FastAPI()\n\napp.include_router(users_router)\n```",
      "decorators": [],
      "arguments": [
        "self",
        "router"
      ],
      "imports": [
        "enum.Enum",
        "typing.Any",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Type",
        "typing.TypeVar",
        "typing.Union",
        "fastapi.routing",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.exception_handlers.http_exception_handler",
        "fastapi.exception_handlers.request_validation_exception_handler",
        "fastapi.exception_handlers.websocket_request_validation_exception_handler",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.logger.logger",
        "fastapi.openapi.docs.get_redoc_html",
        "fastapi.openapi.docs.get_swagger_ui_html",
        "fastapi.openapi.docs.get_swagger_ui_oauth2_redirect_html",
        "fastapi.openapi.utils.get_openapi",
        "fastapi.params.Depends",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.generate_unique_id",
        "starlette.applications.Starlette",
        "starlette.datastructures.State",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.requests.Request",
        "starlette.responses.HTMLResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "self.router.include_router",
          "body": "def include_router(self, router: Annotated[routing.APIRouter, Doc('The `APIRouter` to include.')], *, prefix: Annotated[str, Doc('An optional path prefix for the router.')]='', tags: Annotated[Optional[List[Union[str, Enum]]], Doc('\\n                A list of tags to be applied to all the *path operations* in this\\n                router.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, dependencies: Annotated[Optional[Sequence[Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to all the\\n                *path operations* in this router.\\n\\n                Read more about it in the\\n                [FastAPI docs for Bigger Applications - Multiple Files](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).\\n\\n                **Example**\\n\\n                ```python\\n                from fastapi import Depends, FastAPI\\n\\n                from .dependencies import get_token_header\\n                from .internal import admin\\n\\n                app = FastAPI()\\n\\n                app.include_router(\\n                    admin.router,\\n                    dependencies=[Depends(get_token_header)],\\n                )\\n                ```\\n                ')]=None, responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses to be shown in OpenAPI.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Additional Responses in OpenAPI](https://fastapi.tiangolo.com/advanced/additional-responses/).\\n\\n                And in the\\n                [FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).\\n                ')]=None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark all the *path operations* in this router as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                **Example**\\n\\n                ```python\\n                from fastapi import FastAPI\\n\\n                from .internal import old_api\\n\\n                app = FastAPI()\\n\\n                app.include_router(\\n                    old_api.router,\\n                    deprecated=True,\\n                )\\n                ```\\n                ')]=None, include_in_schema: Annotated[bool, Doc('\\n                Include (or not) all the *path operations* in this router in the\\n                generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                **Example**\\n\\n                ```python\\n                from fastapi import FastAPI\\n\\n                from .internal import old_api\\n\\n                app = FastAPI()\\n\\n                app.include_router(\\n                    old_api.router,\\n                    include_in_schema=False,\\n                )\\n                ```\\n                ')]=True, default_response_class: Annotated[Type[Response], Doc('\\n                Default response class to be used for the *path operations* in this\\n                router.\\n\\n                Read more in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#default-response-class).\\n\\n                **Example**\\n\\n                ```python\\n                from fastapi import FastAPI\\n                from fastapi.responses import ORJSONResponse\\n\\n                from .internal import old_api\\n\\n                app = FastAPI()\\n\\n                app.include_router(\\n                    old_api.router,\\n                    default_response_class=ORJSONResponse,\\n                )\\n                ```\\n                ')]=Default(JSONResponse), callbacks: Annotated[Optional[List[BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")]=None, generate_unique_id_function: Annotated[Callable[[routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=Default(generate_unique_id)) -> None:\n    \"\"\"\n        Include an `APIRouter` in the same app.\n\n        Read more about it in the\n        [FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/).\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI\n\n        from .users import users_router\n\n        app = FastAPI()\n\n        app.include_router(users_router)\n        ```\n        \"\"\"\n    self.router.include_router(router, prefix=prefix, tags=tags, dependencies=dependencies, responses=responses, deprecated=deprecated, include_in_schema=include_in_schema, default_response_class=default_response_class, callbacks=callbacks, generate_unique_id_function=generate_unique_id_function)"
        }
      ]
    },
    {
      "name": "get",
      "module": "applications",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\applications.py",
      "line_number": 1460,
      "end_line_number": 1831,
      "source_code": "def get(\n        self,\n        path: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The URL path to be used for this *path operation*.\n\n                For example, in `http://example.com/items`, the path is `/items`.\n                \"\"\"\n            ),\n        ],\n        *,\n        response_model: Annotated[\n            Any,\n            Doc(\n                \"\"\"\n                The type to use for the response.\n\n                It could be any valid Pydantic *field* type. So, it doesn't have to\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\n                etc.\n\n                It will be used for:\n\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\n                    show it as the response (JSON Schema).\n                * Serialization: you could return an arbitrary object and the\n                    `response_model` would be used to serialize that object into the\n                    corresponding JSON.\n                * Filtering: the JSON sent to the client will only contain the data\n                    (fields) defined in the `response_model`. If you returned an object\n                    that contains an attribute `password` but the `response_model` does\n                    not include that field, the JSON sent to the client would not have\n                    that `password`.\n                * Validation: whatever you return will be serialized with the\n                    `response_model`, converting any data as necessary to generate the\n                    corresponding JSON. But if the data in the object returned is not\n                    valid, that would mean a violation of the contract with the client,\n                    so it's an error from the API developer. So, FastAPI will raise an\n                    error and return a 500 error code (Internal Server Error).\n\n                Read more about it in the\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\n                \"\"\"\n            ),\n        ] = Default(None),\n        status_code: Annotated[\n            Optional[int],\n            Doc(\n                \"\"\"\n                The default status code to be used for the response.\n\n                You could override the status code by returning a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\n                \"\"\"\n            ),\n        ] = None,\n        tags: Annotated[\n            Optional[List[Union[str, Enum]]],\n            Doc(\n                \"\"\"\n                A list of tags to be applied to the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\n                \"\"\"\n            ),\n        ] = None,\n        dependencies: Annotated[\n            Optional[Sequence[Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be applied to the\n                *path operation*.\n\n                Read more about it in the\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\n                \"\"\"\n            ),\n        ] = None,\n        summary: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A summary for the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A description for the *path operation*.\n\n                If not provided, it will be extracted automatically from the docstring\n                of the *path operation function*.\n\n                It can contain Markdown.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        response_description: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The description for the default response.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = \"Successful Response\",\n        responses: Annotated[\n            Optional[Dict[Union[int, str], Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                Additional responses that could be returned by this *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        deprecated: Annotated[\n            Optional[bool],\n            Doc(\n                \"\"\"\n                Mark this *path operation* as deprecated.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        operation_id: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Custom operation ID to be used by this *path operation*.\n\n                By default, it is generated automatically.\n\n                If you provide a custom operation ID, you need to make sure it is\n                unique for the whole API.\n\n                You can customize the\n                operation ID generation with the parameter\n                `generate_unique_id_function` in the `FastAPI` class.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_include: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to include only certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_exclude: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to exclude certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_by_alias: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response model\n                should be serialized by alias when an alias is used.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = True,\n        response_model_exclude_unset: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that were not set and\n                have their default values. This is different from\n                `response_model_exclude_defaults` in that if the fields are set,\n                they will be included in the response, even if the value is the same\n                as the default.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_defaults: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that have the same value\n                as the default. This is different from `response_model_exclude_unset`\n                in that if the fields are set but contain the same default values,\n                they will be excluded from the response.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_none: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data should\n                exclude fields set to `None`.\n\n                This is much simpler (less smart) than `response_model_exclude_unset`\n                and `response_model_exclude_defaults`. You probably want to use one of\n                those two instead of this one, as those allow returning `None` values\n                when it makes sense.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\n                \"\"\"\n            ),\n        ] = False,\n        include_in_schema: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Include this *path operation* in the generated OpenAPI schema.\n\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\n                \"\"\"\n            ),\n        ] = True,\n        response_class: Annotated[\n            Type[Response],\n            Doc(\n                \"\"\"\n                Response class to be used for this *path operation*.\n\n                This will not be used if you return a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\n                \"\"\"\n            ),\n        ] = Default(JSONResponse),\n        name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Name for this *path operation*. Only used internally.\n                \"\"\"\n            ),\n        ] = None,\n        callbacks: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                List of *path operations* that will be used as OpenAPI callbacks.\n\n                This is only for OpenAPI documentation, the callbacks won't be used\n                directly.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\n                \"\"\"\n            ),\n        ] = None,\n        openapi_extra: Annotated[\n            Optional[Dict[str, Any]],\n            Doc(\n                \"\"\"\n                Extra metadata to be included in the OpenAPI schema for this *path\n                operation*.\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\n                \"\"\"\n            ),\n        ] = None,\n        generate_unique_id_function: Annotated[\n            Callable[[routing.APIRoute], str],\n            Doc(\n                \"\"\"\n                Customize the function used to generate unique IDs for the *path\n                operations* shown in the generated OpenAPI.\n\n                This is particularly useful when automatically generating clients or\n                SDKs for your API.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = Default(generate_unique_id),\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Add a *path operation* using an HTTP GET operation.\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI\n\n        app = FastAPI()\n\n        @app.get(\"/items/\")\n        def read_items():\n            return [{\"name\": \"Empanada\"}, {\"name\": \"Arepa\"}]\n        ```\n        \"\"\"\n        return self.router.get(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n            generate_unique_id_function=generate_unique_id_function,\n        )",
      "docstring": "Add a *path operation* using an HTTP GET operation.\n\n## Example\n\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/items/\")\ndef read_items():\n    return [{\"name\": \"Empanada\"}, {\"name\": \"Arepa\"}]\n```",
      "decorators": [],
      "arguments": [
        "self",
        "path"
      ],
      "imports": [
        "enum.Enum",
        "typing.Any",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Type",
        "typing.TypeVar",
        "typing.Union",
        "fastapi.routing",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.exception_handlers.http_exception_handler",
        "fastapi.exception_handlers.request_validation_exception_handler",
        "fastapi.exception_handlers.websocket_request_validation_exception_handler",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.logger.logger",
        "fastapi.openapi.docs.get_redoc_html",
        "fastapi.openapi.docs.get_swagger_ui_html",
        "fastapi.openapi.docs.get_swagger_ui_oauth2_redirect_html",
        "fastapi.openapi.utils.get_openapi",
        "fastapi.params.Depends",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.generate_unique_id",
        "starlette.applications.Starlette",
        "starlette.datastructures.State",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.requests.Request",
        "starlette.responses.HTMLResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "self.router.get",
          "body": "def get(self, path: Annotated[str, Doc('\\n                The URL path to be used for this *path operation*.\\n\\n                For example, in `http://example.com/items`, the path is `/items`.\\n                ')], *, response_model: Annotated[Any, Doc(\"\\n                The type to use for the response.\\n\\n                It could be any valid Pydantic *field* type. So, it doesn't have to\\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\\n                etc.\\n\\n                It will be used for:\\n\\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\\n                    show it as the response (JSON Schema).\\n                * Serialization: you could return an arbitrary object and the\\n                    `response_model` would be used to serialize that object into the\\n                    corresponding JSON.\\n                * Filtering: the JSON sent to the client will only contain the data\\n                    (fields) defined in the `response_model`. If you returned an object\\n                    that contains an attribute `password` but the `response_model` does\\n                    not include that field, the JSON sent to the client would not have\\n                    that `password`.\\n                * Validation: whatever you return will be serialized with the\\n                    `response_model`, converting any data as necessary to generate the\\n                    corresponding JSON. But if the data in the object returned is not\\n                    valid, that would mean a violation of the contract with the client,\\n                    so it's an error from the API developer. So, FastAPI will raise an\\n                    error and return a 500 error code (Internal Server Error).\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\\n                \")]=Default(None), status_code: Annotated[Optional[int], Doc('\\n                The default status code to be used for the response.\\n\\n                You could override the status code by returning a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\\n                ')]=None, tags: Annotated[Optional[List[Union[str, Enum]]], Doc('\\n                A list of tags to be applied to the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\\n                ')]=None, dependencies: Annotated[Optional[Sequence[Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to the\\n                *path operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\\n                ')]=None, summary: Annotated[Optional[str], Doc('\\n                A summary for the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, description: Annotated[Optional[str], Doc('\\n                A description for the *path operation*.\\n\\n                If not provided, it will be extracted automatically from the docstring\\n                of the *path operation function*.\\n\\n                It can contain Markdown.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, response_description: Annotated[str, Doc('\\n                The description for the default response.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]='Successful Response', responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses that could be returned by this *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark this *path operation* as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, operation_id: Annotated[Optional[str], Doc('\\n                Custom operation ID to be used by this *path operation*.\\n\\n                By default, it is generated automatically.\\n\\n                If you provide a custom operation ID, you need to make sure it is\\n                unique for the whole API.\\n\\n                You can customize the\\n                operation ID generation with the parameter\\n                `generate_unique_id_function` in the `FastAPI` class.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=None, response_model_include: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to include only certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_exclude: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to exclude certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_by_alias: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response model\\n                should be serialized by alias when an alias is used.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=True, response_model_exclude_unset: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that were not set and\\n                have their default values. This is different from\\n                `response_model_exclude_defaults` in that if the fields are set,\\n                they will be included in the response, even if the value is the same\\n                as the default.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_defaults: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that have the same value\\n                as the default. This is different from `response_model_exclude_unset`\\n                in that if the fields are set but contain the same default values,\\n                they will be excluded from the response.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_none: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data should\\n                exclude fields set to `None`.\\n\\n                This is much simpler (less smart) than `response_model_exclude_unset`\\n                and `response_model_exclude_defaults`. You probably want to use one of\\n                those two instead of this one, as those allow returning `None` values\\n                when it makes sense.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\\n                ')]=False, include_in_schema: Annotated[bool, Doc('\\n                Include this *path operation* in the generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\\n                ')]=True, response_class: Annotated[Type[Response], Doc('\\n                Response class to be used for this *path operation*.\\n\\n                This will not be used if you return a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\\n                ')]=Default(JSONResponse), name: Annotated[Optional[str], Doc('\\n                Name for this *path operation*. Only used internally.\\n                ')]=None, callbacks: Annotated[Optional[List[BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")]=None, openapi_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n                Extra metadata to be included in the OpenAPI schema for this *path\\n                operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\\n                ')]=None, generate_unique_id_function: Annotated[Callable[[routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=Default(generate_unique_id)) -> Callable[[DecoratedCallable], DecoratedCallable]:\n    \"\"\"\n        Add a *path operation* using an HTTP GET operation.\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI\n\n        app = FastAPI()\n\n        @app.get(\"/items/\")\n        def read_items():\n            return [{\"name\": \"Empanada\"}, {\"name\": \"Arepa\"}]\n        ```\n        \"\"\"\n    return self.router.get(path, response_model=response_model, status_code=status_code, tags=tags, dependencies=dependencies, summary=summary, description=description, response_description=response_description, responses=responses, deprecated=deprecated, operation_id=operation_id, response_model_include=response_model_include, response_model_exclude=response_model_exclude, response_model_by_alias=response_model_by_alias, response_model_exclude_unset=response_model_exclude_unset, response_model_exclude_defaults=response_model_exclude_defaults, response_model_exclude_none=response_model_exclude_none, include_in_schema=include_in_schema, response_class=response_class, name=name, callbacks=callbacks, openapi_extra=openapi_extra, generate_unique_id_function=generate_unique_id_function)"
        }
      ]
    },
    {
      "name": "put",
      "module": "applications",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\applications.py",
      "line_number": 1833,
      "end_line_number": 2209,
      "source_code": "def put(\n        self,\n        path: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The URL path to be used for this *path operation*.\n\n                For example, in `http://example.com/items`, the path is `/items`.\n                \"\"\"\n            ),\n        ],\n        *,\n        response_model: Annotated[\n            Any,\n            Doc(\n                \"\"\"\n                The type to use for the response.\n\n                It could be any valid Pydantic *field* type. So, it doesn't have to\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\n                etc.\n\n                It will be used for:\n\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\n                    show it as the response (JSON Schema).\n                * Serialization: you could return an arbitrary object and the\n                    `response_model` would be used to serialize that object into the\n                    corresponding JSON.\n                * Filtering: the JSON sent to the client will only contain the data\n                    (fields) defined in the `response_model`. If you returned an object\n                    that contains an attribute `password` but the `response_model` does\n                    not include that field, the JSON sent to the client would not have\n                    that `password`.\n                * Validation: whatever you return will be serialized with the\n                    `response_model`, converting any data as necessary to generate the\n                    corresponding JSON. But if the data in the object returned is not\n                    valid, that would mean a violation of the contract with the client,\n                    so it's an error from the API developer. So, FastAPI will raise an\n                    error and return a 500 error code (Internal Server Error).\n\n                Read more about it in the\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\n                \"\"\"\n            ),\n        ] = Default(None),\n        status_code: Annotated[\n            Optional[int],\n            Doc(\n                \"\"\"\n                The default status code to be used for the response.\n\n                You could override the status code by returning a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\n                \"\"\"\n            ),\n        ] = None,\n        tags: Annotated[\n            Optional[List[Union[str, Enum]]],\n            Doc(\n                \"\"\"\n                A list of tags to be applied to the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\n                \"\"\"\n            ),\n        ] = None,\n        dependencies: Annotated[\n            Optional[Sequence[Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be applied to the\n                *path operation*.\n\n                Read more about it in the\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\n                \"\"\"\n            ),\n        ] = None,\n        summary: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A summary for the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A description for the *path operation*.\n\n                If not provided, it will be extracted automatically from the docstring\n                of the *path operation function*.\n\n                It can contain Markdown.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        response_description: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The description for the default response.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = \"Successful Response\",\n        responses: Annotated[\n            Optional[Dict[Union[int, str], Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                Additional responses that could be returned by this *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        deprecated: Annotated[\n            Optional[bool],\n            Doc(\n                \"\"\"\n                Mark this *path operation* as deprecated.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        operation_id: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Custom operation ID to be used by this *path operation*.\n\n                By default, it is generated automatically.\n\n                If you provide a custom operation ID, you need to make sure it is\n                unique for the whole API.\n\n                You can customize the\n                operation ID generation with the parameter\n                `generate_unique_id_function` in the `FastAPI` class.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_include: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to include only certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_exclude: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to exclude certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_by_alias: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response model\n                should be serialized by alias when an alias is used.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = True,\n        response_model_exclude_unset: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that were not set and\n                have their default values. This is different from\n                `response_model_exclude_defaults` in that if the fields are set,\n                they will be included in the response, even if the value is the same\n                as the default.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_defaults: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that have the same value\n                as the default. This is different from `response_model_exclude_unset`\n                in that if the fields are set but contain the same default values,\n                they will be excluded from the response.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_none: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data should\n                exclude fields set to `None`.\n\n                This is much simpler (less smart) than `response_model_exclude_unset`\n                and `response_model_exclude_defaults`. You probably want to use one of\n                those two instead of this one, as those allow returning `None` values\n                when it makes sense.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\n                \"\"\"\n            ),\n        ] = False,\n        include_in_schema: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Include this *path operation* in the generated OpenAPI schema.\n\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\n                \"\"\"\n            ),\n        ] = True,\n        response_class: Annotated[\n            Type[Response],\n            Doc(\n                \"\"\"\n                Response class to be used for this *path operation*.\n\n                This will not be used if you return a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\n                \"\"\"\n            ),\n        ] = Default(JSONResponse),\n        name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Name for this *path operation*. Only used internally.\n                \"\"\"\n            ),\n        ] = None,\n        callbacks: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                List of *path operations* that will be used as OpenAPI callbacks.\n\n                This is only for OpenAPI documentation, the callbacks won't be used\n                directly.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\n                \"\"\"\n            ),\n        ] = None,\n        openapi_extra: Annotated[\n            Optional[Dict[str, Any]],\n            Doc(\n                \"\"\"\n                Extra metadata to be included in the OpenAPI schema for this *path\n                operation*.\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\n                \"\"\"\n            ),\n        ] = None,\n        generate_unique_id_function: Annotated[\n            Callable[[routing.APIRoute], str],\n            Doc(\n                \"\"\"\n                Customize the function used to generate unique IDs for the *path\n                operations* shown in the generated OpenAPI.\n\n                This is particularly useful when automatically generating clients or\n                SDKs for your API.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = Default(generate_unique_id),\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Add a *path operation* using an HTTP PUT operation.\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI\n        from pydantic import BaseModel\n\n        class Item(BaseModel):\n            name: str\n            description: str | None = None\n\n        app = FastAPI()\n\n        @app.put(\"/items/{item_id}\")\n        def replace_item(item_id: str, item: Item):\n            return {\"message\": \"Item replaced\", \"id\": item_id}\n        ```\n        \"\"\"\n        return self.router.put(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n            generate_unique_id_function=generate_unique_id_function,\n        )",
      "docstring": "Add a *path operation* using an HTTP PUT operation.\n\n## Example\n\n```python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\nclass Item(BaseModel):\n    name: str\n    description: str | None = None\n\napp = FastAPI()\n\n@app.put(\"/items/{item_id}\")\ndef replace_item(item_id: str, item: Item):\n    return {\"message\": \"Item replaced\", \"id\": item_id}\n```",
      "decorators": [],
      "arguments": [
        "self",
        "path"
      ],
      "imports": [
        "enum.Enum",
        "typing.Any",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Type",
        "typing.TypeVar",
        "typing.Union",
        "fastapi.routing",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.exception_handlers.http_exception_handler",
        "fastapi.exception_handlers.request_validation_exception_handler",
        "fastapi.exception_handlers.websocket_request_validation_exception_handler",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.logger.logger",
        "fastapi.openapi.docs.get_redoc_html",
        "fastapi.openapi.docs.get_swagger_ui_html",
        "fastapi.openapi.docs.get_swagger_ui_oauth2_redirect_html",
        "fastapi.openapi.utils.get_openapi",
        "fastapi.params.Depends",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.generate_unique_id",
        "starlette.applications.Starlette",
        "starlette.datastructures.State",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.requests.Request",
        "starlette.responses.HTMLResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "self.router.put",
          "body": "def put(self, path: Annotated[str, Doc('\\n                The URL path to be used for this *path operation*.\\n\\n                For example, in `http://example.com/items`, the path is `/items`.\\n                ')], *, response_model: Annotated[Any, Doc(\"\\n                The type to use for the response.\\n\\n                It could be any valid Pydantic *field* type. So, it doesn't have to\\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\\n                etc.\\n\\n                It will be used for:\\n\\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\\n                    show it as the response (JSON Schema).\\n                * Serialization: you could return an arbitrary object and the\\n                    `response_model` would be used to serialize that object into the\\n                    corresponding JSON.\\n                * Filtering: the JSON sent to the client will only contain the data\\n                    (fields) defined in the `response_model`. If you returned an object\\n                    that contains an attribute `password` but the `response_model` does\\n                    not include that field, the JSON sent to the client would not have\\n                    that `password`.\\n                * Validation: whatever you return will be serialized with the\\n                    `response_model`, converting any data as necessary to generate the\\n                    corresponding JSON. But if the data in the object returned is not\\n                    valid, that would mean a violation of the contract with the client,\\n                    so it's an error from the API developer. So, FastAPI will raise an\\n                    error and return a 500 error code (Internal Server Error).\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\\n                \")]=Default(None), status_code: Annotated[Optional[int], Doc('\\n                The default status code to be used for the response.\\n\\n                You could override the status code by returning a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\\n                ')]=None, tags: Annotated[Optional[List[Union[str, Enum]]], Doc('\\n                A list of tags to be applied to the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\\n                ')]=None, dependencies: Annotated[Optional[Sequence[Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to the\\n                *path operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\\n                ')]=None, summary: Annotated[Optional[str], Doc('\\n                A summary for the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, description: Annotated[Optional[str], Doc('\\n                A description for the *path operation*.\\n\\n                If not provided, it will be extracted automatically from the docstring\\n                of the *path operation function*.\\n\\n                It can contain Markdown.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, response_description: Annotated[str, Doc('\\n                The description for the default response.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]='Successful Response', responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses that could be returned by this *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark this *path operation* as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, operation_id: Annotated[Optional[str], Doc('\\n                Custom operation ID to be used by this *path operation*.\\n\\n                By default, it is generated automatically.\\n\\n                If you provide a custom operation ID, you need to make sure it is\\n                unique for the whole API.\\n\\n                You can customize the\\n                operation ID generation with the parameter\\n                `generate_unique_id_function` in the `FastAPI` class.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=None, response_model_include: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to include only certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_exclude: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to exclude certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_by_alias: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response model\\n                should be serialized by alias when an alias is used.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=True, response_model_exclude_unset: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that were not set and\\n                have their default values. This is different from\\n                `response_model_exclude_defaults` in that if the fields are set,\\n                they will be included in the response, even if the value is the same\\n                as the default.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_defaults: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that have the same value\\n                as the default. This is different from `response_model_exclude_unset`\\n                in that if the fields are set but contain the same default values,\\n                they will be excluded from the response.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_none: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data should\\n                exclude fields set to `None`.\\n\\n                This is much simpler (less smart) than `response_model_exclude_unset`\\n                and `response_model_exclude_defaults`. You probably want to use one of\\n                those two instead of this one, as those allow returning `None` values\\n                when it makes sense.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\\n                ')]=False, include_in_schema: Annotated[bool, Doc('\\n                Include this *path operation* in the generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\\n                ')]=True, response_class: Annotated[Type[Response], Doc('\\n                Response class to be used for this *path operation*.\\n\\n                This will not be used if you return a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\\n                ')]=Default(JSONResponse), name: Annotated[Optional[str], Doc('\\n                Name for this *path operation*. Only used internally.\\n                ')]=None, callbacks: Annotated[Optional[List[BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")]=None, openapi_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n                Extra metadata to be included in the OpenAPI schema for this *path\\n                operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\\n                ')]=None, generate_unique_id_function: Annotated[Callable[[routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=Default(generate_unique_id)) -> Callable[[DecoratedCallable], DecoratedCallable]:\n    \"\"\"\n        Add a *path operation* using an HTTP PUT operation.\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI\n        from pydantic import BaseModel\n\n        class Item(BaseModel):\n            name: str\n            description: str | None = None\n\n        app = FastAPI()\n\n        @app.put(\"/items/{item_id}\")\n        def replace_item(item_id: str, item: Item):\n            return {\"message\": \"Item replaced\", \"id\": item_id}\n        ```\n        \"\"\"\n    return self.router.put(path, response_model=response_model, status_code=status_code, tags=tags, dependencies=dependencies, summary=summary, description=description, response_description=response_description, responses=responses, deprecated=deprecated, operation_id=operation_id, response_model_include=response_model_include, response_model_exclude=response_model_exclude, response_model_by_alias=response_model_by_alias, response_model_exclude_unset=response_model_exclude_unset, response_model_exclude_defaults=response_model_exclude_defaults, response_model_exclude_none=response_model_exclude_none, include_in_schema=include_in_schema, response_class=response_class, name=name, callbacks=callbacks, openapi_extra=openapi_extra, generate_unique_id_function=generate_unique_id_function)"
        }
      ]
    },
    {
      "name": "post",
      "module": "applications",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\applications.py",
      "line_number": 2211,
      "end_line_number": 2587,
      "source_code": "def post(\n        self,\n        path: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The URL path to be used for this *path operation*.\n\n                For example, in `http://example.com/items`, the path is `/items`.\n                \"\"\"\n            ),\n        ],\n        *,\n        response_model: Annotated[\n            Any,\n            Doc(\n                \"\"\"\n                The type to use for the response.\n\n                It could be any valid Pydantic *field* type. So, it doesn't have to\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\n                etc.\n\n                It will be used for:\n\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\n                    show it as the response (JSON Schema).\n                * Serialization: you could return an arbitrary object and the\n                    `response_model` would be used to serialize that object into the\n                    corresponding JSON.\n                * Filtering: the JSON sent to the client will only contain the data\n                    (fields) defined in the `response_model`. If you returned an object\n                    that contains an attribute `password` but the `response_model` does\n                    not include that field, the JSON sent to the client would not have\n                    that `password`.\n                * Validation: whatever you return will be serialized with the\n                    `response_model`, converting any data as necessary to generate the\n                    corresponding JSON. But if the data in the object returned is not\n                    valid, that would mean a violation of the contract with the client,\n                    so it's an error from the API developer. So, FastAPI will raise an\n                    error and return a 500 error code (Internal Server Error).\n\n                Read more about it in the\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\n                \"\"\"\n            ),\n        ] = Default(None),\n        status_code: Annotated[\n            Optional[int],\n            Doc(\n                \"\"\"\n                The default status code to be used for the response.\n\n                You could override the status code by returning a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\n                \"\"\"\n            ),\n        ] = None,\n        tags: Annotated[\n            Optional[List[Union[str, Enum]]],\n            Doc(\n                \"\"\"\n                A list of tags to be applied to the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\n                \"\"\"\n            ),\n        ] = None,\n        dependencies: Annotated[\n            Optional[Sequence[Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be applied to the\n                *path operation*.\n\n                Read more about it in the\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\n                \"\"\"\n            ),\n        ] = None,\n        summary: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A summary for the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A description for the *path operation*.\n\n                If not provided, it will be extracted automatically from the docstring\n                of the *path operation function*.\n\n                It can contain Markdown.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        response_description: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The description for the default response.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = \"Successful Response\",\n        responses: Annotated[\n            Optional[Dict[Union[int, str], Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                Additional responses that could be returned by this *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        deprecated: Annotated[\n            Optional[bool],\n            Doc(\n                \"\"\"\n                Mark this *path operation* as deprecated.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        operation_id: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Custom operation ID to be used by this *path operation*.\n\n                By default, it is generated automatically.\n\n                If you provide a custom operation ID, you need to make sure it is\n                unique for the whole API.\n\n                You can customize the\n                operation ID generation with the parameter\n                `generate_unique_id_function` in the `FastAPI` class.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_include: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to include only certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_exclude: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to exclude certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_by_alias: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response model\n                should be serialized by alias when an alias is used.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = True,\n        response_model_exclude_unset: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that were not set and\n                have their default values. This is different from\n                `response_model_exclude_defaults` in that if the fields are set,\n                they will be included in the response, even if the value is the same\n                as the default.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_defaults: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that have the same value\n                as the default. This is different from `response_model_exclude_unset`\n                in that if the fields are set but contain the same default values,\n                they will be excluded from the response.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_none: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data should\n                exclude fields set to `None`.\n\n                This is much simpler (less smart) than `response_model_exclude_unset`\n                and `response_model_exclude_defaults`. You probably want to use one of\n                those two instead of this one, as those allow returning `None` values\n                when it makes sense.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\n                \"\"\"\n            ),\n        ] = False,\n        include_in_schema: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Include this *path operation* in the generated OpenAPI schema.\n\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\n                \"\"\"\n            ),\n        ] = True,\n        response_class: Annotated[\n            Type[Response],\n            Doc(\n                \"\"\"\n                Response class to be used for this *path operation*.\n\n                This will not be used if you return a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\n                \"\"\"\n            ),\n        ] = Default(JSONResponse),\n        name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Name for this *path operation*. Only used internally.\n                \"\"\"\n            ),\n        ] = None,\n        callbacks: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                List of *path operations* that will be used as OpenAPI callbacks.\n\n                This is only for OpenAPI documentation, the callbacks won't be used\n                directly.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\n                \"\"\"\n            ),\n        ] = None,\n        openapi_extra: Annotated[\n            Optional[Dict[str, Any]],\n            Doc(\n                \"\"\"\n                Extra metadata to be included in the OpenAPI schema for this *path\n                operation*.\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\n                \"\"\"\n            ),\n        ] = None,\n        generate_unique_id_function: Annotated[\n            Callable[[routing.APIRoute], str],\n            Doc(\n                \"\"\"\n                Customize the function used to generate unique IDs for the *path\n                operations* shown in the generated OpenAPI.\n\n                This is particularly useful when automatically generating clients or\n                SDKs for your API.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = Default(generate_unique_id),\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Add a *path operation* using an HTTP POST operation.\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI\n        from pydantic import BaseModel\n\n        class Item(BaseModel):\n            name: str\n            description: str | None = None\n\n        app = FastAPI()\n\n        @app.post(\"/items/\")\n        def create_item(item: Item):\n            return {\"message\": \"Item created\"}\n        ```\n        \"\"\"\n        return self.router.post(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n            generate_unique_id_function=generate_unique_id_function,\n        )",
      "docstring": "Add a *path operation* using an HTTP POST operation.\n\n## Example\n\n```python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\nclass Item(BaseModel):\n    name: str\n    description: str | None = None\n\napp = FastAPI()\n\n@app.post(\"/items/\")\ndef create_item(item: Item):\n    return {\"message\": \"Item created\"}\n```",
      "decorators": [],
      "arguments": [
        "self",
        "path"
      ],
      "imports": [
        "enum.Enum",
        "typing.Any",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Type",
        "typing.TypeVar",
        "typing.Union",
        "fastapi.routing",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.exception_handlers.http_exception_handler",
        "fastapi.exception_handlers.request_validation_exception_handler",
        "fastapi.exception_handlers.websocket_request_validation_exception_handler",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.logger.logger",
        "fastapi.openapi.docs.get_redoc_html",
        "fastapi.openapi.docs.get_swagger_ui_html",
        "fastapi.openapi.docs.get_swagger_ui_oauth2_redirect_html",
        "fastapi.openapi.utils.get_openapi",
        "fastapi.params.Depends",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.generate_unique_id",
        "starlette.applications.Starlette",
        "starlette.datastructures.State",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.requests.Request",
        "starlette.responses.HTMLResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "self.router.post",
          "body": "def post(self, path: Annotated[str, Doc('\\n                The URL path to be used for this *path operation*.\\n\\n                For example, in `http://example.com/items`, the path is `/items`.\\n                ')], *, response_model: Annotated[Any, Doc(\"\\n                The type to use for the response.\\n\\n                It could be any valid Pydantic *field* type. So, it doesn't have to\\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\\n                etc.\\n\\n                It will be used for:\\n\\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\\n                    show it as the response (JSON Schema).\\n                * Serialization: you could return an arbitrary object and the\\n                    `response_model` would be used to serialize that object into the\\n                    corresponding JSON.\\n                * Filtering: the JSON sent to the client will only contain the data\\n                    (fields) defined in the `response_model`. If you returned an object\\n                    that contains an attribute `password` but the `response_model` does\\n                    not include that field, the JSON sent to the client would not have\\n                    that `password`.\\n                * Validation: whatever you return will be serialized with the\\n                    `response_model`, converting any data as necessary to generate the\\n                    corresponding JSON. But if the data in the object returned is not\\n                    valid, that would mean a violation of the contract with the client,\\n                    so it's an error from the API developer. So, FastAPI will raise an\\n                    error and return a 500 error code (Internal Server Error).\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\\n                \")]=Default(None), status_code: Annotated[Optional[int], Doc('\\n                The default status code to be used for the response.\\n\\n                You could override the status code by returning a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\\n                ')]=None, tags: Annotated[Optional[List[Union[str, Enum]]], Doc('\\n                A list of tags to be applied to the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\\n                ')]=None, dependencies: Annotated[Optional[Sequence[Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to the\\n                *path operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\\n                ')]=None, summary: Annotated[Optional[str], Doc('\\n                A summary for the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, description: Annotated[Optional[str], Doc('\\n                A description for the *path operation*.\\n\\n                If not provided, it will be extracted automatically from the docstring\\n                of the *path operation function*.\\n\\n                It can contain Markdown.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, response_description: Annotated[str, Doc('\\n                The description for the default response.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]='Successful Response', responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses that could be returned by this *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark this *path operation* as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, operation_id: Annotated[Optional[str], Doc('\\n                Custom operation ID to be used by this *path operation*.\\n\\n                By default, it is generated automatically.\\n\\n                If you provide a custom operation ID, you need to make sure it is\\n                unique for the whole API.\\n\\n                You can customize the\\n                operation ID generation with the parameter\\n                `generate_unique_id_function` in the `FastAPI` class.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=None, response_model_include: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to include only certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_exclude: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to exclude certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_by_alias: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response model\\n                should be serialized by alias when an alias is used.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=True, response_model_exclude_unset: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that were not set and\\n                have their default values. This is different from\\n                `response_model_exclude_defaults` in that if the fields are set,\\n                they will be included in the response, even if the value is the same\\n                as the default.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_defaults: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that have the same value\\n                as the default. This is different from `response_model_exclude_unset`\\n                in that if the fields are set but contain the same default values,\\n                they will be excluded from the response.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_none: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data should\\n                exclude fields set to `None`.\\n\\n                This is much simpler (less smart) than `response_model_exclude_unset`\\n                and `response_model_exclude_defaults`. You probably want to use one of\\n                those two instead of this one, as those allow returning `None` values\\n                when it makes sense.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\\n                ')]=False, include_in_schema: Annotated[bool, Doc('\\n                Include this *path operation* in the generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\\n                ')]=True, response_class: Annotated[Type[Response], Doc('\\n                Response class to be used for this *path operation*.\\n\\n                This will not be used if you return a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\\n                ')]=Default(JSONResponse), name: Annotated[Optional[str], Doc('\\n                Name for this *path operation*. Only used internally.\\n                ')]=None, callbacks: Annotated[Optional[List[BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")]=None, openapi_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n                Extra metadata to be included in the OpenAPI schema for this *path\\n                operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\\n                ')]=None, generate_unique_id_function: Annotated[Callable[[routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=Default(generate_unique_id)) -> Callable[[DecoratedCallable], DecoratedCallable]:\n    \"\"\"\n        Add a *path operation* using an HTTP POST operation.\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI\n        from pydantic import BaseModel\n\n        class Item(BaseModel):\n            name: str\n            description: str | None = None\n\n        app = FastAPI()\n\n        @app.post(\"/items/\")\n        def create_item(item: Item):\n            return {\"message\": \"Item created\"}\n        ```\n        \"\"\"\n    return self.router.post(path, response_model=response_model, status_code=status_code, tags=tags, dependencies=dependencies, summary=summary, description=description, response_description=response_description, responses=responses, deprecated=deprecated, operation_id=operation_id, response_model_include=response_model_include, response_model_exclude=response_model_exclude, response_model_by_alias=response_model_by_alias, response_model_exclude_unset=response_model_exclude_unset, response_model_exclude_defaults=response_model_exclude_defaults, response_model_exclude_none=response_model_exclude_none, include_in_schema=include_in_schema, response_class=response_class, name=name, callbacks=callbacks, openapi_extra=openapi_extra, generate_unique_id_function=generate_unique_id_function)"
        }
      ]
    },
    {
      "name": "delete",
      "module": "applications",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\applications.py",
      "line_number": 2589,
      "end_line_number": 2960,
      "source_code": "def delete(\n        self,\n        path: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The URL path to be used for this *path operation*.\n\n                For example, in `http://example.com/items`, the path is `/items`.\n                \"\"\"\n            ),\n        ],\n        *,\n        response_model: Annotated[\n            Any,\n            Doc(\n                \"\"\"\n                The type to use for the response.\n\n                It could be any valid Pydantic *field* type. So, it doesn't have to\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\n                etc.\n\n                It will be used for:\n\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\n                    show it as the response (JSON Schema).\n                * Serialization: you could return an arbitrary object and the\n                    `response_model` would be used to serialize that object into the\n                    corresponding JSON.\n                * Filtering: the JSON sent to the client will only contain the data\n                    (fields) defined in the `response_model`. If you returned an object\n                    that contains an attribute `password` but the `response_model` does\n                    not include that field, the JSON sent to the client would not have\n                    that `password`.\n                * Validation: whatever you return will be serialized with the\n                    `response_model`, converting any data as necessary to generate the\n                    corresponding JSON. But if the data in the object returned is not\n                    valid, that would mean a violation of the contract with the client,\n                    so it's an error from the API developer. So, FastAPI will raise an\n                    error and return a 500 error code (Internal Server Error).\n\n                Read more about it in the\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\n                \"\"\"\n            ),\n        ] = Default(None),\n        status_code: Annotated[\n            Optional[int],\n            Doc(\n                \"\"\"\n                The default status code to be used for the response.\n\n                You could override the status code by returning a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\n                \"\"\"\n            ),\n        ] = None,\n        tags: Annotated[\n            Optional[List[Union[str, Enum]]],\n            Doc(\n                \"\"\"\n                A list of tags to be applied to the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\n                \"\"\"\n            ),\n        ] = None,\n        dependencies: Annotated[\n            Optional[Sequence[Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be applied to the\n                *path operation*.\n\n                Read more about it in the\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\n                \"\"\"\n            ),\n        ] = None,\n        summary: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A summary for the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A description for the *path operation*.\n\n                If not provided, it will be extracted automatically from the docstring\n                of the *path operation function*.\n\n                It can contain Markdown.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        response_description: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The description for the default response.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = \"Successful Response\",\n        responses: Annotated[\n            Optional[Dict[Union[int, str], Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                Additional responses that could be returned by this *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        deprecated: Annotated[\n            Optional[bool],\n            Doc(\n                \"\"\"\n                Mark this *path operation* as deprecated.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        operation_id: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Custom operation ID to be used by this *path operation*.\n\n                By default, it is generated automatically.\n\n                If you provide a custom operation ID, you need to make sure it is\n                unique for the whole API.\n\n                You can customize the\n                operation ID generation with the parameter\n                `generate_unique_id_function` in the `FastAPI` class.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_include: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to include only certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_exclude: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to exclude certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_by_alias: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response model\n                should be serialized by alias when an alias is used.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = True,\n        response_model_exclude_unset: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that were not set and\n                have their default values. This is different from\n                `response_model_exclude_defaults` in that if the fields are set,\n                they will be included in the response, even if the value is the same\n                as the default.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_defaults: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that have the same value\n                as the default. This is different from `response_model_exclude_unset`\n                in that if the fields are set but contain the same default values,\n                they will be excluded from the response.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_none: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data should\n                exclude fields set to `None`.\n\n                This is much simpler (less smart) than `response_model_exclude_unset`\n                and `response_model_exclude_defaults`. You probably want to use one of\n                those two instead of this one, as those allow returning `None` values\n                when it makes sense.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\n                \"\"\"\n            ),\n        ] = False,\n        include_in_schema: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Include this *path operation* in the generated OpenAPI schema.\n\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\n                \"\"\"\n            ),\n        ] = True,\n        response_class: Annotated[\n            Type[Response],\n            Doc(\n                \"\"\"\n                Response class to be used for this *path operation*.\n\n                This will not be used if you return a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\n                \"\"\"\n            ),\n        ] = Default(JSONResponse),\n        name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Name for this *path operation*. Only used internally.\n                \"\"\"\n            ),\n        ] = None,\n        callbacks: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                List of *path operations* that will be used as OpenAPI callbacks.\n\n                This is only for OpenAPI documentation, the callbacks won't be used\n                directly.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\n                \"\"\"\n            ),\n        ] = None,\n        openapi_extra: Annotated[\n            Optional[Dict[str, Any]],\n            Doc(\n                \"\"\"\n                Extra metadata to be included in the OpenAPI schema for this *path\n                operation*.\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\n                \"\"\"\n            ),\n        ] = None,\n        generate_unique_id_function: Annotated[\n            Callable[[routing.APIRoute], str],\n            Doc(\n                \"\"\"\n                Customize the function used to generate unique IDs for the *path\n                operations* shown in the generated OpenAPI.\n\n                This is particularly useful when automatically generating clients or\n                SDKs for your API.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = Default(generate_unique_id),\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Add a *path operation* using an HTTP DELETE operation.\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI\n\n        app = FastAPI()\n\n        @app.delete(\"/items/{item_id}\")\n        def delete_item(item_id: str):\n            return {\"message\": \"Item deleted\"}\n        ```\n        \"\"\"\n        return self.router.delete(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n            generate_unique_id_function=generate_unique_id_function,\n        )",
      "docstring": "Add a *path operation* using an HTTP DELETE operation.\n\n## Example\n\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.delete(\"/items/{item_id}\")\ndef delete_item(item_id: str):\n    return {\"message\": \"Item deleted\"}\n```",
      "decorators": [],
      "arguments": [
        "self",
        "path"
      ],
      "imports": [
        "enum.Enum",
        "typing.Any",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Type",
        "typing.TypeVar",
        "typing.Union",
        "fastapi.routing",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.exception_handlers.http_exception_handler",
        "fastapi.exception_handlers.request_validation_exception_handler",
        "fastapi.exception_handlers.websocket_request_validation_exception_handler",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.logger.logger",
        "fastapi.openapi.docs.get_redoc_html",
        "fastapi.openapi.docs.get_swagger_ui_html",
        "fastapi.openapi.docs.get_swagger_ui_oauth2_redirect_html",
        "fastapi.openapi.utils.get_openapi",
        "fastapi.params.Depends",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.generate_unique_id",
        "starlette.applications.Starlette",
        "starlette.datastructures.State",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.requests.Request",
        "starlette.responses.HTMLResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "self.router.delete",
          "body": "def delete(self, path: Annotated[str, Doc('\\n                The URL path to be used for this *path operation*.\\n\\n                For example, in `http://example.com/items`, the path is `/items`.\\n                ')], *, response_model: Annotated[Any, Doc(\"\\n                The type to use for the response.\\n\\n                It could be any valid Pydantic *field* type. So, it doesn't have to\\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\\n                etc.\\n\\n                It will be used for:\\n\\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\\n                    show it as the response (JSON Schema).\\n                * Serialization: you could return an arbitrary object and the\\n                    `response_model` would be used to serialize that object into the\\n                    corresponding JSON.\\n                * Filtering: the JSON sent to the client will only contain the data\\n                    (fields) defined in the `response_model`. If you returned an object\\n                    that contains an attribute `password` but the `response_model` does\\n                    not include that field, the JSON sent to the client would not have\\n                    that `password`.\\n                * Validation: whatever you return will be serialized with the\\n                    `response_model`, converting any data as necessary to generate the\\n                    corresponding JSON. But if the data in the object returned is not\\n                    valid, that would mean a violation of the contract with the client,\\n                    so it's an error from the API developer. So, FastAPI will raise an\\n                    error and return a 500 error code (Internal Server Error).\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\\n                \")]=Default(None), status_code: Annotated[Optional[int], Doc('\\n                The default status code to be used for the response.\\n\\n                You could override the status code by returning a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\\n                ')]=None, tags: Annotated[Optional[List[Union[str, Enum]]], Doc('\\n                A list of tags to be applied to the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\\n                ')]=None, dependencies: Annotated[Optional[Sequence[Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to the\\n                *path operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\\n                ')]=None, summary: Annotated[Optional[str], Doc('\\n                A summary for the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, description: Annotated[Optional[str], Doc('\\n                A description for the *path operation*.\\n\\n                If not provided, it will be extracted automatically from the docstring\\n                of the *path operation function*.\\n\\n                It can contain Markdown.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, response_description: Annotated[str, Doc('\\n                The description for the default response.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]='Successful Response', responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses that could be returned by this *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark this *path operation* as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, operation_id: Annotated[Optional[str], Doc('\\n                Custom operation ID to be used by this *path operation*.\\n\\n                By default, it is generated automatically.\\n\\n                If you provide a custom operation ID, you need to make sure it is\\n                unique for the whole API.\\n\\n                You can customize the\\n                operation ID generation with the parameter\\n                `generate_unique_id_function` in the `FastAPI` class.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=None, response_model_include: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to include only certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_exclude: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to exclude certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_by_alias: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response model\\n                should be serialized by alias when an alias is used.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=True, response_model_exclude_unset: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that were not set and\\n                have their default values. This is different from\\n                `response_model_exclude_defaults` in that if the fields are set,\\n                they will be included in the response, even if the value is the same\\n                as the default.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_defaults: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that have the same value\\n                as the default. This is different from `response_model_exclude_unset`\\n                in that if the fields are set but contain the same default values,\\n                they will be excluded from the response.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_none: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data should\\n                exclude fields set to `None`.\\n\\n                This is much simpler (less smart) than `response_model_exclude_unset`\\n                and `response_model_exclude_defaults`. You probably want to use one of\\n                those two instead of this one, as those allow returning `None` values\\n                when it makes sense.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\\n                ')]=False, include_in_schema: Annotated[bool, Doc('\\n                Include this *path operation* in the generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\\n                ')]=True, response_class: Annotated[Type[Response], Doc('\\n                Response class to be used for this *path operation*.\\n\\n                This will not be used if you return a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\\n                ')]=Default(JSONResponse), name: Annotated[Optional[str], Doc('\\n                Name for this *path operation*. Only used internally.\\n                ')]=None, callbacks: Annotated[Optional[List[BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")]=None, openapi_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n                Extra metadata to be included in the OpenAPI schema for this *path\\n                operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\\n                ')]=None, generate_unique_id_function: Annotated[Callable[[routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=Default(generate_unique_id)) -> Callable[[DecoratedCallable], DecoratedCallable]:\n    \"\"\"\n        Add a *path operation* using an HTTP DELETE operation.\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI\n\n        app = FastAPI()\n\n        @app.delete(\"/items/{item_id}\")\n        def delete_item(item_id: str):\n            return {\"message\": \"Item deleted\"}\n        ```\n        \"\"\"\n    return self.router.delete(path, response_model=response_model, status_code=status_code, tags=tags, dependencies=dependencies, summary=summary, description=description, response_description=response_description, responses=responses, deprecated=deprecated, operation_id=operation_id, response_model_include=response_model_include, response_model_exclude=response_model_exclude, response_model_by_alias=response_model_by_alias, response_model_exclude_unset=response_model_exclude_unset, response_model_exclude_defaults=response_model_exclude_defaults, response_model_exclude_none=response_model_exclude_none, include_in_schema=include_in_schema, response_class=response_class, name=name, callbacks=callbacks, openapi_extra=openapi_extra, generate_unique_id_function=generate_unique_id_function)"
        }
      ]
    },
    {
      "name": "options",
      "module": "applications",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\applications.py",
      "line_number": 2962,
      "end_line_number": 3333,
      "source_code": "def options(\n        self,\n        path: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The URL path to be used for this *path operation*.\n\n                For example, in `http://example.com/items`, the path is `/items`.\n                \"\"\"\n            ),\n        ],\n        *,\n        response_model: Annotated[\n            Any,\n            Doc(\n                \"\"\"\n                The type to use for the response.\n\n                It could be any valid Pydantic *field* type. So, it doesn't have to\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\n                etc.\n\n                It will be used for:\n\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\n                    show it as the response (JSON Schema).\n                * Serialization: you could return an arbitrary object and the\n                    `response_model` would be used to serialize that object into the\n                    corresponding JSON.\n                * Filtering: the JSON sent to the client will only contain the data\n                    (fields) defined in the `response_model`. If you returned an object\n                    that contains an attribute `password` but the `response_model` does\n                    not include that field, the JSON sent to the client would not have\n                    that `password`.\n                * Validation: whatever you return will be serialized with the\n                    `response_model`, converting any data as necessary to generate the\n                    corresponding JSON. But if the data in the object returned is not\n                    valid, that would mean a violation of the contract with the client,\n                    so it's an error from the API developer. So, FastAPI will raise an\n                    error and return a 500 error code (Internal Server Error).\n\n                Read more about it in the\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\n                \"\"\"\n            ),\n        ] = Default(None),\n        status_code: Annotated[\n            Optional[int],\n            Doc(\n                \"\"\"\n                The default status code to be used for the response.\n\n                You could override the status code by returning a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\n                \"\"\"\n            ),\n        ] = None,\n        tags: Annotated[\n            Optional[List[Union[str, Enum]]],\n            Doc(\n                \"\"\"\n                A list of tags to be applied to the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\n                \"\"\"\n            ),\n        ] = None,\n        dependencies: Annotated[\n            Optional[Sequence[Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be applied to the\n                *path operation*.\n\n                Read more about it in the\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\n                \"\"\"\n            ),\n        ] = None,\n        summary: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A summary for the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A description for the *path operation*.\n\n                If not provided, it will be extracted automatically from the docstring\n                of the *path operation function*.\n\n                It can contain Markdown.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        response_description: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The description for the default response.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = \"Successful Response\",\n        responses: Annotated[\n            Optional[Dict[Union[int, str], Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                Additional responses that could be returned by this *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        deprecated: Annotated[\n            Optional[bool],\n            Doc(\n                \"\"\"\n                Mark this *path operation* as deprecated.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        operation_id: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Custom operation ID to be used by this *path operation*.\n\n                By default, it is generated automatically.\n\n                If you provide a custom operation ID, you need to make sure it is\n                unique for the whole API.\n\n                You can customize the\n                operation ID generation with the parameter\n                `generate_unique_id_function` in the `FastAPI` class.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_include: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to include only certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_exclude: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to exclude certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_by_alias: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response model\n                should be serialized by alias when an alias is used.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = True,\n        response_model_exclude_unset: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that were not set and\n                have their default values. This is different from\n                `response_model_exclude_defaults` in that if the fields are set,\n                they will be included in the response, even if the value is the same\n                as the default.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_defaults: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that have the same value\n                as the default. This is different from `response_model_exclude_unset`\n                in that if the fields are set but contain the same default values,\n                they will be excluded from the response.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_none: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data should\n                exclude fields set to `None`.\n\n                This is much simpler (less smart) than `response_model_exclude_unset`\n                and `response_model_exclude_defaults`. You probably want to use one of\n                those two instead of this one, as those allow returning `None` values\n                when it makes sense.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\n                \"\"\"\n            ),\n        ] = False,\n        include_in_schema: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Include this *path operation* in the generated OpenAPI schema.\n\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\n                \"\"\"\n            ),\n        ] = True,\n        response_class: Annotated[\n            Type[Response],\n            Doc(\n                \"\"\"\n                Response class to be used for this *path operation*.\n\n                This will not be used if you return a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\n                \"\"\"\n            ),\n        ] = Default(JSONResponse),\n        name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Name for this *path operation*. Only used internally.\n                \"\"\"\n            ),\n        ] = None,\n        callbacks: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                List of *path operations* that will be used as OpenAPI callbacks.\n\n                This is only for OpenAPI documentation, the callbacks won't be used\n                directly.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\n                \"\"\"\n            ),\n        ] = None,\n        openapi_extra: Annotated[\n            Optional[Dict[str, Any]],\n            Doc(\n                \"\"\"\n                Extra metadata to be included in the OpenAPI schema for this *path\n                operation*.\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\n                \"\"\"\n            ),\n        ] = None,\n        generate_unique_id_function: Annotated[\n            Callable[[routing.APIRoute], str],\n            Doc(\n                \"\"\"\n                Customize the function used to generate unique IDs for the *path\n                operations* shown in the generated OpenAPI.\n\n                This is particularly useful when automatically generating clients or\n                SDKs for your API.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = Default(generate_unique_id),\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Add a *path operation* using an HTTP OPTIONS operation.\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI\n\n        app = FastAPI()\n\n        @app.options(\"/items/\")\n        def get_item_options():\n            return {\"additions\": [\"Aji\", \"Guacamole\"]}\n        ```\n        \"\"\"\n        return self.router.options(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n            generate_unique_id_function=generate_unique_id_function,\n        )",
      "docstring": "Add a *path operation* using an HTTP OPTIONS operation.\n\n## Example\n\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.options(\"/items/\")\ndef get_item_options():\n    return {\"additions\": [\"Aji\", \"Guacamole\"]}\n```",
      "decorators": [],
      "arguments": [
        "self",
        "path"
      ],
      "imports": [
        "enum.Enum",
        "typing.Any",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Type",
        "typing.TypeVar",
        "typing.Union",
        "fastapi.routing",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.exception_handlers.http_exception_handler",
        "fastapi.exception_handlers.request_validation_exception_handler",
        "fastapi.exception_handlers.websocket_request_validation_exception_handler",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.logger.logger",
        "fastapi.openapi.docs.get_redoc_html",
        "fastapi.openapi.docs.get_swagger_ui_html",
        "fastapi.openapi.docs.get_swagger_ui_oauth2_redirect_html",
        "fastapi.openapi.utils.get_openapi",
        "fastapi.params.Depends",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.generate_unique_id",
        "starlette.applications.Starlette",
        "starlette.datastructures.State",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.requests.Request",
        "starlette.responses.HTMLResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "self.router.options",
          "body": "def options(self, path: Annotated[str, Doc('\\n                The URL path to be used for this *path operation*.\\n\\n                For example, in `http://example.com/items`, the path is `/items`.\\n                ')], *, response_model: Annotated[Any, Doc(\"\\n                The type to use for the response.\\n\\n                It could be any valid Pydantic *field* type. So, it doesn't have to\\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\\n                etc.\\n\\n                It will be used for:\\n\\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\\n                    show it as the response (JSON Schema).\\n                * Serialization: you could return an arbitrary object and the\\n                    `response_model` would be used to serialize that object into the\\n                    corresponding JSON.\\n                * Filtering: the JSON sent to the client will only contain the data\\n                    (fields) defined in the `response_model`. If you returned an object\\n                    that contains an attribute `password` but the `response_model` does\\n                    not include that field, the JSON sent to the client would not have\\n                    that `password`.\\n                * Validation: whatever you return will be serialized with the\\n                    `response_model`, converting any data as necessary to generate the\\n                    corresponding JSON. But if the data in the object returned is not\\n                    valid, that would mean a violation of the contract with the client,\\n                    so it's an error from the API developer. So, FastAPI will raise an\\n                    error and return a 500 error code (Internal Server Error).\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\\n                \")]=Default(None), status_code: Annotated[Optional[int], Doc('\\n                The default status code to be used for the response.\\n\\n                You could override the status code by returning a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\\n                ')]=None, tags: Annotated[Optional[List[Union[str, Enum]]], Doc('\\n                A list of tags to be applied to the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\\n                ')]=None, dependencies: Annotated[Optional[Sequence[Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to the\\n                *path operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\\n                ')]=None, summary: Annotated[Optional[str], Doc('\\n                A summary for the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, description: Annotated[Optional[str], Doc('\\n                A description for the *path operation*.\\n\\n                If not provided, it will be extracted automatically from the docstring\\n                of the *path operation function*.\\n\\n                It can contain Markdown.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, response_description: Annotated[str, Doc('\\n                The description for the default response.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]='Successful Response', responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses that could be returned by this *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark this *path operation* as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, operation_id: Annotated[Optional[str], Doc('\\n                Custom operation ID to be used by this *path operation*.\\n\\n                By default, it is generated automatically.\\n\\n                If you provide a custom operation ID, you need to make sure it is\\n                unique for the whole API.\\n\\n                You can customize the\\n                operation ID generation with the parameter\\n                `generate_unique_id_function` in the `FastAPI` class.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=None, response_model_include: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to include only certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_exclude: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to exclude certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_by_alias: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response model\\n                should be serialized by alias when an alias is used.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=True, response_model_exclude_unset: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that were not set and\\n                have their default values. This is different from\\n                `response_model_exclude_defaults` in that if the fields are set,\\n                they will be included in the response, even if the value is the same\\n                as the default.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_defaults: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that have the same value\\n                as the default. This is different from `response_model_exclude_unset`\\n                in that if the fields are set but contain the same default values,\\n                they will be excluded from the response.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_none: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data should\\n                exclude fields set to `None`.\\n\\n                This is much simpler (less smart) than `response_model_exclude_unset`\\n                and `response_model_exclude_defaults`. You probably want to use one of\\n                those two instead of this one, as those allow returning `None` values\\n                when it makes sense.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\\n                ')]=False, include_in_schema: Annotated[bool, Doc('\\n                Include this *path operation* in the generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\\n                ')]=True, response_class: Annotated[Type[Response], Doc('\\n                Response class to be used for this *path operation*.\\n\\n                This will not be used if you return a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\\n                ')]=Default(JSONResponse), name: Annotated[Optional[str], Doc('\\n                Name for this *path operation*. Only used internally.\\n                ')]=None, callbacks: Annotated[Optional[List[BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")]=None, openapi_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n                Extra metadata to be included in the OpenAPI schema for this *path\\n                operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\\n                ')]=None, generate_unique_id_function: Annotated[Callable[[routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=Default(generate_unique_id)) -> Callable[[DecoratedCallable], DecoratedCallable]:\n    \"\"\"\n        Add a *path operation* using an HTTP OPTIONS operation.\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI\n\n        app = FastAPI()\n\n        @app.options(\"/items/\")\n        def get_item_options():\n            return {\"additions\": [\"Aji\", \"Guacamole\"]}\n        ```\n        \"\"\"\n    return self.router.options(path, response_model=response_model, status_code=status_code, tags=tags, dependencies=dependencies, summary=summary, description=description, response_description=response_description, responses=responses, deprecated=deprecated, operation_id=operation_id, response_model_include=response_model_include, response_model_exclude=response_model_exclude, response_model_by_alias=response_model_by_alias, response_model_exclude_unset=response_model_exclude_unset, response_model_exclude_defaults=response_model_exclude_defaults, response_model_exclude_none=response_model_exclude_none, include_in_schema=include_in_schema, response_class=response_class, name=name, callbacks=callbacks, openapi_extra=openapi_extra, generate_unique_id_function=generate_unique_id_function)"
        }
      ]
    },
    {
      "name": "head",
      "module": "applications",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\applications.py",
      "line_number": 3335,
      "end_line_number": 3706,
      "source_code": "def head(\n        self,\n        path: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The URL path to be used for this *path operation*.\n\n                For example, in `http://example.com/items`, the path is `/items`.\n                \"\"\"\n            ),\n        ],\n        *,\n        response_model: Annotated[\n            Any,\n            Doc(\n                \"\"\"\n                The type to use for the response.\n\n                It could be any valid Pydantic *field* type. So, it doesn't have to\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\n                etc.\n\n                It will be used for:\n\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\n                    show it as the response (JSON Schema).\n                * Serialization: you could return an arbitrary object and the\n                    `response_model` would be used to serialize that object into the\n                    corresponding JSON.\n                * Filtering: the JSON sent to the client will only contain the data\n                    (fields) defined in the `response_model`. If you returned an object\n                    that contains an attribute `password` but the `response_model` does\n                    not include that field, the JSON sent to the client would not have\n                    that `password`.\n                * Validation: whatever you return will be serialized with the\n                    `response_model`, converting any data as necessary to generate the\n                    corresponding JSON. But if the data in the object returned is not\n                    valid, that would mean a violation of the contract with the client,\n                    so it's an error from the API developer. So, FastAPI will raise an\n                    error and return a 500 error code (Internal Server Error).\n\n                Read more about it in the\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\n                \"\"\"\n            ),\n        ] = Default(None),\n        status_code: Annotated[\n            Optional[int],\n            Doc(\n                \"\"\"\n                The default status code to be used for the response.\n\n                You could override the status code by returning a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\n                \"\"\"\n            ),\n        ] = None,\n        tags: Annotated[\n            Optional[List[Union[str, Enum]]],\n            Doc(\n                \"\"\"\n                A list of tags to be applied to the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\n                \"\"\"\n            ),\n        ] = None,\n        dependencies: Annotated[\n            Optional[Sequence[Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be applied to the\n                *path operation*.\n\n                Read more about it in the\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\n                \"\"\"\n            ),\n        ] = None,\n        summary: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A summary for the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A description for the *path operation*.\n\n                If not provided, it will be extracted automatically from the docstring\n                of the *path operation function*.\n\n                It can contain Markdown.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        response_description: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The description for the default response.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = \"Successful Response\",\n        responses: Annotated[\n            Optional[Dict[Union[int, str], Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                Additional responses that could be returned by this *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        deprecated: Annotated[\n            Optional[bool],\n            Doc(\n                \"\"\"\n                Mark this *path operation* as deprecated.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        operation_id: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Custom operation ID to be used by this *path operation*.\n\n                By default, it is generated automatically.\n\n                If you provide a custom operation ID, you need to make sure it is\n                unique for the whole API.\n\n                You can customize the\n                operation ID generation with the parameter\n                `generate_unique_id_function` in the `FastAPI` class.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_include: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to include only certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_exclude: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to exclude certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_by_alias: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response model\n                should be serialized by alias when an alias is used.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = True,\n        response_model_exclude_unset: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that were not set and\n                have their default values. This is different from\n                `response_model_exclude_defaults` in that if the fields are set,\n                they will be included in the response, even if the value is the same\n                as the default.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_defaults: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that have the same value\n                as the default. This is different from `response_model_exclude_unset`\n                in that if the fields are set but contain the same default values,\n                they will be excluded from the response.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_none: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data should\n                exclude fields set to `None`.\n\n                This is much simpler (less smart) than `response_model_exclude_unset`\n                and `response_model_exclude_defaults`. You probably want to use one of\n                those two instead of this one, as those allow returning `None` values\n                when it makes sense.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\n                \"\"\"\n            ),\n        ] = False,\n        include_in_schema: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Include this *path operation* in the generated OpenAPI schema.\n\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\n                \"\"\"\n            ),\n        ] = True,\n        response_class: Annotated[\n            Type[Response],\n            Doc(\n                \"\"\"\n                Response class to be used for this *path operation*.\n\n                This will not be used if you return a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\n                \"\"\"\n            ),\n        ] = Default(JSONResponse),\n        name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Name for this *path operation*. Only used internally.\n                \"\"\"\n            ),\n        ] = None,\n        callbacks: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                List of *path operations* that will be used as OpenAPI callbacks.\n\n                This is only for OpenAPI documentation, the callbacks won't be used\n                directly.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\n                \"\"\"\n            ),\n        ] = None,\n        openapi_extra: Annotated[\n            Optional[Dict[str, Any]],\n            Doc(\n                \"\"\"\n                Extra metadata to be included in the OpenAPI schema for this *path\n                operation*.\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\n                \"\"\"\n            ),\n        ] = None,\n        generate_unique_id_function: Annotated[\n            Callable[[routing.APIRoute], str],\n            Doc(\n                \"\"\"\n                Customize the function used to generate unique IDs for the *path\n                operations* shown in the generated OpenAPI.\n\n                This is particularly useful when automatically generating clients or\n                SDKs for your API.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = Default(generate_unique_id),\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Add a *path operation* using an HTTP HEAD operation.\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI, Response\n\n        app = FastAPI()\n\n        @app.head(\"/items/\", status_code=204)\n        def get_items_headers(response: Response):\n            response.headers[\"X-Cat-Dog\"] = \"Alone in the world\"\n        ```\n        \"\"\"\n        return self.router.head(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n            generate_unique_id_function=generate_unique_id_function,\n        )",
      "docstring": "Add a *path operation* using an HTTP HEAD operation.\n\n## Example\n\n```python\nfrom fastapi import FastAPI, Response\n\napp = FastAPI()\n\n@app.head(\"/items/\", status_code=204)\ndef get_items_headers(response: Response):\n    response.headers[\"X-Cat-Dog\"] = \"Alone in the world\"\n```",
      "decorators": [],
      "arguments": [
        "self",
        "path"
      ],
      "imports": [
        "enum.Enum",
        "typing.Any",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Type",
        "typing.TypeVar",
        "typing.Union",
        "fastapi.routing",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.exception_handlers.http_exception_handler",
        "fastapi.exception_handlers.request_validation_exception_handler",
        "fastapi.exception_handlers.websocket_request_validation_exception_handler",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.logger.logger",
        "fastapi.openapi.docs.get_redoc_html",
        "fastapi.openapi.docs.get_swagger_ui_html",
        "fastapi.openapi.docs.get_swagger_ui_oauth2_redirect_html",
        "fastapi.openapi.utils.get_openapi",
        "fastapi.params.Depends",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.generate_unique_id",
        "starlette.applications.Starlette",
        "starlette.datastructures.State",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.requests.Request",
        "starlette.responses.HTMLResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "self.router.head",
          "body": "def head(self, path: Annotated[str, Doc('\\n                The URL path to be used for this *path operation*.\\n\\n                For example, in `http://example.com/items`, the path is `/items`.\\n                ')], *, response_model: Annotated[Any, Doc(\"\\n                The type to use for the response.\\n\\n                It could be any valid Pydantic *field* type. So, it doesn't have to\\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\\n                etc.\\n\\n                It will be used for:\\n\\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\\n                    show it as the response (JSON Schema).\\n                * Serialization: you could return an arbitrary object and the\\n                    `response_model` would be used to serialize that object into the\\n                    corresponding JSON.\\n                * Filtering: the JSON sent to the client will only contain the data\\n                    (fields) defined in the `response_model`. If you returned an object\\n                    that contains an attribute `password` but the `response_model` does\\n                    not include that field, the JSON sent to the client would not have\\n                    that `password`.\\n                * Validation: whatever you return will be serialized with the\\n                    `response_model`, converting any data as necessary to generate the\\n                    corresponding JSON. But if the data in the object returned is not\\n                    valid, that would mean a violation of the contract with the client,\\n                    so it's an error from the API developer. So, FastAPI will raise an\\n                    error and return a 500 error code (Internal Server Error).\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\\n                \")]=Default(None), status_code: Annotated[Optional[int], Doc('\\n                The default status code to be used for the response.\\n\\n                You could override the status code by returning a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\\n                ')]=None, tags: Annotated[Optional[List[Union[str, Enum]]], Doc('\\n                A list of tags to be applied to the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\\n                ')]=None, dependencies: Annotated[Optional[Sequence[Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to the\\n                *path operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\\n                ')]=None, summary: Annotated[Optional[str], Doc('\\n                A summary for the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, description: Annotated[Optional[str], Doc('\\n                A description for the *path operation*.\\n\\n                If not provided, it will be extracted automatically from the docstring\\n                of the *path operation function*.\\n\\n                It can contain Markdown.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, response_description: Annotated[str, Doc('\\n                The description for the default response.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]='Successful Response', responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses that could be returned by this *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark this *path operation* as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, operation_id: Annotated[Optional[str], Doc('\\n                Custom operation ID to be used by this *path operation*.\\n\\n                By default, it is generated automatically.\\n\\n                If you provide a custom operation ID, you need to make sure it is\\n                unique for the whole API.\\n\\n                You can customize the\\n                operation ID generation with the parameter\\n                `generate_unique_id_function` in the `FastAPI` class.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=None, response_model_include: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to include only certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_exclude: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to exclude certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_by_alias: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response model\\n                should be serialized by alias when an alias is used.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=True, response_model_exclude_unset: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that were not set and\\n                have their default values. This is different from\\n                `response_model_exclude_defaults` in that if the fields are set,\\n                they will be included in the response, even if the value is the same\\n                as the default.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_defaults: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that have the same value\\n                as the default. This is different from `response_model_exclude_unset`\\n                in that if the fields are set but contain the same default values,\\n                they will be excluded from the response.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_none: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data should\\n                exclude fields set to `None`.\\n\\n                This is much simpler (less smart) than `response_model_exclude_unset`\\n                and `response_model_exclude_defaults`. You probably want to use one of\\n                those two instead of this one, as those allow returning `None` values\\n                when it makes sense.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\\n                ')]=False, include_in_schema: Annotated[bool, Doc('\\n                Include this *path operation* in the generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\\n                ')]=True, response_class: Annotated[Type[Response], Doc('\\n                Response class to be used for this *path operation*.\\n\\n                This will not be used if you return a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\\n                ')]=Default(JSONResponse), name: Annotated[Optional[str], Doc('\\n                Name for this *path operation*. Only used internally.\\n                ')]=None, callbacks: Annotated[Optional[List[BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")]=None, openapi_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n                Extra metadata to be included in the OpenAPI schema for this *path\\n                operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\\n                ')]=None, generate_unique_id_function: Annotated[Callable[[routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=Default(generate_unique_id)) -> Callable[[DecoratedCallable], DecoratedCallable]:\n    \"\"\"\n        Add a *path operation* using an HTTP HEAD operation.\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI, Response\n\n        app = FastAPI()\n\n        @app.head(\"/items/\", status_code=204)\n        def get_items_headers(response: Response):\n            response.headers[\"X-Cat-Dog\"] = \"Alone in the world\"\n        ```\n        \"\"\"\n    return self.router.head(path, response_model=response_model, status_code=status_code, tags=tags, dependencies=dependencies, summary=summary, description=description, response_description=response_description, responses=responses, deprecated=deprecated, operation_id=operation_id, response_model_include=response_model_include, response_model_exclude=response_model_exclude, response_model_by_alias=response_model_by_alias, response_model_exclude_unset=response_model_exclude_unset, response_model_exclude_defaults=response_model_exclude_defaults, response_model_exclude_none=response_model_exclude_none, include_in_schema=include_in_schema, response_class=response_class, name=name, callbacks=callbacks, openapi_extra=openapi_extra, generate_unique_id_function=generate_unique_id_function)"
        }
      ]
    },
    {
      "name": "patch",
      "module": "applications",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\applications.py",
      "line_number": 3708,
      "end_line_number": 4084,
      "source_code": "def patch(\n        self,\n        path: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The URL path to be used for this *path operation*.\n\n                For example, in `http://example.com/items`, the path is `/items`.\n                \"\"\"\n            ),\n        ],\n        *,\n        response_model: Annotated[\n            Any,\n            Doc(\n                \"\"\"\n                The type to use for the response.\n\n                It could be any valid Pydantic *field* type. So, it doesn't have to\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\n                etc.\n\n                It will be used for:\n\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\n                    show it as the response (JSON Schema).\n                * Serialization: you could return an arbitrary object and the\n                    `response_model` would be used to serialize that object into the\n                    corresponding JSON.\n                * Filtering: the JSON sent to the client will only contain the data\n                    (fields) defined in the `response_model`. If you returned an object\n                    that contains an attribute `password` but the `response_model` does\n                    not include that field, the JSON sent to the client would not have\n                    that `password`.\n                * Validation: whatever you return will be serialized with the\n                    `response_model`, converting any data as necessary to generate the\n                    corresponding JSON. But if the data in the object returned is not\n                    valid, that would mean a violation of the contract with the client,\n                    so it's an error from the API developer. So, FastAPI will raise an\n                    error and return a 500 error code (Internal Server Error).\n\n                Read more about it in the\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\n                \"\"\"\n            ),\n        ] = Default(None),\n        status_code: Annotated[\n            Optional[int],\n            Doc(\n                \"\"\"\n                The default status code to be used for the response.\n\n                You could override the status code by returning a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\n                \"\"\"\n            ),\n        ] = None,\n        tags: Annotated[\n            Optional[List[Union[str, Enum]]],\n            Doc(\n                \"\"\"\n                A list of tags to be applied to the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\n                \"\"\"\n            ),\n        ] = None,\n        dependencies: Annotated[\n            Optional[Sequence[Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be applied to the\n                *path operation*.\n\n                Read more about it in the\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\n                \"\"\"\n            ),\n        ] = None,\n        summary: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A summary for the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A description for the *path operation*.\n\n                If not provided, it will be extracted automatically from the docstring\n                of the *path operation function*.\n\n                It can contain Markdown.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        response_description: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The description for the default response.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = \"Successful Response\",\n        responses: Annotated[\n            Optional[Dict[Union[int, str], Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                Additional responses that could be returned by this *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        deprecated: Annotated[\n            Optional[bool],\n            Doc(\n                \"\"\"\n                Mark this *path operation* as deprecated.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        operation_id: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Custom operation ID to be used by this *path operation*.\n\n                By default, it is generated automatically.\n\n                If you provide a custom operation ID, you need to make sure it is\n                unique for the whole API.\n\n                You can customize the\n                operation ID generation with the parameter\n                `generate_unique_id_function` in the `FastAPI` class.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_include: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to include only certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_exclude: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to exclude certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_by_alias: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response model\n                should be serialized by alias when an alias is used.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = True,\n        response_model_exclude_unset: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that were not set and\n                have their default values. This is different from\n                `response_model_exclude_defaults` in that if the fields are set,\n                they will be included in the response, even if the value is the same\n                as the default.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_defaults: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that have the same value\n                as the default. This is different from `response_model_exclude_unset`\n                in that if the fields are set but contain the same default values,\n                they will be excluded from the response.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_none: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data should\n                exclude fields set to `None`.\n\n                This is much simpler (less smart) than `response_model_exclude_unset`\n                and `response_model_exclude_defaults`. You probably want to use one of\n                those two instead of this one, as those allow returning `None` values\n                when it makes sense.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\n                \"\"\"\n            ),\n        ] = False,\n        include_in_schema: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Include this *path operation* in the generated OpenAPI schema.\n\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\n                \"\"\"\n            ),\n        ] = True,\n        response_class: Annotated[\n            Type[Response],\n            Doc(\n                \"\"\"\n                Response class to be used for this *path operation*.\n\n                This will not be used if you return a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\n                \"\"\"\n            ),\n        ] = Default(JSONResponse),\n        name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Name for this *path operation*. Only used internally.\n                \"\"\"\n            ),\n        ] = None,\n        callbacks: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                List of *path operations* that will be used as OpenAPI callbacks.\n\n                This is only for OpenAPI documentation, the callbacks won't be used\n                directly.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\n                \"\"\"\n            ),\n        ] = None,\n        openapi_extra: Annotated[\n            Optional[Dict[str, Any]],\n            Doc(\n                \"\"\"\n                Extra metadata to be included in the OpenAPI schema for this *path\n                operation*.\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\n                \"\"\"\n            ),\n        ] = None,\n        generate_unique_id_function: Annotated[\n            Callable[[routing.APIRoute], str],\n            Doc(\n                \"\"\"\n                Customize the function used to generate unique IDs for the *path\n                operations* shown in the generated OpenAPI.\n\n                This is particularly useful when automatically generating clients or\n                SDKs for your API.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = Default(generate_unique_id),\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Add a *path operation* using an HTTP PATCH operation.\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI\n        from pydantic import BaseModel\n\n        class Item(BaseModel):\n            name: str\n            description: str | None = None\n\n        app = FastAPI()\n\n        @app.patch(\"/items/\")\n        def update_item(item: Item):\n            return {\"message\": \"Item updated in place\"}\n        ```\n        \"\"\"\n        return self.router.patch(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n            generate_unique_id_function=generate_unique_id_function,\n        )",
      "docstring": "Add a *path operation* using an HTTP PATCH operation.\n\n## Example\n\n```python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\nclass Item(BaseModel):\n    name: str\n    description: str | None = None\n\napp = FastAPI()\n\n@app.patch(\"/items/\")\ndef update_item(item: Item):\n    return {\"message\": \"Item updated in place\"}\n```",
      "decorators": [],
      "arguments": [
        "self",
        "path"
      ],
      "imports": [
        "enum.Enum",
        "typing.Any",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Type",
        "typing.TypeVar",
        "typing.Union",
        "fastapi.routing",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.exception_handlers.http_exception_handler",
        "fastapi.exception_handlers.request_validation_exception_handler",
        "fastapi.exception_handlers.websocket_request_validation_exception_handler",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.logger.logger",
        "fastapi.openapi.docs.get_redoc_html",
        "fastapi.openapi.docs.get_swagger_ui_html",
        "fastapi.openapi.docs.get_swagger_ui_oauth2_redirect_html",
        "fastapi.openapi.utils.get_openapi",
        "fastapi.params.Depends",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.generate_unique_id",
        "starlette.applications.Starlette",
        "starlette.datastructures.State",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.requests.Request",
        "starlette.responses.HTMLResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "self.router.patch(path, response_model=response_model, status_code=status_code, tags=tags, dependencies=dependencies, summary=summary, description=description, response_description=response_description, responses=responses, deprecated=deprecated, operation_id=operation_id, response_model_include=response_model_include, response_model_exclude=response_model_exclude, response_model_by_alias=response_model_by_alias, response_model_exclude_unset=response_model_exclude_unset, response_model_exclude_defaults=response_model_exclude_defaults, response_model_exclude_none=response_model_exclude_none, include_in_schema=include_in_schema, response_class=response_class, name=name, callbacks=callbacks, openapi_extra=openapi_extra, generate_unique_id_function=generate_unique_id_function)"
      ],
      "methods_under_test": [
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "self.router.patch",
          "body": "def patch(self, path: Annotated[str, Doc('\\n                The URL path to be used for this *path operation*.\\n\\n                For example, in `http://example.com/items`, the path is `/items`.\\n                ')], *, response_model: Annotated[Any, Doc(\"\\n                The type to use for the response.\\n\\n                It could be any valid Pydantic *field* type. So, it doesn't have to\\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\\n                etc.\\n\\n                It will be used for:\\n\\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\\n                    show it as the response (JSON Schema).\\n                * Serialization: you could return an arbitrary object and the\\n                    `response_model` would be used to serialize that object into the\\n                    corresponding JSON.\\n                * Filtering: the JSON sent to the client will only contain the data\\n                    (fields) defined in the `response_model`. If you returned an object\\n                    that contains an attribute `password` but the `response_model` does\\n                    not include that field, the JSON sent to the client would not have\\n                    that `password`.\\n                * Validation: whatever you return will be serialized with the\\n                    `response_model`, converting any data as necessary to generate the\\n                    corresponding JSON. But if the data in the object returned is not\\n                    valid, that would mean a violation of the contract with the client,\\n                    so it's an error from the API developer. So, FastAPI will raise an\\n                    error and return a 500 error code (Internal Server Error).\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\\n                \")]=Default(None), status_code: Annotated[Optional[int], Doc('\\n                The default status code to be used for the response.\\n\\n                You could override the status code by returning a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\\n                ')]=None, tags: Annotated[Optional[List[Union[str, Enum]]], Doc('\\n                A list of tags to be applied to the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\\n                ')]=None, dependencies: Annotated[Optional[Sequence[Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to the\\n                *path operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\\n                ')]=None, summary: Annotated[Optional[str], Doc('\\n                A summary for the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, description: Annotated[Optional[str], Doc('\\n                A description for the *path operation*.\\n\\n                If not provided, it will be extracted automatically from the docstring\\n                of the *path operation function*.\\n\\n                It can contain Markdown.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, response_description: Annotated[str, Doc('\\n                The description for the default response.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]='Successful Response', responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses that could be returned by this *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark this *path operation* as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, operation_id: Annotated[Optional[str], Doc('\\n                Custom operation ID to be used by this *path operation*.\\n\\n                By default, it is generated automatically.\\n\\n                If you provide a custom operation ID, you need to make sure it is\\n                unique for the whole API.\\n\\n                You can customize the\\n                operation ID generation with the parameter\\n                `generate_unique_id_function` in the `FastAPI` class.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=None, response_model_include: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to include only certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_exclude: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to exclude certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_by_alias: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response model\\n                should be serialized by alias when an alias is used.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=True, response_model_exclude_unset: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that were not set and\\n                have their default values. This is different from\\n                `response_model_exclude_defaults` in that if the fields are set,\\n                they will be included in the response, even if the value is the same\\n                as the default.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_defaults: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that have the same value\\n                as the default. This is different from `response_model_exclude_unset`\\n                in that if the fields are set but contain the same default values,\\n                they will be excluded from the response.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_none: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data should\\n                exclude fields set to `None`.\\n\\n                This is much simpler (less smart) than `response_model_exclude_unset`\\n                and `response_model_exclude_defaults`. You probably want to use one of\\n                those two instead of this one, as those allow returning `None` values\\n                when it makes sense.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\\n                ')]=False, include_in_schema: Annotated[bool, Doc('\\n                Include this *path operation* in the generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\\n                ')]=True, response_class: Annotated[Type[Response], Doc('\\n                Response class to be used for this *path operation*.\\n\\n                This will not be used if you return a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\\n                ')]=Default(JSONResponse), name: Annotated[Optional[str], Doc('\\n                Name for this *path operation*. Only used internally.\\n                ')]=None, callbacks: Annotated[Optional[List[BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")]=None, openapi_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n                Extra metadata to be included in the OpenAPI schema for this *path\\n                operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\\n                ')]=None, generate_unique_id_function: Annotated[Callable[[routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=Default(generate_unique_id)) -> Callable[[DecoratedCallable], DecoratedCallable]:\n    \"\"\"\n        Add a *path operation* using an HTTP PATCH operation.\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI\n        from pydantic import BaseModel\n\n        class Item(BaseModel):\n            name: str\n            description: str | None = None\n\n        app = FastAPI()\n\n        @app.patch(\"/items/\")\n        def update_item(item: Item):\n            return {\"message\": \"Item updated in place\"}\n        ```\n        \"\"\"\n    return self.router.patch(path, response_model=response_model, status_code=status_code, tags=tags, dependencies=dependencies, summary=summary, description=description, response_description=response_description, responses=responses, deprecated=deprecated, operation_id=operation_id, response_model_include=response_model_include, response_model_exclude=response_model_exclude, response_model_by_alias=response_model_by_alias, response_model_exclude_unset=response_model_exclude_unset, response_model_exclude_defaults=response_model_exclude_defaults, response_model_exclude_none=response_model_exclude_none, include_in_schema=include_in_schema, response_class=response_class, name=name, callbacks=callbacks, openapi_extra=openapi_extra, generate_unique_id_function=generate_unique_id_function)"
        }
      ]
    },
    {
      "name": "trace",
      "module": "applications",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\applications.py",
      "line_number": 4086,
      "end_line_number": 4457,
      "source_code": "def trace(\n        self,\n        path: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The URL path to be used for this *path operation*.\n\n                For example, in `http://example.com/items`, the path is `/items`.\n                \"\"\"\n            ),\n        ],\n        *,\n        response_model: Annotated[\n            Any,\n            Doc(\n                \"\"\"\n                The type to use for the response.\n\n                It could be any valid Pydantic *field* type. So, it doesn't have to\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\n                etc.\n\n                It will be used for:\n\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\n                    show it as the response (JSON Schema).\n                * Serialization: you could return an arbitrary object and the\n                    `response_model` would be used to serialize that object into the\n                    corresponding JSON.\n                * Filtering: the JSON sent to the client will only contain the data\n                    (fields) defined in the `response_model`. If you returned an object\n                    that contains an attribute `password` but the `response_model` does\n                    not include that field, the JSON sent to the client would not have\n                    that `password`.\n                * Validation: whatever you return will be serialized with the\n                    `response_model`, converting any data as necessary to generate the\n                    corresponding JSON. But if the data in the object returned is not\n                    valid, that would mean a violation of the contract with the client,\n                    so it's an error from the API developer. So, FastAPI will raise an\n                    error and return a 500 error code (Internal Server Error).\n\n                Read more about it in the\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\n                \"\"\"\n            ),\n        ] = Default(None),\n        status_code: Annotated[\n            Optional[int],\n            Doc(\n                \"\"\"\n                The default status code to be used for the response.\n\n                You could override the status code by returning a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\n                \"\"\"\n            ),\n        ] = None,\n        tags: Annotated[\n            Optional[List[Union[str, Enum]]],\n            Doc(\n                \"\"\"\n                A list of tags to be applied to the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\n                \"\"\"\n            ),\n        ] = None,\n        dependencies: Annotated[\n            Optional[Sequence[Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be applied to the\n                *path operation*.\n\n                Read more about it in the\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\n                \"\"\"\n            ),\n        ] = None,\n        summary: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A summary for the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A description for the *path operation*.\n\n                If not provided, it will be extracted automatically from the docstring\n                of the *path operation function*.\n\n                It can contain Markdown.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        response_description: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The description for the default response.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = \"Successful Response\",\n        responses: Annotated[\n            Optional[Dict[Union[int, str], Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                Additional responses that could be returned by this *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        deprecated: Annotated[\n            Optional[bool],\n            Doc(\n                \"\"\"\n                Mark this *path operation* as deprecated.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        operation_id: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Custom operation ID to be used by this *path operation*.\n\n                By default, it is generated automatically.\n\n                If you provide a custom operation ID, you need to make sure it is\n                unique for the whole API.\n\n                You can customize the\n                operation ID generation with the parameter\n                `generate_unique_id_function` in the `FastAPI` class.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_include: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to include only certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_exclude: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to exclude certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_by_alias: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response model\n                should be serialized by alias when an alias is used.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = True,\n        response_model_exclude_unset: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that were not set and\n                have their default values. This is different from\n                `response_model_exclude_defaults` in that if the fields are set,\n                they will be included in the response, even if the value is the same\n                as the default.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_defaults: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that have the same value\n                as the default. This is different from `response_model_exclude_unset`\n                in that if the fields are set but contain the same default values,\n                they will be excluded from the response.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_none: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data should\n                exclude fields set to `None`.\n\n                This is much simpler (less smart) than `response_model_exclude_unset`\n                and `response_model_exclude_defaults`. You probably want to use one of\n                those two instead of this one, as those allow returning `None` values\n                when it makes sense.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\n                \"\"\"\n            ),\n        ] = False,\n        include_in_schema: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Include this *path operation* in the generated OpenAPI schema.\n\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\n                \"\"\"\n            ),\n        ] = True,\n        response_class: Annotated[\n            Type[Response],\n            Doc(\n                \"\"\"\n                Response class to be used for this *path operation*.\n\n                This will not be used if you return a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\n                \"\"\"\n            ),\n        ] = Default(JSONResponse),\n        name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Name for this *path operation*. Only used internally.\n                \"\"\"\n            ),\n        ] = None,\n        callbacks: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                List of *path operations* that will be used as OpenAPI callbacks.\n\n                This is only for OpenAPI documentation, the callbacks won't be used\n                directly.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\n                \"\"\"\n            ),\n        ] = None,\n        openapi_extra: Annotated[\n            Optional[Dict[str, Any]],\n            Doc(\n                \"\"\"\n                Extra metadata to be included in the OpenAPI schema for this *path\n                operation*.\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\n                \"\"\"\n            ),\n        ] = None,\n        generate_unique_id_function: Annotated[\n            Callable[[routing.APIRoute], str],\n            Doc(\n                \"\"\"\n                Customize the function used to generate unique IDs for the *path\n                operations* shown in the generated OpenAPI.\n\n                This is particularly useful when automatically generating clients or\n                SDKs for your API.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = Default(generate_unique_id),\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Add a *path operation* using an HTTP TRACE operation.\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI\n\n        app = FastAPI()\n\n        @app.put(\"/items/{item_id}\")\n        def trace_item(item_id: str):\n            return None\n        ```\n        \"\"\"\n        return self.router.trace(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n            generate_unique_id_function=generate_unique_id_function,\n        )",
      "docstring": "Add a *path operation* using an HTTP TRACE operation.\n\n## Example\n\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.put(\"/items/{item_id}\")\ndef trace_item(item_id: str):\n    return None\n```",
      "decorators": [],
      "arguments": [
        "self",
        "path"
      ],
      "imports": [
        "enum.Enum",
        "typing.Any",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Type",
        "typing.TypeVar",
        "typing.Union",
        "fastapi.routing",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.exception_handlers.http_exception_handler",
        "fastapi.exception_handlers.request_validation_exception_handler",
        "fastapi.exception_handlers.websocket_request_validation_exception_handler",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.logger.logger",
        "fastapi.openapi.docs.get_redoc_html",
        "fastapi.openapi.docs.get_swagger_ui_html",
        "fastapi.openapi.docs.get_swagger_ui_oauth2_redirect_html",
        "fastapi.openapi.utils.get_openapi",
        "fastapi.params.Depends",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.generate_unique_id",
        "starlette.applications.Starlette",
        "starlette.datastructures.State",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.requests.Request",
        "starlette.responses.HTMLResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "self.router.trace",
          "body": "def trace(self, path: Annotated[str, Doc('\\n                The URL path to be used for this *path operation*.\\n\\n                For example, in `http://example.com/items`, the path is `/items`.\\n                ')], *, response_model: Annotated[Any, Doc(\"\\n                The type to use for the response.\\n\\n                It could be any valid Pydantic *field* type. So, it doesn't have to\\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\\n                etc.\\n\\n                It will be used for:\\n\\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\\n                    show it as the response (JSON Schema).\\n                * Serialization: you could return an arbitrary object and the\\n                    `response_model` would be used to serialize that object into the\\n                    corresponding JSON.\\n                * Filtering: the JSON sent to the client will only contain the data\\n                    (fields) defined in the `response_model`. If you returned an object\\n                    that contains an attribute `password` but the `response_model` does\\n                    not include that field, the JSON sent to the client would not have\\n                    that `password`.\\n                * Validation: whatever you return will be serialized with the\\n                    `response_model`, converting any data as necessary to generate the\\n                    corresponding JSON. But if the data in the object returned is not\\n                    valid, that would mean a violation of the contract with the client,\\n                    so it's an error from the API developer. So, FastAPI will raise an\\n                    error and return a 500 error code (Internal Server Error).\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\\n                \")]=Default(None), status_code: Annotated[Optional[int], Doc('\\n                The default status code to be used for the response.\\n\\n                You could override the status code by returning a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\\n                ')]=None, tags: Annotated[Optional[List[Union[str, Enum]]], Doc('\\n                A list of tags to be applied to the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\\n                ')]=None, dependencies: Annotated[Optional[Sequence[Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to the\\n                *path operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\\n                ')]=None, summary: Annotated[Optional[str], Doc('\\n                A summary for the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, description: Annotated[Optional[str], Doc('\\n                A description for the *path operation*.\\n\\n                If not provided, it will be extracted automatically from the docstring\\n                of the *path operation function*.\\n\\n                It can contain Markdown.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, response_description: Annotated[str, Doc('\\n                The description for the default response.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]='Successful Response', responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses that could be returned by this *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark this *path operation* as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, operation_id: Annotated[Optional[str], Doc('\\n                Custom operation ID to be used by this *path operation*.\\n\\n                By default, it is generated automatically.\\n\\n                If you provide a custom operation ID, you need to make sure it is\\n                unique for the whole API.\\n\\n                You can customize the\\n                operation ID generation with the parameter\\n                `generate_unique_id_function` in the `FastAPI` class.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=None, response_model_include: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to include only certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_exclude: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to exclude certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_by_alias: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response model\\n                should be serialized by alias when an alias is used.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=True, response_model_exclude_unset: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that were not set and\\n                have their default values. This is different from\\n                `response_model_exclude_defaults` in that if the fields are set,\\n                they will be included in the response, even if the value is the same\\n                as the default.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_defaults: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that have the same value\\n                as the default. This is different from `response_model_exclude_unset`\\n                in that if the fields are set but contain the same default values,\\n                they will be excluded from the response.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_none: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data should\\n                exclude fields set to `None`.\\n\\n                This is much simpler (less smart) than `response_model_exclude_unset`\\n                and `response_model_exclude_defaults`. You probably want to use one of\\n                those two instead of this one, as those allow returning `None` values\\n                when it makes sense.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\\n                ')]=False, include_in_schema: Annotated[bool, Doc('\\n                Include this *path operation* in the generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\\n                ')]=True, response_class: Annotated[Type[Response], Doc('\\n                Response class to be used for this *path operation*.\\n\\n                This will not be used if you return a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\\n                ')]=Default(JSONResponse), name: Annotated[Optional[str], Doc('\\n                Name for this *path operation*. Only used internally.\\n                ')]=None, callbacks: Annotated[Optional[List[BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")]=None, openapi_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n                Extra metadata to be included in the OpenAPI schema for this *path\\n                operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\\n                ')]=None, generate_unique_id_function: Annotated[Callable[[routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=Default(generate_unique_id)) -> Callable[[DecoratedCallable], DecoratedCallable]:\n    \"\"\"\n        Add a *path operation* using an HTTP TRACE operation.\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI\n\n        app = FastAPI()\n\n        @app.put(\"/items/{item_id}\")\n        def trace_item(item_id: str):\n            return None\n        ```\n        \"\"\"\n    return self.router.trace(path, response_model=response_model, status_code=status_code, tags=tags, dependencies=dependencies, summary=summary, description=description, response_description=response_description, responses=responses, deprecated=deprecated, operation_id=operation_id, response_model_include=response_model_include, response_model_exclude=response_model_exclude, response_model_by_alias=response_model_by_alias, response_model_exclude_unset=response_model_exclude_unset, response_model_exclude_defaults=response_model_exclude_defaults, response_model_exclude_none=response_model_exclude_none, include_in_schema=include_in_schema, response_class=response_class, name=name, callbacks=callbacks, openapi_extra=openapi_extra, generate_unique_id_function=generate_unique_id_function)"
        }
      ]
    },
    {
      "name": "websocket_route",
      "module": "applications",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\applications.py",
      "line_number": 4459,
      "end_line_number": 4466,
      "source_code": "def websocket_route(\n        self, path: str, name: Union[str, None] = None\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.router.add_websocket_route(path, func, name=name)\n            return func\n\n        return decorator",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "path",
        "name"
      ],
      "imports": [
        "enum.Enum",
        "typing.Any",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Type",
        "typing.TypeVar",
        "typing.Union",
        "fastapi.routing",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.exception_handlers.http_exception_handler",
        "fastapi.exception_handlers.request_validation_exception_handler",
        "fastapi.exception_handlers.websocket_request_validation_exception_handler",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.logger.logger",
        "fastapi.openapi.docs.get_redoc_html",
        "fastapi.openapi.docs.get_swagger_ui_html",
        "fastapi.openapi.docs.get_swagger_ui_oauth2_redirect_html",
        "fastapi.openapi.utils.get_openapi",
        "fastapi.params.Depends",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.generate_unique_id",
        "starlette.applications.Starlette",
        "starlette.datastructures.State",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.requests.Request",
        "starlette.responses.HTMLResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "on_event",
      "module": "applications",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\applications.py",
      "line_number": 4476,
      "end_line_number": 4495,
      "source_code": "def on_event(\n        self,\n        event_type: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The type of event. `startup` or `shutdown`.\n                \"\"\"\n            ),\n        ],\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Add an event handler for the application.\n\n        `on_event` is deprecated, use `lifespan` event handlers instead.\n\n        Read more about it in the\n        [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/#alternative-events-deprecated).\n        \"\"\"\n        return self.router.on_event(event_type)",
      "docstring": "Add an event handler for the application.\n\n`on_event` is deprecated, use `lifespan` event handlers instead.\n\nRead more about it in the\n[FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/#alternative-events-deprecated).",
      "decorators": [
        "deprecated('\\n        on_event is deprecated, use lifespan event handlers instead.\\n\\n        Read more about it in the\\n        [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).\\n        ')"
      ],
      "arguments": [
        "self",
        "event_type"
      ],
      "imports": [
        "enum.Enum",
        "typing.Any",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Type",
        "typing.TypeVar",
        "typing.Union",
        "fastapi.routing",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.exception_handlers.http_exception_handler",
        "fastapi.exception_handlers.request_validation_exception_handler",
        "fastapi.exception_handlers.websocket_request_validation_exception_handler",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.logger.logger",
        "fastapi.openapi.docs.get_redoc_html",
        "fastapi.openapi.docs.get_swagger_ui_html",
        "fastapi.openapi.docs.get_swagger_ui_oauth2_redirect_html",
        "fastapi.openapi.utils.get_openapi",
        "fastapi.params.Depends",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.generate_unique_id",
        "starlette.applications.Starlette",
        "starlette.datastructures.State",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.requests.Request",
        "starlette.responses.HTMLResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.router.on_event",
          "body": "@deprecated('\\n        on_event is deprecated, use lifespan event handlers instead.\\n\\n        Read more about it in the\\n        [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).\\n        ')\ndef on_event(self, event_type: Annotated[str, Doc('\\n                The type of event. `startup` or `shutdown`.\\n                ')]) -> Callable[[DecoratedCallable], DecoratedCallable]:\n    \"\"\"\n        Add an event handler for the application.\n\n        `on_event` is deprecated, use `lifespan` event handlers instead.\n\n        Read more about it in the\n        [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/#alternative-events-deprecated).\n        \"\"\"\n    return self.router.on_event(event_type)"
        }
      ]
    },
    {
      "name": "middleware",
      "module": "applications",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\applications.py",
      "line_number": 4497,
      "end_line_number": 4538,
      "source_code": "def middleware(\n        self,\n        middleware_type: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The type of middleware. Currently only supports `http`.\n                \"\"\"\n            ),\n        ],\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Add a middleware to the application.\n\n        Read more about it in the\n        [FastAPI docs for Middleware](https://fastapi.tiangolo.com/tutorial/middleware/).\n\n        ## Example\n\n        ```python\n        import time\n\n        from fastapi import FastAPI, Request\n\n        app = FastAPI()\n\n\n        @app.middleware(\"http\")\n        async def add_process_time_header(request: Request, call_next):\n            start_time = time.time()\n            response = await call_next(request)\n            process_time = time.time() - start_time\n            response.headers[\"X-Process-Time\"] = str(process_time)\n            return response\n        ```\n        \"\"\"\n\n        def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.add_middleware(BaseHTTPMiddleware, dispatch=func)\n            return func\n\n        return decorator",
      "docstring": "Add a middleware to the application.\n\nRead more about it in the\n[FastAPI docs for Middleware](https://fastapi.tiangolo.com/tutorial/middleware/).\n\n## Example\n\n```python\nimport time\n\nfrom fastapi import FastAPI, Request\n\napp = FastAPI()\n\n\n@app.middleware(\"http\")\nasync def add_process_time_header(request: Request, call_next):\n    start_time = time.time()\n    response = await call_next(request)\n    process_time = time.time() - start_time\n    response.headers[\"X-Process-Time\"] = str(process_time)\n    return response\n```",
      "decorators": [],
      "arguments": [
        "self",
        "middleware_type"
      ],
      "imports": [
        "enum.Enum",
        "typing.Any",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Type",
        "typing.TypeVar",
        "typing.Union",
        "fastapi.routing",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.exception_handlers.http_exception_handler",
        "fastapi.exception_handlers.request_validation_exception_handler",
        "fastapi.exception_handlers.websocket_request_validation_exception_handler",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.logger.logger",
        "fastapi.openapi.docs.get_redoc_html",
        "fastapi.openapi.docs.get_swagger_ui_html",
        "fastapi.openapi.docs.get_swagger_ui_oauth2_redirect_html",
        "fastapi.openapi.utils.get_openapi",
        "fastapi.params.Depends",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.generate_unique_id",
        "starlette.applications.Starlette",
        "starlette.datastructures.State",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.requests.Request",
        "starlette.responses.HTMLResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "exception_handler",
      "module": "applications",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\applications.py",
      "line_number": 4540,
      "end_line_number": 4585,
      "source_code": "def exception_handler(\n        self,\n        exc_class_or_status_code: Annotated[\n            Union[int, Type[Exception]],\n            Doc(\n                \"\"\"\n                The Exception class this would handle, or a status code.\n                \"\"\"\n            ),\n        ],\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Add an exception handler to the app.\n\n        Read more about it in the\n        [FastAPI docs for Handling Errors](https://fastapi.tiangolo.com/tutorial/handling-errors/).\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI, Request\n        from fastapi.responses import JSONResponse\n\n\n        class UnicornException(Exception):\n            def __init__(self, name: str):\n                self.name = name\n\n\n        app = FastAPI()\n\n\n        @app.exception_handler(UnicornException)\n        async def unicorn_exception_handler(request: Request, exc: UnicornException):\n            return JSONResponse(\n                status_code=418,\n                content={\"message\": f\"Oops! {exc.name} did something. There goes a rainbow...\"},\n            )\n        ```\n        \"\"\"\n\n        def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.add_exception_handler(exc_class_or_status_code, func)\n            return func\n\n        return decorator",
      "docstring": "Add an exception handler to the app.\n\nRead more about it in the\n[FastAPI docs for Handling Errors](https://fastapi.tiangolo.com/tutorial/handling-errors/).\n\n## Example\n\n```python\nfrom fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\n\n\nclass UnicornException(Exception):\n    def __init__(self, name: str):\n        self.name = name\n\n\napp = FastAPI()\n\n\n@app.exception_handler(UnicornException)\nasync def unicorn_exception_handler(request: Request, exc: UnicornException):\n    return JSONResponse(\n        status_code=418,\n        content={\"message\": f\"Oops! {exc.name} did something. There goes a rainbow...\"},\n    )\n```",
      "decorators": [],
      "arguments": [
        "self",
        "exc_class_or_status_code"
      ],
      "imports": [
        "enum.Enum",
        "typing.Any",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Type",
        "typing.TypeVar",
        "typing.Union",
        "fastapi.routing",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.exception_handlers.http_exception_handler",
        "fastapi.exception_handlers.request_validation_exception_handler",
        "fastapi.exception_handlers.websocket_request_validation_exception_handler",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.logger.logger",
        "fastapi.openapi.docs.get_redoc_html",
        "fastapi.openapi.docs.get_swagger_ui_html",
        "fastapi.openapi.docs.get_swagger_ui_oauth2_redirect_html",
        "fastapi.openapi.utils.get_openapi",
        "fastapi.params.Depends",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.generate_unique_id",
        "starlette.applications.Starlette",
        "starlette.datastructures.State",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.requests.Request",
        "starlette.responses.HTMLResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "decorator",
      "module": "applications",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\applications.py",
      "line_number": 1144,
      "end_line_number": 1171,
      "source_code": "def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.router.add_api_route(\n                path,\n                func,\n                response_model=response_model,\n                status_code=status_code,\n                tags=tags,\n                dependencies=dependencies,\n                summary=summary,\n                description=description,\n                response_description=response_description,\n                responses=responses,\n                deprecated=deprecated,\n                methods=methods,\n                operation_id=operation_id,\n                response_model_include=response_model_include,\n                response_model_exclude=response_model_exclude,\n                response_model_by_alias=response_model_by_alias,\n                response_model_exclude_unset=response_model_exclude_unset,\n                response_model_exclude_defaults=response_model_exclude_defaults,\n                response_model_exclude_none=response_model_exclude_none,\n                include_in_schema=include_in_schema,\n                response_class=response_class,\n                name=name,\n                openapi_extra=openapi_extra,\n                generate_unique_id_function=generate_unique_id_function,\n            )\n            return func",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "func"
      ],
      "imports": [
        "enum.Enum",
        "typing.Any",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Type",
        "typing.TypeVar",
        "typing.Union",
        "fastapi.routing",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.exception_handlers.http_exception_handler",
        "fastapi.exception_handlers.request_validation_exception_handler",
        "fastapi.exception_handlers.websocket_request_validation_exception_handler",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.logger.logger",
        "fastapi.openapi.docs.get_redoc_html",
        "fastapi.openapi.docs.get_swagger_ui_html",
        "fastapi.openapi.docs.get_swagger_ui_oauth2_redirect_html",
        "fastapi.openapi.utils.get_openapi",
        "fastapi.params.Depends",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.generate_unique_id",
        "starlette.applications.Starlette",
        "starlette.datastructures.State",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.requests.Request",
        "starlette.responses.HTMLResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.router.add_api_route",
          "body": "def add_api_route(self, path: str, endpoint: Callable[..., Any], *, response_model: Any=Default(None), status_code: Optional[int]=None, tags: Optional[List[Union[str, Enum]]]=None, dependencies: Optional[Sequence[Depends]]=None, summary: Optional[str]=None, description: Optional[str]=None, response_description: str='Successful Response', responses: Optional[Dict[Union[int, str], Dict[str, Any]]]=None, deprecated: Optional[bool]=None, methods: Optional[List[str]]=None, operation_id: Optional[str]=None, response_model_include: Optional[IncEx]=None, response_model_exclude: Optional[IncEx]=None, response_model_by_alias: bool=True, response_model_exclude_unset: bool=False, response_model_exclude_defaults: bool=False, response_model_exclude_none: bool=False, include_in_schema: bool=True, response_class: Union[Type[Response], DefaultPlaceholder]=Default(JSONResponse), name: Optional[str]=None, openapi_extra: Optional[Dict[str, Any]]=None, generate_unique_id_function: Callable[[routing.APIRoute], str]=Default(generate_unique_id)) -> None:\n    self.router.add_api_route(path, endpoint=endpoint, response_model=response_model, status_code=status_code, tags=tags, dependencies=dependencies, summary=summary, description=description, response_description=response_description, responses=responses, deprecated=deprecated, methods=methods, operation_id=operation_id, response_model_include=response_model_include, response_model_exclude=response_model_exclude, response_model_by_alias=response_model_by_alias, response_model_exclude_unset=response_model_exclude_unset, response_model_exclude_defaults=response_model_exclude_defaults, response_model_exclude_none=response_model_exclude_none, include_in_schema=include_in_schema, response_class=response_class, name=name, openapi_extra=openapi_extra, generate_unique_id_function=generate_unique_id_function)"
        }
      ]
    },
    {
      "name": "decorator",
      "module": "applications",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\applications.py",
      "line_number": 1244,
      "end_line_number": 1251,
      "source_code": "def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.add_api_websocket_route(\n                path,\n                func,\n                name=name,\n                dependencies=dependencies,\n            )\n            return func",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "func"
      ],
      "imports": [
        "enum.Enum",
        "typing.Any",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Type",
        "typing.TypeVar",
        "typing.Union",
        "fastapi.routing",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.exception_handlers.http_exception_handler",
        "fastapi.exception_handlers.request_validation_exception_handler",
        "fastapi.exception_handlers.websocket_request_validation_exception_handler",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.logger.logger",
        "fastapi.openapi.docs.get_redoc_html",
        "fastapi.openapi.docs.get_swagger_ui_html",
        "fastapi.openapi.docs.get_swagger_ui_oauth2_redirect_html",
        "fastapi.openapi.utils.get_openapi",
        "fastapi.params.Depends",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.generate_unique_id",
        "starlette.applications.Starlette",
        "starlette.datastructures.State",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.requests.Request",
        "starlette.responses.HTMLResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.add_api_websocket_route",
          "body": "def add_api_websocket_route(self, path: str, endpoint: Callable[..., Any], name: Optional[str]=None, *, dependencies: Optional[Sequence[Depends]]=None) -> None:\n    self.router.add_api_websocket_route(path, endpoint, name=name, dependencies=dependencies)"
        }
      ]
    },
    {
      "name": "decorator",
      "module": "applications",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\applications.py",
      "line_number": 4462,
      "end_line_number": 4464,
      "source_code": "def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.router.add_websocket_route(path, func, name=name)\n            return func",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "func"
      ],
      "imports": [
        "enum.Enum",
        "typing.Any",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Type",
        "typing.TypeVar",
        "typing.Union",
        "fastapi.routing",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.exception_handlers.http_exception_handler",
        "fastapi.exception_handlers.request_validation_exception_handler",
        "fastapi.exception_handlers.websocket_request_validation_exception_handler",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.logger.logger",
        "fastapi.openapi.docs.get_redoc_html",
        "fastapi.openapi.docs.get_swagger_ui_html",
        "fastapi.openapi.docs.get_swagger_ui_oauth2_redirect_html",
        "fastapi.openapi.utils.get_openapi",
        "fastapi.params.Depends",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.generate_unique_id",
        "starlette.applications.Starlette",
        "starlette.datastructures.State",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.requests.Request",
        "starlette.responses.HTMLResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "decorator",
      "module": "applications",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\applications.py",
      "line_number": 4534,
      "end_line_number": 4536,
      "source_code": "def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.add_middleware(BaseHTTPMiddleware, dispatch=func)\n            return func",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "func"
      ],
      "imports": [
        "enum.Enum",
        "typing.Any",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Type",
        "typing.TypeVar",
        "typing.Union",
        "fastapi.routing",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.exception_handlers.http_exception_handler",
        "fastapi.exception_handlers.request_validation_exception_handler",
        "fastapi.exception_handlers.websocket_request_validation_exception_handler",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.logger.logger",
        "fastapi.openapi.docs.get_redoc_html",
        "fastapi.openapi.docs.get_swagger_ui_html",
        "fastapi.openapi.docs.get_swagger_ui_oauth2_redirect_html",
        "fastapi.openapi.utils.get_openapi",
        "fastapi.params.Depends",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.generate_unique_id",
        "starlette.applications.Starlette",
        "starlette.datastructures.State",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.requests.Request",
        "starlette.responses.HTMLResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "decorator",
      "module": "applications",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\applications.py",
      "line_number": 4581,
      "end_line_number": 4583,
      "source_code": "def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.add_exception_handler(exc_class_or_status_code, func)\n            return func",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "func"
      ],
      "imports": [
        "enum.Enum",
        "typing.Any",
        "typing.Awaitable",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Type",
        "typing.TypeVar",
        "typing.Union",
        "fastapi.routing",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.exception_handlers.http_exception_handler",
        "fastapi.exception_handlers.request_validation_exception_handler",
        "fastapi.exception_handlers.websocket_request_validation_exception_handler",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.logger.logger",
        "fastapi.openapi.docs.get_redoc_html",
        "fastapi.openapi.docs.get_swagger_ui_html",
        "fastapi.openapi.docs.get_swagger_ui_oauth2_redirect_html",
        "fastapi.openapi.utils.get_openapi",
        "fastapi.params.Depends",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.generate_unique_id",
        "starlette.applications.Starlette",
        "starlette.datastructures.State",
        "starlette.exceptions.HTTPException",
        "starlette.middleware.Middleware",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.requests.Request",
        "starlette.responses.HTMLResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Receive",
        "starlette.types.Scope",
        "starlette.types.Send",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "add_task",
      "module": "background",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\background.py",
      "line_number": 38,
      "end_line_number": 59,
      "source_code": "def add_task(\n        self,\n        func: Annotated[\n            Callable[P, Any],\n            Doc(\n                \"\"\"\n                The function to call after the response is sent.\n\n                It can be a regular `def` function or an `async def` function.\n                \"\"\"\n            ),\n        ],\n        *args: P.args,\n        **kwargs: P.kwargs,\n    ) -> None:\n        \"\"\"\n        Add a function to be called in the background after the response is sent.\n\n        Read more about it in the\n        [FastAPI docs for Background Tasks](https://fastapi.tiangolo.com/tutorial/background-tasks/).\n        \"\"\"\n        return super().add_task(func, *args, **kwargs)",
      "docstring": "Add a function to be called in the background after the response is sent.\n\nRead more about it in the\n[FastAPI docs for Background Tasks](https://fastapi.tiangolo.com/tutorial/background-tasks/).",
      "decorators": [],
      "arguments": [
        "self",
        "func"
      ],
      "imports": [
        "typing.Any",
        "typing.Callable",
        "starlette.background.BackgroundTasks",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.ParamSpec"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "main",
      "module": "cli",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\cli.py",
      "line_number": 8,
      "end_line_number": 13,
      "source_code": "def main() -> None:\n    if not cli_main:  # type: ignore[truthy-function]\n        message = 'To use the fastapi command, please install \"fastapi[standard]\":\\n\\n\\tpip install \"fastapi[standard]\"\\n'\n        print(message)\n        raise RuntimeError(message)  # noqa: B904\n    cli_main()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "fastapi_cli.cli.main"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "Default",
      "module": "datastructures",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\datastructures.py",
      "line_number": 197,
      "end_line_number": 204,
      "source_code": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)",
      "docstring": "You shouldn't use this function directly.\n\nIt's used internally to recognize when a default value has been overwritten, even\nif the overridden default value was truthy.",
      "decorators": [],
      "arguments": [
        "value"
      ],
      "imports": [
        "typing.Any",
        "typing.BinaryIO",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterable",
        "typing.Optional",
        "typing.Type",
        "typing.TypeVar",
        "typing.cast",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.CoreSchema",
        "fastapi._compat.GetJsonSchemaHandler",
        "fastapi._compat.JsonSchemaValue",
        "fastapi._compat.with_info_plain_validator_function",
        "starlette.datastructures.URL",
        "starlette.datastructures.Address",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.State",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Doc"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__get_validators__",
      "module": "datastructures",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\datastructures.py",
      "line_number": 142,
      "end_line_number": 143,
      "source_code": "def __get_validators__(cls: Type[\"UploadFile\"]) -> Iterable[Callable[..., Any]]:\n        yield cls.validate",
      "docstring": null,
      "decorators": [
        "classmethod"
      ],
      "arguments": [
        "cls"
      ],
      "imports": [
        "typing.Any",
        "typing.BinaryIO",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterable",
        "typing.Optional",
        "typing.Type",
        "typing.TypeVar",
        "typing.cast",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.CoreSchema",
        "fastapi._compat.GetJsonSchemaHandler",
        "fastapi._compat.JsonSchemaValue",
        "fastapi._compat.with_info_plain_validator_function",
        "starlette.datastructures.URL",
        "starlette.datastructures.Address",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.State",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Doc"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "validate",
      "module": "datastructures",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\datastructures.py",
      "line_number": 146,
      "end_line_number": 149,
      "source_code": "def validate(cls: Type[\"UploadFile\"], v: Any) -> Any:\n        if not isinstance(v, StarletteUploadFile):\n            raise ValueError(f\"Expected UploadFile, received: {type(v)}\")\n        return v",
      "docstring": null,
      "decorators": [
        "classmethod"
      ],
      "arguments": [
        "cls",
        "v"
      ],
      "imports": [
        "typing.Any",
        "typing.BinaryIO",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterable",
        "typing.Optional",
        "typing.Type",
        "typing.TypeVar",
        "typing.cast",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.CoreSchema",
        "fastapi._compat.GetJsonSchemaHandler",
        "fastapi._compat.JsonSchemaValue",
        "fastapi._compat.with_info_plain_validator_function",
        "starlette.datastructures.URL",
        "starlette.datastructures.Address",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.State",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Doc"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_validate",
      "module": "datastructures",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\datastructures.py",
      "line_number": 152,
      "end_line_number": 155,
      "source_code": "def _validate(cls, __input_value: Any, _: Any) -> \"UploadFile\":\n        if not isinstance(__input_value, StarletteUploadFile):\n            raise ValueError(f\"Expected UploadFile, received: {type(__input_value)}\")\n        return cast(UploadFile, __input_value)",
      "docstring": null,
      "decorators": [
        "classmethod"
      ],
      "arguments": [
        "cls",
        "__input_value",
        "_"
      ],
      "imports": [
        "typing.Any",
        "typing.BinaryIO",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterable",
        "typing.Optional",
        "typing.Type",
        "typing.TypeVar",
        "typing.cast",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.CoreSchema",
        "fastapi._compat.GetJsonSchemaHandler",
        "fastapi._compat.JsonSchemaValue",
        "fastapi._compat.with_info_plain_validator_function",
        "starlette.datastructures.URL",
        "starlette.datastructures.Address",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.State",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Doc"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__get_pydantic_json_schema__",
      "module": "datastructures",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\datastructures.py",
      "line_number": 164,
      "end_line_number": 167,
      "source_code": "def __get_pydantic_json_schema__(\n        cls, core_schema: CoreSchema, handler: GetJsonSchemaHandler\n    ) -> JsonSchemaValue:\n        return {\"type\": \"string\", \"format\": \"binary\"}",
      "docstring": null,
      "decorators": [
        "classmethod"
      ],
      "arguments": [
        "cls",
        "core_schema",
        "handler"
      ],
      "imports": [
        "typing.Any",
        "typing.BinaryIO",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterable",
        "typing.Optional",
        "typing.Type",
        "typing.TypeVar",
        "typing.cast",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.CoreSchema",
        "fastapi._compat.GetJsonSchemaHandler",
        "fastapi._compat.JsonSchemaValue",
        "fastapi._compat.with_info_plain_validator_function",
        "starlette.datastructures.URL",
        "starlette.datastructures.Address",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.State",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Doc"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__get_pydantic_core_schema__",
      "module": "datastructures",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\datastructures.py",
      "line_number": 170,
      "end_line_number": 173,
      "source_code": "def __get_pydantic_core_schema__(\n        cls, source: Type[Any], handler: Callable[[Any], CoreSchema]\n    ) -> CoreSchema:\n        return with_info_plain_validator_function(cls._validate)",
      "docstring": null,
      "decorators": [
        "classmethod"
      ],
      "arguments": [
        "cls",
        "source",
        "handler"
      ],
      "imports": [
        "typing.Any",
        "typing.BinaryIO",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterable",
        "typing.Optional",
        "typing.Type",
        "typing.TypeVar",
        "typing.cast",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.CoreSchema",
        "fastapi._compat.GetJsonSchemaHandler",
        "fastapi._compat.JsonSchemaValue",
        "fastapi._compat.with_info_plain_validator_function",
        "starlette.datastructures.URL",
        "starlette.datastructures.Address",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.State",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Doc"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "with_info_plain_validator_function",
          "body": "def with_info_plain_validator_function(function: Callable[..., Any], *, ref: Union[str, None]=None, metadata: Any=None, serialization: Any=None) -> Any:\n    return {}"
        }
      ]
    },
    {
      "name": "__init__",
      "module": "datastructures",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\datastructures.py",
      "line_number": 184,
      "end_line_number": 185,
      "source_code": "def __init__(self, value: Any):\n        self.value = value",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "value"
      ],
      "imports": [
        "typing.Any",
        "typing.BinaryIO",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterable",
        "typing.Optional",
        "typing.Type",
        "typing.TypeVar",
        "typing.cast",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.CoreSchema",
        "fastapi._compat.GetJsonSchemaHandler",
        "fastapi._compat.JsonSchemaValue",
        "fastapi._compat.with_info_plain_validator_function",
        "starlette.datastructures.URL",
        "starlette.datastructures.Address",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.State",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Doc"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__bool__",
      "module": "datastructures",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\datastructures.py",
      "line_number": 187,
      "end_line_number": 188,
      "source_code": "def __bool__(self) -> bool:\n        return bool(self.value)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "typing.Any",
        "typing.BinaryIO",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterable",
        "typing.Optional",
        "typing.Type",
        "typing.TypeVar",
        "typing.cast",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.CoreSchema",
        "fastapi._compat.GetJsonSchemaHandler",
        "fastapi._compat.JsonSchemaValue",
        "fastapi._compat.with_info_plain_validator_function",
        "starlette.datastructures.URL",
        "starlette.datastructures.Address",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.State",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Doc"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__eq__",
      "module": "datastructures",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\datastructures.py",
      "line_number": 190,
      "end_line_number": 191,
      "source_code": "def __eq__(self, o: object) -> bool:\n        return isinstance(o, DefaultPlaceholder) and o.value == self.value",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "o"
      ],
      "imports": [
        "typing.Any",
        "typing.BinaryIO",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterable",
        "typing.Optional",
        "typing.Type",
        "typing.TypeVar",
        "typing.cast",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.CoreSchema",
        "fastapi._compat.GetJsonSchemaHandler",
        "fastapi._compat.JsonSchemaValue",
        "fastapi._compat.with_info_plain_validator_function",
        "starlette.datastructures.URL",
        "starlette.datastructures.Address",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.State",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Doc"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__modify_schema__",
      "module": "datastructures",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\datastructures.py",
      "line_number": 160,
      "end_line_number": 161,
      "source_code": "def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:\n            field_schema.update({\"type\": \"string\", \"format\": \"binary\"})",
      "docstring": null,
      "decorators": [
        "classmethod"
      ],
      "arguments": [
        "cls",
        "field_schema"
      ],
      "imports": [
        "typing.Any",
        "typing.BinaryIO",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterable",
        "typing.Optional",
        "typing.Type",
        "typing.TypeVar",
        "typing.cast",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.CoreSchema",
        "fastapi._compat.GetJsonSchemaHandler",
        "fastapi._compat.JsonSchemaValue",
        "fastapi._compat.with_info_plain_validator_function",
        "starlette.datastructures.URL",
        "starlette.datastructures.Address",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.State",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Doc"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "isoformat",
      "module": "encoders",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\encoders.py",
      "line_number": 31,
      "end_line_number": 32,
      "source_code": "def isoformat(o: Union[datetime.date, datetime.time]) -> str:\n    return o.isoformat()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "o"
      ],
      "imports": [
        "dataclasses",
        "datetime",
        "collections.defaultdict",
        "collections.deque",
        "decimal.Decimal",
        "enum.Enum",
        "ipaddress.IPv4Address",
        "ipaddress.IPv4Interface",
        "ipaddress.IPv4Network",
        "ipaddress.IPv6Address",
        "ipaddress.IPv6Interface",
        "ipaddress.IPv6Network",
        "pathlib.Path",
        "pathlib.PurePath",
        "re.Pattern",
        "types.GeneratorType",
        "typing.Any",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "uuid.UUID",
        "fastapi.types.IncEx",
        "pydantic.BaseModel",
        "pydantic.color.Color",
        "pydantic.networks.AnyUrl",
        "pydantic.networks.NameEmail",
        "pydantic.types.SecretBytes",
        "pydantic.types.SecretStr",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "_compat.PYDANTIC_V2",
        "_compat.UndefinedType",
        "_compat.Url",
        "_compat._model_dump"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "o.isoformat",
          "body": "def isoformat(o: Union[datetime.date, datetime.time]) -> str:\n    return o.isoformat()"
        }
      ]
    },
    {
      "name": "decimal_encoder",
      "module": "encoders",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\encoders.py",
      "line_number": 37,
      "end_line_number": 55,
      "source_code": "def decimal_encoder(dec_value: Decimal) -> Union[int, float]:\n    \"\"\"\n    Encodes a Decimal as int of there's no exponent, otherwise float\n\n    This is useful when we use ConstrainedDecimal to represent Numeric(x,0)\n    where a integer (but not int typed) is used. Encoding this as a float\n    results in failed round-tripping between encode and parse.\n    Our Id type is a prime example of this.\n\n    >>> decimal_encoder(Decimal(\"1.0\"))\n    1.0\n\n    >>> decimal_encoder(Decimal(\"1\"))\n    1\n    \"\"\"\n    if dec_value.as_tuple().exponent >= 0:  # type: ignore[operator]\n        return int(dec_value)\n    else:\n        return float(dec_value)",
      "docstring": "Encodes a Decimal as int of there's no exponent, otherwise float\n\nThis is useful when we use ConstrainedDecimal to represent Numeric(x,0)\nwhere a integer (but not int typed) is used. Encoding this as a float\nresults in failed round-tripping between encode and parse.\nOur Id type is a prime example of this.\n\n>>> decimal_encoder(Decimal(\"1.0\"))\n1.0\n\n>>> decimal_encoder(Decimal(\"1\"))\n1",
      "decorators": [],
      "arguments": [
        "dec_value"
      ],
      "imports": [
        "dataclasses",
        "datetime",
        "collections.defaultdict",
        "collections.deque",
        "decimal.Decimal",
        "enum.Enum",
        "ipaddress.IPv4Address",
        "ipaddress.IPv4Interface",
        "ipaddress.IPv4Network",
        "ipaddress.IPv6Address",
        "ipaddress.IPv6Interface",
        "ipaddress.IPv6Network",
        "pathlib.Path",
        "pathlib.PurePath",
        "re.Pattern",
        "types.GeneratorType",
        "typing.Any",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "uuid.UUID",
        "fastapi.types.IncEx",
        "pydantic.BaseModel",
        "pydantic.color.Color",
        "pydantic.networks.AnyUrl",
        "pydantic.networks.NameEmail",
        "pydantic.types.SecretBytes",
        "pydantic.types.SecretStr",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "_compat.PYDANTIC_V2",
        "_compat.UndefinedType",
        "_compat.Url",
        "_compat._model_dump"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "generate_encoders_by_class_tuples",
      "module": "encoders",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\encoders.py",
      "line_number": 88,
      "end_line_number": 96,
      "source_code": "def generate_encoders_by_class_tuples(\n    type_encoder_map: Dict[Any, Callable[[Any], Any]],\n) -> Dict[Callable[[Any], Any], Tuple[Any, ...]]:\n    encoders_by_class_tuples: Dict[Callable[[Any], Any], Tuple[Any, ...]] = defaultdict(\n        tuple\n    )\n    for type_, encoder in type_encoder_map.items():\n        encoders_by_class_tuples[encoder] += (type_,)\n    return encoders_by_class_tuples",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "type_encoder_map"
      ],
      "imports": [
        "dataclasses",
        "datetime",
        "collections.defaultdict",
        "collections.deque",
        "decimal.Decimal",
        "enum.Enum",
        "ipaddress.IPv4Address",
        "ipaddress.IPv4Interface",
        "ipaddress.IPv4Network",
        "ipaddress.IPv6Address",
        "ipaddress.IPv6Interface",
        "ipaddress.IPv6Network",
        "pathlib.Path",
        "pathlib.PurePath",
        "re.Pattern",
        "types.GeneratorType",
        "typing.Any",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "uuid.UUID",
        "fastapi.types.IncEx",
        "pydantic.BaseModel",
        "pydantic.color.Color",
        "pydantic.networks.AnyUrl",
        "pydantic.networks.NameEmail",
        "pydantic.types.SecretBytes",
        "pydantic.types.SecretStr",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "_compat.PYDANTIC_V2",
        "_compat.UndefinedType",
        "_compat.Url",
        "_compat._model_dump"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "jsonable_encoder",
      "module": "encoders",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\encoders.py",
      "line_number": 102,
      "end_line_number": 343,
      "source_code": "def jsonable_encoder(\n    obj: Annotated[\n        Any,\n        Doc(\n            \"\"\"\n            The input object to convert to JSON.\n            \"\"\"\n        ),\n    ],\n    include: Annotated[\n        Optional[IncEx],\n        Doc(\n            \"\"\"\n            Pydantic's `include` parameter, passed to Pydantic models to set the\n            fields to include.\n            \"\"\"\n        ),\n    ] = None,\n    exclude: Annotated[\n        Optional[IncEx],\n        Doc(\n            \"\"\"\n            Pydantic's `exclude` parameter, passed to Pydantic models to set the\n            fields to exclude.\n            \"\"\"\n        ),\n    ] = None,\n    by_alias: Annotated[\n        bool,\n        Doc(\n            \"\"\"\n            Pydantic's `by_alias` parameter, passed to Pydantic models to define if\n            the output should use the alias names (when provided) or the Python\n            attribute names. In an API, if you set an alias, it's probably because you\n            want to use it in the result, so you probably want to leave this set to\n            `True`.\n            \"\"\"\n        ),\n    ] = True,\n    exclude_unset: Annotated[\n        bool,\n        Doc(\n            \"\"\"\n            Pydantic's `exclude_unset` parameter, passed to Pydantic models to define\n            if it should exclude from the output the fields that were not explicitly\n            set (and that only had their default values).\n            \"\"\"\n        ),\n    ] = False,\n    exclude_defaults: Annotated[\n        bool,\n        Doc(\n            \"\"\"\n            Pydantic's `exclude_defaults` parameter, passed to Pydantic models to define\n            if it should exclude from the output the fields that had the same default\n            value, even when they were explicitly set.\n            \"\"\"\n        ),\n    ] = False,\n    exclude_none: Annotated[\n        bool,\n        Doc(\n            \"\"\"\n            Pydantic's `exclude_none` parameter, passed to Pydantic models to define\n            if it should exclude from the output any fields that have a `None` value.\n            \"\"\"\n        ),\n    ] = False,\n    custom_encoder: Annotated[\n        Optional[Dict[Any, Callable[[Any], Any]]],\n        Doc(\n            \"\"\"\n            Pydantic's `custom_encoder` parameter, passed to Pydantic models to define\n            a custom encoder.\n            \"\"\"\n        ),\n    ] = None,\n    sqlalchemy_safe: Annotated[\n        bool,\n        Doc(\n            \"\"\"\n            Exclude from the output any fields that start with the name `_sa`.\n\n            This is mainly a hack for compatibility with SQLAlchemy objects, they\n            store internal SQLAlchemy-specific state in attributes named with `_sa`,\n            and those objects can't (and shouldn't be) serialized to JSON.\n            \"\"\"\n        ),\n    ] = True,\n) -> Any:\n    \"\"\"\n    Convert any object to something that can be encoded in JSON.\n\n    This is used internally by FastAPI to make sure anything you return can be\n    encoded as JSON before it is sent to the client.\n\n    You can also use it yourself, for example to convert objects before saving them\n    in a database that supports only JSON.\n\n    Read more about it in the\n    [FastAPI docs for JSON Compatible Encoder](https://fastapi.tiangolo.com/tutorial/encoder/).\n    \"\"\"\n    custom_encoder = custom_encoder or {}\n    if custom_encoder:\n        if type(obj) in custom_encoder:\n            return custom_encoder[type(obj)](obj)\n        else:\n            for encoder_type, encoder_instance in custom_encoder.items():\n                if isinstance(obj, encoder_type):\n                    return encoder_instance(obj)\n    if include is not None and not isinstance(include, (set, dict)):\n        include = set(include)\n    if exclude is not None and not isinstance(exclude, (set, dict)):\n        exclude = set(exclude)\n    if isinstance(obj, BaseModel):\n        # TODO: remove when deprecating Pydantic v1\n        encoders: Dict[Any, Any] = {}\n        if not PYDANTIC_V2:\n            encoders = getattr(obj.__config__, \"json_encoders\", {})  # type: ignore[attr-defined]\n            if custom_encoder:\n                encoders.update(custom_encoder)\n        obj_dict = _model_dump(\n            obj,\n            mode=\"json\",\n            include=include,\n            exclude=exclude,\n            by_alias=by_alias,\n            exclude_unset=exclude_unset,\n            exclude_none=exclude_none,\n            exclude_defaults=exclude_defaults,\n        )\n        if \"__root__\" in obj_dict:\n            obj_dict = obj_dict[\"__root__\"]\n        return jsonable_encoder(\n            obj_dict,\n            exclude_none=exclude_none,\n            exclude_defaults=exclude_defaults,\n            # TODO: remove when deprecating Pydantic v1\n            custom_encoder=encoders,\n            sqlalchemy_safe=sqlalchemy_safe,\n        )\n    if dataclasses.is_dataclass(obj):\n        obj_dict = dataclasses.asdict(obj)\n        return jsonable_encoder(\n            obj_dict,\n            include=include,\n            exclude=exclude,\n            by_alias=by_alias,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n            custom_encoder=custom_encoder,\n            sqlalchemy_safe=sqlalchemy_safe,\n        )\n    if isinstance(obj, Enum):\n        return obj.value\n    if isinstance(obj, PurePath):\n        return str(obj)\n    if isinstance(obj, (str, int, float, type(None))):\n        return obj\n    if isinstance(obj, UndefinedType):\n        return None\n    if isinstance(obj, dict):\n        encoded_dict = {}\n        allowed_keys = set(obj.keys())\n        if include is not None:\n            allowed_keys &= set(include)\n        if exclude is not None:\n            allowed_keys -= set(exclude)\n        for key, value in obj.items():\n            if (\n                (\n                    not sqlalchemy_safe\n                    or (not isinstance(key, str))\n                    or (not key.startswith(\"_sa\"))\n                )\n                and (value is not None or not exclude_none)\n                and key in allowed_keys\n            ):\n                encoded_key = jsonable_encoder(\n                    key,\n                    by_alias=by_alias,\n                    exclude_unset=exclude_unset,\n                    exclude_none=exclude_none,\n                    custom_encoder=custom_encoder,\n                    sqlalchemy_safe=sqlalchemy_safe,\n                )\n                encoded_value = jsonable_encoder(\n                    value,\n                    by_alias=by_alias,\n                    exclude_unset=exclude_unset,\n                    exclude_none=exclude_none,\n                    custom_encoder=custom_encoder,\n                    sqlalchemy_safe=sqlalchemy_safe,\n                )\n                encoded_dict[encoded_key] = encoded_value\n        return encoded_dict\n    if isinstance(obj, (list, set, frozenset, GeneratorType, tuple, deque)):\n        encoded_list = []\n        for item in obj:\n            encoded_list.append(\n                jsonable_encoder(\n                    item,\n                    include=include,\n                    exclude=exclude,\n                    by_alias=by_alias,\n                    exclude_unset=exclude_unset,\n                    exclude_defaults=exclude_defaults,\n                    exclude_none=exclude_none,\n                    custom_encoder=custom_encoder,\n                    sqlalchemy_safe=sqlalchemy_safe,\n                )\n            )\n        return encoded_list\n\n    if type(obj) in ENCODERS_BY_TYPE:\n        return ENCODERS_BY_TYPE[type(obj)](obj)\n    for encoder, classes_tuple in encoders_by_class_tuples.items():\n        if isinstance(obj, classes_tuple):\n            return encoder(obj)\n\n    try:\n        data = dict(obj)\n    except Exception as e:\n        errors: List[Exception] = []\n        errors.append(e)\n        try:\n            data = vars(obj)\n        except Exception as e:\n            errors.append(e)\n            raise ValueError(errors) from e\n    return jsonable_encoder(\n        data,\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        custom_encoder=custom_encoder,\n        sqlalchemy_safe=sqlalchemy_safe,\n    )",
      "docstring": "Convert any object to something that can be encoded in JSON.\n\nThis is used internally by FastAPI to make sure anything you return can be\nencoded as JSON before it is sent to the client.\n\nYou can also use it yourself, for example to convert objects before saving them\nin a database that supports only JSON.\n\nRead more about it in the\n[FastAPI docs for JSON Compatible Encoder](https://fastapi.tiangolo.com/tutorial/encoder/).",
      "decorators": [],
      "arguments": [
        "obj",
        "include",
        "exclude",
        "by_alias",
        "exclude_unset",
        "exclude_defaults",
        "exclude_none",
        "custom_encoder",
        "sqlalchemy_safe"
      ],
      "imports": [
        "dataclasses",
        "datetime",
        "collections.defaultdict",
        "collections.deque",
        "decimal.Decimal",
        "enum.Enum",
        "ipaddress.IPv4Address",
        "ipaddress.IPv4Interface",
        "ipaddress.IPv4Network",
        "ipaddress.IPv6Address",
        "ipaddress.IPv6Interface",
        "ipaddress.IPv6Network",
        "pathlib.Path",
        "pathlib.PurePath",
        "re.Pattern",
        "types.GeneratorType",
        "typing.Any",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "uuid.UUID",
        "fastapi.types.IncEx",
        "pydantic.BaseModel",
        "pydantic.color.Color",
        "pydantic.networks.AnyUrl",
        "pydantic.networks.NameEmail",
        "pydantic.types.SecretBytes",
        "pydantic.types.SecretStr",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "_compat.PYDANTIC_V2",
        "_compat.UndefinedType",
        "_compat.Url",
        "_compat._model_dump"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "jsonable_encoder",
          "body": "def jsonable_encoder(obj: Annotated[Any, Doc('\\n            The input object to convert to JSON.\\n            ')], include: Annotated[Optional[IncEx], Doc(\"\\n            Pydantic's `include` parameter, passed to Pydantic models to set the\\n            fields to include.\\n            \")]=None, exclude: Annotated[Optional[IncEx], Doc(\"\\n            Pydantic's `exclude` parameter, passed to Pydantic models to set the\\n            fields to exclude.\\n            \")]=None, by_alias: Annotated[bool, Doc(\"\\n            Pydantic's `by_alias` parameter, passed to Pydantic models to define if\\n            the output should use the alias names (when provided) or the Python\\n            attribute names. In an API, if you set an alias, it's probably because you\\n            want to use it in the result, so you probably want to leave this set to\\n            `True`.\\n            \")]=True, exclude_unset: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_unset` parameter, passed to Pydantic models to define\\n            if it should exclude from the output the fields that were not explicitly\\n            set (and that only had their default values).\\n            \")]=False, exclude_defaults: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_defaults` parameter, passed to Pydantic models to define\\n            if it should exclude from the output the fields that had the same default\\n            value, even when they were explicitly set.\\n            \")]=False, exclude_none: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_none` parameter, passed to Pydantic models to define\\n            if it should exclude from the output any fields that have a `None` value.\\n            \")]=False, custom_encoder: Annotated[Optional[Dict[Any, Callable[[Any], Any]]], Doc(\"\\n            Pydantic's `custom_encoder` parameter, passed to Pydantic models to define\\n            a custom encoder.\\n            \")]=None, sqlalchemy_safe: Annotated[bool, Doc(\"\\n            Exclude from the output any fields that start with the name `_sa`.\\n\\n            This is mainly a hack for compatibility with SQLAlchemy objects, they\\n            store internal SQLAlchemy-specific state in attributes named with `_sa`,\\n            and those objects can't (and shouldn't be) serialized to JSON.\\n            \")]=True) -> Any:\n    \"\"\"\n    Convert any object to something that can be encoded in JSON.\n\n    This is used internally by FastAPI to make sure anything you return can be\n    encoded as JSON before it is sent to the client.\n\n    You can also use it yourself, for example to convert objects before saving them\n    in a database that supports only JSON.\n\n    Read more about it in the\n    [FastAPI docs for JSON Compatible Encoder](https://fastapi.tiangolo.com/tutorial/encoder/).\n    \"\"\"\n    custom_encoder = custom_encoder or {}\n    if custom_encoder:\n        if type(obj) in custom_encoder:\n            return custom_encoder[type(obj)](obj)\n        else:\n            for encoder_type, encoder_instance in custom_encoder.items():\n                if isinstance(obj, encoder_type):\n                    return encoder_instance(obj)\n    if include is not None and (not isinstance(include, (set, dict))):\n        include = set(include)\n    if exclude is not None and (not isinstance(exclude, (set, dict))):\n        exclude = set(exclude)\n    if isinstance(obj, BaseModel):\n        encoders: Dict[Any, Any] = {}\n        if not PYDANTIC_V2:\n            encoders = getattr(obj.__config__, 'json_encoders', {})\n            if custom_encoder:\n                encoders.update(custom_encoder)\n        obj_dict = _model_dump(obj, mode='json', include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, exclude_defaults=exclude_defaults)\n        if '__root__' in obj_dict:\n            obj_dict = obj_dict['__root__']\n        return jsonable_encoder(obj_dict, exclude_none=exclude_none, exclude_defaults=exclude_defaults, custom_encoder=encoders, sqlalchemy_safe=sqlalchemy_safe)\n    if dataclasses.is_dataclass(obj):\n        obj_dict = dataclasses.asdict(obj)\n        return jsonable_encoder(obj_dict, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n    if isinstance(obj, Enum):\n        return obj.value\n    if isinstance(obj, PurePath):\n        return str(obj)\n    if isinstance(obj, (str, int, float, type(None))):\n        return obj\n    if isinstance(obj, UndefinedType):\n        return None\n    if isinstance(obj, dict):\n        encoded_dict = {}\n        allowed_keys = set(obj.keys())\n        if include is not None:\n            allowed_keys &= set(include)\n        if exclude is not None:\n            allowed_keys -= set(exclude)\n        for key, value in obj.items():\n            if (not sqlalchemy_safe or not isinstance(key, str) or (not key.startswith('_sa'))) and (value is not None or not exclude_none) and (key in allowed_keys):\n                encoded_key = jsonable_encoder(key, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n                encoded_value = jsonable_encoder(value, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n                encoded_dict[encoded_key] = encoded_value\n        return encoded_dict\n    if isinstance(obj, (list, set, frozenset, GeneratorType, tuple, deque)):\n        encoded_list = []\n        for item in obj:\n            encoded_list.append(jsonable_encoder(item, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe))\n        return encoded_list\n    if type(obj) in ENCODERS_BY_TYPE:\n        return ENCODERS_BY_TYPE[type(obj)](obj)\n    for encoder, classes_tuple in encoders_by_class_tuples.items():\n        if isinstance(obj, classes_tuple):\n            return encoder(obj)\n    try:\n        data = dict(obj)\n    except Exception as e:\n        errors: List[Exception] = []\n        errors.append(e)\n        try:\n            data = vars(obj)\n        except Exception as e:\n            errors.append(e)\n            raise ValueError(errors) from e\n    return jsonable_encoder(data, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)"
        },
        {
          "name": "_model_dump",
          "body": "def _model_dump(model: BaseModel, mode: Literal['json', 'python']='json', **kwargs: Any) -> Any:\n    return model.model_dump(mode=mode, **kwargs)"
        },
        {
          "name": "jsonable_encoder",
          "body": "def jsonable_encoder(obj: Annotated[Any, Doc('\\n            The input object to convert to JSON.\\n            ')], include: Annotated[Optional[IncEx], Doc(\"\\n            Pydantic's `include` parameter, passed to Pydantic models to set the\\n            fields to include.\\n            \")]=None, exclude: Annotated[Optional[IncEx], Doc(\"\\n            Pydantic's `exclude` parameter, passed to Pydantic models to set the\\n            fields to exclude.\\n            \")]=None, by_alias: Annotated[bool, Doc(\"\\n            Pydantic's `by_alias` parameter, passed to Pydantic models to define if\\n            the output should use the alias names (when provided) or the Python\\n            attribute names. In an API, if you set an alias, it's probably because you\\n            want to use it in the result, so you probably want to leave this set to\\n            `True`.\\n            \")]=True, exclude_unset: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_unset` parameter, passed to Pydantic models to define\\n            if it should exclude from the output the fields that were not explicitly\\n            set (and that only had their default values).\\n            \")]=False, exclude_defaults: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_defaults` parameter, passed to Pydantic models to define\\n            if it should exclude from the output the fields that had the same default\\n            value, even when they were explicitly set.\\n            \")]=False, exclude_none: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_none` parameter, passed to Pydantic models to define\\n            if it should exclude from the output any fields that have a `None` value.\\n            \")]=False, custom_encoder: Annotated[Optional[Dict[Any, Callable[[Any], Any]]], Doc(\"\\n            Pydantic's `custom_encoder` parameter, passed to Pydantic models to define\\n            a custom encoder.\\n            \")]=None, sqlalchemy_safe: Annotated[bool, Doc(\"\\n            Exclude from the output any fields that start with the name `_sa`.\\n\\n            This is mainly a hack for compatibility with SQLAlchemy objects, they\\n            store internal SQLAlchemy-specific state in attributes named with `_sa`,\\n            and those objects can't (and shouldn't be) serialized to JSON.\\n            \")]=True) -> Any:\n    \"\"\"\n    Convert any object to something that can be encoded in JSON.\n\n    This is used internally by FastAPI to make sure anything you return can be\n    encoded as JSON before it is sent to the client.\n\n    You can also use it yourself, for example to convert objects before saving them\n    in a database that supports only JSON.\n\n    Read more about it in the\n    [FastAPI docs for JSON Compatible Encoder](https://fastapi.tiangolo.com/tutorial/encoder/).\n    \"\"\"\n    custom_encoder = custom_encoder or {}\n    if custom_encoder:\n        if type(obj) in custom_encoder:\n            return custom_encoder[type(obj)](obj)\n        else:\n            for encoder_type, encoder_instance in custom_encoder.items():\n                if isinstance(obj, encoder_type):\n                    return encoder_instance(obj)\n    if include is not None and (not isinstance(include, (set, dict))):\n        include = set(include)\n    if exclude is not None and (not isinstance(exclude, (set, dict))):\n        exclude = set(exclude)\n    if isinstance(obj, BaseModel):\n        encoders: Dict[Any, Any] = {}\n        if not PYDANTIC_V2:\n            encoders = getattr(obj.__config__, 'json_encoders', {})\n            if custom_encoder:\n                encoders.update(custom_encoder)\n        obj_dict = _model_dump(obj, mode='json', include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, exclude_defaults=exclude_defaults)\n        if '__root__' in obj_dict:\n            obj_dict = obj_dict['__root__']\n        return jsonable_encoder(obj_dict, exclude_none=exclude_none, exclude_defaults=exclude_defaults, custom_encoder=encoders, sqlalchemy_safe=sqlalchemy_safe)\n    if dataclasses.is_dataclass(obj):\n        obj_dict = dataclasses.asdict(obj)\n        return jsonable_encoder(obj_dict, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n    if isinstance(obj, Enum):\n        return obj.value\n    if isinstance(obj, PurePath):\n        return str(obj)\n    if isinstance(obj, (str, int, float, type(None))):\n        return obj\n    if isinstance(obj, UndefinedType):\n        return None\n    if isinstance(obj, dict):\n        encoded_dict = {}\n        allowed_keys = set(obj.keys())\n        if include is not None:\n            allowed_keys &= set(include)\n        if exclude is not None:\n            allowed_keys -= set(exclude)\n        for key, value in obj.items():\n            if (not sqlalchemy_safe or not isinstance(key, str) or (not key.startswith('_sa'))) and (value is not None or not exclude_none) and (key in allowed_keys):\n                encoded_key = jsonable_encoder(key, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n                encoded_value = jsonable_encoder(value, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n                encoded_dict[encoded_key] = encoded_value\n        return encoded_dict\n    if isinstance(obj, (list, set, frozenset, GeneratorType, tuple, deque)):\n        encoded_list = []\n        for item in obj:\n            encoded_list.append(jsonable_encoder(item, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe))\n        return encoded_list\n    if type(obj) in ENCODERS_BY_TYPE:\n        return ENCODERS_BY_TYPE[type(obj)](obj)\n    for encoder, classes_tuple in encoders_by_class_tuples.items():\n        if isinstance(obj, classes_tuple):\n            return encoder(obj)\n    try:\n        data = dict(obj)\n    except Exception as e:\n        errors: List[Exception] = []\n        errors.append(e)\n        try:\n            data = vars(obj)\n        except Exception as e:\n            errors.append(e)\n            raise ValueError(errors) from e\n    return jsonable_encoder(data, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)"
        },
        {
          "name": "jsonable_encoder",
          "body": "def jsonable_encoder(obj: Annotated[Any, Doc('\\n            The input object to convert to JSON.\\n            ')], include: Annotated[Optional[IncEx], Doc(\"\\n            Pydantic's `include` parameter, passed to Pydantic models to set the\\n            fields to include.\\n            \")]=None, exclude: Annotated[Optional[IncEx], Doc(\"\\n            Pydantic's `exclude` parameter, passed to Pydantic models to set the\\n            fields to exclude.\\n            \")]=None, by_alias: Annotated[bool, Doc(\"\\n            Pydantic's `by_alias` parameter, passed to Pydantic models to define if\\n            the output should use the alias names (when provided) or the Python\\n            attribute names. In an API, if you set an alias, it's probably because you\\n            want to use it in the result, so you probably want to leave this set to\\n            `True`.\\n            \")]=True, exclude_unset: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_unset` parameter, passed to Pydantic models to define\\n            if it should exclude from the output the fields that were not explicitly\\n            set (and that only had their default values).\\n            \")]=False, exclude_defaults: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_defaults` parameter, passed to Pydantic models to define\\n            if it should exclude from the output the fields that had the same default\\n            value, even when they were explicitly set.\\n            \")]=False, exclude_none: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_none` parameter, passed to Pydantic models to define\\n            if it should exclude from the output any fields that have a `None` value.\\n            \")]=False, custom_encoder: Annotated[Optional[Dict[Any, Callable[[Any], Any]]], Doc(\"\\n            Pydantic's `custom_encoder` parameter, passed to Pydantic models to define\\n            a custom encoder.\\n            \")]=None, sqlalchemy_safe: Annotated[bool, Doc(\"\\n            Exclude from the output any fields that start with the name `_sa`.\\n\\n            This is mainly a hack for compatibility with SQLAlchemy objects, they\\n            store internal SQLAlchemy-specific state in attributes named with `_sa`,\\n            and those objects can't (and shouldn't be) serialized to JSON.\\n            \")]=True) -> Any:\n    \"\"\"\n    Convert any object to something that can be encoded in JSON.\n\n    This is used internally by FastAPI to make sure anything you return can be\n    encoded as JSON before it is sent to the client.\n\n    You can also use it yourself, for example to convert objects before saving them\n    in a database that supports only JSON.\n\n    Read more about it in the\n    [FastAPI docs for JSON Compatible Encoder](https://fastapi.tiangolo.com/tutorial/encoder/).\n    \"\"\"\n    custom_encoder = custom_encoder or {}\n    if custom_encoder:\n        if type(obj) in custom_encoder:\n            return custom_encoder[type(obj)](obj)\n        else:\n            for encoder_type, encoder_instance in custom_encoder.items():\n                if isinstance(obj, encoder_type):\n                    return encoder_instance(obj)\n    if include is not None and (not isinstance(include, (set, dict))):\n        include = set(include)\n    if exclude is not None and (not isinstance(exclude, (set, dict))):\n        exclude = set(exclude)\n    if isinstance(obj, BaseModel):\n        encoders: Dict[Any, Any] = {}\n        if not PYDANTIC_V2:\n            encoders = getattr(obj.__config__, 'json_encoders', {})\n            if custom_encoder:\n                encoders.update(custom_encoder)\n        obj_dict = _model_dump(obj, mode='json', include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, exclude_defaults=exclude_defaults)\n        if '__root__' in obj_dict:\n            obj_dict = obj_dict['__root__']\n        return jsonable_encoder(obj_dict, exclude_none=exclude_none, exclude_defaults=exclude_defaults, custom_encoder=encoders, sqlalchemy_safe=sqlalchemy_safe)\n    if dataclasses.is_dataclass(obj):\n        obj_dict = dataclasses.asdict(obj)\n        return jsonable_encoder(obj_dict, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n    if isinstance(obj, Enum):\n        return obj.value\n    if isinstance(obj, PurePath):\n        return str(obj)\n    if isinstance(obj, (str, int, float, type(None))):\n        return obj\n    if isinstance(obj, UndefinedType):\n        return None\n    if isinstance(obj, dict):\n        encoded_dict = {}\n        allowed_keys = set(obj.keys())\n        if include is not None:\n            allowed_keys &= set(include)\n        if exclude is not None:\n            allowed_keys -= set(exclude)\n        for key, value in obj.items():\n            if (not sqlalchemy_safe or not isinstance(key, str) or (not key.startswith('_sa'))) and (value is not None or not exclude_none) and (key in allowed_keys):\n                encoded_key = jsonable_encoder(key, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n                encoded_value = jsonable_encoder(value, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n                encoded_dict[encoded_key] = encoded_value\n        return encoded_dict\n    if isinstance(obj, (list, set, frozenset, GeneratorType, tuple, deque)):\n        encoded_list = []\n        for item in obj:\n            encoded_list.append(jsonable_encoder(item, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe))\n        return encoded_list\n    if type(obj) in ENCODERS_BY_TYPE:\n        return ENCODERS_BY_TYPE[type(obj)](obj)\n    for encoder, classes_tuple in encoders_by_class_tuples.items():\n        if isinstance(obj, classes_tuple):\n            return encoder(obj)\n    try:\n        data = dict(obj)\n    except Exception as e:\n        errors: List[Exception] = []\n        errors.append(e)\n        try:\n            data = vars(obj)\n        except Exception as e:\n            errors.append(e)\n            raise ValueError(errors) from e\n    return jsonable_encoder(data, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)"
        },
        {
          "name": "jsonable_encoder",
          "body": "def jsonable_encoder(obj: Annotated[Any, Doc('\\n            The input object to convert to JSON.\\n            ')], include: Annotated[Optional[IncEx], Doc(\"\\n            Pydantic's `include` parameter, passed to Pydantic models to set the\\n            fields to include.\\n            \")]=None, exclude: Annotated[Optional[IncEx], Doc(\"\\n            Pydantic's `exclude` parameter, passed to Pydantic models to set the\\n            fields to exclude.\\n            \")]=None, by_alias: Annotated[bool, Doc(\"\\n            Pydantic's `by_alias` parameter, passed to Pydantic models to define if\\n            the output should use the alias names (when provided) or the Python\\n            attribute names. In an API, if you set an alias, it's probably because you\\n            want to use it in the result, so you probably want to leave this set to\\n            `True`.\\n            \")]=True, exclude_unset: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_unset` parameter, passed to Pydantic models to define\\n            if it should exclude from the output the fields that were not explicitly\\n            set (and that only had their default values).\\n            \")]=False, exclude_defaults: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_defaults` parameter, passed to Pydantic models to define\\n            if it should exclude from the output the fields that had the same default\\n            value, even when they were explicitly set.\\n            \")]=False, exclude_none: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_none` parameter, passed to Pydantic models to define\\n            if it should exclude from the output any fields that have a `None` value.\\n            \")]=False, custom_encoder: Annotated[Optional[Dict[Any, Callable[[Any], Any]]], Doc(\"\\n            Pydantic's `custom_encoder` parameter, passed to Pydantic models to define\\n            a custom encoder.\\n            \")]=None, sqlalchemy_safe: Annotated[bool, Doc(\"\\n            Exclude from the output any fields that start with the name `_sa`.\\n\\n            This is mainly a hack for compatibility with SQLAlchemy objects, they\\n            store internal SQLAlchemy-specific state in attributes named with `_sa`,\\n            and those objects can't (and shouldn't be) serialized to JSON.\\n            \")]=True) -> Any:\n    \"\"\"\n    Convert any object to something that can be encoded in JSON.\n\n    This is used internally by FastAPI to make sure anything you return can be\n    encoded as JSON before it is sent to the client.\n\n    You can also use it yourself, for example to convert objects before saving them\n    in a database that supports only JSON.\n\n    Read more about it in the\n    [FastAPI docs for JSON Compatible Encoder](https://fastapi.tiangolo.com/tutorial/encoder/).\n    \"\"\"\n    custom_encoder = custom_encoder or {}\n    if custom_encoder:\n        if type(obj) in custom_encoder:\n            return custom_encoder[type(obj)](obj)\n        else:\n            for encoder_type, encoder_instance in custom_encoder.items():\n                if isinstance(obj, encoder_type):\n                    return encoder_instance(obj)\n    if include is not None and (not isinstance(include, (set, dict))):\n        include = set(include)\n    if exclude is not None and (not isinstance(exclude, (set, dict))):\n        exclude = set(exclude)\n    if isinstance(obj, BaseModel):\n        encoders: Dict[Any, Any] = {}\n        if not PYDANTIC_V2:\n            encoders = getattr(obj.__config__, 'json_encoders', {})\n            if custom_encoder:\n                encoders.update(custom_encoder)\n        obj_dict = _model_dump(obj, mode='json', include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, exclude_defaults=exclude_defaults)\n        if '__root__' in obj_dict:\n            obj_dict = obj_dict['__root__']\n        return jsonable_encoder(obj_dict, exclude_none=exclude_none, exclude_defaults=exclude_defaults, custom_encoder=encoders, sqlalchemy_safe=sqlalchemy_safe)\n    if dataclasses.is_dataclass(obj):\n        obj_dict = dataclasses.asdict(obj)\n        return jsonable_encoder(obj_dict, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n    if isinstance(obj, Enum):\n        return obj.value\n    if isinstance(obj, PurePath):\n        return str(obj)\n    if isinstance(obj, (str, int, float, type(None))):\n        return obj\n    if isinstance(obj, UndefinedType):\n        return None\n    if isinstance(obj, dict):\n        encoded_dict = {}\n        allowed_keys = set(obj.keys())\n        if include is not None:\n            allowed_keys &= set(include)\n        if exclude is not None:\n            allowed_keys -= set(exclude)\n        for key, value in obj.items():\n            if (not sqlalchemy_safe or not isinstance(key, str) or (not key.startswith('_sa'))) and (value is not None or not exclude_none) and (key in allowed_keys):\n                encoded_key = jsonable_encoder(key, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n                encoded_value = jsonable_encoder(value, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n                encoded_dict[encoded_key] = encoded_value\n        return encoded_dict\n    if isinstance(obj, (list, set, frozenset, GeneratorType, tuple, deque)):\n        encoded_list = []\n        for item in obj:\n            encoded_list.append(jsonable_encoder(item, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe))\n        return encoded_list\n    if type(obj) in ENCODERS_BY_TYPE:\n        return ENCODERS_BY_TYPE[type(obj)](obj)\n    for encoder, classes_tuple in encoders_by_class_tuples.items():\n        if isinstance(obj, classes_tuple):\n            return encoder(obj)\n    try:\n        data = dict(obj)\n    except Exception as e:\n        errors: List[Exception] = []\n        errors.append(e)\n        try:\n            data = vars(obj)\n        except Exception as e:\n            errors.append(e)\n            raise ValueError(errors) from e\n    return jsonable_encoder(data, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)"
        },
        {
          "name": "jsonable_encoder",
          "body": "def jsonable_encoder(obj: Annotated[Any, Doc('\\n            The input object to convert to JSON.\\n            ')], include: Annotated[Optional[IncEx], Doc(\"\\n            Pydantic's `include` parameter, passed to Pydantic models to set the\\n            fields to include.\\n            \")]=None, exclude: Annotated[Optional[IncEx], Doc(\"\\n            Pydantic's `exclude` parameter, passed to Pydantic models to set the\\n            fields to exclude.\\n            \")]=None, by_alias: Annotated[bool, Doc(\"\\n            Pydantic's `by_alias` parameter, passed to Pydantic models to define if\\n            the output should use the alias names (when provided) or the Python\\n            attribute names. In an API, if you set an alias, it's probably because you\\n            want to use it in the result, so you probably want to leave this set to\\n            `True`.\\n            \")]=True, exclude_unset: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_unset` parameter, passed to Pydantic models to define\\n            if it should exclude from the output the fields that were not explicitly\\n            set (and that only had their default values).\\n            \")]=False, exclude_defaults: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_defaults` parameter, passed to Pydantic models to define\\n            if it should exclude from the output the fields that had the same default\\n            value, even when they were explicitly set.\\n            \")]=False, exclude_none: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_none` parameter, passed to Pydantic models to define\\n            if it should exclude from the output any fields that have a `None` value.\\n            \")]=False, custom_encoder: Annotated[Optional[Dict[Any, Callable[[Any], Any]]], Doc(\"\\n            Pydantic's `custom_encoder` parameter, passed to Pydantic models to define\\n            a custom encoder.\\n            \")]=None, sqlalchemy_safe: Annotated[bool, Doc(\"\\n            Exclude from the output any fields that start with the name `_sa`.\\n\\n            This is mainly a hack for compatibility with SQLAlchemy objects, they\\n            store internal SQLAlchemy-specific state in attributes named with `_sa`,\\n            and those objects can't (and shouldn't be) serialized to JSON.\\n            \")]=True) -> Any:\n    \"\"\"\n    Convert any object to something that can be encoded in JSON.\n\n    This is used internally by FastAPI to make sure anything you return can be\n    encoded as JSON before it is sent to the client.\n\n    You can also use it yourself, for example to convert objects before saving them\n    in a database that supports only JSON.\n\n    Read more about it in the\n    [FastAPI docs for JSON Compatible Encoder](https://fastapi.tiangolo.com/tutorial/encoder/).\n    \"\"\"\n    custom_encoder = custom_encoder or {}\n    if custom_encoder:\n        if type(obj) in custom_encoder:\n            return custom_encoder[type(obj)](obj)\n        else:\n            for encoder_type, encoder_instance in custom_encoder.items():\n                if isinstance(obj, encoder_type):\n                    return encoder_instance(obj)\n    if include is not None and (not isinstance(include, (set, dict))):\n        include = set(include)\n    if exclude is not None and (not isinstance(exclude, (set, dict))):\n        exclude = set(exclude)\n    if isinstance(obj, BaseModel):\n        encoders: Dict[Any, Any] = {}\n        if not PYDANTIC_V2:\n            encoders = getattr(obj.__config__, 'json_encoders', {})\n            if custom_encoder:\n                encoders.update(custom_encoder)\n        obj_dict = _model_dump(obj, mode='json', include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, exclude_defaults=exclude_defaults)\n        if '__root__' in obj_dict:\n            obj_dict = obj_dict['__root__']\n        return jsonable_encoder(obj_dict, exclude_none=exclude_none, exclude_defaults=exclude_defaults, custom_encoder=encoders, sqlalchemy_safe=sqlalchemy_safe)\n    if dataclasses.is_dataclass(obj):\n        obj_dict = dataclasses.asdict(obj)\n        return jsonable_encoder(obj_dict, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n    if isinstance(obj, Enum):\n        return obj.value\n    if isinstance(obj, PurePath):\n        return str(obj)\n    if isinstance(obj, (str, int, float, type(None))):\n        return obj\n    if isinstance(obj, UndefinedType):\n        return None\n    if isinstance(obj, dict):\n        encoded_dict = {}\n        allowed_keys = set(obj.keys())\n        if include is not None:\n            allowed_keys &= set(include)\n        if exclude is not None:\n            allowed_keys -= set(exclude)\n        for key, value in obj.items():\n            if (not sqlalchemy_safe or not isinstance(key, str) or (not key.startswith('_sa'))) and (value is not None or not exclude_none) and (key in allowed_keys):\n                encoded_key = jsonable_encoder(key, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n                encoded_value = jsonable_encoder(value, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n                encoded_dict[encoded_key] = encoded_value\n        return encoded_dict\n    if isinstance(obj, (list, set, frozenset, GeneratorType, tuple, deque)):\n        encoded_list = []\n        for item in obj:\n            encoded_list.append(jsonable_encoder(item, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe))\n        return encoded_list\n    if type(obj) in ENCODERS_BY_TYPE:\n        return ENCODERS_BY_TYPE[type(obj)](obj)\n    for encoder, classes_tuple in encoders_by_class_tuples.items():\n        if isinstance(obj, classes_tuple):\n            return encoder(obj)\n    try:\n        data = dict(obj)\n    except Exception as e:\n        errors: List[Exception] = []\n        errors.append(e)\n        try:\n            data = vars(obj)\n        except Exception as e:\n            errors.append(e)\n            raise ValueError(errors) from e\n    return jsonable_encoder(data, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)"
        },
        {
          "name": "jsonable_encoder",
          "body": "def jsonable_encoder(obj: Annotated[Any, Doc('\\n            The input object to convert to JSON.\\n            ')], include: Annotated[Optional[IncEx], Doc(\"\\n            Pydantic's `include` parameter, passed to Pydantic models to set the\\n            fields to include.\\n            \")]=None, exclude: Annotated[Optional[IncEx], Doc(\"\\n            Pydantic's `exclude` parameter, passed to Pydantic models to set the\\n            fields to exclude.\\n            \")]=None, by_alias: Annotated[bool, Doc(\"\\n            Pydantic's `by_alias` parameter, passed to Pydantic models to define if\\n            the output should use the alias names (when provided) or the Python\\n            attribute names. In an API, if you set an alias, it's probably because you\\n            want to use it in the result, so you probably want to leave this set to\\n            `True`.\\n            \")]=True, exclude_unset: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_unset` parameter, passed to Pydantic models to define\\n            if it should exclude from the output the fields that were not explicitly\\n            set (and that only had their default values).\\n            \")]=False, exclude_defaults: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_defaults` parameter, passed to Pydantic models to define\\n            if it should exclude from the output the fields that had the same default\\n            value, even when they were explicitly set.\\n            \")]=False, exclude_none: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_none` parameter, passed to Pydantic models to define\\n            if it should exclude from the output any fields that have a `None` value.\\n            \")]=False, custom_encoder: Annotated[Optional[Dict[Any, Callable[[Any], Any]]], Doc(\"\\n            Pydantic's `custom_encoder` parameter, passed to Pydantic models to define\\n            a custom encoder.\\n            \")]=None, sqlalchemy_safe: Annotated[bool, Doc(\"\\n            Exclude from the output any fields that start with the name `_sa`.\\n\\n            This is mainly a hack for compatibility with SQLAlchemy objects, they\\n            store internal SQLAlchemy-specific state in attributes named with `_sa`,\\n            and those objects can't (and shouldn't be) serialized to JSON.\\n            \")]=True) -> Any:\n    \"\"\"\n    Convert any object to something that can be encoded in JSON.\n\n    This is used internally by FastAPI to make sure anything you return can be\n    encoded as JSON before it is sent to the client.\n\n    You can also use it yourself, for example to convert objects before saving them\n    in a database that supports only JSON.\n\n    Read more about it in the\n    [FastAPI docs for JSON Compatible Encoder](https://fastapi.tiangolo.com/tutorial/encoder/).\n    \"\"\"\n    custom_encoder = custom_encoder or {}\n    if custom_encoder:\n        if type(obj) in custom_encoder:\n            return custom_encoder[type(obj)](obj)\n        else:\n            for encoder_type, encoder_instance in custom_encoder.items():\n                if isinstance(obj, encoder_type):\n                    return encoder_instance(obj)\n    if include is not None and (not isinstance(include, (set, dict))):\n        include = set(include)\n    if exclude is not None and (not isinstance(exclude, (set, dict))):\n        exclude = set(exclude)\n    if isinstance(obj, BaseModel):\n        encoders: Dict[Any, Any] = {}\n        if not PYDANTIC_V2:\n            encoders = getattr(obj.__config__, 'json_encoders', {})\n            if custom_encoder:\n                encoders.update(custom_encoder)\n        obj_dict = _model_dump(obj, mode='json', include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, exclude_defaults=exclude_defaults)\n        if '__root__' in obj_dict:\n            obj_dict = obj_dict['__root__']\n        return jsonable_encoder(obj_dict, exclude_none=exclude_none, exclude_defaults=exclude_defaults, custom_encoder=encoders, sqlalchemy_safe=sqlalchemy_safe)\n    if dataclasses.is_dataclass(obj):\n        obj_dict = dataclasses.asdict(obj)\n        return jsonable_encoder(obj_dict, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n    if isinstance(obj, Enum):\n        return obj.value\n    if isinstance(obj, PurePath):\n        return str(obj)\n    if isinstance(obj, (str, int, float, type(None))):\n        return obj\n    if isinstance(obj, UndefinedType):\n        return None\n    if isinstance(obj, dict):\n        encoded_dict = {}\n        allowed_keys = set(obj.keys())\n        if include is not None:\n            allowed_keys &= set(include)\n        if exclude is not None:\n            allowed_keys -= set(exclude)\n        for key, value in obj.items():\n            if (not sqlalchemy_safe or not isinstance(key, str) or (not key.startswith('_sa'))) and (value is not None or not exclude_none) and (key in allowed_keys):\n                encoded_key = jsonable_encoder(key, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n                encoded_value = jsonable_encoder(value, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n                encoded_dict[encoded_key] = encoded_value\n        return encoded_dict\n    if isinstance(obj, (list, set, frozenset, GeneratorType, tuple, deque)):\n        encoded_list = []\n        for item in obj:\n            encoded_list.append(jsonable_encoder(item, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe))\n        return encoded_list\n    if type(obj) in ENCODERS_BY_TYPE:\n        return ENCODERS_BY_TYPE[type(obj)](obj)\n    for encoder, classes_tuple in encoders_by_class_tuples.items():\n        if isinstance(obj, classes_tuple):\n            return encoder(obj)\n    try:\n        data = dict(obj)\n    except Exception as e:\n        errors: List[Exception] = []\n        errors.append(e)\n        try:\n            data = vars(obj)\n        except Exception as e:\n            errors.append(e)\n            raise ValueError(errors) from e\n    return jsonable_encoder(data, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)"
        }
      ]
    },
    {
      "name": "__init__",
      "module": "exceptions",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\exceptions.py",
      "line_number": 37,
      "end_line_number": 65,
      "source_code": "def __init__(\n        self,\n        status_code: Annotated[\n            int,\n            Doc(\n                \"\"\"\n                HTTP status code to send to the client.\n                \"\"\"\n            ),\n        ],\n        detail: Annotated[\n            Any,\n            Doc(\n                \"\"\"\n                Any data to be sent to the client in the `detail` key of the JSON\n                response.\n                \"\"\"\n            ),\n        ] = None,\n        headers: Annotated[\n            Optional[Dict[str, str]],\n            Doc(\n                \"\"\"\n                Any headers to send to the client in the response.\n                \"\"\"\n            ),\n        ] = None,\n    ) -> None:\n        super().__init__(status_code=status_code, detail=detail, headers=headers)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "status_code",
        "detail",
        "headers"
      ],
      "imports": [
        "typing.Any",
        "typing.Dict",
        "typing.Optional",
        "typing.Sequence",
        "typing.Type",
        "typing.Union",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "typing_extensions.Annotated",
        "typing_extensions.Doc"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "exceptions",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\exceptions.py",
      "line_number": 110,
      "end_line_number": 136,
      "source_code": "def __init__(\n        self,\n        code: Annotated[\n            int,\n            Doc(\n                \"\"\"\n                A closing code from the\n                [valid codes defined in the specification](https://datatracker.ietf.org/doc/html/rfc6455#section-7.4.1).\n                \"\"\"\n            ),\n        ],\n        reason: Annotated[\n            Union[str, None],\n            Doc(\n                \"\"\"\n                The reason to close the WebSocket connection.\n\n                It is UTF-8-encoded data. The interpretation of the reason is up to the\n                application, it is not specified by the WebSocket specification.\n\n                It could contain text that could be human-readable or interpretable\n                by the client code, etc.\n                \"\"\"\n            ),\n        ] = None,\n    ) -> None:\n        super().__init__(code=code, reason=reason)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "code",
        "reason"
      ],
      "imports": [
        "typing.Any",
        "typing.Dict",
        "typing.Optional",
        "typing.Sequence",
        "typing.Type",
        "typing.Union",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "typing_extensions.Annotated",
        "typing_extensions.Doc"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "exceptions",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\exceptions.py",
      "line_number": 150,
      "end_line_number": 151,
      "source_code": "def __init__(self, errors: Sequence[Any]) -> None:\n        self._errors = errors",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "errors"
      ],
      "imports": [
        "typing.Any",
        "typing.Dict",
        "typing.Optional",
        "typing.Sequence",
        "typing.Type",
        "typing.Union",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "typing_extensions.Annotated",
        "typing_extensions.Doc"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "errors",
      "module": "exceptions",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\exceptions.py",
      "line_number": 153,
      "end_line_number": 154,
      "source_code": "def errors(self) -> Sequence[Any]:\n        return self._errors",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "typing.Any",
        "typing.Dict",
        "typing.Optional",
        "typing.Sequence",
        "typing.Type",
        "typing.Union",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "typing_extensions.Annotated",
        "typing_extensions.Doc"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "exceptions",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\exceptions.py",
      "line_number": 158,
      "end_line_number": 160,
      "source_code": "def __init__(self, errors: Sequence[Any], *, body: Any = None) -> None:\n        super().__init__(errors)\n        self.body = body",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "errors"
      ],
      "imports": [
        "typing.Any",
        "typing.Dict",
        "typing.Optional",
        "typing.Sequence",
        "typing.Type",
        "typing.Union",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "typing_extensions.Annotated",
        "typing_extensions.Doc"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "exceptions",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\exceptions.py",
      "line_number": 168,
      "end_line_number": 170,
      "source_code": "def __init__(self, errors: Sequence[Any], *, body: Any = None) -> None:\n        super().__init__(errors)\n        self.body = body",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "errors"
      ],
      "imports": [
        "typing.Any",
        "typing.Dict",
        "typing.Optional",
        "typing.Sequence",
        "typing.Type",
        "typing.Union",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "typing_extensions.Annotated",
        "typing_extensions.Doc"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__str__",
      "module": "exceptions",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\exceptions.py",
      "line_number": 172,
      "end_line_number": 176,
      "source_code": "def __str__(self) -> str:\n        message = f\"{len(self._errors)} validation errors:\\n\"\n        for err in self._errors:\n            message += f\"  {err}\\n\"\n        return message",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "typing.Any",
        "typing.Dict",
        "typing.Optional",
        "typing.Sequence",
        "typing.Type",
        "typing.Union",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "starlette.exceptions.HTTPException",
        "starlette.exceptions.WebSocketException",
        "typing_extensions.Annotated",
        "typing_extensions.Doc"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "params",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\params.py",
      "line_number": 28,
      "end_line_number": 133,
      "source_code": "def __init__(\n        self,\n        default: Any = Undefined,\n        *,\n        default_factory: Union[Callable[[], Any], None] = _Unset,\n        annotation: Optional[Any] = None,\n        alias: Optional[str] = None,\n        alias_priority: Union[int, None] = _Unset,\n        # TODO: update when deprecating Pydantic v1, import these types\n        # validation_alias: str | AliasPath | AliasChoices | None\n        validation_alias: Union[str, None] = None,\n        serialization_alias: Union[str, None] = None,\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n        gt: Optional[float] = None,\n        ge: Optional[float] = None,\n        lt: Optional[float] = None,\n        le: Optional[float] = None,\n        min_length: Optional[int] = None,\n        max_length: Optional[int] = None,\n        pattern: Optional[str] = None,\n        regex: Annotated[\n            Optional[str],\n            deprecated(\n                \"Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead.\"\n            ),\n        ] = None,\n        discriminator: Union[str, None] = None,\n        strict: Union[bool, None] = _Unset,\n        multiple_of: Union[float, None] = _Unset,\n        allow_inf_nan: Union[bool, None] = _Unset,\n        max_digits: Union[int, None] = _Unset,\n        decimal_places: Union[int, None] = _Unset,\n        examples: Optional[List[Any]] = None,\n        example: Annotated[\n            Optional[Any],\n            deprecated(\n                \"Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, \"\n                \"although still supported. Use examples instead.\"\n            ),\n        ] = _Unset,\n        openapi_examples: Optional[Dict[str, Example]] = None,\n        deprecated: Union[deprecated, str, bool, None] = None,\n        include_in_schema: bool = True,\n        json_schema_extra: Union[Dict[str, Any], None] = None,\n        **extra: Any,\n    ):\n        if example is not _Unset:\n            warnings.warn(\n                \"`example` has been deprecated, please use `examples` instead\",\n                category=DeprecationWarning,\n                stacklevel=4,\n            )\n        self.example = example\n        self.include_in_schema = include_in_schema\n        self.openapi_examples = openapi_examples\n        kwargs = dict(\n            default=default,\n            default_factory=default_factory,\n            alias=alias,\n            title=title,\n            description=description,\n            gt=gt,\n            ge=ge,\n            lt=lt,\n            le=le,\n            min_length=min_length,\n            max_length=max_length,\n            discriminator=discriminator,\n            multiple_of=multiple_of,\n            allow_inf_nan=allow_inf_nan,\n            max_digits=max_digits,\n            decimal_places=decimal_places,\n            **extra,\n        )\n        if examples is not None:\n            kwargs[\"examples\"] = examples\n        if regex is not None:\n            warnings.warn(\n                \"`regex` has been deprecated, please use `pattern` instead\",\n                category=DeprecationWarning,\n                stacklevel=4,\n            )\n        current_json_schema_extra = json_schema_extra or extra\n        if PYDANTIC_VERSION_MINOR_TUPLE < (2, 7):\n            self.deprecated = deprecated\n        else:\n            kwargs[\"deprecated\"] = deprecated\n        if PYDANTIC_V2:\n            kwargs.update(\n                {\n                    \"annotation\": annotation,\n                    \"alias_priority\": alias_priority,\n                    \"validation_alias\": validation_alias,\n                    \"serialization_alias\": serialization_alias,\n                    \"strict\": strict,\n                    \"json_schema_extra\": current_json_schema_extra,\n                }\n            )\n            kwargs[\"pattern\"] = pattern or regex\n        else:\n            kwargs[\"regex\"] = pattern or regex\n            kwargs.update(**current_json_schema_extra)\n        use_kwargs = {k: v for k, v in kwargs.items() if v is not _Unset}\n\n        super().__init__(**use_kwargs)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "default"
      ],
      "imports": [
        "warnings",
        "enum.Enum",
        "typing.Any",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Union",
        "fastapi.openapi.models.Example",
        "pydantic.fields.FieldInfo",
        "typing_extensions.Annotated",
        "typing_extensions.deprecated",
        "_compat.PYDANTIC_V2",
        "_compat.PYDANTIC_VERSION_MINOR_TUPLE",
        "_compat.Undefined"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__repr__",
      "module": "params",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\params.py",
      "line_number": 135,
      "end_line_number": 136,
      "source_code": "def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}({self.default})\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "warnings",
        "enum.Enum",
        "typing.Any",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Union",
        "fastapi.openapi.models.Example",
        "pydantic.fields.FieldInfo",
        "typing_extensions.Annotated",
        "typing_extensions.deprecated",
        "_compat.PYDANTIC_V2",
        "_compat.PYDANTIC_VERSION_MINOR_TUPLE",
        "_compat.Undefined"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "params",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\params.py",
      "line_number": 142,
      "end_line_number": 222,
      "source_code": "def __init__(\n        self,\n        default: Any = ...,\n        *,\n        default_factory: Union[Callable[[], Any], None] = _Unset,\n        annotation: Optional[Any] = None,\n        alias: Optional[str] = None,\n        alias_priority: Union[int, None] = _Unset,\n        # TODO: update when deprecating Pydantic v1, import these types\n        # validation_alias: str | AliasPath | AliasChoices | None\n        validation_alias: Union[str, None] = None,\n        serialization_alias: Union[str, None] = None,\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n        gt: Optional[float] = None,\n        ge: Optional[float] = None,\n        lt: Optional[float] = None,\n        le: Optional[float] = None,\n        min_length: Optional[int] = None,\n        max_length: Optional[int] = None,\n        pattern: Optional[str] = None,\n        regex: Annotated[\n            Optional[str],\n            deprecated(\n                \"Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead.\"\n            ),\n        ] = None,\n        discriminator: Union[str, None] = None,\n        strict: Union[bool, None] = _Unset,\n        multiple_of: Union[float, None] = _Unset,\n        allow_inf_nan: Union[bool, None] = _Unset,\n        max_digits: Union[int, None] = _Unset,\n        decimal_places: Union[int, None] = _Unset,\n        examples: Optional[List[Any]] = None,\n        example: Annotated[\n            Optional[Any],\n            deprecated(\n                \"Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, \"\n                \"although still supported. Use examples instead.\"\n            ),\n        ] = _Unset,\n        openapi_examples: Optional[Dict[str, Example]] = None,\n        deprecated: Union[deprecated, str, bool, None] = None,\n        include_in_schema: bool = True,\n        json_schema_extra: Union[Dict[str, Any], None] = None,\n        **extra: Any,\n    ):\n        assert default is ..., \"Path parameters cannot have a default value\"\n        self.in_ = self.in_\n        super().__init__(\n            default=default,\n            default_factory=default_factory,\n            annotation=annotation,\n            alias=alias,\n            alias_priority=alias_priority,\n            validation_alias=validation_alias,\n            serialization_alias=serialization_alias,\n            title=title,\n            description=description,\n            gt=gt,\n            ge=ge,\n            lt=lt,\n            le=le,\n            min_length=min_length,\n            max_length=max_length,\n            pattern=pattern,\n            regex=regex,\n            discriminator=discriminator,\n            strict=strict,\n            multiple_of=multiple_of,\n            allow_inf_nan=allow_inf_nan,\n            max_digits=max_digits,\n            decimal_places=decimal_places,\n            deprecated=deprecated,\n            example=example,\n            examples=examples,\n            openapi_examples=openapi_examples,\n            include_in_schema=include_in_schema,\n            json_schema_extra=json_schema_extra,\n            **extra,\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "default"
      ],
      "imports": [
        "warnings",
        "enum.Enum",
        "typing.Any",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Union",
        "fastapi.openapi.models.Example",
        "pydantic.fields.FieldInfo",
        "typing_extensions.Annotated",
        "typing_extensions.deprecated",
        "_compat.PYDANTIC_V2",
        "_compat.PYDANTIC_VERSION_MINOR_TUPLE",
        "_compat.Undefined"
      ],
      "fixtures": [],
      "assertions": [
        "assert default is ..., 'Path parameters cannot have a default value'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "params",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\params.py",
      "line_number": 228,
      "end_line_number": 306,
      "source_code": "def __init__(\n        self,\n        default: Any = Undefined,\n        *,\n        default_factory: Union[Callable[[], Any], None] = _Unset,\n        annotation: Optional[Any] = None,\n        alias: Optional[str] = None,\n        alias_priority: Union[int, None] = _Unset,\n        # TODO: update when deprecating Pydantic v1, import these types\n        # validation_alias: str | AliasPath | AliasChoices | None\n        validation_alias: Union[str, None] = None,\n        serialization_alias: Union[str, None] = None,\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n        gt: Optional[float] = None,\n        ge: Optional[float] = None,\n        lt: Optional[float] = None,\n        le: Optional[float] = None,\n        min_length: Optional[int] = None,\n        max_length: Optional[int] = None,\n        pattern: Optional[str] = None,\n        regex: Annotated[\n            Optional[str],\n            deprecated(\n                \"Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead.\"\n            ),\n        ] = None,\n        discriminator: Union[str, None] = None,\n        strict: Union[bool, None] = _Unset,\n        multiple_of: Union[float, None] = _Unset,\n        allow_inf_nan: Union[bool, None] = _Unset,\n        max_digits: Union[int, None] = _Unset,\n        decimal_places: Union[int, None] = _Unset,\n        examples: Optional[List[Any]] = None,\n        example: Annotated[\n            Optional[Any],\n            deprecated(\n                \"Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, \"\n                \"although still supported. Use examples instead.\"\n            ),\n        ] = _Unset,\n        openapi_examples: Optional[Dict[str, Example]] = None,\n        deprecated: Union[deprecated, str, bool, None] = None,\n        include_in_schema: bool = True,\n        json_schema_extra: Union[Dict[str, Any], None] = None,\n        **extra: Any,\n    ):\n        super().__init__(\n            default=default,\n            default_factory=default_factory,\n            annotation=annotation,\n            alias=alias,\n            alias_priority=alias_priority,\n            validation_alias=validation_alias,\n            serialization_alias=serialization_alias,\n            title=title,\n            description=description,\n            gt=gt,\n            ge=ge,\n            lt=lt,\n            le=le,\n            min_length=min_length,\n            max_length=max_length,\n            pattern=pattern,\n            regex=regex,\n            discriminator=discriminator,\n            strict=strict,\n            multiple_of=multiple_of,\n            allow_inf_nan=allow_inf_nan,\n            max_digits=max_digits,\n            decimal_places=decimal_places,\n            deprecated=deprecated,\n            example=example,\n            examples=examples,\n            openapi_examples=openapi_examples,\n            include_in_schema=include_in_schema,\n            json_schema_extra=json_schema_extra,\n            **extra,\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "default"
      ],
      "imports": [
        "warnings",
        "enum.Enum",
        "typing.Any",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Union",
        "fastapi.openapi.models.Example",
        "pydantic.fields.FieldInfo",
        "typing_extensions.Annotated",
        "typing_extensions.deprecated",
        "_compat.PYDANTIC_V2",
        "_compat.PYDANTIC_VERSION_MINOR_TUPLE",
        "_compat.Undefined"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "params",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\params.py",
      "line_number": 312,
      "end_line_number": 392,
      "source_code": "def __init__(\n        self,\n        default: Any = Undefined,\n        *,\n        default_factory: Union[Callable[[], Any], None] = _Unset,\n        annotation: Optional[Any] = None,\n        alias: Optional[str] = None,\n        alias_priority: Union[int, None] = _Unset,\n        # TODO: update when deprecating Pydantic v1, import these types\n        # validation_alias: str | AliasPath | AliasChoices | None\n        validation_alias: Union[str, None] = None,\n        serialization_alias: Union[str, None] = None,\n        convert_underscores: bool = True,\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n        gt: Optional[float] = None,\n        ge: Optional[float] = None,\n        lt: Optional[float] = None,\n        le: Optional[float] = None,\n        min_length: Optional[int] = None,\n        max_length: Optional[int] = None,\n        pattern: Optional[str] = None,\n        regex: Annotated[\n            Optional[str],\n            deprecated(\n                \"Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead.\"\n            ),\n        ] = None,\n        discriminator: Union[str, None] = None,\n        strict: Union[bool, None] = _Unset,\n        multiple_of: Union[float, None] = _Unset,\n        allow_inf_nan: Union[bool, None] = _Unset,\n        max_digits: Union[int, None] = _Unset,\n        decimal_places: Union[int, None] = _Unset,\n        examples: Optional[List[Any]] = None,\n        example: Annotated[\n            Optional[Any],\n            deprecated(\n                \"Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, \"\n                \"although still supported. Use examples instead.\"\n            ),\n        ] = _Unset,\n        openapi_examples: Optional[Dict[str, Example]] = None,\n        deprecated: Union[deprecated, str, bool, None] = None,\n        include_in_schema: bool = True,\n        json_schema_extra: Union[Dict[str, Any], None] = None,\n        **extra: Any,\n    ):\n        self.convert_underscores = convert_underscores\n        super().__init__(\n            default=default,\n            default_factory=default_factory,\n            annotation=annotation,\n            alias=alias,\n            alias_priority=alias_priority,\n            validation_alias=validation_alias,\n            serialization_alias=serialization_alias,\n            title=title,\n            description=description,\n            gt=gt,\n            ge=ge,\n            lt=lt,\n            le=le,\n            min_length=min_length,\n            max_length=max_length,\n            pattern=pattern,\n            regex=regex,\n            discriminator=discriminator,\n            strict=strict,\n            multiple_of=multiple_of,\n            allow_inf_nan=allow_inf_nan,\n            max_digits=max_digits,\n            decimal_places=decimal_places,\n            deprecated=deprecated,\n            example=example,\n            examples=examples,\n            openapi_examples=openapi_examples,\n            include_in_schema=include_in_schema,\n            json_schema_extra=json_schema_extra,\n            **extra,\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "default"
      ],
      "imports": [
        "warnings",
        "enum.Enum",
        "typing.Any",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Union",
        "fastapi.openapi.models.Example",
        "pydantic.fields.FieldInfo",
        "typing_extensions.Annotated",
        "typing_extensions.deprecated",
        "_compat.PYDANTIC_V2",
        "_compat.PYDANTIC_VERSION_MINOR_TUPLE",
        "_compat.Undefined"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "params",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\params.py",
      "line_number": 398,
      "end_line_number": 476,
      "source_code": "def __init__(\n        self,\n        default: Any = Undefined,\n        *,\n        default_factory: Union[Callable[[], Any], None] = _Unset,\n        annotation: Optional[Any] = None,\n        alias: Optional[str] = None,\n        alias_priority: Union[int, None] = _Unset,\n        # TODO: update when deprecating Pydantic v1, import these types\n        # validation_alias: str | AliasPath | AliasChoices | None\n        validation_alias: Union[str, None] = None,\n        serialization_alias: Union[str, None] = None,\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n        gt: Optional[float] = None,\n        ge: Optional[float] = None,\n        lt: Optional[float] = None,\n        le: Optional[float] = None,\n        min_length: Optional[int] = None,\n        max_length: Optional[int] = None,\n        pattern: Optional[str] = None,\n        regex: Annotated[\n            Optional[str],\n            deprecated(\n                \"Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead.\"\n            ),\n        ] = None,\n        discriminator: Union[str, None] = None,\n        strict: Union[bool, None] = _Unset,\n        multiple_of: Union[float, None] = _Unset,\n        allow_inf_nan: Union[bool, None] = _Unset,\n        max_digits: Union[int, None] = _Unset,\n        decimal_places: Union[int, None] = _Unset,\n        examples: Optional[List[Any]] = None,\n        example: Annotated[\n            Optional[Any],\n            deprecated(\n                \"Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, \"\n                \"although still supported. Use examples instead.\"\n            ),\n        ] = _Unset,\n        openapi_examples: Optional[Dict[str, Example]] = None,\n        deprecated: Union[deprecated, str, bool, None] = None,\n        include_in_schema: bool = True,\n        json_schema_extra: Union[Dict[str, Any], None] = None,\n        **extra: Any,\n    ):\n        super().__init__(\n            default=default,\n            default_factory=default_factory,\n            annotation=annotation,\n            alias=alias,\n            alias_priority=alias_priority,\n            validation_alias=validation_alias,\n            serialization_alias=serialization_alias,\n            title=title,\n            description=description,\n            gt=gt,\n            ge=ge,\n            lt=lt,\n            le=le,\n            min_length=min_length,\n            max_length=max_length,\n            pattern=pattern,\n            regex=regex,\n            discriminator=discriminator,\n            strict=strict,\n            multiple_of=multiple_of,\n            allow_inf_nan=allow_inf_nan,\n            max_digits=max_digits,\n            decimal_places=decimal_places,\n            deprecated=deprecated,\n            example=example,\n            examples=examples,\n            openapi_examples=openapi_examples,\n            include_in_schema=include_in_schema,\n            json_schema_extra=json_schema_extra,\n            **extra,\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "default"
      ],
      "imports": [
        "warnings",
        "enum.Enum",
        "typing.Any",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Union",
        "fastapi.openapi.models.Example",
        "pydantic.fields.FieldInfo",
        "typing_extensions.Annotated",
        "typing_extensions.deprecated",
        "_compat.PYDANTIC_V2",
        "_compat.PYDANTIC_VERSION_MINOR_TUPLE",
        "_compat.Undefined"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "params",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\params.py",
      "line_number": 480,
      "end_line_number": 590,
      "source_code": "def __init__(\n        self,\n        default: Any = Undefined,\n        *,\n        default_factory: Union[Callable[[], Any], None] = _Unset,\n        annotation: Optional[Any] = None,\n        embed: Union[bool, None] = None,\n        media_type: str = \"application/json\",\n        alias: Optional[str] = None,\n        alias_priority: Union[int, None] = _Unset,\n        # TODO: update when deprecating Pydantic v1, import these types\n        # validation_alias: str | AliasPath | AliasChoices | None\n        validation_alias: Union[str, None] = None,\n        serialization_alias: Union[str, None] = None,\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n        gt: Optional[float] = None,\n        ge: Optional[float] = None,\n        lt: Optional[float] = None,\n        le: Optional[float] = None,\n        min_length: Optional[int] = None,\n        max_length: Optional[int] = None,\n        pattern: Optional[str] = None,\n        regex: Annotated[\n            Optional[str],\n            deprecated(\n                \"Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead.\"\n            ),\n        ] = None,\n        discriminator: Union[str, None] = None,\n        strict: Union[bool, None] = _Unset,\n        multiple_of: Union[float, None] = _Unset,\n        allow_inf_nan: Union[bool, None] = _Unset,\n        max_digits: Union[int, None] = _Unset,\n        decimal_places: Union[int, None] = _Unset,\n        examples: Optional[List[Any]] = None,\n        example: Annotated[\n            Optional[Any],\n            deprecated(\n                \"Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, \"\n                \"although still supported. Use examples instead.\"\n            ),\n        ] = _Unset,\n        openapi_examples: Optional[Dict[str, Example]] = None,\n        deprecated: Union[deprecated, str, bool, None] = None,\n        include_in_schema: bool = True,\n        json_schema_extra: Union[Dict[str, Any], None] = None,\n        **extra: Any,\n    ):\n        self.embed = embed\n        self.media_type = media_type\n        if example is not _Unset:\n            warnings.warn(\n                \"`example` has been deprecated, please use `examples` instead\",\n                category=DeprecationWarning,\n                stacklevel=4,\n            )\n        self.example = example\n        self.include_in_schema = include_in_schema\n        self.openapi_examples = openapi_examples\n        kwargs = dict(\n            default=default,\n            default_factory=default_factory,\n            alias=alias,\n            title=title,\n            description=description,\n            gt=gt,\n            ge=ge,\n            lt=lt,\n            le=le,\n            min_length=min_length,\n            max_length=max_length,\n            discriminator=discriminator,\n            multiple_of=multiple_of,\n            allow_inf_nan=allow_inf_nan,\n            max_digits=max_digits,\n            decimal_places=decimal_places,\n            **extra,\n        )\n        if examples is not None:\n            kwargs[\"examples\"] = examples\n        if regex is not None:\n            warnings.warn(\n                \"`regex` has been deprecated, please use `pattern` instead\",\n                category=DeprecationWarning,\n                stacklevel=4,\n            )\n        current_json_schema_extra = json_schema_extra or extra\n        if PYDANTIC_VERSION_MINOR_TUPLE < (2, 7):\n            self.deprecated = deprecated\n        else:\n            kwargs[\"deprecated\"] = deprecated\n        if PYDANTIC_V2:\n            kwargs.update(\n                {\n                    \"annotation\": annotation,\n                    \"alias_priority\": alias_priority,\n                    \"validation_alias\": validation_alias,\n                    \"serialization_alias\": serialization_alias,\n                    \"strict\": strict,\n                    \"json_schema_extra\": current_json_schema_extra,\n                }\n            )\n            kwargs[\"pattern\"] = pattern or regex\n        else:\n            kwargs[\"regex\"] = pattern or regex\n            kwargs.update(**current_json_schema_extra)\n\n        use_kwargs = {k: v for k, v in kwargs.items() if v is not _Unset}\n\n        super().__init__(**use_kwargs)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "default"
      ],
      "imports": [
        "warnings",
        "enum.Enum",
        "typing.Any",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Union",
        "fastapi.openapi.models.Example",
        "pydantic.fields.FieldInfo",
        "typing_extensions.Annotated",
        "typing_extensions.deprecated",
        "_compat.PYDANTIC_V2",
        "_compat.PYDANTIC_VERSION_MINOR_TUPLE",
        "_compat.Undefined"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__repr__",
      "module": "params",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\params.py",
      "line_number": 592,
      "end_line_number": 593,
      "source_code": "def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}({self.default})\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "warnings",
        "enum.Enum",
        "typing.Any",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Union",
        "fastapi.openapi.models.Example",
        "pydantic.fields.FieldInfo",
        "typing_extensions.Annotated",
        "typing_extensions.deprecated",
        "_compat.PYDANTIC_V2",
        "_compat.PYDANTIC_VERSION_MINOR_TUPLE",
        "_compat.Undefined"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "params",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\params.py",
      "line_number": 597,
      "end_line_number": 677,
      "source_code": "def __init__(\n        self,\n        default: Any = Undefined,\n        *,\n        default_factory: Union[Callable[[], Any], None] = _Unset,\n        annotation: Optional[Any] = None,\n        media_type: str = \"application/x-www-form-urlencoded\",\n        alias: Optional[str] = None,\n        alias_priority: Union[int, None] = _Unset,\n        # TODO: update when deprecating Pydantic v1, import these types\n        # validation_alias: str | AliasPath | AliasChoices | None\n        validation_alias: Union[str, None] = None,\n        serialization_alias: Union[str, None] = None,\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n        gt: Optional[float] = None,\n        ge: Optional[float] = None,\n        lt: Optional[float] = None,\n        le: Optional[float] = None,\n        min_length: Optional[int] = None,\n        max_length: Optional[int] = None,\n        pattern: Optional[str] = None,\n        regex: Annotated[\n            Optional[str],\n            deprecated(\n                \"Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead.\"\n            ),\n        ] = None,\n        discriminator: Union[str, None] = None,\n        strict: Union[bool, None] = _Unset,\n        multiple_of: Union[float, None] = _Unset,\n        allow_inf_nan: Union[bool, None] = _Unset,\n        max_digits: Union[int, None] = _Unset,\n        decimal_places: Union[int, None] = _Unset,\n        examples: Optional[List[Any]] = None,\n        example: Annotated[\n            Optional[Any],\n            deprecated(\n                \"Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, \"\n                \"although still supported. Use examples instead.\"\n            ),\n        ] = _Unset,\n        openapi_examples: Optional[Dict[str, Example]] = None,\n        deprecated: Union[deprecated, str, bool, None] = None,\n        include_in_schema: bool = True,\n        json_schema_extra: Union[Dict[str, Any], None] = None,\n        **extra: Any,\n    ):\n        super().__init__(\n            default=default,\n            default_factory=default_factory,\n            annotation=annotation,\n            media_type=media_type,\n            alias=alias,\n            alias_priority=alias_priority,\n            validation_alias=validation_alias,\n            serialization_alias=serialization_alias,\n            title=title,\n            description=description,\n            gt=gt,\n            ge=ge,\n            lt=lt,\n            le=le,\n            min_length=min_length,\n            max_length=max_length,\n            pattern=pattern,\n            regex=regex,\n            discriminator=discriminator,\n            strict=strict,\n            multiple_of=multiple_of,\n            allow_inf_nan=allow_inf_nan,\n            max_digits=max_digits,\n            decimal_places=decimal_places,\n            deprecated=deprecated,\n            example=example,\n            examples=examples,\n            openapi_examples=openapi_examples,\n            include_in_schema=include_in_schema,\n            json_schema_extra=json_schema_extra,\n            **extra,\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "default"
      ],
      "imports": [
        "warnings",
        "enum.Enum",
        "typing.Any",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Union",
        "fastapi.openapi.models.Example",
        "pydantic.fields.FieldInfo",
        "typing_extensions.Annotated",
        "typing_extensions.deprecated",
        "_compat.PYDANTIC_V2",
        "_compat.PYDANTIC_VERSION_MINOR_TUPLE",
        "_compat.Undefined"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "params",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\params.py",
      "line_number": 681,
      "end_line_number": 761,
      "source_code": "def __init__(\n        self,\n        default: Any = Undefined,\n        *,\n        default_factory: Union[Callable[[], Any], None] = _Unset,\n        annotation: Optional[Any] = None,\n        media_type: str = \"multipart/form-data\",\n        alias: Optional[str] = None,\n        alias_priority: Union[int, None] = _Unset,\n        # TODO: update when deprecating Pydantic v1, import these types\n        # validation_alias: str | AliasPath | AliasChoices | None\n        validation_alias: Union[str, None] = None,\n        serialization_alias: Union[str, None] = None,\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n        gt: Optional[float] = None,\n        ge: Optional[float] = None,\n        lt: Optional[float] = None,\n        le: Optional[float] = None,\n        min_length: Optional[int] = None,\n        max_length: Optional[int] = None,\n        pattern: Optional[str] = None,\n        regex: Annotated[\n            Optional[str],\n            deprecated(\n                \"Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead.\"\n            ),\n        ] = None,\n        discriminator: Union[str, None] = None,\n        strict: Union[bool, None] = _Unset,\n        multiple_of: Union[float, None] = _Unset,\n        allow_inf_nan: Union[bool, None] = _Unset,\n        max_digits: Union[int, None] = _Unset,\n        decimal_places: Union[int, None] = _Unset,\n        examples: Optional[List[Any]] = None,\n        example: Annotated[\n            Optional[Any],\n            deprecated(\n                \"Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, \"\n                \"although still supported. Use examples instead.\"\n            ),\n        ] = _Unset,\n        openapi_examples: Optional[Dict[str, Example]] = None,\n        deprecated: Union[deprecated, str, bool, None] = None,\n        include_in_schema: bool = True,\n        json_schema_extra: Union[Dict[str, Any], None] = None,\n        **extra: Any,\n    ):\n        super().__init__(\n            default=default,\n            default_factory=default_factory,\n            annotation=annotation,\n            media_type=media_type,\n            alias=alias,\n            alias_priority=alias_priority,\n            validation_alias=validation_alias,\n            serialization_alias=serialization_alias,\n            title=title,\n            description=description,\n            gt=gt,\n            ge=ge,\n            lt=lt,\n            le=le,\n            min_length=min_length,\n            max_length=max_length,\n            pattern=pattern,\n            regex=regex,\n            discriminator=discriminator,\n            strict=strict,\n            multiple_of=multiple_of,\n            allow_inf_nan=allow_inf_nan,\n            max_digits=max_digits,\n            decimal_places=decimal_places,\n            deprecated=deprecated,\n            example=example,\n            examples=examples,\n            openapi_examples=openapi_examples,\n            include_in_schema=include_in_schema,\n            json_schema_extra=json_schema_extra,\n            **extra,\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "default"
      ],
      "imports": [
        "warnings",
        "enum.Enum",
        "typing.Any",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Union",
        "fastapi.openapi.models.Example",
        "pydantic.fields.FieldInfo",
        "typing_extensions.Annotated",
        "typing_extensions.deprecated",
        "_compat.PYDANTIC_V2",
        "_compat.PYDANTIC_VERSION_MINOR_TUPLE",
        "_compat.Undefined"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "params",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\params.py",
      "line_number": 765,
      "end_line_number": 769,
      "source_code": "def __init__(\n        self, dependency: Optional[Callable[..., Any]] = None, *, use_cache: bool = True\n    ):\n        self.dependency = dependency\n        self.use_cache = use_cache",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "dependency"
      ],
      "imports": [
        "warnings",
        "enum.Enum",
        "typing.Any",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Union",
        "fastapi.openapi.models.Example",
        "pydantic.fields.FieldInfo",
        "typing_extensions.Annotated",
        "typing_extensions.deprecated",
        "_compat.PYDANTIC_V2",
        "_compat.PYDANTIC_VERSION_MINOR_TUPLE",
        "_compat.Undefined"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__repr__",
      "module": "params",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\params.py",
      "line_number": 771,
      "end_line_number": 774,
      "source_code": "def __repr__(self) -> str:\n        attr = getattr(self.dependency, \"__name__\", type(self.dependency).__name__)\n        cache = \"\" if self.use_cache else \", use_cache=False\"\n        return f\"{self.__class__.__name__}({attr}{cache})\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "warnings",
        "enum.Enum",
        "typing.Any",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Union",
        "fastapi.openapi.models.Example",
        "pydantic.fields.FieldInfo",
        "typing_extensions.Annotated",
        "typing_extensions.deprecated",
        "_compat.PYDANTIC_V2",
        "_compat.PYDANTIC_VERSION_MINOR_TUPLE",
        "_compat.Undefined"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "params",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\params.py",
      "line_number": 778,
      "end_line_number": 786,
      "source_code": "def __init__(\n        self,\n        dependency: Optional[Callable[..., Any]] = None,\n        *,\n        scopes: Optional[Sequence[str]] = None,\n        use_cache: bool = True,\n    ):\n        super().__init__(dependency=dependency, use_cache=use_cache)\n        self.scopes = scopes or []",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "dependency"
      ],
      "imports": [
        "warnings",
        "enum.Enum",
        "typing.Any",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Union",
        "fastapi.openapi.models.Example",
        "pydantic.fields.FieldInfo",
        "typing_extensions.Annotated",
        "typing_extensions.deprecated",
        "_compat.PYDANTIC_V2",
        "_compat.PYDANTIC_VERSION_MINOR_TUPLE",
        "_compat.Undefined"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "Path",
      "module": "param_functions",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\param_functions.py",
      "line_number": 11,
      "end_line_number": 336,
      "source_code": "def Path(  # noqa: N802\n    default: Annotated[\n        Any,\n        Doc(\n            \"\"\"\n            Default value if the parameter field is not set.\n\n            This doesn't affect `Path` parameters as the value is always required.\n            The parameter is available only for compatibility.\n            \"\"\"\n        ),\n    ] = ...,\n    *,\n    default_factory: Annotated[\n        Union[Callable[[], Any], None],\n        Doc(\n            \"\"\"\n            A callable to generate the default value.\n\n            This doesn't affect `Path` parameters as the value is always required.\n            The parameter is available only for compatibility.\n            \"\"\"\n        ),\n    ] = _Unset,\n    alias: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            An alternative name for the parameter field.\n\n            This will be used to extract the data and for the generated OpenAPI.\n            It is particularly useful when you can't use the name you want because it\n            is a Python reserved keyword or similar.\n            \"\"\"\n        ),\n    ] = None,\n    alias_priority: Annotated[\n        Union[int, None],\n        Doc(\n            \"\"\"\n            Priority of the alias. This affects whether an alias generator is used.\n            \"\"\"\n        ),\n    ] = _Unset,\n    # TODO: update when deprecating Pydantic v1, import these types\n    # validation_alias: str | AliasPath | AliasChoices | None\n    validation_alias: Annotated[\n        Union[str, None],\n        Doc(\n            \"\"\"\n            'Whitelist' validation step. The parameter field will be the single one\n            allowed by the alias or set of aliases defined.\n            \"\"\"\n        ),\n    ] = None,\n    serialization_alias: Annotated[\n        Union[str, None],\n        Doc(\n            \"\"\"\n            'Blacklist' validation step. The vanilla parameter field will be the\n            single one of the alias' or set of aliases' fields and all the other\n            fields will be ignored at serialization time.\n            \"\"\"\n        ),\n    ] = None,\n    title: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            Human-readable title.\n            \"\"\"\n        ),\n    ] = None,\n    description: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            Human-readable description.\n            \"\"\"\n        ),\n    ] = None,\n    gt: Annotated[\n        Optional[float],\n        Doc(\n            \"\"\"\n            Greater than. If set, value must be greater than this. Only applicable to\n            numbers.\n            \"\"\"\n        ),\n    ] = None,\n    ge: Annotated[\n        Optional[float],\n        Doc(\n            \"\"\"\n            Greater than or equal. If set, value must be greater than or equal to\n            this. Only applicable to numbers.\n            \"\"\"\n        ),\n    ] = None,\n    lt: Annotated[\n        Optional[float],\n        Doc(\n            \"\"\"\n            Less than. If set, value must be less than this. Only applicable to numbers.\n            \"\"\"\n        ),\n    ] = None,\n    le: Annotated[\n        Optional[float],\n        Doc(\n            \"\"\"\n            Less than or equal. If set, value must be less than or equal to this.\n            Only applicable to numbers.\n            \"\"\"\n        ),\n    ] = None,\n    min_length: Annotated[\n        Optional[int],\n        Doc(\n            \"\"\"\n            Minimum length for strings.\n            \"\"\"\n        ),\n    ] = None,\n    max_length: Annotated[\n        Optional[int],\n        Doc(\n            \"\"\"\n            Maximum length for strings.\n            \"\"\"\n        ),\n    ] = None,\n    pattern: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            RegEx pattern for strings.\n            \"\"\"\n        ),\n    ] = None,\n    regex: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            RegEx pattern for strings.\n            \"\"\"\n        ),\n        deprecated(\n            \"Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead.\"\n        ),\n    ] = None,\n    discriminator: Annotated[\n        Union[str, None],\n        Doc(\n            \"\"\"\n            Parameter field name for discriminating the type in a tagged union.\n            \"\"\"\n        ),\n    ] = None,\n    strict: Annotated[\n        Union[bool, None],\n        Doc(\n            \"\"\"\n            If `True`, strict validation is applied to the field.\n            \"\"\"\n        ),\n    ] = _Unset,\n    multiple_of: Annotated[\n        Union[float, None],\n        Doc(\n            \"\"\"\n            Value must be a multiple of this. Only applicable to numbers.\n            \"\"\"\n        ),\n    ] = _Unset,\n    allow_inf_nan: Annotated[\n        Union[bool, None],\n        Doc(\n            \"\"\"\n            Allow `inf`, `-inf`, `nan`. Only applicable to numbers.\n            \"\"\"\n        ),\n    ] = _Unset,\n    max_digits: Annotated[\n        Union[int, None],\n        Doc(\n            \"\"\"\n            Maximum number of allow digits for strings.\n            \"\"\"\n        ),\n    ] = _Unset,\n    decimal_places: Annotated[\n        Union[int, None],\n        Doc(\n            \"\"\"\n            Maximum number of decimal places allowed for numbers.\n            \"\"\"\n        ),\n    ] = _Unset,\n    examples: Annotated[\n        Optional[List[Any]],\n        Doc(\n            \"\"\"\n            Example values for this field.\n            \"\"\"\n        ),\n    ] = None,\n    example: Annotated[\n        Optional[Any],\n        deprecated(\n            \"Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, \"\n            \"although still supported. Use examples instead.\"\n        ),\n    ] = _Unset,\n    openapi_examples: Annotated[\n        Optional[Dict[str, Example]],\n        Doc(\n            \"\"\"\n            OpenAPI-specific examples.\n\n            It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n            Swagger UI (that provides the `/docs` interface) has better support for the\n            OpenAPI-specific examples than the JSON Schema `examples`, that's the main\n            use case for this.\n\n            Read more about it in the\n            [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).\n            \"\"\"\n        ),\n    ] = None,\n    deprecated: Annotated[\n        Union[deprecated, str, bool, None],\n        Doc(\n            \"\"\"\n            Mark this parameter field as deprecated.\n\n            It will affect the generated OpenAPI (e.g. visible at `/docs`).\n            \"\"\"\n        ),\n    ] = None,\n    include_in_schema: Annotated[\n        bool,\n        Doc(\n            \"\"\"\n            To include (or not) this parameter field in the generated OpenAPI.\n            You probably don't need it, but it's available.\n\n            This affects the generated OpenAPI (e.g. visible at `/docs`).\n            \"\"\"\n        ),\n    ] = True,\n    json_schema_extra: Annotated[\n        Union[Dict[str, Any], None],\n        Doc(\n            \"\"\"\n            Any additional JSON schema data.\n            \"\"\"\n        ),\n    ] = None,\n    **extra: Annotated[\n        Any,\n        Doc(\n            \"\"\"\n            Include extra fields used by the JSON Schema.\n            \"\"\"\n        ),\n        deprecated(\n            \"\"\"\n            The `extra` kwargs is deprecated. Use `json_schema_extra` instead.\n            \"\"\"\n        ),\n    ],\n) -> Any:\n    \"\"\"\n    Declare a path parameter for a *path operation*.\n\n    Read more about it in the\n    [FastAPI docs for Path Parameters and Numeric Validations](https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/).\n\n    ```python\n    from typing import Annotated\n\n    from fastapi import FastAPI, Path\n\n    app = FastAPI()\n\n\n    @app.get(\"/items/{item_id}\")\n    async def read_items(\n        item_id: Annotated[int, Path(title=\"The ID of the item to get\")],\n    ):\n        return {\"item_id\": item_id}\n    ```\n    \"\"\"\n    return params.Path(\n        default=default,\n        default_factory=default_factory,\n        alias=alias,\n        alias_priority=alias_priority,\n        validation_alias=validation_alias,\n        serialization_alias=serialization_alias,\n        title=title,\n        description=description,\n        gt=gt,\n        ge=ge,\n        lt=lt,\n        le=le,\n        min_length=min_length,\n        max_length=max_length,\n        pattern=pattern,\n        regex=regex,\n        discriminator=discriminator,\n        strict=strict,\n        multiple_of=multiple_of,\n        allow_inf_nan=allow_inf_nan,\n        max_digits=max_digits,\n        decimal_places=decimal_places,\n        example=example,\n        examples=examples,\n        openapi_examples=openapi_examples,\n        deprecated=deprecated,\n        include_in_schema=include_in_schema,\n        json_schema_extra=json_schema_extra,\n        **extra,\n    )",
      "docstring": "Declare a path parameter for a *path operation*.\n\nRead more about it in the\n[FastAPI docs for Path Parameters and Numeric Validations](https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/).\n\n```python\nfrom typing import Annotated\n\nfrom fastapi import FastAPI, Path\n\napp = FastAPI()\n\n\n@app.get(\"/items/{item_id}\")\nasync def read_items(\n    item_id: Annotated[int, Path(title=\"The ID of the item to get\")],\n):\n    return {\"item_id\": item_id}\n```",
      "decorators": [],
      "arguments": [
        "default"
      ],
      "imports": [
        "typing.Any",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Union",
        "fastapi.params",
        "fastapi._compat.Undefined",
        "fastapi.openapi.models.Example",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "params.Path",
          "body": "def Path(default: Annotated[Any, Doc(\"\\n            Default value if the parameter field is not set.\\n\\n            This doesn't affect `Path` parameters as the value is always required.\\n            The parameter is available only for compatibility.\\n            \")]=..., *, default_factory: Annotated[Union[Callable[[], Any], None], Doc(\"\\n            A callable to generate the default value.\\n\\n            This doesn't affect `Path` parameters as the value is always required.\\n            The parameter is available only for compatibility.\\n            \")]=_Unset, alias: Annotated[Optional[str], Doc(\"\\n            An alternative name for the parameter field.\\n\\n            This will be used to extract the data and for the generated OpenAPI.\\n            It is particularly useful when you can't use the name you want because it\\n            is a Python reserved keyword or similar.\\n            \")]=None, alias_priority: Annotated[Union[int, None], Doc('\\n            Priority of the alias. This affects whether an alias generator is used.\\n            ')]=_Unset, validation_alias: Annotated[Union[str, None], Doc(\"\\n            'Whitelist' validation step. The parameter field will be the single one\\n            allowed by the alias or set of aliases defined.\\n            \")]=None, serialization_alias: Annotated[Union[str, None], Doc(\"\\n            'Blacklist' validation step. The vanilla parameter field will be the\\n            single one of the alias' or set of aliases' fields and all the other\\n            fields will be ignored at serialization time.\\n            \")]=None, title: Annotated[Optional[str], Doc('\\n            Human-readable title.\\n            ')]=None, description: Annotated[Optional[str], Doc('\\n            Human-readable description.\\n            ')]=None, gt: Annotated[Optional[float], Doc('\\n            Greater than. If set, value must be greater than this. Only applicable to\\n            numbers.\\n            ')]=None, ge: Annotated[Optional[float], Doc('\\n            Greater than or equal. If set, value must be greater than or equal to\\n            this. Only applicable to numbers.\\n            ')]=None, lt: Annotated[Optional[float], Doc('\\n            Less than. If set, value must be less than this. Only applicable to numbers.\\n            ')]=None, le: Annotated[Optional[float], Doc('\\n            Less than or equal. If set, value must be less than or equal to this.\\n            Only applicable to numbers.\\n            ')]=None, min_length: Annotated[Optional[int], Doc('\\n            Minimum length for strings.\\n            ')]=None, max_length: Annotated[Optional[int], Doc('\\n            Maximum length for strings.\\n            ')]=None, pattern: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            ')]=None, regex: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            '), deprecated('Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead.')]=None, discriminator: Annotated[Union[str, None], Doc('\\n            Parameter field name for discriminating the type in a tagged union.\\n            ')]=None, strict: Annotated[Union[bool, None], Doc('\\n            If `True`, strict validation is applied to the field.\\n            ')]=_Unset, multiple_of: Annotated[Union[float, None], Doc('\\n            Value must be a multiple of this. Only applicable to numbers.\\n            ')]=_Unset, allow_inf_nan: Annotated[Union[bool, None], Doc('\\n            Allow `inf`, `-inf`, `nan`. Only applicable to numbers.\\n            ')]=_Unset, max_digits: Annotated[Union[int, None], Doc('\\n            Maximum number of allow digits for strings.\\n            ')]=_Unset, decimal_places: Annotated[Union[int, None], Doc('\\n            Maximum number of decimal places allowed for numbers.\\n            ')]=_Unset, examples: Annotated[Optional[List[Any]], Doc('\\n            Example values for this field.\\n            ')]=None, example: Annotated[Optional[Any], deprecated('Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.')]=_Unset, openapi_examples: Annotated[Optional[Dict[str, Example]], Doc(\"\\n            OpenAPI-specific examples.\\n\\n            It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n            Swagger UI (that provides the `/docs` interface) has better support for the\\n            OpenAPI-specific examples than the JSON Schema `examples`, that's the main\\n            use case for this.\\n\\n            Read more about it in the\\n            [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).\\n            \")]=None, deprecated: Annotated[Union[deprecated, str, bool, None], Doc('\\n            Mark this parameter field as deprecated.\\n\\n            It will affect the generated OpenAPI (e.g. visible at `/docs`).\\n            ')]=None, include_in_schema: Annotated[bool, Doc(\"\\n            To include (or not) this parameter field in the generated OpenAPI.\\n            You probably don't need it, but it's available.\\n\\n            This affects the generated OpenAPI (e.g. visible at `/docs`).\\n            \")]=True, json_schema_extra: Annotated[Union[Dict[str, Any], None], Doc('\\n            Any additional JSON schema data.\\n            ')]=None, **extra: Annotated[Any, Doc('\\n            Include extra fields used by the JSON Schema.\\n            '), deprecated('\\n            The `extra` kwargs is deprecated. Use `json_schema_extra` instead.\\n            ')]) -> Any:\n    \"\"\"\n    Declare a path parameter for a *path operation*.\n\n    Read more about it in the\n    [FastAPI docs for Path Parameters and Numeric Validations](https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/).\n\n    ```python\n    from typing import Annotated\n\n    from fastapi import FastAPI, Path\n\n    app = FastAPI()\n\n\n    @app.get(\"/items/{item_id}\")\n    async def read_items(\n        item_id: Annotated[int, Path(title=\"The ID of the item to get\")],\n    ):\n        return {\"item_id\": item_id}\n    ```\n    \"\"\"\n    return params.Path(default=default, default_factory=default_factory, alias=alias, alias_priority=alias_priority, validation_alias=validation_alias, serialization_alias=serialization_alias, title=title, description=description, gt=gt, ge=ge, lt=lt, le=le, min_length=min_length, max_length=max_length, pattern=pattern, regex=regex, discriminator=discriminator, strict=strict, multiple_of=multiple_of, allow_inf_nan=allow_inf_nan, max_digits=max_digits, decimal_places=decimal_places, example=example, examples=examples, openapi_examples=openapi_examples, deprecated=deprecated, include_in_schema=include_in_schema, json_schema_extra=json_schema_extra, **extra)"
        }
      ]
    },
    {
      "name": "Query",
      "module": "param_functions",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\param_functions.py",
      "line_number": 339,
      "end_line_number": 640,
      "source_code": "def Query(  # noqa: N802\n    default: Annotated[\n        Any,\n        Doc(\n            \"\"\"\n            Default value if the parameter field is not set.\n            \"\"\"\n        ),\n    ] = Undefined,\n    *,\n    default_factory: Annotated[\n        Union[Callable[[], Any], None],\n        Doc(\n            \"\"\"\n            A callable to generate the default value.\n\n            This doesn't affect `Path` parameters as the value is always required.\n            The parameter is available only for compatibility.\n            \"\"\"\n        ),\n    ] = _Unset,\n    alias: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            An alternative name for the parameter field.\n\n            This will be used to extract the data and for the generated OpenAPI.\n            It is particularly useful when you can't use the name you want because it\n            is a Python reserved keyword or similar.\n            \"\"\"\n        ),\n    ] = None,\n    alias_priority: Annotated[\n        Union[int, None],\n        Doc(\n            \"\"\"\n            Priority of the alias. This affects whether an alias generator is used.\n            \"\"\"\n        ),\n    ] = _Unset,\n    # TODO: update when deprecating Pydantic v1, import these types\n    # validation_alias: str | AliasPath | AliasChoices | None\n    validation_alias: Annotated[\n        Union[str, None],\n        Doc(\n            \"\"\"\n            'Whitelist' validation step. The parameter field will be the single one\n            allowed by the alias or set of aliases defined.\n            \"\"\"\n        ),\n    ] = None,\n    serialization_alias: Annotated[\n        Union[str, None],\n        Doc(\n            \"\"\"\n            'Blacklist' validation step. The vanilla parameter field will be the\n            single one of the alias' or set of aliases' fields and all the other\n            fields will be ignored at serialization time.\n            \"\"\"\n        ),\n    ] = None,\n    title: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            Human-readable title.\n            \"\"\"\n        ),\n    ] = None,\n    description: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            Human-readable description.\n            \"\"\"\n        ),\n    ] = None,\n    gt: Annotated[\n        Optional[float],\n        Doc(\n            \"\"\"\n            Greater than. If set, value must be greater than this. Only applicable to\n            numbers.\n            \"\"\"\n        ),\n    ] = None,\n    ge: Annotated[\n        Optional[float],\n        Doc(\n            \"\"\"\n            Greater than or equal. If set, value must be greater than or equal to\n            this. Only applicable to numbers.\n            \"\"\"\n        ),\n    ] = None,\n    lt: Annotated[\n        Optional[float],\n        Doc(\n            \"\"\"\n            Less than. If set, value must be less than this. Only applicable to numbers.\n            \"\"\"\n        ),\n    ] = None,\n    le: Annotated[\n        Optional[float],\n        Doc(\n            \"\"\"\n            Less than or equal. If set, value must be less than or equal to this.\n            Only applicable to numbers.\n            \"\"\"\n        ),\n    ] = None,\n    min_length: Annotated[\n        Optional[int],\n        Doc(\n            \"\"\"\n            Minimum length for strings.\n            \"\"\"\n        ),\n    ] = None,\n    max_length: Annotated[\n        Optional[int],\n        Doc(\n            \"\"\"\n            Maximum length for strings.\n            \"\"\"\n        ),\n    ] = None,\n    pattern: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            RegEx pattern for strings.\n            \"\"\"\n        ),\n    ] = None,\n    regex: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            RegEx pattern for strings.\n            \"\"\"\n        ),\n        deprecated(\n            \"Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead.\"\n        ),\n    ] = None,\n    discriminator: Annotated[\n        Union[str, None],\n        Doc(\n            \"\"\"\n            Parameter field name for discriminating the type in a tagged union.\n            \"\"\"\n        ),\n    ] = None,\n    strict: Annotated[\n        Union[bool, None],\n        Doc(\n            \"\"\"\n            If `True`, strict validation is applied to the field.\n            \"\"\"\n        ),\n    ] = _Unset,\n    multiple_of: Annotated[\n        Union[float, None],\n        Doc(\n            \"\"\"\n            Value must be a multiple of this. Only applicable to numbers.\n            \"\"\"\n        ),\n    ] = _Unset,\n    allow_inf_nan: Annotated[\n        Union[bool, None],\n        Doc(\n            \"\"\"\n            Allow `inf`, `-inf`, `nan`. Only applicable to numbers.\n            \"\"\"\n        ),\n    ] = _Unset,\n    max_digits: Annotated[\n        Union[int, None],\n        Doc(\n            \"\"\"\n            Maximum number of allow digits for strings.\n            \"\"\"\n        ),\n    ] = _Unset,\n    decimal_places: Annotated[\n        Union[int, None],\n        Doc(\n            \"\"\"\n            Maximum number of decimal places allowed for numbers.\n            \"\"\"\n        ),\n    ] = _Unset,\n    examples: Annotated[\n        Optional[List[Any]],\n        Doc(\n            \"\"\"\n            Example values for this field.\n            \"\"\"\n        ),\n    ] = None,\n    example: Annotated[\n        Optional[Any],\n        deprecated(\n            \"Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, \"\n            \"although still supported. Use examples instead.\"\n        ),\n    ] = _Unset,\n    openapi_examples: Annotated[\n        Optional[Dict[str, Example]],\n        Doc(\n            \"\"\"\n            OpenAPI-specific examples.\n\n            It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n            Swagger UI (that provides the `/docs` interface) has better support for the\n            OpenAPI-specific examples than the JSON Schema `examples`, that's the main\n            use case for this.\n\n            Read more about it in the\n            [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).\n            \"\"\"\n        ),\n    ] = None,\n    deprecated: Annotated[\n        Union[deprecated, str, bool, None],\n        Doc(\n            \"\"\"\n            Mark this parameter field as deprecated.\n\n            It will affect the generated OpenAPI (e.g. visible at `/docs`).\n            \"\"\"\n        ),\n    ] = None,\n    include_in_schema: Annotated[\n        bool,\n        Doc(\n            \"\"\"\n            To include (or not) this parameter field in the generated OpenAPI.\n            You probably don't need it, but it's available.\n\n            This affects the generated OpenAPI (e.g. visible at `/docs`).\n            \"\"\"\n        ),\n    ] = True,\n    json_schema_extra: Annotated[\n        Union[Dict[str, Any], None],\n        Doc(\n            \"\"\"\n            Any additional JSON schema data.\n            \"\"\"\n        ),\n    ] = None,\n    **extra: Annotated[\n        Any,\n        Doc(\n            \"\"\"\n            Include extra fields used by the JSON Schema.\n            \"\"\"\n        ),\n        deprecated(\n            \"\"\"\n            The `extra` kwargs is deprecated. Use `json_schema_extra` instead.\n            \"\"\"\n        ),\n    ],\n) -> Any:\n    return params.Query(\n        default=default,\n        default_factory=default_factory,\n        alias=alias,\n        alias_priority=alias_priority,\n        validation_alias=validation_alias,\n        serialization_alias=serialization_alias,\n        title=title,\n        description=description,\n        gt=gt,\n        ge=ge,\n        lt=lt,\n        le=le,\n        min_length=min_length,\n        max_length=max_length,\n        pattern=pattern,\n        regex=regex,\n        discriminator=discriminator,\n        strict=strict,\n        multiple_of=multiple_of,\n        allow_inf_nan=allow_inf_nan,\n        max_digits=max_digits,\n        decimal_places=decimal_places,\n        example=example,\n        examples=examples,\n        openapi_examples=openapi_examples,\n        deprecated=deprecated,\n        include_in_schema=include_in_schema,\n        json_schema_extra=json_schema_extra,\n        **extra,\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "default"
      ],
      "imports": [
        "typing.Any",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Union",
        "fastapi.params",
        "fastapi._compat.Undefined",
        "fastapi.openapi.models.Example",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "params.Query",
          "body": "def Query(default: Annotated[Any, Doc('\\n            Default value if the parameter field is not set.\\n            ')]=Undefined, *, default_factory: Annotated[Union[Callable[[], Any], None], Doc(\"\\n            A callable to generate the default value.\\n\\n            This doesn't affect `Path` parameters as the value is always required.\\n            The parameter is available only for compatibility.\\n            \")]=_Unset, alias: Annotated[Optional[str], Doc(\"\\n            An alternative name for the parameter field.\\n\\n            This will be used to extract the data and for the generated OpenAPI.\\n            It is particularly useful when you can't use the name you want because it\\n            is a Python reserved keyword or similar.\\n            \")]=None, alias_priority: Annotated[Union[int, None], Doc('\\n            Priority of the alias. This affects whether an alias generator is used.\\n            ')]=_Unset, validation_alias: Annotated[Union[str, None], Doc(\"\\n            'Whitelist' validation step. The parameter field will be the single one\\n            allowed by the alias or set of aliases defined.\\n            \")]=None, serialization_alias: Annotated[Union[str, None], Doc(\"\\n            'Blacklist' validation step. The vanilla parameter field will be the\\n            single one of the alias' or set of aliases' fields and all the other\\n            fields will be ignored at serialization time.\\n            \")]=None, title: Annotated[Optional[str], Doc('\\n            Human-readable title.\\n            ')]=None, description: Annotated[Optional[str], Doc('\\n            Human-readable description.\\n            ')]=None, gt: Annotated[Optional[float], Doc('\\n            Greater than. If set, value must be greater than this. Only applicable to\\n            numbers.\\n            ')]=None, ge: Annotated[Optional[float], Doc('\\n            Greater than or equal. If set, value must be greater than or equal to\\n            this. Only applicable to numbers.\\n            ')]=None, lt: Annotated[Optional[float], Doc('\\n            Less than. If set, value must be less than this. Only applicable to numbers.\\n            ')]=None, le: Annotated[Optional[float], Doc('\\n            Less than or equal. If set, value must be less than or equal to this.\\n            Only applicable to numbers.\\n            ')]=None, min_length: Annotated[Optional[int], Doc('\\n            Minimum length for strings.\\n            ')]=None, max_length: Annotated[Optional[int], Doc('\\n            Maximum length for strings.\\n            ')]=None, pattern: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            ')]=None, regex: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            '), deprecated('Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead.')]=None, discriminator: Annotated[Union[str, None], Doc('\\n            Parameter field name for discriminating the type in a tagged union.\\n            ')]=None, strict: Annotated[Union[bool, None], Doc('\\n            If `True`, strict validation is applied to the field.\\n            ')]=_Unset, multiple_of: Annotated[Union[float, None], Doc('\\n            Value must be a multiple of this. Only applicable to numbers.\\n            ')]=_Unset, allow_inf_nan: Annotated[Union[bool, None], Doc('\\n            Allow `inf`, `-inf`, `nan`. Only applicable to numbers.\\n            ')]=_Unset, max_digits: Annotated[Union[int, None], Doc('\\n            Maximum number of allow digits for strings.\\n            ')]=_Unset, decimal_places: Annotated[Union[int, None], Doc('\\n            Maximum number of decimal places allowed for numbers.\\n            ')]=_Unset, examples: Annotated[Optional[List[Any]], Doc('\\n            Example values for this field.\\n            ')]=None, example: Annotated[Optional[Any], deprecated('Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.')]=_Unset, openapi_examples: Annotated[Optional[Dict[str, Example]], Doc(\"\\n            OpenAPI-specific examples.\\n\\n            It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n            Swagger UI (that provides the `/docs` interface) has better support for the\\n            OpenAPI-specific examples than the JSON Schema `examples`, that's the main\\n            use case for this.\\n\\n            Read more about it in the\\n            [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).\\n            \")]=None, deprecated: Annotated[Union[deprecated, str, bool, None], Doc('\\n            Mark this parameter field as deprecated.\\n\\n            It will affect the generated OpenAPI (e.g. visible at `/docs`).\\n            ')]=None, include_in_schema: Annotated[bool, Doc(\"\\n            To include (or not) this parameter field in the generated OpenAPI.\\n            You probably don't need it, but it's available.\\n\\n            This affects the generated OpenAPI (e.g. visible at `/docs`).\\n            \")]=True, json_schema_extra: Annotated[Union[Dict[str, Any], None], Doc('\\n            Any additional JSON schema data.\\n            ')]=None, **extra: Annotated[Any, Doc('\\n            Include extra fields used by the JSON Schema.\\n            '), deprecated('\\n            The `extra` kwargs is deprecated. Use `json_schema_extra` instead.\\n            ')]) -> Any:\n    return params.Query(default=default, default_factory=default_factory, alias=alias, alias_priority=alias_priority, validation_alias=validation_alias, serialization_alias=serialization_alias, title=title, description=description, gt=gt, ge=ge, lt=lt, le=le, min_length=min_length, max_length=max_length, pattern=pattern, regex=regex, discriminator=discriminator, strict=strict, multiple_of=multiple_of, allow_inf_nan=allow_inf_nan, max_digits=max_digits, decimal_places=decimal_places, example=example, examples=examples, openapi_examples=openapi_examples, deprecated=deprecated, include_in_schema=include_in_schema, json_schema_extra=json_schema_extra, **extra)"
        }
      ]
    },
    {
      "name": "Header",
      "module": "param_functions",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\param_functions.py",
      "line_number": 643,
      "end_line_number": 956,
      "source_code": "def Header(  # noqa: N802\n    default: Annotated[\n        Any,\n        Doc(\n            \"\"\"\n            Default value if the parameter field is not set.\n            \"\"\"\n        ),\n    ] = Undefined,\n    *,\n    default_factory: Annotated[\n        Union[Callable[[], Any], None],\n        Doc(\n            \"\"\"\n            A callable to generate the default value.\n\n            This doesn't affect `Path` parameters as the value is always required.\n            The parameter is available only for compatibility.\n            \"\"\"\n        ),\n    ] = _Unset,\n    alias: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            An alternative name for the parameter field.\n\n            This will be used to extract the data and for the generated OpenAPI.\n            It is particularly useful when you can't use the name you want because it\n            is a Python reserved keyword or similar.\n            \"\"\"\n        ),\n    ] = None,\n    alias_priority: Annotated[\n        Union[int, None],\n        Doc(\n            \"\"\"\n            Priority of the alias. This affects whether an alias generator is used.\n            \"\"\"\n        ),\n    ] = _Unset,\n    # TODO: update when deprecating Pydantic v1, import these types\n    # validation_alias: str | AliasPath | AliasChoices | None\n    validation_alias: Annotated[\n        Union[str, None],\n        Doc(\n            \"\"\"\n            'Whitelist' validation step. The parameter field will be the single one\n            allowed by the alias or set of aliases defined.\n            \"\"\"\n        ),\n    ] = None,\n    serialization_alias: Annotated[\n        Union[str, None],\n        Doc(\n            \"\"\"\n            'Blacklist' validation step. The vanilla parameter field will be the\n            single one of the alias' or set of aliases' fields and all the other\n            fields will be ignored at serialization time.\n            \"\"\"\n        ),\n    ] = None,\n    convert_underscores: Annotated[\n        bool,\n        Doc(\n            \"\"\"\n            Automatically convert underscores to hyphens in the parameter field name.\n\n            Read more about it in the\n            [FastAPI docs for Header Parameters](https://fastapi.tiangolo.com/tutorial/header-params/#automatic-conversion)\n            \"\"\"\n        ),\n    ] = True,\n    title: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            Human-readable title.\n            \"\"\"\n        ),\n    ] = None,\n    description: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            Human-readable description.\n            \"\"\"\n        ),\n    ] = None,\n    gt: Annotated[\n        Optional[float],\n        Doc(\n            \"\"\"\n            Greater than. If set, value must be greater than this. Only applicable to\n            numbers.\n            \"\"\"\n        ),\n    ] = None,\n    ge: Annotated[\n        Optional[float],\n        Doc(\n            \"\"\"\n            Greater than or equal. If set, value must be greater than or equal to\n            this. Only applicable to numbers.\n            \"\"\"\n        ),\n    ] = None,\n    lt: Annotated[\n        Optional[float],\n        Doc(\n            \"\"\"\n            Less than. If set, value must be less than this. Only applicable to numbers.\n            \"\"\"\n        ),\n    ] = None,\n    le: Annotated[\n        Optional[float],\n        Doc(\n            \"\"\"\n            Less than or equal. If set, value must be less than or equal to this.\n            Only applicable to numbers.\n            \"\"\"\n        ),\n    ] = None,\n    min_length: Annotated[\n        Optional[int],\n        Doc(\n            \"\"\"\n            Minimum length for strings.\n            \"\"\"\n        ),\n    ] = None,\n    max_length: Annotated[\n        Optional[int],\n        Doc(\n            \"\"\"\n            Maximum length for strings.\n            \"\"\"\n        ),\n    ] = None,\n    pattern: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            RegEx pattern for strings.\n            \"\"\"\n        ),\n    ] = None,\n    regex: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            RegEx pattern for strings.\n            \"\"\"\n        ),\n        deprecated(\n            \"Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead.\"\n        ),\n    ] = None,\n    discriminator: Annotated[\n        Union[str, None],\n        Doc(\n            \"\"\"\n            Parameter field name for discriminating the type in a tagged union.\n            \"\"\"\n        ),\n    ] = None,\n    strict: Annotated[\n        Union[bool, None],\n        Doc(\n            \"\"\"\n            If `True`, strict validation is applied to the field.\n            \"\"\"\n        ),\n    ] = _Unset,\n    multiple_of: Annotated[\n        Union[float, None],\n        Doc(\n            \"\"\"\n            Value must be a multiple of this. Only applicable to numbers.\n            \"\"\"\n        ),\n    ] = _Unset,\n    allow_inf_nan: Annotated[\n        Union[bool, None],\n        Doc(\n            \"\"\"\n            Allow `inf`, `-inf`, `nan`. Only applicable to numbers.\n            \"\"\"\n        ),\n    ] = _Unset,\n    max_digits: Annotated[\n        Union[int, None],\n        Doc(\n            \"\"\"\n            Maximum number of allow digits for strings.\n            \"\"\"\n        ),\n    ] = _Unset,\n    decimal_places: Annotated[\n        Union[int, None],\n        Doc(\n            \"\"\"\n            Maximum number of decimal places allowed for numbers.\n            \"\"\"\n        ),\n    ] = _Unset,\n    examples: Annotated[\n        Optional[List[Any]],\n        Doc(\n            \"\"\"\n            Example values for this field.\n            \"\"\"\n        ),\n    ] = None,\n    example: Annotated[\n        Optional[Any],\n        deprecated(\n            \"Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, \"\n            \"although still supported. Use examples instead.\"\n        ),\n    ] = _Unset,\n    openapi_examples: Annotated[\n        Optional[Dict[str, Example]],\n        Doc(\n            \"\"\"\n            OpenAPI-specific examples.\n\n            It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n            Swagger UI (that provides the `/docs` interface) has better support for the\n            OpenAPI-specific examples than the JSON Schema `examples`, that's the main\n            use case for this.\n\n            Read more about it in the\n            [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).\n            \"\"\"\n        ),\n    ] = None,\n    deprecated: Annotated[\n        Union[deprecated, str, bool, None],\n        Doc(\n            \"\"\"\n            Mark this parameter field as deprecated.\n\n            It will affect the generated OpenAPI (e.g. visible at `/docs`).\n            \"\"\"\n        ),\n    ] = None,\n    include_in_schema: Annotated[\n        bool,\n        Doc(\n            \"\"\"\n            To include (or not) this parameter field in the generated OpenAPI.\n            You probably don't need it, but it's available.\n\n            This affects the generated OpenAPI (e.g. visible at `/docs`).\n            \"\"\"\n        ),\n    ] = True,\n    json_schema_extra: Annotated[\n        Union[Dict[str, Any], None],\n        Doc(\n            \"\"\"\n            Any additional JSON schema data.\n            \"\"\"\n        ),\n    ] = None,\n    **extra: Annotated[\n        Any,\n        Doc(\n            \"\"\"\n            Include extra fields used by the JSON Schema.\n            \"\"\"\n        ),\n        deprecated(\n            \"\"\"\n            The `extra` kwargs is deprecated. Use `json_schema_extra` instead.\n            \"\"\"\n        ),\n    ],\n) -> Any:\n    return params.Header(\n        default=default,\n        default_factory=default_factory,\n        alias=alias,\n        alias_priority=alias_priority,\n        validation_alias=validation_alias,\n        serialization_alias=serialization_alias,\n        convert_underscores=convert_underscores,\n        title=title,\n        description=description,\n        gt=gt,\n        ge=ge,\n        lt=lt,\n        le=le,\n        min_length=min_length,\n        max_length=max_length,\n        pattern=pattern,\n        regex=regex,\n        discriminator=discriminator,\n        strict=strict,\n        multiple_of=multiple_of,\n        allow_inf_nan=allow_inf_nan,\n        max_digits=max_digits,\n        decimal_places=decimal_places,\n        example=example,\n        examples=examples,\n        openapi_examples=openapi_examples,\n        deprecated=deprecated,\n        include_in_schema=include_in_schema,\n        json_schema_extra=json_schema_extra,\n        **extra,\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "default"
      ],
      "imports": [
        "typing.Any",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Union",
        "fastapi.params",
        "fastapi._compat.Undefined",
        "fastapi.openapi.models.Example",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "params.Header",
          "body": "def Header(default: Annotated[Any, Doc('\\n            Default value if the parameter field is not set.\\n            ')]=Undefined, *, default_factory: Annotated[Union[Callable[[], Any], None], Doc(\"\\n            A callable to generate the default value.\\n\\n            This doesn't affect `Path` parameters as the value is always required.\\n            The parameter is available only for compatibility.\\n            \")]=_Unset, alias: Annotated[Optional[str], Doc(\"\\n            An alternative name for the parameter field.\\n\\n            This will be used to extract the data and for the generated OpenAPI.\\n            It is particularly useful when you can't use the name you want because it\\n            is a Python reserved keyword or similar.\\n            \")]=None, alias_priority: Annotated[Union[int, None], Doc('\\n            Priority of the alias. This affects whether an alias generator is used.\\n            ')]=_Unset, validation_alias: Annotated[Union[str, None], Doc(\"\\n            'Whitelist' validation step. The parameter field will be the single one\\n            allowed by the alias or set of aliases defined.\\n            \")]=None, serialization_alias: Annotated[Union[str, None], Doc(\"\\n            'Blacklist' validation step. The vanilla parameter field will be the\\n            single one of the alias' or set of aliases' fields and all the other\\n            fields will be ignored at serialization time.\\n            \")]=None, convert_underscores: Annotated[bool, Doc('\\n            Automatically convert underscores to hyphens in the parameter field name.\\n\\n            Read more about it in the\\n            [FastAPI docs for Header Parameters](https://fastapi.tiangolo.com/tutorial/header-params/#automatic-conversion)\\n            ')]=True, title: Annotated[Optional[str], Doc('\\n            Human-readable title.\\n            ')]=None, description: Annotated[Optional[str], Doc('\\n            Human-readable description.\\n            ')]=None, gt: Annotated[Optional[float], Doc('\\n            Greater than. If set, value must be greater than this. Only applicable to\\n            numbers.\\n            ')]=None, ge: Annotated[Optional[float], Doc('\\n            Greater than or equal. If set, value must be greater than or equal to\\n            this. Only applicable to numbers.\\n            ')]=None, lt: Annotated[Optional[float], Doc('\\n            Less than. If set, value must be less than this. Only applicable to numbers.\\n            ')]=None, le: Annotated[Optional[float], Doc('\\n            Less than or equal. If set, value must be less than or equal to this.\\n            Only applicable to numbers.\\n            ')]=None, min_length: Annotated[Optional[int], Doc('\\n            Minimum length for strings.\\n            ')]=None, max_length: Annotated[Optional[int], Doc('\\n            Maximum length for strings.\\n            ')]=None, pattern: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            ')]=None, regex: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            '), deprecated('Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead.')]=None, discriminator: Annotated[Union[str, None], Doc('\\n            Parameter field name for discriminating the type in a tagged union.\\n            ')]=None, strict: Annotated[Union[bool, None], Doc('\\n            If `True`, strict validation is applied to the field.\\n            ')]=_Unset, multiple_of: Annotated[Union[float, None], Doc('\\n            Value must be a multiple of this. Only applicable to numbers.\\n            ')]=_Unset, allow_inf_nan: Annotated[Union[bool, None], Doc('\\n            Allow `inf`, `-inf`, `nan`. Only applicable to numbers.\\n            ')]=_Unset, max_digits: Annotated[Union[int, None], Doc('\\n            Maximum number of allow digits for strings.\\n            ')]=_Unset, decimal_places: Annotated[Union[int, None], Doc('\\n            Maximum number of decimal places allowed for numbers.\\n            ')]=_Unset, examples: Annotated[Optional[List[Any]], Doc('\\n            Example values for this field.\\n            ')]=None, example: Annotated[Optional[Any], deprecated('Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.')]=_Unset, openapi_examples: Annotated[Optional[Dict[str, Example]], Doc(\"\\n            OpenAPI-specific examples.\\n\\n            It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n            Swagger UI (that provides the `/docs` interface) has better support for the\\n            OpenAPI-specific examples than the JSON Schema `examples`, that's the main\\n            use case for this.\\n\\n            Read more about it in the\\n            [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).\\n            \")]=None, deprecated: Annotated[Union[deprecated, str, bool, None], Doc('\\n            Mark this parameter field as deprecated.\\n\\n            It will affect the generated OpenAPI (e.g. visible at `/docs`).\\n            ')]=None, include_in_schema: Annotated[bool, Doc(\"\\n            To include (or not) this parameter field in the generated OpenAPI.\\n            You probably don't need it, but it's available.\\n\\n            This affects the generated OpenAPI (e.g. visible at `/docs`).\\n            \")]=True, json_schema_extra: Annotated[Union[Dict[str, Any], None], Doc('\\n            Any additional JSON schema data.\\n            ')]=None, **extra: Annotated[Any, Doc('\\n            Include extra fields used by the JSON Schema.\\n            '), deprecated('\\n            The `extra` kwargs is deprecated. Use `json_schema_extra` instead.\\n            ')]) -> Any:\n    return params.Header(default=default, default_factory=default_factory, alias=alias, alias_priority=alias_priority, validation_alias=validation_alias, serialization_alias=serialization_alias, convert_underscores=convert_underscores, title=title, description=description, gt=gt, ge=ge, lt=lt, le=le, min_length=min_length, max_length=max_length, pattern=pattern, regex=regex, discriminator=discriminator, strict=strict, multiple_of=multiple_of, allow_inf_nan=allow_inf_nan, max_digits=max_digits, decimal_places=decimal_places, example=example, examples=examples, openapi_examples=openapi_examples, deprecated=deprecated, include_in_schema=include_in_schema, json_schema_extra=json_schema_extra, **extra)"
        }
      ]
    },
    {
      "name": "Cookie",
      "module": "param_functions",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\param_functions.py",
      "line_number": 959,
      "end_line_number": 1260,
      "source_code": "def Cookie(  # noqa: N802\n    default: Annotated[\n        Any,\n        Doc(\n            \"\"\"\n            Default value if the parameter field is not set.\n            \"\"\"\n        ),\n    ] = Undefined,\n    *,\n    default_factory: Annotated[\n        Union[Callable[[], Any], None],\n        Doc(\n            \"\"\"\n            A callable to generate the default value.\n\n            This doesn't affect `Path` parameters as the value is always required.\n            The parameter is available only for compatibility.\n            \"\"\"\n        ),\n    ] = _Unset,\n    alias: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            An alternative name for the parameter field.\n\n            This will be used to extract the data and for the generated OpenAPI.\n            It is particularly useful when you can't use the name you want because it\n            is a Python reserved keyword or similar.\n            \"\"\"\n        ),\n    ] = None,\n    alias_priority: Annotated[\n        Union[int, None],\n        Doc(\n            \"\"\"\n            Priority of the alias. This affects whether an alias generator is used.\n            \"\"\"\n        ),\n    ] = _Unset,\n    # TODO: update when deprecating Pydantic v1, import these types\n    # validation_alias: str | AliasPath | AliasChoices | None\n    validation_alias: Annotated[\n        Union[str, None],\n        Doc(\n            \"\"\"\n            'Whitelist' validation step. The parameter field will be the single one\n            allowed by the alias or set of aliases defined.\n            \"\"\"\n        ),\n    ] = None,\n    serialization_alias: Annotated[\n        Union[str, None],\n        Doc(\n            \"\"\"\n            'Blacklist' validation step. The vanilla parameter field will be the\n            single one of the alias' or set of aliases' fields and all the other\n            fields will be ignored at serialization time.\n            \"\"\"\n        ),\n    ] = None,\n    title: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            Human-readable title.\n            \"\"\"\n        ),\n    ] = None,\n    description: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            Human-readable description.\n            \"\"\"\n        ),\n    ] = None,\n    gt: Annotated[\n        Optional[float],\n        Doc(\n            \"\"\"\n            Greater than. If set, value must be greater than this. Only applicable to\n            numbers.\n            \"\"\"\n        ),\n    ] = None,\n    ge: Annotated[\n        Optional[float],\n        Doc(\n            \"\"\"\n            Greater than or equal. If set, value must be greater than or equal to\n            this. Only applicable to numbers.\n            \"\"\"\n        ),\n    ] = None,\n    lt: Annotated[\n        Optional[float],\n        Doc(\n            \"\"\"\n            Less than. If set, value must be less than this. Only applicable to numbers.\n            \"\"\"\n        ),\n    ] = None,\n    le: Annotated[\n        Optional[float],\n        Doc(\n            \"\"\"\n            Less than or equal. If set, value must be less than or equal to this.\n            Only applicable to numbers.\n            \"\"\"\n        ),\n    ] = None,\n    min_length: Annotated[\n        Optional[int],\n        Doc(\n            \"\"\"\n            Minimum length for strings.\n            \"\"\"\n        ),\n    ] = None,\n    max_length: Annotated[\n        Optional[int],\n        Doc(\n            \"\"\"\n            Maximum length for strings.\n            \"\"\"\n        ),\n    ] = None,\n    pattern: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            RegEx pattern for strings.\n            \"\"\"\n        ),\n    ] = None,\n    regex: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            RegEx pattern for strings.\n            \"\"\"\n        ),\n        deprecated(\n            \"Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead.\"\n        ),\n    ] = None,\n    discriminator: Annotated[\n        Union[str, None],\n        Doc(\n            \"\"\"\n            Parameter field name for discriminating the type in a tagged union.\n            \"\"\"\n        ),\n    ] = None,\n    strict: Annotated[\n        Union[bool, None],\n        Doc(\n            \"\"\"\n            If `True`, strict validation is applied to the field.\n            \"\"\"\n        ),\n    ] = _Unset,\n    multiple_of: Annotated[\n        Union[float, None],\n        Doc(\n            \"\"\"\n            Value must be a multiple of this. Only applicable to numbers.\n            \"\"\"\n        ),\n    ] = _Unset,\n    allow_inf_nan: Annotated[\n        Union[bool, None],\n        Doc(\n            \"\"\"\n            Allow `inf`, `-inf`, `nan`. Only applicable to numbers.\n            \"\"\"\n        ),\n    ] = _Unset,\n    max_digits: Annotated[\n        Union[int, None],\n        Doc(\n            \"\"\"\n            Maximum number of allow digits for strings.\n            \"\"\"\n        ),\n    ] = _Unset,\n    decimal_places: Annotated[\n        Union[int, None],\n        Doc(\n            \"\"\"\n            Maximum number of decimal places allowed for numbers.\n            \"\"\"\n        ),\n    ] = _Unset,\n    examples: Annotated[\n        Optional[List[Any]],\n        Doc(\n            \"\"\"\n            Example values for this field.\n            \"\"\"\n        ),\n    ] = None,\n    example: Annotated[\n        Optional[Any],\n        deprecated(\n            \"Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, \"\n            \"although still supported. Use examples instead.\"\n        ),\n    ] = _Unset,\n    openapi_examples: Annotated[\n        Optional[Dict[str, Example]],\n        Doc(\n            \"\"\"\n            OpenAPI-specific examples.\n\n            It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n            Swagger UI (that provides the `/docs` interface) has better support for the\n            OpenAPI-specific examples than the JSON Schema `examples`, that's the main\n            use case for this.\n\n            Read more about it in the\n            [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).\n            \"\"\"\n        ),\n    ] = None,\n    deprecated: Annotated[\n        Union[deprecated, str, bool, None],\n        Doc(\n            \"\"\"\n            Mark this parameter field as deprecated.\n\n            It will affect the generated OpenAPI (e.g. visible at `/docs`).\n            \"\"\"\n        ),\n    ] = None,\n    include_in_schema: Annotated[\n        bool,\n        Doc(\n            \"\"\"\n            To include (or not) this parameter field in the generated OpenAPI.\n            You probably don't need it, but it's available.\n\n            This affects the generated OpenAPI (e.g. visible at `/docs`).\n            \"\"\"\n        ),\n    ] = True,\n    json_schema_extra: Annotated[\n        Union[Dict[str, Any], None],\n        Doc(\n            \"\"\"\n            Any additional JSON schema data.\n            \"\"\"\n        ),\n    ] = None,\n    **extra: Annotated[\n        Any,\n        Doc(\n            \"\"\"\n            Include extra fields used by the JSON Schema.\n            \"\"\"\n        ),\n        deprecated(\n            \"\"\"\n            The `extra` kwargs is deprecated. Use `json_schema_extra` instead.\n            \"\"\"\n        ),\n    ],\n) -> Any:\n    return params.Cookie(\n        default=default,\n        default_factory=default_factory,\n        alias=alias,\n        alias_priority=alias_priority,\n        validation_alias=validation_alias,\n        serialization_alias=serialization_alias,\n        title=title,\n        description=description,\n        gt=gt,\n        ge=ge,\n        lt=lt,\n        le=le,\n        min_length=min_length,\n        max_length=max_length,\n        pattern=pattern,\n        regex=regex,\n        discriminator=discriminator,\n        strict=strict,\n        multiple_of=multiple_of,\n        allow_inf_nan=allow_inf_nan,\n        max_digits=max_digits,\n        decimal_places=decimal_places,\n        example=example,\n        examples=examples,\n        openapi_examples=openapi_examples,\n        deprecated=deprecated,\n        include_in_schema=include_in_schema,\n        json_schema_extra=json_schema_extra,\n        **extra,\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "default"
      ],
      "imports": [
        "typing.Any",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Union",
        "fastapi.params",
        "fastapi._compat.Undefined",
        "fastapi.openapi.models.Example",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "params.Cookie",
          "body": "def Cookie(default: Annotated[Any, Doc('\\n            Default value if the parameter field is not set.\\n            ')]=Undefined, *, default_factory: Annotated[Union[Callable[[], Any], None], Doc(\"\\n            A callable to generate the default value.\\n\\n            This doesn't affect `Path` parameters as the value is always required.\\n            The parameter is available only for compatibility.\\n            \")]=_Unset, alias: Annotated[Optional[str], Doc(\"\\n            An alternative name for the parameter field.\\n\\n            This will be used to extract the data and for the generated OpenAPI.\\n            It is particularly useful when you can't use the name you want because it\\n            is a Python reserved keyword or similar.\\n            \")]=None, alias_priority: Annotated[Union[int, None], Doc('\\n            Priority of the alias. This affects whether an alias generator is used.\\n            ')]=_Unset, validation_alias: Annotated[Union[str, None], Doc(\"\\n            'Whitelist' validation step. The parameter field will be the single one\\n            allowed by the alias or set of aliases defined.\\n            \")]=None, serialization_alias: Annotated[Union[str, None], Doc(\"\\n            'Blacklist' validation step. The vanilla parameter field will be the\\n            single one of the alias' or set of aliases' fields and all the other\\n            fields will be ignored at serialization time.\\n            \")]=None, title: Annotated[Optional[str], Doc('\\n            Human-readable title.\\n            ')]=None, description: Annotated[Optional[str], Doc('\\n            Human-readable description.\\n            ')]=None, gt: Annotated[Optional[float], Doc('\\n            Greater than. If set, value must be greater than this. Only applicable to\\n            numbers.\\n            ')]=None, ge: Annotated[Optional[float], Doc('\\n            Greater than or equal. If set, value must be greater than or equal to\\n            this. Only applicable to numbers.\\n            ')]=None, lt: Annotated[Optional[float], Doc('\\n            Less than. If set, value must be less than this. Only applicable to numbers.\\n            ')]=None, le: Annotated[Optional[float], Doc('\\n            Less than or equal. If set, value must be less than or equal to this.\\n            Only applicable to numbers.\\n            ')]=None, min_length: Annotated[Optional[int], Doc('\\n            Minimum length for strings.\\n            ')]=None, max_length: Annotated[Optional[int], Doc('\\n            Maximum length for strings.\\n            ')]=None, pattern: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            ')]=None, regex: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            '), deprecated('Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead.')]=None, discriminator: Annotated[Union[str, None], Doc('\\n            Parameter field name for discriminating the type in a tagged union.\\n            ')]=None, strict: Annotated[Union[bool, None], Doc('\\n            If `True`, strict validation is applied to the field.\\n            ')]=_Unset, multiple_of: Annotated[Union[float, None], Doc('\\n            Value must be a multiple of this. Only applicable to numbers.\\n            ')]=_Unset, allow_inf_nan: Annotated[Union[bool, None], Doc('\\n            Allow `inf`, `-inf`, `nan`. Only applicable to numbers.\\n            ')]=_Unset, max_digits: Annotated[Union[int, None], Doc('\\n            Maximum number of allow digits for strings.\\n            ')]=_Unset, decimal_places: Annotated[Union[int, None], Doc('\\n            Maximum number of decimal places allowed for numbers.\\n            ')]=_Unset, examples: Annotated[Optional[List[Any]], Doc('\\n            Example values for this field.\\n            ')]=None, example: Annotated[Optional[Any], deprecated('Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.')]=_Unset, openapi_examples: Annotated[Optional[Dict[str, Example]], Doc(\"\\n            OpenAPI-specific examples.\\n\\n            It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n            Swagger UI (that provides the `/docs` interface) has better support for the\\n            OpenAPI-specific examples than the JSON Schema `examples`, that's the main\\n            use case for this.\\n\\n            Read more about it in the\\n            [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).\\n            \")]=None, deprecated: Annotated[Union[deprecated, str, bool, None], Doc('\\n            Mark this parameter field as deprecated.\\n\\n            It will affect the generated OpenAPI (e.g. visible at `/docs`).\\n            ')]=None, include_in_schema: Annotated[bool, Doc(\"\\n            To include (or not) this parameter field in the generated OpenAPI.\\n            You probably don't need it, but it's available.\\n\\n            This affects the generated OpenAPI (e.g. visible at `/docs`).\\n            \")]=True, json_schema_extra: Annotated[Union[Dict[str, Any], None], Doc('\\n            Any additional JSON schema data.\\n            ')]=None, **extra: Annotated[Any, Doc('\\n            Include extra fields used by the JSON Schema.\\n            '), deprecated('\\n            The `extra` kwargs is deprecated. Use `json_schema_extra` instead.\\n            ')]) -> Any:\n    return params.Cookie(default=default, default_factory=default_factory, alias=alias, alias_priority=alias_priority, validation_alias=validation_alias, serialization_alias=serialization_alias, title=title, description=description, gt=gt, ge=ge, lt=lt, le=le, min_length=min_length, max_length=max_length, pattern=pattern, regex=regex, discriminator=discriminator, strict=strict, multiple_of=multiple_of, allow_inf_nan=allow_inf_nan, max_digits=max_digits, decimal_places=decimal_places, example=example, examples=examples, openapi_examples=openapi_examples, deprecated=deprecated, include_in_schema=include_in_schema, json_schema_extra=json_schema_extra, **extra)"
        }
      ]
    },
    {
      "name": "Body",
      "module": "param_functions",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\param_functions.py",
      "line_number": 1263,
      "end_line_number": 1589,
      "source_code": "def Body(  # noqa: N802\n    default: Annotated[\n        Any,\n        Doc(\n            \"\"\"\n            Default value if the parameter field is not set.\n            \"\"\"\n        ),\n    ] = Undefined,\n    *,\n    default_factory: Annotated[\n        Union[Callable[[], Any], None],\n        Doc(\n            \"\"\"\n            A callable to generate the default value.\n\n            This doesn't affect `Path` parameters as the value is always required.\n            The parameter is available only for compatibility.\n            \"\"\"\n        ),\n    ] = _Unset,\n    embed: Annotated[\n        Union[bool, None],\n        Doc(\n            \"\"\"\n            When `embed` is `True`, the parameter will be expected in a JSON body as a\n            key instead of being the JSON body itself.\n\n            This happens automatically when more than one `Body` parameter is declared.\n\n            Read more about it in the\n            [FastAPI docs for Body - Multiple Parameters](https://fastapi.tiangolo.com/tutorial/body-multiple-params/#embed-a-single-body-parameter).\n            \"\"\"\n        ),\n    ] = None,\n    media_type: Annotated[\n        str,\n        Doc(\n            \"\"\"\n            The media type of this parameter field. Changing it would affect the\n            generated OpenAPI, but currently it doesn't affect the parsing of the data.\n            \"\"\"\n        ),\n    ] = \"application/json\",\n    alias: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            An alternative name for the parameter field.\n\n            This will be used to extract the data and for the generated OpenAPI.\n            It is particularly useful when you can't use the name you want because it\n            is a Python reserved keyword or similar.\n            \"\"\"\n        ),\n    ] = None,\n    alias_priority: Annotated[\n        Union[int, None],\n        Doc(\n            \"\"\"\n            Priority of the alias. This affects whether an alias generator is used.\n            \"\"\"\n        ),\n    ] = _Unset,\n    # TODO: update when deprecating Pydantic v1, import these types\n    # validation_alias: str | AliasPath | AliasChoices | None\n    validation_alias: Annotated[\n        Union[str, None],\n        Doc(\n            \"\"\"\n            'Whitelist' validation step. The parameter field will be the single one\n            allowed by the alias or set of aliases defined.\n            \"\"\"\n        ),\n    ] = None,\n    serialization_alias: Annotated[\n        Union[str, None],\n        Doc(\n            \"\"\"\n            'Blacklist' validation step. The vanilla parameter field will be the\n            single one of the alias' or set of aliases' fields and all the other\n            fields will be ignored at serialization time.\n            \"\"\"\n        ),\n    ] = None,\n    title: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            Human-readable title.\n            \"\"\"\n        ),\n    ] = None,\n    description: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            Human-readable description.\n            \"\"\"\n        ),\n    ] = None,\n    gt: Annotated[\n        Optional[float],\n        Doc(\n            \"\"\"\n            Greater than. If set, value must be greater than this. Only applicable to\n            numbers.\n            \"\"\"\n        ),\n    ] = None,\n    ge: Annotated[\n        Optional[float],\n        Doc(\n            \"\"\"\n            Greater than or equal. If set, value must be greater than or equal to\n            this. Only applicable to numbers.\n            \"\"\"\n        ),\n    ] = None,\n    lt: Annotated[\n        Optional[float],\n        Doc(\n            \"\"\"\n            Less than. If set, value must be less than this. Only applicable to numbers.\n            \"\"\"\n        ),\n    ] = None,\n    le: Annotated[\n        Optional[float],\n        Doc(\n            \"\"\"\n            Less than or equal. If set, value must be less than or equal to this.\n            Only applicable to numbers.\n            \"\"\"\n        ),\n    ] = None,\n    min_length: Annotated[\n        Optional[int],\n        Doc(\n            \"\"\"\n            Minimum length for strings.\n            \"\"\"\n        ),\n    ] = None,\n    max_length: Annotated[\n        Optional[int],\n        Doc(\n            \"\"\"\n            Maximum length for strings.\n            \"\"\"\n        ),\n    ] = None,\n    pattern: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            RegEx pattern for strings.\n            \"\"\"\n        ),\n    ] = None,\n    regex: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            RegEx pattern for strings.\n            \"\"\"\n        ),\n        deprecated(\n            \"Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead.\"\n        ),\n    ] = None,\n    discriminator: Annotated[\n        Union[str, None],\n        Doc(\n            \"\"\"\n            Parameter field name for discriminating the type in a tagged union.\n            \"\"\"\n        ),\n    ] = None,\n    strict: Annotated[\n        Union[bool, None],\n        Doc(\n            \"\"\"\n            If `True`, strict validation is applied to the field.\n            \"\"\"\n        ),\n    ] = _Unset,\n    multiple_of: Annotated[\n        Union[float, None],\n        Doc(\n            \"\"\"\n            Value must be a multiple of this. Only applicable to numbers.\n            \"\"\"\n        ),\n    ] = _Unset,\n    allow_inf_nan: Annotated[\n        Union[bool, None],\n        Doc(\n            \"\"\"\n            Allow `inf`, `-inf`, `nan`. Only applicable to numbers.\n            \"\"\"\n        ),\n    ] = _Unset,\n    max_digits: Annotated[\n        Union[int, None],\n        Doc(\n            \"\"\"\n            Maximum number of allow digits for strings.\n            \"\"\"\n        ),\n    ] = _Unset,\n    decimal_places: Annotated[\n        Union[int, None],\n        Doc(\n            \"\"\"\n            Maximum number of decimal places allowed for numbers.\n            \"\"\"\n        ),\n    ] = _Unset,\n    examples: Annotated[\n        Optional[List[Any]],\n        Doc(\n            \"\"\"\n            Example values for this field.\n            \"\"\"\n        ),\n    ] = None,\n    example: Annotated[\n        Optional[Any],\n        deprecated(\n            \"Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, \"\n            \"although still supported. Use examples instead.\"\n        ),\n    ] = _Unset,\n    openapi_examples: Annotated[\n        Optional[Dict[str, Example]],\n        Doc(\n            \"\"\"\n            OpenAPI-specific examples.\n\n            It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n            Swagger UI (that provides the `/docs` interface) has better support for the\n            OpenAPI-specific examples than the JSON Schema `examples`, that's the main\n            use case for this.\n\n            Read more about it in the\n            [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).\n            \"\"\"\n        ),\n    ] = None,\n    deprecated: Annotated[\n        Union[deprecated, str, bool, None],\n        Doc(\n            \"\"\"\n            Mark this parameter field as deprecated.\n\n            It will affect the generated OpenAPI (e.g. visible at `/docs`).\n            \"\"\"\n        ),\n    ] = None,\n    include_in_schema: Annotated[\n        bool,\n        Doc(\n            \"\"\"\n            To include (or not) this parameter field in the generated OpenAPI.\n            You probably don't need it, but it's available.\n\n            This affects the generated OpenAPI (e.g. visible at `/docs`).\n            \"\"\"\n        ),\n    ] = True,\n    json_schema_extra: Annotated[\n        Union[Dict[str, Any], None],\n        Doc(\n            \"\"\"\n            Any additional JSON schema data.\n            \"\"\"\n        ),\n    ] = None,\n    **extra: Annotated[\n        Any,\n        Doc(\n            \"\"\"\n            Include extra fields used by the JSON Schema.\n            \"\"\"\n        ),\n        deprecated(\n            \"\"\"\n            The `extra` kwargs is deprecated. Use `json_schema_extra` instead.\n            \"\"\"\n        ),\n    ],\n) -> Any:\n    return params.Body(\n        default=default,\n        default_factory=default_factory,\n        embed=embed,\n        media_type=media_type,\n        alias=alias,\n        alias_priority=alias_priority,\n        validation_alias=validation_alias,\n        serialization_alias=serialization_alias,\n        title=title,\n        description=description,\n        gt=gt,\n        ge=ge,\n        lt=lt,\n        le=le,\n        min_length=min_length,\n        max_length=max_length,\n        pattern=pattern,\n        regex=regex,\n        discriminator=discriminator,\n        strict=strict,\n        multiple_of=multiple_of,\n        allow_inf_nan=allow_inf_nan,\n        max_digits=max_digits,\n        decimal_places=decimal_places,\n        example=example,\n        examples=examples,\n        openapi_examples=openapi_examples,\n        deprecated=deprecated,\n        include_in_schema=include_in_schema,\n        json_schema_extra=json_schema_extra,\n        **extra,\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "default"
      ],
      "imports": [
        "typing.Any",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Union",
        "fastapi.params",
        "fastapi._compat.Undefined",
        "fastapi.openapi.models.Example",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "params.Body",
          "body": "def Body(default: Annotated[Any, Doc('\\n            Default value if the parameter field is not set.\\n            ')]=Undefined, *, default_factory: Annotated[Union[Callable[[], Any], None], Doc(\"\\n            A callable to generate the default value.\\n\\n            This doesn't affect `Path` parameters as the value is always required.\\n            The parameter is available only for compatibility.\\n            \")]=_Unset, embed: Annotated[Union[bool, None], Doc('\\n            When `embed` is `True`, the parameter will be expected in a JSON body as a\\n            key instead of being the JSON body itself.\\n\\n            This happens automatically when more than one `Body` parameter is declared.\\n\\n            Read more about it in the\\n            [FastAPI docs for Body - Multiple Parameters](https://fastapi.tiangolo.com/tutorial/body-multiple-params/#embed-a-single-body-parameter).\\n            ')]=None, media_type: Annotated[str, Doc(\"\\n            The media type of this parameter field. Changing it would affect the\\n            generated OpenAPI, but currently it doesn't affect the parsing of the data.\\n            \")]='application/json', alias: Annotated[Optional[str], Doc(\"\\n            An alternative name for the parameter field.\\n\\n            This will be used to extract the data and for the generated OpenAPI.\\n            It is particularly useful when you can't use the name you want because it\\n            is a Python reserved keyword or similar.\\n            \")]=None, alias_priority: Annotated[Union[int, None], Doc('\\n            Priority of the alias. This affects whether an alias generator is used.\\n            ')]=_Unset, validation_alias: Annotated[Union[str, None], Doc(\"\\n            'Whitelist' validation step. The parameter field will be the single one\\n            allowed by the alias or set of aliases defined.\\n            \")]=None, serialization_alias: Annotated[Union[str, None], Doc(\"\\n            'Blacklist' validation step. The vanilla parameter field will be the\\n            single one of the alias' or set of aliases' fields and all the other\\n            fields will be ignored at serialization time.\\n            \")]=None, title: Annotated[Optional[str], Doc('\\n            Human-readable title.\\n            ')]=None, description: Annotated[Optional[str], Doc('\\n            Human-readable description.\\n            ')]=None, gt: Annotated[Optional[float], Doc('\\n            Greater than. If set, value must be greater than this. Only applicable to\\n            numbers.\\n            ')]=None, ge: Annotated[Optional[float], Doc('\\n            Greater than or equal. If set, value must be greater than or equal to\\n            this. Only applicable to numbers.\\n            ')]=None, lt: Annotated[Optional[float], Doc('\\n            Less than. If set, value must be less than this. Only applicable to numbers.\\n            ')]=None, le: Annotated[Optional[float], Doc('\\n            Less than or equal. If set, value must be less than or equal to this.\\n            Only applicable to numbers.\\n            ')]=None, min_length: Annotated[Optional[int], Doc('\\n            Minimum length for strings.\\n            ')]=None, max_length: Annotated[Optional[int], Doc('\\n            Maximum length for strings.\\n            ')]=None, pattern: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            ')]=None, regex: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            '), deprecated('Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead.')]=None, discriminator: Annotated[Union[str, None], Doc('\\n            Parameter field name for discriminating the type in a tagged union.\\n            ')]=None, strict: Annotated[Union[bool, None], Doc('\\n            If `True`, strict validation is applied to the field.\\n            ')]=_Unset, multiple_of: Annotated[Union[float, None], Doc('\\n            Value must be a multiple of this. Only applicable to numbers.\\n            ')]=_Unset, allow_inf_nan: Annotated[Union[bool, None], Doc('\\n            Allow `inf`, `-inf`, `nan`. Only applicable to numbers.\\n            ')]=_Unset, max_digits: Annotated[Union[int, None], Doc('\\n            Maximum number of allow digits for strings.\\n            ')]=_Unset, decimal_places: Annotated[Union[int, None], Doc('\\n            Maximum number of decimal places allowed for numbers.\\n            ')]=_Unset, examples: Annotated[Optional[List[Any]], Doc('\\n            Example values for this field.\\n            ')]=None, example: Annotated[Optional[Any], deprecated('Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.')]=_Unset, openapi_examples: Annotated[Optional[Dict[str, Example]], Doc(\"\\n            OpenAPI-specific examples.\\n\\n            It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n            Swagger UI (that provides the `/docs` interface) has better support for the\\n            OpenAPI-specific examples than the JSON Schema `examples`, that's the main\\n            use case for this.\\n\\n            Read more about it in the\\n            [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).\\n            \")]=None, deprecated: Annotated[Union[deprecated, str, bool, None], Doc('\\n            Mark this parameter field as deprecated.\\n\\n            It will affect the generated OpenAPI (e.g. visible at `/docs`).\\n            ')]=None, include_in_schema: Annotated[bool, Doc(\"\\n            To include (or not) this parameter field in the generated OpenAPI.\\n            You probably don't need it, but it's available.\\n\\n            This affects the generated OpenAPI (e.g. visible at `/docs`).\\n            \")]=True, json_schema_extra: Annotated[Union[Dict[str, Any], None], Doc('\\n            Any additional JSON schema data.\\n            ')]=None, **extra: Annotated[Any, Doc('\\n            Include extra fields used by the JSON Schema.\\n            '), deprecated('\\n            The `extra` kwargs is deprecated. Use `json_schema_extra` instead.\\n            ')]) -> Any:\n    return params.Body(default=default, default_factory=default_factory, embed=embed, media_type=media_type, alias=alias, alias_priority=alias_priority, validation_alias=validation_alias, serialization_alias=serialization_alias, title=title, description=description, gt=gt, ge=ge, lt=lt, le=le, min_length=min_length, max_length=max_length, pattern=pattern, regex=regex, discriminator=discriminator, strict=strict, multiple_of=multiple_of, allow_inf_nan=allow_inf_nan, max_digits=max_digits, decimal_places=decimal_places, example=example, examples=examples, openapi_examples=openapi_examples, deprecated=deprecated, include_in_schema=include_in_schema, json_schema_extra=json_schema_extra, **extra)"
        }
      ]
    },
    {
      "name": "Form",
      "module": "param_functions",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\param_functions.py",
      "line_number": 1592,
      "end_line_number": 1903,
      "source_code": "def Form(  # noqa: N802\n    default: Annotated[\n        Any,\n        Doc(\n            \"\"\"\n            Default value if the parameter field is not set.\n            \"\"\"\n        ),\n    ] = Undefined,\n    *,\n    default_factory: Annotated[\n        Union[Callable[[], Any], None],\n        Doc(\n            \"\"\"\n            A callable to generate the default value.\n\n            This doesn't affect `Path` parameters as the value is always required.\n            The parameter is available only for compatibility.\n            \"\"\"\n        ),\n    ] = _Unset,\n    media_type: Annotated[\n        str,\n        Doc(\n            \"\"\"\n            The media type of this parameter field. Changing it would affect the\n            generated OpenAPI, but currently it doesn't affect the parsing of the data.\n            \"\"\"\n        ),\n    ] = \"application/x-www-form-urlencoded\",\n    alias: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            An alternative name for the parameter field.\n\n            This will be used to extract the data and for the generated OpenAPI.\n            It is particularly useful when you can't use the name you want because it\n            is a Python reserved keyword or similar.\n            \"\"\"\n        ),\n    ] = None,\n    alias_priority: Annotated[\n        Union[int, None],\n        Doc(\n            \"\"\"\n            Priority of the alias. This affects whether an alias generator is used.\n            \"\"\"\n        ),\n    ] = _Unset,\n    # TODO: update when deprecating Pydantic v1, import these types\n    # validation_alias: str | AliasPath | AliasChoices | None\n    validation_alias: Annotated[\n        Union[str, None],\n        Doc(\n            \"\"\"\n            'Whitelist' validation step. The parameter field will be the single one\n            allowed by the alias or set of aliases defined.\n            \"\"\"\n        ),\n    ] = None,\n    serialization_alias: Annotated[\n        Union[str, None],\n        Doc(\n            \"\"\"\n            'Blacklist' validation step. The vanilla parameter field will be the\n            single one of the alias' or set of aliases' fields and all the other\n            fields will be ignored at serialization time.\n            \"\"\"\n        ),\n    ] = None,\n    title: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            Human-readable title.\n            \"\"\"\n        ),\n    ] = None,\n    description: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            Human-readable description.\n            \"\"\"\n        ),\n    ] = None,\n    gt: Annotated[\n        Optional[float],\n        Doc(\n            \"\"\"\n            Greater than. If set, value must be greater than this. Only applicable to\n            numbers.\n            \"\"\"\n        ),\n    ] = None,\n    ge: Annotated[\n        Optional[float],\n        Doc(\n            \"\"\"\n            Greater than or equal. If set, value must be greater than or equal to\n            this. Only applicable to numbers.\n            \"\"\"\n        ),\n    ] = None,\n    lt: Annotated[\n        Optional[float],\n        Doc(\n            \"\"\"\n            Less than. If set, value must be less than this. Only applicable to numbers.\n            \"\"\"\n        ),\n    ] = None,\n    le: Annotated[\n        Optional[float],\n        Doc(\n            \"\"\"\n            Less than or equal. If set, value must be less than or equal to this.\n            Only applicable to numbers.\n            \"\"\"\n        ),\n    ] = None,\n    min_length: Annotated[\n        Optional[int],\n        Doc(\n            \"\"\"\n            Minimum length for strings.\n            \"\"\"\n        ),\n    ] = None,\n    max_length: Annotated[\n        Optional[int],\n        Doc(\n            \"\"\"\n            Maximum length for strings.\n            \"\"\"\n        ),\n    ] = None,\n    pattern: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            RegEx pattern for strings.\n            \"\"\"\n        ),\n    ] = None,\n    regex: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            RegEx pattern for strings.\n            \"\"\"\n        ),\n        deprecated(\n            \"Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead.\"\n        ),\n    ] = None,\n    discriminator: Annotated[\n        Union[str, None],\n        Doc(\n            \"\"\"\n            Parameter field name for discriminating the type in a tagged union.\n            \"\"\"\n        ),\n    ] = None,\n    strict: Annotated[\n        Union[bool, None],\n        Doc(\n            \"\"\"\n            If `True`, strict validation is applied to the field.\n            \"\"\"\n        ),\n    ] = _Unset,\n    multiple_of: Annotated[\n        Union[float, None],\n        Doc(\n            \"\"\"\n            Value must be a multiple of this. Only applicable to numbers.\n            \"\"\"\n        ),\n    ] = _Unset,\n    allow_inf_nan: Annotated[\n        Union[bool, None],\n        Doc(\n            \"\"\"\n            Allow `inf`, `-inf`, `nan`. Only applicable to numbers.\n            \"\"\"\n        ),\n    ] = _Unset,\n    max_digits: Annotated[\n        Union[int, None],\n        Doc(\n            \"\"\"\n            Maximum number of allow digits for strings.\n            \"\"\"\n        ),\n    ] = _Unset,\n    decimal_places: Annotated[\n        Union[int, None],\n        Doc(\n            \"\"\"\n            Maximum number of decimal places allowed for numbers.\n            \"\"\"\n        ),\n    ] = _Unset,\n    examples: Annotated[\n        Optional[List[Any]],\n        Doc(\n            \"\"\"\n            Example values for this field.\n            \"\"\"\n        ),\n    ] = None,\n    example: Annotated[\n        Optional[Any],\n        deprecated(\n            \"Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, \"\n            \"although still supported. Use examples instead.\"\n        ),\n    ] = _Unset,\n    openapi_examples: Annotated[\n        Optional[Dict[str, Example]],\n        Doc(\n            \"\"\"\n            OpenAPI-specific examples.\n\n            It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n            Swagger UI (that provides the `/docs` interface) has better support for the\n            OpenAPI-specific examples than the JSON Schema `examples`, that's the main\n            use case for this.\n\n            Read more about it in the\n            [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).\n            \"\"\"\n        ),\n    ] = None,\n    deprecated: Annotated[\n        Union[deprecated, str, bool, None],\n        Doc(\n            \"\"\"\n            Mark this parameter field as deprecated.\n\n            It will affect the generated OpenAPI (e.g. visible at `/docs`).\n            \"\"\"\n        ),\n    ] = None,\n    include_in_schema: Annotated[\n        bool,\n        Doc(\n            \"\"\"\n            To include (or not) this parameter field in the generated OpenAPI.\n            You probably don't need it, but it's available.\n\n            This affects the generated OpenAPI (e.g. visible at `/docs`).\n            \"\"\"\n        ),\n    ] = True,\n    json_schema_extra: Annotated[\n        Union[Dict[str, Any], None],\n        Doc(\n            \"\"\"\n            Any additional JSON schema data.\n            \"\"\"\n        ),\n    ] = None,\n    **extra: Annotated[\n        Any,\n        Doc(\n            \"\"\"\n            Include extra fields used by the JSON Schema.\n            \"\"\"\n        ),\n        deprecated(\n            \"\"\"\n            The `extra` kwargs is deprecated. Use `json_schema_extra` instead.\n            \"\"\"\n        ),\n    ],\n) -> Any:\n    return params.Form(\n        default=default,\n        default_factory=default_factory,\n        media_type=media_type,\n        alias=alias,\n        alias_priority=alias_priority,\n        validation_alias=validation_alias,\n        serialization_alias=serialization_alias,\n        title=title,\n        description=description,\n        gt=gt,\n        ge=ge,\n        lt=lt,\n        le=le,\n        min_length=min_length,\n        max_length=max_length,\n        pattern=pattern,\n        regex=regex,\n        discriminator=discriminator,\n        strict=strict,\n        multiple_of=multiple_of,\n        allow_inf_nan=allow_inf_nan,\n        max_digits=max_digits,\n        decimal_places=decimal_places,\n        example=example,\n        examples=examples,\n        openapi_examples=openapi_examples,\n        deprecated=deprecated,\n        include_in_schema=include_in_schema,\n        json_schema_extra=json_schema_extra,\n        **extra,\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "default"
      ],
      "imports": [
        "typing.Any",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Union",
        "fastapi.params",
        "fastapi._compat.Undefined",
        "fastapi.openapi.models.Example",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "params.Form",
          "body": "def Form(default: Annotated[Any, Doc('\\n            Default value if the parameter field is not set.\\n            ')]=Undefined, *, default_factory: Annotated[Union[Callable[[], Any], None], Doc(\"\\n            A callable to generate the default value.\\n\\n            This doesn't affect `Path` parameters as the value is always required.\\n            The parameter is available only for compatibility.\\n            \")]=_Unset, media_type: Annotated[str, Doc(\"\\n            The media type of this parameter field. Changing it would affect the\\n            generated OpenAPI, but currently it doesn't affect the parsing of the data.\\n            \")]='application/x-www-form-urlencoded', alias: Annotated[Optional[str], Doc(\"\\n            An alternative name for the parameter field.\\n\\n            This will be used to extract the data and for the generated OpenAPI.\\n            It is particularly useful when you can't use the name you want because it\\n            is a Python reserved keyword or similar.\\n            \")]=None, alias_priority: Annotated[Union[int, None], Doc('\\n            Priority of the alias. This affects whether an alias generator is used.\\n            ')]=_Unset, validation_alias: Annotated[Union[str, None], Doc(\"\\n            'Whitelist' validation step. The parameter field will be the single one\\n            allowed by the alias or set of aliases defined.\\n            \")]=None, serialization_alias: Annotated[Union[str, None], Doc(\"\\n            'Blacklist' validation step. The vanilla parameter field will be the\\n            single one of the alias' or set of aliases' fields and all the other\\n            fields will be ignored at serialization time.\\n            \")]=None, title: Annotated[Optional[str], Doc('\\n            Human-readable title.\\n            ')]=None, description: Annotated[Optional[str], Doc('\\n            Human-readable description.\\n            ')]=None, gt: Annotated[Optional[float], Doc('\\n            Greater than. If set, value must be greater than this. Only applicable to\\n            numbers.\\n            ')]=None, ge: Annotated[Optional[float], Doc('\\n            Greater than or equal. If set, value must be greater than or equal to\\n            this. Only applicable to numbers.\\n            ')]=None, lt: Annotated[Optional[float], Doc('\\n            Less than. If set, value must be less than this. Only applicable to numbers.\\n            ')]=None, le: Annotated[Optional[float], Doc('\\n            Less than or equal. If set, value must be less than or equal to this.\\n            Only applicable to numbers.\\n            ')]=None, min_length: Annotated[Optional[int], Doc('\\n            Minimum length for strings.\\n            ')]=None, max_length: Annotated[Optional[int], Doc('\\n            Maximum length for strings.\\n            ')]=None, pattern: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            ')]=None, regex: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            '), deprecated('Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead.')]=None, discriminator: Annotated[Union[str, None], Doc('\\n            Parameter field name for discriminating the type in a tagged union.\\n            ')]=None, strict: Annotated[Union[bool, None], Doc('\\n            If `True`, strict validation is applied to the field.\\n            ')]=_Unset, multiple_of: Annotated[Union[float, None], Doc('\\n            Value must be a multiple of this. Only applicable to numbers.\\n            ')]=_Unset, allow_inf_nan: Annotated[Union[bool, None], Doc('\\n            Allow `inf`, `-inf`, `nan`. Only applicable to numbers.\\n            ')]=_Unset, max_digits: Annotated[Union[int, None], Doc('\\n            Maximum number of allow digits for strings.\\n            ')]=_Unset, decimal_places: Annotated[Union[int, None], Doc('\\n            Maximum number of decimal places allowed for numbers.\\n            ')]=_Unset, examples: Annotated[Optional[List[Any]], Doc('\\n            Example values for this field.\\n            ')]=None, example: Annotated[Optional[Any], deprecated('Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.')]=_Unset, openapi_examples: Annotated[Optional[Dict[str, Example]], Doc(\"\\n            OpenAPI-specific examples.\\n\\n            It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n            Swagger UI (that provides the `/docs` interface) has better support for the\\n            OpenAPI-specific examples than the JSON Schema `examples`, that's the main\\n            use case for this.\\n\\n            Read more about it in the\\n            [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).\\n            \")]=None, deprecated: Annotated[Union[deprecated, str, bool, None], Doc('\\n            Mark this parameter field as deprecated.\\n\\n            It will affect the generated OpenAPI (e.g. visible at `/docs`).\\n            ')]=None, include_in_schema: Annotated[bool, Doc(\"\\n            To include (or not) this parameter field in the generated OpenAPI.\\n            You probably don't need it, but it's available.\\n\\n            This affects the generated OpenAPI (e.g. visible at `/docs`).\\n            \")]=True, json_schema_extra: Annotated[Union[Dict[str, Any], None], Doc('\\n            Any additional JSON schema data.\\n            ')]=None, **extra: Annotated[Any, Doc('\\n            Include extra fields used by the JSON Schema.\\n            '), deprecated('\\n            The `extra` kwargs is deprecated. Use `json_schema_extra` instead.\\n            ')]) -> Any:\n    return params.Form(default=default, default_factory=default_factory, media_type=media_type, alias=alias, alias_priority=alias_priority, validation_alias=validation_alias, serialization_alias=serialization_alias, title=title, description=description, gt=gt, ge=ge, lt=lt, le=le, min_length=min_length, max_length=max_length, pattern=pattern, regex=regex, discriminator=discriminator, strict=strict, multiple_of=multiple_of, allow_inf_nan=allow_inf_nan, max_digits=max_digits, decimal_places=decimal_places, example=example, examples=examples, openapi_examples=openapi_examples, deprecated=deprecated, include_in_schema=include_in_schema, json_schema_extra=json_schema_extra, **extra)"
        }
      ]
    },
    {
      "name": "File",
      "module": "param_functions",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\param_functions.py",
      "line_number": 1906,
      "end_line_number": 2217,
      "source_code": "def File(  # noqa: N802\n    default: Annotated[\n        Any,\n        Doc(\n            \"\"\"\n            Default value if the parameter field is not set.\n            \"\"\"\n        ),\n    ] = Undefined,\n    *,\n    default_factory: Annotated[\n        Union[Callable[[], Any], None],\n        Doc(\n            \"\"\"\n            A callable to generate the default value.\n\n            This doesn't affect `Path` parameters as the value is always required.\n            The parameter is available only for compatibility.\n            \"\"\"\n        ),\n    ] = _Unset,\n    media_type: Annotated[\n        str,\n        Doc(\n            \"\"\"\n            The media type of this parameter field. Changing it would affect the\n            generated OpenAPI, but currently it doesn't affect the parsing of the data.\n            \"\"\"\n        ),\n    ] = \"multipart/form-data\",\n    alias: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            An alternative name for the parameter field.\n\n            This will be used to extract the data and for the generated OpenAPI.\n            It is particularly useful when you can't use the name you want because it\n            is a Python reserved keyword or similar.\n            \"\"\"\n        ),\n    ] = None,\n    alias_priority: Annotated[\n        Union[int, None],\n        Doc(\n            \"\"\"\n            Priority of the alias. This affects whether an alias generator is used.\n            \"\"\"\n        ),\n    ] = _Unset,\n    # TODO: update when deprecating Pydantic v1, import these types\n    # validation_alias: str | AliasPath | AliasChoices | None\n    validation_alias: Annotated[\n        Union[str, None],\n        Doc(\n            \"\"\"\n            'Whitelist' validation step. The parameter field will be the single one\n            allowed by the alias or set of aliases defined.\n            \"\"\"\n        ),\n    ] = None,\n    serialization_alias: Annotated[\n        Union[str, None],\n        Doc(\n            \"\"\"\n            'Blacklist' validation step. The vanilla parameter field will be the\n            single one of the alias' or set of aliases' fields and all the other\n            fields will be ignored at serialization time.\n            \"\"\"\n        ),\n    ] = None,\n    title: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            Human-readable title.\n            \"\"\"\n        ),\n    ] = None,\n    description: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            Human-readable description.\n            \"\"\"\n        ),\n    ] = None,\n    gt: Annotated[\n        Optional[float],\n        Doc(\n            \"\"\"\n            Greater than. If set, value must be greater than this. Only applicable to\n            numbers.\n            \"\"\"\n        ),\n    ] = None,\n    ge: Annotated[\n        Optional[float],\n        Doc(\n            \"\"\"\n            Greater than or equal. If set, value must be greater than or equal to\n            this. Only applicable to numbers.\n            \"\"\"\n        ),\n    ] = None,\n    lt: Annotated[\n        Optional[float],\n        Doc(\n            \"\"\"\n            Less than. If set, value must be less than this. Only applicable to numbers.\n            \"\"\"\n        ),\n    ] = None,\n    le: Annotated[\n        Optional[float],\n        Doc(\n            \"\"\"\n            Less than or equal. If set, value must be less than or equal to this.\n            Only applicable to numbers.\n            \"\"\"\n        ),\n    ] = None,\n    min_length: Annotated[\n        Optional[int],\n        Doc(\n            \"\"\"\n            Minimum length for strings.\n            \"\"\"\n        ),\n    ] = None,\n    max_length: Annotated[\n        Optional[int],\n        Doc(\n            \"\"\"\n            Maximum length for strings.\n            \"\"\"\n        ),\n    ] = None,\n    pattern: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            RegEx pattern for strings.\n            \"\"\"\n        ),\n    ] = None,\n    regex: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            RegEx pattern for strings.\n            \"\"\"\n        ),\n        deprecated(\n            \"Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead.\"\n        ),\n    ] = None,\n    discriminator: Annotated[\n        Union[str, None],\n        Doc(\n            \"\"\"\n            Parameter field name for discriminating the type in a tagged union.\n            \"\"\"\n        ),\n    ] = None,\n    strict: Annotated[\n        Union[bool, None],\n        Doc(\n            \"\"\"\n            If `True`, strict validation is applied to the field.\n            \"\"\"\n        ),\n    ] = _Unset,\n    multiple_of: Annotated[\n        Union[float, None],\n        Doc(\n            \"\"\"\n            Value must be a multiple of this. Only applicable to numbers.\n            \"\"\"\n        ),\n    ] = _Unset,\n    allow_inf_nan: Annotated[\n        Union[bool, None],\n        Doc(\n            \"\"\"\n            Allow `inf`, `-inf`, `nan`. Only applicable to numbers.\n            \"\"\"\n        ),\n    ] = _Unset,\n    max_digits: Annotated[\n        Union[int, None],\n        Doc(\n            \"\"\"\n            Maximum number of allow digits for strings.\n            \"\"\"\n        ),\n    ] = _Unset,\n    decimal_places: Annotated[\n        Union[int, None],\n        Doc(\n            \"\"\"\n            Maximum number of decimal places allowed for numbers.\n            \"\"\"\n        ),\n    ] = _Unset,\n    examples: Annotated[\n        Optional[List[Any]],\n        Doc(\n            \"\"\"\n            Example values for this field.\n            \"\"\"\n        ),\n    ] = None,\n    example: Annotated[\n        Optional[Any],\n        deprecated(\n            \"Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, \"\n            \"although still supported. Use examples instead.\"\n        ),\n    ] = _Unset,\n    openapi_examples: Annotated[\n        Optional[Dict[str, Example]],\n        Doc(\n            \"\"\"\n            OpenAPI-specific examples.\n\n            It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n            Swagger UI (that provides the `/docs` interface) has better support for the\n            OpenAPI-specific examples than the JSON Schema `examples`, that's the main\n            use case for this.\n\n            Read more about it in the\n            [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).\n            \"\"\"\n        ),\n    ] = None,\n    deprecated: Annotated[\n        Union[deprecated, str, bool, None],\n        Doc(\n            \"\"\"\n            Mark this parameter field as deprecated.\n\n            It will affect the generated OpenAPI (e.g. visible at `/docs`).\n            \"\"\"\n        ),\n    ] = None,\n    include_in_schema: Annotated[\n        bool,\n        Doc(\n            \"\"\"\n            To include (or not) this parameter field in the generated OpenAPI.\n            You probably don't need it, but it's available.\n\n            This affects the generated OpenAPI (e.g. visible at `/docs`).\n            \"\"\"\n        ),\n    ] = True,\n    json_schema_extra: Annotated[\n        Union[Dict[str, Any], None],\n        Doc(\n            \"\"\"\n            Any additional JSON schema data.\n            \"\"\"\n        ),\n    ] = None,\n    **extra: Annotated[\n        Any,\n        Doc(\n            \"\"\"\n            Include extra fields used by the JSON Schema.\n            \"\"\"\n        ),\n        deprecated(\n            \"\"\"\n            The `extra` kwargs is deprecated. Use `json_schema_extra` instead.\n            \"\"\"\n        ),\n    ],\n) -> Any:\n    return params.File(\n        default=default,\n        default_factory=default_factory,\n        media_type=media_type,\n        alias=alias,\n        alias_priority=alias_priority,\n        validation_alias=validation_alias,\n        serialization_alias=serialization_alias,\n        title=title,\n        description=description,\n        gt=gt,\n        ge=ge,\n        lt=lt,\n        le=le,\n        min_length=min_length,\n        max_length=max_length,\n        pattern=pattern,\n        regex=regex,\n        discriminator=discriminator,\n        strict=strict,\n        multiple_of=multiple_of,\n        allow_inf_nan=allow_inf_nan,\n        max_digits=max_digits,\n        decimal_places=decimal_places,\n        example=example,\n        examples=examples,\n        openapi_examples=openapi_examples,\n        deprecated=deprecated,\n        include_in_schema=include_in_schema,\n        json_schema_extra=json_schema_extra,\n        **extra,\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "default"
      ],
      "imports": [
        "typing.Any",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Union",
        "fastapi.params",
        "fastapi._compat.Undefined",
        "fastapi.openapi.models.Example",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "params.File",
          "body": "def File(default: Annotated[Any, Doc('\\n            Default value if the parameter field is not set.\\n            ')]=Undefined, *, default_factory: Annotated[Union[Callable[[], Any], None], Doc(\"\\n            A callable to generate the default value.\\n\\n            This doesn't affect `Path` parameters as the value is always required.\\n            The parameter is available only for compatibility.\\n            \")]=_Unset, media_type: Annotated[str, Doc(\"\\n            The media type of this parameter field. Changing it would affect the\\n            generated OpenAPI, but currently it doesn't affect the parsing of the data.\\n            \")]='multipart/form-data', alias: Annotated[Optional[str], Doc(\"\\n            An alternative name for the parameter field.\\n\\n            This will be used to extract the data and for the generated OpenAPI.\\n            It is particularly useful when you can't use the name you want because it\\n            is a Python reserved keyword or similar.\\n            \")]=None, alias_priority: Annotated[Union[int, None], Doc('\\n            Priority of the alias. This affects whether an alias generator is used.\\n            ')]=_Unset, validation_alias: Annotated[Union[str, None], Doc(\"\\n            'Whitelist' validation step. The parameter field will be the single one\\n            allowed by the alias or set of aliases defined.\\n            \")]=None, serialization_alias: Annotated[Union[str, None], Doc(\"\\n            'Blacklist' validation step. The vanilla parameter field will be the\\n            single one of the alias' or set of aliases' fields and all the other\\n            fields will be ignored at serialization time.\\n            \")]=None, title: Annotated[Optional[str], Doc('\\n            Human-readable title.\\n            ')]=None, description: Annotated[Optional[str], Doc('\\n            Human-readable description.\\n            ')]=None, gt: Annotated[Optional[float], Doc('\\n            Greater than. If set, value must be greater than this. Only applicable to\\n            numbers.\\n            ')]=None, ge: Annotated[Optional[float], Doc('\\n            Greater than or equal. If set, value must be greater than or equal to\\n            this. Only applicable to numbers.\\n            ')]=None, lt: Annotated[Optional[float], Doc('\\n            Less than. If set, value must be less than this. Only applicable to numbers.\\n            ')]=None, le: Annotated[Optional[float], Doc('\\n            Less than or equal. If set, value must be less than or equal to this.\\n            Only applicable to numbers.\\n            ')]=None, min_length: Annotated[Optional[int], Doc('\\n            Minimum length for strings.\\n            ')]=None, max_length: Annotated[Optional[int], Doc('\\n            Maximum length for strings.\\n            ')]=None, pattern: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            ')]=None, regex: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            '), deprecated('Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead.')]=None, discriminator: Annotated[Union[str, None], Doc('\\n            Parameter field name for discriminating the type in a tagged union.\\n            ')]=None, strict: Annotated[Union[bool, None], Doc('\\n            If `True`, strict validation is applied to the field.\\n            ')]=_Unset, multiple_of: Annotated[Union[float, None], Doc('\\n            Value must be a multiple of this. Only applicable to numbers.\\n            ')]=_Unset, allow_inf_nan: Annotated[Union[bool, None], Doc('\\n            Allow `inf`, `-inf`, `nan`. Only applicable to numbers.\\n            ')]=_Unset, max_digits: Annotated[Union[int, None], Doc('\\n            Maximum number of allow digits for strings.\\n            ')]=_Unset, decimal_places: Annotated[Union[int, None], Doc('\\n            Maximum number of decimal places allowed for numbers.\\n            ')]=_Unset, examples: Annotated[Optional[List[Any]], Doc('\\n            Example values for this field.\\n            ')]=None, example: Annotated[Optional[Any], deprecated('Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.')]=_Unset, openapi_examples: Annotated[Optional[Dict[str, Example]], Doc(\"\\n            OpenAPI-specific examples.\\n\\n            It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n            Swagger UI (that provides the `/docs` interface) has better support for the\\n            OpenAPI-specific examples than the JSON Schema `examples`, that's the main\\n            use case for this.\\n\\n            Read more about it in the\\n            [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).\\n            \")]=None, deprecated: Annotated[Union[deprecated, str, bool, None], Doc('\\n            Mark this parameter field as deprecated.\\n\\n            It will affect the generated OpenAPI (e.g. visible at `/docs`).\\n            ')]=None, include_in_schema: Annotated[bool, Doc(\"\\n            To include (or not) this parameter field in the generated OpenAPI.\\n            You probably don't need it, but it's available.\\n\\n            This affects the generated OpenAPI (e.g. visible at `/docs`).\\n            \")]=True, json_schema_extra: Annotated[Union[Dict[str, Any], None], Doc('\\n            Any additional JSON schema data.\\n            ')]=None, **extra: Annotated[Any, Doc('\\n            Include extra fields used by the JSON Schema.\\n            '), deprecated('\\n            The `extra` kwargs is deprecated. Use `json_schema_extra` instead.\\n            ')]) -> Any:\n    return params.File(default=default, default_factory=default_factory, media_type=media_type, alias=alias, alias_priority=alias_priority, validation_alias=validation_alias, serialization_alias=serialization_alias, title=title, description=description, gt=gt, ge=ge, lt=lt, le=le, min_length=min_length, max_length=max_length, pattern=pattern, regex=regex, discriminator=discriminator, strict=strict, multiple_of=multiple_of, allow_inf_nan=allow_inf_nan, max_digits=max_digits, decimal_places=decimal_places, example=example, examples=examples, openapi_examples=openapi_examples, deprecated=deprecated, include_in_schema=include_in_schema, json_schema_extra=json_schema_extra, **extra)"
        }
      ]
    },
    {
      "name": "Depends",
      "module": "param_functions",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\param_functions.py",
      "line_number": 2220,
      "end_line_number": 2277,
      "source_code": "def Depends(  # noqa: N802\n    dependency: Annotated[\n        Optional[Callable[..., Any]],\n        Doc(\n            \"\"\"\n            A \"dependable\" callable (like a function).\n\n            Don't call it directly, FastAPI will call it for you, just pass the object\n            directly.\n            \"\"\"\n        ),\n    ] = None,\n    *,\n    use_cache: Annotated[\n        bool,\n        Doc(\n            \"\"\"\n            By default, after a dependency is called the first time in a request, if\n            the dependency is declared again for the rest of the request (for example\n            if the dependency is needed by several dependencies), the value will be\n            re-used for the rest of the request.\n\n            Set `use_cache` to `False` to disable this behavior and ensure the\n            dependency is called again (if declared more than once) in the same request.\n            \"\"\"\n        ),\n    ] = True,\n) -> Any:\n    \"\"\"\n    Declare a FastAPI dependency.\n\n    It takes a single \"dependable\" callable (like a function).\n\n    Don't call it directly, FastAPI will call it for you.\n\n    Read more about it in the\n    [FastAPI docs for Dependencies](https://fastapi.tiangolo.com/tutorial/dependencies/).\n\n    **Example**\n\n    ```python\n    from typing import Annotated\n\n    from fastapi import Depends, FastAPI\n\n    app = FastAPI()\n\n\n    async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):\n        return {\"q\": q, \"skip\": skip, \"limit\": limit}\n\n\n    @app.get(\"/items/\")\n    async def read_items(commons: Annotated[dict, Depends(common_parameters)]):\n        return commons\n    ```\n    \"\"\"\n    return params.Depends(dependency=dependency, use_cache=use_cache)",
      "docstring": "Declare a FastAPI dependency.\n\nIt takes a single \"dependable\" callable (like a function).\n\nDon't call it directly, FastAPI will call it for you.\n\nRead more about it in the\n[FastAPI docs for Dependencies](https://fastapi.tiangolo.com/tutorial/dependencies/).\n\n**Example**\n\n```python\nfrom typing import Annotated\n\nfrom fastapi import Depends, FastAPI\n\napp = FastAPI()\n\n\nasync def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):\n    return {\"q\": q, \"skip\": skip, \"limit\": limit}\n\n\n@app.get(\"/items/\")\nasync def read_items(commons: Annotated[dict, Depends(common_parameters)]):\n    return commons\n```",
      "decorators": [],
      "arguments": [
        "dependency"
      ],
      "imports": [
        "typing.Any",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Union",
        "fastapi.params",
        "fastapi._compat.Undefined",
        "fastapi.openapi.models.Example",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "params.Depends",
          "body": "def Depends(dependency: Annotated[Optional[Callable[..., Any]], Doc('\\n            A \"dependable\" callable (like a function).\\n\\n            Don\\'t call it directly, FastAPI will call it for you, just pass the object\\n            directly.\\n            ')]=None, *, use_cache: Annotated[bool, Doc('\\n            By default, after a dependency is called the first time in a request, if\\n            the dependency is declared again for the rest of the request (for example\\n            if the dependency is needed by several dependencies), the value will be\\n            re-used for the rest of the request.\\n\\n            Set `use_cache` to `False` to disable this behavior and ensure the\\n            dependency is called again (if declared more than once) in the same request.\\n            ')]=True) -> Any:\n    \"\"\"\n    Declare a FastAPI dependency.\n\n    It takes a single \"dependable\" callable (like a function).\n\n    Don't call it directly, FastAPI will call it for you.\n\n    Read more about it in the\n    [FastAPI docs for Dependencies](https://fastapi.tiangolo.com/tutorial/dependencies/).\n\n    **Example**\n\n    ```python\n    from typing import Annotated\n\n    from fastapi import Depends, FastAPI\n\n    app = FastAPI()\n\n\n    async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):\n        return {\"q\": q, \"skip\": skip, \"limit\": limit}\n\n\n    @app.get(\"/items/\")\n    async def read_items(commons: Annotated[dict, Depends(common_parameters)]):\n        return commons\n    ```\n    \"\"\"\n    return params.Depends(dependency=dependency, use_cache=use_cache)"
        }
      ]
    },
    {
      "name": "Security",
      "module": "param_functions",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\param_functions.py",
      "line_number": 2280,
      "end_line_number": 2360,
      "source_code": "def Security(  # noqa: N802\n    dependency: Annotated[\n        Optional[Callable[..., Any]],\n        Doc(\n            \"\"\"\n            A \"dependable\" callable (like a function).\n\n            Don't call it directly, FastAPI will call it for you, just pass the object\n            directly.\n            \"\"\"\n        ),\n    ] = None,\n    *,\n    scopes: Annotated[\n        Optional[Sequence[str]],\n        Doc(\n            \"\"\"\n            OAuth2 scopes required for the *path operation* that uses this Security\n            dependency.\n\n            The term \"scope\" comes from the OAuth2 specification, it seems to be\n            intentionally vague and interpretable. It normally refers to permissions,\n            in cases to roles.\n\n            These scopes are integrated with OpenAPI (and the API docs at `/docs`).\n            So they are visible in the OpenAPI specification.\n            )\n            \"\"\"\n        ),\n    ] = None,\n    use_cache: Annotated[\n        bool,\n        Doc(\n            \"\"\"\n            By default, after a dependency is called the first time in a request, if\n            the dependency is declared again for the rest of the request (for example\n            if the dependency is needed by several dependencies), the value will be\n            re-used for the rest of the request.\n\n            Set `use_cache` to `False` to disable this behavior and ensure the\n            dependency is called again (if declared more than once) in the same request.\n            \"\"\"\n        ),\n    ] = True,\n) -> Any:\n    \"\"\"\n    Declare a FastAPI Security dependency.\n\n    The only difference with a regular dependency is that it can declare OAuth2\n    scopes that will be integrated with OpenAPI and the automatic UI docs (by default\n    at `/docs`).\n\n    It takes a single \"dependable\" callable (like a function).\n\n    Don't call it directly, FastAPI will call it for you.\n\n    Read more about it in the\n    [FastAPI docs for Security](https://fastapi.tiangolo.com/tutorial/security/) and\n    in the\n    [FastAPI docs for OAuth2 scopes](https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/).\n\n    **Example**\n\n    ```python\n    from typing import Annotated\n\n    from fastapi import Security, FastAPI\n\n    from .db import User\n    from .security import get_current_active_user\n\n    app = FastAPI()\n\n    @app.get(\"/users/me/items/\")\n    async def read_own_items(\n        current_user: Annotated[User, Security(get_current_active_user, scopes=[\"items\"])]\n    ):\n        return [{\"item_id\": \"Foo\", \"owner\": current_user.username}]\n    ```\n    \"\"\"\n    return params.Security(dependency=dependency, scopes=scopes, use_cache=use_cache)",
      "docstring": "Declare a FastAPI Security dependency.\n\nThe only difference with a regular dependency is that it can declare OAuth2\nscopes that will be integrated with OpenAPI and the automatic UI docs (by default\nat `/docs`).\n\nIt takes a single \"dependable\" callable (like a function).\n\nDon't call it directly, FastAPI will call it for you.\n\nRead more about it in the\n[FastAPI docs for Security](https://fastapi.tiangolo.com/tutorial/security/) and\nin the\n[FastAPI docs for OAuth2 scopes](https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/).\n\n**Example**\n\n```python\nfrom typing import Annotated\n\nfrom fastapi import Security, FastAPI\n\nfrom .db import User\nfrom .security import get_current_active_user\n\napp = FastAPI()\n\n@app.get(\"/users/me/items/\")\nasync def read_own_items(\n    current_user: Annotated[User, Security(get_current_active_user, scopes=[\"items\"])]\n):\n    return [{\"item_id\": \"Foo\", \"owner\": current_user.username}]\n```",
      "decorators": [],
      "arguments": [
        "dependency"
      ],
      "imports": [
        "typing.Any",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Union",
        "fastapi.params",
        "fastapi._compat.Undefined",
        "fastapi.openapi.models.Example",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "params.Security",
          "body": "def Security(dependency: Annotated[Optional[Callable[..., Any]], Doc('\\n            A \"dependable\" callable (like a function).\\n\\n            Don\\'t call it directly, FastAPI will call it for you, just pass the object\\n            directly.\\n            ')]=None, *, scopes: Annotated[Optional[Sequence[str]], Doc('\\n            OAuth2 scopes required for the *path operation* that uses this Security\\n            dependency.\\n\\n            The term \"scope\" comes from the OAuth2 specification, it seems to be\\n            intentionally vague and interpretable. It normally refers to permissions,\\n            in cases to roles.\\n\\n            These scopes are integrated with OpenAPI (and the API docs at `/docs`).\\n            So they are visible in the OpenAPI specification.\\n            )\\n            ')]=None, use_cache: Annotated[bool, Doc('\\n            By default, after a dependency is called the first time in a request, if\\n            the dependency is declared again for the rest of the request (for example\\n            if the dependency is needed by several dependencies), the value will be\\n            re-used for the rest of the request.\\n\\n            Set `use_cache` to `False` to disable this behavior and ensure the\\n            dependency is called again (if declared more than once) in the same request.\\n            ')]=True) -> Any:\n    \"\"\"\n    Declare a FastAPI Security dependency.\n\n    The only difference with a regular dependency is that it can declare OAuth2\n    scopes that will be integrated with OpenAPI and the automatic UI docs (by default\n    at `/docs`).\n\n    It takes a single \"dependable\" callable (like a function).\n\n    Don't call it directly, FastAPI will call it for you.\n\n    Read more about it in the\n    [FastAPI docs for Security](https://fastapi.tiangolo.com/tutorial/security/) and\n    in the\n    [FastAPI docs for OAuth2 scopes](https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/).\n\n    **Example**\n\n    ```python\n    from typing import Annotated\n\n    from fastapi import Security, FastAPI\n\n    from .db import User\n    from .security import get_current_active_user\n\n    app = FastAPI()\n\n    @app.get(\"/users/me/items/\")\n    async def read_own_items(\n        current_user: Annotated[User, Security(get_current_active_user, scopes=[\"items\"])]\n    ):\n        return [{\"item_id\": \"Foo\", \"owner\": current_user.username}]\n    ```\n    \"\"\"\n    return params.Security(dependency=dependency, scopes=scopes, use_cache=use_cache)"
        }
      ]
    },
    {
      "name": "render",
      "module": "responses",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\responses.py",
      "line_number": 31,
      "end_line_number": 33,
      "source_code": "def render(self, content: Any) -> bytes:\n        assert ujson is not None, \"ujson must be installed to use UJSONResponse\"\n        return ujson.dumps(content, ensure_ascii=False).encode(\"utf-8\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "content"
      ],
      "imports": [
        "typing.Any",
        "starlette.responses.FileResponse",
        "starlette.responses.HTMLResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "ujson",
        "orjson"
      ],
      "fixtures": [],
      "assertions": [
        "assert ujson is not None, 'ujson must be installed to use UJSONResponse'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "render",
      "module": "responses",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\responses.py",
      "line_number": 44,
      "end_line_number": 48,
      "source_code": "def render(self, content: Any) -> bytes:\n        assert orjson is not None, \"orjson must be installed to use ORJSONResponse\"\n        return orjson.dumps(\n            content, option=orjson.OPT_NON_STR_KEYS | orjson.OPT_SERIALIZE_NUMPY\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "content"
      ],
      "imports": [
        "typing.Any",
        "starlette.responses.FileResponse",
        "starlette.responses.HTMLResponse",
        "starlette.responses.JSONResponse",
        "starlette.responses.PlainTextResponse",
        "starlette.responses.RedirectResponse",
        "starlette.responses.Response",
        "starlette.responses.StreamingResponse",
        "ujson",
        "orjson"
      ],
      "fixtures": [],
      "assertions": [
        "assert orjson is not None, 'orjson must be installed to use ORJSONResponse'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_prepare_response_content",
      "module": "routing",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\routing.py",
      "line_number": 79,
      "end_line_number": 123,
      "source_code": "def _prepare_response_content(\n    res: Any,\n    *,\n    exclude_unset: bool,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n) -> Any:\n    if isinstance(res, BaseModel):\n        read_with_orm_mode = getattr(_get_model_config(res), \"read_with_orm_mode\", None)\n        if read_with_orm_mode:\n            # Let from_orm extract the data from this model instead of converting\n            # it now to a dict.\n            # Otherwise, there's no way to extract lazy data that requires attribute\n            # access instead of dict iteration, e.g. lazy relationships.\n            return res\n        return _model_dump(\n            res,\n            by_alias=True,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n        )\n    elif isinstance(res, list):\n        return [\n            _prepare_response_content(\n                item,\n                exclude_unset=exclude_unset,\n                exclude_defaults=exclude_defaults,\n                exclude_none=exclude_none,\n            )\n            for item in res\n        ]\n    elif isinstance(res, dict):\n        return {\n            k: _prepare_response_content(\n                v,\n                exclude_unset=exclude_unset,\n                exclude_defaults=exclude_defaults,\n                exclude_none=exclude_none,\n            )\n            for k, v in res.items()\n        }\n    elif dataclasses.is_dataclass(res):\n        return dataclasses.asdict(res)\n    return res",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "res"
      ],
      "imports": [
        "asyncio",
        "dataclasses",
        "email.message",
        "inspect",
        "json",
        "contextlib.AsyncExitStack",
        "contextlib.asynccontextmanager",
        "enum.Enum",
        "enum.IntEnum",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.params",
        "fastapi._compat.ModelField",
        "fastapi._compat.Undefined",
        "fastapi._compat._get_model_config",
        "fastapi._compat._model_dump",
        "fastapi._compat._normalize_errors",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.utils._should_embed_body_fields",
        "fastapi.dependencies.utils.get_body_field",
        "fastapi.dependencies.utils.get_dependant",
        "fastapi.dependencies.utils.get_flat_dependant",
        "fastapi.dependencies.utils.get_parameterless_sub_dependant",
        "fastapi.dependencies.utils.get_typed_return_annotation",
        "fastapi.dependencies.utils.solve_dependencies",
        "fastapi.encoders.jsonable_encoder",
        "fastapi.exceptions.FastAPIError",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.ResponseValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.create_cloned_field",
        "fastapi.utils.create_model_field",
        "fastapi.utils.generate_unique_id",
        "fastapi.utils.get_value_or_default",
        "fastapi.utils.is_body_allowed_for_status_code",
        "pydantic.BaseModel",
        "starlette.routing",
        "starlette.concurrency.run_in_threadpool",
        "starlette.exceptions.HTTPException",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.routing.Match",
        "starlette.routing.compile_path",
        "starlette.routing.get_name",
        "starlette.routing.request_response",
        "starlette.routing.websocket_session",
        "starlette.routing.Mount",
        "starlette.types.AppType",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Scope",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "_model_dump",
          "body": "def _model_dump(model: BaseModel, mode: Literal['json', 'python']='json', **kwargs: Any) -> Any:\n    return model.model_dump(mode=mode, **kwargs)"
        },
        {
          "name": "_get_model_config",
          "body": "def _get_model_config(model: BaseModel) -> Any:\n    return model.model_config"
        },
        {
          "name": "_prepare_response_content",
          "body": "def _prepare_response_content(res: Any, *, exclude_unset: bool, exclude_defaults: bool=False, exclude_none: bool=False) -> Any:\n    if isinstance(res, BaseModel):\n        read_with_orm_mode = getattr(_get_model_config(res), 'read_with_orm_mode', None)\n        if read_with_orm_mode:\n            return res\n        return _model_dump(res, by_alias=True, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none)\n    elif isinstance(res, list):\n        return [_prepare_response_content(item, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none) for item in res]\n    elif isinstance(res, dict):\n        return {k: _prepare_response_content(v, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none) for k, v in res.items()}\n    elif dataclasses.is_dataclass(res):\n        return dataclasses.asdict(res)\n    return res"
        },
        {
          "name": "_prepare_response_content",
          "body": "def _prepare_response_content(res: Any, *, exclude_unset: bool, exclude_defaults: bool=False, exclude_none: bool=False) -> Any:\n    if isinstance(res, BaseModel):\n        read_with_orm_mode = getattr(_get_model_config(res), 'read_with_orm_mode', None)\n        if read_with_orm_mode:\n            return res\n        return _model_dump(res, by_alias=True, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none)\n    elif isinstance(res, list):\n        return [_prepare_response_content(item, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none) for item in res]\n    elif isinstance(res, dict):\n        return {k: _prepare_response_content(v, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none) for k, v in res.items()}\n    elif dataclasses.is_dataclass(res):\n        return dataclasses.asdict(res)\n    return res"
        }
      ]
    },
    {
      "name": "_merge_lifespan_context",
      "module": "routing",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\routing.py",
      "line_number": 126,
      "end_line_number": 140,
      "source_code": "def _merge_lifespan_context(\n    original_context: Lifespan[Any], nested_context: Lifespan[Any]\n) -> Lifespan[Any]:\n    @asynccontextmanager\n    async def merged_lifespan(\n        app: AppType,\n    ) -> AsyncIterator[Optional[Mapping[str, Any]]]:\n        async with original_context(app) as maybe_original_state:\n            async with nested_context(app) as maybe_nested_state:\n                if maybe_nested_state is None and maybe_original_state is None:\n                    yield None  # old ASGI compatibility\n                else:\n                    yield {**(maybe_nested_state or {}), **(maybe_original_state or {})}\n\n    return merged_lifespan",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "original_context",
        "nested_context"
      ],
      "imports": [
        "asyncio",
        "dataclasses",
        "email.message",
        "inspect",
        "json",
        "contextlib.AsyncExitStack",
        "contextlib.asynccontextmanager",
        "enum.Enum",
        "enum.IntEnum",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.params",
        "fastapi._compat.ModelField",
        "fastapi._compat.Undefined",
        "fastapi._compat._get_model_config",
        "fastapi._compat._model_dump",
        "fastapi._compat._normalize_errors",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.utils._should_embed_body_fields",
        "fastapi.dependencies.utils.get_body_field",
        "fastapi.dependencies.utils.get_dependant",
        "fastapi.dependencies.utils.get_flat_dependant",
        "fastapi.dependencies.utils.get_parameterless_sub_dependant",
        "fastapi.dependencies.utils.get_typed_return_annotation",
        "fastapi.dependencies.utils.solve_dependencies",
        "fastapi.encoders.jsonable_encoder",
        "fastapi.exceptions.FastAPIError",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.ResponseValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.create_cloned_field",
        "fastapi.utils.create_model_field",
        "fastapi.utils.generate_unique_id",
        "fastapi.utils.get_value_or_default",
        "fastapi.utils.is_body_allowed_for_status_code",
        "pydantic.BaseModel",
        "starlette.routing",
        "starlette.concurrency.run_in_threadpool",
        "starlette.exceptions.HTTPException",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.routing.Match",
        "starlette.routing.compile_path",
        "starlette.routing.get_name",
        "starlette.routing.request_response",
        "starlette.routing.websocket_session",
        "starlette.routing.Mount",
        "starlette.types.AppType",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Scope",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "get_request_handler",
      "module": "routing",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\routing.py",
      "line_number": 217,
      "end_line_number": 357,
      "source_code": "def get_request_handler(\n    dependant: Dependant,\n    body_field: Optional[ModelField] = None,\n    status_code: Optional[int] = None,\n    response_class: Union[Type[Response], DefaultPlaceholder] = Default(JSONResponse),\n    response_field: Optional[ModelField] = None,\n    response_model_include: Optional[IncEx] = None,\n    response_model_exclude: Optional[IncEx] = None,\n    response_model_by_alias: bool = True,\n    response_model_exclude_unset: bool = False,\n    response_model_exclude_defaults: bool = False,\n    response_model_exclude_none: bool = False,\n    dependency_overrides_provider: Optional[Any] = None,\n    embed_body_fields: bool = False,\n) -> Callable[[Request], Coroutine[Any, Any, Response]]:\n    assert dependant.call is not None, \"dependant.call must be a function\"\n    is_coroutine = asyncio.iscoroutinefunction(dependant.call)\n    is_body_form = body_field and isinstance(body_field.field_info, params.Form)\n    if isinstance(response_class, DefaultPlaceholder):\n        actual_response_class: Type[Response] = response_class.value\n    else:\n        actual_response_class = response_class\n\n    async def app(request: Request) -> Response:\n        response: Union[Response, None] = None\n        async with AsyncExitStack() as file_stack:\n            try:\n                body: Any = None\n                if body_field:\n                    if is_body_form:\n                        body = await request.form()\n                        file_stack.push_async_callback(body.close)\n                    else:\n                        body_bytes = await request.body()\n                        if body_bytes:\n                            json_body: Any = Undefined\n                            content_type_value = request.headers.get(\"content-type\")\n                            if not content_type_value:\n                                json_body = await request.json()\n                            else:\n                                message = email.message.Message()\n                                message[\"content-type\"] = content_type_value\n                                if message.get_content_maintype() == \"application\":\n                                    subtype = message.get_content_subtype()\n                                    if subtype == \"json\" or subtype.endswith(\"+json\"):\n                                        json_body = await request.json()\n                            if json_body != Undefined:\n                                body = json_body\n                            else:\n                                body = body_bytes\n            except json.JSONDecodeError as e:\n                validation_error = RequestValidationError(\n                    [\n                        {\n                            \"type\": \"json_invalid\",\n                            \"loc\": (\"body\", e.pos),\n                            \"msg\": \"JSON decode error\",\n                            \"input\": {},\n                            \"ctx\": {\"error\": e.msg},\n                        }\n                    ],\n                    body=e.doc,\n                )\n                raise validation_error from e\n            except HTTPException:\n                # If a middleware raises an HTTPException, it should be raised again\n                raise\n            except Exception as e:\n                http_error = HTTPException(\n                    status_code=400, detail=\"There was an error parsing the body\"\n                )\n                raise http_error from e\n            errors: List[Any] = []\n            async with AsyncExitStack() as async_exit_stack:\n                solved_result = await solve_dependencies(\n                    request=request,\n                    dependant=dependant,\n                    body=body,\n                    dependency_overrides_provider=dependency_overrides_provider,\n                    async_exit_stack=async_exit_stack,\n                    embed_body_fields=embed_body_fields,\n                )\n                errors = solved_result.errors\n                if not errors:\n                    raw_response = await run_endpoint_function(\n                        dependant=dependant,\n                        values=solved_result.values,\n                        is_coroutine=is_coroutine,\n                    )\n                    if isinstance(raw_response, Response):\n                        if raw_response.background is None:\n                            raw_response.background = solved_result.background_tasks\n                        response = raw_response\n                    else:\n                        response_args: Dict[str, Any] = {\n                            \"background\": solved_result.background_tasks\n                        }\n                        # If status_code was set, use it, otherwise use the default from the\n                        # response class, in the case of redirect it's 307\n                        current_status_code = (\n                            status_code\n                            if status_code\n                            else solved_result.response.status_code\n                        )\n                        if current_status_code is not None:\n                            response_args[\"status_code\"] = current_status_code\n                        if solved_result.response.status_code:\n                            response_args[\"status_code\"] = (\n                                solved_result.response.status_code\n                            )\n                        content = await serialize_response(\n                            field=response_field,\n                            response_content=raw_response,\n                            include=response_model_include,\n                            exclude=response_model_exclude,\n                            by_alias=response_model_by_alias,\n                            exclude_unset=response_model_exclude_unset,\n                            exclude_defaults=response_model_exclude_defaults,\n                            exclude_none=response_model_exclude_none,\n                            is_coroutine=is_coroutine,\n                        )\n                        response = actual_response_class(content, **response_args)\n                        if not is_body_allowed_for_status_code(response.status_code):\n                            response.body = b\"\"\n                        response.headers.raw.extend(solved_result.response.headers.raw)\n            if errors:\n                validation_error = RequestValidationError(\n                    _normalize_errors(errors), body=body\n                )\n                raise validation_error\n        if response is None:\n            raise FastAPIError(\n                \"No response object was returned. There's a high chance that the \"\n                \"application code is raising an exception and a dependency with yield \"\n                \"has a block with a bare except, or a block with except Exception, \"\n                \"and is not raising the exception again. Read more about it in the \"\n                \"docs: https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-with-yield/#dependencies-with-yield-and-except\"\n            )\n        return response\n\n    return app",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "dependant",
        "body_field",
        "status_code",
        "response_class",
        "response_field",
        "response_model_include",
        "response_model_exclude",
        "response_model_by_alias",
        "response_model_exclude_unset",
        "response_model_exclude_defaults",
        "response_model_exclude_none",
        "dependency_overrides_provider",
        "embed_body_fields"
      ],
      "imports": [
        "asyncio",
        "dataclasses",
        "email.message",
        "inspect",
        "json",
        "contextlib.AsyncExitStack",
        "contextlib.asynccontextmanager",
        "enum.Enum",
        "enum.IntEnum",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.params",
        "fastapi._compat.ModelField",
        "fastapi._compat.Undefined",
        "fastapi._compat._get_model_config",
        "fastapi._compat._model_dump",
        "fastapi._compat._normalize_errors",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.utils._should_embed_body_fields",
        "fastapi.dependencies.utils.get_body_field",
        "fastapi.dependencies.utils.get_dependant",
        "fastapi.dependencies.utils.get_flat_dependant",
        "fastapi.dependencies.utils.get_parameterless_sub_dependant",
        "fastapi.dependencies.utils.get_typed_return_annotation",
        "fastapi.dependencies.utils.solve_dependencies",
        "fastapi.encoders.jsonable_encoder",
        "fastapi.exceptions.FastAPIError",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.ResponseValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.create_cloned_field",
        "fastapi.utils.create_model_field",
        "fastapi.utils.generate_unique_id",
        "fastapi.utils.get_value_or_default",
        "fastapi.utils.is_body_allowed_for_status_code",
        "pydantic.BaseModel",
        "starlette.routing",
        "starlette.concurrency.run_in_threadpool",
        "starlette.exceptions.HTTPException",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.routing.Match",
        "starlette.routing.compile_path",
        "starlette.routing.get_name",
        "starlette.routing.request_response",
        "starlette.routing.websocket_session",
        "starlette.routing.Mount",
        "starlette.types.AppType",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Scope",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [
        "assert dependant.call is not None, 'dependant.call must be a function'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "_normalize_errors",
          "body": "def _normalize_errors(errors: Sequence[Any]) -> List[Dict[str, Any]]:\n    return errors"
        },
        {
          "name": "request.headers.get",
          "body": "def get(self, path: Annotated[str, Doc('\\n                The URL path to be used for this *path operation*.\\n\\n                For example, in `http://example.com/items`, the path is `/items`.\\n                ')], *, response_model: Annotated[Any, Doc(\"\\n                The type to use for the response.\\n\\n                It could be any valid Pydantic *field* type. So, it doesn't have to\\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\\n                etc.\\n\\n                It will be used for:\\n\\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\\n                    show it as the response (JSON Schema).\\n                * Serialization: you could return an arbitrary object and the\\n                    `response_model` would be used to serialize that object into the\\n                    corresponding JSON.\\n                * Filtering: the JSON sent to the client will only contain the data\\n                    (fields) defined in the `response_model`. If you returned an object\\n                    that contains an attribute `password` but the `response_model` does\\n                    not include that field, the JSON sent to the client would not have\\n                    that `password`.\\n                * Validation: whatever you return will be serialized with the\\n                    `response_model`, converting any data as necessary to generate the\\n                    corresponding JSON. But if the data in the object returned is not\\n                    valid, that would mean a violation of the contract with the client,\\n                    so it's an error from the API developer. So, FastAPI will raise an\\n                    error and return a 500 error code (Internal Server Error).\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\\n                \")]=Default(None), status_code: Annotated[Optional[int], Doc('\\n                The default status code to be used for the response.\\n\\n                You could override the status code by returning a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\\n                ')]=None, tags: Annotated[Optional[List[Union[str, Enum]]], Doc('\\n                A list of tags to be applied to the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\\n                ')]=None, dependencies: Annotated[Optional[Sequence[Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to the\\n                *path operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\\n                ')]=None, summary: Annotated[Optional[str], Doc('\\n                A summary for the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, description: Annotated[Optional[str], Doc('\\n                A description for the *path operation*.\\n\\n                If not provided, it will be extracted automatically from the docstring\\n                of the *path operation function*.\\n\\n                It can contain Markdown.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, response_description: Annotated[str, Doc('\\n                The description for the default response.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]='Successful Response', responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses that could be returned by this *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark this *path operation* as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, operation_id: Annotated[Optional[str], Doc('\\n                Custom operation ID to be used by this *path operation*.\\n\\n                By default, it is generated automatically.\\n\\n                If you provide a custom operation ID, you need to make sure it is\\n                unique for the whole API.\\n\\n                You can customize the\\n                operation ID generation with the parameter\\n                `generate_unique_id_function` in the `FastAPI` class.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=None, response_model_include: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to include only certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_exclude: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to exclude certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_by_alias: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response model\\n                should be serialized by alias when an alias is used.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=True, response_model_exclude_unset: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that were not set and\\n                have their default values. This is different from\\n                `response_model_exclude_defaults` in that if the fields are set,\\n                they will be included in the response, even if the value is the same\\n                as the default.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_defaults: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that have the same value\\n                as the default. This is different from `response_model_exclude_unset`\\n                in that if the fields are set but contain the same default values,\\n                they will be excluded from the response.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_none: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data should\\n                exclude fields set to `None`.\\n\\n                This is much simpler (less smart) than `response_model_exclude_unset`\\n                and `response_model_exclude_defaults`. You probably want to use one of\\n                those two instead of this one, as those allow returning `None` values\\n                when it makes sense.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\\n                ')]=False, include_in_schema: Annotated[bool, Doc('\\n                Include this *path operation* in the generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\\n                ')]=True, response_class: Annotated[Type[Response], Doc('\\n                Response class to be used for this *path operation*.\\n\\n                This will not be used if you return a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\\n                ')]=Default(JSONResponse), name: Annotated[Optional[str], Doc('\\n                Name for this *path operation*. Only used internally.\\n                ')]=None, callbacks: Annotated[Optional[List[BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")]=None, openapi_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n                Extra metadata to be included in the OpenAPI schema for this *path\\n                operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\\n                ')]=None, generate_unique_id_function: Annotated[Callable[[routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=Default(generate_unique_id)) -> Callable[[DecoratedCallable], DecoratedCallable]:\n    \"\"\"\n        Add a *path operation* using an HTTP GET operation.\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI\n\n        app = FastAPI()\n\n        @app.get(\"/items/\")\n        def read_items():\n            return [{\"name\": \"Empanada\"}, {\"name\": \"Arepa\"}]\n        ```\n        \"\"\"\n    return self.router.get(path, response_model=response_model, status_code=status_code, tags=tags, dependencies=dependencies, summary=summary, description=description, response_description=response_description, responses=responses, deprecated=deprecated, operation_id=operation_id, response_model_include=response_model_include, response_model_exclude=response_model_exclude, response_model_by_alias=response_model_by_alias, response_model_exclude_unset=response_model_exclude_unset, response_model_exclude_defaults=response_model_exclude_defaults, response_model_exclude_none=response_model_exclude_none, include_in_schema=include_in_schema, response_class=response_class, name=name, callbacks=callbacks, openapi_extra=openapi_extra, generate_unique_id_function=generate_unique_id_function)"
        },
        {
          "name": "is_body_allowed_for_status_code",
          "body": "def is_body_allowed_for_status_code(status_code: Union[int, str, None]) -> bool:\n    if status_code is None:\n        return True\n    if status_code in {'default', '1XX', '2XX', '3XX', '4XX', '5XX'}:\n        return True\n    current_status_code = int(status_code)\n    return not (current_status_code < 200 or current_status_code in {204, 205, 304})"
        }
      ]
    },
    {
      "name": "get_websocket_app",
      "module": "routing",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\routing.py",
      "line_number": 360,
      "end_line_number": 385,
      "source_code": "def get_websocket_app(\n    dependant: Dependant,\n    dependency_overrides_provider: Optional[Any] = None,\n    embed_body_fields: bool = False,\n) -> Callable[[WebSocket], Coroutine[Any, Any, Any]]:\n    async def app(websocket: WebSocket) -> None:\n        async with AsyncExitStack() as async_exit_stack:\n            # TODO: remove this scope later, after a few releases\n            # This scope fastapi_astack is no longer used by FastAPI, kept for\n            # compatibility, just in case\n            websocket.scope[\"fastapi_astack\"] = async_exit_stack\n            solved_result = await solve_dependencies(\n                request=websocket,\n                dependant=dependant,\n                dependency_overrides_provider=dependency_overrides_provider,\n                async_exit_stack=async_exit_stack,\n                embed_body_fields=embed_body_fields,\n            )\n            if solved_result.errors:\n                raise WebSocketRequestValidationError(\n                    _normalize_errors(solved_result.errors)\n                )\n            assert dependant.call is not None, \"dependant.call must be a function\"\n            await dependant.call(**solved_result.values)\n\n    return app",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "dependant",
        "dependency_overrides_provider",
        "embed_body_fields"
      ],
      "imports": [
        "asyncio",
        "dataclasses",
        "email.message",
        "inspect",
        "json",
        "contextlib.AsyncExitStack",
        "contextlib.asynccontextmanager",
        "enum.Enum",
        "enum.IntEnum",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.params",
        "fastapi._compat.ModelField",
        "fastapi._compat.Undefined",
        "fastapi._compat._get_model_config",
        "fastapi._compat._model_dump",
        "fastapi._compat._normalize_errors",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.utils._should_embed_body_fields",
        "fastapi.dependencies.utils.get_body_field",
        "fastapi.dependencies.utils.get_dependant",
        "fastapi.dependencies.utils.get_flat_dependant",
        "fastapi.dependencies.utils.get_parameterless_sub_dependant",
        "fastapi.dependencies.utils.get_typed_return_annotation",
        "fastapi.dependencies.utils.solve_dependencies",
        "fastapi.encoders.jsonable_encoder",
        "fastapi.exceptions.FastAPIError",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.ResponseValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.create_cloned_field",
        "fastapi.utils.create_model_field",
        "fastapi.utils.generate_unique_id",
        "fastapi.utils.get_value_or_default",
        "fastapi.utils.is_body_allowed_for_status_code",
        "pydantic.BaseModel",
        "starlette.routing",
        "starlette.concurrency.run_in_threadpool",
        "starlette.exceptions.HTTPException",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.routing.Match",
        "starlette.routing.compile_path",
        "starlette.routing.get_name",
        "starlette.routing.request_response",
        "starlette.routing.websocket_session",
        "starlette.routing.Mount",
        "starlette.types.AppType",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Scope",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [
        "assert dependant.call is not None, 'dependant.call must be a function'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "_normalize_errors",
          "body": "def _normalize_errors(errors: Sequence[Any]) -> List[Dict[str, Any]]:\n    return errors"
        }
      ]
    },
    {
      "name": "__init__",
      "module": "routing",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\routing.py",
      "line_number": 389,
      "end_line_number": 419,
      "source_code": "def __init__(\n        self,\n        path: str,\n        endpoint: Callable[..., Any],\n        *,\n        name: Optional[str] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        dependency_overrides_provider: Optional[Any] = None,\n    ) -> None:\n        self.path = path\n        self.endpoint = endpoint\n        self.name = get_name(endpoint) if name is None else name\n        self.dependencies = list(dependencies or [])\n        self.path_regex, self.path_format, self.param_convertors = compile_path(path)\n        self.dependant = get_dependant(path=self.path_format, call=self.endpoint)\n        for depends in self.dependencies[::-1]:\n            self.dependant.dependencies.insert(\n                0,\n                get_parameterless_sub_dependant(depends=depends, path=self.path_format),\n            )\n        self._flat_dependant = get_flat_dependant(self.dependant)\n        self._embed_body_fields = _should_embed_body_fields(\n            self._flat_dependant.body_params\n        )\n        self.app = websocket_session(\n            get_websocket_app(\n                dependant=self.dependant,\n                dependency_overrides_provider=dependency_overrides_provider,\n                embed_body_fields=self._embed_body_fields,\n            )\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "path",
        "endpoint"
      ],
      "imports": [
        "asyncio",
        "dataclasses",
        "email.message",
        "inspect",
        "json",
        "contextlib.AsyncExitStack",
        "contextlib.asynccontextmanager",
        "enum.Enum",
        "enum.IntEnum",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.params",
        "fastapi._compat.ModelField",
        "fastapi._compat.Undefined",
        "fastapi._compat._get_model_config",
        "fastapi._compat._model_dump",
        "fastapi._compat._normalize_errors",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.utils._should_embed_body_fields",
        "fastapi.dependencies.utils.get_body_field",
        "fastapi.dependencies.utils.get_dependant",
        "fastapi.dependencies.utils.get_flat_dependant",
        "fastapi.dependencies.utils.get_parameterless_sub_dependant",
        "fastapi.dependencies.utils.get_typed_return_annotation",
        "fastapi.dependencies.utils.solve_dependencies",
        "fastapi.encoders.jsonable_encoder",
        "fastapi.exceptions.FastAPIError",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.ResponseValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.create_cloned_field",
        "fastapi.utils.create_model_field",
        "fastapi.utils.generate_unique_id",
        "fastapi.utils.get_value_or_default",
        "fastapi.utils.is_body_allowed_for_status_code",
        "pydantic.BaseModel",
        "starlette.routing",
        "starlette.concurrency.run_in_threadpool",
        "starlette.exceptions.HTTPException",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.routing.Match",
        "starlette.routing.compile_path",
        "starlette.routing.get_name",
        "starlette.routing.request_response",
        "starlette.routing.websocket_session",
        "starlette.routing.Mount",
        "starlette.types.AppType",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Scope",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_dependant",
          "body": "def get_dependant(*, path: str, call: Callable[..., Any], name: Optional[str]=None, security_scopes: Optional[List[str]]=None, use_cache: bool=True) -> Dependant:\n    path_param_names = get_path_param_names(path)\n    endpoint_signature = get_typed_signature(call)\n    signature_params = endpoint_signature.parameters\n    dependant = Dependant(call=call, name=name, path=path, security_scopes=security_scopes, use_cache=use_cache)\n    for param_name, param in signature_params.items():\n        is_path_param = param_name in path_param_names\n        param_details = analyze_param(param_name=param_name, annotation=param.annotation, value=param.default, is_path_param=is_path_param)\n        if param_details.depends is not None:\n            sub_dependant = get_param_sub_dependant(param_name=param_name, depends=param_details.depends, path=path, security_scopes=security_scopes)\n            dependant.dependencies.append(sub_dependant)\n            continue\n        if add_non_field_param_to_dependency(param_name=param_name, type_annotation=param_details.type_annotation, dependant=dependant):\n            assert param_details.field is None, f'Cannot specify multiple FastAPI annotations for {param_name!r}'\n            continue\n        assert param_details.field is not None\n        if isinstance(param_details.field.field_info, params.Body):\n            dependant.body_params.append(param_details.field)\n        else:\n            add_param_to_fields(field=param_details.field, dependant=dependant)\n    return dependant"
        },
        {
          "name": "get_flat_dependant",
          "body": "def get_flat_dependant(dependant: Dependant, *, skip_repeats: bool=False, visited: Optional[List[CacheKey]]=None) -> Dependant:\n    if visited is None:\n        visited = []\n    visited.append(dependant.cache_key)\n    flat_dependant = Dependant(path_params=dependant.path_params.copy(), query_params=dependant.query_params.copy(), header_params=dependant.header_params.copy(), cookie_params=dependant.cookie_params.copy(), body_params=dependant.body_params.copy(), security_requirements=dependant.security_requirements.copy(), use_cache=dependant.use_cache, path=dependant.path)\n    for sub_dependant in dependant.dependencies:\n        if skip_repeats and sub_dependant.cache_key in visited:\n            continue\n        flat_sub = get_flat_dependant(sub_dependant, skip_repeats=skip_repeats, visited=visited)\n        flat_dependant.path_params.extend(flat_sub.path_params)\n        flat_dependant.query_params.extend(flat_sub.query_params)\n        flat_dependant.header_params.extend(flat_sub.header_params)\n        flat_dependant.cookie_params.extend(flat_sub.cookie_params)\n        flat_dependant.body_params.extend(flat_sub.body_params)\n        flat_dependant.security_requirements.extend(flat_sub.security_requirements)\n    return flat_dependant"
        },
        {
          "name": "_should_embed_body_fields",
          "body": "def _should_embed_body_fields(fields: List[ModelField]) -> bool:\n    if not fields:\n        return False\n    body_param_names_set = {field.name for field in fields}\n    if len(body_param_names_set) > 1:\n        return True\n    first_field = fields[0]\n    if getattr(first_field.field_info, 'embed', None):\n        return True\n    if isinstance(first_field.field_info, params.Form) and (not lenient_issubclass(first_field.type_, BaseModel)):\n        return True\n    return False"
        },
        {
          "name": "get_websocket_app",
          "body": "def get_websocket_app(dependant: Dependant, dependency_overrides_provider: Optional[Any]=None, embed_body_fields: bool=False) -> Callable[[WebSocket], Coroutine[Any, Any, Any]]:\n\n    async def app(websocket: WebSocket) -> None:\n        async with AsyncExitStack() as async_exit_stack:\n            websocket.scope['fastapi_astack'] = async_exit_stack\n            solved_result = await solve_dependencies(request=websocket, dependant=dependant, dependency_overrides_provider=dependency_overrides_provider, async_exit_stack=async_exit_stack, embed_body_fields=embed_body_fields)\n            if solved_result.errors:\n                raise WebSocketRequestValidationError(_normalize_errors(solved_result.errors))\n            assert dependant.call is not None, 'dependant.call must be a function'\n            await dependant.call(**solved_result.values)\n    return app"
        },
        {
          "name": "get_parameterless_sub_dependant",
          "body": "def get_parameterless_sub_dependant(*, depends: params.Depends, path: str) -> Dependant:\n    assert callable(depends.dependency), 'A parameter-less dependency must have a callable dependency'\n    return get_sub_dependant(depends=depends, dependency=depends.dependency, path=path)"
        }
      ]
    },
    {
      "name": "matches",
      "module": "routing",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\routing.py",
      "line_number": 421,
      "end_line_number": 425,
      "source_code": "def matches(self, scope: Scope) -> Tuple[Match, Scope]:\n        match, child_scope = super().matches(scope)\n        if match != Match.NONE:\n            child_scope[\"route\"] = self\n        return match, child_scope",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "scope"
      ],
      "imports": [
        "asyncio",
        "dataclasses",
        "email.message",
        "inspect",
        "json",
        "contextlib.AsyncExitStack",
        "contextlib.asynccontextmanager",
        "enum.Enum",
        "enum.IntEnum",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.params",
        "fastapi._compat.ModelField",
        "fastapi._compat.Undefined",
        "fastapi._compat._get_model_config",
        "fastapi._compat._model_dump",
        "fastapi._compat._normalize_errors",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.utils._should_embed_body_fields",
        "fastapi.dependencies.utils.get_body_field",
        "fastapi.dependencies.utils.get_dependant",
        "fastapi.dependencies.utils.get_flat_dependant",
        "fastapi.dependencies.utils.get_parameterless_sub_dependant",
        "fastapi.dependencies.utils.get_typed_return_annotation",
        "fastapi.dependencies.utils.solve_dependencies",
        "fastapi.encoders.jsonable_encoder",
        "fastapi.exceptions.FastAPIError",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.ResponseValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.create_cloned_field",
        "fastapi.utils.create_model_field",
        "fastapi.utils.generate_unique_id",
        "fastapi.utils.get_value_or_default",
        "fastapi.utils.is_body_allowed_for_status_code",
        "pydantic.BaseModel",
        "starlette.routing",
        "starlette.concurrency.run_in_threadpool",
        "starlette.exceptions.HTTPException",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.routing.Match",
        "starlette.routing.compile_path",
        "starlette.routing.get_name",
        "starlette.routing.request_response",
        "starlette.routing.websocket_session",
        "starlette.routing.Mount",
        "starlette.types.AppType",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Scope",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "routing",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\routing.py",
      "line_number": 429,
      "end_line_number": 569,
      "source_code": "def __init__(\n        self,\n        path: str,\n        endpoint: Callable[..., Any],\n        *,\n        response_model: Any = Default(None),\n        status_code: Optional[int] = None,\n        tags: Optional[List[Union[str, Enum]]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        name: Optional[str] = None,\n        methods: Optional[Union[Set[str], List[str]]] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[IncEx] = None,\n        response_model_exclude: Optional[IncEx] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Union[Type[Response], DefaultPlaceholder] = Default(\n            JSONResponse\n        ),\n        dependency_overrides_provider: Optional[Any] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n        generate_unique_id_function: Union[\n            Callable[[\"APIRoute\"], str], DefaultPlaceholder\n        ] = Default(generate_unique_id),\n    ) -> None:\n        self.path = path\n        self.endpoint = endpoint\n        if isinstance(response_model, DefaultPlaceholder):\n            return_annotation = get_typed_return_annotation(endpoint)\n            if lenient_issubclass(return_annotation, Response):\n                response_model = None\n            else:\n                response_model = return_annotation\n        self.response_model = response_model\n        self.summary = summary\n        self.response_description = response_description\n        self.deprecated = deprecated\n        self.operation_id = operation_id\n        self.response_model_include = response_model_include\n        self.response_model_exclude = response_model_exclude\n        self.response_model_by_alias = response_model_by_alias\n        self.response_model_exclude_unset = response_model_exclude_unset\n        self.response_model_exclude_defaults = response_model_exclude_defaults\n        self.response_model_exclude_none = response_model_exclude_none\n        self.include_in_schema = include_in_schema\n        self.response_class = response_class\n        self.dependency_overrides_provider = dependency_overrides_provider\n        self.callbacks = callbacks\n        self.openapi_extra = openapi_extra\n        self.generate_unique_id_function = generate_unique_id_function\n        self.tags = tags or []\n        self.responses = responses or {}\n        self.name = get_name(endpoint) if name is None else name\n        self.path_regex, self.path_format, self.param_convertors = compile_path(path)\n        if methods is None:\n            methods = [\"GET\"]\n        self.methods: Set[str] = {method.upper() for method in methods}\n        if isinstance(generate_unique_id_function, DefaultPlaceholder):\n            current_generate_unique_id: Callable[[APIRoute], str] = (\n                generate_unique_id_function.value\n            )\n        else:\n            current_generate_unique_id = generate_unique_id_function\n        self.unique_id = self.operation_id or current_generate_unique_id(self)\n        # normalize enums e.g. http.HTTPStatus\n        if isinstance(status_code, IntEnum):\n            status_code = int(status_code)\n        self.status_code = status_code\n        if self.response_model:\n            assert is_body_allowed_for_status_code(\n                status_code\n            ), f\"Status code {status_code} must not have a response body\"\n            response_name = \"Response_\" + self.unique_id\n            self.response_field = create_model_field(\n                name=response_name,\n                type_=self.response_model,\n                mode=\"serialization\",\n            )\n            # Create a clone of the field, so that a Pydantic submodel is not returned\n            # as is just because it's an instance of a subclass of a more limited class\n            # e.g. UserInDB (containing hashed_password) could be a subclass of User\n            # that doesn't have the hashed_password. But because it's a subclass, it\n            # would pass the validation and be returned as is.\n            # By being a new field, no inheritance will be passed as is. A new model\n            # will always be created.\n            # TODO: remove when deprecating Pydantic v1\n            self.secure_cloned_response_field: Optional[ModelField] = (\n                create_cloned_field(self.response_field)\n            )\n        else:\n            self.response_field = None  # type: ignore\n            self.secure_cloned_response_field = None\n        self.dependencies = list(dependencies or [])\n        self.description = description or inspect.cleandoc(self.endpoint.__doc__ or \"\")\n        # if a \"form feed\" character (page break) is found in the description text,\n        # truncate description text to the content preceding the first \"form feed\"\n        self.description = self.description.split(\"\\f\")[0].strip()\n        response_fields = {}\n        for additional_status_code, response in self.responses.items():\n            assert isinstance(response, dict), \"An additional response must be a dict\"\n            model = response.get(\"model\")\n            if model:\n                assert is_body_allowed_for_status_code(\n                    additional_status_code\n                ), f\"Status code {additional_status_code} must not have a response body\"\n                response_name = f\"Response_{additional_status_code}_{self.unique_id}\"\n                response_field = create_model_field(\n                    name=response_name, type_=model, mode=\"serialization\"\n                )\n                response_fields[additional_status_code] = response_field\n        if response_fields:\n            self.response_fields: Dict[Union[int, str], ModelField] = response_fields\n        else:\n            self.response_fields = {}\n\n        assert callable(endpoint), \"An endpoint must be a callable\"\n        self.dependant = get_dependant(path=self.path_format, call=self.endpoint)\n        for depends in self.dependencies[::-1]:\n            self.dependant.dependencies.insert(\n                0,\n                get_parameterless_sub_dependant(depends=depends, path=self.path_format),\n            )\n        self._flat_dependant = get_flat_dependant(self.dependant)\n        self._embed_body_fields = _should_embed_body_fields(\n            self._flat_dependant.body_params\n        )\n        self.body_field = get_body_field(\n            flat_dependant=self._flat_dependant,\n            name=self.unique_id,\n            embed_body_fields=self._embed_body_fields,\n        )\n        self.app = request_response(self.get_route_handler())",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "path",
        "endpoint"
      ],
      "imports": [
        "asyncio",
        "dataclasses",
        "email.message",
        "inspect",
        "json",
        "contextlib.AsyncExitStack",
        "contextlib.asynccontextmanager",
        "enum.Enum",
        "enum.IntEnum",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.params",
        "fastapi._compat.ModelField",
        "fastapi._compat.Undefined",
        "fastapi._compat._get_model_config",
        "fastapi._compat._model_dump",
        "fastapi._compat._normalize_errors",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.utils._should_embed_body_fields",
        "fastapi.dependencies.utils.get_body_field",
        "fastapi.dependencies.utils.get_dependant",
        "fastapi.dependencies.utils.get_flat_dependant",
        "fastapi.dependencies.utils.get_parameterless_sub_dependant",
        "fastapi.dependencies.utils.get_typed_return_annotation",
        "fastapi.dependencies.utils.solve_dependencies",
        "fastapi.encoders.jsonable_encoder",
        "fastapi.exceptions.FastAPIError",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.ResponseValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.create_cloned_field",
        "fastapi.utils.create_model_field",
        "fastapi.utils.generate_unique_id",
        "fastapi.utils.get_value_or_default",
        "fastapi.utils.is_body_allowed_for_status_code",
        "pydantic.BaseModel",
        "starlette.routing",
        "starlette.concurrency.run_in_threadpool",
        "starlette.exceptions.HTTPException",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.routing.Match",
        "starlette.routing.compile_path",
        "starlette.routing.get_name",
        "starlette.routing.request_response",
        "starlette.routing.websocket_session",
        "starlette.routing.Mount",
        "starlette.types.AppType",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Scope",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [
        "assert callable(endpoint), 'An endpoint must be a callable'",
        "assert is_body_allowed_for_status_code(status_code), f'Status code {status_code} must not have a response body'",
        "assert isinstance(response, dict), 'An additional response must be a dict'",
        "assert is_body_allowed_for_status_code(additional_status_code), f'Status code {additional_status_code} must not have a response body'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "get_dependant",
          "body": "def get_dependant(*, path: str, call: Callable[..., Any], name: Optional[str]=None, security_scopes: Optional[List[str]]=None, use_cache: bool=True) -> Dependant:\n    path_param_names = get_path_param_names(path)\n    endpoint_signature = get_typed_signature(call)\n    signature_params = endpoint_signature.parameters\n    dependant = Dependant(call=call, name=name, path=path, security_scopes=security_scopes, use_cache=use_cache)\n    for param_name, param in signature_params.items():\n        is_path_param = param_name in path_param_names\n        param_details = analyze_param(param_name=param_name, annotation=param.annotation, value=param.default, is_path_param=is_path_param)\n        if param_details.depends is not None:\n            sub_dependant = get_param_sub_dependant(param_name=param_name, depends=param_details.depends, path=path, security_scopes=security_scopes)\n            dependant.dependencies.append(sub_dependant)\n            continue\n        if add_non_field_param_to_dependency(param_name=param_name, type_annotation=param_details.type_annotation, dependant=dependant):\n            assert param_details.field is None, f'Cannot specify multiple FastAPI annotations for {param_name!r}'\n            continue\n        assert param_details.field is not None\n        if isinstance(param_details.field.field_info, params.Body):\n            dependant.body_params.append(param_details.field)\n        else:\n            add_param_to_fields(field=param_details.field, dependant=dependant)\n    return dependant"
        },
        {
          "name": "get_flat_dependant",
          "body": "def get_flat_dependant(dependant: Dependant, *, skip_repeats: bool=False, visited: Optional[List[CacheKey]]=None) -> Dependant:\n    if visited is None:\n        visited = []\n    visited.append(dependant.cache_key)\n    flat_dependant = Dependant(path_params=dependant.path_params.copy(), query_params=dependant.query_params.copy(), header_params=dependant.header_params.copy(), cookie_params=dependant.cookie_params.copy(), body_params=dependant.body_params.copy(), security_requirements=dependant.security_requirements.copy(), use_cache=dependant.use_cache, path=dependant.path)\n    for sub_dependant in dependant.dependencies:\n        if skip_repeats and sub_dependant.cache_key in visited:\n            continue\n        flat_sub = get_flat_dependant(sub_dependant, skip_repeats=skip_repeats, visited=visited)\n        flat_dependant.path_params.extend(flat_sub.path_params)\n        flat_dependant.query_params.extend(flat_sub.query_params)\n        flat_dependant.header_params.extend(flat_sub.header_params)\n        flat_dependant.cookie_params.extend(flat_sub.cookie_params)\n        flat_dependant.body_params.extend(flat_sub.body_params)\n        flat_dependant.security_requirements.extend(flat_sub.security_requirements)\n    return flat_dependant"
        },
        {
          "name": "_should_embed_body_fields",
          "body": "def _should_embed_body_fields(fields: List[ModelField]) -> bool:\n    if not fields:\n        return False\n    body_param_names_set = {field.name for field in fields}\n    if len(body_param_names_set) > 1:\n        return True\n    first_field = fields[0]\n    if getattr(first_field.field_info, 'embed', None):\n        return True\n    if isinstance(first_field.field_info, params.Form) and (not lenient_issubclass(first_field.type_, BaseModel)):\n        return True\n    return False"
        },
        {
          "name": "get_body_field",
          "body": "def get_body_field(*, flat_dependant: Dependant, name: str, embed_body_fields: bool) -> Optional[ModelField]:\n    \"\"\"\n    Get a ModelField representing the request body for a path operation, combining\n    all body parameters into a single field if necessary.\n\n    Used to check if it's form data (with `isinstance(body_field, params.Form)`)\n    or JSON and to generate the JSON Schema for a request body.\n\n    This is **not** used to validate/parse the request body, that's done with each\n    individual body parameter.\n    \"\"\"\n    if not flat_dependant.body_params:\n        return None\n    first_param = flat_dependant.body_params[0]\n    if not embed_body_fields:\n        return first_param\n    model_name = 'Body_' + name\n    BodyModel = create_body_model(fields=flat_dependant.body_params, model_name=model_name)\n    required = any((True for f in flat_dependant.body_params if f.required))\n    BodyFieldInfo_kwargs: Dict[str, Any] = {'annotation': BodyModel, 'alias': 'body'}\n    if not required:\n        BodyFieldInfo_kwargs['default'] = None\n    if any((isinstance(f.field_info, params.File) for f in flat_dependant.body_params)):\n        BodyFieldInfo: Type[params.Body] = params.File\n    elif any((isinstance(f.field_info, params.Form) for f in flat_dependant.body_params)):\n        BodyFieldInfo = params.Form\n    else:\n        BodyFieldInfo = params.Body\n        body_param_media_types = [f.field_info.media_type for f in flat_dependant.body_params if isinstance(f.field_info, params.Body)]\n        if len(set(body_param_media_types)) == 1:\n            BodyFieldInfo_kwargs['media_type'] = body_param_media_types[0]\n    final_field = create_model_field(name='body', type_=BodyModel, required=required, alias='body', field_info=BodyFieldInfo(**BodyFieldInfo_kwargs))\n    return final_field"
        },
        {
          "name": "get_typed_return_annotation",
          "body": "def get_typed_return_annotation(call: Callable[..., Any]) -> Any:\n    signature = inspect.signature(call)\n    annotation = signature.return_annotation\n    if annotation is inspect.Signature.empty:\n        return None\n    globalns = getattr(call, '__globals__', {})\n    return get_typed_annotation(annotation, globalns)"
        },
        {
          "name": "is_body_allowed_for_status_code",
          "body": "def is_body_allowed_for_status_code(status_code: Union[int, str, None]) -> bool:\n    if status_code is None:\n        return True\n    if status_code in {'default', '1XX', '2XX', '3XX', '4XX', '5XX'}:\n        return True\n    current_status_code = int(status_code)\n    return not (current_status_code < 200 or current_status_code in {204, 205, 304})"
        },
        {
          "name": "create_model_field",
          "body": "def create_model_field(name: str, type_: Any, class_validators: Optional[Dict[str, Validator]]=None, default: Optional[Any]=Undefined, required: Union[bool, UndefinedType]=Undefined, model_config: Type[BaseConfig]=BaseConfig, field_info: Optional[FieldInfo]=None, alias: Optional[str]=None, mode: Literal['validation', 'serialization']='validation') -> ModelField:\n    class_validators = class_validators or {}\n    if PYDANTIC_V2:\n        field_info = field_info or FieldInfo(annotation=type_, default=default, alias=alias)\n    else:\n        field_info = field_info or FieldInfo()\n    kwargs = {'name': name, 'field_info': field_info}\n    if PYDANTIC_V2:\n        kwargs.update({'mode': mode})\n    else:\n        kwargs.update({'type_': type_, 'class_validators': class_validators, 'default': default, 'required': required, 'model_config': model_config, 'alias': alias})\n    try:\n        return ModelField(**kwargs)\n    except (RuntimeError, PydanticSchemaGenerationError):\n        raise fastapi.exceptions.FastAPIError(f'Invalid args for response field! Hint: check that {type_} is a valid Pydantic field type. If you are using a return type annotation that is not a valid Pydantic field (e.g. Union[Response, dict, None]) you can disable generating the response model from the type annotation with the path operation decorator parameter response_model=None. Read more: https://fastapi.tiangolo.com/tutorial/response-model/') from None"
        },
        {
          "name": "create_cloned_field",
          "body": "def create_cloned_field(field: ModelField, *, cloned_types: Optional[MutableMapping[Type[BaseModel], Type[BaseModel]]]=None) -> ModelField:\n    if PYDANTIC_V2:\n        return field\n    if cloned_types is None:\n        cloned_types = _CLONED_TYPES_CACHE\n    original_type = field.type_\n    if is_dataclass(original_type) and hasattr(original_type, '__pydantic_model__'):\n        original_type = original_type.__pydantic_model__\n    use_type = original_type\n    if lenient_issubclass(original_type, BaseModel):\n        original_type = cast(Type[BaseModel], original_type)\n        use_type = cloned_types.get(original_type)\n        if use_type is None:\n            use_type = create_model(original_type.__name__, __base__=original_type)\n            cloned_types[original_type] = use_type\n            for f in original_type.__fields__.values():\n                use_type.__fields__[f.name] = create_cloned_field(f, cloned_types=cloned_types)\n    new_field = create_model_field(name=field.name, type_=use_type)\n    new_field.has_alias = field.has_alias\n    new_field.alias = field.alias\n    new_field.class_validators = field.class_validators\n    new_field.default = field.default\n    new_field.required = field.required\n    new_field.model_config = field.model_config\n    new_field.field_info = field.field_info\n    new_field.allow_none = field.allow_none\n    new_field.validate_always = field.validate_always\n    if field.sub_fields:\n        new_field.sub_fields = [create_cloned_field(sub_field, cloned_types=cloned_types) for sub_field in field.sub_fields]\n    if field.key_field:\n        new_field.key_field = create_cloned_field(field.key_field, cloned_types=cloned_types)\n    new_field.validators = field.validators\n    new_field.pre_validators = field.pre_validators\n    new_field.post_validators = field.post_validators\n    new_field.parse_json = field.parse_json\n    new_field.shape = field.shape\n    new_field.populate_validators()\n    return new_field"
        },
        {
          "name": "response.get",
          "body": "def get(self, path: Annotated[str, Doc('\\n                The URL path to be used for this *path operation*.\\n\\n                For example, in `http://example.com/items`, the path is `/items`.\\n                ')], *, response_model: Annotated[Any, Doc(\"\\n                The type to use for the response.\\n\\n                It could be any valid Pydantic *field* type. So, it doesn't have to\\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\\n                etc.\\n\\n                It will be used for:\\n\\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\\n                    show it as the response (JSON Schema).\\n                * Serialization: you could return an arbitrary object and the\\n                    `response_model` would be used to serialize that object into the\\n                    corresponding JSON.\\n                * Filtering: the JSON sent to the client will only contain the data\\n                    (fields) defined in the `response_model`. If you returned an object\\n                    that contains an attribute `password` but the `response_model` does\\n                    not include that field, the JSON sent to the client would not have\\n                    that `password`.\\n                * Validation: whatever you return will be serialized with the\\n                    `response_model`, converting any data as necessary to generate the\\n                    corresponding JSON. But if the data in the object returned is not\\n                    valid, that would mean a violation of the contract with the client,\\n                    so it's an error from the API developer. So, FastAPI will raise an\\n                    error and return a 500 error code (Internal Server Error).\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\\n                \")]=Default(None), status_code: Annotated[Optional[int], Doc('\\n                The default status code to be used for the response.\\n\\n                You could override the status code by returning a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\\n                ')]=None, tags: Annotated[Optional[List[Union[str, Enum]]], Doc('\\n                A list of tags to be applied to the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\\n                ')]=None, dependencies: Annotated[Optional[Sequence[Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to the\\n                *path operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\\n                ')]=None, summary: Annotated[Optional[str], Doc('\\n                A summary for the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, description: Annotated[Optional[str], Doc('\\n                A description for the *path operation*.\\n\\n                If not provided, it will be extracted automatically from the docstring\\n                of the *path operation function*.\\n\\n                It can contain Markdown.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, response_description: Annotated[str, Doc('\\n                The description for the default response.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]='Successful Response', responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses that could be returned by this *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark this *path operation* as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, operation_id: Annotated[Optional[str], Doc('\\n                Custom operation ID to be used by this *path operation*.\\n\\n                By default, it is generated automatically.\\n\\n                If you provide a custom operation ID, you need to make sure it is\\n                unique for the whole API.\\n\\n                You can customize the\\n                operation ID generation with the parameter\\n                `generate_unique_id_function` in the `FastAPI` class.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=None, response_model_include: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to include only certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_exclude: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to exclude certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_by_alias: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response model\\n                should be serialized by alias when an alias is used.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=True, response_model_exclude_unset: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that were not set and\\n                have their default values. This is different from\\n                `response_model_exclude_defaults` in that if the fields are set,\\n                they will be included in the response, even if the value is the same\\n                as the default.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_defaults: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that have the same value\\n                as the default. This is different from `response_model_exclude_unset`\\n                in that if the fields are set but contain the same default values,\\n                they will be excluded from the response.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_none: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data should\\n                exclude fields set to `None`.\\n\\n                This is much simpler (less smart) than `response_model_exclude_unset`\\n                and `response_model_exclude_defaults`. You probably want to use one of\\n                those two instead of this one, as those allow returning `None` values\\n                when it makes sense.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\\n                ')]=False, include_in_schema: Annotated[bool, Doc('\\n                Include this *path operation* in the generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\\n                ')]=True, response_class: Annotated[Type[Response], Doc('\\n                Response class to be used for this *path operation*.\\n\\n                This will not be used if you return a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\\n                ')]=Default(JSONResponse), name: Annotated[Optional[str], Doc('\\n                Name for this *path operation*. Only used internally.\\n                ')]=None, callbacks: Annotated[Optional[List[BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")]=None, openapi_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n                Extra metadata to be included in the OpenAPI schema for this *path\\n                operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\\n                ')]=None, generate_unique_id_function: Annotated[Callable[[routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=Default(generate_unique_id)) -> Callable[[DecoratedCallable], DecoratedCallable]:\n    \"\"\"\n        Add a *path operation* using an HTTP GET operation.\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI\n\n        app = FastAPI()\n\n        @app.get(\"/items/\")\n        def read_items():\n            return [{\"name\": \"Empanada\"}, {\"name\": \"Arepa\"}]\n        ```\n        \"\"\"\n    return self.router.get(path, response_model=response_model, status_code=status_code, tags=tags, dependencies=dependencies, summary=summary, description=description, response_description=response_description, responses=responses, deprecated=deprecated, operation_id=operation_id, response_model_include=response_model_include, response_model_exclude=response_model_exclude, response_model_by_alias=response_model_by_alias, response_model_exclude_unset=response_model_exclude_unset, response_model_exclude_defaults=response_model_exclude_defaults, response_model_exclude_none=response_model_exclude_none, include_in_schema=include_in_schema, response_class=response_class, name=name, callbacks=callbacks, openapi_extra=openapi_extra, generate_unique_id_function=generate_unique_id_function)"
        },
        {
          "name": "self.get_route_handler",
          "body": "def get_route_handler(self) -> Callable[[Request], Coroutine[Any, Any, Response]]:\n    return get_request_handler(dependant=self.dependant, body_field=self.body_field, status_code=self.status_code, response_class=self.response_class, response_field=self.secure_cloned_response_field, response_model_include=self.response_model_include, response_model_exclude=self.response_model_exclude, response_model_by_alias=self.response_model_by_alias, response_model_exclude_unset=self.response_model_exclude_unset, response_model_exclude_defaults=self.response_model_exclude_defaults, response_model_exclude_none=self.response_model_exclude_none, dependency_overrides_provider=self.dependency_overrides_provider, embed_body_fields=self._embed_body_fields)"
        },
        {
          "name": "is_body_allowed_for_status_code",
          "body": "def is_body_allowed_for_status_code(status_code: Union[int, str, None]) -> bool:\n    if status_code is None:\n        return True\n    if status_code in {'default', '1XX', '2XX', '3XX', '4XX', '5XX'}:\n        return True\n    current_status_code = int(status_code)\n    return not (current_status_code < 200 or current_status_code in {204, 205, 304})"
        },
        {
          "name": "create_model_field",
          "body": "def create_model_field(name: str, type_: Any, class_validators: Optional[Dict[str, Validator]]=None, default: Optional[Any]=Undefined, required: Union[bool, UndefinedType]=Undefined, model_config: Type[BaseConfig]=BaseConfig, field_info: Optional[FieldInfo]=None, alias: Optional[str]=None, mode: Literal['validation', 'serialization']='validation') -> ModelField:\n    class_validators = class_validators or {}\n    if PYDANTIC_V2:\n        field_info = field_info or FieldInfo(annotation=type_, default=default, alias=alias)\n    else:\n        field_info = field_info or FieldInfo()\n    kwargs = {'name': name, 'field_info': field_info}\n    if PYDANTIC_V2:\n        kwargs.update({'mode': mode})\n    else:\n        kwargs.update({'type_': type_, 'class_validators': class_validators, 'default': default, 'required': required, 'model_config': model_config, 'alias': alias})\n    try:\n        return ModelField(**kwargs)\n    except (RuntimeError, PydanticSchemaGenerationError):\n        raise fastapi.exceptions.FastAPIError(f'Invalid args for response field! Hint: check that {type_} is a valid Pydantic field type. If you are using a return type annotation that is not a valid Pydantic field (e.g. Union[Response, dict, None]) you can disable generating the response model from the type annotation with the path operation decorator parameter response_model=None. Read more: https://fastapi.tiangolo.com/tutorial/response-model/') from None"
        },
        {
          "name": "get_parameterless_sub_dependant",
          "body": "def get_parameterless_sub_dependant(*, depends: params.Depends, path: str) -> Dependant:\n    assert callable(depends.dependency), 'A parameter-less dependency must have a callable dependency'\n    return get_sub_dependant(depends=depends, dependency=depends.dependency, path=path)"
        }
      ]
    },
    {
      "name": "get_route_handler",
      "module": "routing",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\routing.py",
      "line_number": 571,
      "end_line_number": 586,
      "source_code": "def get_route_handler(self) -> Callable[[Request], Coroutine[Any, Any, Response]]:\n        return get_request_handler(\n            dependant=self.dependant,\n            body_field=self.body_field,\n            status_code=self.status_code,\n            response_class=self.response_class,\n            response_field=self.secure_cloned_response_field,\n            response_model_include=self.response_model_include,\n            response_model_exclude=self.response_model_exclude,\n            response_model_by_alias=self.response_model_by_alias,\n            response_model_exclude_unset=self.response_model_exclude_unset,\n            response_model_exclude_defaults=self.response_model_exclude_defaults,\n            response_model_exclude_none=self.response_model_exclude_none,\n            dependency_overrides_provider=self.dependency_overrides_provider,\n            embed_body_fields=self._embed_body_fields,\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "dataclasses",
        "email.message",
        "inspect",
        "json",
        "contextlib.AsyncExitStack",
        "contextlib.asynccontextmanager",
        "enum.Enum",
        "enum.IntEnum",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.params",
        "fastapi._compat.ModelField",
        "fastapi._compat.Undefined",
        "fastapi._compat._get_model_config",
        "fastapi._compat._model_dump",
        "fastapi._compat._normalize_errors",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.utils._should_embed_body_fields",
        "fastapi.dependencies.utils.get_body_field",
        "fastapi.dependencies.utils.get_dependant",
        "fastapi.dependencies.utils.get_flat_dependant",
        "fastapi.dependencies.utils.get_parameterless_sub_dependant",
        "fastapi.dependencies.utils.get_typed_return_annotation",
        "fastapi.dependencies.utils.solve_dependencies",
        "fastapi.encoders.jsonable_encoder",
        "fastapi.exceptions.FastAPIError",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.ResponseValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.create_cloned_field",
        "fastapi.utils.create_model_field",
        "fastapi.utils.generate_unique_id",
        "fastapi.utils.get_value_or_default",
        "fastapi.utils.is_body_allowed_for_status_code",
        "pydantic.BaseModel",
        "starlette.routing",
        "starlette.concurrency.run_in_threadpool",
        "starlette.exceptions.HTTPException",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.routing.Match",
        "starlette.routing.compile_path",
        "starlette.routing.get_name",
        "starlette.routing.request_response",
        "starlette.routing.websocket_session",
        "starlette.routing.Mount",
        "starlette.types.AppType",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Scope",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_request_handler",
          "body": "def get_request_handler(dependant: Dependant, body_field: Optional[ModelField]=None, status_code: Optional[int]=None, response_class: Union[Type[Response], DefaultPlaceholder]=Default(JSONResponse), response_field: Optional[ModelField]=None, response_model_include: Optional[IncEx]=None, response_model_exclude: Optional[IncEx]=None, response_model_by_alias: bool=True, response_model_exclude_unset: bool=False, response_model_exclude_defaults: bool=False, response_model_exclude_none: bool=False, dependency_overrides_provider: Optional[Any]=None, embed_body_fields: bool=False) -> Callable[[Request], Coroutine[Any, Any, Response]]:\n    assert dependant.call is not None, 'dependant.call must be a function'\n    is_coroutine = asyncio.iscoroutinefunction(dependant.call)\n    is_body_form = body_field and isinstance(body_field.field_info, params.Form)\n    if isinstance(response_class, DefaultPlaceholder):\n        actual_response_class: Type[Response] = response_class.value\n    else:\n        actual_response_class = response_class\n\n    async def app(request: Request) -> Response:\n        response: Union[Response, None] = None\n        async with AsyncExitStack() as file_stack:\n            try:\n                body: Any = None\n                if body_field:\n                    if is_body_form:\n                        body = await request.form()\n                        file_stack.push_async_callback(body.close)\n                    else:\n                        body_bytes = await request.body()\n                        if body_bytes:\n                            json_body: Any = Undefined\n                            content_type_value = request.headers.get('content-type')\n                            if not content_type_value:\n                                json_body = await request.json()\n                            else:\n                                message = email.message.Message()\n                                message['content-type'] = content_type_value\n                                if message.get_content_maintype() == 'application':\n                                    subtype = message.get_content_subtype()\n                                    if subtype == 'json' or subtype.endswith('+json'):\n                                        json_body = await request.json()\n                            if json_body != Undefined:\n                                body = json_body\n                            else:\n                                body = body_bytes\n            except json.JSONDecodeError as e:\n                validation_error = RequestValidationError([{'type': 'json_invalid', 'loc': ('body', e.pos), 'msg': 'JSON decode error', 'input': {}, 'ctx': {'error': e.msg}}], body=e.doc)\n                raise validation_error from e\n            except HTTPException:\n                raise\n            except Exception as e:\n                http_error = HTTPException(status_code=400, detail='There was an error parsing the body')\n                raise http_error from e\n            errors: List[Any] = []\n            async with AsyncExitStack() as async_exit_stack:\n                solved_result = await solve_dependencies(request=request, dependant=dependant, body=body, dependency_overrides_provider=dependency_overrides_provider, async_exit_stack=async_exit_stack, embed_body_fields=embed_body_fields)\n                errors = solved_result.errors\n                if not errors:\n                    raw_response = await run_endpoint_function(dependant=dependant, values=solved_result.values, is_coroutine=is_coroutine)\n                    if isinstance(raw_response, Response):\n                        if raw_response.background is None:\n                            raw_response.background = solved_result.background_tasks\n                        response = raw_response\n                    else:\n                        response_args: Dict[str, Any] = {'background': solved_result.background_tasks}\n                        current_status_code = status_code if status_code else solved_result.response.status_code\n                        if current_status_code is not None:\n                            response_args['status_code'] = current_status_code\n                        if solved_result.response.status_code:\n                            response_args['status_code'] = solved_result.response.status_code\n                        content = await serialize_response(field=response_field, response_content=raw_response, include=response_model_include, exclude=response_model_exclude, by_alias=response_model_by_alias, exclude_unset=response_model_exclude_unset, exclude_defaults=response_model_exclude_defaults, exclude_none=response_model_exclude_none, is_coroutine=is_coroutine)\n                        response = actual_response_class(content, **response_args)\n                        if not is_body_allowed_for_status_code(response.status_code):\n                            response.body = b''\n                        response.headers.raw.extend(solved_result.response.headers.raw)\n            if errors:\n                validation_error = RequestValidationError(_normalize_errors(errors), body=body)\n                raise validation_error\n        if response is None:\n            raise FastAPIError(\"No response object was returned. There's a high chance that the application code is raising an exception and a dependency with yield has a block with a bare except, or a block with except Exception, and is not raising the exception again. Read more about it in the docs: https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-with-yield/#dependencies-with-yield-and-except\")\n        return response\n    return app"
        }
      ]
    },
    {
      "name": "matches",
      "module": "routing",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\routing.py",
      "line_number": 588,
      "end_line_number": 592,
      "source_code": "def matches(self, scope: Scope) -> Tuple[Match, Scope]:\n        match, child_scope = super().matches(scope)\n        if match != Match.NONE:\n            child_scope[\"route\"] = self\n        return match, child_scope",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "scope"
      ],
      "imports": [
        "asyncio",
        "dataclasses",
        "email.message",
        "inspect",
        "json",
        "contextlib.AsyncExitStack",
        "contextlib.asynccontextmanager",
        "enum.Enum",
        "enum.IntEnum",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.params",
        "fastapi._compat.ModelField",
        "fastapi._compat.Undefined",
        "fastapi._compat._get_model_config",
        "fastapi._compat._model_dump",
        "fastapi._compat._normalize_errors",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.utils._should_embed_body_fields",
        "fastapi.dependencies.utils.get_body_field",
        "fastapi.dependencies.utils.get_dependant",
        "fastapi.dependencies.utils.get_flat_dependant",
        "fastapi.dependencies.utils.get_parameterless_sub_dependant",
        "fastapi.dependencies.utils.get_typed_return_annotation",
        "fastapi.dependencies.utils.solve_dependencies",
        "fastapi.encoders.jsonable_encoder",
        "fastapi.exceptions.FastAPIError",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.ResponseValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.create_cloned_field",
        "fastapi.utils.create_model_field",
        "fastapi.utils.generate_unique_id",
        "fastapi.utils.get_value_or_default",
        "fastapi.utils.is_body_allowed_for_status_code",
        "pydantic.BaseModel",
        "starlette.routing",
        "starlette.concurrency.run_in_threadpool",
        "starlette.exceptions.HTTPException",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.routing.Match",
        "starlette.routing.compile_path",
        "starlette.routing.get_name",
        "starlette.routing.request_response",
        "starlette.routing.websocket_session",
        "starlette.routing.Mount",
        "starlette.types.AppType",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Scope",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "routing",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\routing.py",
      "line_number": 622,
      "end_line_number": 860,
      "source_code": "def __init__(\n        self,\n        *,\n        prefix: Annotated[str, Doc(\"An optional path prefix for the router.\")] = \"\",\n        tags: Annotated[\n            Optional[List[Union[str, Enum]]],\n            Doc(\n                \"\"\"\n                A list of tags to be applied to all the *path operations* in this\n                router.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        dependencies: Annotated[\n            Optional[Sequence[params.Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be applied to all the\n                *path operations* in this router.\n\n                Read more about it in the\n                [FastAPI docs for Bigger Applications - Multiple Files](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).\n                \"\"\"\n            ),\n        ] = None,\n        default_response_class: Annotated[\n            Type[Response],\n            Doc(\n                \"\"\"\n                The default response class to be used.\n\n                Read more in the\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#default-response-class).\n                \"\"\"\n            ),\n        ] = Default(JSONResponse),\n        responses: Annotated[\n            Optional[Dict[Union[int, str], Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                Additional responses to be shown in OpenAPI.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Additional Responses in OpenAPI](https://fastapi.tiangolo.com/advanced/additional-responses/).\n\n                And in the\n                [FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).\n                \"\"\"\n            ),\n        ] = None,\n        callbacks: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                OpenAPI callbacks that should apply to all *path operations* in this\n                router.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\n                \"\"\"\n            ),\n        ] = None,\n        routes: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                **Note**: you probably shouldn't use this parameter, it is inherited\n                from Starlette and supported for compatibility.\n\n                ---\n\n                A list of routes to serve incoming HTTP and WebSocket requests.\n                \"\"\"\n            ),\n            deprecated(\n                \"\"\"\n                You normally wouldn't use this parameter with FastAPI, it is inherited\n                from Starlette and supported for compatibility.\n\n                In FastAPI, you normally would use the *path operation methods*,\n                like `router.get()`, `router.post()`, etc.\n                \"\"\"\n            ),\n        ] = None,\n        redirect_slashes: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Whether to detect and redirect slashes in URLs when the client doesn't\n                use the same format.\n                \"\"\"\n            ),\n        ] = True,\n        default: Annotated[\n            Optional[ASGIApp],\n            Doc(\n                \"\"\"\n                Default function handler for this router. Used to handle\n                404 Not Found errors.\n                \"\"\"\n            ),\n        ] = None,\n        dependency_overrides_provider: Annotated[\n            Optional[Any],\n            Doc(\n                \"\"\"\n                Only used internally by FastAPI to handle dependency overrides.\n\n                You shouldn't need to use it. It normally points to the `FastAPI` app\n                object.\n                \"\"\"\n            ),\n        ] = None,\n        route_class: Annotated[\n            Type[APIRoute],\n            Doc(\n                \"\"\"\n                Custom route (*path operation*) class to be used by this router.\n\n                Read more about it in the\n                [FastAPI docs for Custom Request and APIRoute class](https://fastapi.tiangolo.com/how-to/custom-request-and-route/#custom-apiroute-class-in-a-router).\n                \"\"\"\n            ),\n        ] = APIRoute,\n        on_startup: Annotated[\n            Optional[Sequence[Callable[[], Any]]],\n            Doc(\n                \"\"\"\n                A list of startup event handler functions.\n\n                You should instead use the `lifespan` handlers.\n\n                Read more in the [FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).\n                \"\"\"\n            ),\n        ] = None,\n        on_shutdown: Annotated[\n            Optional[Sequence[Callable[[], Any]]],\n            Doc(\n                \"\"\"\n                A list of shutdown event handler functions.\n\n                You should instead use the `lifespan` handlers.\n\n                Read more in the\n                [FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).\n                \"\"\"\n            ),\n        ] = None,\n        # the generic to Lifespan[AppType] is the type of the top level application\n        # which the router cannot know statically, so we use typing.Any\n        lifespan: Annotated[\n            Optional[Lifespan[Any]],\n            Doc(\n                \"\"\"\n                A `Lifespan` context manager handler. This replaces `startup` and\n                `shutdown` functions with a single context manager.\n\n                Read more in the\n                [FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).\n                \"\"\"\n            ),\n        ] = None,\n        deprecated: Annotated[\n            Optional[bool],\n            Doc(\n                \"\"\"\n                Mark all *path operations* in this router as deprecated.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        include_in_schema: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                To include (or not) all the *path operations* in this router in the\n                generated OpenAPI.\n\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\n                \"\"\"\n            ),\n        ] = True,\n        generate_unique_id_function: Annotated[\n            Callable[[APIRoute], str],\n            Doc(\n                \"\"\"\n                Customize the function used to generate unique IDs for the *path\n                operations* shown in the generated OpenAPI.\n\n                This is particularly useful when automatically generating clients or\n                SDKs for your API.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = Default(generate_unique_id),\n    ) -> None:\n        super().__init__(\n            routes=routes,\n            redirect_slashes=redirect_slashes,\n            default=default,\n            on_startup=on_startup,\n            on_shutdown=on_shutdown,\n            lifespan=lifespan,\n        )\n        if prefix:\n            assert prefix.startswith(\"/\"), \"A path prefix must start with '/'\"\n            assert not prefix.endswith(\n                \"/\"\n            ), \"A path prefix must not end with '/', as the routes will start with '/'\"\n        self.prefix = prefix\n        self.tags: List[Union[str, Enum]] = tags or []\n        self.dependencies = list(dependencies or [])\n        self.deprecated = deprecated\n        self.include_in_schema = include_in_schema\n        self.responses = responses or {}\n        self.callbacks = callbacks or []\n        self.dependency_overrides_provider = dependency_overrides_provider\n        self.route_class = route_class\n        self.default_response_class = default_response_class\n        self.generate_unique_id_function = generate_unique_id_function",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "asyncio",
        "dataclasses",
        "email.message",
        "inspect",
        "json",
        "contextlib.AsyncExitStack",
        "contextlib.asynccontextmanager",
        "enum.Enum",
        "enum.IntEnum",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.params",
        "fastapi._compat.ModelField",
        "fastapi._compat.Undefined",
        "fastapi._compat._get_model_config",
        "fastapi._compat._model_dump",
        "fastapi._compat._normalize_errors",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.utils._should_embed_body_fields",
        "fastapi.dependencies.utils.get_body_field",
        "fastapi.dependencies.utils.get_dependant",
        "fastapi.dependencies.utils.get_flat_dependant",
        "fastapi.dependencies.utils.get_parameterless_sub_dependant",
        "fastapi.dependencies.utils.get_typed_return_annotation",
        "fastapi.dependencies.utils.solve_dependencies",
        "fastapi.encoders.jsonable_encoder",
        "fastapi.exceptions.FastAPIError",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.ResponseValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.create_cloned_field",
        "fastapi.utils.create_model_field",
        "fastapi.utils.generate_unique_id",
        "fastapi.utils.get_value_or_default",
        "fastapi.utils.is_body_allowed_for_status_code",
        "pydantic.BaseModel",
        "starlette.routing",
        "starlette.concurrency.run_in_threadpool",
        "starlette.exceptions.HTTPException",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.routing.Match",
        "starlette.routing.compile_path",
        "starlette.routing.get_name",
        "starlette.routing.request_response",
        "starlette.routing.websocket_session",
        "starlette.routing.Mount",
        "starlette.types.AppType",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Scope",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [
        "assert prefix.startswith('/'), \"A path prefix must start with '/'\"",
        "assert not prefix.endswith('/'), \"A path prefix must not end with '/', as the routes will start with '/'\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        }
      ]
    },
    {
      "name": "route",
      "module": "routing",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\routing.py",
      "line_number": 862,
      "end_line_number": 879,
      "source_code": "def route(\n        self,\n        path: str,\n        methods: Optional[List[str]] = None,\n        name: Optional[str] = None,\n        include_in_schema: bool = True,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.add_route(\n                path,\n                func,\n                methods=methods,\n                name=name,\n                include_in_schema=include_in_schema,\n            )\n            return func\n\n        return decorator",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "path",
        "methods",
        "name",
        "include_in_schema"
      ],
      "imports": [
        "asyncio",
        "dataclasses",
        "email.message",
        "inspect",
        "json",
        "contextlib.AsyncExitStack",
        "contextlib.asynccontextmanager",
        "enum.Enum",
        "enum.IntEnum",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.params",
        "fastapi._compat.ModelField",
        "fastapi._compat.Undefined",
        "fastapi._compat._get_model_config",
        "fastapi._compat._model_dump",
        "fastapi._compat._normalize_errors",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.utils._should_embed_body_fields",
        "fastapi.dependencies.utils.get_body_field",
        "fastapi.dependencies.utils.get_dependant",
        "fastapi.dependencies.utils.get_flat_dependant",
        "fastapi.dependencies.utils.get_parameterless_sub_dependant",
        "fastapi.dependencies.utils.get_typed_return_annotation",
        "fastapi.dependencies.utils.solve_dependencies",
        "fastapi.encoders.jsonable_encoder",
        "fastapi.exceptions.FastAPIError",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.ResponseValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.create_cloned_field",
        "fastapi.utils.create_model_field",
        "fastapi.utils.generate_unique_id",
        "fastapi.utils.get_value_or_default",
        "fastapi.utils.is_body_allowed_for_status_code",
        "pydantic.BaseModel",
        "starlette.routing",
        "starlette.concurrency.run_in_threadpool",
        "starlette.exceptions.HTTPException",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.routing.Match",
        "starlette.routing.compile_path",
        "starlette.routing.get_name",
        "starlette.routing.request_response",
        "starlette.routing.websocket_session",
        "starlette.routing.Mount",
        "starlette.types.AppType",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Scope",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "add_api_route",
      "module": "routing",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\routing.py",
      "line_number": 881,
      "end_line_number": 961,
      "source_code": "def add_api_route(\n        self,\n        path: str,\n        endpoint: Callable[..., Any],\n        *,\n        response_model: Any = Default(None),\n        status_code: Optional[int] = None,\n        tags: Optional[List[Union[str, Enum]]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        methods: Optional[Union[Set[str], List[str]]] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[IncEx] = None,\n        response_model_exclude: Optional[IncEx] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Union[Type[Response], DefaultPlaceholder] = Default(\n            JSONResponse\n        ),\n        name: Optional[str] = None,\n        route_class_override: Optional[Type[APIRoute]] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n        generate_unique_id_function: Union[\n            Callable[[APIRoute], str], DefaultPlaceholder\n        ] = Default(generate_unique_id),\n    ) -> None:\n        route_class = route_class_override or self.route_class\n        responses = responses or {}\n        combined_responses = {**self.responses, **responses}\n        current_response_class = get_value_or_default(\n            response_class, self.default_response_class\n        )\n        current_tags = self.tags.copy()\n        if tags:\n            current_tags.extend(tags)\n        current_dependencies = self.dependencies.copy()\n        if dependencies:\n            current_dependencies.extend(dependencies)\n        current_callbacks = self.callbacks.copy()\n        if callbacks:\n            current_callbacks.extend(callbacks)\n        current_generate_unique_id = get_value_or_default(\n            generate_unique_id_function, self.generate_unique_id_function\n        )\n        route = route_class(\n            self.prefix + path,\n            endpoint=endpoint,\n            response_model=response_model,\n            status_code=status_code,\n            tags=current_tags,\n            dependencies=current_dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=combined_responses,\n            deprecated=deprecated or self.deprecated,\n            methods=methods,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema and self.include_in_schema,\n            response_class=current_response_class,\n            name=name,\n            dependency_overrides_provider=self.dependency_overrides_provider,\n            callbacks=current_callbacks,\n            openapi_extra=openapi_extra,\n            generate_unique_id_function=current_generate_unique_id,\n        )\n        self.routes.append(route)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "path",
        "endpoint"
      ],
      "imports": [
        "asyncio",
        "dataclasses",
        "email.message",
        "inspect",
        "json",
        "contextlib.AsyncExitStack",
        "contextlib.asynccontextmanager",
        "enum.Enum",
        "enum.IntEnum",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.params",
        "fastapi._compat.ModelField",
        "fastapi._compat.Undefined",
        "fastapi._compat._get_model_config",
        "fastapi._compat._model_dump",
        "fastapi._compat._normalize_errors",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.utils._should_embed_body_fields",
        "fastapi.dependencies.utils.get_body_field",
        "fastapi.dependencies.utils.get_dependant",
        "fastapi.dependencies.utils.get_flat_dependant",
        "fastapi.dependencies.utils.get_parameterless_sub_dependant",
        "fastapi.dependencies.utils.get_typed_return_annotation",
        "fastapi.dependencies.utils.solve_dependencies",
        "fastapi.encoders.jsonable_encoder",
        "fastapi.exceptions.FastAPIError",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.ResponseValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.create_cloned_field",
        "fastapi.utils.create_model_field",
        "fastapi.utils.generate_unique_id",
        "fastapi.utils.get_value_or_default",
        "fastapi.utils.is_body_allowed_for_status_code",
        "pydantic.BaseModel",
        "starlette.routing",
        "starlette.concurrency.run_in_threadpool",
        "starlette.exceptions.HTTPException",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.routing.Match",
        "starlette.routing.compile_path",
        "starlette.routing.get_name",
        "starlette.routing.request_response",
        "starlette.routing.websocket_session",
        "starlette.routing.Mount",
        "starlette.types.AppType",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Scope",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "get_value_or_default",
          "body": "def get_value_or_default(first_item: Union[DefaultPlaceholder, DefaultType], *extra_items: Union[DefaultPlaceholder, DefaultType]) -> Union[DefaultPlaceholder, DefaultType]:\n    \"\"\"\n    Pass items or `DefaultPlaceholder`s by descending priority.\n\n    The first one to _not_ be a `DefaultPlaceholder` will be returned.\n\n    Otherwise, the first item (a `DefaultPlaceholder`) will be returned.\n    \"\"\"\n    items = (first_item,) + extra_items\n    for item in items:\n        if not isinstance(item, DefaultPlaceholder):\n            return item\n    return first_item"
        },
        {
          "name": "get_value_or_default",
          "body": "def get_value_or_default(first_item: Union[DefaultPlaceholder, DefaultType], *extra_items: Union[DefaultPlaceholder, DefaultType]) -> Union[DefaultPlaceholder, DefaultType]:\n    \"\"\"\n    Pass items or `DefaultPlaceholder`s by descending priority.\n\n    The first one to _not_ be a `DefaultPlaceholder` will be returned.\n\n    Otherwise, the first item (a `DefaultPlaceholder`) will be returned.\n    \"\"\"\n    items = (first_item,) + extra_items\n    for item in items:\n        if not isinstance(item, DefaultPlaceholder):\n            return item\n    return first_item"
        }
      ]
    },
    {
      "name": "api_route",
      "module": "routing",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\routing.py",
      "line_number": 963,
      "end_line_number": 1023,
      "source_code": "def api_route(\n        self,\n        path: str,\n        *,\n        response_model: Any = Default(None),\n        status_code: Optional[int] = None,\n        tags: Optional[List[Union[str, Enum]]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        methods: Optional[List[str]] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[IncEx] = None,\n        response_model_exclude: Optional[IncEx] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n        generate_unique_id_function: Callable[[APIRoute], str] = Default(\n            generate_unique_id\n        ),\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.add_api_route(\n                path,\n                func,\n                response_model=response_model,\n                status_code=status_code,\n                tags=tags,\n                dependencies=dependencies,\n                summary=summary,\n                description=description,\n                response_description=response_description,\n                responses=responses,\n                deprecated=deprecated,\n                methods=methods,\n                operation_id=operation_id,\n                response_model_include=response_model_include,\n                response_model_exclude=response_model_exclude,\n                response_model_by_alias=response_model_by_alias,\n                response_model_exclude_unset=response_model_exclude_unset,\n                response_model_exclude_defaults=response_model_exclude_defaults,\n                response_model_exclude_none=response_model_exclude_none,\n                include_in_schema=include_in_schema,\n                response_class=response_class,\n                name=name,\n                callbacks=callbacks,\n                openapi_extra=openapi_extra,\n                generate_unique_id_function=generate_unique_id_function,\n            )\n            return func\n\n        return decorator",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "path"
      ],
      "imports": [
        "asyncio",
        "dataclasses",
        "email.message",
        "inspect",
        "json",
        "contextlib.AsyncExitStack",
        "contextlib.asynccontextmanager",
        "enum.Enum",
        "enum.IntEnum",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.params",
        "fastapi._compat.ModelField",
        "fastapi._compat.Undefined",
        "fastapi._compat._get_model_config",
        "fastapi._compat._model_dump",
        "fastapi._compat._normalize_errors",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.utils._should_embed_body_fields",
        "fastapi.dependencies.utils.get_body_field",
        "fastapi.dependencies.utils.get_dependant",
        "fastapi.dependencies.utils.get_flat_dependant",
        "fastapi.dependencies.utils.get_parameterless_sub_dependant",
        "fastapi.dependencies.utils.get_typed_return_annotation",
        "fastapi.dependencies.utils.solve_dependencies",
        "fastapi.encoders.jsonable_encoder",
        "fastapi.exceptions.FastAPIError",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.ResponseValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.create_cloned_field",
        "fastapi.utils.create_model_field",
        "fastapi.utils.generate_unique_id",
        "fastapi.utils.get_value_or_default",
        "fastapi.utils.is_body_allowed_for_status_code",
        "pydantic.BaseModel",
        "starlette.routing",
        "starlette.concurrency.run_in_threadpool",
        "starlette.exceptions.HTTPException",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.routing.Match",
        "starlette.routing.compile_path",
        "starlette.routing.get_name",
        "starlette.routing.request_response",
        "starlette.routing.websocket_session",
        "starlette.routing.Mount",
        "starlette.types.AppType",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Scope",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "self.add_api_route",
          "body": "def add_api_route(self, path: str, endpoint: Callable[..., Any], *, response_model: Any=Default(None), status_code: Optional[int]=None, tags: Optional[List[Union[str, Enum]]]=None, dependencies: Optional[Sequence[Depends]]=None, summary: Optional[str]=None, description: Optional[str]=None, response_description: str='Successful Response', responses: Optional[Dict[Union[int, str], Dict[str, Any]]]=None, deprecated: Optional[bool]=None, methods: Optional[List[str]]=None, operation_id: Optional[str]=None, response_model_include: Optional[IncEx]=None, response_model_exclude: Optional[IncEx]=None, response_model_by_alias: bool=True, response_model_exclude_unset: bool=False, response_model_exclude_defaults: bool=False, response_model_exclude_none: bool=False, include_in_schema: bool=True, response_class: Union[Type[Response], DefaultPlaceholder]=Default(JSONResponse), name: Optional[str]=None, openapi_extra: Optional[Dict[str, Any]]=None, generate_unique_id_function: Callable[[routing.APIRoute], str]=Default(generate_unique_id)) -> None:\n    self.router.add_api_route(path, endpoint=endpoint, response_model=response_model, status_code=status_code, tags=tags, dependencies=dependencies, summary=summary, description=description, response_description=response_description, responses=responses, deprecated=deprecated, methods=methods, operation_id=operation_id, response_model_include=response_model_include, response_model_exclude=response_model_exclude, response_model_by_alias=response_model_by_alias, response_model_exclude_unset=response_model_exclude_unset, response_model_exclude_defaults=response_model_exclude_defaults, response_model_exclude_none=response_model_exclude_none, include_in_schema=include_in_schema, response_class=response_class, name=name, openapi_extra=openapi_extra, generate_unique_id_function=generate_unique_id_function)"
        }
      ]
    },
    {
      "name": "add_api_websocket_route",
      "module": "routing",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\routing.py",
      "line_number": 1025,
      "end_line_number": 1044,
      "source_code": "def add_api_websocket_route(\n        self,\n        path: str,\n        endpoint: Callable[..., Any],\n        name: Optional[str] = None,\n        *,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n    ) -> None:\n        current_dependencies = self.dependencies.copy()\n        if dependencies:\n            current_dependencies.extend(dependencies)\n\n        route = APIWebSocketRoute(\n            self.prefix + path,\n            endpoint=endpoint,\n            name=name,\n            dependencies=current_dependencies,\n            dependency_overrides_provider=self.dependency_overrides_provider,\n        )\n        self.routes.append(route)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "path",
        "endpoint",
        "name"
      ],
      "imports": [
        "asyncio",
        "dataclasses",
        "email.message",
        "inspect",
        "json",
        "contextlib.AsyncExitStack",
        "contextlib.asynccontextmanager",
        "enum.Enum",
        "enum.IntEnum",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.params",
        "fastapi._compat.ModelField",
        "fastapi._compat.Undefined",
        "fastapi._compat._get_model_config",
        "fastapi._compat._model_dump",
        "fastapi._compat._normalize_errors",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.utils._should_embed_body_fields",
        "fastapi.dependencies.utils.get_body_field",
        "fastapi.dependencies.utils.get_dependant",
        "fastapi.dependencies.utils.get_flat_dependant",
        "fastapi.dependencies.utils.get_parameterless_sub_dependant",
        "fastapi.dependencies.utils.get_typed_return_annotation",
        "fastapi.dependencies.utils.solve_dependencies",
        "fastapi.encoders.jsonable_encoder",
        "fastapi.exceptions.FastAPIError",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.ResponseValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.create_cloned_field",
        "fastapi.utils.create_model_field",
        "fastapi.utils.generate_unique_id",
        "fastapi.utils.get_value_or_default",
        "fastapi.utils.is_body_allowed_for_status_code",
        "pydantic.BaseModel",
        "starlette.routing",
        "starlette.concurrency.run_in_threadpool",
        "starlette.exceptions.HTTPException",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.routing.Match",
        "starlette.routing.compile_path",
        "starlette.routing.get_name",
        "starlette.routing.request_response",
        "starlette.routing.websocket_session",
        "starlette.routing.Mount",
        "starlette.types.AppType",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Scope",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "websocket",
      "module": "routing",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\routing.py",
      "line_number": 1046,
      "end_line_number": 1111,
      "source_code": "def websocket(\n        self,\n        path: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                WebSocket path.\n                \"\"\"\n            ),\n        ],\n        name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A name for the WebSocket. Only used internally.\n                \"\"\"\n            ),\n        ] = None,\n        *,\n        dependencies: Annotated[\n            Optional[Sequence[params.Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be used for this\n                WebSocket.\n\n                Read more about it in the\n                [FastAPI docs for WebSockets](https://fastapi.tiangolo.com/advanced/websockets/).\n                \"\"\"\n            ),\n        ] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Decorate a WebSocket function.\n\n        Read more about it in the\n        [FastAPI docs for WebSockets](https://fastapi.tiangolo.com/advanced/websockets/).\n\n        **Example**\n\n        ## Example\n\n        ```python\n        from fastapi import APIRouter, FastAPI, WebSocket\n\n        app = FastAPI()\n        router = APIRouter()\n\n        @router.websocket(\"/ws\")\n        async def websocket_endpoint(websocket: WebSocket):\n            await websocket.accept()\n            while True:\n                data = await websocket.receive_text()\n                await websocket.send_text(f\"Message text was: {data}\")\n\n        app.include_router(router)\n        ```\n        \"\"\"\n\n        def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.add_api_websocket_route(\n                path, func, name=name, dependencies=dependencies\n            )\n            return func\n\n        return decorator",
      "docstring": "Decorate a WebSocket function.\n\nRead more about it in the\n[FastAPI docs for WebSockets](https://fastapi.tiangolo.com/advanced/websockets/).\n\n**Example**\n\n## Example\n\n```python\nfrom fastapi import APIRouter, FastAPI, WebSocket\n\napp = FastAPI()\nrouter = APIRouter()\n\n@router.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    while True:\n        data = await websocket.receive_text()\n        await websocket.send_text(f\"Message text was: {data}\")\n\napp.include_router(router)\n```",
      "decorators": [],
      "arguments": [
        "self",
        "path",
        "name"
      ],
      "imports": [
        "asyncio",
        "dataclasses",
        "email.message",
        "inspect",
        "json",
        "contextlib.AsyncExitStack",
        "contextlib.asynccontextmanager",
        "enum.Enum",
        "enum.IntEnum",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.params",
        "fastapi._compat.ModelField",
        "fastapi._compat.Undefined",
        "fastapi._compat._get_model_config",
        "fastapi._compat._model_dump",
        "fastapi._compat._normalize_errors",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.utils._should_embed_body_fields",
        "fastapi.dependencies.utils.get_body_field",
        "fastapi.dependencies.utils.get_dependant",
        "fastapi.dependencies.utils.get_flat_dependant",
        "fastapi.dependencies.utils.get_parameterless_sub_dependant",
        "fastapi.dependencies.utils.get_typed_return_annotation",
        "fastapi.dependencies.utils.solve_dependencies",
        "fastapi.encoders.jsonable_encoder",
        "fastapi.exceptions.FastAPIError",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.ResponseValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.create_cloned_field",
        "fastapi.utils.create_model_field",
        "fastapi.utils.generate_unique_id",
        "fastapi.utils.get_value_or_default",
        "fastapi.utils.is_body_allowed_for_status_code",
        "pydantic.BaseModel",
        "starlette.routing",
        "starlette.concurrency.run_in_threadpool",
        "starlette.exceptions.HTTPException",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.routing.Match",
        "starlette.routing.compile_path",
        "starlette.routing.get_name",
        "starlette.routing.request_response",
        "starlette.routing.websocket_session",
        "starlette.routing.Mount",
        "starlette.types.AppType",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Scope",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.add_api_websocket_route",
          "body": "def add_api_websocket_route(self, path: str, endpoint: Callable[..., Any], name: Optional[str]=None, *, dependencies: Optional[Sequence[Depends]]=None) -> None:\n    self.router.add_api_websocket_route(path, endpoint, name=name, dependencies=dependencies)"
        }
      ]
    },
    {
      "name": "websocket_route",
      "module": "routing",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\routing.py",
      "line_number": 1113,
      "end_line_number": 1120,
      "source_code": "def websocket_route(\n        self, path: str, name: Union[str, None] = None\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.add_websocket_route(path, func, name=name)\n            return func\n\n        return decorator",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "path",
        "name"
      ],
      "imports": [
        "asyncio",
        "dataclasses",
        "email.message",
        "inspect",
        "json",
        "contextlib.AsyncExitStack",
        "contextlib.asynccontextmanager",
        "enum.Enum",
        "enum.IntEnum",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.params",
        "fastapi._compat.ModelField",
        "fastapi._compat.Undefined",
        "fastapi._compat._get_model_config",
        "fastapi._compat._model_dump",
        "fastapi._compat._normalize_errors",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.utils._should_embed_body_fields",
        "fastapi.dependencies.utils.get_body_field",
        "fastapi.dependencies.utils.get_dependant",
        "fastapi.dependencies.utils.get_flat_dependant",
        "fastapi.dependencies.utils.get_parameterless_sub_dependant",
        "fastapi.dependencies.utils.get_typed_return_annotation",
        "fastapi.dependencies.utils.solve_dependencies",
        "fastapi.encoders.jsonable_encoder",
        "fastapi.exceptions.FastAPIError",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.ResponseValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.create_cloned_field",
        "fastapi.utils.create_model_field",
        "fastapi.utils.generate_unique_id",
        "fastapi.utils.get_value_or_default",
        "fastapi.utils.is_body_allowed_for_status_code",
        "pydantic.BaseModel",
        "starlette.routing",
        "starlette.concurrency.run_in_threadpool",
        "starlette.exceptions.HTTPException",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.routing.Match",
        "starlette.routing.compile_path",
        "starlette.routing.get_name",
        "starlette.routing.request_response",
        "starlette.routing.websocket_session",
        "starlette.routing.Mount",
        "starlette.types.AppType",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Scope",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "include_router",
      "module": "routing",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\routing.py",
      "line_number": 1122,
      "end_line_number": 1364,
      "source_code": "def include_router(\n        self,\n        router: Annotated[\"APIRouter\", Doc(\"The `APIRouter` to include.\")],\n        *,\n        prefix: Annotated[str, Doc(\"An optional path prefix for the router.\")] = \"\",\n        tags: Annotated[\n            Optional[List[Union[str, Enum]]],\n            Doc(\n                \"\"\"\n                A list of tags to be applied to all the *path operations* in this\n                router.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        dependencies: Annotated[\n            Optional[Sequence[params.Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be applied to all the\n                *path operations* in this router.\n\n                Read more about it in the\n                [FastAPI docs for Bigger Applications - Multiple Files](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).\n                \"\"\"\n            ),\n        ] = None,\n        default_response_class: Annotated[\n            Type[Response],\n            Doc(\n                \"\"\"\n                The default response class to be used.\n\n                Read more in the\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#default-response-class).\n                \"\"\"\n            ),\n        ] = Default(JSONResponse),\n        responses: Annotated[\n            Optional[Dict[Union[int, str], Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                Additional responses to be shown in OpenAPI.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Additional Responses in OpenAPI](https://fastapi.tiangolo.com/advanced/additional-responses/).\n\n                And in the\n                [FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).\n                \"\"\"\n            ),\n        ] = None,\n        callbacks: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                OpenAPI callbacks that should apply to all *path operations* in this\n                router.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\n                \"\"\"\n            ),\n        ] = None,\n        deprecated: Annotated[\n            Optional[bool],\n            Doc(\n                \"\"\"\n                Mark all *path operations* in this router as deprecated.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        include_in_schema: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Include (or not) all the *path operations* in this router in the\n                generated OpenAPI schema.\n\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = True,\n        generate_unique_id_function: Annotated[\n            Callable[[APIRoute], str],\n            Doc(\n                \"\"\"\n                Customize the function used to generate unique IDs for the *path\n                operations* shown in the generated OpenAPI.\n\n                This is particularly useful when automatically generating clients or\n                SDKs for your API.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = Default(generate_unique_id),\n    ) -> None:\n        \"\"\"\n        Include another `APIRouter` in the same current `APIRouter`.\n\n        Read more about it in the\n        [FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/).\n\n        ## Example\n\n        ```python\n        from fastapi import APIRouter, FastAPI\n\n        app = FastAPI()\n        internal_router = APIRouter()\n        users_router = APIRouter()\n\n        @users_router.get(\"/users/\")\n        def read_users():\n            return [{\"name\": \"Rick\"}, {\"name\": \"Morty\"}]\n\n        internal_router.include_router(users_router)\n        app.include_router(internal_router)\n        ```\n        \"\"\"\n        if prefix:\n            assert prefix.startswith(\"/\"), \"A path prefix must start with '/'\"\n            assert not prefix.endswith(\n                \"/\"\n            ), \"A path prefix must not end with '/', as the routes will start with '/'\"\n        else:\n            for r in router.routes:\n                path = getattr(r, \"path\")  # noqa: B009\n                name = getattr(r, \"name\", \"unknown\")\n                if path is not None and not path:\n                    raise FastAPIError(\n                        f\"Prefix and path cannot be both empty (path operation: {name})\"\n                    )\n        if responses is None:\n            responses = {}\n        for route in router.routes:\n            if isinstance(route, APIRoute):\n                combined_responses = {**responses, **route.responses}\n                use_response_class = get_value_or_default(\n                    route.response_class,\n                    router.default_response_class,\n                    default_response_class,\n                    self.default_response_class,\n                )\n                current_tags = []\n                if tags:\n                    current_tags.extend(tags)\n                if route.tags:\n                    current_tags.extend(route.tags)\n                current_dependencies: List[params.Depends] = []\n                if dependencies:\n                    current_dependencies.extend(dependencies)\n                if route.dependencies:\n                    current_dependencies.extend(route.dependencies)\n                current_callbacks = []\n                if callbacks:\n                    current_callbacks.extend(callbacks)\n                if route.callbacks:\n                    current_callbacks.extend(route.callbacks)\n                current_generate_unique_id = get_value_or_default(\n                    route.generate_unique_id_function,\n                    router.generate_unique_id_function,\n                    generate_unique_id_function,\n                    self.generate_unique_id_function,\n                )\n                self.add_api_route(\n                    prefix + route.path,\n                    route.endpoint,\n                    response_model=route.response_model,\n                    status_code=route.status_code,\n                    tags=current_tags,\n                    dependencies=current_dependencies,\n                    summary=route.summary,\n                    description=route.description,\n                    response_description=route.response_description,\n                    responses=combined_responses,\n                    deprecated=route.deprecated or deprecated or self.deprecated,\n                    methods=route.methods,\n                    operation_id=route.operation_id,\n                    response_model_include=route.response_model_include,\n                    response_model_exclude=route.response_model_exclude,\n                    response_model_by_alias=route.response_model_by_alias,\n                    response_model_exclude_unset=route.response_model_exclude_unset,\n                    response_model_exclude_defaults=route.response_model_exclude_defaults,\n                    response_model_exclude_none=route.response_model_exclude_none,\n                    include_in_schema=route.include_in_schema\n                    and self.include_in_schema\n                    and include_in_schema,\n                    response_class=use_response_class,\n                    name=route.name,\n                    route_class_override=type(route),\n                    callbacks=current_callbacks,\n                    openapi_extra=route.openapi_extra,\n                    generate_unique_id_function=current_generate_unique_id,\n                )\n            elif isinstance(route, routing.Route):\n                methods = list(route.methods or [])\n                self.add_route(\n                    prefix + route.path,\n                    route.endpoint,\n                    methods=methods,\n                    include_in_schema=route.include_in_schema,\n                    name=route.name,\n                )\n            elif isinstance(route, APIWebSocketRoute):\n                current_dependencies = []\n                if dependencies:\n                    current_dependencies.extend(dependencies)\n                if route.dependencies:\n                    current_dependencies.extend(route.dependencies)\n                self.add_api_websocket_route(\n                    prefix + route.path,\n                    route.endpoint,\n                    dependencies=current_dependencies,\n                    name=route.name,\n                )\n            elif isinstance(route, routing.WebSocketRoute):\n                self.add_websocket_route(\n                    prefix + route.path, route.endpoint, name=route.name\n                )\n        for handler in router.on_startup:\n            self.add_event_handler(\"startup\", handler)\n        for handler in router.on_shutdown:\n            self.add_event_handler(\"shutdown\", handler)\n        self.lifespan_context = _merge_lifespan_context(\n            self.lifespan_context,\n            router.lifespan_context,\n        )",
      "docstring": "Include another `APIRouter` in the same current `APIRouter`.\n\nRead more about it in the\n[FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/).\n\n## Example\n\n```python\nfrom fastapi import APIRouter, FastAPI\n\napp = FastAPI()\ninternal_router = APIRouter()\nusers_router = APIRouter()\n\n@users_router.get(\"/users/\")\ndef read_users():\n    return [{\"name\": \"Rick\"}, {\"name\": \"Morty\"}]\n\ninternal_router.include_router(users_router)\napp.include_router(internal_router)\n```",
      "decorators": [],
      "arguments": [
        "self",
        "router"
      ],
      "imports": [
        "asyncio",
        "dataclasses",
        "email.message",
        "inspect",
        "json",
        "contextlib.AsyncExitStack",
        "contextlib.asynccontextmanager",
        "enum.Enum",
        "enum.IntEnum",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.params",
        "fastapi._compat.ModelField",
        "fastapi._compat.Undefined",
        "fastapi._compat._get_model_config",
        "fastapi._compat._model_dump",
        "fastapi._compat._normalize_errors",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.utils._should_embed_body_fields",
        "fastapi.dependencies.utils.get_body_field",
        "fastapi.dependencies.utils.get_dependant",
        "fastapi.dependencies.utils.get_flat_dependant",
        "fastapi.dependencies.utils.get_parameterless_sub_dependant",
        "fastapi.dependencies.utils.get_typed_return_annotation",
        "fastapi.dependencies.utils.solve_dependencies",
        "fastapi.encoders.jsonable_encoder",
        "fastapi.exceptions.FastAPIError",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.ResponseValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.create_cloned_field",
        "fastapi.utils.create_model_field",
        "fastapi.utils.generate_unique_id",
        "fastapi.utils.get_value_or_default",
        "fastapi.utils.is_body_allowed_for_status_code",
        "pydantic.BaseModel",
        "starlette.routing",
        "starlette.concurrency.run_in_threadpool",
        "starlette.exceptions.HTTPException",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.routing.Match",
        "starlette.routing.compile_path",
        "starlette.routing.get_name",
        "starlette.routing.request_response",
        "starlette.routing.websocket_session",
        "starlette.routing.Mount",
        "starlette.types.AppType",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Scope",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [
        "assert prefix.startswith('/'), \"A path prefix must start with '/'\"",
        "assert not prefix.endswith('/'), \"A path prefix must not end with '/', as the routes will start with '/'\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "_merge_lifespan_context",
          "body": "def _merge_lifespan_context(original_context: Lifespan[Any], nested_context: Lifespan[Any]) -> Lifespan[Any]:\n\n    @asynccontextmanager\n    async def merged_lifespan(app: AppType) -> AsyncIterator[Optional[Mapping[str, Any]]]:\n        async with original_context(app) as maybe_original_state:\n            async with nested_context(app) as maybe_nested_state:\n                if maybe_nested_state is None and maybe_original_state is None:\n                    yield None\n                else:\n                    yield {**(maybe_nested_state or {}), **(maybe_original_state or {})}\n    return merged_lifespan"
        },
        {
          "name": "get_value_or_default",
          "body": "def get_value_or_default(first_item: Union[DefaultPlaceholder, DefaultType], *extra_items: Union[DefaultPlaceholder, DefaultType]) -> Union[DefaultPlaceholder, DefaultType]:\n    \"\"\"\n    Pass items or `DefaultPlaceholder`s by descending priority.\n\n    The first one to _not_ be a `DefaultPlaceholder` will be returned.\n\n    Otherwise, the first item (a `DefaultPlaceholder`) will be returned.\n    \"\"\"\n    items = (first_item,) + extra_items\n    for item in items:\n        if not isinstance(item, DefaultPlaceholder):\n            return item\n    return first_item"
        },
        {
          "name": "get_value_or_default",
          "body": "def get_value_or_default(first_item: Union[DefaultPlaceholder, DefaultType], *extra_items: Union[DefaultPlaceholder, DefaultType]) -> Union[DefaultPlaceholder, DefaultType]:\n    \"\"\"\n    Pass items or `DefaultPlaceholder`s by descending priority.\n\n    The first one to _not_ be a `DefaultPlaceholder` will be returned.\n\n    Otherwise, the first item (a `DefaultPlaceholder`) will be returned.\n    \"\"\"\n    items = (first_item,) + extra_items\n    for item in items:\n        if not isinstance(item, DefaultPlaceholder):\n            return item\n    return first_item"
        },
        {
          "name": "self.add_api_route",
          "body": "def add_api_route(self, path: str, endpoint: Callable[..., Any], *, response_model: Any=Default(None), status_code: Optional[int]=None, tags: Optional[List[Union[str, Enum]]]=None, dependencies: Optional[Sequence[Depends]]=None, summary: Optional[str]=None, description: Optional[str]=None, response_description: str='Successful Response', responses: Optional[Dict[Union[int, str], Dict[str, Any]]]=None, deprecated: Optional[bool]=None, methods: Optional[List[str]]=None, operation_id: Optional[str]=None, response_model_include: Optional[IncEx]=None, response_model_exclude: Optional[IncEx]=None, response_model_by_alias: bool=True, response_model_exclude_unset: bool=False, response_model_exclude_defaults: bool=False, response_model_exclude_none: bool=False, include_in_schema: bool=True, response_class: Union[Type[Response], DefaultPlaceholder]=Default(JSONResponse), name: Optional[str]=None, openapi_extra: Optional[Dict[str, Any]]=None, generate_unique_id_function: Callable[[routing.APIRoute], str]=Default(generate_unique_id)) -> None:\n    self.router.add_api_route(path, endpoint=endpoint, response_model=response_model, status_code=status_code, tags=tags, dependencies=dependencies, summary=summary, description=description, response_description=response_description, responses=responses, deprecated=deprecated, methods=methods, operation_id=operation_id, response_model_include=response_model_include, response_model_exclude=response_model_exclude, response_model_by_alias=response_model_by_alias, response_model_exclude_unset=response_model_exclude_unset, response_model_exclude_defaults=response_model_exclude_defaults, response_model_exclude_none=response_model_exclude_none, include_in_schema=include_in_schema, response_class=response_class, name=name, openapi_extra=openapi_extra, generate_unique_id_function=generate_unique_id_function)"
        },
        {
          "name": "self.add_api_websocket_route",
          "body": "def add_api_websocket_route(self, path: str, endpoint: Callable[..., Any], name: Optional[str]=None, *, dependencies: Optional[Sequence[Depends]]=None) -> None:\n    self.router.add_api_websocket_route(path, endpoint, name=name, dependencies=dependencies)"
        }
      ]
    },
    {
      "name": "get",
      "module": "routing",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\routing.py",
      "line_number": 1366,
      "end_line_number": 1741,
      "source_code": "def get(\n        self,\n        path: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The URL path to be used for this *path operation*.\n\n                For example, in `http://example.com/items`, the path is `/items`.\n                \"\"\"\n            ),\n        ],\n        *,\n        response_model: Annotated[\n            Any,\n            Doc(\n                \"\"\"\n                The type to use for the response.\n\n                It could be any valid Pydantic *field* type. So, it doesn't have to\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\n                etc.\n\n                It will be used for:\n\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\n                    show it as the response (JSON Schema).\n                * Serialization: you could return an arbitrary object and the\n                    `response_model` would be used to serialize that object into the\n                    corresponding JSON.\n                * Filtering: the JSON sent to the client will only contain the data\n                    (fields) defined in the `response_model`. If you returned an object\n                    that contains an attribute `password` but the `response_model` does\n                    not include that field, the JSON sent to the client would not have\n                    that `password`.\n                * Validation: whatever you return will be serialized with the\n                    `response_model`, converting any data as necessary to generate the\n                    corresponding JSON. But if the data in the object returned is not\n                    valid, that would mean a violation of the contract with the client,\n                    so it's an error from the API developer. So, FastAPI will raise an\n                    error and return a 500 error code (Internal Server Error).\n\n                Read more about it in the\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\n                \"\"\"\n            ),\n        ] = Default(None),\n        status_code: Annotated[\n            Optional[int],\n            Doc(\n                \"\"\"\n                The default status code to be used for the response.\n\n                You could override the status code by returning a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\n                \"\"\"\n            ),\n        ] = None,\n        tags: Annotated[\n            Optional[List[Union[str, Enum]]],\n            Doc(\n                \"\"\"\n                A list of tags to be applied to the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\n                \"\"\"\n            ),\n        ] = None,\n        dependencies: Annotated[\n            Optional[Sequence[params.Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be applied to the\n                *path operation*.\n\n                Read more about it in the\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\n                \"\"\"\n            ),\n        ] = None,\n        summary: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A summary for the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A description for the *path operation*.\n\n                If not provided, it will be extracted automatically from the docstring\n                of the *path operation function*.\n\n                It can contain Markdown.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        response_description: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The description for the default response.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = \"Successful Response\",\n        responses: Annotated[\n            Optional[Dict[Union[int, str], Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                Additional responses that could be returned by this *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        deprecated: Annotated[\n            Optional[bool],\n            Doc(\n                \"\"\"\n                Mark this *path operation* as deprecated.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        operation_id: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Custom operation ID to be used by this *path operation*.\n\n                By default, it is generated automatically.\n\n                If you provide a custom operation ID, you need to make sure it is\n                unique for the whole API.\n\n                You can customize the\n                operation ID generation with the parameter\n                `generate_unique_id_function` in the `FastAPI` class.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_include: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to include only certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_exclude: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to exclude certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_by_alias: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response model\n                should be serialized by alias when an alias is used.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = True,\n        response_model_exclude_unset: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that were not set and\n                have their default values. This is different from\n                `response_model_exclude_defaults` in that if the fields are set,\n                they will be included in the response, even if the value is the same\n                as the default.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_defaults: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that have the same value\n                as the default. This is different from `response_model_exclude_unset`\n                in that if the fields are set but contain the same default values,\n                they will be excluded from the response.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_none: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data should\n                exclude fields set to `None`.\n\n                This is much simpler (less smart) than `response_model_exclude_unset`\n                and `response_model_exclude_defaults`. You probably want to use one of\n                those two instead of this one, as those allow returning `None` values\n                when it makes sense.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\n                \"\"\"\n            ),\n        ] = False,\n        include_in_schema: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Include this *path operation* in the generated OpenAPI schema.\n\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\n                \"\"\"\n            ),\n        ] = True,\n        response_class: Annotated[\n            Type[Response],\n            Doc(\n                \"\"\"\n                Response class to be used for this *path operation*.\n\n                This will not be used if you return a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\n                \"\"\"\n            ),\n        ] = Default(JSONResponse),\n        name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Name for this *path operation*. Only used internally.\n                \"\"\"\n            ),\n        ] = None,\n        callbacks: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                List of *path operations* that will be used as OpenAPI callbacks.\n\n                This is only for OpenAPI documentation, the callbacks won't be used\n                directly.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\n                \"\"\"\n            ),\n        ] = None,\n        openapi_extra: Annotated[\n            Optional[Dict[str, Any]],\n            Doc(\n                \"\"\"\n                Extra metadata to be included in the OpenAPI schema for this *path\n                operation*.\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\n                \"\"\"\n            ),\n        ] = None,\n        generate_unique_id_function: Annotated[\n            Callable[[APIRoute], str],\n            Doc(\n                \"\"\"\n                Customize the function used to generate unique IDs for the *path\n                operations* shown in the generated OpenAPI.\n\n                This is particularly useful when automatically generating clients or\n                SDKs for your API.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = Default(generate_unique_id),\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Add a *path operation* using an HTTP GET operation.\n\n        ## Example\n\n        ```python\n        from fastapi import APIRouter, FastAPI\n\n        app = FastAPI()\n        router = APIRouter()\n\n        @router.get(\"/items/\")\n        def read_items():\n            return [{\"name\": \"Empanada\"}, {\"name\": \"Arepa\"}]\n\n        app.include_router(router)\n        ```\n        \"\"\"\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"GET\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n            generate_unique_id_function=generate_unique_id_function,\n        )",
      "docstring": "Add a *path operation* using an HTTP GET operation.\n\n## Example\n\n```python\nfrom fastapi import APIRouter, FastAPI\n\napp = FastAPI()\nrouter = APIRouter()\n\n@router.get(\"/items/\")\ndef read_items():\n    return [{\"name\": \"Empanada\"}, {\"name\": \"Arepa\"}]\n\napp.include_router(router)\n```",
      "decorators": [],
      "arguments": [
        "self",
        "path"
      ],
      "imports": [
        "asyncio",
        "dataclasses",
        "email.message",
        "inspect",
        "json",
        "contextlib.AsyncExitStack",
        "contextlib.asynccontextmanager",
        "enum.Enum",
        "enum.IntEnum",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.params",
        "fastapi._compat.ModelField",
        "fastapi._compat.Undefined",
        "fastapi._compat._get_model_config",
        "fastapi._compat._model_dump",
        "fastapi._compat._normalize_errors",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.utils._should_embed_body_fields",
        "fastapi.dependencies.utils.get_body_field",
        "fastapi.dependencies.utils.get_dependant",
        "fastapi.dependencies.utils.get_flat_dependant",
        "fastapi.dependencies.utils.get_parameterless_sub_dependant",
        "fastapi.dependencies.utils.get_typed_return_annotation",
        "fastapi.dependencies.utils.solve_dependencies",
        "fastapi.encoders.jsonable_encoder",
        "fastapi.exceptions.FastAPIError",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.ResponseValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.create_cloned_field",
        "fastapi.utils.create_model_field",
        "fastapi.utils.generate_unique_id",
        "fastapi.utils.get_value_or_default",
        "fastapi.utils.is_body_allowed_for_status_code",
        "pydantic.BaseModel",
        "starlette.routing",
        "starlette.concurrency.run_in_threadpool",
        "starlette.exceptions.HTTPException",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.routing.Match",
        "starlette.routing.compile_path",
        "starlette.routing.get_name",
        "starlette.routing.request_response",
        "starlette.routing.websocket_session",
        "starlette.routing.Mount",
        "starlette.types.AppType",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Scope",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "self.api_route",
          "body": "def api_route(self, path: str, *, response_model: Any=Default(None), status_code: Optional[int]=None, tags: Optional[List[Union[str, Enum]]]=None, dependencies: Optional[Sequence[Depends]]=None, summary: Optional[str]=None, description: Optional[str]=None, response_description: str='Successful Response', responses: Optional[Dict[Union[int, str], Dict[str, Any]]]=None, deprecated: Optional[bool]=None, methods: Optional[List[str]]=None, operation_id: Optional[str]=None, response_model_include: Optional[IncEx]=None, response_model_exclude: Optional[IncEx]=None, response_model_by_alias: bool=True, response_model_exclude_unset: bool=False, response_model_exclude_defaults: bool=False, response_model_exclude_none: bool=False, include_in_schema: bool=True, response_class: Type[Response]=Default(JSONResponse), name: Optional[str]=None, openapi_extra: Optional[Dict[str, Any]]=None, generate_unique_id_function: Callable[[routing.APIRoute], str]=Default(generate_unique_id)) -> Callable[[DecoratedCallable], DecoratedCallable]:\n\n    def decorator(func: DecoratedCallable) -> DecoratedCallable:\n        self.router.add_api_route(path, func, response_model=response_model, status_code=status_code, tags=tags, dependencies=dependencies, summary=summary, description=description, response_description=response_description, responses=responses, deprecated=deprecated, methods=methods, operation_id=operation_id, response_model_include=response_model_include, response_model_exclude=response_model_exclude, response_model_by_alias=response_model_by_alias, response_model_exclude_unset=response_model_exclude_unset, response_model_exclude_defaults=response_model_exclude_defaults, response_model_exclude_none=response_model_exclude_none, include_in_schema=include_in_schema, response_class=response_class, name=name, openapi_extra=openapi_extra, generate_unique_id_function=generate_unique_id_function)\n        return func\n    return decorator"
        }
      ]
    },
    {
      "name": "put",
      "module": "routing",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\routing.py",
      "line_number": 1743,
      "end_line_number": 2123,
      "source_code": "def put(\n        self,\n        path: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The URL path to be used for this *path operation*.\n\n                For example, in `http://example.com/items`, the path is `/items`.\n                \"\"\"\n            ),\n        ],\n        *,\n        response_model: Annotated[\n            Any,\n            Doc(\n                \"\"\"\n                The type to use for the response.\n\n                It could be any valid Pydantic *field* type. So, it doesn't have to\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\n                etc.\n\n                It will be used for:\n\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\n                    show it as the response (JSON Schema).\n                * Serialization: you could return an arbitrary object and the\n                    `response_model` would be used to serialize that object into the\n                    corresponding JSON.\n                * Filtering: the JSON sent to the client will only contain the data\n                    (fields) defined in the `response_model`. If you returned an object\n                    that contains an attribute `password` but the `response_model` does\n                    not include that field, the JSON sent to the client would not have\n                    that `password`.\n                * Validation: whatever you return will be serialized with the\n                    `response_model`, converting any data as necessary to generate the\n                    corresponding JSON. But if the data in the object returned is not\n                    valid, that would mean a violation of the contract with the client,\n                    so it's an error from the API developer. So, FastAPI will raise an\n                    error and return a 500 error code (Internal Server Error).\n\n                Read more about it in the\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\n                \"\"\"\n            ),\n        ] = Default(None),\n        status_code: Annotated[\n            Optional[int],\n            Doc(\n                \"\"\"\n                The default status code to be used for the response.\n\n                You could override the status code by returning a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\n                \"\"\"\n            ),\n        ] = None,\n        tags: Annotated[\n            Optional[List[Union[str, Enum]]],\n            Doc(\n                \"\"\"\n                A list of tags to be applied to the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\n                \"\"\"\n            ),\n        ] = None,\n        dependencies: Annotated[\n            Optional[Sequence[params.Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be applied to the\n                *path operation*.\n\n                Read more about it in the\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\n                \"\"\"\n            ),\n        ] = None,\n        summary: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A summary for the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A description for the *path operation*.\n\n                If not provided, it will be extracted automatically from the docstring\n                of the *path operation function*.\n\n                It can contain Markdown.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        response_description: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The description for the default response.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = \"Successful Response\",\n        responses: Annotated[\n            Optional[Dict[Union[int, str], Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                Additional responses that could be returned by this *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        deprecated: Annotated[\n            Optional[bool],\n            Doc(\n                \"\"\"\n                Mark this *path operation* as deprecated.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        operation_id: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Custom operation ID to be used by this *path operation*.\n\n                By default, it is generated automatically.\n\n                If you provide a custom operation ID, you need to make sure it is\n                unique for the whole API.\n\n                You can customize the\n                operation ID generation with the parameter\n                `generate_unique_id_function` in the `FastAPI` class.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_include: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to include only certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_exclude: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to exclude certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_by_alias: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response model\n                should be serialized by alias when an alias is used.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = True,\n        response_model_exclude_unset: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that were not set and\n                have their default values. This is different from\n                `response_model_exclude_defaults` in that if the fields are set,\n                they will be included in the response, even if the value is the same\n                as the default.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_defaults: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that have the same value\n                as the default. This is different from `response_model_exclude_unset`\n                in that if the fields are set but contain the same default values,\n                they will be excluded from the response.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_none: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data should\n                exclude fields set to `None`.\n\n                This is much simpler (less smart) than `response_model_exclude_unset`\n                and `response_model_exclude_defaults`. You probably want to use one of\n                those two instead of this one, as those allow returning `None` values\n                when it makes sense.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\n                \"\"\"\n            ),\n        ] = False,\n        include_in_schema: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Include this *path operation* in the generated OpenAPI schema.\n\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\n                \"\"\"\n            ),\n        ] = True,\n        response_class: Annotated[\n            Type[Response],\n            Doc(\n                \"\"\"\n                Response class to be used for this *path operation*.\n\n                This will not be used if you return a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\n                \"\"\"\n            ),\n        ] = Default(JSONResponse),\n        name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Name for this *path operation*. Only used internally.\n                \"\"\"\n            ),\n        ] = None,\n        callbacks: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                List of *path operations* that will be used as OpenAPI callbacks.\n\n                This is only for OpenAPI documentation, the callbacks won't be used\n                directly.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\n                \"\"\"\n            ),\n        ] = None,\n        openapi_extra: Annotated[\n            Optional[Dict[str, Any]],\n            Doc(\n                \"\"\"\n                Extra metadata to be included in the OpenAPI schema for this *path\n                operation*.\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\n                \"\"\"\n            ),\n        ] = None,\n        generate_unique_id_function: Annotated[\n            Callable[[APIRoute], str],\n            Doc(\n                \"\"\"\n                Customize the function used to generate unique IDs for the *path\n                operations* shown in the generated OpenAPI.\n\n                This is particularly useful when automatically generating clients or\n                SDKs for your API.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = Default(generate_unique_id),\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Add a *path operation* using an HTTP PUT operation.\n\n        ## Example\n\n        ```python\n        from fastapi import APIRouter, FastAPI\n        from pydantic import BaseModel\n\n        class Item(BaseModel):\n            name: str\n            description: str | None = None\n\n        app = FastAPI()\n        router = APIRouter()\n\n        @router.put(\"/items/{item_id}\")\n        def replace_item(item_id: str, item: Item):\n            return {\"message\": \"Item replaced\", \"id\": item_id}\n\n        app.include_router(router)\n        ```\n        \"\"\"\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"PUT\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n            generate_unique_id_function=generate_unique_id_function,\n        )",
      "docstring": "Add a *path operation* using an HTTP PUT operation.\n\n## Example\n\n```python\nfrom fastapi import APIRouter, FastAPI\nfrom pydantic import BaseModel\n\nclass Item(BaseModel):\n    name: str\n    description: str | None = None\n\napp = FastAPI()\nrouter = APIRouter()\n\n@router.put(\"/items/{item_id}\")\ndef replace_item(item_id: str, item: Item):\n    return {\"message\": \"Item replaced\", \"id\": item_id}\n\napp.include_router(router)\n```",
      "decorators": [],
      "arguments": [
        "self",
        "path"
      ],
      "imports": [
        "asyncio",
        "dataclasses",
        "email.message",
        "inspect",
        "json",
        "contextlib.AsyncExitStack",
        "contextlib.asynccontextmanager",
        "enum.Enum",
        "enum.IntEnum",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.params",
        "fastapi._compat.ModelField",
        "fastapi._compat.Undefined",
        "fastapi._compat._get_model_config",
        "fastapi._compat._model_dump",
        "fastapi._compat._normalize_errors",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.utils._should_embed_body_fields",
        "fastapi.dependencies.utils.get_body_field",
        "fastapi.dependencies.utils.get_dependant",
        "fastapi.dependencies.utils.get_flat_dependant",
        "fastapi.dependencies.utils.get_parameterless_sub_dependant",
        "fastapi.dependencies.utils.get_typed_return_annotation",
        "fastapi.dependencies.utils.solve_dependencies",
        "fastapi.encoders.jsonable_encoder",
        "fastapi.exceptions.FastAPIError",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.ResponseValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.create_cloned_field",
        "fastapi.utils.create_model_field",
        "fastapi.utils.generate_unique_id",
        "fastapi.utils.get_value_or_default",
        "fastapi.utils.is_body_allowed_for_status_code",
        "pydantic.BaseModel",
        "starlette.routing",
        "starlette.concurrency.run_in_threadpool",
        "starlette.exceptions.HTTPException",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.routing.Match",
        "starlette.routing.compile_path",
        "starlette.routing.get_name",
        "starlette.routing.request_response",
        "starlette.routing.websocket_session",
        "starlette.routing.Mount",
        "starlette.types.AppType",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Scope",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "self.api_route",
          "body": "def api_route(self, path: str, *, response_model: Any=Default(None), status_code: Optional[int]=None, tags: Optional[List[Union[str, Enum]]]=None, dependencies: Optional[Sequence[Depends]]=None, summary: Optional[str]=None, description: Optional[str]=None, response_description: str='Successful Response', responses: Optional[Dict[Union[int, str], Dict[str, Any]]]=None, deprecated: Optional[bool]=None, methods: Optional[List[str]]=None, operation_id: Optional[str]=None, response_model_include: Optional[IncEx]=None, response_model_exclude: Optional[IncEx]=None, response_model_by_alias: bool=True, response_model_exclude_unset: bool=False, response_model_exclude_defaults: bool=False, response_model_exclude_none: bool=False, include_in_schema: bool=True, response_class: Type[Response]=Default(JSONResponse), name: Optional[str]=None, openapi_extra: Optional[Dict[str, Any]]=None, generate_unique_id_function: Callable[[routing.APIRoute], str]=Default(generate_unique_id)) -> Callable[[DecoratedCallable], DecoratedCallable]:\n\n    def decorator(func: DecoratedCallable) -> DecoratedCallable:\n        self.router.add_api_route(path, func, response_model=response_model, status_code=status_code, tags=tags, dependencies=dependencies, summary=summary, description=description, response_description=response_description, responses=responses, deprecated=deprecated, methods=methods, operation_id=operation_id, response_model_include=response_model_include, response_model_exclude=response_model_exclude, response_model_by_alias=response_model_by_alias, response_model_exclude_unset=response_model_exclude_unset, response_model_exclude_defaults=response_model_exclude_defaults, response_model_exclude_none=response_model_exclude_none, include_in_schema=include_in_schema, response_class=response_class, name=name, openapi_extra=openapi_extra, generate_unique_id_function=generate_unique_id_function)\n        return func\n    return decorator"
        }
      ]
    },
    {
      "name": "post",
      "module": "routing",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\routing.py",
      "line_number": 2125,
      "end_line_number": 2505,
      "source_code": "def post(\n        self,\n        path: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The URL path to be used for this *path operation*.\n\n                For example, in `http://example.com/items`, the path is `/items`.\n                \"\"\"\n            ),\n        ],\n        *,\n        response_model: Annotated[\n            Any,\n            Doc(\n                \"\"\"\n                The type to use for the response.\n\n                It could be any valid Pydantic *field* type. So, it doesn't have to\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\n                etc.\n\n                It will be used for:\n\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\n                    show it as the response (JSON Schema).\n                * Serialization: you could return an arbitrary object and the\n                    `response_model` would be used to serialize that object into the\n                    corresponding JSON.\n                * Filtering: the JSON sent to the client will only contain the data\n                    (fields) defined in the `response_model`. If you returned an object\n                    that contains an attribute `password` but the `response_model` does\n                    not include that field, the JSON sent to the client would not have\n                    that `password`.\n                * Validation: whatever you return will be serialized with the\n                    `response_model`, converting any data as necessary to generate the\n                    corresponding JSON. But if the data in the object returned is not\n                    valid, that would mean a violation of the contract with the client,\n                    so it's an error from the API developer. So, FastAPI will raise an\n                    error and return a 500 error code (Internal Server Error).\n\n                Read more about it in the\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\n                \"\"\"\n            ),\n        ] = Default(None),\n        status_code: Annotated[\n            Optional[int],\n            Doc(\n                \"\"\"\n                The default status code to be used for the response.\n\n                You could override the status code by returning a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\n                \"\"\"\n            ),\n        ] = None,\n        tags: Annotated[\n            Optional[List[Union[str, Enum]]],\n            Doc(\n                \"\"\"\n                A list of tags to be applied to the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\n                \"\"\"\n            ),\n        ] = None,\n        dependencies: Annotated[\n            Optional[Sequence[params.Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be applied to the\n                *path operation*.\n\n                Read more about it in the\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\n                \"\"\"\n            ),\n        ] = None,\n        summary: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A summary for the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A description for the *path operation*.\n\n                If not provided, it will be extracted automatically from the docstring\n                of the *path operation function*.\n\n                It can contain Markdown.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        response_description: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The description for the default response.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = \"Successful Response\",\n        responses: Annotated[\n            Optional[Dict[Union[int, str], Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                Additional responses that could be returned by this *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        deprecated: Annotated[\n            Optional[bool],\n            Doc(\n                \"\"\"\n                Mark this *path operation* as deprecated.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        operation_id: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Custom operation ID to be used by this *path operation*.\n\n                By default, it is generated automatically.\n\n                If you provide a custom operation ID, you need to make sure it is\n                unique for the whole API.\n\n                You can customize the\n                operation ID generation with the parameter\n                `generate_unique_id_function` in the `FastAPI` class.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_include: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to include only certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_exclude: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to exclude certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_by_alias: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response model\n                should be serialized by alias when an alias is used.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = True,\n        response_model_exclude_unset: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that were not set and\n                have their default values. This is different from\n                `response_model_exclude_defaults` in that if the fields are set,\n                they will be included in the response, even if the value is the same\n                as the default.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_defaults: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that have the same value\n                as the default. This is different from `response_model_exclude_unset`\n                in that if the fields are set but contain the same default values,\n                they will be excluded from the response.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_none: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data should\n                exclude fields set to `None`.\n\n                This is much simpler (less smart) than `response_model_exclude_unset`\n                and `response_model_exclude_defaults`. You probably want to use one of\n                those two instead of this one, as those allow returning `None` values\n                when it makes sense.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\n                \"\"\"\n            ),\n        ] = False,\n        include_in_schema: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Include this *path operation* in the generated OpenAPI schema.\n\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\n                \"\"\"\n            ),\n        ] = True,\n        response_class: Annotated[\n            Type[Response],\n            Doc(\n                \"\"\"\n                Response class to be used for this *path operation*.\n\n                This will not be used if you return a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\n                \"\"\"\n            ),\n        ] = Default(JSONResponse),\n        name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Name for this *path operation*. Only used internally.\n                \"\"\"\n            ),\n        ] = None,\n        callbacks: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                List of *path operations* that will be used as OpenAPI callbacks.\n\n                This is only for OpenAPI documentation, the callbacks won't be used\n                directly.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\n                \"\"\"\n            ),\n        ] = None,\n        openapi_extra: Annotated[\n            Optional[Dict[str, Any]],\n            Doc(\n                \"\"\"\n                Extra metadata to be included in the OpenAPI schema for this *path\n                operation*.\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\n                \"\"\"\n            ),\n        ] = None,\n        generate_unique_id_function: Annotated[\n            Callable[[APIRoute], str],\n            Doc(\n                \"\"\"\n                Customize the function used to generate unique IDs for the *path\n                operations* shown in the generated OpenAPI.\n\n                This is particularly useful when automatically generating clients or\n                SDKs for your API.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = Default(generate_unique_id),\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Add a *path operation* using an HTTP POST operation.\n\n        ## Example\n\n        ```python\n        from fastapi import APIRouter, FastAPI\n        from pydantic import BaseModel\n\n        class Item(BaseModel):\n            name: str\n            description: str | None = None\n\n        app = FastAPI()\n        router = APIRouter()\n\n        @router.post(\"/items/\")\n        def create_item(item: Item):\n            return {\"message\": \"Item created\"}\n\n        app.include_router(router)\n        ```\n        \"\"\"\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"POST\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n            generate_unique_id_function=generate_unique_id_function,\n        )",
      "docstring": "Add a *path operation* using an HTTP POST operation.\n\n## Example\n\n```python\nfrom fastapi import APIRouter, FastAPI\nfrom pydantic import BaseModel\n\nclass Item(BaseModel):\n    name: str\n    description: str | None = None\n\napp = FastAPI()\nrouter = APIRouter()\n\n@router.post(\"/items/\")\ndef create_item(item: Item):\n    return {\"message\": \"Item created\"}\n\napp.include_router(router)\n```",
      "decorators": [],
      "arguments": [
        "self",
        "path"
      ],
      "imports": [
        "asyncio",
        "dataclasses",
        "email.message",
        "inspect",
        "json",
        "contextlib.AsyncExitStack",
        "contextlib.asynccontextmanager",
        "enum.Enum",
        "enum.IntEnum",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.params",
        "fastapi._compat.ModelField",
        "fastapi._compat.Undefined",
        "fastapi._compat._get_model_config",
        "fastapi._compat._model_dump",
        "fastapi._compat._normalize_errors",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.utils._should_embed_body_fields",
        "fastapi.dependencies.utils.get_body_field",
        "fastapi.dependencies.utils.get_dependant",
        "fastapi.dependencies.utils.get_flat_dependant",
        "fastapi.dependencies.utils.get_parameterless_sub_dependant",
        "fastapi.dependencies.utils.get_typed_return_annotation",
        "fastapi.dependencies.utils.solve_dependencies",
        "fastapi.encoders.jsonable_encoder",
        "fastapi.exceptions.FastAPIError",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.ResponseValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.create_cloned_field",
        "fastapi.utils.create_model_field",
        "fastapi.utils.generate_unique_id",
        "fastapi.utils.get_value_or_default",
        "fastapi.utils.is_body_allowed_for_status_code",
        "pydantic.BaseModel",
        "starlette.routing",
        "starlette.concurrency.run_in_threadpool",
        "starlette.exceptions.HTTPException",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.routing.Match",
        "starlette.routing.compile_path",
        "starlette.routing.get_name",
        "starlette.routing.request_response",
        "starlette.routing.websocket_session",
        "starlette.routing.Mount",
        "starlette.types.AppType",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Scope",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "self.api_route",
          "body": "def api_route(self, path: str, *, response_model: Any=Default(None), status_code: Optional[int]=None, tags: Optional[List[Union[str, Enum]]]=None, dependencies: Optional[Sequence[Depends]]=None, summary: Optional[str]=None, description: Optional[str]=None, response_description: str='Successful Response', responses: Optional[Dict[Union[int, str], Dict[str, Any]]]=None, deprecated: Optional[bool]=None, methods: Optional[List[str]]=None, operation_id: Optional[str]=None, response_model_include: Optional[IncEx]=None, response_model_exclude: Optional[IncEx]=None, response_model_by_alias: bool=True, response_model_exclude_unset: bool=False, response_model_exclude_defaults: bool=False, response_model_exclude_none: bool=False, include_in_schema: bool=True, response_class: Type[Response]=Default(JSONResponse), name: Optional[str]=None, openapi_extra: Optional[Dict[str, Any]]=None, generate_unique_id_function: Callable[[routing.APIRoute], str]=Default(generate_unique_id)) -> Callable[[DecoratedCallable], DecoratedCallable]:\n\n    def decorator(func: DecoratedCallable) -> DecoratedCallable:\n        self.router.add_api_route(path, func, response_model=response_model, status_code=status_code, tags=tags, dependencies=dependencies, summary=summary, description=description, response_description=response_description, responses=responses, deprecated=deprecated, methods=methods, operation_id=operation_id, response_model_include=response_model_include, response_model_exclude=response_model_exclude, response_model_by_alias=response_model_by_alias, response_model_exclude_unset=response_model_exclude_unset, response_model_exclude_defaults=response_model_exclude_defaults, response_model_exclude_none=response_model_exclude_none, include_in_schema=include_in_schema, response_class=response_class, name=name, openapi_extra=openapi_extra, generate_unique_id_function=generate_unique_id_function)\n        return func\n    return decorator"
        }
      ]
    },
    {
      "name": "delete",
      "module": "routing",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\routing.py",
      "line_number": 2507,
      "end_line_number": 2882,
      "source_code": "def delete(\n        self,\n        path: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The URL path to be used for this *path operation*.\n\n                For example, in `http://example.com/items`, the path is `/items`.\n                \"\"\"\n            ),\n        ],\n        *,\n        response_model: Annotated[\n            Any,\n            Doc(\n                \"\"\"\n                The type to use for the response.\n\n                It could be any valid Pydantic *field* type. So, it doesn't have to\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\n                etc.\n\n                It will be used for:\n\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\n                    show it as the response (JSON Schema).\n                * Serialization: you could return an arbitrary object and the\n                    `response_model` would be used to serialize that object into the\n                    corresponding JSON.\n                * Filtering: the JSON sent to the client will only contain the data\n                    (fields) defined in the `response_model`. If you returned an object\n                    that contains an attribute `password` but the `response_model` does\n                    not include that field, the JSON sent to the client would not have\n                    that `password`.\n                * Validation: whatever you return will be serialized with the\n                    `response_model`, converting any data as necessary to generate the\n                    corresponding JSON. But if the data in the object returned is not\n                    valid, that would mean a violation of the contract with the client,\n                    so it's an error from the API developer. So, FastAPI will raise an\n                    error and return a 500 error code (Internal Server Error).\n\n                Read more about it in the\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\n                \"\"\"\n            ),\n        ] = Default(None),\n        status_code: Annotated[\n            Optional[int],\n            Doc(\n                \"\"\"\n                The default status code to be used for the response.\n\n                You could override the status code by returning a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\n                \"\"\"\n            ),\n        ] = None,\n        tags: Annotated[\n            Optional[List[Union[str, Enum]]],\n            Doc(\n                \"\"\"\n                A list of tags to be applied to the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\n                \"\"\"\n            ),\n        ] = None,\n        dependencies: Annotated[\n            Optional[Sequence[params.Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be applied to the\n                *path operation*.\n\n                Read more about it in the\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\n                \"\"\"\n            ),\n        ] = None,\n        summary: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A summary for the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A description for the *path operation*.\n\n                If not provided, it will be extracted automatically from the docstring\n                of the *path operation function*.\n\n                It can contain Markdown.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        response_description: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The description for the default response.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = \"Successful Response\",\n        responses: Annotated[\n            Optional[Dict[Union[int, str], Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                Additional responses that could be returned by this *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        deprecated: Annotated[\n            Optional[bool],\n            Doc(\n                \"\"\"\n                Mark this *path operation* as deprecated.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        operation_id: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Custom operation ID to be used by this *path operation*.\n\n                By default, it is generated automatically.\n\n                If you provide a custom operation ID, you need to make sure it is\n                unique for the whole API.\n\n                You can customize the\n                operation ID generation with the parameter\n                `generate_unique_id_function` in the `FastAPI` class.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_include: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to include only certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_exclude: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to exclude certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_by_alias: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response model\n                should be serialized by alias when an alias is used.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = True,\n        response_model_exclude_unset: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that were not set and\n                have their default values. This is different from\n                `response_model_exclude_defaults` in that if the fields are set,\n                they will be included in the response, even if the value is the same\n                as the default.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_defaults: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that have the same value\n                as the default. This is different from `response_model_exclude_unset`\n                in that if the fields are set but contain the same default values,\n                they will be excluded from the response.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_none: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data should\n                exclude fields set to `None`.\n\n                This is much simpler (less smart) than `response_model_exclude_unset`\n                and `response_model_exclude_defaults`. You probably want to use one of\n                those two instead of this one, as those allow returning `None` values\n                when it makes sense.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\n                \"\"\"\n            ),\n        ] = False,\n        include_in_schema: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Include this *path operation* in the generated OpenAPI schema.\n\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\n                \"\"\"\n            ),\n        ] = True,\n        response_class: Annotated[\n            Type[Response],\n            Doc(\n                \"\"\"\n                Response class to be used for this *path operation*.\n\n                This will not be used if you return a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\n                \"\"\"\n            ),\n        ] = Default(JSONResponse),\n        name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Name for this *path operation*. Only used internally.\n                \"\"\"\n            ),\n        ] = None,\n        callbacks: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                List of *path operations* that will be used as OpenAPI callbacks.\n\n                This is only for OpenAPI documentation, the callbacks won't be used\n                directly.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\n                \"\"\"\n            ),\n        ] = None,\n        openapi_extra: Annotated[\n            Optional[Dict[str, Any]],\n            Doc(\n                \"\"\"\n                Extra metadata to be included in the OpenAPI schema for this *path\n                operation*.\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\n                \"\"\"\n            ),\n        ] = None,\n        generate_unique_id_function: Annotated[\n            Callable[[APIRoute], str],\n            Doc(\n                \"\"\"\n                Customize the function used to generate unique IDs for the *path\n                operations* shown in the generated OpenAPI.\n\n                This is particularly useful when automatically generating clients or\n                SDKs for your API.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = Default(generate_unique_id),\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Add a *path operation* using an HTTP DELETE operation.\n\n        ## Example\n\n        ```python\n        from fastapi import APIRouter, FastAPI\n\n        app = FastAPI()\n        router = APIRouter()\n\n        @router.delete(\"/items/{item_id}\")\n        def delete_item(item_id: str):\n            return {\"message\": \"Item deleted\"}\n\n        app.include_router(router)\n        ```\n        \"\"\"\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"DELETE\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n            generate_unique_id_function=generate_unique_id_function,\n        )",
      "docstring": "Add a *path operation* using an HTTP DELETE operation.\n\n## Example\n\n```python\nfrom fastapi import APIRouter, FastAPI\n\napp = FastAPI()\nrouter = APIRouter()\n\n@router.delete(\"/items/{item_id}\")\ndef delete_item(item_id: str):\n    return {\"message\": \"Item deleted\"}\n\napp.include_router(router)\n```",
      "decorators": [],
      "arguments": [
        "self",
        "path"
      ],
      "imports": [
        "asyncio",
        "dataclasses",
        "email.message",
        "inspect",
        "json",
        "contextlib.AsyncExitStack",
        "contextlib.asynccontextmanager",
        "enum.Enum",
        "enum.IntEnum",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.params",
        "fastapi._compat.ModelField",
        "fastapi._compat.Undefined",
        "fastapi._compat._get_model_config",
        "fastapi._compat._model_dump",
        "fastapi._compat._normalize_errors",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.utils._should_embed_body_fields",
        "fastapi.dependencies.utils.get_body_field",
        "fastapi.dependencies.utils.get_dependant",
        "fastapi.dependencies.utils.get_flat_dependant",
        "fastapi.dependencies.utils.get_parameterless_sub_dependant",
        "fastapi.dependencies.utils.get_typed_return_annotation",
        "fastapi.dependencies.utils.solve_dependencies",
        "fastapi.encoders.jsonable_encoder",
        "fastapi.exceptions.FastAPIError",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.ResponseValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.create_cloned_field",
        "fastapi.utils.create_model_field",
        "fastapi.utils.generate_unique_id",
        "fastapi.utils.get_value_or_default",
        "fastapi.utils.is_body_allowed_for_status_code",
        "pydantic.BaseModel",
        "starlette.routing",
        "starlette.concurrency.run_in_threadpool",
        "starlette.exceptions.HTTPException",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.routing.Match",
        "starlette.routing.compile_path",
        "starlette.routing.get_name",
        "starlette.routing.request_response",
        "starlette.routing.websocket_session",
        "starlette.routing.Mount",
        "starlette.types.AppType",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Scope",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "self.api_route",
          "body": "def api_route(self, path: str, *, response_model: Any=Default(None), status_code: Optional[int]=None, tags: Optional[List[Union[str, Enum]]]=None, dependencies: Optional[Sequence[Depends]]=None, summary: Optional[str]=None, description: Optional[str]=None, response_description: str='Successful Response', responses: Optional[Dict[Union[int, str], Dict[str, Any]]]=None, deprecated: Optional[bool]=None, methods: Optional[List[str]]=None, operation_id: Optional[str]=None, response_model_include: Optional[IncEx]=None, response_model_exclude: Optional[IncEx]=None, response_model_by_alias: bool=True, response_model_exclude_unset: bool=False, response_model_exclude_defaults: bool=False, response_model_exclude_none: bool=False, include_in_schema: bool=True, response_class: Type[Response]=Default(JSONResponse), name: Optional[str]=None, openapi_extra: Optional[Dict[str, Any]]=None, generate_unique_id_function: Callable[[routing.APIRoute], str]=Default(generate_unique_id)) -> Callable[[DecoratedCallable], DecoratedCallable]:\n\n    def decorator(func: DecoratedCallable) -> DecoratedCallable:\n        self.router.add_api_route(path, func, response_model=response_model, status_code=status_code, tags=tags, dependencies=dependencies, summary=summary, description=description, response_description=response_description, responses=responses, deprecated=deprecated, methods=methods, operation_id=operation_id, response_model_include=response_model_include, response_model_exclude=response_model_exclude, response_model_by_alias=response_model_by_alias, response_model_exclude_unset=response_model_exclude_unset, response_model_exclude_defaults=response_model_exclude_defaults, response_model_exclude_none=response_model_exclude_none, include_in_schema=include_in_schema, response_class=response_class, name=name, openapi_extra=openapi_extra, generate_unique_id_function=generate_unique_id_function)\n        return func\n    return decorator"
        }
      ]
    },
    {
      "name": "options",
      "module": "routing",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\routing.py",
      "line_number": 2884,
      "end_line_number": 3259,
      "source_code": "def options(\n        self,\n        path: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The URL path to be used for this *path operation*.\n\n                For example, in `http://example.com/items`, the path is `/items`.\n                \"\"\"\n            ),\n        ],\n        *,\n        response_model: Annotated[\n            Any,\n            Doc(\n                \"\"\"\n                The type to use for the response.\n\n                It could be any valid Pydantic *field* type. So, it doesn't have to\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\n                etc.\n\n                It will be used for:\n\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\n                    show it as the response (JSON Schema).\n                * Serialization: you could return an arbitrary object and the\n                    `response_model` would be used to serialize that object into the\n                    corresponding JSON.\n                * Filtering: the JSON sent to the client will only contain the data\n                    (fields) defined in the `response_model`. If you returned an object\n                    that contains an attribute `password` but the `response_model` does\n                    not include that field, the JSON sent to the client would not have\n                    that `password`.\n                * Validation: whatever you return will be serialized with the\n                    `response_model`, converting any data as necessary to generate the\n                    corresponding JSON. But if the data in the object returned is not\n                    valid, that would mean a violation of the contract with the client,\n                    so it's an error from the API developer. So, FastAPI will raise an\n                    error and return a 500 error code (Internal Server Error).\n\n                Read more about it in the\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\n                \"\"\"\n            ),\n        ] = Default(None),\n        status_code: Annotated[\n            Optional[int],\n            Doc(\n                \"\"\"\n                The default status code to be used for the response.\n\n                You could override the status code by returning a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\n                \"\"\"\n            ),\n        ] = None,\n        tags: Annotated[\n            Optional[List[Union[str, Enum]]],\n            Doc(\n                \"\"\"\n                A list of tags to be applied to the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\n                \"\"\"\n            ),\n        ] = None,\n        dependencies: Annotated[\n            Optional[Sequence[params.Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be applied to the\n                *path operation*.\n\n                Read more about it in the\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\n                \"\"\"\n            ),\n        ] = None,\n        summary: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A summary for the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A description for the *path operation*.\n\n                If not provided, it will be extracted automatically from the docstring\n                of the *path operation function*.\n\n                It can contain Markdown.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        response_description: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The description for the default response.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = \"Successful Response\",\n        responses: Annotated[\n            Optional[Dict[Union[int, str], Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                Additional responses that could be returned by this *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        deprecated: Annotated[\n            Optional[bool],\n            Doc(\n                \"\"\"\n                Mark this *path operation* as deprecated.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        operation_id: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Custom operation ID to be used by this *path operation*.\n\n                By default, it is generated automatically.\n\n                If you provide a custom operation ID, you need to make sure it is\n                unique for the whole API.\n\n                You can customize the\n                operation ID generation with the parameter\n                `generate_unique_id_function` in the `FastAPI` class.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_include: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to include only certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_exclude: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to exclude certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_by_alias: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response model\n                should be serialized by alias when an alias is used.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = True,\n        response_model_exclude_unset: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that were not set and\n                have their default values. This is different from\n                `response_model_exclude_defaults` in that if the fields are set,\n                they will be included in the response, even if the value is the same\n                as the default.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_defaults: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that have the same value\n                as the default. This is different from `response_model_exclude_unset`\n                in that if the fields are set but contain the same default values,\n                they will be excluded from the response.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_none: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data should\n                exclude fields set to `None`.\n\n                This is much simpler (less smart) than `response_model_exclude_unset`\n                and `response_model_exclude_defaults`. You probably want to use one of\n                those two instead of this one, as those allow returning `None` values\n                when it makes sense.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\n                \"\"\"\n            ),\n        ] = False,\n        include_in_schema: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Include this *path operation* in the generated OpenAPI schema.\n\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\n                \"\"\"\n            ),\n        ] = True,\n        response_class: Annotated[\n            Type[Response],\n            Doc(\n                \"\"\"\n                Response class to be used for this *path operation*.\n\n                This will not be used if you return a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\n                \"\"\"\n            ),\n        ] = Default(JSONResponse),\n        name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Name for this *path operation*. Only used internally.\n                \"\"\"\n            ),\n        ] = None,\n        callbacks: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                List of *path operations* that will be used as OpenAPI callbacks.\n\n                This is only for OpenAPI documentation, the callbacks won't be used\n                directly.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\n                \"\"\"\n            ),\n        ] = None,\n        openapi_extra: Annotated[\n            Optional[Dict[str, Any]],\n            Doc(\n                \"\"\"\n                Extra metadata to be included in the OpenAPI schema for this *path\n                operation*.\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\n                \"\"\"\n            ),\n        ] = None,\n        generate_unique_id_function: Annotated[\n            Callable[[APIRoute], str],\n            Doc(\n                \"\"\"\n                Customize the function used to generate unique IDs for the *path\n                operations* shown in the generated OpenAPI.\n\n                This is particularly useful when automatically generating clients or\n                SDKs for your API.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = Default(generate_unique_id),\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Add a *path operation* using an HTTP OPTIONS operation.\n\n        ## Example\n\n        ```python\n        from fastapi import APIRouter, FastAPI\n\n        app = FastAPI()\n        router = APIRouter()\n\n        @router.options(\"/items/\")\n        def get_item_options():\n            return {\"additions\": [\"Aji\", \"Guacamole\"]}\n\n        app.include_router(router)\n        ```\n        \"\"\"\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"OPTIONS\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n            generate_unique_id_function=generate_unique_id_function,\n        )",
      "docstring": "Add a *path operation* using an HTTP OPTIONS operation.\n\n## Example\n\n```python\nfrom fastapi import APIRouter, FastAPI\n\napp = FastAPI()\nrouter = APIRouter()\n\n@router.options(\"/items/\")\ndef get_item_options():\n    return {\"additions\": [\"Aji\", \"Guacamole\"]}\n\napp.include_router(router)\n```",
      "decorators": [],
      "arguments": [
        "self",
        "path"
      ],
      "imports": [
        "asyncio",
        "dataclasses",
        "email.message",
        "inspect",
        "json",
        "contextlib.AsyncExitStack",
        "contextlib.asynccontextmanager",
        "enum.Enum",
        "enum.IntEnum",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.params",
        "fastapi._compat.ModelField",
        "fastapi._compat.Undefined",
        "fastapi._compat._get_model_config",
        "fastapi._compat._model_dump",
        "fastapi._compat._normalize_errors",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.utils._should_embed_body_fields",
        "fastapi.dependencies.utils.get_body_field",
        "fastapi.dependencies.utils.get_dependant",
        "fastapi.dependencies.utils.get_flat_dependant",
        "fastapi.dependencies.utils.get_parameterless_sub_dependant",
        "fastapi.dependencies.utils.get_typed_return_annotation",
        "fastapi.dependencies.utils.solve_dependencies",
        "fastapi.encoders.jsonable_encoder",
        "fastapi.exceptions.FastAPIError",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.ResponseValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.create_cloned_field",
        "fastapi.utils.create_model_field",
        "fastapi.utils.generate_unique_id",
        "fastapi.utils.get_value_or_default",
        "fastapi.utils.is_body_allowed_for_status_code",
        "pydantic.BaseModel",
        "starlette.routing",
        "starlette.concurrency.run_in_threadpool",
        "starlette.exceptions.HTTPException",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.routing.Match",
        "starlette.routing.compile_path",
        "starlette.routing.get_name",
        "starlette.routing.request_response",
        "starlette.routing.websocket_session",
        "starlette.routing.Mount",
        "starlette.types.AppType",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Scope",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "self.api_route",
          "body": "def api_route(self, path: str, *, response_model: Any=Default(None), status_code: Optional[int]=None, tags: Optional[List[Union[str, Enum]]]=None, dependencies: Optional[Sequence[Depends]]=None, summary: Optional[str]=None, description: Optional[str]=None, response_description: str='Successful Response', responses: Optional[Dict[Union[int, str], Dict[str, Any]]]=None, deprecated: Optional[bool]=None, methods: Optional[List[str]]=None, operation_id: Optional[str]=None, response_model_include: Optional[IncEx]=None, response_model_exclude: Optional[IncEx]=None, response_model_by_alias: bool=True, response_model_exclude_unset: bool=False, response_model_exclude_defaults: bool=False, response_model_exclude_none: bool=False, include_in_schema: bool=True, response_class: Type[Response]=Default(JSONResponse), name: Optional[str]=None, openapi_extra: Optional[Dict[str, Any]]=None, generate_unique_id_function: Callable[[routing.APIRoute], str]=Default(generate_unique_id)) -> Callable[[DecoratedCallable], DecoratedCallable]:\n\n    def decorator(func: DecoratedCallable) -> DecoratedCallable:\n        self.router.add_api_route(path, func, response_model=response_model, status_code=status_code, tags=tags, dependencies=dependencies, summary=summary, description=description, response_description=response_description, responses=responses, deprecated=deprecated, methods=methods, operation_id=operation_id, response_model_include=response_model_include, response_model_exclude=response_model_exclude, response_model_by_alias=response_model_by_alias, response_model_exclude_unset=response_model_exclude_unset, response_model_exclude_defaults=response_model_exclude_defaults, response_model_exclude_none=response_model_exclude_none, include_in_schema=include_in_schema, response_class=response_class, name=name, openapi_extra=openapi_extra, generate_unique_id_function=generate_unique_id_function)\n        return func\n    return decorator"
        }
      ]
    },
    {
      "name": "head",
      "module": "routing",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\routing.py",
      "line_number": 3261,
      "end_line_number": 3641,
      "source_code": "def head(\n        self,\n        path: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The URL path to be used for this *path operation*.\n\n                For example, in `http://example.com/items`, the path is `/items`.\n                \"\"\"\n            ),\n        ],\n        *,\n        response_model: Annotated[\n            Any,\n            Doc(\n                \"\"\"\n                The type to use for the response.\n\n                It could be any valid Pydantic *field* type. So, it doesn't have to\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\n                etc.\n\n                It will be used for:\n\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\n                    show it as the response (JSON Schema).\n                * Serialization: you could return an arbitrary object and the\n                    `response_model` would be used to serialize that object into the\n                    corresponding JSON.\n                * Filtering: the JSON sent to the client will only contain the data\n                    (fields) defined in the `response_model`. If you returned an object\n                    that contains an attribute `password` but the `response_model` does\n                    not include that field, the JSON sent to the client would not have\n                    that `password`.\n                * Validation: whatever you return will be serialized with the\n                    `response_model`, converting any data as necessary to generate the\n                    corresponding JSON. But if the data in the object returned is not\n                    valid, that would mean a violation of the contract with the client,\n                    so it's an error from the API developer. So, FastAPI will raise an\n                    error and return a 500 error code (Internal Server Error).\n\n                Read more about it in the\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\n                \"\"\"\n            ),\n        ] = Default(None),\n        status_code: Annotated[\n            Optional[int],\n            Doc(\n                \"\"\"\n                The default status code to be used for the response.\n\n                You could override the status code by returning a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\n                \"\"\"\n            ),\n        ] = None,\n        tags: Annotated[\n            Optional[List[Union[str, Enum]]],\n            Doc(\n                \"\"\"\n                A list of tags to be applied to the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\n                \"\"\"\n            ),\n        ] = None,\n        dependencies: Annotated[\n            Optional[Sequence[params.Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be applied to the\n                *path operation*.\n\n                Read more about it in the\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\n                \"\"\"\n            ),\n        ] = None,\n        summary: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A summary for the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A description for the *path operation*.\n\n                If not provided, it will be extracted automatically from the docstring\n                of the *path operation function*.\n\n                It can contain Markdown.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        response_description: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The description for the default response.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = \"Successful Response\",\n        responses: Annotated[\n            Optional[Dict[Union[int, str], Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                Additional responses that could be returned by this *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        deprecated: Annotated[\n            Optional[bool],\n            Doc(\n                \"\"\"\n                Mark this *path operation* as deprecated.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        operation_id: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Custom operation ID to be used by this *path operation*.\n\n                By default, it is generated automatically.\n\n                If you provide a custom operation ID, you need to make sure it is\n                unique for the whole API.\n\n                You can customize the\n                operation ID generation with the parameter\n                `generate_unique_id_function` in the `FastAPI` class.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_include: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to include only certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_exclude: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to exclude certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_by_alias: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response model\n                should be serialized by alias when an alias is used.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = True,\n        response_model_exclude_unset: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that were not set and\n                have their default values. This is different from\n                `response_model_exclude_defaults` in that if the fields are set,\n                they will be included in the response, even if the value is the same\n                as the default.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_defaults: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that have the same value\n                as the default. This is different from `response_model_exclude_unset`\n                in that if the fields are set but contain the same default values,\n                they will be excluded from the response.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_none: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data should\n                exclude fields set to `None`.\n\n                This is much simpler (less smart) than `response_model_exclude_unset`\n                and `response_model_exclude_defaults`. You probably want to use one of\n                those two instead of this one, as those allow returning `None` values\n                when it makes sense.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\n                \"\"\"\n            ),\n        ] = False,\n        include_in_schema: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Include this *path operation* in the generated OpenAPI schema.\n\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\n                \"\"\"\n            ),\n        ] = True,\n        response_class: Annotated[\n            Type[Response],\n            Doc(\n                \"\"\"\n                Response class to be used for this *path operation*.\n\n                This will not be used if you return a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\n                \"\"\"\n            ),\n        ] = Default(JSONResponse),\n        name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Name for this *path operation*. Only used internally.\n                \"\"\"\n            ),\n        ] = None,\n        callbacks: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                List of *path operations* that will be used as OpenAPI callbacks.\n\n                This is only for OpenAPI documentation, the callbacks won't be used\n                directly.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\n                \"\"\"\n            ),\n        ] = None,\n        openapi_extra: Annotated[\n            Optional[Dict[str, Any]],\n            Doc(\n                \"\"\"\n                Extra metadata to be included in the OpenAPI schema for this *path\n                operation*.\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\n                \"\"\"\n            ),\n        ] = None,\n        generate_unique_id_function: Annotated[\n            Callable[[APIRoute], str],\n            Doc(\n                \"\"\"\n                Customize the function used to generate unique IDs for the *path\n                operations* shown in the generated OpenAPI.\n\n                This is particularly useful when automatically generating clients or\n                SDKs for your API.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = Default(generate_unique_id),\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Add a *path operation* using an HTTP HEAD operation.\n\n        ## Example\n\n        ```python\n        from fastapi import APIRouter, FastAPI\n        from pydantic import BaseModel\n\n        class Item(BaseModel):\n            name: str\n            description: str | None = None\n\n        app = FastAPI()\n        router = APIRouter()\n\n        @router.head(\"/items/\", status_code=204)\n        def get_items_headers(response: Response):\n            response.headers[\"X-Cat-Dog\"] = \"Alone in the world\"\n\n        app.include_router(router)\n        ```\n        \"\"\"\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"HEAD\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n            generate_unique_id_function=generate_unique_id_function,\n        )",
      "docstring": "Add a *path operation* using an HTTP HEAD operation.\n\n## Example\n\n```python\nfrom fastapi import APIRouter, FastAPI\nfrom pydantic import BaseModel\n\nclass Item(BaseModel):\n    name: str\n    description: str | None = None\n\napp = FastAPI()\nrouter = APIRouter()\n\n@router.head(\"/items/\", status_code=204)\ndef get_items_headers(response: Response):\n    response.headers[\"X-Cat-Dog\"] = \"Alone in the world\"\n\napp.include_router(router)\n```",
      "decorators": [],
      "arguments": [
        "self",
        "path"
      ],
      "imports": [
        "asyncio",
        "dataclasses",
        "email.message",
        "inspect",
        "json",
        "contextlib.AsyncExitStack",
        "contextlib.asynccontextmanager",
        "enum.Enum",
        "enum.IntEnum",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.params",
        "fastapi._compat.ModelField",
        "fastapi._compat.Undefined",
        "fastapi._compat._get_model_config",
        "fastapi._compat._model_dump",
        "fastapi._compat._normalize_errors",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.utils._should_embed_body_fields",
        "fastapi.dependencies.utils.get_body_field",
        "fastapi.dependencies.utils.get_dependant",
        "fastapi.dependencies.utils.get_flat_dependant",
        "fastapi.dependencies.utils.get_parameterless_sub_dependant",
        "fastapi.dependencies.utils.get_typed_return_annotation",
        "fastapi.dependencies.utils.solve_dependencies",
        "fastapi.encoders.jsonable_encoder",
        "fastapi.exceptions.FastAPIError",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.ResponseValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.create_cloned_field",
        "fastapi.utils.create_model_field",
        "fastapi.utils.generate_unique_id",
        "fastapi.utils.get_value_or_default",
        "fastapi.utils.is_body_allowed_for_status_code",
        "pydantic.BaseModel",
        "starlette.routing",
        "starlette.concurrency.run_in_threadpool",
        "starlette.exceptions.HTTPException",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.routing.Match",
        "starlette.routing.compile_path",
        "starlette.routing.get_name",
        "starlette.routing.request_response",
        "starlette.routing.websocket_session",
        "starlette.routing.Mount",
        "starlette.types.AppType",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Scope",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "self.api_route",
          "body": "def api_route(self, path: str, *, response_model: Any=Default(None), status_code: Optional[int]=None, tags: Optional[List[Union[str, Enum]]]=None, dependencies: Optional[Sequence[Depends]]=None, summary: Optional[str]=None, description: Optional[str]=None, response_description: str='Successful Response', responses: Optional[Dict[Union[int, str], Dict[str, Any]]]=None, deprecated: Optional[bool]=None, methods: Optional[List[str]]=None, operation_id: Optional[str]=None, response_model_include: Optional[IncEx]=None, response_model_exclude: Optional[IncEx]=None, response_model_by_alias: bool=True, response_model_exclude_unset: bool=False, response_model_exclude_defaults: bool=False, response_model_exclude_none: bool=False, include_in_schema: bool=True, response_class: Type[Response]=Default(JSONResponse), name: Optional[str]=None, openapi_extra: Optional[Dict[str, Any]]=None, generate_unique_id_function: Callable[[routing.APIRoute], str]=Default(generate_unique_id)) -> Callable[[DecoratedCallable], DecoratedCallable]:\n\n    def decorator(func: DecoratedCallable) -> DecoratedCallable:\n        self.router.add_api_route(path, func, response_model=response_model, status_code=status_code, tags=tags, dependencies=dependencies, summary=summary, description=description, response_description=response_description, responses=responses, deprecated=deprecated, methods=methods, operation_id=operation_id, response_model_include=response_model_include, response_model_exclude=response_model_exclude, response_model_by_alias=response_model_by_alias, response_model_exclude_unset=response_model_exclude_unset, response_model_exclude_defaults=response_model_exclude_defaults, response_model_exclude_none=response_model_exclude_none, include_in_schema=include_in_schema, response_class=response_class, name=name, openapi_extra=openapi_extra, generate_unique_id_function=generate_unique_id_function)\n        return func\n    return decorator"
        }
      ]
    },
    {
      "name": "patch",
      "module": "routing",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\routing.py",
      "line_number": 3643,
      "end_line_number": 4023,
      "source_code": "def patch(\n        self,\n        path: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The URL path to be used for this *path operation*.\n\n                For example, in `http://example.com/items`, the path is `/items`.\n                \"\"\"\n            ),\n        ],\n        *,\n        response_model: Annotated[\n            Any,\n            Doc(\n                \"\"\"\n                The type to use for the response.\n\n                It could be any valid Pydantic *field* type. So, it doesn't have to\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\n                etc.\n\n                It will be used for:\n\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\n                    show it as the response (JSON Schema).\n                * Serialization: you could return an arbitrary object and the\n                    `response_model` would be used to serialize that object into the\n                    corresponding JSON.\n                * Filtering: the JSON sent to the client will only contain the data\n                    (fields) defined in the `response_model`. If you returned an object\n                    that contains an attribute `password` but the `response_model` does\n                    not include that field, the JSON sent to the client would not have\n                    that `password`.\n                * Validation: whatever you return will be serialized with the\n                    `response_model`, converting any data as necessary to generate the\n                    corresponding JSON. But if the data in the object returned is not\n                    valid, that would mean a violation of the contract with the client,\n                    so it's an error from the API developer. So, FastAPI will raise an\n                    error and return a 500 error code (Internal Server Error).\n\n                Read more about it in the\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\n                \"\"\"\n            ),\n        ] = Default(None),\n        status_code: Annotated[\n            Optional[int],\n            Doc(\n                \"\"\"\n                The default status code to be used for the response.\n\n                You could override the status code by returning a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\n                \"\"\"\n            ),\n        ] = None,\n        tags: Annotated[\n            Optional[List[Union[str, Enum]]],\n            Doc(\n                \"\"\"\n                A list of tags to be applied to the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\n                \"\"\"\n            ),\n        ] = None,\n        dependencies: Annotated[\n            Optional[Sequence[params.Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be applied to the\n                *path operation*.\n\n                Read more about it in the\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\n                \"\"\"\n            ),\n        ] = None,\n        summary: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A summary for the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A description for the *path operation*.\n\n                If not provided, it will be extracted automatically from the docstring\n                of the *path operation function*.\n\n                It can contain Markdown.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        response_description: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The description for the default response.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = \"Successful Response\",\n        responses: Annotated[\n            Optional[Dict[Union[int, str], Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                Additional responses that could be returned by this *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        deprecated: Annotated[\n            Optional[bool],\n            Doc(\n                \"\"\"\n                Mark this *path operation* as deprecated.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        operation_id: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Custom operation ID to be used by this *path operation*.\n\n                By default, it is generated automatically.\n\n                If you provide a custom operation ID, you need to make sure it is\n                unique for the whole API.\n\n                You can customize the\n                operation ID generation with the parameter\n                `generate_unique_id_function` in the `FastAPI` class.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_include: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to include only certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_exclude: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to exclude certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_by_alias: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response model\n                should be serialized by alias when an alias is used.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = True,\n        response_model_exclude_unset: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that were not set and\n                have their default values. This is different from\n                `response_model_exclude_defaults` in that if the fields are set,\n                they will be included in the response, even if the value is the same\n                as the default.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_defaults: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that have the same value\n                as the default. This is different from `response_model_exclude_unset`\n                in that if the fields are set but contain the same default values,\n                they will be excluded from the response.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_none: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data should\n                exclude fields set to `None`.\n\n                This is much simpler (less smart) than `response_model_exclude_unset`\n                and `response_model_exclude_defaults`. You probably want to use one of\n                those two instead of this one, as those allow returning `None` values\n                when it makes sense.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\n                \"\"\"\n            ),\n        ] = False,\n        include_in_schema: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Include this *path operation* in the generated OpenAPI schema.\n\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\n                \"\"\"\n            ),\n        ] = True,\n        response_class: Annotated[\n            Type[Response],\n            Doc(\n                \"\"\"\n                Response class to be used for this *path operation*.\n\n                This will not be used if you return a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\n                \"\"\"\n            ),\n        ] = Default(JSONResponse),\n        name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Name for this *path operation*. Only used internally.\n                \"\"\"\n            ),\n        ] = None,\n        callbacks: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                List of *path operations* that will be used as OpenAPI callbacks.\n\n                This is only for OpenAPI documentation, the callbacks won't be used\n                directly.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\n                \"\"\"\n            ),\n        ] = None,\n        openapi_extra: Annotated[\n            Optional[Dict[str, Any]],\n            Doc(\n                \"\"\"\n                Extra metadata to be included in the OpenAPI schema for this *path\n                operation*.\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\n                \"\"\"\n            ),\n        ] = None,\n        generate_unique_id_function: Annotated[\n            Callable[[APIRoute], str],\n            Doc(\n                \"\"\"\n                Customize the function used to generate unique IDs for the *path\n                operations* shown in the generated OpenAPI.\n\n                This is particularly useful when automatically generating clients or\n                SDKs for your API.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = Default(generate_unique_id),\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Add a *path operation* using an HTTP PATCH operation.\n\n        ## Example\n\n        ```python\n        from fastapi import APIRouter, FastAPI\n        from pydantic import BaseModel\n\n        class Item(BaseModel):\n            name: str\n            description: str | None = None\n\n        app = FastAPI()\n        router = APIRouter()\n\n        @router.patch(\"/items/\")\n        def update_item(item: Item):\n            return {\"message\": \"Item updated in place\"}\n\n        app.include_router(router)\n        ```\n        \"\"\"\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"PATCH\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n            generate_unique_id_function=generate_unique_id_function,\n        )",
      "docstring": "Add a *path operation* using an HTTP PATCH operation.\n\n## Example\n\n```python\nfrom fastapi import APIRouter, FastAPI\nfrom pydantic import BaseModel\n\nclass Item(BaseModel):\n    name: str\n    description: str | None = None\n\napp = FastAPI()\nrouter = APIRouter()\n\n@router.patch(\"/items/\")\ndef update_item(item: Item):\n    return {\"message\": \"Item updated in place\"}\n\napp.include_router(router)\n```",
      "decorators": [],
      "arguments": [
        "self",
        "path"
      ],
      "imports": [
        "asyncio",
        "dataclasses",
        "email.message",
        "inspect",
        "json",
        "contextlib.AsyncExitStack",
        "contextlib.asynccontextmanager",
        "enum.Enum",
        "enum.IntEnum",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.params",
        "fastapi._compat.ModelField",
        "fastapi._compat.Undefined",
        "fastapi._compat._get_model_config",
        "fastapi._compat._model_dump",
        "fastapi._compat._normalize_errors",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.utils._should_embed_body_fields",
        "fastapi.dependencies.utils.get_body_field",
        "fastapi.dependencies.utils.get_dependant",
        "fastapi.dependencies.utils.get_flat_dependant",
        "fastapi.dependencies.utils.get_parameterless_sub_dependant",
        "fastapi.dependencies.utils.get_typed_return_annotation",
        "fastapi.dependencies.utils.solve_dependencies",
        "fastapi.encoders.jsonable_encoder",
        "fastapi.exceptions.FastAPIError",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.ResponseValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.create_cloned_field",
        "fastapi.utils.create_model_field",
        "fastapi.utils.generate_unique_id",
        "fastapi.utils.get_value_or_default",
        "fastapi.utils.is_body_allowed_for_status_code",
        "pydantic.BaseModel",
        "starlette.routing",
        "starlette.concurrency.run_in_threadpool",
        "starlette.exceptions.HTTPException",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.routing.Match",
        "starlette.routing.compile_path",
        "starlette.routing.get_name",
        "starlette.routing.request_response",
        "starlette.routing.websocket_session",
        "starlette.routing.Mount",
        "starlette.types.AppType",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Scope",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "self.api_route",
          "body": "def api_route(self, path: str, *, response_model: Any=Default(None), status_code: Optional[int]=None, tags: Optional[List[Union[str, Enum]]]=None, dependencies: Optional[Sequence[Depends]]=None, summary: Optional[str]=None, description: Optional[str]=None, response_description: str='Successful Response', responses: Optional[Dict[Union[int, str], Dict[str, Any]]]=None, deprecated: Optional[bool]=None, methods: Optional[List[str]]=None, operation_id: Optional[str]=None, response_model_include: Optional[IncEx]=None, response_model_exclude: Optional[IncEx]=None, response_model_by_alias: bool=True, response_model_exclude_unset: bool=False, response_model_exclude_defaults: bool=False, response_model_exclude_none: bool=False, include_in_schema: bool=True, response_class: Type[Response]=Default(JSONResponse), name: Optional[str]=None, openapi_extra: Optional[Dict[str, Any]]=None, generate_unique_id_function: Callable[[routing.APIRoute], str]=Default(generate_unique_id)) -> Callable[[DecoratedCallable], DecoratedCallable]:\n\n    def decorator(func: DecoratedCallable) -> DecoratedCallable:\n        self.router.add_api_route(path, func, response_model=response_model, status_code=status_code, tags=tags, dependencies=dependencies, summary=summary, description=description, response_description=response_description, responses=responses, deprecated=deprecated, methods=methods, operation_id=operation_id, response_model_include=response_model_include, response_model_exclude=response_model_exclude, response_model_by_alias=response_model_by_alias, response_model_exclude_unset=response_model_exclude_unset, response_model_exclude_defaults=response_model_exclude_defaults, response_model_exclude_none=response_model_exclude_none, include_in_schema=include_in_schema, response_class=response_class, name=name, openapi_extra=openapi_extra, generate_unique_id_function=generate_unique_id_function)\n        return func\n    return decorator"
        }
      ]
    },
    {
      "name": "trace",
      "module": "routing",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\routing.py",
      "line_number": 4025,
      "end_line_number": 4405,
      "source_code": "def trace(\n        self,\n        path: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The URL path to be used for this *path operation*.\n\n                For example, in `http://example.com/items`, the path is `/items`.\n                \"\"\"\n            ),\n        ],\n        *,\n        response_model: Annotated[\n            Any,\n            Doc(\n                \"\"\"\n                The type to use for the response.\n\n                It could be any valid Pydantic *field* type. So, it doesn't have to\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\n                etc.\n\n                It will be used for:\n\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\n                    show it as the response (JSON Schema).\n                * Serialization: you could return an arbitrary object and the\n                    `response_model` would be used to serialize that object into the\n                    corresponding JSON.\n                * Filtering: the JSON sent to the client will only contain the data\n                    (fields) defined in the `response_model`. If you returned an object\n                    that contains an attribute `password` but the `response_model` does\n                    not include that field, the JSON sent to the client would not have\n                    that `password`.\n                * Validation: whatever you return will be serialized with the\n                    `response_model`, converting any data as necessary to generate the\n                    corresponding JSON. But if the data in the object returned is not\n                    valid, that would mean a violation of the contract with the client,\n                    so it's an error from the API developer. So, FastAPI will raise an\n                    error and return a 500 error code (Internal Server Error).\n\n                Read more about it in the\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\n                \"\"\"\n            ),\n        ] = Default(None),\n        status_code: Annotated[\n            Optional[int],\n            Doc(\n                \"\"\"\n                The default status code to be used for the response.\n\n                You could override the status code by returning a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\n                \"\"\"\n            ),\n        ] = None,\n        tags: Annotated[\n            Optional[List[Union[str, Enum]]],\n            Doc(\n                \"\"\"\n                A list of tags to be applied to the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\n                \"\"\"\n            ),\n        ] = None,\n        dependencies: Annotated[\n            Optional[Sequence[params.Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be applied to the\n                *path operation*.\n\n                Read more about it in the\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\n                \"\"\"\n            ),\n        ] = None,\n        summary: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A summary for the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A description for the *path operation*.\n\n                If not provided, it will be extracted automatically from the docstring\n                of the *path operation function*.\n\n                It can contain Markdown.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        response_description: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The description for the default response.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = \"Successful Response\",\n        responses: Annotated[\n            Optional[Dict[Union[int, str], Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                Additional responses that could be returned by this *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        deprecated: Annotated[\n            Optional[bool],\n            Doc(\n                \"\"\"\n                Mark this *path operation* as deprecated.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        operation_id: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Custom operation ID to be used by this *path operation*.\n\n                By default, it is generated automatically.\n\n                If you provide a custom operation ID, you need to make sure it is\n                unique for the whole API.\n\n                You can customize the\n                operation ID generation with the parameter\n                `generate_unique_id_function` in the `FastAPI` class.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_include: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to include only certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_exclude: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to exclude certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_by_alias: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response model\n                should be serialized by alias when an alias is used.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = True,\n        response_model_exclude_unset: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that were not set and\n                have their default values. This is different from\n                `response_model_exclude_defaults` in that if the fields are set,\n                they will be included in the response, even if the value is the same\n                as the default.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_defaults: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that have the same value\n                as the default. This is different from `response_model_exclude_unset`\n                in that if the fields are set but contain the same default values,\n                they will be excluded from the response.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_none: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data should\n                exclude fields set to `None`.\n\n                This is much simpler (less smart) than `response_model_exclude_unset`\n                and `response_model_exclude_defaults`. You probably want to use one of\n                those two instead of this one, as those allow returning `None` values\n                when it makes sense.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\n                \"\"\"\n            ),\n        ] = False,\n        include_in_schema: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Include this *path operation* in the generated OpenAPI schema.\n\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\n                \"\"\"\n            ),\n        ] = True,\n        response_class: Annotated[\n            Type[Response],\n            Doc(\n                \"\"\"\n                Response class to be used for this *path operation*.\n\n                This will not be used if you return a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\n                \"\"\"\n            ),\n        ] = Default(JSONResponse),\n        name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Name for this *path operation*. Only used internally.\n                \"\"\"\n            ),\n        ] = None,\n        callbacks: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                List of *path operations* that will be used as OpenAPI callbacks.\n\n                This is only for OpenAPI documentation, the callbacks won't be used\n                directly.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\n                \"\"\"\n            ),\n        ] = None,\n        openapi_extra: Annotated[\n            Optional[Dict[str, Any]],\n            Doc(\n                \"\"\"\n                Extra metadata to be included in the OpenAPI schema for this *path\n                operation*.\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\n                \"\"\"\n            ),\n        ] = None,\n        generate_unique_id_function: Annotated[\n            Callable[[APIRoute], str],\n            Doc(\n                \"\"\"\n                Customize the function used to generate unique IDs for the *path\n                operations* shown in the generated OpenAPI.\n\n                This is particularly useful when automatically generating clients or\n                SDKs for your API.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = Default(generate_unique_id),\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Add a *path operation* using an HTTP TRACE operation.\n\n        ## Example\n\n        ```python\n        from fastapi import APIRouter, FastAPI\n        from pydantic import BaseModel\n\n        class Item(BaseModel):\n            name: str\n            description: str | None = None\n\n        app = FastAPI()\n        router = APIRouter()\n\n        @router.trace(\"/items/{item_id}\")\n        def trace_item(item_id: str):\n            return None\n\n        app.include_router(router)\n        ```\n        \"\"\"\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"TRACE\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n            generate_unique_id_function=generate_unique_id_function,\n        )",
      "docstring": "Add a *path operation* using an HTTP TRACE operation.\n\n## Example\n\n```python\nfrom fastapi import APIRouter, FastAPI\nfrom pydantic import BaseModel\n\nclass Item(BaseModel):\n    name: str\n    description: str | None = None\n\napp = FastAPI()\nrouter = APIRouter()\n\n@router.trace(\"/items/{item_id}\")\ndef trace_item(item_id: str):\n    return None\n\napp.include_router(router)\n```",
      "decorators": [],
      "arguments": [
        "self",
        "path"
      ],
      "imports": [
        "asyncio",
        "dataclasses",
        "email.message",
        "inspect",
        "json",
        "contextlib.AsyncExitStack",
        "contextlib.asynccontextmanager",
        "enum.Enum",
        "enum.IntEnum",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.params",
        "fastapi._compat.ModelField",
        "fastapi._compat.Undefined",
        "fastapi._compat._get_model_config",
        "fastapi._compat._model_dump",
        "fastapi._compat._normalize_errors",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.utils._should_embed_body_fields",
        "fastapi.dependencies.utils.get_body_field",
        "fastapi.dependencies.utils.get_dependant",
        "fastapi.dependencies.utils.get_flat_dependant",
        "fastapi.dependencies.utils.get_parameterless_sub_dependant",
        "fastapi.dependencies.utils.get_typed_return_annotation",
        "fastapi.dependencies.utils.solve_dependencies",
        "fastapi.encoders.jsonable_encoder",
        "fastapi.exceptions.FastAPIError",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.ResponseValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.create_cloned_field",
        "fastapi.utils.create_model_field",
        "fastapi.utils.generate_unique_id",
        "fastapi.utils.get_value_or_default",
        "fastapi.utils.is_body_allowed_for_status_code",
        "pydantic.BaseModel",
        "starlette.routing",
        "starlette.concurrency.run_in_threadpool",
        "starlette.exceptions.HTTPException",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.routing.Match",
        "starlette.routing.compile_path",
        "starlette.routing.get_name",
        "starlette.routing.request_response",
        "starlette.routing.websocket_session",
        "starlette.routing.Mount",
        "starlette.types.AppType",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Scope",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "Default",
          "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)"
        },
        {
          "name": "self.api_route",
          "body": "def api_route(self, path: str, *, response_model: Any=Default(None), status_code: Optional[int]=None, tags: Optional[List[Union[str, Enum]]]=None, dependencies: Optional[Sequence[Depends]]=None, summary: Optional[str]=None, description: Optional[str]=None, response_description: str='Successful Response', responses: Optional[Dict[Union[int, str], Dict[str, Any]]]=None, deprecated: Optional[bool]=None, methods: Optional[List[str]]=None, operation_id: Optional[str]=None, response_model_include: Optional[IncEx]=None, response_model_exclude: Optional[IncEx]=None, response_model_by_alias: bool=True, response_model_exclude_unset: bool=False, response_model_exclude_defaults: bool=False, response_model_exclude_none: bool=False, include_in_schema: bool=True, response_class: Type[Response]=Default(JSONResponse), name: Optional[str]=None, openapi_extra: Optional[Dict[str, Any]]=None, generate_unique_id_function: Callable[[routing.APIRoute], str]=Default(generate_unique_id)) -> Callable[[DecoratedCallable], DecoratedCallable]:\n\n    def decorator(func: DecoratedCallable) -> DecoratedCallable:\n        self.router.add_api_route(path, func, response_model=response_model, status_code=status_code, tags=tags, dependencies=dependencies, summary=summary, description=description, response_description=response_description, responses=responses, deprecated=deprecated, methods=methods, operation_id=operation_id, response_model_include=response_model_include, response_model_exclude=response_model_exclude, response_model_by_alias=response_model_by_alias, response_model_exclude_unset=response_model_exclude_unset, response_model_exclude_defaults=response_model_exclude_defaults, response_model_exclude_none=response_model_exclude_none, include_in_schema=include_in_schema, response_class=response_class, name=name, openapi_extra=openapi_extra, generate_unique_id_function=generate_unique_id_function)\n        return func\n    return decorator"
        }
      ]
    },
    {
      "name": "on_event",
      "module": "routing",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\routing.py",
      "line_number": 4415,
      "end_line_number": 4439,
      "source_code": "def on_event(\n        self,\n        event_type: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The type of event. `startup` or `shutdown`.\n                \"\"\"\n            ),\n        ],\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Add an event handler for the router.\n\n        `on_event` is deprecated, use `lifespan` event handlers instead.\n\n        Read more about it in the\n        [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/#alternative-events-deprecated).\n        \"\"\"\n\n        def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.add_event_handler(event_type, func)\n            return func\n\n        return decorator",
      "docstring": "Add an event handler for the router.\n\n`on_event` is deprecated, use `lifespan` event handlers instead.\n\nRead more about it in the\n[FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/#alternative-events-deprecated).",
      "decorators": [
        "deprecated('\\n        on_event is deprecated, use lifespan event handlers instead.\\n\\n        Read more about it in the\\n        [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).\\n        ')"
      ],
      "arguments": [
        "self",
        "event_type"
      ],
      "imports": [
        "asyncio",
        "dataclasses",
        "email.message",
        "inspect",
        "json",
        "contextlib.AsyncExitStack",
        "contextlib.asynccontextmanager",
        "enum.Enum",
        "enum.IntEnum",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.params",
        "fastapi._compat.ModelField",
        "fastapi._compat.Undefined",
        "fastapi._compat._get_model_config",
        "fastapi._compat._model_dump",
        "fastapi._compat._normalize_errors",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.utils._should_embed_body_fields",
        "fastapi.dependencies.utils.get_body_field",
        "fastapi.dependencies.utils.get_dependant",
        "fastapi.dependencies.utils.get_flat_dependant",
        "fastapi.dependencies.utils.get_parameterless_sub_dependant",
        "fastapi.dependencies.utils.get_typed_return_annotation",
        "fastapi.dependencies.utils.solve_dependencies",
        "fastapi.encoders.jsonable_encoder",
        "fastapi.exceptions.FastAPIError",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.ResponseValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.create_cloned_field",
        "fastapi.utils.create_model_field",
        "fastapi.utils.generate_unique_id",
        "fastapi.utils.get_value_or_default",
        "fastapi.utils.is_body_allowed_for_status_code",
        "pydantic.BaseModel",
        "starlette.routing",
        "starlette.concurrency.run_in_threadpool",
        "starlette.exceptions.HTTPException",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.routing.Match",
        "starlette.routing.compile_path",
        "starlette.routing.get_name",
        "starlette.routing.request_response",
        "starlette.routing.websocket_session",
        "starlette.routing.Mount",
        "starlette.types.AppType",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Scope",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "decorator",
      "module": "routing",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\routing.py",
      "line_number": 869,
      "end_line_number": 877,
      "source_code": "def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.add_route(\n                path,\n                func,\n                methods=methods,\n                name=name,\n                include_in_schema=include_in_schema,\n            )\n            return func",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "func"
      ],
      "imports": [
        "asyncio",
        "dataclasses",
        "email.message",
        "inspect",
        "json",
        "contextlib.AsyncExitStack",
        "contextlib.asynccontextmanager",
        "enum.Enum",
        "enum.IntEnum",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.params",
        "fastapi._compat.ModelField",
        "fastapi._compat.Undefined",
        "fastapi._compat._get_model_config",
        "fastapi._compat._model_dump",
        "fastapi._compat._normalize_errors",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.utils._should_embed_body_fields",
        "fastapi.dependencies.utils.get_body_field",
        "fastapi.dependencies.utils.get_dependant",
        "fastapi.dependencies.utils.get_flat_dependant",
        "fastapi.dependencies.utils.get_parameterless_sub_dependant",
        "fastapi.dependencies.utils.get_typed_return_annotation",
        "fastapi.dependencies.utils.solve_dependencies",
        "fastapi.encoders.jsonable_encoder",
        "fastapi.exceptions.FastAPIError",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.ResponseValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.create_cloned_field",
        "fastapi.utils.create_model_field",
        "fastapi.utils.generate_unique_id",
        "fastapi.utils.get_value_or_default",
        "fastapi.utils.is_body_allowed_for_status_code",
        "pydantic.BaseModel",
        "starlette.routing",
        "starlette.concurrency.run_in_threadpool",
        "starlette.exceptions.HTTPException",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.routing.Match",
        "starlette.routing.compile_path",
        "starlette.routing.get_name",
        "starlette.routing.request_response",
        "starlette.routing.websocket_session",
        "starlette.routing.Mount",
        "starlette.types.AppType",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Scope",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "decorator",
      "module": "routing",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\routing.py",
      "line_number": 993,
      "end_line_number": 1021,
      "source_code": "def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.add_api_route(\n                path,\n                func,\n                response_model=response_model,\n                status_code=status_code,\n                tags=tags,\n                dependencies=dependencies,\n                summary=summary,\n                description=description,\n                response_description=response_description,\n                responses=responses,\n                deprecated=deprecated,\n                methods=methods,\n                operation_id=operation_id,\n                response_model_include=response_model_include,\n                response_model_exclude=response_model_exclude,\n                response_model_by_alias=response_model_by_alias,\n                response_model_exclude_unset=response_model_exclude_unset,\n                response_model_exclude_defaults=response_model_exclude_defaults,\n                response_model_exclude_none=response_model_exclude_none,\n                include_in_schema=include_in_schema,\n                response_class=response_class,\n                name=name,\n                callbacks=callbacks,\n                openapi_extra=openapi_extra,\n                generate_unique_id_function=generate_unique_id_function,\n            )\n            return func",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "func"
      ],
      "imports": [
        "asyncio",
        "dataclasses",
        "email.message",
        "inspect",
        "json",
        "contextlib.AsyncExitStack",
        "contextlib.asynccontextmanager",
        "enum.Enum",
        "enum.IntEnum",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.params",
        "fastapi._compat.ModelField",
        "fastapi._compat.Undefined",
        "fastapi._compat._get_model_config",
        "fastapi._compat._model_dump",
        "fastapi._compat._normalize_errors",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.utils._should_embed_body_fields",
        "fastapi.dependencies.utils.get_body_field",
        "fastapi.dependencies.utils.get_dependant",
        "fastapi.dependencies.utils.get_flat_dependant",
        "fastapi.dependencies.utils.get_parameterless_sub_dependant",
        "fastapi.dependencies.utils.get_typed_return_annotation",
        "fastapi.dependencies.utils.solve_dependencies",
        "fastapi.encoders.jsonable_encoder",
        "fastapi.exceptions.FastAPIError",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.ResponseValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.create_cloned_field",
        "fastapi.utils.create_model_field",
        "fastapi.utils.generate_unique_id",
        "fastapi.utils.get_value_or_default",
        "fastapi.utils.is_body_allowed_for_status_code",
        "pydantic.BaseModel",
        "starlette.routing",
        "starlette.concurrency.run_in_threadpool",
        "starlette.exceptions.HTTPException",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.routing.Match",
        "starlette.routing.compile_path",
        "starlette.routing.get_name",
        "starlette.routing.request_response",
        "starlette.routing.websocket_session",
        "starlette.routing.Mount",
        "starlette.types.AppType",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Scope",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.add_api_route",
          "body": "def add_api_route(self, path: str, endpoint: Callable[..., Any], *, response_model: Any=Default(None), status_code: Optional[int]=None, tags: Optional[List[Union[str, Enum]]]=None, dependencies: Optional[Sequence[Depends]]=None, summary: Optional[str]=None, description: Optional[str]=None, response_description: str='Successful Response', responses: Optional[Dict[Union[int, str], Dict[str, Any]]]=None, deprecated: Optional[bool]=None, methods: Optional[List[str]]=None, operation_id: Optional[str]=None, response_model_include: Optional[IncEx]=None, response_model_exclude: Optional[IncEx]=None, response_model_by_alias: bool=True, response_model_exclude_unset: bool=False, response_model_exclude_defaults: bool=False, response_model_exclude_none: bool=False, include_in_schema: bool=True, response_class: Union[Type[Response], DefaultPlaceholder]=Default(JSONResponse), name: Optional[str]=None, openapi_extra: Optional[Dict[str, Any]]=None, generate_unique_id_function: Callable[[routing.APIRoute], str]=Default(generate_unique_id)) -> None:\n    self.router.add_api_route(path, endpoint=endpoint, response_model=response_model, status_code=status_code, tags=tags, dependencies=dependencies, summary=summary, description=description, response_description=response_description, responses=responses, deprecated=deprecated, methods=methods, operation_id=operation_id, response_model_include=response_model_include, response_model_exclude=response_model_exclude, response_model_by_alias=response_model_by_alias, response_model_exclude_unset=response_model_exclude_unset, response_model_exclude_defaults=response_model_exclude_defaults, response_model_exclude_none=response_model_exclude_none, include_in_schema=include_in_schema, response_class=response_class, name=name, openapi_extra=openapi_extra, generate_unique_id_function=generate_unique_id_function)"
        }
      ]
    },
    {
      "name": "decorator",
      "module": "routing",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\routing.py",
      "line_number": 1105,
      "end_line_number": 1109,
      "source_code": "def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.add_api_websocket_route(\n                path, func, name=name, dependencies=dependencies\n            )\n            return func",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "func"
      ],
      "imports": [
        "asyncio",
        "dataclasses",
        "email.message",
        "inspect",
        "json",
        "contextlib.AsyncExitStack",
        "contextlib.asynccontextmanager",
        "enum.Enum",
        "enum.IntEnum",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.params",
        "fastapi._compat.ModelField",
        "fastapi._compat.Undefined",
        "fastapi._compat._get_model_config",
        "fastapi._compat._model_dump",
        "fastapi._compat._normalize_errors",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.utils._should_embed_body_fields",
        "fastapi.dependencies.utils.get_body_field",
        "fastapi.dependencies.utils.get_dependant",
        "fastapi.dependencies.utils.get_flat_dependant",
        "fastapi.dependencies.utils.get_parameterless_sub_dependant",
        "fastapi.dependencies.utils.get_typed_return_annotation",
        "fastapi.dependencies.utils.solve_dependencies",
        "fastapi.encoders.jsonable_encoder",
        "fastapi.exceptions.FastAPIError",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.ResponseValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.create_cloned_field",
        "fastapi.utils.create_model_field",
        "fastapi.utils.generate_unique_id",
        "fastapi.utils.get_value_or_default",
        "fastapi.utils.is_body_allowed_for_status_code",
        "pydantic.BaseModel",
        "starlette.routing",
        "starlette.concurrency.run_in_threadpool",
        "starlette.exceptions.HTTPException",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.routing.Match",
        "starlette.routing.compile_path",
        "starlette.routing.get_name",
        "starlette.routing.request_response",
        "starlette.routing.websocket_session",
        "starlette.routing.Mount",
        "starlette.types.AppType",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Scope",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.add_api_websocket_route",
          "body": "def add_api_websocket_route(self, path: str, endpoint: Callable[..., Any], name: Optional[str]=None, *, dependencies: Optional[Sequence[Depends]]=None) -> None:\n    self.router.add_api_websocket_route(path, endpoint, name=name, dependencies=dependencies)"
        }
      ]
    },
    {
      "name": "decorator",
      "module": "routing",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\routing.py",
      "line_number": 1116,
      "end_line_number": 1118,
      "source_code": "def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.add_websocket_route(path, func, name=name)\n            return func",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "func"
      ],
      "imports": [
        "asyncio",
        "dataclasses",
        "email.message",
        "inspect",
        "json",
        "contextlib.AsyncExitStack",
        "contextlib.asynccontextmanager",
        "enum.Enum",
        "enum.IntEnum",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.params",
        "fastapi._compat.ModelField",
        "fastapi._compat.Undefined",
        "fastapi._compat._get_model_config",
        "fastapi._compat._model_dump",
        "fastapi._compat._normalize_errors",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.utils._should_embed_body_fields",
        "fastapi.dependencies.utils.get_body_field",
        "fastapi.dependencies.utils.get_dependant",
        "fastapi.dependencies.utils.get_flat_dependant",
        "fastapi.dependencies.utils.get_parameterless_sub_dependant",
        "fastapi.dependencies.utils.get_typed_return_annotation",
        "fastapi.dependencies.utils.solve_dependencies",
        "fastapi.encoders.jsonable_encoder",
        "fastapi.exceptions.FastAPIError",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.ResponseValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.create_cloned_field",
        "fastapi.utils.create_model_field",
        "fastapi.utils.generate_unique_id",
        "fastapi.utils.get_value_or_default",
        "fastapi.utils.is_body_allowed_for_status_code",
        "pydantic.BaseModel",
        "starlette.routing",
        "starlette.concurrency.run_in_threadpool",
        "starlette.exceptions.HTTPException",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.routing.Match",
        "starlette.routing.compile_path",
        "starlette.routing.get_name",
        "starlette.routing.request_response",
        "starlette.routing.websocket_session",
        "starlette.routing.Mount",
        "starlette.types.AppType",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Scope",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "decorator",
      "module": "routing",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\routing.py",
      "line_number": 4435,
      "end_line_number": 4437,
      "source_code": "def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.add_event_handler(event_type, func)\n            return func",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "func"
      ],
      "imports": [
        "asyncio",
        "dataclasses",
        "email.message",
        "inspect",
        "json",
        "contextlib.AsyncExitStack",
        "contextlib.asynccontextmanager",
        "enum.Enum",
        "enum.IntEnum",
        "typing.Any",
        "typing.AsyncIterator",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.params",
        "fastapi._compat.ModelField",
        "fastapi._compat.Undefined",
        "fastapi._compat._get_model_config",
        "fastapi._compat._model_dump",
        "fastapi._compat._normalize_errors",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.Default",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.utils._should_embed_body_fields",
        "fastapi.dependencies.utils.get_body_field",
        "fastapi.dependencies.utils.get_dependant",
        "fastapi.dependencies.utils.get_flat_dependant",
        "fastapi.dependencies.utils.get_parameterless_sub_dependant",
        "fastapi.dependencies.utils.get_typed_return_annotation",
        "fastapi.dependencies.utils.solve_dependencies",
        "fastapi.encoders.jsonable_encoder",
        "fastapi.exceptions.FastAPIError",
        "fastapi.exceptions.RequestValidationError",
        "fastapi.exceptions.ResponseValidationError",
        "fastapi.exceptions.WebSocketRequestValidationError",
        "fastapi.types.DecoratedCallable",
        "fastapi.types.IncEx",
        "fastapi.utils.create_cloned_field",
        "fastapi.utils.create_model_field",
        "fastapi.utils.generate_unique_id",
        "fastapi.utils.get_value_or_default",
        "fastapi.utils.is_body_allowed_for_status_code",
        "pydantic.BaseModel",
        "starlette.routing",
        "starlette.concurrency.run_in_threadpool",
        "starlette.exceptions.HTTPException",
        "starlette.requests.Request",
        "starlette.responses.JSONResponse",
        "starlette.responses.Response",
        "starlette.routing.BaseRoute",
        "starlette.routing.Match",
        "starlette.routing.compile_path",
        "starlette.routing.get_name",
        "starlette.routing.request_response",
        "starlette.routing.websocket_session",
        "starlette.routing.Mount",
        "starlette.types.AppType",
        "starlette.types.ASGIApp",
        "starlette.types.Lifespan",
        "starlette.types.Scope",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.Doc",
        "typing_extensions.deprecated"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "is_body_allowed_for_status_code",
      "module": "utils",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\utils.py",
      "line_number": 42,
      "end_line_number": 56,
      "source_code": "def is_body_allowed_for_status_code(status_code: Union[int, str, None]) -> bool:\n    if status_code is None:\n        return True\n    # Ref: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#patterned-fields-1\n    if status_code in {\n        \"default\",\n        \"1XX\",\n        \"2XX\",\n        \"3XX\",\n        \"4XX\",\n        \"5XX\",\n    }:\n        return True\n    current_status_code = int(status_code)\n    return not (current_status_code < 200 or current_status_code in {204, 205, 304})",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "status_code"
      ],
      "imports": [
        "re",
        "warnings",
        "dataclasses.is_dataclass",
        "typing.TYPE_CHECKING",
        "typing.Any",
        "typing.Dict",
        "typing.MutableMapping",
        "typing.Optional",
        "typing.Set",
        "typing.Type",
        "typing.Union",
        "typing.cast",
        "weakref.WeakKeyDictionary",
        "fastapi",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.BaseConfig",
        "fastapi._compat.ModelField",
        "fastapi._compat.PydanticSchemaGenerationError",
        "fastapi._compat.Undefined",
        "fastapi._compat.UndefinedType",
        "fastapi._compat.Validator",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.datastructures.DefaultType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.fields.FieldInfo",
        "typing_extensions.Literal",
        "routing.APIRoute"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "get_path_param_names",
      "module": "utils",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\utils.py",
      "line_number": 59,
      "end_line_number": 60,
      "source_code": "def get_path_param_names(path: str) -> Set[str]:\n    return set(re.findall(\"{(.*?)}\", path))",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "path"
      ],
      "imports": [
        "re",
        "warnings",
        "dataclasses.is_dataclass",
        "typing.TYPE_CHECKING",
        "typing.Any",
        "typing.Dict",
        "typing.MutableMapping",
        "typing.Optional",
        "typing.Set",
        "typing.Type",
        "typing.Union",
        "typing.cast",
        "weakref.WeakKeyDictionary",
        "fastapi",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.BaseConfig",
        "fastapi._compat.ModelField",
        "fastapi._compat.PydanticSchemaGenerationError",
        "fastapi._compat.Undefined",
        "fastapi._compat.UndefinedType",
        "fastapi._compat.Validator",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.datastructures.DefaultType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.fields.FieldInfo",
        "typing_extensions.Literal",
        "routing.APIRoute"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "create_model_field",
      "module": "utils",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\utils.py",
      "line_number": 63,
      "end_line_number": 106,
      "source_code": "def create_model_field(\n    name: str,\n    type_: Any,\n    class_validators: Optional[Dict[str, Validator]] = None,\n    default: Optional[Any] = Undefined,\n    required: Union[bool, UndefinedType] = Undefined,\n    model_config: Type[BaseConfig] = BaseConfig,\n    field_info: Optional[FieldInfo] = None,\n    alias: Optional[str] = None,\n    mode: Literal[\"validation\", \"serialization\"] = \"validation\",\n) -> ModelField:\n    class_validators = class_validators or {}\n    if PYDANTIC_V2:\n        field_info = field_info or FieldInfo(\n            annotation=type_, default=default, alias=alias\n        )\n    else:\n        field_info = field_info or FieldInfo()\n    kwargs = {\"name\": name, \"field_info\": field_info}\n    if PYDANTIC_V2:\n        kwargs.update({\"mode\": mode})\n    else:\n        kwargs.update(\n            {\n                \"type_\": type_,\n                \"class_validators\": class_validators,\n                \"default\": default,\n                \"required\": required,\n                \"model_config\": model_config,\n                \"alias\": alias,\n            }\n        )\n    try:\n        return ModelField(**kwargs)  # type: ignore[arg-type]\n    except (RuntimeError, PydanticSchemaGenerationError):\n        raise fastapi.exceptions.FastAPIError(\n            \"Invalid args for response field! Hint: \"\n            f\"check that {type_} is a valid Pydantic field type. \"\n            \"If you are using a return type annotation that is not a valid Pydantic \"\n            \"field (e.g. Union[Response, dict, None]) you can disable generating the \"\n            \"response model from the type annotation with the path operation decorator \"\n            \"parameter response_model=None. Read more: \"\n            \"https://fastapi.tiangolo.com/tutorial/response-model/\"\n        ) from None",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "name",
        "type_",
        "class_validators",
        "default",
        "required",
        "model_config",
        "field_info",
        "alias",
        "mode"
      ],
      "imports": [
        "re",
        "warnings",
        "dataclasses.is_dataclass",
        "typing.TYPE_CHECKING",
        "typing.Any",
        "typing.Dict",
        "typing.MutableMapping",
        "typing.Optional",
        "typing.Set",
        "typing.Type",
        "typing.Union",
        "typing.cast",
        "weakref.WeakKeyDictionary",
        "fastapi",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.BaseConfig",
        "fastapi._compat.ModelField",
        "fastapi._compat.PydanticSchemaGenerationError",
        "fastapi._compat.Undefined",
        "fastapi._compat.UndefinedType",
        "fastapi._compat.Validator",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.datastructures.DefaultType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.fields.FieldInfo",
        "typing_extensions.Literal",
        "routing.APIRoute"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "create_cloned_field",
      "module": "utils",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\utils.py",
      "line_number": 109,
      "end_line_number": 161,
      "source_code": "def create_cloned_field(\n    field: ModelField,\n    *,\n    cloned_types: Optional[MutableMapping[Type[BaseModel], Type[BaseModel]]] = None,\n) -> ModelField:\n    if PYDANTIC_V2:\n        return field\n    # cloned_types caches already cloned types to support recursive models and improve\n    # performance by avoiding unnecessary cloning\n    if cloned_types is None:\n        cloned_types = _CLONED_TYPES_CACHE\n\n    original_type = field.type_\n    if is_dataclass(original_type) and hasattr(original_type, \"__pydantic_model__\"):\n        original_type = original_type.__pydantic_model__\n    use_type = original_type\n    if lenient_issubclass(original_type, BaseModel):\n        original_type = cast(Type[BaseModel], original_type)\n        use_type = cloned_types.get(original_type)\n        if use_type is None:\n            use_type = create_model(original_type.__name__, __base__=original_type)\n            cloned_types[original_type] = use_type\n            for f in original_type.__fields__.values():\n                use_type.__fields__[f.name] = create_cloned_field(\n                    f, cloned_types=cloned_types\n                )\n    new_field = create_model_field(name=field.name, type_=use_type)\n    new_field.has_alias = field.has_alias  # type: ignore[attr-defined]\n    new_field.alias = field.alias  # type: ignore[misc]\n    new_field.class_validators = field.class_validators  # type: ignore[attr-defined]\n    new_field.default = field.default  # type: ignore[misc]\n    new_field.required = field.required  # type: ignore[misc]\n    new_field.model_config = field.model_config  # type: ignore[attr-defined]\n    new_field.field_info = field.field_info\n    new_field.allow_none = field.allow_none  # type: ignore[attr-defined]\n    new_field.validate_always = field.validate_always  # type: ignore[attr-defined]\n    if field.sub_fields:  # type: ignore[attr-defined]\n        new_field.sub_fields = [  # type: ignore[attr-defined]\n            create_cloned_field(sub_field, cloned_types=cloned_types)\n            for sub_field in field.sub_fields  # type: ignore[attr-defined]\n        ]\n    if field.key_field:  # type: ignore[attr-defined]\n        new_field.key_field = create_cloned_field(  # type: ignore[attr-defined]\n            field.key_field,  # type: ignore[attr-defined]\n            cloned_types=cloned_types,\n        )\n    new_field.validators = field.validators  # type: ignore[attr-defined]\n    new_field.pre_validators = field.pre_validators  # type: ignore[attr-defined]\n    new_field.post_validators = field.post_validators  # type: ignore[attr-defined]\n    new_field.parse_json = field.parse_json  # type: ignore[attr-defined]\n    new_field.shape = field.shape  # type: ignore[attr-defined]\n    new_field.populate_validators()  # type: ignore[attr-defined]\n    return new_field",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "field"
      ],
      "imports": [
        "re",
        "warnings",
        "dataclasses.is_dataclass",
        "typing.TYPE_CHECKING",
        "typing.Any",
        "typing.Dict",
        "typing.MutableMapping",
        "typing.Optional",
        "typing.Set",
        "typing.Type",
        "typing.Union",
        "typing.cast",
        "weakref.WeakKeyDictionary",
        "fastapi",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.BaseConfig",
        "fastapi._compat.ModelField",
        "fastapi._compat.PydanticSchemaGenerationError",
        "fastapi._compat.Undefined",
        "fastapi._compat.UndefinedType",
        "fastapi._compat.Validator",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.datastructures.DefaultType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.fields.FieldInfo",
        "typing_extensions.Literal",
        "routing.APIRoute"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "create_model_field",
          "body": "def create_model_field(name: str, type_: Any, class_validators: Optional[Dict[str, Validator]]=None, default: Optional[Any]=Undefined, required: Union[bool, UndefinedType]=Undefined, model_config: Type[BaseConfig]=BaseConfig, field_info: Optional[FieldInfo]=None, alias: Optional[str]=None, mode: Literal['validation', 'serialization']='validation') -> ModelField:\n    class_validators = class_validators or {}\n    if PYDANTIC_V2:\n        field_info = field_info or FieldInfo(annotation=type_, default=default, alias=alias)\n    else:\n        field_info = field_info or FieldInfo()\n    kwargs = {'name': name, 'field_info': field_info}\n    if PYDANTIC_V2:\n        kwargs.update({'mode': mode})\n    else:\n        kwargs.update({'type_': type_, 'class_validators': class_validators, 'default': default, 'required': required, 'model_config': model_config, 'alias': alias})\n    try:\n        return ModelField(**kwargs)\n    except (RuntimeError, PydanticSchemaGenerationError):\n        raise fastapi.exceptions.FastAPIError(f'Invalid args for response field! Hint: check that {type_} is a valid Pydantic field type. If you are using a return type annotation that is not a valid Pydantic field (e.g. Union[Response, dict, None]) you can disable generating the response model from the type annotation with the path operation decorator parameter response_model=None. Read more: https://fastapi.tiangolo.com/tutorial/response-model/') from None"
        },
        {
          "name": "cloned_types.get",
          "body": "def get(self, path: Annotated[str, Doc('\\n                The URL path to be used for this *path operation*.\\n\\n                For example, in `http://example.com/items`, the path is `/items`.\\n                ')], *, response_model: Annotated[Any, Doc(\"\\n                The type to use for the response.\\n\\n                It could be any valid Pydantic *field* type. So, it doesn't have to\\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\\n                etc.\\n\\n                It will be used for:\\n\\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\\n                    show it as the response (JSON Schema).\\n                * Serialization: you could return an arbitrary object and the\\n                    `response_model` would be used to serialize that object into the\\n                    corresponding JSON.\\n                * Filtering: the JSON sent to the client will only contain the data\\n                    (fields) defined in the `response_model`. If you returned an object\\n                    that contains an attribute `password` but the `response_model` does\\n                    not include that field, the JSON sent to the client would not have\\n                    that `password`.\\n                * Validation: whatever you return will be serialized with the\\n                    `response_model`, converting any data as necessary to generate the\\n                    corresponding JSON. But if the data in the object returned is not\\n                    valid, that would mean a violation of the contract with the client,\\n                    so it's an error from the API developer. So, FastAPI will raise an\\n                    error and return a 500 error code (Internal Server Error).\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\\n                \")]=Default(None), status_code: Annotated[Optional[int], Doc('\\n                The default status code to be used for the response.\\n\\n                You could override the status code by returning a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\\n                ')]=None, tags: Annotated[Optional[List[Union[str, Enum]]], Doc('\\n                A list of tags to be applied to the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\\n                ')]=None, dependencies: Annotated[Optional[Sequence[Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to the\\n                *path operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\\n                ')]=None, summary: Annotated[Optional[str], Doc('\\n                A summary for the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, description: Annotated[Optional[str], Doc('\\n                A description for the *path operation*.\\n\\n                If not provided, it will be extracted automatically from the docstring\\n                of the *path operation function*.\\n\\n                It can contain Markdown.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, response_description: Annotated[str, Doc('\\n                The description for the default response.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]='Successful Response', responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses that could be returned by this *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark this *path operation* as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, operation_id: Annotated[Optional[str], Doc('\\n                Custom operation ID to be used by this *path operation*.\\n\\n                By default, it is generated automatically.\\n\\n                If you provide a custom operation ID, you need to make sure it is\\n                unique for the whole API.\\n\\n                You can customize the\\n                operation ID generation with the parameter\\n                `generate_unique_id_function` in the `FastAPI` class.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=None, response_model_include: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to include only certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_exclude: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to exclude certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_by_alias: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response model\\n                should be serialized by alias when an alias is used.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=True, response_model_exclude_unset: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that were not set and\\n                have their default values. This is different from\\n                `response_model_exclude_defaults` in that if the fields are set,\\n                they will be included in the response, even if the value is the same\\n                as the default.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_defaults: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that have the same value\\n                as the default. This is different from `response_model_exclude_unset`\\n                in that if the fields are set but contain the same default values,\\n                they will be excluded from the response.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_none: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data should\\n                exclude fields set to `None`.\\n\\n                This is much simpler (less smart) than `response_model_exclude_unset`\\n                and `response_model_exclude_defaults`. You probably want to use one of\\n                those two instead of this one, as those allow returning `None` values\\n                when it makes sense.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\\n                ')]=False, include_in_schema: Annotated[bool, Doc('\\n                Include this *path operation* in the generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\\n                ')]=True, response_class: Annotated[Type[Response], Doc('\\n                Response class to be used for this *path operation*.\\n\\n                This will not be used if you return a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\\n                ')]=Default(JSONResponse), name: Annotated[Optional[str], Doc('\\n                Name for this *path operation*. Only used internally.\\n                ')]=None, callbacks: Annotated[Optional[List[BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")]=None, openapi_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n                Extra metadata to be included in the OpenAPI schema for this *path\\n                operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\\n                ')]=None, generate_unique_id_function: Annotated[Callable[[routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=Default(generate_unique_id)) -> Callable[[DecoratedCallable], DecoratedCallable]:\n    \"\"\"\n        Add a *path operation* using an HTTP GET operation.\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI\n\n        app = FastAPI()\n\n        @app.get(\"/items/\")\n        def read_items():\n            return [{\"name\": \"Empanada\"}, {\"name\": \"Arepa\"}]\n        ```\n        \"\"\"\n    return self.router.get(path, response_model=response_model, status_code=status_code, tags=tags, dependencies=dependencies, summary=summary, description=description, response_description=response_description, responses=responses, deprecated=deprecated, operation_id=operation_id, response_model_include=response_model_include, response_model_exclude=response_model_exclude, response_model_by_alias=response_model_by_alias, response_model_exclude_unset=response_model_exclude_unset, response_model_exclude_defaults=response_model_exclude_defaults, response_model_exclude_none=response_model_exclude_none, include_in_schema=include_in_schema, response_class=response_class, name=name, callbacks=callbacks, openapi_extra=openapi_extra, generate_unique_id_function=generate_unique_id_function)"
        },
        {
          "name": "create_cloned_field",
          "body": "def create_cloned_field(field: ModelField, *, cloned_types: Optional[MutableMapping[Type[BaseModel], Type[BaseModel]]]=None) -> ModelField:\n    if PYDANTIC_V2:\n        return field\n    if cloned_types is None:\n        cloned_types = _CLONED_TYPES_CACHE\n    original_type = field.type_\n    if is_dataclass(original_type) and hasattr(original_type, '__pydantic_model__'):\n        original_type = original_type.__pydantic_model__\n    use_type = original_type\n    if lenient_issubclass(original_type, BaseModel):\n        original_type = cast(Type[BaseModel], original_type)\n        use_type = cloned_types.get(original_type)\n        if use_type is None:\n            use_type = create_model(original_type.__name__, __base__=original_type)\n            cloned_types[original_type] = use_type\n            for f in original_type.__fields__.values():\n                use_type.__fields__[f.name] = create_cloned_field(f, cloned_types=cloned_types)\n    new_field = create_model_field(name=field.name, type_=use_type)\n    new_field.has_alias = field.has_alias\n    new_field.alias = field.alias\n    new_field.class_validators = field.class_validators\n    new_field.default = field.default\n    new_field.required = field.required\n    new_field.model_config = field.model_config\n    new_field.field_info = field.field_info\n    new_field.allow_none = field.allow_none\n    new_field.validate_always = field.validate_always\n    if field.sub_fields:\n        new_field.sub_fields = [create_cloned_field(sub_field, cloned_types=cloned_types) for sub_field in field.sub_fields]\n    if field.key_field:\n        new_field.key_field = create_cloned_field(field.key_field, cloned_types=cloned_types)\n    new_field.validators = field.validators\n    new_field.pre_validators = field.pre_validators\n    new_field.post_validators = field.post_validators\n    new_field.parse_json = field.parse_json\n    new_field.shape = field.shape\n    new_field.populate_validators()\n    return new_field"
        },
        {
          "name": "create_cloned_field",
          "body": "def create_cloned_field(field: ModelField, *, cloned_types: Optional[MutableMapping[Type[BaseModel], Type[BaseModel]]]=None) -> ModelField:\n    if PYDANTIC_V2:\n        return field\n    if cloned_types is None:\n        cloned_types = _CLONED_TYPES_CACHE\n    original_type = field.type_\n    if is_dataclass(original_type) and hasattr(original_type, '__pydantic_model__'):\n        original_type = original_type.__pydantic_model__\n    use_type = original_type\n    if lenient_issubclass(original_type, BaseModel):\n        original_type = cast(Type[BaseModel], original_type)\n        use_type = cloned_types.get(original_type)\n        if use_type is None:\n            use_type = create_model(original_type.__name__, __base__=original_type)\n            cloned_types[original_type] = use_type\n            for f in original_type.__fields__.values():\n                use_type.__fields__[f.name] = create_cloned_field(f, cloned_types=cloned_types)\n    new_field = create_model_field(name=field.name, type_=use_type)\n    new_field.has_alias = field.has_alias\n    new_field.alias = field.alias\n    new_field.class_validators = field.class_validators\n    new_field.default = field.default\n    new_field.required = field.required\n    new_field.model_config = field.model_config\n    new_field.field_info = field.field_info\n    new_field.allow_none = field.allow_none\n    new_field.validate_always = field.validate_always\n    if field.sub_fields:\n        new_field.sub_fields = [create_cloned_field(sub_field, cloned_types=cloned_types) for sub_field in field.sub_fields]\n    if field.key_field:\n        new_field.key_field = create_cloned_field(field.key_field, cloned_types=cloned_types)\n    new_field.validators = field.validators\n    new_field.pre_validators = field.pre_validators\n    new_field.post_validators = field.post_validators\n    new_field.parse_json = field.parse_json\n    new_field.shape = field.shape\n    new_field.populate_validators()\n    return new_field"
        },
        {
          "name": "create_cloned_field",
          "body": "def create_cloned_field(field: ModelField, *, cloned_types: Optional[MutableMapping[Type[BaseModel], Type[BaseModel]]]=None) -> ModelField:\n    if PYDANTIC_V2:\n        return field\n    if cloned_types is None:\n        cloned_types = _CLONED_TYPES_CACHE\n    original_type = field.type_\n    if is_dataclass(original_type) and hasattr(original_type, '__pydantic_model__'):\n        original_type = original_type.__pydantic_model__\n    use_type = original_type\n    if lenient_issubclass(original_type, BaseModel):\n        original_type = cast(Type[BaseModel], original_type)\n        use_type = cloned_types.get(original_type)\n        if use_type is None:\n            use_type = create_model(original_type.__name__, __base__=original_type)\n            cloned_types[original_type] = use_type\n            for f in original_type.__fields__.values():\n                use_type.__fields__[f.name] = create_cloned_field(f, cloned_types=cloned_types)\n    new_field = create_model_field(name=field.name, type_=use_type)\n    new_field.has_alias = field.has_alias\n    new_field.alias = field.alias\n    new_field.class_validators = field.class_validators\n    new_field.default = field.default\n    new_field.required = field.required\n    new_field.model_config = field.model_config\n    new_field.field_info = field.field_info\n    new_field.allow_none = field.allow_none\n    new_field.validate_always = field.validate_always\n    if field.sub_fields:\n        new_field.sub_fields = [create_cloned_field(sub_field, cloned_types=cloned_types) for sub_field in field.sub_fields]\n    if field.key_field:\n        new_field.key_field = create_cloned_field(field.key_field, cloned_types=cloned_types)\n    new_field.validators = field.validators\n    new_field.pre_validators = field.pre_validators\n    new_field.post_validators = field.post_validators\n    new_field.parse_json = field.parse_json\n    new_field.shape = field.shape\n    new_field.populate_validators()\n    return new_field"
        }
      ]
    },
    {
      "name": "generate_operation_id_for_path",
      "module": "utils",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\utils.py",
      "line_number": 164,
      "end_line_number": 176,
      "source_code": "def generate_operation_id_for_path(\n    *, name: str, path: str, method: str\n) -> str:  # pragma: nocover\n    warnings.warn(\n        \"fastapi.utils.generate_operation_id_for_path() was deprecated, \"\n        \"it is not used internally, and will be removed soon\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    operation_id = f\"{name}{path}\"\n    operation_id = re.sub(r\"\\W\", \"_\", operation_id)\n    operation_id = f\"{operation_id}_{method.lower()}\"\n    return operation_id",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "re",
        "warnings",
        "dataclasses.is_dataclass",
        "typing.TYPE_CHECKING",
        "typing.Any",
        "typing.Dict",
        "typing.MutableMapping",
        "typing.Optional",
        "typing.Set",
        "typing.Type",
        "typing.Union",
        "typing.cast",
        "weakref.WeakKeyDictionary",
        "fastapi",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.BaseConfig",
        "fastapi._compat.ModelField",
        "fastapi._compat.PydanticSchemaGenerationError",
        "fastapi._compat.Undefined",
        "fastapi._compat.UndefinedType",
        "fastapi._compat.Validator",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.datastructures.DefaultType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.fields.FieldInfo",
        "typing_extensions.Literal",
        "routing.APIRoute"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "generate_unique_id",
      "module": "utils",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\utils.py",
      "line_number": 179,
      "end_line_number": 184,
      "source_code": "def generate_unique_id(route: \"APIRoute\") -> str:\n    operation_id = f\"{route.name}{route.path_format}\"\n    operation_id = re.sub(r\"\\W\", \"_\", operation_id)\n    assert route.methods\n    operation_id = f\"{operation_id}_{list(route.methods)[0].lower()}\"\n    return operation_id",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "route"
      ],
      "imports": [
        "re",
        "warnings",
        "dataclasses.is_dataclass",
        "typing.TYPE_CHECKING",
        "typing.Any",
        "typing.Dict",
        "typing.MutableMapping",
        "typing.Optional",
        "typing.Set",
        "typing.Type",
        "typing.Union",
        "typing.cast",
        "weakref.WeakKeyDictionary",
        "fastapi",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.BaseConfig",
        "fastapi._compat.ModelField",
        "fastapi._compat.PydanticSchemaGenerationError",
        "fastapi._compat.Undefined",
        "fastapi._compat.UndefinedType",
        "fastapi._compat.Validator",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.datastructures.DefaultType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.fields.FieldInfo",
        "typing_extensions.Literal",
        "routing.APIRoute"
      ],
      "fixtures": [],
      "assertions": [
        "assert route.methods"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "deep_dict_update",
      "module": "utils",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\utils.py",
      "line_number": 187,
      "end_line_number": 202,
      "source_code": "def deep_dict_update(main_dict: Dict[Any, Any], update_dict: Dict[Any, Any]) -> None:\n    for key, value in update_dict.items():\n        if (\n            key in main_dict\n            and isinstance(main_dict[key], dict)\n            and isinstance(value, dict)\n        ):\n            deep_dict_update(main_dict[key], value)\n        elif (\n            key in main_dict\n            and isinstance(main_dict[key], list)\n            and isinstance(update_dict[key], list)\n        ):\n            main_dict[key] = main_dict[key] + update_dict[key]\n        else:\n            main_dict[key] = value",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "main_dict",
        "update_dict"
      ],
      "imports": [
        "re",
        "warnings",
        "dataclasses.is_dataclass",
        "typing.TYPE_CHECKING",
        "typing.Any",
        "typing.Dict",
        "typing.MutableMapping",
        "typing.Optional",
        "typing.Set",
        "typing.Type",
        "typing.Union",
        "typing.cast",
        "weakref.WeakKeyDictionary",
        "fastapi",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.BaseConfig",
        "fastapi._compat.ModelField",
        "fastapi._compat.PydanticSchemaGenerationError",
        "fastapi._compat.Undefined",
        "fastapi._compat.UndefinedType",
        "fastapi._compat.Validator",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.datastructures.DefaultType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.fields.FieldInfo",
        "typing_extensions.Literal",
        "routing.APIRoute"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "deep_dict_update",
          "body": "def deep_dict_update(main_dict: Dict[Any, Any], update_dict: Dict[Any, Any]) -> None:\n    for key, value in update_dict.items():\n        if key in main_dict and isinstance(main_dict[key], dict) and isinstance(value, dict):\n            deep_dict_update(main_dict[key], value)\n        elif key in main_dict and isinstance(main_dict[key], list) and isinstance(update_dict[key], list):\n            main_dict[key] = main_dict[key] + update_dict[key]\n        else:\n            main_dict[key] = value"
        }
      ]
    },
    {
      "name": "get_value_or_default",
      "module": "utils",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\utils.py",
      "line_number": 205,
      "end_line_number": 220,
      "source_code": "def get_value_or_default(\n    first_item: Union[DefaultPlaceholder, DefaultType],\n    *extra_items: Union[DefaultPlaceholder, DefaultType],\n) -> Union[DefaultPlaceholder, DefaultType]:\n    \"\"\"\n    Pass items or `DefaultPlaceholder`s by descending priority.\n\n    The first one to _not_ be a `DefaultPlaceholder` will be returned.\n\n    Otherwise, the first item (a `DefaultPlaceholder`) will be returned.\n    \"\"\"\n    items = (first_item,) + extra_items\n    for item in items:\n        if not isinstance(item, DefaultPlaceholder):\n            return item\n    return first_item",
      "docstring": "Pass items or `DefaultPlaceholder`s by descending priority.\n\nThe first one to _not_ be a `DefaultPlaceholder` will be returned.\n\nOtherwise, the first item (a `DefaultPlaceholder`) will be returned.",
      "decorators": [],
      "arguments": [
        "first_item"
      ],
      "imports": [
        "re",
        "warnings",
        "dataclasses.is_dataclass",
        "typing.TYPE_CHECKING",
        "typing.Any",
        "typing.Dict",
        "typing.MutableMapping",
        "typing.Optional",
        "typing.Set",
        "typing.Type",
        "typing.Union",
        "typing.cast",
        "weakref.WeakKeyDictionary",
        "fastapi",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.BaseConfig",
        "fastapi._compat.ModelField",
        "fastapi._compat.PydanticSchemaGenerationError",
        "fastapi._compat.Undefined",
        "fastapi._compat.UndefinedType",
        "fastapi._compat.Validator",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.datastructures.DefaultType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.fields.FieldInfo",
        "typing_extensions.Literal",
        "routing.APIRoute"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_regenerate_error_with_loc",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 529,
      "end_line_number": 537,
      "source_code": "def _regenerate_error_with_loc(\n    *, errors: Sequence[Any], loc_prefix: Tuple[Union[str, int], ...]\n) -> List[Dict[str, Any]]:\n    updated_loc_errors: List[Any] = [\n        {**err, \"loc\": loc_prefix + err.get(\"loc\", ())}\n        for err in _normalize_errors(errors)\n    ]\n\n    return updated_loc_errors",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "_normalize_errors",
          "body": "def _normalize_errors(errors: Sequence[Any]) -> List[Dict[str, Any]]:\n    return errors"
        },
        {
          "name": "err.get",
          "body": "def get(self, path: Annotated[str, Doc('\\n                The URL path to be used for this *path operation*.\\n\\n                For example, in `http://example.com/items`, the path is `/items`.\\n                ')], *, response_model: Annotated[Any, Doc(\"\\n                The type to use for the response.\\n\\n                It could be any valid Pydantic *field* type. So, it doesn't have to\\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\\n                etc.\\n\\n                It will be used for:\\n\\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\\n                    show it as the response (JSON Schema).\\n                * Serialization: you could return an arbitrary object and the\\n                    `response_model` would be used to serialize that object into the\\n                    corresponding JSON.\\n                * Filtering: the JSON sent to the client will only contain the data\\n                    (fields) defined in the `response_model`. If you returned an object\\n                    that contains an attribute `password` but the `response_model` does\\n                    not include that field, the JSON sent to the client would not have\\n                    that `password`.\\n                * Validation: whatever you return will be serialized with the\\n                    `response_model`, converting any data as necessary to generate the\\n                    corresponding JSON. But if the data in the object returned is not\\n                    valid, that would mean a violation of the contract with the client,\\n                    so it's an error from the API developer. So, FastAPI will raise an\\n                    error and return a 500 error code (Internal Server Error).\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\\n                \")]=Default(None), status_code: Annotated[Optional[int], Doc('\\n                The default status code to be used for the response.\\n\\n                You could override the status code by returning a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\\n                ')]=None, tags: Annotated[Optional[List[Union[str, Enum]]], Doc('\\n                A list of tags to be applied to the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\\n                ')]=None, dependencies: Annotated[Optional[Sequence[Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to the\\n                *path operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\\n                ')]=None, summary: Annotated[Optional[str], Doc('\\n                A summary for the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, description: Annotated[Optional[str], Doc('\\n                A description for the *path operation*.\\n\\n                If not provided, it will be extracted automatically from the docstring\\n                of the *path operation function*.\\n\\n                It can contain Markdown.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, response_description: Annotated[str, Doc('\\n                The description for the default response.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]='Successful Response', responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses that could be returned by this *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark this *path operation* as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, operation_id: Annotated[Optional[str], Doc('\\n                Custom operation ID to be used by this *path operation*.\\n\\n                By default, it is generated automatically.\\n\\n                If you provide a custom operation ID, you need to make sure it is\\n                unique for the whole API.\\n\\n                You can customize the\\n                operation ID generation with the parameter\\n                `generate_unique_id_function` in the `FastAPI` class.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=None, response_model_include: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to include only certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_exclude: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to exclude certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_by_alias: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response model\\n                should be serialized by alias when an alias is used.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=True, response_model_exclude_unset: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that were not set and\\n                have their default values. This is different from\\n                `response_model_exclude_defaults` in that if the fields are set,\\n                they will be included in the response, even if the value is the same\\n                as the default.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_defaults: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that have the same value\\n                as the default. This is different from `response_model_exclude_unset`\\n                in that if the fields are set but contain the same default values,\\n                they will be excluded from the response.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_none: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data should\\n                exclude fields set to `None`.\\n\\n                This is much simpler (less smart) than `response_model_exclude_unset`\\n                and `response_model_exclude_defaults`. You probably want to use one of\\n                those two instead of this one, as those allow returning `None` values\\n                when it makes sense.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\\n                ')]=False, include_in_schema: Annotated[bool, Doc('\\n                Include this *path operation* in the generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\\n                ')]=True, response_class: Annotated[Type[Response], Doc('\\n                Response class to be used for this *path operation*.\\n\\n                This will not be used if you return a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\\n                ')]=Default(JSONResponse), name: Annotated[Optional[str], Doc('\\n                Name for this *path operation*. Only used internally.\\n                ')]=None, callbacks: Annotated[Optional[List[BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")]=None, openapi_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n                Extra metadata to be included in the OpenAPI schema for this *path\\n                operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\\n                ')]=None, generate_unique_id_function: Annotated[Callable[[routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=Default(generate_unique_id)) -> Callable[[DecoratedCallable], DecoratedCallable]:\n    \"\"\"\n        Add a *path operation* using an HTTP GET operation.\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI\n\n        app = FastAPI()\n\n        @app.get(\"/items/\")\n        def read_items():\n            return [{\"name\": \"Empanada\"}, {\"name\": \"Arepa\"}]\n        ```\n        \"\"\"\n    return self.router.get(path, response_model=response_model, status_code=status_code, tags=tags, dependencies=dependencies, summary=summary, description=description, response_description=response_description, responses=responses, deprecated=deprecated, operation_id=operation_id, response_model_include=response_model_include, response_model_exclude=response_model_exclude, response_model_by_alias=response_model_by_alias, response_model_exclude_unset=response_model_exclude_unset, response_model_exclude_defaults=response_model_exclude_defaults, response_model_exclude_none=response_model_exclude_none, include_in_schema=include_in_schema, response_class=response_class, name=name, callbacks=callbacks, openapi_extra=openapi_extra, generate_unique_id_function=generate_unique_id_function)"
        }
      ]
    },
    {
      "name": "_annotation_is_sequence",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 540,
      "end_line_number": 543,
      "source_code": "def _annotation_is_sequence(annotation: Union[Type[Any], None]) -> bool:\n    if lenient_issubclass(annotation, (str, bytes)):\n        return False\n    return lenient_issubclass(annotation, sequence_types)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "annotation"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "field_annotation_is_sequence",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 546,
      "end_line_number": 555,
      "source_code": "def field_annotation_is_sequence(annotation: Union[Type[Any], None]) -> bool:\n    origin = get_origin(annotation)\n    if origin is Union or origin is UnionType:\n        for arg in get_args(annotation):\n            if field_annotation_is_sequence(arg):\n                return True\n        return False\n    return _annotation_is_sequence(annotation) or _annotation_is_sequence(\n        get_origin(annotation)\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "annotation"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "_annotation_is_sequence",
          "body": "def _annotation_is_sequence(annotation: Union[Type[Any], None]) -> bool:\n    if lenient_issubclass(annotation, (str, bytes)):\n        return False\n    return lenient_issubclass(annotation, sequence_types)"
        },
        {
          "name": "_annotation_is_sequence",
          "body": "def _annotation_is_sequence(annotation: Union[Type[Any], None]) -> bool:\n    if lenient_issubclass(annotation, (str, bytes)):\n        return False\n    return lenient_issubclass(annotation, sequence_types)"
        },
        {
          "name": "field_annotation_is_sequence",
          "body": "def field_annotation_is_sequence(annotation: Union[Type[Any], None]) -> bool:\n    origin = get_origin(annotation)\n    if origin is Union or origin is UnionType:\n        for arg in get_args(annotation):\n            if field_annotation_is_sequence(arg):\n                return True\n        return False\n    return _annotation_is_sequence(annotation) or _annotation_is_sequence(get_origin(annotation))"
        }
      ]
    },
    {
      "name": "value_is_sequence",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 558,
      "end_line_number": 559,
      "source_code": "def value_is_sequence(value: Any) -> bool:\n    return isinstance(value, sequence_types) and not isinstance(value, (str, bytes))",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "value"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_annotation_is_complex",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 562,
      "end_line_number": 567,
      "source_code": "def _annotation_is_complex(annotation: Union[Type[Any], None]) -> bool:\n    return (\n        lenient_issubclass(annotation, (BaseModel, Mapping, UploadFile))\n        or _annotation_is_sequence(annotation)\n        or is_dataclass(annotation)\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "annotation"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "_annotation_is_sequence",
          "body": "def _annotation_is_sequence(annotation: Union[Type[Any], None]) -> bool:\n    if lenient_issubclass(annotation, (str, bytes)):\n        return False\n    return lenient_issubclass(annotation, sequence_types)"
        }
      ]
    },
    {
      "name": "field_annotation_is_complex",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 570,
      "end_line_number": 580,
      "source_code": "def field_annotation_is_complex(annotation: Union[Type[Any], None]) -> bool:\n    origin = get_origin(annotation)\n    if origin is Union or origin is UnionType:\n        return any(field_annotation_is_complex(arg) for arg in get_args(annotation))\n\n    return (\n        _annotation_is_complex(annotation)\n        or _annotation_is_complex(origin)\n        or hasattr(origin, \"__pydantic_core_schema__\")\n        or hasattr(origin, \"__get_pydantic_core_schema__\")\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "annotation"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "_annotation_is_complex",
          "body": "def _annotation_is_complex(annotation: Union[Type[Any], None]) -> bool:\n    return lenient_issubclass(annotation, (BaseModel, Mapping, UploadFile)) or _annotation_is_sequence(annotation) or is_dataclass(annotation)"
        },
        {
          "name": "_annotation_is_complex",
          "body": "def _annotation_is_complex(annotation: Union[Type[Any], None]) -> bool:\n    return lenient_issubclass(annotation, (BaseModel, Mapping, UploadFile)) or _annotation_is_sequence(annotation) or is_dataclass(annotation)"
        },
        {
          "name": "field_annotation_is_complex",
          "body": "def field_annotation_is_complex(annotation: Union[Type[Any], None]) -> bool:\n    origin = get_origin(annotation)\n    if origin is Union or origin is UnionType:\n        return any((field_annotation_is_complex(arg) for arg in get_args(annotation)))\n    return _annotation_is_complex(annotation) or _annotation_is_complex(origin) or hasattr(origin, '__pydantic_core_schema__') or hasattr(origin, '__get_pydantic_core_schema__')"
        }
      ]
    },
    {
      "name": "field_annotation_is_scalar",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 583,
      "end_line_number": 585,
      "source_code": "def field_annotation_is_scalar(annotation: Any) -> bool:\n    # handle Ellipsis here to make tuple[int, ...] work nicely\n    return annotation is Ellipsis or not field_annotation_is_complex(annotation)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "annotation"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "field_annotation_is_complex",
          "body": "def field_annotation_is_complex(annotation: Union[Type[Any], None]) -> bool:\n    origin = get_origin(annotation)\n    if origin is Union or origin is UnionType:\n        return any((field_annotation_is_complex(arg) for arg in get_args(annotation)))\n    return _annotation_is_complex(annotation) or _annotation_is_complex(origin) or hasattr(origin, '__pydantic_core_schema__') or hasattr(origin, '__get_pydantic_core_schema__')"
        }
      ]
    },
    {
      "name": "field_annotation_is_scalar_sequence",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 588,
      "end_line_number": 602,
      "source_code": "def field_annotation_is_scalar_sequence(annotation: Union[Type[Any], None]) -> bool:\n    origin = get_origin(annotation)\n    if origin is Union or origin is UnionType:\n        at_least_one_scalar_sequence = False\n        for arg in get_args(annotation):\n            if field_annotation_is_scalar_sequence(arg):\n                at_least_one_scalar_sequence = True\n                continue\n            elif not field_annotation_is_scalar(arg):\n                return False\n        return at_least_one_scalar_sequence\n    return field_annotation_is_sequence(annotation) and all(\n        field_annotation_is_scalar(sub_annotation)\n        for sub_annotation in get_args(annotation)\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "annotation"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "field_annotation_is_sequence",
          "body": "def field_annotation_is_sequence(annotation: Union[Type[Any], None]) -> bool:\n    origin = get_origin(annotation)\n    if origin is Union or origin is UnionType:\n        for arg in get_args(annotation):\n            if field_annotation_is_sequence(arg):\n                return True\n        return False\n    return _annotation_is_sequence(annotation) or _annotation_is_sequence(get_origin(annotation))"
        },
        {
          "name": "field_annotation_is_scalar_sequence",
          "body": "def field_annotation_is_scalar_sequence(annotation: Union[Type[Any], None]) -> bool:\n    origin = get_origin(annotation)\n    if origin is Union or origin is UnionType:\n        at_least_one_scalar_sequence = False\n        for arg in get_args(annotation):\n            if field_annotation_is_scalar_sequence(arg):\n                at_least_one_scalar_sequence = True\n                continue\n            elif not field_annotation_is_scalar(arg):\n                return False\n        return at_least_one_scalar_sequence\n    return field_annotation_is_sequence(annotation) and all((field_annotation_is_scalar(sub_annotation) for sub_annotation in get_args(annotation)))"
        },
        {
          "name": "field_annotation_is_scalar",
          "body": "def field_annotation_is_scalar(annotation: Any) -> bool:\n    return annotation is Ellipsis or not field_annotation_is_complex(annotation)"
        },
        {
          "name": "field_annotation_is_scalar",
          "body": "def field_annotation_is_scalar(annotation: Any) -> bool:\n    return annotation is Ellipsis or not field_annotation_is_complex(annotation)"
        }
      ]
    },
    {
      "name": "is_bytes_or_nonable_bytes_annotation",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 605,
      "end_line_number": 613,
      "source_code": "def is_bytes_or_nonable_bytes_annotation(annotation: Any) -> bool:\n    if lenient_issubclass(annotation, bytes):\n        return True\n    origin = get_origin(annotation)\n    if origin is Union or origin is UnionType:\n        for arg in get_args(annotation):\n            if lenient_issubclass(arg, bytes):\n                return True\n    return False",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "annotation"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "is_uploadfile_or_nonable_uploadfile_annotation",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 616,
      "end_line_number": 624,
      "source_code": "def is_uploadfile_or_nonable_uploadfile_annotation(annotation: Any) -> bool:\n    if lenient_issubclass(annotation, UploadFile):\n        return True\n    origin = get_origin(annotation)\n    if origin is Union or origin is UnionType:\n        for arg in get_args(annotation):\n            if lenient_issubclass(arg, UploadFile):\n                return True\n    return False",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "annotation"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "is_bytes_sequence_annotation",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 627,
      "end_line_number": 639,
      "source_code": "def is_bytes_sequence_annotation(annotation: Any) -> bool:\n    origin = get_origin(annotation)\n    if origin is Union or origin is UnionType:\n        at_least_one = False\n        for arg in get_args(annotation):\n            if is_bytes_sequence_annotation(arg):\n                at_least_one = True\n                continue\n        return at_least_one\n    return field_annotation_is_sequence(annotation) and all(\n        is_bytes_or_nonable_bytes_annotation(sub_annotation)\n        for sub_annotation in get_args(annotation)\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "annotation"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "field_annotation_is_sequence",
          "body": "def field_annotation_is_sequence(annotation: Union[Type[Any], None]) -> bool:\n    origin = get_origin(annotation)\n    if origin is Union or origin is UnionType:\n        for arg in get_args(annotation):\n            if field_annotation_is_sequence(arg):\n                return True\n        return False\n    return _annotation_is_sequence(annotation) or _annotation_is_sequence(get_origin(annotation))"
        },
        {
          "name": "is_bytes_sequence_annotation",
          "body": "def is_bytes_sequence_annotation(annotation: Any) -> bool:\n    origin = get_origin(annotation)\n    if origin is Union or origin is UnionType:\n        at_least_one = False\n        for arg in get_args(annotation):\n            if is_bytes_sequence_annotation(arg):\n                at_least_one = True\n                continue\n        return at_least_one\n    return field_annotation_is_sequence(annotation) and all((is_bytes_or_nonable_bytes_annotation(sub_annotation) for sub_annotation in get_args(annotation)))"
        },
        {
          "name": "is_bytes_or_nonable_bytes_annotation",
          "body": "def is_bytes_or_nonable_bytes_annotation(annotation: Any) -> bool:\n    if lenient_issubclass(annotation, bytes):\n        return True\n    origin = get_origin(annotation)\n    if origin is Union or origin is UnionType:\n        for arg in get_args(annotation):\n            if lenient_issubclass(arg, bytes):\n                return True\n    return False"
        }
      ]
    },
    {
      "name": "is_uploadfile_sequence_annotation",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 642,
      "end_line_number": 654,
      "source_code": "def is_uploadfile_sequence_annotation(annotation: Any) -> bool:\n    origin = get_origin(annotation)\n    if origin is Union or origin is UnionType:\n        at_least_one = False\n        for arg in get_args(annotation):\n            if is_uploadfile_sequence_annotation(arg):\n                at_least_one = True\n                continue\n        return at_least_one\n    return field_annotation_is_sequence(annotation) and all(\n        is_uploadfile_or_nonable_uploadfile_annotation(sub_annotation)\n        for sub_annotation in get_args(annotation)\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "annotation"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "field_annotation_is_sequence",
          "body": "def field_annotation_is_sequence(annotation: Union[Type[Any], None]) -> bool:\n    origin = get_origin(annotation)\n    if origin is Union or origin is UnionType:\n        for arg in get_args(annotation):\n            if field_annotation_is_sequence(arg):\n                return True\n        return False\n    return _annotation_is_sequence(annotation) or _annotation_is_sequence(get_origin(annotation))"
        },
        {
          "name": "is_uploadfile_sequence_annotation",
          "body": "def is_uploadfile_sequence_annotation(annotation: Any) -> bool:\n    origin = get_origin(annotation)\n    if origin is Union or origin is UnionType:\n        at_least_one = False\n        for arg in get_args(annotation):\n            if is_uploadfile_sequence_annotation(arg):\n                at_least_one = True\n                continue\n        return at_least_one\n    return field_annotation_is_sequence(annotation) and all((is_uploadfile_or_nonable_uploadfile_annotation(sub_annotation) for sub_annotation in get_args(annotation)))"
        },
        {
          "name": "is_uploadfile_or_nonable_uploadfile_annotation",
          "body": "def is_uploadfile_or_nonable_uploadfile_annotation(annotation: Any) -> bool:\n    if lenient_issubclass(annotation, UploadFile):\n        return True\n    origin = get_origin(annotation)\n    if origin is Union or origin is UnionType:\n        for arg in get_args(annotation):\n            if lenient_issubclass(arg, UploadFile):\n                return True\n    return False"
        }
      ]
    },
    {
      "name": "get_cached_model_fields",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 658,
      "end_line_number": 659,
      "source_code": "def get_cached_model_fields(model: Type[BaseModel]) -> List[ModelField]:\n    return get_model_fields(model)",
      "docstring": null,
      "decorators": [
        "lru_cache"
      ],
      "arguments": [
        "model"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_model_fields",
          "body": "def get_model_fields(model: Type[BaseModel]) -> List[ModelField]:\n    return [ModelField(field_info=field_info, name=name) for name, field_info in model.model_fields.items()]"
        }
      ]
    },
    {
      "name": "get_annotation_from_field_info",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 167,
      "end_line_number": 170,
      "source_code": "def get_annotation_from_field_info(\n        annotation: Any, field_info: FieldInfo, field_name: str\n    ) -> Any:\n        return annotation",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "annotation",
        "field_info",
        "field_name"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_normalize_errors",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 172,
      "end_line_number": 173,
      "source_code": "def _normalize_errors(errors: Sequence[Any]) -> List[Dict[str, Any]]:\n        return errors",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "errors"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_model_rebuild",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 175,
      "end_line_number": 176,
      "source_code": "def _model_rebuild(model: Type[BaseModel]) -> None:\n        model.model_rebuild()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "model"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_model_dump",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 178,
      "end_line_number": 181,
      "source_code": "def _model_dump(\n        model: BaseModel, mode: Literal[\"json\", \"python\"] = \"json\", **kwargs: Any\n    ) -> Any:\n        return model.model_dump(mode=mode, **kwargs)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "model",
        "mode"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_get_model_config",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 183,
      "end_line_number": 184,
      "source_code": "def _get_model_config(model: BaseModel) -> Any:\n        return model.model_config",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "model"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "get_schema_from_model_field",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 186,
      "end_line_number": 207,
      "source_code": "def get_schema_from_model_field(\n        *,\n        field: ModelField,\n        schema_generator: GenerateJsonSchema,\n        model_name_map: ModelNameMap,\n        field_mapping: Dict[\n            Tuple[ModelField, Literal[\"validation\", \"serialization\"]], JsonSchemaValue\n        ],\n        separate_input_output_schemas: bool = True,\n    ) -> Dict[str, Any]:\n        override_mode: Union[Literal[\"validation\"], None] = (\n            None if separate_input_output_schemas else \"validation\"\n        )\n        # This expects that GenerateJsonSchema was already used to generate the definitions\n        json_schema = field_mapping[(field, override_mode or field.mode)]\n        if \"$ref\" not in json_schema:\n            # TODO remove when deprecating Pydantic v1\n            # Ref: https://github.com/pydantic/pydantic/blob/d61792cc42c80b13b23e3ffa74bc37ec7c77f7d1/pydantic/schema.py#L207\n            json_schema[\"title\"] = (\n                field.field_info.title or field.alias.title().replace(\"_\", \" \")\n            )\n        return json_schema",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "get_compat_model_name_map",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 209,
      "end_line_number": 210,
      "source_code": "def get_compat_model_name_map(fields: List[ModelField]) -> ModelNameMap:\n        return {}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "fields"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "get_definitions",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 212,
      "end_line_number": 234,
      "source_code": "def get_definitions(\n        *,\n        fields: List[ModelField],\n        schema_generator: GenerateJsonSchema,\n        model_name_map: ModelNameMap,\n        separate_input_output_schemas: bool = True,\n    ) -> Tuple[\n        Dict[\n            Tuple[ModelField, Literal[\"validation\", \"serialization\"]], JsonSchemaValue\n        ],\n        Dict[str, Dict[str, Any]],\n    ]:\n        override_mode: Union[Literal[\"validation\"], None] = (\n            None if separate_input_output_schemas else \"validation\"\n        )\n        inputs = [\n            (field, override_mode or field.mode, field._type_adapter.core_schema)\n            for field in fields\n        ]\n        field_mapping, definitions = schema_generator.generate_definitions(\n            inputs=inputs\n        )\n        return field_mapping, definitions",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "is_scalar_field",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 236,
      "end_line_number": 241,
      "source_code": "def is_scalar_field(field: ModelField) -> bool:\n        from fastapi import params\n\n        return field_annotation_is_scalar(\n            field.field_info.annotation\n        ) and not isinstance(field.field_info, params.Body)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "field"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "field_annotation_is_scalar",
          "body": "def field_annotation_is_scalar(annotation: Any) -> bool:\n    return annotation is Ellipsis or not field_annotation_is_complex(annotation)"
        }
      ]
    },
    {
      "name": "is_sequence_field",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 243,
      "end_line_number": 244,
      "source_code": "def is_sequence_field(field: ModelField) -> bool:\n        return field_annotation_is_sequence(field.field_info.annotation)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "field"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "field_annotation_is_sequence",
          "body": "def field_annotation_is_sequence(annotation: Union[Type[Any], None]) -> bool:\n    origin = get_origin(annotation)\n    if origin is Union or origin is UnionType:\n        for arg in get_args(annotation):\n            if field_annotation_is_sequence(arg):\n                return True\n        return False\n    return _annotation_is_sequence(annotation) or _annotation_is_sequence(get_origin(annotation))"
        }
      ]
    },
    {
      "name": "is_scalar_sequence_field",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 246,
      "end_line_number": 247,
      "source_code": "def is_scalar_sequence_field(field: ModelField) -> bool:\n        return field_annotation_is_scalar_sequence(field.field_info.annotation)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "field"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "field_annotation_is_scalar_sequence",
          "body": "def field_annotation_is_scalar_sequence(annotation: Union[Type[Any], None]) -> bool:\n    origin = get_origin(annotation)\n    if origin is Union or origin is UnionType:\n        at_least_one_scalar_sequence = False\n        for arg in get_args(annotation):\n            if field_annotation_is_scalar_sequence(arg):\n                at_least_one_scalar_sequence = True\n                continue\n            elif not field_annotation_is_scalar(arg):\n                return False\n        return at_least_one_scalar_sequence\n    return field_annotation_is_sequence(annotation) and all((field_annotation_is_scalar(sub_annotation) for sub_annotation in get_args(annotation)))"
        }
      ]
    },
    {
      "name": "is_bytes_field",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 249,
      "end_line_number": 250,
      "source_code": "def is_bytes_field(field: ModelField) -> bool:\n        return is_bytes_or_nonable_bytes_annotation(field.type_)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "field"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "is_bytes_or_nonable_bytes_annotation",
          "body": "def is_bytes_or_nonable_bytes_annotation(annotation: Any) -> bool:\n    if lenient_issubclass(annotation, bytes):\n        return True\n    origin = get_origin(annotation)\n    if origin is Union or origin is UnionType:\n        for arg in get_args(annotation):\n            if lenient_issubclass(arg, bytes):\n                return True\n    return False"
        }
      ]
    },
    {
      "name": "is_bytes_sequence_field",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 252,
      "end_line_number": 253,
      "source_code": "def is_bytes_sequence_field(field: ModelField) -> bool:\n        return is_bytes_sequence_annotation(field.type_)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "field"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "is_bytes_sequence_annotation",
          "body": "def is_bytes_sequence_annotation(annotation: Any) -> bool:\n    origin = get_origin(annotation)\n    if origin is Union or origin is UnionType:\n        at_least_one = False\n        for arg in get_args(annotation):\n            if is_bytes_sequence_annotation(arg):\n                at_least_one = True\n                continue\n        return at_least_one\n    return field_annotation_is_sequence(annotation) and all((is_bytes_or_nonable_bytes_annotation(sub_annotation) for sub_annotation in get_args(annotation)))"
        }
      ]
    },
    {
      "name": "copy_field_info",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 255,
      "end_line_number": 261,
      "source_code": "def copy_field_info(*, field_info: FieldInfo, annotation: Any) -> FieldInfo:\n        cls = type(field_info)\n        merged_field_info = cls.from_annotation(annotation)\n        new_field_info = copy(field_info)\n        new_field_info.metadata = merged_field_info.metadata\n        new_field_info.annotation = merged_field_info.annotation\n        return new_field_info",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "serialize_sequence_value",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 263,
      "end_line_number": 268,
      "source_code": "def serialize_sequence_value(*, field: ModelField, value: Any) -> Sequence[Any]:\n        origin_type = (\n            get_origin(field.field_info.annotation) or field.field_info.annotation\n        )\n        assert issubclass(origin_type, sequence_types)  # type: ignore[arg-type]\n        return sequence_annotation_to_type[origin_type](value)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [
        "assert issubclass(origin_type, sequence_types)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "get_missing_field_error",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 270,
      "end_line_number": 275,
      "source_code": "def get_missing_field_error(loc: Tuple[str, ...]) -> Dict[str, Any]:\n        error = ValidationError.from_exception_data(\n            \"Field required\", [{\"type\": \"missing\", \"loc\": loc, \"input\": {}}]\n        ).errors(include_url=False)[0]\n        error[\"input\"] = None\n        return error",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loc"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "create_body_model",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 277,
      "end_line_number": 282,
      "source_code": "def create_body_model(\n        *, fields: Sequence[ModelField], model_name: str\n    ) -> Type[BaseModel]:\n        field_params = {f.name: (f.field_info.annotation, f.field_info) for f in fields}\n        BodyModel: Type[BaseModel] = create_model(model_name, **field_params)  # type: ignore[call-overload]\n        return BodyModel",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "get_model_fields",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 284,
      "end_line_number": 288,
      "source_code": "def get_model_fields(model: Type[BaseModel]) -> List[ModelField]:\n        return [\n            ModelField(field_info=field_info, name=name)\n            for name, field_info in model.model_fields.items()\n        ]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "model"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "with_info_plain_validator_function",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 370,
      "end_line_number": 377,
      "source_code": "def with_info_plain_validator_function(  # type: ignore[misc]\n        function: Callable[..., Any],\n        *,\n        ref: Union[str, None] = None,\n        metadata: Any = None,\n        serialization: Any = None,\n    ) -> Any:\n        return {}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "function"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "get_model_definitions",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 379,
      "end_line_number": 394,
      "source_code": "def get_model_definitions(\n        *,\n        flat_models: Set[Union[Type[BaseModel], Type[Enum]]],\n        model_name_map: Dict[Union[Type[BaseModel], Type[Enum]], str],\n    ) -> Dict[str, Any]:\n        definitions: Dict[str, Dict[str, Any]] = {}\n        for model in flat_models:\n            m_schema, m_definitions, m_nested_models = model_process_schema(\n                model, model_name_map=model_name_map, ref_prefix=REF_PREFIX\n            )\n            definitions.update(m_definitions)\n            model_name = model_name_map[model]\n            if \"description\" in m_schema:\n                m_schema[\"description\"] = m_schema[\"description\"].split(\"\\f\")[0]\n            definitions[model_name] = m_schema\n        return definitions",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "is_pv1_scalar_field",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 396,
      "end_line_number": 415,
      "source_code": "def is_pv1_scalar_field(field: ModelField) -> bool:\n        from fastapi import params\n\n        field_info = field.field_info\n        if not (\n            field.shape == SHAPE_SINGLETON  # type: ignore[attr-defined]\n            and not lenient_issubclass(field.type_, BaseModel)\n            and not lenient_issubclass(field.type_, dict)\n            and not field_annotation_is_sequence(field.type_)\n            and not is_dataclass(field.type_)\n            and not isinstance(field_info, params.Body)\n        ):\n            return False\n        if field.sub_fields:  # type: ignore[attr-defined]\n            if not all(\n                is_pv1_scalar_field(f)\n                for f in field.sub_fields  # type: ignore[attr-defined]\n            ):\n                return False\n        return True",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "field"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "field_annotation_is_sequence",
          "body": "def field_annotation_is_sequence(annotation: Union[Type[Any], None]) -> bool:\n    origin = get_origin(annotation)\n    if origin is Union or origin is UnionType:\n        for arg in get_args(annotation):\n            if field_annotation_is_sequence(arg):\n                return True\n        return False\n    return _annotation_is_sequence(annotation) or _annotation_is_sequence(get_origin(annotation))"
        },
        {
          "name": "is_pv1_scalar_field",
          "body": "def is_pv1_scalar_field(field: ModelField) -> bool:\n    from fastapi import params\n    field_info = field.field_info\n    if not (field.shape == SHAPE_SINGLETON and (not lenient_issubclass(field.type_, BaseModel)) and (not lenient_issubclass(field.type_, dict)) and (not field_annotation_is_sequence(field.type_)) and (not is_dataclass(field.type_)) and (not isinstance(field_info, params.Body))):\n        return False\n    if field.sub_fields:\n        if not all((is_pv1_scalar_field(f) for f in field.sub_fields)):\n            return False\n    return True"
        }
      ]
    },
    {
      "name": "is_pv1_scalar_sequence_field",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 417,
      "end_line_number": 428,
      "source_code": "def is_pv1_scalar_sequence_field(field: ModelField) -> bool:\n        if (field.shape in sequence_shapes) and not lenient_issubclass(  # type: ignore[attr-defined]\n            field.type_, BaseModel\n        ):\n            if field.sub_fields is not None:  # type: ignore[attr-defined]\n                for sub_field in field.sub_fields:  # type: ignore[attr-defined]\n                    if not is_pv1_scalar_field(sub_field):\n                        return False\n            return True\n        if _annotation_is_sequence(field.type_):\n            return True\n        return False",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "field"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "_annotation_is_sequence",
          "body": "def _annotation_is_sequence(annotation: Union[Type[Any], None]) -> bool:\n    if lenient_issubclass(annotation, (str, bytes)):\n        return False\n    return lenient_issubclass(annotation, sequence_types)"
        },
        {
          "name": "is_pv1_scalar_field",
          "body": "def is_pv1_scalar_field(field: ModelField) -> bool:\n    from fastapi import params\n    field_info = field.field_info\n    if not (field.shape == SHAPE_SINGLETON and (not lenient_issubclass(field.type_, BaseModel)) and (not lenient_issubclass(field.type_, dict)) and (not field_annotation_is_sequence(field.type_)) and (not is_dataclass(field.type_)) and (not isinstance(field_info, params.Body))):\n        return False\n    if field.sub_fields:\n        if not all((is_pv1_scalar_field(f) for f in field.sub_fields)):\n            return False\n    return True"
        }
      ]
    },
    {
      "name": "_normalize_errors",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 430,
      "end_line_number": 442,
      "source_code": "def _normalize_errors(errors: Sequence[Any]) -> List[Dict[str, Any]]:\n        use_errors: List[Any] = []\n        for error in errors:\n            if isinstance(error, ErrorWrapper):\n                new_errors = ValidationError(  # type: ignore[call-arg]\n                    errors=[error], model=RequestErrorModel\n                ).errors()\n                use_errors.extend(new_errors)\n            elif isinstance(error, list):\n                use_errors.extend(_normalize_errors(error))\n            else:\n                use_errors.append(error)\n        return use_errors",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "errors"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "_normalize_errors",
          "body": "def _normalize_errors(errors: Sequence[Any]) -> List[Dict[str, Any]]:\n    return errors"
        }
      ]
    },
    {
      "name": "_model_rebuild",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 444,
      "end_line_number": 445,
      "source_code": "def _model_rebuild(model: Type[BaseModel]) -> None:\n        model.update_forward_refs()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "model"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_model_dump",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 447,
      "end_line_number": 450,
      "source_code": "def _model_dump(\n        model: BaseModel, mode: Literal[\"json\", \"python\"] = \"json\", **kwargs: Any\n    ) -> Any:\n        return model.dict(**kwargs)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "model",
        "mode"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_get_model_config",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 452,
      "end_line_number": 453,
      "source_code": "def _get_model_config(model: BaseModel) -> Any:\n        return model.__config__",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "model"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "get_schema_from_model_field",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 455,
      "end_line_number": 468,
      "source_code": "def get_schema_from_model_field(\n        *,\n        field: ModelField,\n        schema_generator: GenerateJsonSchema,\n        model_name_map: ModelNameMap,\n        field_mapping: Dict[\n            Tuple[ModelField, Literal[\"validation\", \"serialization\"]], JsonSchemaValue\n        ],\n        separate_input_output_schemas: bool = True,\n    ) -> Dict[str, Any]:\n        # This expects that GenerateJsonSchema was already used to generate the definitions\n        return field_schema(  # type: ignore[no-any-return]\n            field, model_name_map=model_name_map, ref_prefix=REF_PREFIX\n        )[0]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "get_compat_model_name_map",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 470,
      "end_line_number": 472,
      "source_code": "def get_compat_model_name_map(fields: List[ModelField]) -> ModelNameMap:\n        models = get_flat_models_from_fields(fields, known_models=set())\n        return get_model_name_map(models)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "fields"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "get_definitions",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 474,
      "end_line_number": 489,
      "source_code": "def get_definitions(\n        *,\n        fields: List[ModelField],\n        schema_generator: GenerateJsonSchema,\n        model_name_map: ModelNameMap,\n        separate_input_output_schemas: bool = True,\n    ) -> Tuple[\n        Dict[\n            Tuple[ModelField, Literal[\"validation\", \"serialization\"]], JsonSchemaValue\n        ],\n        Dict[str, Dict[str, Any]],\n    ]:\n        models = get_flat_models_from_fields(fields, known_models=set())\n        return {}, get_model_definitions(\n            flat_models=models, model_name_map=model_name_map\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_model_definitions",
          "body": "def get_model_definitions(*, flat_models: Set[Union[Type[BaseModel], Type[Enum]]], model_name_map: Dict[Union[Type[BaseModel], Type[Enum]], str]) -> Dict[str, Any]:\n    definitions: Dict[str, Dict[str, Any]] = {}\n    for model in flat_models:\n        m_schema, m_definitions, m_nested_models = model_process_schema(model, model_name_map=model_name_map, ref_prefix=REF_PREFIX)\n        definitions.update(m_definitions)\n        model_name = model_name_map[model]\n        if 'description' in m_schema:\n            m_schema['description'] = m_schema['description'].split('\\x0c')[0]\n        definitions[model_name] = m_schema\n    return definitions"
        }
      ]
    },
    {
      "name": "is_scalar_field",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 491,
      "end_line_number": 492,
      "source_code": "def is_scalar_field(field: ModelField) -> bool:\n        return is_pv1_scalar_field(field)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "field"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "is_pv1_scalar_field",
          "body": "def is_pv1_scalar_field(field: ModelField) -> bool:\n    from fastapi import params\n    field_info = field.field_info\n    if not (field.shape == SHAPE_SINGLETON and (not lenient_issubclass(field.type_, BaseModel)) and (not lenient_issubclass(field.type_, dict)) and (not field_annotation_is_sequence(field.type_)) and (not is_dataclass(field.type_)) and (not isinstance(field_info, params.Body))):\n        return False\n    if field.sub_fields:\n        if not all((is_pv1_scalar_field(f) for f in field.sub_fields)):\n            return False\n    return True"
        }
      ]
    },
    {
      "name": "is_sequence_field",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 494,
      "end_line_number": 495,
      "source_code": "def is_sequence_field(field: ModelField) -> bool:\n        return field.shape in sequence_shapes or _annotation_is_sequence(field.type_)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "field"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "_annotation_is_sequence",
          "body": "def _annotation_is_sequence(annotation: Union[Type[Any], None]) -> bool:\n    if lenient_issubclass(annotation, (str, bytes)):\n        return False\n    return lenient_issubclass(annotation, sequence_types)"
        }
      ]
    },
    {
      "name": "is_scalar_sequence_field",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 497,
      "end_line_number": 498,
      "source_code": "def is_scalar_sequence_field(field: ModelField) -> bool:\n        return is_pv1_scalar_sequence_field(field)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "field"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "is_pv1_scalar_sequence_field",
          "body": "def is_pv1_scalar_sequence_field(field: ModelField) -> bool:\n    if field.shape in sequence_shapes and (not lenient_issubclass(field.type_, BaseModel)):\n        if field.sub_fields is not None:\n            for sub_field in field.sub_fields:\n                if not is_pv1_scalar_field(sub_field):\n                    return False\n        return True\n    if _annotation_is_sequence(field.type_):\n        return True\n    return False"
        }
      ]
    },
    {
      "name": "is_bytes_field",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 500,
      "end_line_number": 501,
      "source_code": "def is_bytes_field(field: ModelField) -> bool:\n        return lenient_issubclass(field.type_, bytes)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "field"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "is_bytes_sequence_field",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 503,
      "end_line_number": 504,
      "source_code": "def is_bytes_sequence_field(field: ModelField) -> bool:\n        return field.shape in sequence_shapes and lenient_issubclass(field.type_, bytes)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "field"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "copy_field_info",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 506,
      "end_line_number": 507,
      "source_code": "def copy_field_info(*, field_info: FieldInfo, annotation: Any) -> FieldInfo:\n        return copy(field_info)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "serialize_sequence_value",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 509,
      "end_line_number": 510,
      "source_code": "def serialize_sequence_value(*, field: ModelField, value: Any) -> Sequence[Any]:\n        return sequence_shape_to_type[field.shape](value)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "get_missing_field_error",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 512,
      "end_line_number": 515,
      "source_code": "def get_missing_field_error(loc: Tuple[str, ...]) -> Dict[str, Any]:\n        missing_field_error = ErrorWrapper(MissingError(), loc=loc)  # type: ignore[call-arg]\n        new_error = ValidationError([missing_field_error], RequestErrorModel)\n        return new_error.errors()[0]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "loc"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "new_error.errors",
          "body": "def errors(self) -> Sequence[Any]:\n    return self._errors"
        }
      ]
    },
    {
      "name": "create_body_model",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 517,
      "end_line_number": 523,
      "source_code": "def create_body_model(\n        *, fields: Sequence[ModelField], model_name: str\n    ) -> Type[BaseModel]:\n        BodyModel = create_model(model_name)\n        for f in fields:\n            BodyModel.__fields__[f.name] = f  # type: ignore[index]\n        return BodyModel",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "get_model_fields",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 525,
      "end_line_number": 526,
      "source_code": "def get_model_fields(model: Type[BaseModel]) -> List[ModelField]:\n        return list(model.__fields__.values())",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "model"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "alias",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 94,
      "end_line_number": 96,
      "source_code": "def alias(self) -> str:\n            a = self.field_info.alias\n            return a if a is not None else self.name",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "required",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 99,
      "end_line_number": 100,
      "source_code": "def required(self) -> bool:\n            return self.field_info.is_required()",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "default",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 103,
      "end_line_number": 104,
      "source_code": "def default(self) -> Any:\n            return self.get_default()",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.get_default",
          "body": "def get_default(self) -> Any:\n    if self.field_info.is_required():\n        return Undefined\n    return self.field_info.get_default(call_default_factory=True)"
        }
      ]
    },
    {
      "name": "type_",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 107,
      "end_line_number": 108,
      "source_code": "def type_(self) -> Any:\n            return self.field_info.annotation",
      "docstring": null,
      "decorators": [
        "property"
      ],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__post_init__",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 110,
      "end_line_number": 113,
      "source_code": "def __post_init__(self) -> None:\n            self._type_adapter: TypeAdapter[Any] = TypeAdapter(\n                Annotated[self.field_info.annotation, self.field_info]\n            )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "get_default",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 115,
      "end_line_number": 118,
      "source_code": "def get_default(self) -> Any:\n            if self.field_info.is_required():\n                return Undefined\n            return self.field_info.get_default(call_default_factory=True)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "self.field_info.get_default",
          "body": "def get_default(self) -> Any:\n    if self.field_info.is_required():\n        return Undefined\n    return self.field_info.get_default(call_default_factory=True)"
        }
      ]
    },
    {
      "name": "validate",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 120,
      "end_line_number": 135,
      "source_code": "def validate(\n            self,\n            value: Any,\n            values: Dict[str, Any] = {},  # noqa: B006\n            *,\n            loc: Tuple[Union[int, str], ...] = (),\n        ) -> Tuple[Any, Union[List[Dict[str, Any]], None]]:\n            try:\n                return (\n                    self._type_adapter.validate_python(value, from_attributes=True),\n                    None,\n                )\n            except ValidationError as exc:\n                return None, _regenerate_error_with_loc(\n                    errors=exc.errors(include_url=False), loc_prefix=loc\n                )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "value",
        "values"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "_regenerate_error_with_loc",
          "body": "def _regenerate_error_with_loc(*, errors: Sequence[Any], loc_prefix: Tuple[Union[str, int], ...]) -> List[Dict[str, Any]]:\n    updated_loc_errors: List[Any] = [{**err, 'loc': loc_prefix + err.get('loc', ())} for err in _normalize_errors(errors)]\n    return updated_loc_errors"
        },
        {
          "name": "exc.errors",
          "body": "def errors(self) -> Sequence[Any]:\n    return self._errors"
        }
      ]
    },
    {
      "name": "serialize",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 137,
      "end_line_number": 160,
      "source_code": "def serialize(\n            self,\n            value: Any,\n            *,\n            mode: Literal[\"json\", \"python\"] = \"json\",\n            include: Union[IncEx, None] = None,\n            exclude: Union[IncEx, None] = None,\n            by_alias: bool = True,\n            exclude_unset: bool = False,\n            exclude_defaults: bool = False,\n            exclude_none: bool = False,\n        ) -> Any:\n            # What calls this code passes a value that already called\n            # self._type_adapter.validate_python(value)\n            return self._type_adapter.dump_python(\n                value,\n                mode=mode,\n                include=include,\n                exclude=exclude,\n                by_alias=by_alias,\n                exclude_unset=exclude_unset,\n                exclude_defaults=exclude_defaults,\n                exclude_none=exclude_none,\n            )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "value"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__hash__",
      "module": "_compat",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\_compat.py",
      "line_number": 162,
      "end_line_number": 165,
      "source_code": "def __hash__(self) -> int:\n            # Each ModelField is unique for our purposes, to allow making a dict from\n            # ModelField to its JSON Schema.\n            return id(self)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "collections.deque",
        "copy.copy",
        "dataclasses.dataclass",
        "dataclasses.is_dataclass",
        "enum.Enum",
        "functools.lru_cache",
        "typing.Any",
        "typing.Callable",
        "typing.Deque",
        "typing.Dict",
        "typing.FrozenSet",
        "typing.List",
        "typing.Mapping",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "fastapi.exceptions.RequestErrorModel",
        "fastapi.types.IncEx",
        "fastapi.types.ModelNameMap",
        "fastapi.types.UnionType",
        "pydantic.BaseModel",
        "pydantic.create_model",
        "pydantic.version.VERSION",
        "starlette.datastructures.UploadFile",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "pydantic.PydanticSchemaGenerationError",
        "pydantic.TypeAdapter",
        "pydantic.ValidationError",
        "pydantic._internal._schema_generation_shared.GetJsonSchemaHandler",
        "pydantic._internal._typing_extra.eval_type_lenient",
        "pydantic._internal._utils.lenient_issubclass",
        "pydantic.fields.FieldInfo",
        "pydantic.json_schema.GenerateJsonSchema",
        "pydantic.json_schema.JsonSchemaValue",
        "pydantic_core.CoreSchema",
        "pydantic_core.PydanticUndefined",
        "pydantic_core.PydanticUndefinedType",
        "pydantic_core.Url",
        "fastapi.openapi.constants.REF_PREFIX",
        "pydantic.AnyUrl",
        "pydantic.BaseConfig",
        "pydantic.ValidationError",
        "pydantic.class_validators.Validator",
        "pydantic.error_wrappers.ErrorWrapper",
        "pydantic.errors.MissingError",
        "pydantic.fields.SHAPE_FROZENSET",
        "pydantic.fields.SHAPE_LIST",
        "pydantic.fields.SHAPE_SEQUENCE",
        "pydantic.fields.SHAPE_SET",
        "pydantic.fields.SHAPE_SINGLETON",
        "pydantic.fields.SHAPE_TUPLE",
        "pydantic.fields.SHAPE_TUPLE_ELLIPSIS",
        "pydantic.fields.FieldInfo",
        "pydantic.fields.ModelField",
        "pydantic.fields.Undefined",
        "pydantic.fields.UndefinedType",
        "pydantic.schema.field_schema",
        "pydantic.schema.get_flat_models_from_fields",
        "pydantic.schema.get_model_name_map",
        "pydantic.schema.model_process_schema",
        "pydantic.schema.get_annotation_from_field_info",
        "pydantic.typing.evaluate_forwardref",
        "pydantic.utils.lenient_issubclass",
        "pydantic_core.core_schema.with_info_plain_validator_function",
        "fastapi.params",
        "fastapi.params",
        "pydantic_core.core_schema.general_plain_validator_function"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__post_init__",
      "module": "models",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\dependencies\\models.py",
      "line_number": 36,
      "end_line_number": 37,
      "source_code": "def __post_init__(self) -> None:\n        self.cache_key = (self.call, tuple(sorted(set(self.security_scopes or []))))",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "dataclasses.dataclass",
        "dataclasses.field",
        "typing.Any",
        "typing.Callable",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "fastapi._compat.ModelField",
        "fastapi.security.base.SecurityBase"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "ensure_multipart_is_installed",
      "module": "utils",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\dependencies\\utils.py",
      "line_number": 91,
      "end_line_number": 115,
      "source_code": "def ensure_multipart_is_installed() -> None:\n    try:\n        from python_multipart import __version__\n\n        # Import an attribute that can be mocked/deleted in testing\n        assert __version__ > \"0.0.12\"\n    except (ImportError, AssertionError):\n        try:\n            # __version__ is available in both multiparts, and can be mocked\n            from multipart import __version__  # type: ignore[no-redef,import-untyped]\n\n            assert __version__\n            try:\n                # parse_options_header is only available in the right multipart\n                from multipart.multipart import (  # type: ignore[import-untyped]\n                    parse_options_header,\n                )\n\n                assert parse_options_header\n            except ImportError:\n                logger.error(multipart_incorrect_install_error)\n                raise RuntimeError(multipart_incorrect_install_error) from None\n        except ImportError:\n            logger.error(multipart_not_installed_error)\n            raise RuntimeError(multipart_not_installed_error) from None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "inspect",
        "contextlib.AsyncExitStack",
        "contextlib.contextmanager",
        "copy.copy",
        "copy.deepcopy",
        "dataclasses.dataclass",
        "typing.Any",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.ForwardRef",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "typing.cast",
        "anyio",
        "fastapi.params",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.ErrorWrapper",
        "fastapi._compat.ModelField",
        "fastapi._compat.RequiredParam",
        "fastapi._compat.Undefined",
        "fastapi._compat._regenerate_error_with_loc",
        "fastapi._compat.copy_field_info",
        "fastapi._compat.create_body_model",
        "fastapi._compat.evaluate_forwardref",
        "fastapi._compat.field_annotation_is_scalar",
        "fastapi._compat.get_annotation_from_field_info",
        "fastapi._compat.get_cached_model_fields",
        "fastapi._compat.get_missing_field_error",
        "fastapi._compat.is_bytes_field",
        "fastapi._compat.is_bytes_sequence_field",
        "fastapi._compat.is_scalar_field",
        "fastapi._compat.is_scalar_sequence_field",
        "fastapi._compat.is_sequence_field",
        "fastapi._compat.is_uploadfile_or_nonable_uploadfile_annotation",
        "fastapi._compat.is_uploadfile_sequence_annotation",
        "fastapi._compat.lenient_issubclass",
        "fastapi._compat.sequence_types",
        "fastapi._compat.serialize_sequence_value",
        "fastapi._compat.value_is_sequence",
        "fastapi.background.BackgroundTasks",
        "fastapi.concurrency.asynccontextmanager",
        "fastapi.concurrency.contextmanager_in_threadpool",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.models.SecurityRequirement",
        "fastapi.logger.logger",
        "fastapi.security.base.SecurityBase",
        "fastapi.security.oauth2.OAuth2",
        "fastapi.security.oauth2.SecurityScopes",
        "fastapi.security.open_id_connect_url.OpenIdConnect",
        "fastapi.utils.create_model_field",
        "fastapi.utils.get_path_param_names",
        "pydantic.BaseModel",
        "pydantic.fields.FieldInfo",
        "starlette.background.BackgroundTasks",
        "starlette.concurrency.run_in_threadpool",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.ImmutableMultiDict",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.UploadFile",
        "starlette.requests.HTTPConnection",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "python_multipart.__version__",
        "multipart.__version__",
        "multipart.multipart.parse_options_header"
      ],
      "fixtures": [],
      "assertions": [
        "assert __version__ > '0.0.12'",
        "assert __version__",
        "assert parse_options_header"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "get_param_sub_dependant",
      "module": "utils",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\dependencies\\utils.py",
      "line_number": 118,
      "end_line_number": 132,
      "source_code": "def get_param_sub_dependant(\n    *,\n    param_name: str,\n    depends: params.Depends,\n    path: str,\n    security_scopes: Optional[List[str]] = None,\n) -> Dependant:\n    assert depends.dependency\n    return get_sub_dependant(\n        depends=depends,\n        dependency=depends.dependency,\n        path=path,\n        name=param_name,\n        security_scopes=security_scopes,\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "inspect",
        "contextlib.AsyncExitStack",
        "contextlib.contextmanager",
        "copy.copy",
        "copy.deepcopy",
        "dataclasses.dataclass",
        "typing.Any",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.ForwardRef",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "typing.cast",
        "anyio",
        "fastapi.params",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.ErrorWrapper",
        "fastapi._compat.ModelField",
        "fastapi._compat.RequiredParam",
        "fastapi._compat.Undefined",
        "fastapi._compat._regenerate_error_with_loc",
        "fastapi._compat.copy_field_info",
        "fastapi._compat.create_body_model",
        "fastapi._compat.evaluate_forwardref",
        "fastapi._compat.field_annotation_is_scalar",
        "fastapi._compat.get_annotation_from_field_info",
        "fastapi._compat.get_cached_model_fields",
        "fastapi._compat.get_missing_field_error",
        "fastapi._compat.is_bytes_field",
        "fastapi._compat.is_bytes_sequence_field",
        "fastapi._compat.is_scalar_field",
        "fastapi._compat.is_scalar_sequence_field",
        "fastapi._compat.is_sequence_field",
        "fastapi._compat.is_uploadfile_or_nonable_uploadfile_annotation",
        "fastapi._compat.is_uploadfile_sequence_annotation",
        "fastapi._compat.lenient_issubclass",
        "fastapi._compat.sequence_types",
        "fastapi._compat.serialize_sequence_value",
        "fastapi._compat.value_is_sequence",
        "fastapi.background.BackgroundTasks",
        "fastapi.concurrency.asynccontextmanager",
        "fastapi.concurrency.contextmanager_in_threadpool",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.models.SecurityRequirement",
        "fastapi.logger.logger",
        "fastapi.security.base.SecurityBase",
        "fastapi.security.oauth2.OAuth2",
        "fastapi.security.oauth2.SecurityScopes",
        "fastapi.security.open_id_connect_url.OpenIdConnect",
        "fastapi.utils.create_model_field",
        "fastapi.utils.get_path_param_names",
        "pydantic.BaseModel",
        "pydantic.fields.FieldInfo",
        "starlette.background.BackgroundTasks",
        "starlette.concurrency.run_in_threadpool",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.ImmutableMultiDict",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.UploadFile",
        "starlette.requests.HTTPConnection",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "python_multipart.__version__",
        "multipart.__version__",
        "multipart.multipart.parse_options_header"
      ],
      "fixtures": [],
      "assertions": [
        "assert depends.dependency"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_sub_dependant",
          "body": "def get_sub_dependant(*, depends: params.Depends, dependency: Callable[..., Any], path: str, name: Optional[str]=None, security_scopes: Optional[List[str]]=None) -> Dependant:\n    security_requirement = None\n    security_scopes = security_scopes or []\n    if isinstance(depends, params.Security):\n        dependency_scopes = depends.scopes\n        security_scopes.extend(dependency_scopes)\n    if isinstance(dependency, SecurityBase):\n        use_scopes: List[str] = []\n        if isinstance(dependency, (OAuth2, OpenIdConnect)):\n            use_scopes = security_scopes\n        security_requirement = SecurityRequirement(security_scheme=dependency, scopes=use_scopes)\n    sub_dependant = get_dependant(path=path, call=dependency, name=name, security_scopes=security_scopes, use_cache=depends.use_cache)\n    if security_requirement:\n        sub_dependant.security_requirements.append(security_requirement)\n    return sub_dependant"
        }
      ]
    },
    {
      "name": "get_parameterless_sub_dependant",
      "module": "utils",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\dependencies\\utils.py",
      "line_number": 135,
      "end_line_number": 139,
      "source_code": "def get_parameterless_sub_dependant(*, depends: params.Depends, path: str) -> Dependant:\n    assert callable(\n        depends.dependency\n    ), \"A parameter-less dependency must have a callable dependency\"\n    return get_sub_dependant(depends=depends, dependency=depends.dependency, path=path)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "inspect",
        "contextlib.AsyncExitStack",
        "contextlib.contextmanager",
        "copy.copy",
        "copy.deepcopy",
        "dataclasses.dataclass",
        "typing.Any",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.ForwardRef",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "typing.cast",
        "anyio",
        "fastapi.params",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.ErrorWrapper",
        "fastapi._compat.ModelField",
        "fastapi._compat.RequiredParam",
        "fastapi._compat.Undefined",
        "fastapi._compat._regenerate_error_with_loc",
        "fastapi._compat.copy_field_info",
        "fastapi._compat.create_body_model",
        "fastapi._compat.evaluate_forwardref",
        "fastapi._compat.field_annotation_is_scalar",
        "fastapi._compat.get_annotation_from_field_info",
        "fastapi._compat.get_cached_model_fields",
        "fastapi._compat.get_missing_field_error",
        "fastapi._compat.is_bytes_field",
        "fastapi._compat.is_bytes_sequence_field",
        "fastapi._compat.is_scalar_field",
        "fastapi._compat.is_scalar_sequence_field",
        "fastapi._compat.is_sequence_field",
        "fastapi._compat.is_uploadfile_or_nonable_uploadfile_annotation",
        "fastapi._compat.is_uploadfile_sequence_annotation",
        "fastapi._compat.lenient_issubclass",
        "fastapi._compat.sequence_types",
        "fastapi._compat.serialize_sequence_value",
        "fastapi._compat.value_is_sequence",
        "fastapi.background.BackgroundTasks",
        "fastapi.concurrency.asynccontextmanager",
        "fastapi.concurrency.contextmanager_in_threadpool",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.models.SecurityRequirement",
        "fastapi.logger.logger",
        "fastapi.security.base.SecurityBase",
        "fastapi.security.oauth2.OAuth2",
        "fastapi.security.oauth2.SecurityScopes",
        "fastapi.security.open_id_connect_url.OpenIdConnect",
        "fastapi.utils.create_model_field",
        "fastapi.utils.get_path_param_names",
        "pydantic.BaseModel",
        "pydantic.fields.FieldInfo",
        "starlette.background.BackgroundTasks",
        "starlette.concurrency.run_in_threadpool",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.ImmutableMultiDict",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.UploadFile",
        "starlette.requests.HTTPConnection",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "python_multipart.__version__",
        "multipart.__version__",
        "multipart.multipart.parse_options_header"
      ],
      "fixtures": [],
      "assertions": [
        "assert callable(depends.dependency), 'A parameter-less dependency must have a callable dependency'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_sub_dependant",
          "body": "def get_sub_dependant(*, depends: params.Depends, dependency: Callable[..., Any], path: str, name: Optional[str]=None, security_scopes: Optional[List[str]]=None) -> Dependant:\n    security_requirement = None\n    security_scopes = security_scopes or []\n    if isinstance(depends, params.Security):\n        dependency_scopes = depends.scopes\n        security_scopes.extend(dependency_scopes)\n    if isinstance(dependency, SecurityBase):\n        use_scopes: List[str] = []\n        if isinstance(dependency, (OAuth2, OpenIdConnect)):\n            use_scopes = security_scopes\n        security_requirement = SecurityRequirement(security_scheme=dependency, scopes=use_scopes)\n    sub_dependant = get_dependant(path=path, call=dependency, name=name, security_scopes=security_scopes, use_cache=depends.use_cache)\n    if security_requirement:\n        sub_dependant.security_requirements.append(security_requirement)\n    return sub_dependant"
        }
      ]
    },
    {
      "name": "get_sub_dependant",
      "module": "utils",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\dependencies\\utils.py",
      "line_number": 142,
      "end_line_number": 171,
      "source_code": "def get_sub_dependant(\n    *,\n    depends: params.Depends,\n    dependency: Callable[..., Any],\n    path: str,\n    name: Optional[str] = None,\n    security_scopes: Optional[List[str]] = None,\n) -> Dependant:\n    security_requirement = None\n    security_scopes = security_scopes or []\n    if isinstance(depends, params.Security):\n        dependency_scopes = depends.scopes\n        security_scopes.extend(dependency_scopes)\n    if isinstance(dependency, SecurityBase):\n        use_scopes: List[str] = []\n        if isinstance(dependency, (OAuth2, OpenIdConnect)):\n            use_scopes = security_scopes\n        security_requirement = SecurityRequirement(\n            security_scheme=dependency, scopes=use_scopes\n        )\n    sub_dependant = get_dependant(\n        path=path,\n        call=dependency,\n        name=name,\n        security_scopes=security_scopes,\n        use_cache=depends.use_cache,\n    )\n    if security_requirement:\n        sub_dependant.security_requirements.append(security_requirement)\n    return sub_dependant",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "inspect",
        "contextlib.AsyncExitStack",
        "contextlib.contextmanager",
        "copy.copy",
        "copy.deepcopy",
        "dataclasses.dataclass",
        "typing.Any",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.ForwardRef",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "typing.cast",
        "anyio",
        "fastapi.params",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.ErrorWrapper",
        "fastapi._compat.ModelField",
        "fastapi._compat.RequiredParam",
        "fastapi._compat.Undefined",
        "fastapi._compat._regenerate_error_with_loc",
        "fastapi._compat.copy_field_info",
        "fastapi._compat.create_body_model",
        "fastapi._compat.evaluate_forwardref",
        "fastapi._compat.field_annotation_is_scalar",
        "fastapi._compat.get_annotation_from_field_info",
        "fastapi._compat.get_cached_model_fields",
        "fastapi._compat.get_missing_field_error",
        "fastapi._compat.is_bytes_field",
        "fastapi._compat.is_bytes_sequence_field",
        "fastapi._compat.is_scalar_field",
        "fastapi._compat.is_scalar_sequence_field",
        "fastapi._compat.is_sequence_field",
        "fastapi._compat.is_uploadfile_or_nonable_uploadfile_annotation",
        "fastapi._compat.is_uploadfile_sequence_annotation",
        "fastapi._compat.lenient_issubclass",
        "fastapi._compat.sequence_types",
        "fastapi._compat.serialize_sequence_value",
        "fastapi._compat.value_is_sequence",
        "fastapi.background.BackgroundTasks",
        "fastapi.concurrency.asynccontextmanager",
        "fastapi.concurrency.contextmanager_in_threadpool",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.models.SecurityRequirement",
        "fastapi.logger.logger",
        "fastapi.security.base.SecurityBase",
        "fastapi.security.oauth2.OAuth2",
        "fastapi.security.oauth2.SecurityScopes",
        "fastapi.security.open_id_connect_url.OpenIdConnect",
        "fastapi.utils.create_model_field",
        "fastapi.utils.get_path_param_names",
        "pydantic.BaseModel",
        "pydantic.fields.FieldInfo",
        "starlette.background.BackgroundTasks",
        "starlette.concurrency.run_in_threadpool",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.ImmutableMultiDict",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.UploadFile",
        "starlette.requests.HTTPConnection",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "python_multipart.__version__",
        "multipart.__version__",
        "multipart.multipart.parse_options_header"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_dependant",
          "body": "def get_dependant(*, path: str, call: Callable[..., Any], name: Optional[str]=None, security_scopes: Optional[List[str]]=None, use_cache: bool=True) -> Dependant:\n    path_param_names = get_path_param_names(path)\n    endpoint_signature = get_typed_signature(call)\n    signature_params = endpoint_signature.parameters\n    dependant = Dependant(call=call, name=name, path=path, security_scopes=security_scopes, use_cache=use_cache)\n    for param_name, param in signature_params.items():\n        is_path_param = param_name in path_param_names\n        param_details = analyze_param(param_name=param_name, annotation=param.annotation, value=param.default, is_path_param=is_path_param)\n        if param_details.depends is not None:\n            sub_dependant = get_param_sub_dependant(param_name=param_name, depends=param_details.depends, path=path, security_scopes=security_scopes)\n            dependant.dependencies.append(sub_dependant)\n            continue\n        if add_non_field_param_to_dependency(param_name=param_name, type_annotation=param_details.type_annotation, dependant=dependant):\n            assert param_details.field is None, f'Cannot specify multiple FastAPI annotations for {param_name!r}'\n            continue\n        assert param_details.field is not None\n        if isinstance(param_details.field.field_info, params.Body):\n            dependant.body_params.append(param_details.field)\n        else:\n            add_param_to_fields(field=param_details.field, dependant=dependant)\n    return dependant"
        }
      ]
    },
    {
      "name": "get_flat_dependant",
      "module": "utils",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\dependencies\\utils.py",
      "line_number": 177,
      "end_line_number": 209,
      "source_code": "def get_flat_dependant(\n    dependant: Dependant,\n    *,\n    skip_repeats: bool = False,\n    visited: Optional[List[CacheKey]] = None,\n) -> Dependant:\n    if visited is None:\n        visited = []\n    visited.append(dependant.cache_key)\n\n    flat_dependant = Dependant(\n        path_params=dependant.path_params.copy(),\n        query_params=dependant.query_params.copy(),\n        header_params=dependant.header_params.copy(),\n        cookie_params=dependant.cookie_params.copy(),\n        body_params=dependant.body_params.copy(),\n        security_requirements=dependant.security_requirements.copy(),\n        use_cache=dependant.use_cache,\n        path=dependant.path,\n    )\n    for sub_dependant in dependant.dependencies:\n        if skip_repeats and sub_dependant.cache_key in visited:\n            continue\n        flat_sub = get_flat_dependant(\n            sub_dependant, skip_repeats=skip_repeats, visited=visited\n        )\n        flat_dependant.path_params.extend(flat_sub.path_params)\n        flat_dependant.query_params.extend(flat_sub.query_params)\n        flat_dependant.header_params.extend(flat_sub.header_params)\n        flat_dependant.cookie_params.extend(flat_sub.cookie_params)\n        flat_dependant.body_params.extend(flat_sub.body_params)\n        flat_dependant.security_requirements.extend(flat_sub.security_requirements)\n    return flat_dependant",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "dependant"
      ],
      "imports": [
        "inspect",
        "contextlib.AsyncExitStack",
        "contextlib.contextmanager",
        "copy.copy",
        "copy.deepcopy",
        "dataclasses.dataclass",
        "typing.Any",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.ForwardRef",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "typing.cast",
        "anyio",
        "fastapi.params",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.ErrorWrapper",
        "fastapi._compat.ModelField",
        "fastapi._compat.RequiredParam",
        "fastapi._compat.Undefined",
        "fastapi._compat._regenerate_error_with_loc",
        "fastapi._compat.copy_field_info",
        "fastapi._compat.create_body_model",
        "fastapi._compat.evaluate_forwardref",
        "fastapi._compat.field_annotation_is_scalar",
        "fastapi._compat.get_annotation_from_field_info",
        "fastapi._compat.get_cached_model_fields",
        "fastapi._compat.get_missing_field_error",
        "fastapi._compat.is_bytes_field",
        "fastapi._compat.is_bytes_sequence_field",
        "fastapi._compat.is_scalar_field",
        "fastapi._compat.is_scalar_sequence_field",
        "fastapi._compat.is_sequence_field",
        "fastapi._compat.is_uploadfile_or_nonable_uploadfile_annotation",
        "fastapi._compat.is_uploadfile_sequence_annotation",
        "fastapi._compat.lenient_issubclass",
        "fastapi._compat.sequence_types",
        "fastapi._compat.serialize_sequence_value",
        "fastapi._compat.value_is_sequence",
        "fastapi.background.BackgroundTasks",
        "fastapi.concurrency.asynccontextmanager",
        "fastapi.concurrency.contextmanager_in_threadpool",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.models.SecurityRequirement",
        "fastapi.logger.logger",
        "fastapi.security.base.SecurityBase",
        "fastapi.security.oauth2.OAuth2",
        "fastapi.security.oauth2.SecurityScopes",
        "fastapi.security.open_id_connect_url.OpenIdConnect",
        "fastapi.utils.create_model_field",
        "fastapi.utils.get_path_param_names",
        "pydantic.BaseModel",
        "pydantic.fields.FieldInfo",
        "starlette.background.BackgroundTasks",
        "starlette.concurrency.run_in_threadpool",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.ImmutableMultiDict",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.UploadFile",
        "starlette.requests.HTTPConnection",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "python_multipart.__version__",
        "multipart.__version__",
        "multipart.multipart.parse_options_header"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_flat_dependant",
          "body": "def get_flat_dependant(dependant: Dependant, *, skip_repeats: bool=False, visited: Optional[List[CacheKey]]=None) -> Dependant:\n    if visited is None:\n        visited = []\n    visited.append(dependant.cache_key)\n    flat_dependant = Dependant(path_params=dependant.path_params.copy(), query_params=dependant.query_params.copy(), header_params=dependant.header_params.copy(), cookie_params=dependant.cookie_params.copy(), body_params=dependant.body_params.copy(), security_requirements=dependant.security_requirements.copy(), use_cache=dependant.use_cache, path=dependant.path)\n    for sub_dependant in dependant.dependencies:\n        if skip_repeats and sub_dependant.cache_key in visited:\n            continue\n        flat_sub = get_flat_dependant(sub_dependant, skip_repeats=skip_repeats, visited=visited)\n        flat_dependant.path_params.extend(flat_sub.path_params)\n        flat_dependant.query_params.extend(flat_sub.query_params)\n        flat_dependant.header_params.extend(flat_sub.header_params)\n        flat_dependant.cookie_params.extend(flat_sub.cookie_params)\n        flat_dependant.body_params.extend(flat_sub.body_params)\n        flat_dependant.security_requirements.extend(flat_sub.security_requirements)\n    return flat_dependant"
        }
      ]
    },
    {
      "name": "_get_flat_fields_from_params",
      "module": "utils",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\dependencies\\utils.py",
      "line_number": 212,
      "end_line_number": 219,
      "source_code": "def _get_flat_fields_from_params(fields: List[ModelField]) -> List[ModelField]:\n    if not fields:\n        return fields\n    first_field = fields[0]\n    if len(fields) == 1 and lenient_issubclass(first_field.type_, BaseModel):\n        fields_to_extract = get_cached_model_fields(first_field.type_)\n        return fields_to_extract\n    return fields",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "fields"
      ],
      "imports": [
        "inspect",
        "contextlib.AsyncExitStack",
        "contextlib.contextmanager",
        "copy.copy",
        "copy.deepcopy",
        "dataclasses.dataclass",
        "typing.Any",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.ForwardRef",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "typing.cast",
        "anyio",
        "fastapi.params",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.ErrorWrapper",
        "fastapi._compat.ModelField",
        "fastapi._compat.RequiredParam",
        "fastapi._compat.Undefined",
        "fastapi._compat._regenerate_error_with_loc",
        "fastapi._compat.copy_field_info",
        "fastapi._compat.create_body_model",
        "fastapi._compat.evaluate_forwardref",
        "fastapi._compat.field_annotation_is_scalar",
        "fastapi._compat.get_annotation_from_field_info",
        "fastapi._compat.get_cached_model_fields",
        "fastapi._compat.get_missing_field_error",
        "fastapi._compat.is_bytes_field",
        "fastapi._compat.is_bytes_sequence_field",
        "fastapi._compat.is_scalar_field",
        "fastapi._compat.is_scalar_sequence_field",
        "fastapi._compat.is_sequence_field",
        "fastapi._compat.is_uploadfile_or_nonable_uploadfile_annotation",
        "fastapi._compat.is_uploadfile_sequence_annotation",
        "fastapi._compat.lenient_issubclass",
        "fastapi._compat.sequence_types",
        "fastapi._compat.serialize_sequence_value",
        "fastapi._compat.value_is_sequence",
        "fastapi.background.BackgroundTasks",
        "fastapi.concurrency.asynccontextmanager",
        "fastapi.concurrency.contextmanager_in_threadpool",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.models.SecurityRequirement",
        "fastapi.logger.logger",
        "fastapi.security.base.SecurityBase",
        "fastapi.security.oauth2.OAuth2",
        "fastapi.security.oauth2.SecurityScopes",
        "fastapi.security.open_id_connect_url.OpenIdConnect",
        "fastapi.utils.create_model_field",
        "fastapi.utils.get_path_param_names",
        "pydantic.BaseModel",
        "pydantic.fields.FieldInfo",
        "starlette.background.BackgroundTasks",
        "starlette.concurrency.run_in_threadpool",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.ImmutableMultiDict",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.UploadFile",
        "starlette.requests.HTTPConnection",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "python_multipart.__version__",
        "multipart.__version__",
        "multipart.multipart.parse_options_header"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_cached_model_fields",
          "body": "@lru_cache\ndef get_cached_model_fields(model: Type[BaseModel]) -> List[ModelField]:\n    return get_model_fields(model)"
        }
      ]
    },
    {
      "name": "get_flat_params",
      "module": "utils",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\dependencies\\utils.py",
      "line_number": 222,
      "end_line_number": 228,
      "source_code": "def get_flat_params(dependant: Dependant) -> List[ModelField]:\n    flat_dependant = get_flat_dependant(dependant, skip_repeats=True)\n    path_params = _get_flat_fields_from_params(flat_dependant.path_params)\n    query_params = _get_flat_fields_from_params(flat_dependant.query_params)\n    header_params = _get_flat_fields_from_params(flat_dependant.header_params)\n    cookie_params = _get_flat_fields_from_params(flat_dependant.cookie_params)\n    return path_params + query_params + header_params + cookie_params",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "dependant"
      ],
      "imports": [
        "inspect",
        "contextlib.AsyncExitStack",
        "contextlib.contextmanager",
        "copy.copy",
        "copy.deepcopy",
        "dataclasses.dataclass",
        "typing.Any",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.ForwardRef",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "typing.cast",
        "anyio",
        "fastapi.params",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.ErrorWrapper",
        "fastapi._compat.ModelField",
        "fastapi._compat.RequiredParam",
        "fastapi._compat.Undefined",
        "fastapi._compat._regenerate_error_with_loc",
        "fastapi._compat.copy_field_info",
        "fastapi._compat.create_body_model",
        "fastapi._compat.evaluate_forwardref",
        "fastapi._compat.field_annotation_is_scalar",
        "fastapi._compat.get_annotation_from_field_info",
        "fastapi._compat.get_cached_model_fields",
        "fastapi._compat.get_missing_field_error",
        "fastapi._compat.is_bytes_field",
        "fastapi._compat.is_bytes_sequence_field",
        "fastapi._compat.is_scalar_field",
        "fastapi._compat.is_scalar_sequence_field",
        "fastapi._compat.is_sequence_field",
        "fastapi._compat.is_uploadfile_or_nonable_uploadfile_annotation",
        "fastapi._compat.is_uploadfile_sequence_annotation",
        "fastapi._compat.lenient_issubclass",
        "fastapi._compat.sequence_types",
        "fastapi._compat.serialize_sequence_value",
        "fastapi._compat.value_is_sequence",
        "fastapi.background.BackgroundTasks",
        "fastapi.concurrency.asynccontextmanager",
        "fastapi.concurrency.contextmanager_in_threadpool",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.models.SecurityRequirement",
        "fastapi.logger.logger",
        "fastapi.security.base.SecurityBase",
        "fastapi.security.oauth2.OAuth2",
        "fastapi.security.oauth2.SecurityScopes",
        "fastapi.security.open_id_connect_url.OpenIdConnect",
        "fastapi.utils.create_model_field",
        "fastapi.utils.get_path_param_names",
        "pydantic.BaseModel",
        "pydantic.fields.FieldInfo",
        "starlette.background.BackgroundTasks",
        "starlette.concurrency.run_in_threadpool",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.ImmutableMultiDict",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.UploadFile",
        "starlette.requests.HTTPConnection",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "python_multipart.__version__",
        "multipart.__version__",
        "multipart.multipart.parse_options_header"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_flat_dependant",
          "body": "def get_flat_dependant(dependant: Dependant, *, skip_repeats: bool=False, visited: Optional[List[CacheKey]]=None) -> Dependant:\n    if visited is None:\n        visited = []\n    visited.append(dependant.cache_key)\n    flat_dependant = Dependant(path_params=dependant.path_params.copy(), query_params=dependant.query_params.copy(), header_params=dependant.header_params.copy(), cookie_params=dependant.cookie_params.copy(), body_params=dependant.body_params.copy(), security_requirements=dependant.security_requirements.copy(), use_cache=dependant.use_cache, path=dependant.path)\n    for sub_dependant in dependant.dependencies:\n        if skip_repeats and sub_dependant.cache_key in visited:\n            continue\n        flat_sub = get_flat_dependant(sub_dependant, skip_repeats=skip_repeats, visited=visited)\n        flat_dependant.path_params.extend(flat_sub.path_params)\n        flat_dependant.query_params.extend(flat_sub.query_params)\n        flat_dependant.header_params.extend(flat_sub.header_params)\n        flat_dependant.cookie_params.extend(flat_sub.cookie_params)\n        flat_dependant.body_params.extend(flat_sub.body_params)\n        flat_dependant.security_requirements.extend(flat_sub.security_requirements)\n    return flat_dependant"
        },
        {
          "name": "_get_flat_fields_from_params",
          "body": "def _get_flat_fields_from_params(fields: List[ModelField]) -> List[ModelField]:\n    if not fields:\n        return fields\n    first_field = fields[0]\n    if len(fields) == 1 and lenient_issubclass(first_field.type_, BaseModel):\n        fields_to_extract = get_cached_model_fields(first_field.type_)\n        return fields_to_extract\n    return fields"
        },
        {
          "name": "_get_flat_fields_from_params",
          "body": "def _get_flat_fields_from_params(fields: List[ModelField]) -> List[ModelField]:\n    if not fields:\n        return fields\n    first_field = fields[0]\n    if len(fields) == 1 and lenient_issubclass(first_field.type_, BaseModel):\n        fields_to_extract = get_cached_model_fields(first_field.type_)\n        return fields_to_extract\n    return fields"
        },
        {
          "name": "_get_flat_fields_from_params",
          "body": "def _get_flat_fields_from_params(fields: List[ModelField]) -> List[ModelField]:\n    if not fields:\n        return fields\n    first_field = fields[0]\n    if len(fields) == 1 and lenient_issubclass(first_field.type_, BaseModel):\n        fields_to_extract = get_cached_model_fields(first_field.type_)\n        return fields_to_extract\n    return fields"
        },
        {
          "name": "_get_flat_fields_from_params",
          "body": "def _get_flat_fields_from_params(fields: List[ModelField]) -> List[ModelField]:\n    if not fields:\n        return fields\n    first_field = fields[0]\n    if len(fields) == 1 and lenient_issubclass(first_field.type_, BaseModel):\n        fields_to_extract = get_cached_model_fields(first_field.type_)\n        return fields_to_extract\n    return fields"
        }
      ]
    },
    {
      "name": "get_typed_signature",
      "module": "utils",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\dependencies\\utils.py",
      "line_number": 231,
      "end_line_number": 244,
      "source_code": "def get_typed_signature(call: Callable[..., Any]) -> inspect.Signature:\n    signature = inspect.signature(call)\n    globalns = getattr(call, \"__globals__\", {})\n    typed_params = [\n        inspect.Parameter(\n            name=param.name,\n            kind=param.kind,\n            default=param.default,\n            annotation=get_typed_annotation(param.annotation, globalns),\n        )\n        for param in signature.parameters.values()\n    ]\n    typed_signature = inspect.Signature(typed_params)\n    return typed_signature",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "call"
      ],
      "imports": [
        "inspect",
        "contextlib.AsyncExitStack",
        "contextlib.contextmanager",
        "copy.copy",
        "copy.deepcopy",
        "dataclasses.dataclass",
        "typing.Any",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.ForwardRef",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "typing.cast",
        "anyio",
        "fastapi.params",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.ErrorWrapper",
        "fastapi._compat.ModelField",
        "fastapi._compat.RequiredParam",
        "fastapi._compat.Undefined",
        "fastapi._compat._regenerate_error_with_loc",
        "fastapi._compat.copy_field_info",
        "fastapi._compat.create_body_model",
        "fastapi._compat.evaluate_forwardref",
        "fastapi._compat.field_annotation_is_scalar",
        "fastapi._compat.get_annotation_from_field_info",
        "fastapi._compat.get_cached_model_fields",
        "fastapi._compat.get_missing_field_error",
        "fastapi._compat.is_bytes_field",
        "fastapi._compat.is_bytes_sequence_field",
        "fastapi._compat.is_scalar_field",
        "fastapi._compat.is_scalar_sequence_field",
        "fastapi._compat.is_sequence_field",
        "fastapi._compat.is_uploadfile_or_nonable_uploadfile_annotation",
        "fastapi._compat.is_uploadfile_sequence_annotation",
        "fastapi._compat.lenient_issubclass",
        "fastapi._compat.sequence_types",
        "fastapi._compat.serialize_sequence_value",
        "fastapi._compat.value_is_sequence",
        "fastapi.background.BackgroundTasks",
        "fastapi.concurrency.asynccontextmanager",
        "fastapi.concurrency.contextmanager_in_threadpool",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.models.SecurityRequirement",
        "fastapi.logger.logger",
        "fastapi.security.base.SecurityBase",
        "fastapi.security.oauth2.OAuth2",
        "fastapi.security.oauth2.SecurityScopes",
        "fastapi.security.open_id_connect_url.OpenIdConnect",
        "fastapi.utils.create_model_field",
        "fastapi.utils.get_path_param_names",
        "pydantic.BaseModel",
        "pydantic.fields.FieldInfo",
        "starlette.background.BackgroundTasks",
        "starlette.concurrency.run_in_threadpool",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.ImmutableMultiDict",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.UploadFile",
        "starlette.requests.HTTPConnection",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "python_multipart.__version__",
        "multipart.__version__",
        "multipart.multipart.parse_options_header"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_typed_annotation",
          "body": "def get_typed_annotation(annotation: Any, globalns: Dict[str, Any]) -> Any:\n    if isinstance(annotation, str):\n        annotation = ForwardRef(annotation)\n        annotation = evaluate_forwardref(annotation, globalns, globalns)\n    return annotation"
        }
      ]
    },
    {
      "name": "get_typed_annotation",
      "module": "utils",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\dependencies\\utils.py",
      "line_number": 247,
      "end_line_number": 251,
      "source_code": "def get_typed_annotation(annotation: Any, globalns: Dict[str, Any]) -> Any:\n    if isinstance(annotation, str):\n        annotation = ForwardRef(annotation)\n        annotation = evaluate_forwardref(annotation, globalns, globalns)\n    return annotation",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "annotation",
        "globalns"
      ],
      "imports": [
        "inspect",
        "contextlib.AsyncExitStack",
        "contextlib.contextmanager",
        "copy.copy",
        "copy.deepcopy",
        "dataclasses.dataclass",
        "typing.Any",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.ForwardRef",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "typing.cast",
        "anyio",
        "fastapi.params",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.ErrorWrapper",
        "fastapi._compat.ModelField",
        "fastapi._compat.RequiredParam",
        "fastapi._compat.Undefined",
        "fastapi._compat._regenerate_error_with_loc",
        "fastapi._compat.copy_field_info",
        "fastapi._compat.create_body_model",
        "fastapi._compat.evaluate_forwardref",
        "fastapi._compat.field_annotation_is_scalar",
        "fastapi._compat.get_annotation_from_field_info",
        "fastapi._compat.get_cached_model_fields",
        "fastapi._compat.get_missing_field_error",
        "fastapi._compat.is_bytes_field",
        "fastapi._compat.is_bytes_sequence_field",
        "fastapi._compat.is_scalar_field",
        "fastapi._compat.is_scalar_sequence_field",
        "fastapi._compat.is_sequence_field",
        "fastapi._compat.is_uploadfile_or_nonable_uploadfile_annotation",
        "fastapi._compat.is_uploadfile_sequence_annotation",
        "fastapi._compat.lenient_issubclass",
        "fastapi._compat.sequence_types",
        "fastapi._compat.serialize_sequence_value",
        "fastapi._compat.value_is_sequence",
        "fastapi.background.BackgroundTasks",
        "fastapi.concurrency.asynccontextmanager",
        "fastapi.concurrency.contextmanager_in_threadpool",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.models.SecurityRequirement",
        "fastapi.logger.logger",
        "fastapi.security.base.SecurityBase",
        "fastapi.security.oauth2.OAuth2",
        "fastapi.security.oauth2.SecurityScopes",
        "fastapi.security.open_id_connect_url.OpenIdConnect",
        "fastapi.utils.create_model_field",
        "fastapi.utils.get_path_param_names",
        "pydantic.BaseModel",
        "pydantic.fields.FieldInfo",
        "starlette.background.BackgroundTasks",
        "starlette.concurrency.run_in_threadpool",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.ImmutableMultiDict",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.UploadFile",
        "starlette.requests.HTTPConnection",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "python_multipart.__version__",
        "multipart.__version__",
        "multipart.multipart.parse_options_header"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "get_typed_return_annotation",
      "module": "utils",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\dependencies\\utils.py",
      "line_number": 254,
      "end_line_number": 262,
      "source_code": "def get_typed_return_annotation(call: Callable[..., Any]) -> Any:\n    signature = inspect.signature(call)\n    annotation = signature.return_annotation\n\n    if annotation is inspect.Signature.empty:\n        return None\n\n    globalns = getattr(call, \"__globals__\", {})\n    return get_typed_annotation(annotation, globalns)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "call"
      ],
      "imports": [
        "inspect",
        "contextlib.AsyncExitStack",
        "contextlib.contextmanager",
        "copy.copy",
        "copy.deepcopy",
        "dataclasses.dataclass",
        "typing.Any",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.ForwardRef",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "typing.cast",
        "anyio",
        "fastapi.params",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.ErrorWrapper",
        "fastapi._compat.ModelField",
        "fastapi._compat.RequiredParam",
        "fastapi._compat.Undefined",
        "fastapi._compat._regenerate_error_with_loc",
        "fastapi._compat.copy_field_info",
        "fastapi._compat.create_body_model",
        "fastapi._compat.evaluate_forwardref",
        "fastapi._compat.field_annotation_is_scalar",
        "fastapi._compat.get_annotation_from_field_info",
        "fastapi._compat.get_cached_model_fields",
        "fastapi._compat.get_missing_field_error",
        "fastapi._compat.is_bytes_field",
        "fastapi._compat.is_bytes_sequence_field",
        "fastapi._compat.is_scalar_field",
        "fastapi._compat.is_scalar_sequence_field",
        "fastapi._compat.is_sequence_field",
        "fastapi._compat.is_uploadfile_or_nonable_uploadfile_annotation",
        "fastapi._compat.is_uploadfile_sequence_annotation",
        "fastapi._compat.lenient_issubclass",
        "fastapi._compat.sequence_types",
        "fastapi._compat.serialize_sequence_value",
        "fastapi._compat.value_is_sequence",
        "fastapi.background.BackgroundTasks",
        "fastapi.concurrency.asynccontextmanager",
        "fastapi.concurrency.contextmanager_in_threadpool",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.models.SecurityRequirement",
        "fastapi.logger.logger",
        "fastapi.security.base.SecurityBase",
        "fastapi.security.oauth2.OAuth2",
        "fastapi.security.oauth2.SecurityScopes",
        "fastapi.security.open_id_connect_url.OpenIdConnect",
        "fastapi.utils.create_model_field",
        "fastapi.utils.get_path_param_names",
        "pydantic.BaseModel",
        "pydantic.fields.FieldInfo",
        "starlette.background.BackgroundTasks",
        "starlette.concurrency.run_in_threadpool",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.ImmutableMultiDict",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.UploadFile",
        "starlette.requests.HTTPConnection",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "python_multipart.__version__",
        "multipart.__version__",
        "multipart.multipart.parse_options_header"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_typed_annotation",
          "body": "def get_typed_annotation(annotation: Any, globalns: Dict[str, Any]) -> Any:\n    if isinstance(annotation, str):\n        annotation = ForwardRef(annotation)\n        annotation = evaluate_forwardref(annotation, globalns, globalns)\n    return annotation"
        }
      ]
    },
    {
      "name": "get_dependant",
      "module": "utils",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\dependencies\\utils.py",
      "line_number": 265,
      "end_line_number": 314,
      "source_code": "def get_dependant(\n    *,\n    path: str,\n    call: Callable[..., Any],\n    name: Optional[str] = None,\n    security_scopes: Optional[List[str]] = None,\n    use_cache: bool = True,\n) -> Dependant:\n    path_param_names = get_path_param_names(path)\n    endpoint_signature = get_typed_signature(call)\n    signature_params = endpoint_signature.parameters\n    dependant = Dependant(\n        call=call,\n        name=name,\n        path=path,\n        security_scopes=security_scopes,\n        use_cache=use_cache,\n    )\n    for param_name, param in signature_params.items():\n        is_path_param = param_name in path_param_names\n        param_details = analyze_param(\n            param_name=param_name,\n            annotation=param.annotation,\n            value=param.default,\n            is_path_param=is_path_param,\n        )\n        if param_details.depends is not None:\n            sub_dependant = get_param_sub_dependant(\n                param_name=param_name,\n                depends=param_details.depends,\n                path=path,\n                security_scopes=security_scopes,\n            )\n            dependant.dependencies.append(sub_dependant)\n            continue\n        if add_non_field_param_to_dependency(\n            param_name=param_name,\n            type_annotation=param_details.type_annotation,\n            dependant=dependant,\n        ):\n            assert (\n                param_details.field is None\n            ), f\"Cannot specify multiple FastAPI annotations for {param_name!r}\"\n            continue\n        assert param_details.field is not None\n        if isinstance(param_details.field.field_info, params.Body):\n            dependant.body_params.append(param_details.field)\n        else:\n            add_param_to_fields(field=param_details.field, dependant=dependant)\n    return dependant",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "inspect",
        "contextlib.AsyncExitStack",
        "contextlib.contextmanager",
        "copy.copy",
        "copy.deepcopy",
        "dataclasses.dataclass",
        "typing.Any",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.ForwardRef",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "typing.cast",
        "anyio",
        "fastapi.params",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.ErrorWrapper",
        "fastapi._compat.ModelField",
        "fastapi._compat.RequiredParam",
        "fastapi._compat.Undefined",
        "fastapi._compat._regenerate_error_with_loc",
        "fastapi._compat.copy_field_info",
        "fastapi._compat.create_body_model",
        "fastapi._compat.evaluate_forwardref",
        "fastapi._compat.field_annotation_is_scalar",
        "fastapi._compat.get_annotation_from_field_info",
        "fastapi._compat.get_cached_model_fields",
        "fastapi._compat.get_missing_field_error",
        "fastapi._compat.is_bytes_field",
        "fastapi._compat.is_bytes_sequence_field",
        "fastapi._compat.is_scalar_field",
        "fastapi._compat.is_scalar_sequence_field",
        "fastapi._compat.is_sequence_field",
        "fastapi._compat.is_uploadfile_or_nonable_uploadfile_annotation",
        "fastapi._compat.is_uploadfile_sequence_annotation",
        "fastapi._compat.lenient_issubclass",
        "fastapi._compat.sequence_types",
        "fastapi._compat.serialize_sequence_value",
        "fastapi._compat.value_is_sequence",
        "fastapi.background.BackgroundTasks",
        "fastapi.concurrency.asynccontextmanager",
        "fastapi.concurrency.contextmanager_in_threadpool",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.models.SecurityRequirement",
        "fastapi.logger.logger",
        "fastapi.security.base.SecurityBase",
        "fastapi.security.oauth2.OAuth2",
        "fastapi.security.oauth2.SecurityScopes",
        "fastapi.security.open_id_connect_url.OpenIdConnect",
        "fastapi.utils.create_model_field",
        "fastapi.utils.get_path_param_names",
        "pydantic.BaseModel",
        "pydantic.fields.FieldInfo",
        "starlette.background.BackgroundTasks",
        "starlette.concurrency.run_in_threadpool",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.ImmutableMultiDict",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.UploadFile",
        "starlette.requests.HTTPConnection",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "python_multipart.__version__",
        "multipart.__version__",
        "multipart.multipart.parse_options_header"
      ],
      "fixtures": [],
      "assertions": [
        "assert param_details.field is not None",
        "assert param_details.field is None, f'Cannot specify multiple FastAPI annotations for {param_name!r}'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_path_param_names",
          "body": "def get_path_param_names(path: str) -> Set[str]:\n    return set(re.findall('{(.*?)}', path))"
        },
        {
          "name": "get_typed_signature",
          "body": "def get_typed_signature(call: Callable[..., Any]) -> inspect.Signature:\n    signature = inspect.signature(call)\n    globalns = getattr(call, '__globals__', {})\n    typed_params = [inspect.Parameter(name=param.name, kind=param.kind, default=param.default, annotation=get_typed_annotation(param.annotation, globalns)) for param in signature.parameters.values()]\n    typed_signature = inspect.Signature(typed_params)\n    return typed_signature"
        },
        {
          "name": "analyze_param",
          "body": "def analyze_param(*, param_name: str, annotation: Any, value: Any, is_path_param: bool) -> ParamDetails:\n    field_info = None\n    depends = None\n    type_annotation: Any = Any\n    use_annotation: Any = Any\n    if annotation is not inspect.Signature.empty:\n        use_annotation = annotation\n        type_annotation = annotation\n    if get_origin(use_annotation) is Annotated:\n        annotated_args = get_args(annotation)\n        type_annotation = annotated_args[0]\n        fastapi_annotations = [arg for arg in annotated_args[1:] if isinstance(arg, (FieldInfo, params.Depends))]\n        fastapi_specific_annotations = [arg for arg in fastapi_annotations if isinstance(arg, (params.Param, params.Body, params.Depends))]\n        if fastapi_specific_annotations:\n            fastapi_annotation: Union[FieldInfo, params.Depends, None] = fastapi_specific_annotations[-1]\n        else:\n            fastapi_annotation = None\n        if isinstance(fastapi_annotation, FieldInfo):\n            field_info = copy_field_info(field_info=fastapi_annotation, annotation=use_annotation)\n            assert field_info.default is Undefined or field_info.default is RequiredParam, f'`{field_info.__class__.__name__}` default value cannot be set in `Annotated` for {param_name!r}. Set the default value with `=` instead.'\n            if value is not inspect.Signature.empty:\n                assert not is_path_param, 'Path parameters cannot have default values'\n                field_info.default = value\n            else:\n                field_info.default = RequiredParam\n        elif isinstance(fastapi_annotation, params.Depends):\n            depends = fastapi_annotation\n    if isinstance(value, params.Depends):\n        assert depends is None, f'Cannot specify `Depends` in `Annotated` and default value together for {param_name!r}'\n        assert field_info is None, f'Cannot specify a FastAPI annotation in `Annotated` and `Depends` as a default value together for {param_name!r}'\n        depends = value\n    elif isinstance(value, FieldInfo):\n        assert field_info is None, f'Cannot specify FastAPI annotations in `Annotated` and default value together for {param_name!r}'\n        field_info = value\n        if PYDANTIC_V2:\n            field_info.annotation = type_annotation\n    if depends is not None and depends.dependency is None:\n        depends = copy(depends)\n        depends.dependency = type_annotation\n    if lenient_issubclass(type_annotation, (Request, WebSocket, HTTPConnection, Response, StarletteBackgroundTasks, SecurityScopes)):\n        assert depends is None, f'Cannot specify `Depends` for type {type_annotation!r}'\n        assert field_info is None, f'Cannot specify FastAPI annotation for type {type_annotation!r}'\n    elif field_info is None and depends is None:\n        default_value = value if value is not inspect.Signature.empty else RequiredParam\n        if is_path_param:\n            field_info = params.Path(annotation=use_annotation)\n        elif is_uploadfile_or_nonable_uploadfile_annotation(type_annotation) or is_uploadfile_sequence_annotation(type_annotation):\n            field_info = params.File(annotation=use_annotation, default=default_value)\n        elif not field_annotation_is_scalar(annotation=type_annotation):\n            field_info = params.Body(annotation=use_annotation, default=default_value)\n        else:\n            field_info = params.Query(annotation=use_annotation, default=default_value)\n    field = None\n    if field_info is not None:\n        if is_path_param:\n            assert isinstance(field_info, params.Path), f'Cannot use `{field_info.__class__.__name__}` for path param {param_name!r}'\n        elif isinstance(field_info, params.Param) and getattr(field_info, 'in_', None) is None:\n            field_info.in_ = params.ParamTypes.query\n        use_annotation_from_field_info = get_annotation_from_field_info(use_annotation, field_info, param_name)\n        if isinstance(field_info, params.Form):\n            ensure_multipart_is_installed()\n        if not field_info.alias and getattr(field_info, 'convert_underscores', None):\n            alias = param_name.replace('_', '-')\n        else:\n            alias = field_info.alias or param_name\n        field_info.alias = alias\n        field = create_model_field(name=param_name, type_=use_annotation_from_field_info, default=field_info.default, alias=alias, required=field_info.default in (RequiredParam, Undefined), field_info=field_info)\n        if is_path_param:\n            assert is_scalar_field(field=field), 'Path params must be of one of the supported types'\n        elif isinstance(field_info, params.Query):\n            assert is_scalar_field(field) or is_scalar_sequence_field(field) or (lenient_issubclass(field.type_, BaseModel) and getattr(field, 'shape', 1) == 1)\n    return ParamDetails(type_annotation=type_annotation, depends=depends, field=field)"
        },
        {
          "name": "add_non_field_param_to_dependency",
          "body": "def add_non_field_param_to_dependency(*, param_name: str, type_annotation: Any, dependant: Dependant) -> Optional[bool]:\n    if lenient_issubclass(type_annotation, Request):\n        dependant.request_param_name = param_name\n        return True\n    elif lenient_issubclass(type_annotation, WebSocket):\n        dependant.websocket_param_name = param_name\n        return True\n    elif lenient_issubclass(type_annotation, HTTPConnection):\n        dependant.http_connection_param_name = param_name\n        return True\n    elif lenient_issubclass(type_annotation, Response):\n        dependant.response_param_name = param_name\n        return True\n    elif lenient_issubclass(type_annotation, StarletteBackgroundTasks):\n        dependant.background_tasks_param_name = param_name\n        return True\n    elif lenient_issubclass(type_annotation, SecurityScopes):\n        dependant.security_scopes_param_name = param_name\n        return True\n    return None"
        },
        {
          "name": "get_param_sub_dependant",
          "body": "def get_param_sub_dependant(*, param_name: str, depends: params.Depends, path: str, security_scopes: Optional[List[str]]=None) -> Dependant:\n    assert depends.dependency\n    return get_sub_dependant(depends=depends, dependency=depends.dependency, path=path, name=param_name, security_scopes=security_scopes)"
        },
        {
          "name": "add_param_to_fields",
          "body": "def add_param_to_fields(*, field: ModelField, dependant: Dependant) -> None:\n    field_info = field.field_info\n    field_info_in = getattr(field_info, 'in_', None)\n    if field_info_in == params.ParamTypes.path:\n        dependant.path_params.append(field)\n    elif field_info_in == params.ParamTypes.query:\n        dependant.query_params.append(field)\n    elif field_info_in == params.ParamTypes.header:\n        dependant.header_params.append(field)\n    else:\n        assert field_info_in == params.ParamTypes.cookie, f'non-body parameters must be in path, query, header or cookie: {field.name}'\n        dependant.cookie_params.append(field)"
        }
      ]
    },
    {
      "name": "add_non_field_param_to_dependency",
      "module": "utils",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\dependencies\\utils.py",
      "line_number": 317,
      "end_line_number": 338,
      "source_code": "def add_non_field_param_to_dependency(\n    *, param_name: str, type_annotation: Any, dependant: Dependant\n) -> Optional[bool]:\n    if lenient_issubclass(type_annotation, Request):\n        dependant.request_param_name = param_name\n        return True\n    elif lenient_issubclass(type_annotation, WebSocket):\n        dependant.websocket_param_name = param_name\n        return True\n    elif lenient_issubclass(type_annotation, HTTPConnection):\n        dependant.http_connection_param_name = param_name\n        return True\n    elif lenient_issubclass(type_annotation, Response):\n        dependant.response_param_name = param_name\n        return True\n    elif lenient_issubclass(type_annotation, StarletteBackgroundTasks):\n        dependant.background_tasks_param_name = param_name\n        return True\n    elif lenient_issubclass(type_annotation, SecurityScopes):\n        dependant.security_scopes_param_name = param_name\n        return True\n    return None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "inspect",
        "contextlib.AsyncExitStack",
        "contextlib.contextmanager",
        "copy.copy",
        "copy.deepcopy",
        "dataclasses.dataclass",
        "typing.Any",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.ForwardRef",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "typing.cast",
        "anyio",
        "fastapi.params",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.ErrorWrapper",
        "fastapi._compat.ModelField",
        "fastapi._compat.RequiredParam",
        "fastapi._compat.Undefined",
        "fastapi._compat._regenerate_error_with_loc",
        "fastapi._compat.copy_field_info",
        "fastapi._compat.create_body_model",
        "fastapi._compat.evaluate_forwardref",
        "fastapi._compat.field_annotation_is_scalar",
        "fastapi._compat.get_annotation_from_field_info",
        "fastapi._compat.get_cached_model_fields",
        "fastapi._compat.get_missing_field_error",
        "fastapi._compat.is_bytes_field",
        "fastapi._compat.is_bytes_sequence_field",
        "fastapi._compat.is_scalar_field",
        "fastapi._compat.is_scalar_sequence_field",
        "fastapi._compat.is_sequence_field",
        "fastapi._compat.is_uploadfile_or_nonable_uploadfile_annotation",
        "fastapi._compat.is_uploadfile_sequence_annotation",
        "fastapi._compat.lenient_issubclass",
        "fastapi._compat.sequence_types",
        "fastapi._compat.serialize_sequence_value",
        "fastapi._compat.value_is_sequence",
        "fastapi.background.BackgroundTasks",
        "fastapi.concurrency.asynccontextmanager",
        "fastapi.concurrency.contextmanager_in_threadpool",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.models.SecurityRequirement",
        "fastapi.logger.logger",
        "fastapi.security.base.SecurityBase",
        "fastapi.security.oauth2.OAuth2",
        "fastapi.security.oauth2.SecurityScopes",
        "fastapi.security.open_id_connect_url.OpenIdConnect",
        "fastapi.utils.create_model_field",
        "fastapi.utils.get_path_param_names",
        "pydantic.BaseModel",
        "pydantic.fields.FieldInfo",
        "starlette.background.BackgroundTasks",
        "starlette.concurrency.run_in_threadpool",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.ImmutableMultiDict",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.UploadFile",
        "starlette.requests.HTTPConnection",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "python_multipart.__version__",
        "multipart.__version__",
        "multipart.multipart.parse_options_header"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "analyze_param",
      "module": "utils",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\dependencies\\utils.py",
      "line_number": 348,
      "end_line_number": 511,
      "source_code": "def analyze_param(\n    *,\n    param_name: str,\n    annotation: Any,\n    value: Any,\n    is_path_param: bool,\n) -> ParamDetails:\n    field_info = None\n    depends = None\n    type_annotation: Any = Any\n    use_annotation: Any = Any\n    if annotation is not inspect.Signature.empty:\n        use_annotation = annotation\n        type_annotation = annotation\n    # Extract Annotated info\n    if get_origin(use_annotation) is Annotated:\n        annotated_args = get_args(annotation)\n        type_annotation = annotated_args[0]\n        fastapi_annotations = [\n            arg\n            for arg in annotated_args[1:]\n            if isinstance(arg, (FieldInfo, params.Depends))\n        ]\n        fastapi_specific_annotations = [\n            arg\n            for arg in fastapi_annotations\n            if isinstance(arg, (params.Param, params.Body, params.Depends))\n        ]\n        if fastapi_specific_annotations:\n            fastapi_annotation: Union[FieldInfo, params.Depends, None] = (\n                fastapi_specific_annotations[-1]\n            )\n        else:\n            fastapi_annotation = None\n        # Set default for Annotated FieldInfo\n        if isinstance(fastapi_annotation, FieldInfo):\n            # Copy `field_info` because we mutate `field_info.default` below.\n            field_info = copy_field_info(\n                field_info=fastapi_annotation, annotation=use_annotation\n            )\n            assert (\n                field_info.default is Undefined or field_info.default is RequiredParam\n            ), (\n                f\"`{field_info.__class__.__name__}` default value cannot be set in\"\n                f\" `Annotated` for {param_name!r}. Set the default value with `=` instead.\"\n            )\n            if value is not inspect.Signature.empty:\n                assert not is_path_param, \"Path parameters cannot have default values\"\n                field_info.default = value\n            else:\n                field_info.default = RequiredParam\n        # Get Annotated Depends\n        elif isinstance(fastapi_annotation, params.Depends):\n            depends = fastapi_annotation\n    # Get Depends from default value\n    if isinstance(value, params.Depends):\n        assert depends is None, (\n            \"Cannot specify `Depends` in `Annotated` and default value\"\n            f\" together for {param_name!r}\"\n        )\n        assert field_info is None, (\n            \"Cannot specify a FastAPI annotation in `Annotated` and `Depends` as a\"\n            f\" default value together for {param_name!r}\"\n        )\n        depends = value\n    # Get FieldInfo from default value\n    elif isinstance(value, FieldInfo):\n        assert field_info is None, (\n            \"Cannot specify FastAPI annotations in `Annotated` and default value\"\n            f\" together for {param_name!r}\"\n        )\n        field_info = value\n        if PYDANTIC_V2:\n            field_info.annotation = type_annotation\n\n    # Get Depends from type annotation\n    if depends is not None and depends.dependency is None:\n        # Copy `depends` before mutating it\n        depends = copy(depends)\n        depends.dependency = type_annotation\n\n    # Handle non-param type annotations like Request\n    if lenient_issubclass(\n        type_annotation,\n        (\n            Request,\n            WebSocket,\n            HTTPConnection,\n            Response,\n            StarletteBackgroundTasks,\n            SecurityScopes,\n        ),\n    ):\n        assert depends is None, f\"Cannot specify `Depends` for type {type_annotation!r}\"\n        assert (\n            field_info is None\n        ), f\"Cannot specify FastAPI annotation for type {type_annotation!r}\"\n    # Handle default assignations, neither field_info nor depends was not found in Annotated nor default value\n    elif field_info is None and depends is None:\n        default_value = value if value is not inspect.Signature.empty else RequiredParam\n        if is_path_param:\n            # We might check here that `default_value is RequiredParam`, but the fact is that the same\n            # parameter might sometimes be a path parameter and sometimes not. See\n            # `tests/test_infer_param_optionality.py` for an example.\n            field_info = params.Path(annotation=use_annotation)\n        elif is_uploadfile_or_nonable_uploadfile_annotation(\n            type_annotation\n        ) or is_uploadfile_sequence_annotation(type_annotation):\n            field_info = params.File(annotation=use_annotation, default=default_value)\n        elif not field_annotation_is_scalar(annotation=type_annotation):\n            field_info = params.Body(annotation=use_annotation, default=default_value)\n        else:\n            field_info = params.Query(annotation=use_annotation, default=default_value)\n\n    field = None\n    # It's a field_info, not a dependency\n    if field_info is not None:\n        # Handle field_info.in_\n        if is_path_param:\n            assert isinstance(field_info, params.Path), (\n                f\"Cannot use `{field_info.__class__.__name__}` for path param\"\n                f\" {param_name!r}\"\n            )\n        elif (\n            isinstance(field_info, params.Param)\n            and getattr(field_info, \"in_\", None) is None\n        ):\n            field_info.in_ = params.ParamTypes.query\n        use_annotation_from_field_info = get_annotation_from_field_info(\n            use_annotation,\n            field_info,\n            param_name,\n        )\n        if isinstance(field_info, params.Form):\n            ensure_multipart_is_installed()\n        if not field_info.alias and getattr(field_info, \"convert_underscores\", None):\n            alias = param_name.replace(\"_\", \"-\")\n        else:\n            alias = field_info.alias or param_name\n        field_info.alias = alias\n        field = create_model_field(\n            name=param_name,\n            type_=use_annotation_from_field_info,\n            default=field_info.default,\n            alias=alias,\n            required=field_info.default in (RequiredParam, Undefined),\n            field_info=field_info,\n        )\n        if is_path_param:\n            assert is_scalar_field(\n                field=field\n            ), \"Path params must be of one of the supported types\"\n        elif isinstance(field_info, params.Query):\n            assert (\n                is_scalar_field(field)\n                or is_scalar_sequence_field(field)\n                or (\n                    lenient_issubclass(field.type_, BaseModel)\n                    # For Pydantic v1\n                    and getattr(field, \"shape\", 1) == 1\n                )\n            )\n\n    return ParamDetails(type_annotation=type_annotation, depends=depends, field=field)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "inspect",
        "contextlib.AsyncExitStack",
        "contextlib.contextmanager",
        "copy.copy",
        "copy.deepcopy",
        "dataclasses.dataclass",
        "typing.Any",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.ForwardRef",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "typing.cast",
        "anyio",
        "fastapi.params",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.ErrorWrapper",
        "fastapi._compat.ModelField",
        "fastapi._compat.RequiredParam",
        "fastapi._compat.Undefined",
        "fastapi._compat._regenerate_error_with_loc",
        "fastapi._compat.copy_field_info",
        "fastapi._compat.create_body_model",
        "fastapi._compat.evaluate_forwardref",
        "fastapi._compat.field_annotation_is_scalar",
        "fastapi._compat.get_annotation_from_field_info",
        "fastapi._compat.get_cached_model_fields",
        "fastapi._compat.get_missing_field_error",
        "fastapi._compat.is_bytes_field",
        "fastapi._compat.is_bytes_sequence_field",
        "fastapi._compat.is_scalar_field",
        "fastapi._compat.is_scalar_sequence_field",
        "fastapi._compat.is_sequence_field",
        "fastapi._compat.is_uploadfile_or_nonable_uploadfile_annotation",
        "fastapi._compat.is_uploadfile_sequence_annotation",
        "fastapi._compat.lenient_issubclass",
        "fastapi._compat.sequence_types",
        "fastapi._compat.serialize_sequence_value",
        "fastapi._compat.value_is_sequence",
        "fastapi.background.BackgroundTasks",
        "fastapi.concurrency.asynccontextmanager",
        "fastapi.concurrency.contextmanager_in_threadpool",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.models.SecurityRequirement",
        "fastapi.logger.logger",
        "fastapi.security.base.SecurityBase",
        "fastapi.security.oauth2.OAuth2",
        "fastapi.security.oauth2.SecurityScopes",
        "fastapi.security.open_id_connect_url.OpenIdConnect",
        "fastapi.utils.create_model_field",
        "fastapi.utils.get_path_param_names",
        "pydantic.BaseModel",
        "pydantic.fields.FieldInfo",
        "starlette.background.BackgroundTasks",
        "starlette.concurrency.run_in_threadpool",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.ImmutableMultiDict",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.UploadFile",
        "starlette.requests.HTTPConnection",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "python_multipart.__version__",
        "multipart.__version__",
        "multipart.multipart.parse_options_header"
      ],
      "fixtures": [],
      "assertions": [
        "assert depends is None, f'Cannot specify `Depends` in `Annotated` and default value together for {param_name!r}'",
        "assert field_info is None, f'Cannot specify a FastAPI annotation in `Annotated` and `Depends` as a default value together for {param_name!r}'",
        "assert depends is None, f'Cannot specify `Depends` for type {type_annotation!r}'",
        "assert field_info is None, f'Cannot specify FastAPI annotation for type {type_annotation!r}'",
        "assert field_info.default is Undefined or field_info.default is RequiredParam, f'`{field_info.__class__.__name__}` default value cannot be set in `Annotated` for {param_name!r}. Set the default value with `=` instead.'",
        "assert field_info is None, f'Cannot specify FastAPI annotations in `Annotated` and default value together for {param_name!r}'",
        "assert isinstance(field_info, params.Path), f'Cannot use `{field_info.__class__.__name__}` for path param {param_name!r}'",
        "assert is_scalar_field(field=field), 'Path params must be of one of the supported types'",
        "assert not is_path_param, 'Path parameters cannot have default values'",
        "assert is_scalar_field(field) or is_scalar_sequence_field(field) or (lenient_issubclass(field.type_, BaseModel) and getattr(field, 'shape', 1) == 1)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_annotation_from_field_info",
          "body": "def get_annotation_from_field_info(annotation: Any, field_info: FieldInfo, field_name: str) -> Any:\n    return annotation"
        },
        {
          "name": "create_model_field",
          "body": "def create_model_field(name: str, type_: Any, class_validators: Optional[Dict[str, Validator]]=None, default: Optional[Any]=Undefined, required: Union[bool, UndefinedType]=Undefined, model_config: Type[BaseConfig]=BaseConfig, field_info: Optional[FieldInfo]=None, alias: Optional[str]=None, mode: Literal['validation', 'serialization']='validation') -> ModelField:\n    class_validators = class_validators or {}\n    if PYDANTIC_V2:\n        field_info = field_info or FieldInfo(annotation=type_, default=default, alias=alias)\n    else:\n        field_info = field_info or FieldInfo()\n    kwargs = {'name': name, 'field_info': field_info}\n    if PYDANTIC_V2:\n        kwargs.update({'mode': mode})\n    else:\n        kwargs.update({'type_': type_, 'class_validators': class_validators, 'default': default, 'required': required, 'model_config': model_config, 'alias': alias})\n    try:\n        return ModelField(**kwargs)\n    except (RuntimeError, PydanticSchemaGenerationError):\n        raise fastapi.exceptions.FastAPIError(f'Invalid args for response field! Hint: check that {type_} is a valid Pydantic field type. If you are using a return type annotation that is not a valid Pydantic field (e.g. Union[Response, dict, None]) you can disable generating the response model from the type annotation with the path operation decorator parameter response_model=None. Read more: https://fastapi.tiangolo.com/tutorial/response-model/') from None"
        },
        {
          "name": "copy_field_info",
          "body": "def copy_field_info(*, field_info: FieldInfo, annotation: Any) -> FieldInfo:\n    cls = type(field_info)\n    merged_field_info = cls.from_annotation(annotation)\n    new_field_info = copy(field_info)\n    new_field_info.metadata = merged_field_info.metadata\n    new_field_info.annotation = merged_field_info.annotation\n    return new_field_info"
        },
        {
          "name": "ensure_multipart_is_installed",
          "body": "def ensure_multipart_is_installed() -> None:\n    try:\n        from python_multipart import __version__\n        assert __version__ > '0.0.12'\n    except (ImportError, AssertionError):\n        try:\n            from multipart import __version__\n            assert __version__\n            try:\n                from multipart.multipart import parse_options_header\n                assert parse_options_header\n            except ImportError:\n                logger.error(multipart_incorrect_install_error)\n                raise RuntimeError(multipart_incorrect_install_error) from None\n        except ImportError:\n            logger.error(multipart_not_installed_error)\n            raise RuntimeError(multipart_not_installed_error) from None"
        },
        {
          "name": "is_scalar_field",
          "body": "def is_scalar_field(field: ModelField) -> bool:\n    from fastapi import params\n    return field_annotation_is_scalar(field.field_info.annotation) and (not isinstance(field.field_info, params.Body))"
        },
        {
          "name": "params.Path",
          "body": "def Path(default: Annotated[Any, Doc(\"\\n            Default value if the parameter field is not set.\\n\\n            This doesn't affect `Path` parameters as the value is always required.\\n            The parameter is available only for compatibility.\\n            \")]=..., *, default_factory: Annotated[Union[Callable[[], Any], None], Doc(\"\\n            A callable to generate the default value.\\n\\n            This doesn't affect `Path` parameters as the value is always required.\\n            The parameter is available only for compatibility.\\n            \")]=_Unset, alias: Annotated[Optional[str], Doc(\"\\n            An alternative name for the parameter field.\\n\\n            This will be used to extract the data and for the generated OpenAPI.\\n            It is particularly useful when you can't use the name you want because it\\n            is a Python reserved keyword or similar.\\n            \")]=None, alias_priority: Annotated[Union[int, None], Doc('\\n            Priority of the alias. This affects whether an alias generator is used.\\n            ')]=_Unset, validation_alias: Annotated[Union[str, None], Doc(\"\\n            'Whitelist' validation step. The parameter field will be the single one\\n            allowed by the alias or set of aliases defined.\\n            \")]=None, serialization_alias: Annotated[Union[str, None], Doc(\"\\n            'Blacklist' validation step. The vanilla parameter field will be the\\n            single one of the alias' or set of aliases' fields and all the other\\n            fields will be ignored at serialization time.\\n            \")]=None, title: Annotated[Optional[str], Doc('\\n            Human-readable title.\\n            ')]=None, description: Annotated[Optional[str], Doc('\\n            Human-readable description.\\n            ')]=None, gt: Annotated[Optional[float], Doc('\\n            Greater than. If set, value must be greater than this. Only applicable to\\n            numbers.\\n            ')]=None, ge: Annotated[Optional[float], Doc('\\n            Greater than or equal. If set, value must be greater than or equal to\\n            this. Only applicable to numbers.\\n            ')]=None, lt: Annotated[Optional[float], Doc('\\n            Less than. If set, value must be less than this. Only applicable to numbers.\\n            ')]=None, le: Annotated[Optional[float], Doc('\\n            Less than or equal. If set, value must be less than or equal to this.\\n            Only applicable to numbers.\\n            ')]=None, min_length: Annotated[Optional[int], Doc('\\n            Minimum length for strings.\\n            ')]=None, max_length: Annotated[Optional[int], Doc('\\n            Maximum length for strings.\\n            ')]=None, pattern: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            ')]=None, regex: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            '), deprecated('Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead.')]=None, discriminator: Annotated[Union[str, None], Doc('\\n            Parameter field name for discriminating the type in a tagged union.\\n            ')]=None, strict: Annotated[Union[bool, None], Doc('\\n            If `True`, strict validation is applied to the field.\\n            ')]=_Unset, multiple_of: Annotated[Union[float, None], Doc('\\n            Value must be a multiple of this. Only applicable to numbers.\\n            ')]=_Unset, allow_inf_nan: Annotated[Union[bool, None], Doc('\\n            Allow `inf`, `-inf`, `nan`. Only applicable to numbers.\\n            ')]=_Unset, max_digits: Annotated[Union[int, None], Doc('\\n            Maximum number of allow digits for strings.\\n            ')]=_Unset, decimal_places: Annotated[Union[int, None], Doc('\\n            Maximum number of decimal places allowed for numbers.\\n            ')]=_Unset, examples: Annotated[Optional[List[Any]], Doc('\\n            Example values for this field.\\n            ')]=None, example: Annotated[Optional[Any], deprecated('Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.')]=_Unset, openapi_examples: Annotated[Optional[Dict[str, Example]], Doc(\"\\n            OpenAPI-specific examples.\\n\\n            It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n            Swagger UI (that provides the `/docs` interface) has better support for the\\n            OpenAPI-specific examples than the JSON Schema `examples`, that's the main\\n            use case for this.\\n\\n            Read more about it in the\\n            [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).\\n            \")]=None, deprecated: Annotated[Union[deprecated, str, bool, None], Doc('\\n            Mark this parameter field as deprecated.\\n\\n            It will affect the generated OpenAPI (e.g. visible at `/docs`).\\n            ')]=None, include_in_schema: Annotated[bool, Doc(\"\\n            To include (or not) this parameter field in the generated OpenAPI.\\n            You probably don't need it, but it's available.\\n\\n            This affects the generated OpenAPI (e.g. visible at `/docs`).\\n            \")]=True, json_schema_extra: Annotated[Union[Dict[str, Any], None], Doc('\\n            Any additional JSON schema data.\\n            ')]=None, **extra: Annotated[Any, Doc('\\n            Include extra fields used by the JSON Schema.\\n            '), deprecated('\\n            The `extra` kwargs is deprecated. Use `json_schema_extra` instead.\\n            ')]) -> Any:\n    \"\"\"\n    Declare a path parameter for a *path operation*.\n\n    Read more about it in the\n    [FastAPI docs for Path Parameters and Numeric Validations](https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/).\n\n    ```python\n    from typing import Annotated\n\n    from fastapi import FastAPI, Path\n\n    app = FastAPI()\n\n\n    @app.get(\"/items/{item_id}\")\n    async def read_items(\n        item_id: Annotated[int, Path(title=\"The ID of the item to get\")],\n    ):\n        return {\"item_id\": item_id}\n    ```\n    \"\"\"\n    return params.Path(default=default, default_factory=default_factory, alias=alias, alias_priority=alias_priority, validation_alias=validation_alias, serialization_alias=serialization_alias, title=title, description=description, gt=gt, ge=ge, lt=lt, le=le, min_length=min_length, max_length=max_length, pattern=pattern, regex=regex, discriminator=discriminator, strict=strict, multiple_of=multiple_of, allow_inf_nan=allow_inf_nan, max_digits=max_digits, decimal_places=decimal_places, example=example, examples=examples, openapi_examples=openapi_examples, deprecated=deprecated, include_in_schema=include_in_schema, json_schema_extra=json_schema_extra, **extra)"
        },
        {
          "name": "is_uploadfile_or_nonable_uploadfile_annotation",
          "body": "def is_uploadfile_or_nonable_uploadfile_annotation(annotation: Any) -> bool:\n    if lenient_issubclass(annotation, UploadFile):\n        return True\n    origin = get_origin(annotation)\n    if origin is Union or origin is UnionType:\n        for arg in get_args(annotation):\n            if lenient_issubclass(arg, UploadFile):\n                return True\n    return False"
        },
        {
          "name": "is_uploadfile_sequence_annotation",
          "body": "def is_uploadfile_sequence_annotation(annotation: Any) -> bool:\n    origin = get_origin(annotation)\n    if origin is Union or origin is UnionType:\n        at_least_one = False\n        for arg in get_args(annotation):\n            if is_uploadfile_sequence_annotation(arg):\n                at_least_one = True\n                continue\n        return at_least_one\n    return field_annotation_is_sequence(annotation) and all((is_uploadfile_or_nonable_uploadfile_annotation(sub_annotation) for sub_annotation in get_args(annotation)))"
        },
        {
          "name": "params.File",
          "body": "def File(default: Annotated[Any, Doc('\\n            Default value if the parameter field is not set.\\n            ')]=Undefined, *, default_factory: Annotated[Union[Callable[[], Any], None], Doc(\"\\n            A callable to generate the default value.\\n\\n            This doesn't affect `Path` parameters as the value is always required.\\n            The parameter is available only for compatibility.\\n            \")]=_Unset, media_type: Annotated[str, Doc(\"\\n            The media type of this parameter field. Changing it would affect the\\n            generated OpenAPI, but currently it doesn't affect the parsing of the data.\\n            \")]='multipart/form-data', alias: Annotated[Optional[str], Doc(\"\\n            An alternative name for the parameter field.\\n\\n            This will be used to extract the data and for the generated OpenAPI.\\n            It is particularly useful when you can't use the name you want because it\\n            is a Python reserved keyword or similar.\\n            \")]=None, alias_priority: Annotated[Union[int, None], Doc('\\n            Priority of the alias. This affects whether an alias generator is used.\\n            ')]=_Unset, validation_alias: Annotated[Union[str, None], Doc(\"\\n            'Whitelist' validation step. The parameter field will be the single one\\n            allowed by the alias or set of aliases defined.\\n            \")]=None, serialization_alias: Annotated[Union[str, None], Doc(\"\\n            'Blacklist' validation step. The vanilla parameter field will be the\\n            single one of the alias' or set of aliases' fields and all the other\\n            fields will be ignored at serialization time.\\n            \")]=None, title: Annotated[Optional[str], Doc('\\n            Human-readable title.\\n            ')]=None, description: Annotated[Optional[str], Doc('\\n            Human-readable description.\\n            ')]=None, gt: Annotated[Optional[float], Doc('\\n            Greater than. If set, value must be greater than this. Only applicable to\\n            numbers.\\n            ')]=None, ge: Annotated[Optional[float], Doc('\\n            Greater than or equal. If set, value must be greater than or equal to\\n            this. Only applicable to numbers.\\n            ')]=None, lt: Annotated[Optional[float], Doc('\\n            Less than. If set, value must be less than this. Only applicable to numbers.\\n            ')]=None, le: Annotated[Optional[float], Doc('\\n            Less than or equal. If set, value must be less than or equal to this.\\n            Only applicable to numbers.\\n            ')]=None, min_length: Annotated[Optional[int], Doc('\\n            Minimum length for strings.\\n            ')]=None, max_length: Annotated[Optional[int], Doc('\\n            Maximum length for strings.\\n            ')]=None, pattern: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            ')]=None, regex: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            '), deprecated('Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead.')]=None, discriminator: Annotated[Union[str, None], Doc('\\n            Parameter field name for discriminating the type in a tagged union.\\n            ')]=None, strict: Annotated[Union[bool, None], Doc('\\n            If `True`, strict validation is applied to the field.\\n            ')]=_Unset, multiple_of: Annotated[Union[float, None], Doc('\\n            Value must be a multiple of this. Only applicable to numbers.\\n            ')]=_Unset, allow_inf_nan: Annotated[Union[bool, None], Doc('\\n            Allow `inf`, `-inf`, `nan`. Only applicable to numbers.\\n            ')]=_Unset, max_digits: Annotated[Union[int, None], Doc('\\n            Maximum number of allow digits for strings.\\n            ')]=_Unset, decimal_places: Annotated[Union[int, None], Doc('\\n            Maximum number of decimal places allowed for numbers.\\n            ')]=_Unset, examples: Annotated[Optional[List[Any]], Doc('\\n            Example values for this field.\\n            ')]=None, example: Annotated[Optional[Any], deprecated('Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.')]=_Unset, openapi_examples: Annotated[Optional[Dict[str, Example]], Doc(\"\\n            OpenAPI-specific examples.\\n\\n            It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n            Swagger UI (that provides the `/docs` interface) has better support for the\\n            OpenAPI-specific examples than the JSON Schema `examples`, that's the main\\n            use case for this.\\n\\n            Read more about it in the\\n            [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).\\n            \")]=None, deprecated: Annotated[Union[deprecated, str, bool, None], Doc('\\n            Mark this parameter field as deprecated.\\n\\n            It will affect the generated OpenAPI (e.g. visible at `/docs`).\\n            ')]=None, include_in_schema: Annotated[bool, Doc(\"\\n            To include (or not) this parameter field in the generated OpenAPI.\\n            You probably don't need it, but it's available.\\n\\n            This affects the generated OpenAPI (e.g. visible at `/docs`).\\n            \")]=True, json_schema_extra: Annotated[Union[Dict[str, Any], None], Doc('\\n            Any additional JSON schema data.\\n            ')]=None, **extra: Annotated[Any, Doc('\\n            Include extra fields used by the JSON Schema.\\n            '), deprecated('\\n            The `extra` kwargs is deprecated. Use `json_schema_extra` instead.\\n            ')]) -> Any:\n    return params.File(default=default, default_factory=default_factory, media_type=media_type, alias=alias, alias_priority=alias_priority, validation_alias=validation_alias, serialization_alias=serialization_alias, title=title, description=description, gt=gt, ge=ge, lt=lt, le=le, min_length=min_length, max_length=max_length, pattern=pattern, regex=regex, discriminator=discriminator, strict=strict, multiple_of=multiple_of, allow_inf_nan=allow_inf_nan, max_digits=max_digits, decimal_places=decimal_places, example=example, examples=examples, openapi_examples=openapi_examples, deprecated=deprecated, include_in_schema=include_in_schema, json_schema_extra=json_schema_extra, **extra)"
        },
        {
          "name": "is_scalar_field",
          "body": "def is_scalar_field(field: ModelField) -> bool:\n    from fastapi import params\n    return field_annotation_is_scalar(field.field_info.annotation) and (not isinstance(field.field_info, params.Body))"
        },
        {
          "name": "is_scalar_sequence_field",
          "body": "def is_scalar_sequence_field(field: ModelField) -> bool:\n    return field_annotation_is_scalar_sequence(field.field_info.annotation)"
        },
        {
          "name": "field_annotation_is_scalar",
          "body": "def field_annotation_is_scalar(annotation: Any) -> bool:\n    return annotation is Ellipsis or not field_annotation_is_complex(annotation)"
        },
        {
          "name": "params.Body",
          "body": "def Body(default: Annotated[Any, Doc('\\n            Default value if the parameter field is not set.\\n            ')]=Undefined, *, default_factory: Annotated[Union[Callable[[], Any], None], Doc(\"\\n            A callable to generate the default value.\\n\\n            This doesn't affect `Path` parameters as the value is always required.\\n            The parameter is available only for compatibility.\\n            \")]=_Unset, embed: Annotated[Union[bool, None], Doc('\\n            When `embed` is `True`, the parameter will be expected in a JSON body as a\\n            key instead of being the JSON body itself.\\n\\n            This happens automatically when more than one `Body` parameter is declared.\\n\\n            Read more about it in the\\n            [FastAPI docs for Body - Multiple Parameters](https://fastapi.tiangolo.com/tutorial/body-multiple-params/#embed-a-single-body-parameter).\\n            ')]=None, media_type: Annotated[str, Doc(\"\\n            The media type of this parameter field. Changing it would affect the\\n            generated OpenAPI, but currently it doesn't affect the parsing of the data.\\n            \")]='application/json', alias: Annotated[Optional[str], Doc(\"\\n            An alternative name for the parameter field.\\n\\n            This will be used to extract the data and for the generated OpenAPI.\\n            It is particularly useful when you can't use the name you want because it\\n            is a Python reserved keyword or similar.\\n            \")]=None, alias_priority: Annotated[Union[int, None], Doc('\\n            Priority of the alias. This affects whether an alias generator is used.\\n            ')]=_Unset, validation_alias: Annotated[Union[str, None], Doc(\"\\n            'Whitelist' validation step. The parameter field will be the single one\\n            allowed by the alias or set of aliases defined.\\n            \")]=None, serialization_alias: Annotated[Union[str, None], Doc(\"\\n            'Blacklist' validation step. The vanilla parameter field will be the\\n            single one of the alias' or set of aliases' fields and all the other\\n            fields will be ignored at serialization time.\\n            \")]=None, title: Annotated[Optional[str], Doc('\\n            Human-readable title.\\n            ')]=None, description: Annotated[Optional[str], Doc('\\n            Human-readable description.\\n            ')]=None, gt: Annotated[Optional[float], Doc('\\n            Greater than. If set, value must be greater than this. Only applicable to\\n            numbers.\\n            ')]=None, ge: Annotated[Optional[float], Doc('\\n            Greater than or equal. If set, value must be greater than or equal to\\n            this. Only applicable to numbers.\\n            ')]=None, lt: Annotated[Optional[float], Doc('\\n            Less than. If set, value must be less than this. Only applicable to numbers.\\n            ')]=None, le: Annotated[Optional[float], Doc('\\n            Less than or equal. If set, value must be less than or equal to this.\\n            Only applicable to numbers.\\n            ')]=None, min_length: Annotated[Optional[int], Doc('\\n            Minimum length for strings.\\n            ')]=None, max_length: Annotated[Optional[int], Doc('\\n            Maximum length for strings.\\n            ')]=None, pattern: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            ')]=None, regex: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            '), deprecated('Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead.')]=None, discriminator: Annotated[Union[str, None], Doc('\\n            Parameter field name for discriminating the type in a tagged union.\\n            ')]=None, strict: Annotated[Union[bool, None], Doc('\\n            If `True`, strict validation is applied to the field.\\n            ')]=_Unset, multiple_of: Annotated[Union[float, None], Doc('\\n            Value must be a multiple of this. Only applicable to numbers.\\n            ')]=_Unset, allow_inf_nan: Annotated[Union[bool, None], Doc('\\n            Allow `inf`, `-inf`, `nan`. Only applicable to numbers.\\n            ')]=_Unset, max_digits: Annotated[Union[int, None], Doc('\\n            Maximum number of allow digits for strings.\\n            ')]=_Unset, decimal_places: Annotated[Union[int, None], Doc('\\n            Maximum number of decimal places allowed for numbers.\\n            ')]=_Unset, examples: Annotated[Optional[List[Any]], Doc('\\n            Example values for this field.\\n            ')]=None, example: Annotated[Optional[Any], deprecated('Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.')]=_Unset, openapi_examples: Annotated[Optional[Dict[str, Example]], Doc(\"\\n            OpenAPI-specific examples.\\n\\n            It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n            Swagger UI (that provides the `/docs` interface) has better support for the\\n            OpenAPI-specific examples than the JSON Schema `examples`, that's the main\\n            use case for this.\\n\\n            Read more about it in the\\n            [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).\\n            \")]=None, deprecated: Annotated[Union[deprecated, str, bool, None], Doc('\\n            Mark this parameter field as deprecated.\\n\\n            It will affect the generated OpenAPI (e.g. visible at `/docs`).\\n            ')]=None, include_in_schema: Annotated[bool, Doc(\"\\n            To include (or not) this parameter field in the generated OpenAPI.\\n            You probably don't need it, but it's available.\\n\\n            This affects the generated OpenAPI (e.g. visible at `/docs`).\\n            \")]=True, json_schema_extra: Annotated[Union[Dict[str, Any], None], Doc('\\n            Any additional JSON schema data.\\n            ')]=None, **extra: Annotated[Any, Doc('\\n            Include extra fields used by the JSON Schema.\\n            '), deprecated('\\n            The `extra` kwargs is deprecated. Use `json_schema_extra` instead.\\n            ')]) -> Any:\n    return params.Body(default=default, default_factory=default_factory, embed=embed, media_type=media_type, alias=alias, alias_priority=alias_priority, validation_alias=validation_alias, serialization_alias=serialization_alias, title=title, description=description, gt=gt, ge=ge, lt=lt, le=le, min_length=min_length, max_length=max_length, pattern=pattern, regex=regex, discriminator=discriminator, strict=strict, multiple_of=multiple_of, allow_inf_nan=allow_inf_nan, max_digits=max_digits, decimal_places=decimal_places, example=example, examples=examples, openapi_examples=openapi_examples, deprecated=deprecated, include_in_schema=include_in_schema, json_schema_extra=json_schema_extra, **extra)"
        },
        {
          "name": "params.Query",
          "body": "def Query(default: Annotated[Any, Doc('\\n            Default value if the parameter field is not set.\\n            ')]=Undefined, *, default_factory: Annotated[Union[Callable[[], Any], None], Doc(\"\\n            A callable to generate the default value.\\n\\n            This doesn't affect `Path` parameters as the value is always required.\\n            The parameter is available only for compatibility.\\n            \")]=_Unset, alias: Annotated[Optional[str], Doc(\"\\n            An alternative name for the parameter field.\\n\\n            This will be used to extract the data and for the generated OpenAPI.\\n            It is particularly useful when you can't use the name you want because it\\n            is a Python reserved keyword or similar.\\n            \")]=None, alias_priority: Annotated[Union[int, None], Doc('\\n            Priority of the alias. This affects whether an alias generator is used.\\n            ')]=_Unset, validation_alias: Annotated[Union[str, None], Doc(\"\\n            'Whitelist' validation step. The parameter field will be the single one\\n            allowed by the alias or set of aliases defined.\\n            \")]=None, serialization_alias: Annotated[Union[str, None], Doc(\"\\n            'Blacklist' validation step. The vanilla parameter field will be the\\n            single one of the alias' or set of aliases' fields and all the other\\n            fields will be ignored at serialization time.\\n            \")]=None, title: Annotated[Optional[str], Doc('\\n            Human-readable title.\\n            ')]=None, description: Annotated[Optional[str], Doc('\\n            Human-readable description.\\n            ')]=None, gt: Annotated[Optional[float], Doc('\\n            Greater than. If set, value must be greater than this. Only applicable to\\n            numbers.\\n            ')]=None, ge: Annotated[Optional[float], Doc('\\n            Greater than or equal. If set, value must be greater than or equal to\\n            this. Only applicable to numbers.\\n            ')]=None, lt: Annotated[Optional[float], Doc('\\n            Less than. If set, value must be less than this. Only applicable to numbers.\\n            ')]=None, le: Annotated[Optional[float], Doc('\\n            Less than or equal. If set, value must be less than or equal to this.\\n            Only applicable to numbers.\\n            ')]=None, min_length: Annotated[Optional[int], Doc('\\n            Minimum length for strings.\\n            ')]=None, max_length: Annotated[Optional[int], Doc('\\n            Maximum length for strings.\\n            ')]=None, pattern: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            ')]=None, regex: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            '), deprecated('Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead.')]=None, discriminator: Annotated[Union[str, None], Doc('\\n            Parameter field name for discriminating the type in a tagged union.\\n            ')]=None, strict: Annotated[Union[bool, None], Doc('\\n            If `True`, strict validation is applied to the field.\\n            ')]=_Unset, multiple_of: Annotated[Union[float, None], Doc('\\n            Value must be a multiple of this. Only applicable to numbers.\\n            ')]=_Unset, allow_inf_nan: Annotated[Union[bool, None], Doc('\\n            Allow `inf`, `-inf`, `nan`. Only applicable to numbers.\\n            ')]=_Unset, max_digits: Annotated[Union[int, None], Doc('\\n            Maximum number of allow digits for strings.\\n            ')]=_Unset, decimal_places: Annotated[Union[int, None], Doc('\\n            Maximum number of decimal places allowed for numbers.\\n            ')]=_Unset, examples: Annotated[Optional[List[Any]], Doc('\\n            Example values for this field.\\n            ')]=None, example: Annotated[Optional[Any], deprecated('Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.')]=_Unset, openapi_examples: Annotated[Optional[Dict[str, Example]], Doc(\"\\n            OpenAPI-specific examples.\\n\\n            It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n            Swagger UI (that provides the `/docs` interface) has better support for the\\n            OpenAPI-specific examples than the JSON Schema `examples`, that's the main\\n            use case for this.\\n\\n            Read more about it in the\\n            [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).\\n            \")]=None, deprecated: Annotated[Union[deprecated, str, bool, None], Doc('\\n            Mark this parameter field as deprecated.\\n\\n            It will affect the generated OpenAPI (e.g. visible at `/docs`).\\n            ')]=None, include_in_schema: Annotated[bool, Doc(\"\\n            To include (or not) this parameter field in the generated OpenAPI.\\n            You probably don't need it, but it's available.\\n\\n            This affects the generated OpenAPI (e.g. visible at `/docs`).\\n            \")]=True, json_schema_extra: Annotated[Union[Dict[str, Any], None], Doc('\\n            Any additional JSON schema data.\\n            ')]=None, **extra: Annotated[Any, Doc('\\n            Include extra fields used by the JSON Schema.\\n            '), deprecated('\\n            The `extra` kwargs is deprecated. Use `json_schema_extra` instead.\\n            ')]) -> Any:\n    return params.Query(default=default, default_factory=default_factory, alias=alias, alias_priority=alias_priority, validation_alias=validation_alias, serialization_alias=serialization_alias, title=title, description=description, gt=gt, ge=ge, lt=lt, le=le, min_length=min_length, max_length=max_length, pattern=pattern, regex=regex, discriminator=discriminator, strict=strict, multiple_of=multiple_of, allow_inf_nan=allow_inf_nan, max_digits=max_digits, decimal_places=decimal_places, example=example, examples=examples, openapi_examples=openapi_examples, deprecated=deprecated, include_in_schema=include_in_schema, json_schema_extra=json_schema_extra, **extra)"
        }
      ]
    },
    {
      "name": "add_param_to_fields",
      "module": "utils",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\dependencies\\utils.py",
      "line_number": 514,
      "end_line_number": 527,
      "source_code": "def add_param_to_fields(*, field: ModelField, dependant: Dependant) -> None:\n    field_info = field.field_info\n    field_info_in = getattr(field_info, \"in_\", None)\n    if field_info_in == params.ParamTypes.path:\n        dependant.path_params.append(field)\n    elif field_info_in == params.ParamTypes.query:\n        dependant.query_params.append(field)\n    elif field_info_in == params.ParamTypes.header:\n        dependant.header_params.append(field)\n    else:\n        assert (\n            field_info_in == params.ParamTypes.cookie\n        ), f\"non-body parameters must be in path, query, header or cookie: {field.name}\"\n        dependant.cookie_params.append(field)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "inspect",
        "contextlib.AsyncExitStack",
        "contextlib.contextmanager",
        "copy.copy",
        "copy.deepcopy",
        "dataclasses.dataclass",
        "typing.Any",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.ForwardRef",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "typing.cast",
        "anyio",
        "fastapi.params",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.ErrorWrapper",
        "fastapi._compat.ModelField",
        "fastapi._compat.RequiredParam",
        "fastapi._compat.Undefined",
        "fastapi._compat._regenerate_error_with_loc",
        "fastapi._compat.copy_field_info",
        "fastapi._compat.create_body_model",
        "fastapi._compat.evaluate_forwardref",
        "fastapi._compat.field_annotation_is_scalar",
        "fastapi._compat.get_annotation_from_field_info",
        "fastapi._compat.get_cached_model_fields",
        "fastapi._compat.get_missing_field_error",
        "fastapi._compat.is_bytes_field",
        "fastapi._compat.is_bytes_sequence_field",
        "fastapi._compat.is_scalar_field",
        "fastapi._compat.is_scalar_sequence_field",
        "fastapi._compat.is_sequence_field",
        "fastapi._compat.is_uploadfile_or_nonable_uploadfile_annotation",
        "fastapi._compat.is_uploadfile_sequence_annotation",
        "fastapi._compat.lenient_issubclass",
        "fastapi._compat.sequence_types",
        "fastapi._compat.serialize_sequence_value",
        "fastapi._compat.value_is_sequence",
        "fastapi.background.BackgroundTasks",
        "fastapi.concurrency.asynccontextmanager",
        "fastapi.concurrency.contextmanager_in_threadpool",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.models.SecurityRequirement",
        "fastapi.logger.logger",
        "fastapi.security.base.SecurityBase",
        "fastapi.security.oauth2.OAuth2",
        "fastapi.security.oauth2.SecurityScopes",
        "fastapi.security.open_id_connect_url.OpenIdConnect",
        "fastapi.utils.create_model_field",
        "fastapi.utils.get_path_param_names",
        "pydantic.BaseModel",
        "pydantic.fields.FieldInfo",
        "starlette.background.BackgroundTasks",
        "starlette.concurrency.run_in_threadpool",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.ImmutableMultiDict",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.UploadFile",
        "starlette.requests.HTTPConnection",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "python_multipart.__version__",
        "multipart.__version__",
        "multipart.multipart.parse_options_header"
      ],
      "fixtures": [],
      "assertions": [
        "assert field_info_in == params.ParamTypes.cookie, f'non-body parameters must be in path, query, header or cookie: {field.name}'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "is_coroutine_callable",
      "module": "utils",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\dependencies\\utils.py",
      "line_number": 530,
      "end_line_number": 536,
      "source_code": "def is_coroutine_callable(call: Callable[..., Any]) -> bool:\n    if inspect.isroutine(call):\n        return inspect.iscoroutinefunction(call)\n    if inspect.isclass(call):\n        return False\n    dunder_call = getattr(call, \"__call__\", None)  # noqa: B004\n    return inspect.iscoroutinefunction(dunder_call)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "call"
      ],
      "imports": [
        "inspect",
        "contextlib.AsyncExitStack",
        "contextlib.contextmanager",
        "copy.copy",
        "copy.deepcopy",
        "dataclasses.dataclass",
        "typing.Any",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.ForwardRef",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "typing.cast",
        "anyio",
        "fastapi.params",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.ErrorWrapper",
        "fastapi._compat.ModelField",
        "fastapi._compat.RequiredParam",
        "fastapi._compat.Undefined",
        "fastapi._compat._regenerate_error_with_loc",
        "fastapi._compat.copy_field_info",
        "fastapi._compat.create_body_model",
        "fastapi._compat.evaluate_forwardref",
        "fastapi._compat.field_annotation_is_scalar",
        "fastapi._compat.get_annotation_from_field_info",
        "fastapi._compat.get_cached_model_fields",
        "fastapi._compat.get_missing_field_error",
        "fastapi._compat.is_bytes_field",
        "fastapi._compat.is_bytes_sequence_field",
        "fastapi._compat.is_scalar_field",
        "fastapi._compat.is_scalar_sequence_field",
        "fastapi._compat.is_sequence_field",
        "fastapi._compat.is_uploadfile_or_nonable_uploadfile_annotation",
        "fastapi._compat.is_uploadfile_sequence_annotation",
        "fastapi._compat.lenient_issubclass",
        "fastapi._compat.sequence_types",
        "fastapi._compat.serialize_sequence_value",
        "fastapi._compat.value_is_sequence",
        "fastapi.background.BackgroundTasks",
        "fastapi.concurrency.asynccontextmanager",
        "fastapi.concurrency.contextmanager_in_threadpool",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.models.SecurityRequirement",
        "fastapi.logger.logger",
        "fastapi.security.base.SecurityBase",
        "fastapi.security.oauth2.OAuth2",
        "fastapi.security.oauth2.SecurityScopes",
        "fastapi.security.open_id_connect_url.OpenIdConnect",
        "fastapi.utils.create_model_field",
        "fastapi.utils.get_path_param_names",
        "pydantic.BaseModel",
        "pydantic.fields.FieldInfo",
        "starlette.background.BackgroundTasks",
        "starlette.concurrency.run_in_threadpool",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.ImmutableMultiDict",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.UploadFile",
        "starlette.requests.HTTPConnection",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "python_multipart.__version__",
        "multipart.__version__",
        "multipart.multipart.parse_options_header"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "is_async_gen_callable",
      "module": "utils",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\dependencies\\utils.py",
      "line_number": 539,
      "end_line_number": 543,
      "source_code": "def is_async_gen_callable(call: Callable[..., Any]) -> bool:\n    if inspect.isasyncgenfunction(call):\n        return True\n    dunder_call = getattr(call, \"__call__\", None)  # noqa: B004\n    return inspect.isasyncgenfunction(dunder_call)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "call"
      ],
      "imports": [
        "inspect",
        "contextlib.AsyncExitStack",
        "contextlib.contextmanager",
        "copy.copy",
        "copy.deepcopy",
        "dataclasses.dataclass",
        "typing.Any",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.ForwardRef",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "typing.cast",
        "anyio",
        "fastapi.params",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.ErrorWrapper",
        "fastapi._compat.ModelField",
        "fastapi._compat.RequiredParam",
        "fastapi._compat.Undefined",
        "fastapi._compat._regenerate_error_with_loc",
        "fastapi._compat.copy_field_info",
        "fastapi._compat.create_body_model",
        "fastapi._compat.evaluate_forwardref",
        "fastapi._compat.field_annotation_is_scalar",
        "fastapi._compat.get_annotation_from_field_info",
        "fastapi._compat.get_cached_model_fields",
        "fastapi._compat.get_missing_field_error",
        "fastapi._compat.is_bytes_field",
        "fastapi._compat.is_bytes_sequence_field",
        "fastapi._compat.is_scalar_field",
        "fastapi._compat.is_scalar_sequence_field",
        "fastapi._compat.is_sequence_field",
        "fastapi._compat.is_uploadfile_or_nonable_uploadfile_annotation",
        "fastapi._compat.is_uploadfile_sequence_annotation",
        "fastapi._compat.lenient_issubclass",
        "fastapi._compat.sequence_types",
        "fastapi._compat.serialize_sequence_value",
        "fastapi._compat.value_is_sequence",
        "fastapi.background.BackgroundTasks",
        "fastapi.concurrency.asynccontextmanager",
        "fastapi.concurrency.contextmanager_in_threadpool",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.models.SecurityRequirement",
        "fastapi.logger.logger",
        "fastapi.security.base.SecurityBase",
        "fastapi.security.oauth2.OAuth2",
        "fastapi.security.oauth2.SecurityScopes",
        "fastapi.security.open_id_connect_url.OpenIdConnect",
        "fastapi.utils.create_model_field",
        "fastapi.utils.get_path_param_names",
        "pydantic.BaseModel",
        "pydantic.fields.FieldInfo",
        "starlette.background.BackgroundTasks",
        "starlette.concurrency.run_in_threadpool",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.ImmutableMultiDict",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.UploadFile",
        "starlette.requests.HTTPConnection",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "python_multipart.__version__",
        "multipart.__version__",
        "multipart.multipart.parse_options_header"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "is_gen_callable",
      "module": "utils",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\dependencies\\utils.py",
      "line_number": 546,
      "end_line_number": 550,
      "source_code": "def is_gen_callable(call: Callable[..., Any]) -> bool:\n    if inspect.isgeneratorfunction(call):\n        return True\n    dunder_call = getattr(call, \"__call__\", None)  # noqa: B004\n    return inspect.isgeneratorfunction(dunder_call)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "call"
      ],
      "imports": [
        "inspect",
        "contextlib.AsyncExitStack",
        "contextlib.contextmanager",
        "copy.copy",
        "copy.deepcopy",
        "dataclasses.dataclass",
        "typing.Any",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.ForwardRef",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "typing.cast",
        "anyio",
        "fastapi.params",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.ErrorWrapper",
        "fastapi._compat.ModelField",
        "fastapi._compat.RequiredParam",
        "fastapi._compat.Undefined",
        "fastapi._compat._regenerate_error_with_loc",
        "fastapi._compat.copy_field_info",
        "fastapi._compat.create_body_model",
        "fastapi._compat.evaluate_forwardref",
        "fastapi._compat.field_annotation_is_scalar",
        "fastapi._compat.get_annotation_from_field_info",
        "fastapi._compat.get_cached_model_fields",
        "fastapi._compat.get_missing_field_error",
        "fastapi._compat.is_bytes_field",
        "fastapi._compat.is_bytes_sequence_field",
        "fastapi._compat.is_scalar_field",
        "fastapi._compat.is_scalar_sequence_field",
        "fastapi._compat.is_sequence_field",
        "fastapi._compat.is_uploadfile_or_nonable_uploadfile_annotation",
        "fastapi._compat.is_uploadfile_sequence_annotation",
        "fastapi._compat.lenient_issubclass",
        "fastapi._compat.sequence_types",
        "fastapi._compat.serialize_sequence_value",
        "fastapi._compat.value_is_sequence",
        "fastapi.background.BackgroundTasks",
        "fastapi.concurrency.asynccontextmanager",
        "fastapi.concurrency.contextmanager_in_threadpool",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.models.SecurityRequirement",
        "fastapi.logger.logger",
        "fastapi.security.base.SecurityBase",
        "fastapi.security.oauth2.OAuth2",
        "fastapi.security.oauth2.SecurityScopes",
        "fastapi.security.open_id_connect_url.OpenIdConnect",
        "fastapi.utils.create_model_field",
        "fastapi.utils.get_path_param_names",
        "pydantic.BaseModel",
        "pydantic.fields.FieldInfo",
        "starlette.background.BackgroundTasks",
        "starlette.concurrency.run_in_threadpool",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.ImmutableMultiDict",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.UploadFile",
        "starlette.requests.HTTPConnection",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "python_multipart.__version__",
        "multipart.__version__",
        "multipart.multipart.parse_options_header"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_validate_value_with_model_field",
      "module": "utils",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\dependencies\\utils.py",
      "line_number": 698,
      "end_line_number": 713,
      "source_code": "def _validate_value_with_model_field(\n    *, field: ModelField, value: Any, values: Dict[str, Any], loc: Tuple[str, ...]\n) -> Tuple[Any, List[Any]]:\n    if value is None:\n        if field.required:\n            return None, [get_missing_field_error(loc=loc)]\n        else:\n            return deepcopy(field.default), []\n    v_, errors_ = field.validate(value, values, loc=loc)\n    if isinstance(errors_, ErrorWrapper):\n        return None, [errors_]\n    elif isinstance(errors_, list):\n        new_errors = _regenerate_error_with_loc(errors=errors_, loc_prefix=())\n        return None, new_errors\n    else:\n        return v_, []",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "inspect",
        "contextlib.AsyncExitStack",
        "contextlib.contextmanager",
        "copy.copy",
        "copy.deepcopy",
        "dataclasses.dataclass",
        "typing.Any",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.ForwardRef",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "typing.cast",
        "anyio",
        "fastapi.params",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.ErrorWrapper",
        "fastapi._compat.ModelField",
        "fastapi._compat.RequiredParam",
        "fastapi._compat.Undefined",
        "fastapi._compat._regenerate_error_with_loc",
        "fastapi._compat.copy_field_info",
        "fastapi._compat.create_body_model",
        "fastapi._compat.evaluate_forwardref",
        "fastapi._compat.field_annotation_is_scalar",
        "fastapi._compat.get_annotation_from_field_info",
        "fastapi._compat.get_cached_model_fields",
        "fastapi._compat.get_missing_field_error",
        "fastapi._compat.is_bytes_field",
        "fastapi._compat.is_bytes_sequence_field",
        "fastapi._compat.is_scalar_field",
        "fastapi._compat.is_scalar_sequence_field",
        "fastapi._compat.is_sequence_field",
        "fastapi._compat.is_uploadfile_or_nonable_uploadfile_annotation",
        "fastapi._compat.is_uploadfile_sequence_annotation",
        "fastapi._compat.lenient_issubclass",
        "fastapi._compat.sequence_types",
        "fastapi._compat.serialize_sequence_value",
        "fastapi._compat.value_is_sequence",
        "fastapi.background.BackgroundTasks",
        "fastapi.concurrency.asynccontextmanager",
        "fastapi.concurrency.contextmanager_in_threadpool",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.models.SecurityRequirement",
        "fastapi.logger.logger",
        "fastapi.security.base.SecurityBase",
        "fastapi.security.oauth2.OAuth2",
        "fastapi.security.oauth2.SecurityScopes",
        "fastapi.security.open_id_connect_url.OpenIdConnect",
        "fastapi.utils.create_model_field",
        "fastapi.utils.get_path_param_names",
        "pydantic.BaseModel",
        "pydantic.fields.FieldInfo",
        "starlette.background.BackgroundTasks",
        "starlette.concurrency.run_in_threadpool",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.ImmutableMultiDict",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.UploadFile",
        "starlette.requests.HTTPConnection",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "python_multipart.__version__",
        "multipart.__version__",
        "multipart.multipart.parse_options_header"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "field.validate",
          "body": "@classmethod\ndef validate(cls: Type['UploadFile'], v: Any) -> Any:\n    if not isinstance(v, StarletteUploadFile):\n        raise ValueError(f'Expected UploadFile, received: {type(v)}')\n    return v"
        },
        {
          "name": "_regenerate_error_with_loc",
          "body": "def _regenerate_error_with_loc(*, errors: Sequence[Any], loc_prefix: Tuple[Union[str, int], ...]) -> List[Dict[str, Any]]:\n    updated_loc_errors: List[Any] = [{**err, 'loc': loc_prefix + err.get('loc', ())} for err in _normalize_errors(errors)]\n    return updated_loc_errors"
        },
        {
          "name": "get_missing_field_error",
          "body": "def get_missing_field_error(loc: Tuple[str, ...]) -> Dict[str, Any]:\n    error = ValidationError.from_exception_data('Field required', [{'type': 'missing', 'loc': loc, 'input': {}}]).errors(include_url=False)[0]\n    error['input'] = None\n    return error"
        }
      ]
    },
    {
      "name": "_get_multidict_value",
      "module": "utils",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\dependencies\\utils.py",
      "line_number": 716,
      "end_line_number": 737,
      "source_code": "def _get_multidict_value(\n    field: ModelField, values: Mapping[str, Any], alias: Union[str, None] = None\n) -> Any:\n    alias = alias or field.alias\n    if is_sequence_field(field) and isinstance(values, (ImmutableMultiDict, Headers)):\n        value = values.getlist(alias)\n    else:\n        value = values.get(alias, None)\n    if (\n        value is None\n        or (\n            isinstance(field.field_info, params.Form)\n            and isinstance(value, str)  # For type checks\n            and value == \"\"\n        )\n        or (is_sequence_field(field) and len(value) == 0)\n    ):\n        if field.required:\n            return\n        else:\n            return deepcopy(field.default)\n    return value",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "field",
        "values",
        "alias"
      ],
      "imports": [
        "inspect",
        "contextlib.AsyncExitStack",
        "contextlib.contextmanager",
        "copy.copy",
        "copy.deepcopy",
        "dataclasses.dataclass",
        "typing.Any",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.ForwardRef",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "typing.cast",
        "anyio",
        "fastapi.params",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.ErrorWrapper",
        "fastapi._compat.ModelField",
        "fastapi._compat.RequiredParam",
        "fastapi._compat.Undefined",
        "fastapi._compat._regenerate_error_with_loc",
        "fastapi._compat.copy_field_info",
        "fastapi._compat.create_body_model",
        "fastapi._compat.evaluate_forwardref",
        "fastapi._compat.field_annotation_is_scalar",
        "fastapi._compat.get_annotation_from_field_info",
        "fastapi._compat.get_cached_model_fields",
        "fastapi._compat.get_missing_field_error",
        "fastapi._compat.is_bytes_field",
        "fastapi._compat.is_bytes_sequence_field",
        "fastapi._compat.is_scalar_field",
        "fastapi._compat.is_scalar_sequence_field",
        "fastapi._compat.is_sequence_field",
        "fastapi._compat.is_uploadfile_or_nonable_uploadfile_annotation",
        "fastapi._compat.is_uploadfile_sequence_annotation",
        "fastapi._compat.lenient_issubclass",
        "fastapi._compat.sequence_types",
        "fastapi._compat.serialize_sequence_value",
        "fastapi._compat.value_is_sequence",
        "fastapi.background.BackgroundTasks",
        "fastapi.concurrency.asynccontextmanager",
        "fastapi.concurrency.contextmanager_in_threadpool",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.models.SecurityRequirement",
        "fastapi.logger.logger",
        "fastapi.security.base.SecurityBase",
        "fastapi.security.oauth2.OAuth2",
        "fastapi.security.oauth2.SecurityScopes",
        "fastapi.security.open_id_connect_url.OpenIdConnect",
        "fastapi.utils.create_model_field",
        "fastapi.utils.get_path_param_names",
        "pydantic.BaseModel",
        "pydantic.fields.FieldInfo",
        "starlette.background.BackgroundTasks",
        "starlette.concurrency.run_in_threadpool",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.ImmutableMultiDict",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.UploadFile",
        "starlette.requests.HTTPConnection",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "python_multipart.__version__",
        "multipart.__version__",
        "multipart.multipart.parse_options_header"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "is_sequence_field",
          "body": "def is_sequence_field(field: ModelField) -> bool:\n    return field_annotation_is_sequence(field.field_info.annotation)"
        },
        {
          "name": "values.get",
          "body": "def get(self, path: Annotated[str, Doc('\\n                The URL path to be used for this *path operation*.\\n\\n                For example, in `http://example.com/items`, the path is `/items`.\\n                ')], *, response_model: Annotated[Any, Doc(\"\\n                The type to use for the response.\\n\\n                It could be any valid Pydantic *field* type. So, it doesn't have to\\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\\n                etc.\\n\\n                It will be used for:\\n\\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\\n                    show it as the response (JSON Schema).\\n                * Serialization: you could return an arbitrary object and the\\n                    `response_model` would be used to serialize that object into the\\n                    corresponding JSON.\\n                * Filtering: the JSON sent to the client will only contain the data\\n                    (fields) defined in the `response_model`. If you returned an object\\n                    that contains an attribute `password` but the `response_model` does\\n                    not include that field, the JSON sent to the client would not have\\n                    that `password`.\\n                * Validation: whatever you return will be serialized with the\\n                    `response_model`, converting any data as necessary to generate the\\n                    corresponding JSON. But if the data in the object returned is not\\n                    valid, that would mean a violation of the contract with the client,\\n                    so it's an error from the API developer. So, FastAPI will raise an\\n                    error and return a 500 error code (Internal Server Error).\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\\n                \")]=Default(None), status_code: Annotated[Optional[int], Doc('\\n                The default status code to be used for the response.\\n\\n                You could override the status code by returning a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\\n                ')]=None, tags: Annotated[Optional[List[Union[str, Enum]]], Doc('\\n                A list of tags to be applied to the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\\n                ')]=None, dependencies: Annotated[Optional[Sequence[Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to the\\n                *path operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\\n                ')]=None, summary: Annotated[Optional[str], Doc('\\n                A summary for the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, description: Annotated[Optional[str], Doc('\\n                A description for the *path operation*.\\n\\n                If not provided, it will be extracted automatically from the docstring\\n                of the *path operation function*.\\n\\n                It can contain Markdown.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, response_description: Annotated[str, Doc('\\n                The description for the default response.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]='Successful Response', responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses that could be returned by this *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark this *path operation* as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, operation_id: Annotated[Optional[str], Doc('\\n                Custom operation ID to be used by this *path operation*.\\n\\n                By default, it is generated automatically.\\n\\n                If you provide a custom operation ID, you need to make sure it is\\n                unique for the whole API.\\n\\n                You can customize the\\n                operation ID generation with the parameter\\n                `generate_unique_id_function` in the `FastAPI` class.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=None, response_model_include: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to include only certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_exclude: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to exclude certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_by_alias: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response model\\n                should be serialized by alias when an alias is used.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=True, response_model_exclude_unset: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that were not set and\\n                have their default values. This is different from\\n                `response_model_exclude_defaults` in that if the fields are set,\\n                they will be included in the response, even if the value is the same\\n                as the default.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_defaults: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that have the same value\\n                as the default. This is different from `response_model_exclude_unset`\\n                in that if the fields are set but contain the same default values,\\n                they will be excluded from the response.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_none: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data should\\n                exclude fields set to `None`.\\n\\n                This is much simpler (less smart) than `response_model_exclude_unset`\\n                and `response_model_exclude_defaults`. You probably want to use one of\\n                those two instead of this one, as those allow returning `None` values\\n                when it makes sense.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\\n                ')]=False, include_in_schema: Annotated[bool, Doc('\\n                Include this *path operation* in the generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\\n                ')]=True, response_class: Annotated[Type[Response], Doc('\\n                Response class to be used for this *path operation*.\\n\\n                This will not be used if you return a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\\n                ')]=Default(JSONResponse), name: Annotated[Optional[str], Doc('\\n                Name for this *path operation*. Only used internally.\\n                ')]=None, callbacks: Annotated[Optional[List[BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")]=None, openapi_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n                Extra metadata to be included in the OpenAPI schema for this *path\\n                operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\\n                ')]=None, generate_unique_id_function: Annotated[Callable[[routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=Default(generate_unique_id)) -> Callable[[DecoratedCallable], DecoratedCallable]:\n    \"\"\"\n        Add a *path operation* using an HTTP GET operation.\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI\n\n        app = FastAPI()\n\n        @app.get(\"/items/\")\n        def read_items():\n            return [{\"name\": \"Empanada\"}, {\"name\": \"Arepa\"}]\n        ```\n        \"\"\"\n    return self.router.get(path, response_model=response_model, status_code=status_code, tags=tags, dependencies=dependencies, summary=summary, description=description, response_description=response_description, responses=responses, deprecated=deprecated, operation_id=operation_id, response_model_include=response_model_include, response_model_exclude=response_model_exclude, response_model_by_alias=response_model_by_alias, response_model_exclude_unset=response_model_exclude_unset, response_model_exclude_defaults=response_model_exclude_defaults, response_model_exclude_none=response_model_exclude_none, include_in_schema=include_in_schema, response_class=response_class, name=name, callbacks=callbacks, openapi_extra=openapi_extra, generate_unique_id_function=generate_unique_id_function)"
        },
        {
          "name": "is_sequence_field",
          "body": "def is_sequence_field(field: ModelField) -> bool:\n    return field_annotation_is_sequence(field.field_info.annotation)"
        }
      ]
    },
    {
      "name": "request_params_to_args",
      "module": "utils",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\dependencies\\utils.py",
      "line_number": 740,
      "end_line_number": 808,
      "source_code": "def request_params_to_args(\n    fields: Sequence[ModelField],\n    received_params: Union[Mapping[str, Any], QueryParams, Headers],\n) -> Tuple[Dict[str, Any], List[Any]]:\n    values: Dict[str, Any] = {}\n    errors: List[Dict[str, Any]] = []\n\n    if not fields:\n        return values, errors\n\n    first_field = fields[0]\n    fields_to_extract = fields\n    single_not_embedded_field = False\n    if len(fields) == 1 and lenient_issubclass(first_field.type_, BaseModel):\n        fields_to_extract = get_cached_model_fields(first_field.type_)\n        single_not_embedded_field = True\n\n    params_to_process: Dict[str, Any] = {}\n\n    processed_keys = set()\n\n    for field in fields_to_extract:\n        alias = None\n        if isinstance(received_params, Headers):\n            # Handle fields extracted from a Pydantic Model for a header, each field\n            # doesn't have a FieldInfo of type Header with the default convert_underscores=True\n            convert_underscores = getattr(field.field_info, \"convert_underscores\", True)\n            if convert_underscores:\n                alias = (\n                    field.alias\n                    if field.alias != field.name\n                    else field.name.replace(\"_\", \"-\")\n                )\n        value = _get_multidict_value(field, received_params, alias=alias)\n        if value is not None:\n            params_to_process[field.name] = value\n        processed_keys.add(alias or field.alias)\n        processed_keys.add(field.name)\n\n    for key, value in received_params.items():\n        if key not in processed_keys:\n            params_to_process[key] = value\n\n    if single_not_embedded_field:\n        field_info = first_field.field_info\n        assert isinstance(\n            field_info, params.Param\n        ), \"Params must be subclasses of Param\"\n        loc: Tuple[str, ...] = (field_info.in_.value,)\n        v_, errors_ = _validate_value_with_model_field(\n            field=first_field, value=params_to_process, values=values, loc=loc\n        )\n        return {first_field.name: v_}, errors_\n\n    for field in fields:\n        value = _get_multidict_value(field, received_params)\n        field_info = field.field_info\n        assert isinstance(\n            field_info, params.Param\n        ), \"Params must be subclasses of Param\"\n        loc = (field_info.in_.value, field.alias)\n        v_, errors_ = _validate_value_with_model_field(\n            field=field, value=value, values=values, loc=loc\n        )\n        if errors_:\n            errors.extend(errors_)\n        else:\n            values[field.name] = v_\n    return values, errors",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "fields",
        "received_params"
      ],
      "imports": [
        "inspect",
        "contextlib.AsyncExitStack",
        "contextlib.contextmanager",
        "copy.copy",
        "copy.deepcopy",
        "dataclasses.dataclass",
        "typing.Any",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.ForwardRef",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "typing.cast",
        "anyio",
        "fastapi.params",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.ErrorWrapper",
        "fastapi._compat.ModelField",
        "fastapi._compat.RequiredParam",
        "fastapi._compat.Undefined",
        "fastapi._compat._regenerate_error_with_loc",
        "fastapi._compat.copy_field_info",
        "fastapi._compat.create_body_model",
        "fastapi._compat.evaluate_forwardref",
        "fastapi._compat.field_annotation_is_scalar",
        "fastapi._compat.get_annotation_from_field_info",
        "fastapi._compat.get_cached_model_fields",
        "fastapi._compat.get_missing_field_error",
        "fastapi._compat.is_bytes_field",
        "fastapi._compat.is_bytes_sequence_field",
        "fastapi._compat.is_scalar_field",
        "fastapi._compat.is_scalar_sequence_field",
        "fastapi._compat.is_sequence_field",
        "fastapi._compat.is_uploadfile_or_nonable_uploadfile_annotation",
        "fastapi._compat.is_uploadfile_sequence_annotation",
        "fastapi._compat.lenient_issubclass",
        "fastapi._compat.sequence_types",
        "fastapi._compat.serialize_sequence_value",
        "fastapi._compat.value_is_sequence",
        "fastapi.background.BackgroundTasks",
        "fastapi.concurrency.asynccontextmanager",
        "fastapi.concurrency.contextmanager_in_threadpool",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.models.SecurityRequirement",
        "fastapi.logger.logger",
        "fastapi.security.base.SecurityBase",
        "fastapi.security.oauth2.OAuth2",
        "fastapi.security.oauth2.SecurityScopes",
        "fastapi.security.open_id_connect_url.OpenIdConnect",
        "fastapi.utils.create_model_field",
        "fastapi.utils.get_path_param_names",
        "pydantic.BaseModel",
        "pydantic.fields.FieldInfo",
        "starlette.background.BackgroundTasks",
        "starlette.concurrency.run_in_threadpool",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.ImmutableMultiDict",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.UploadFile",
        "starlette.requests.HTTPConnection",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "python_multipart.__version__",
        "multipart.__version__",
        "multipart.multipart.parse_options_header"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(field_info, params.Param), 'Params must be subclasses of Param'",
        "assert isinstance(field_info, params.Param), 'Params must be subclasses of Param'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_cached_model_fields",
          "body": "@lru_cache\ndef get_cached_model_fields(model: Type[BaseModel]) -> List[ModelField]:\n    return get_model_fields(model)"
        },
        {
          "name": "_get_multidict_value",
          "body": "def _get_multidict_value(field: ModelField, values: Mapping[str, Any], alias: Union[str, None]=None) -> Any:\n    alias = alias or field.alias\n    if is_sequence_field(field) and isinstance(values, (ImmutableMultiDict, Headers)):\n        value = values.getlist(alias)\n    else:\n        value = values.get(alias, None)\n    if value is None or (isinstance(field.field_info, params.Form) and isinstance(value, str) and (value == '')) or (is_sequence_field(field) and len(value) == 0):\n        if field.required:\n            return\n        else:\n            return deepcopy(field.default)\n    return value"
        },
        {
          "name": "_validate_value_with_model_field",
          "body": "def _validate_value_with_model_field(*, field: ModelField, value: Any, values: Dict[str, Any], loc: Tuple[str, ...]) -> Tuple[Any, List[Any]]:\n    if value is None:\n        if field.required:\n            return (None, [get_missing_field_error(loc=loc)])\n        else:\n            return (deepcopy(field.default), [])\n    v_, errors_ = field.validate(value, values, loc=loc)\n    if isinstance(errors_, ErrorWrapper):\n        return (None, [errors_])\n    elif isinstance(errors_, list):\n        new_errors = _regenerate_error_with_loc(errors=errors_, loc_prefix=())\n        return (None, new_errors)\n    else:\n        return (v_, [])"
        },
        {
          "name": "_get_multidict_value",
          "body": "def _get_multidict_value(field: ModelField, values: Mapping[str, Any], alias: Union[str, None]=None) -> Any:\n    alias = alias or field.alias\n    if is_sequence_field(field) and isinstance(values, (ImmutableMultiDict, Headers)):\n        value = values.getlist(alias)\n    else:\n        value = values.get(alias, None)\n    if value is None or (isinstance(field.field_info, params.Form) and isinstance(value, str) and (value == '')) or (is_sequence_field(field) and len(value) == 0):\n        if field.required:\n            return\n        else:\n            return deepcopy(field.default)\n    return value"
        },
        {
          "name": "_validate_value_with_model_field",
          "body": "def _validate_value_with_model_field(*, field: ModelField, value: Any, values: Dict[str, Any], loc: Tuple[str, ...]) -> Tuple[Any, List[Any]]:\n    if value is None:\n        if field.required:\n            return (None, [get_missing_field_error(loc=loc)])\n        else:\n            return (deepcopy(field.default), [])\n    v_, errors_ = field.validate(value, values, loc=loc)\n    if isinstance(errors_, ErrorWrapper):\n        return (None, [errors_])\n    elif isinstance(errors_, list):\n        new_errors = _regenerate_error_with_loc(errors=errors_, loc_prefix=())\n        return (None, new_errors)\n    else:\n        return (v_, [])"
        }
      ]
    },
    {
      "name": "_should_embed_body_fields",
      "module": "utils",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\dependencies\\utils.py",
      "line_number": 811,
      "end_line_number": 830,
      "source_code": "def _should_embed_body_fields(fields: List[ModelField]) -> bool:\n    if not fields:\n        return False\n    # More than one dependency could have the same field, it would show up as multiple\n    # fields but it's the same one, so count them by name\n    body_param_names_set = {field.name for field in fields}\n    # A top level field has to be a single field, not multiple\n    if len(body_param_names_set) > 1:\n        return True\n    first_field = fields[0]\n    # If it explicitly specifies it is embedded, it has to be embedded\n    if getattr(first_field.field_info, \"embed\", None):\n        return True\n    # If it's a Form (or File) field, it has to be a BaseModel to be top level\n    # otherwise it has to be embedded, so that the key value pair can be extracted\n    if isinstance(first_field.field_info, params.Form) and not lenient_issubclass(\n        first_field.type_, BaseModel\n    ):\n        return True\n    return False",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "fields"
      ],
      "imports": [
        "inspect",
        "contextlib.AsyncExitStack",
        "contextlib.contextmanager",
        "copy.copy",
        "copy.deepcopy",
        "dataclasses.dataclass",
        "typing.Any",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.ForwardRef",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "typing.cast",
        "anyio",
        "fastapi.params",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.ErrorWrapper",
        "fastapi._compat.ModelField",
        "fastapi._compat.RequiredParam",
        "fastapi._compat.Undefined",
        "fastapi._compat._regenerate_error_with_loc",
        "fastapi._compat.copy_field_info",
        "fastapi._compat.create_body_model",
        "fastapi._compat.evaluate_forwardref",
        "fastapi._compat.field_annotation_is_scalar",
        "fastapi._compat.get_annotation_from_field_info",
        "fastapi._compat.get_cached_model_fields",
        "fastapi._compat.get_missing_field_error",
        "fastapi._compat.is_bytes_field",
        "fastapi._compat.is_bytes_sequence_field",
        "fastapi._compat.is_scalar_field",
        "fastapi._compat.is_scalar_sequence_field",
        "fastapi._compat.is_sequence_field",
        "fastapi._compat.is_uploadfile_or_nonable_uploadfile_annotation",
        "fastapi._compat.is_uploadfile_sequence_annotation",
        "fastapi._compat.lenient_issubclass",
        "fastapi._compat.sequence_types",
        "fastapi._compat.serialize_sequence_value",
        "fastapi._compat.value_is_sequence",
        "fastapi.background.BackgroundTasks",
        "fastapi.concurrency.asynccontextmanager",
        "fastapi.concurrency.contextmanager_in_threadpool",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.models.SecurityRequirement",
        "fastapi.logger.logger",
        "fastapi.security.base.SecurityBase",
        "fastapi.security.oauth2.OAuth2",
        "fastapi.security.oauth2.SecurityScopes",
        "fastapi.security.open_id_connect_url.OpenIdConnect",
        "fastapi.utils.create_model_field",
        "fastapi.utils.get_path_param_names",
        "pydantic.BaseModel",
        "pydantic.fields.FieldInfo",
        "starlette.background.BackgroundTasks",
        "starlette.concurrency.run_in_threadpool",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.ImmutableMultiDict",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.UploadFile",
        "starlette.requests.HTTPConnection",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "python_multipart.__version__",
        "multipart.__version__",
        "multipart.multipart.parse_options_header"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "get_body_field",
      "module": "utils",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\dependencies\\utils.py",
      "line_number": 922,
      "end_line_number": 972,
      "source_code": "def get_body_field(\n    *, flat_dependant: Dependant, name: str, embed_body_fields: bool\n) -> Optional[ModelField]:\n    \"\"\"\n    Get a ModelField representing the request body for a path operation, combining\n    all body parameters into a single field if necessary.\n\n    Used to check if it's form data (with `isinstance(body_field, params.Form)`)\n    or JSON and to generate the JSON Schema for a request body.\n\n    This is **not** used to validate/parse the request body, that's done with each\n    individual body parameter.\n    \"\"\"\n    if not flat_dependant.body_params:\n        return None\n    first_param = flat_dependant.body_params[0]\n    if not embed_body_fields:\n        return first_param\n    model_name = \"Body_\" + name\n    BodyModel = create_body_model(\n        fields=flat_dependant.body_params, model_name=model_name\n    )\n    required = any(True for f in flat_dependant.body_params if f.required)\n    BodyFieldInfo_kwargs: Dict[str, Any] = {\n        \"annotation\": BodyModel,\n        \"alias\": \"body\",\n    }\n    if not required:\n        BodyFieldInfo_kwargs[\"default\"] = None\n    if any(isinstance(f.field_info, params.File) for f in flat_dependant.body_params):\n        BodyFieldInfo: Type[params.Body] = params.File\n    elif any(isinstance(f.field_info, params.Form) for f in flat_dependant.body_params):\n        BodyFieldInfo = params.Form\n    else:\n        BodyFieldInfo = params.Body\n\n        body_param_media_types = [\n            f.field_info.media_type\n            for f in flat_dependant.body_params\n            if isinstance(f.field_info, params.Body)\n        ]\n        if len(set(body_param_media_types)) == 1:\n            BodyFieldInfo_kwargs[\"media_type\"] = body_param_media_types[0]\n    final_field = create_model_field(\n        name=\"body\",\n        type_=BodyModel,\n        required=required,\n        alias=\"body\",\n        field_info=BodyFieldInfo(**BodyFieldInfo_kwargs),\n    )\n    return final_field",
      "docstring": "Get a ModelField representing the request body for a path operation, combining\nall body parameters into a single field if necessary.\n\nUsed to check if it's form data (with `isinstance(body_field, params.Form)`)\nor JSON and to generate the JSON Schema for a request body.\n\nThis is **not** used to validate/parse the request body, that's done with each\nindividual body parameter.",
      "decorators": [],
      "arguments": [],
      "imports": [
        "inspect",
        "contextlib.AsyncExitStack",
        "contextlib.contextmanager",
        "copy.copy",
        "copy.deepcopy",
        "dataclasses.dataclass",
        "typing.Any",
        "typing.Callable",
        "typing.Coroutine",
        "typing.Dict",
        "typing.ForwardRef",
        "typing.List",
        "typing.Mapping",
        "typing.Optional",
        "typing.Sequence",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "typing.cast",
        "anyio",
        "fastapi.params",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.ErrorWrapper",
        "fastapi._compat.ModelField",
        "fastapi._compat.RequiredParam",
        "fastapi._compat.Undefined",
        "fastapi._compat._regenerate_error_with_loc",
        "fastapi._compat.copy_field_info",
        "fastapi._compat.create_body_model",
        "fastapi._compat.evaluate_forwardref",
        "fastapi._compat.field_annotation_is_scalar",
        "fastapi._compat.get_annotation_from_field_info",
        "fastapi._compat.get_cached_model_fields",
        "fastapi._compat.get_missing_field_error",
        "fastapi._compat.is_bytes_field",
        "fastapi._compat.is_bytes_sequence_field",
        "fastapi._compat.is_scalar_field",
        "fastapi._compat.is_scalar_sequence_field",
        "fastapi._compat.is_sequence_field",
        "fastapi._compat.is_uploadfile_or_nonable_uploadfile_annotation",
        "fastapi._compat.is_uploadfile_sequence_annotation",
        "fastapi._compat.lenient_issubclass",
        "fastapi._compat.sequence_types",
        "fastapi._compat.serialize_sequence_value",
        "fastapi._compat.value_is_sequence",
        "fastapi.background.BackgroundTasks",
        "fastapi.concurrency.asynccontextmanager",
        "fastapi.concurrency.contextmanager_in_threadpool",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.models.SecurityRequirement",
        "fastapi.logger.logger",
        "fastapi.security.base.SecurityBase",
        "fastapi.security.oauth2.OAuth2",
        "fastapi.security.oauth2.SecurityScopes",
        "fastapi.security.open_id_connect_url.OpenIdConnect",
        "fastapi.utils.create_model_field",
        "fastapi.utils.get_path_param_names",
        "pydantic.BaseModel",
        "pydantic.fields.FieldInfo",
        "starlette.background.BackgroundTasks",
        "starlette.concurrency.run_in_threadpool",
        "starlette.datastructures.FormData",
        "starlette.datastructures.Headers",
        "starlette.datastructures.ImmutableMultiDict",
        "starlette.datastructures.QueryParams",
        "starlette.datastructures.UploadFile",
        "starlette.requests.HTTPConnection",
        "starlette.requests.Request",
        "starlette.responses.Response",
        "starlette.websockets.WebSocket",
        "typing_extensions.Annotated",
        "typing_extensions.get_args",
        "typing_extensions.get_origin",
        "python_multipart.__version__",
        "multipart.__version__",
        "multipart.multipart.parse_options_header"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "create_body_model",
          "body": "def create_body_model(*, fields: Sequence[ModelField], model_name: str) -> Type[BaseModel]:\n    field_params = {f.name: (f.field_info.annotation, f.field_info) for f in fields}\n    BodyModel: Type[BaseModel] = create_model(model_name, **field_params)\n    return BodyModel"
        },
        {
          "name": "create_model_field",
          "body": "def create_model_field(name: str, type_: Any, class_validators: Optional[Dict[str, Validator]]=None, default: Optional[Any]=Undefined, required: Union[bool, UndefinedType]=Undefined, model_config: Type[BaseConfig]=BaseConfig, field_info: Optional[FieldInfo]=None, alias: Optional[str]=None, mode: Literal['validation', 'serialization']='validation') -> ModelField:\n    class_validators = class_validators or {}\n    if PYDANTIC_V2:\n        field_info = field_info or FieldInfo(annotation=type_, default=default, alias=alias)\n    else:\n        field_info = field_info or FieldInfo()\n    kwargs = {'name': name, 'field_info': field_info}\n    if PYDANTIC_V2:\n        kwargs.update({'mode': mode})\n    else:\n        kwargs.update({'type_': type_, 'class_validators': class_validators, 'default': default, 'required': required, 'model_config': model_config, 'alias': alias})\n    try:\n        return ModelField(**kwargs)\n    except (RuntimeError, PydanticSchemaGenerationError):\n        raise fastapi.exceptions.FastAPIError(f'Invalid args for response field! Hint: check that {type_} is a valid Pydantic field type. If you are using a return type annotation that is not a valid Pydantic field (e.g. Union[Response, dict, None]) you can disable generating the response model from the type annotation with the path operation decorator parameter response_model=None. Read more: https://fastapi.tiangolo.com/tutorial/response-model/') from None"
        }
      ]
    },
    {
      "name": "get_swagger_ui_html",
      "module": "docs",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\openapi\\docs.py",
      "line_number": 26,
      "end_line_number": 158,
      "source_code": "def get_swagger_ui_html(\n    *,\n    openapi_url: Annotated[\n        str,\n        Doc(\n            \"\"\"\n            The OpenAPI URL that Swagger UI should load and use.\n\n            This is normally done automatically by FastAPI using the default URL\n            `/openapi.json`.\n            \"\"\"\n        ),\n    ],\n    title: Annotated[\n        str,\n        Doc(\n            \"\"\"\n            The HTML `<title>` content, normally shown in the browser tab.\n            \"\"\"\n        ),\n    ],\n    swagger_js_url: Annotated[\n        str,\n        Doc(\n            \"\"\"\n            The URL to use to load the Swagger UI JavaScript.\n\n            It is normally set to a CDN URL.\n            \"\"\"\n        ),\n    ] = \"https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui-bundle.js\",\n    swagger_css_url: Annotated[\n        str,\n        Doc(\n            \"\"\"\n            The URL to use to load the Swagger UI CSS.\n\n            It is normally set to a CDN URL.\n            \"\"\"\n        ),\n    ] = \"https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui.css\",\n    swagger_favicon_url: Annotated[\n        str,\n        Doc(\n            \"\"\"\n            The URL of the favicon to use. It is normally shown in the browser tab.\n            \"\"\"\n        ),\n    ] = \"https://fastapi.tiangolo.com/img/favicon.png\",\n    oauth2_redirect_url: Annotated[\n        Optional[str],\n        Doc(\n            \"\"\"\n            The OAuth2 redirect URL, it is normally automatically handled by FastAPI.\n            \"\"\"\n        ),\n    ] = None,\n    init_oauth: Annotated[\n        Optional[Dict[str, Any]],\n        Doc(\n            \"\"\"\n            A dictionary with Swagger UI OAuth2 initialization configurations.\n            \"\"\"\n        ),\n    ] = None,\n    swagger_ui_parameters: Annotated[\n        Optional[Dict[str, Any]],\n        Doc(\n            \"\"\"\n            Configuration parameters for Swagger UI.\n\n            It defaults to [swagger_ui_default_parameters][fastapi.openapi.docs.swagger_ui_default_parameters].\n            \"\"\"\n        ),\n    ] = None,\n) -> HTMLResponse:\n    \"\"\"\n    Generate and return the HTML  that loads Swagger UI for the interactive\n    API docs (normally served at `/docs`).\n\n    You would only call this function yourself if you needed to override some parts,\n    for example the URLs to use to load Swagger UI's JavaScript and CSS.\n\n    Read more about it in the\n    [FastAPI docs for Configure Swagger UI](https://fastapi.tiangolo.com/how-to/configure-swagger-ui/)\n    and the [FastAPI docs for Custom Docs UI Static Assets (Self-Hosting)](https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/).\n    \"\"\"\n    current_swagger_ui_parameters = swagger_ui_default_parameters.copy()\n    if swagger_ui_parameters:\n        current_swagger_ui_parameters.update(swagger_ui_parameters)\n\n    html = f\"\"\"\n    <!DOCTYPE html>\n    <html>\n    <head>\n    <link type=\"text/css\" rel=\"stylesheet\" href=\"{swagger_css_url}\">\n    <link rel=\"shortcut icon\" href=\"{swagger_favicon_url}\">\n    <title>{title}</title>\n    </head>\n    <body>\n    <div id=\"swagger-ui\">\n    </div>\n    <script src=\"{swagger_js_url}\"></script>\n    <!-- `SwaggerUIBundle` is now available on the page -->\n    <script>\n    const ui = SwaggerUIBundle({{\n        url: '{openapi_url}',\n    \"\"\"\n\n    for key, value in current_swagger_ui_parameters.items():\n        html += f\"{json.dumps(key)}: {json.dumps(jsonable_encoder(value))},\\n\"\n\n    if oauth2_redirect_url:\n        html += f\"oauth2RedirectUrl: window.location.origin + '{oauth2_redirect_url}',\"\n\n    html += \"\"\"\n    presets: [\n        SwaggerUIBundle.presets.apis,\n        SwaggerUIBundle.SwaggerUIStandalonePreset\n        ],\n    })\"\"\"\n\n    if init_oauth:\n        html += f\"\"\"\n        ui.initOAuth({json.dumps(jsonable_encoder(init_oauth))})\n        \"\"\"\n\n    html += \"\"\"\n    </script>\n    </body>\n    </html>\n    \"\"\"\n    return HTMLResponse(html)",
      "docstring": "Generate and return the HTML  that loads Swagger UI for the interactive\nAPI docs (normally served at `/docs`).\n\nYou would only call this function yourself if you needed to override some parts,\nfor example the URLs to use to load Swagger UI's JavaScript and CSS.\n\nRead more about it in the\n[FastAPI docs for Configure Swagger UI](https://fastapi.tiangolo.com/how-to/configure-swagger-ui/)\nand the [FastAPI docs for Custom Docs UI Static Assets (Self-Hosting)](https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/).",
      "decorators": [],
      "arguments": [],
      "imports": [
        "json",
        "typing.Any",
        "typing.Dict",
        "typing.Optional",
        "fastapi.encoders.jsonable_encoder",
        "starlette.responses.HTMLResponse",
        "typing_extensions.Annotated",
        "typing_extensions.Doc"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "jsonable_encoder",
          "body": "def jsonable_encoder(obj: Annotated[Any, Doc('\\n            The input object to convert to JSON.\\n            ')], include: Annotated[Optional[IncEx], Doc(\"\\n            Pydantic's `include` parameter, passed to Pydantic models to set the\\n            fields to include.\\n            \")]=None, exclude: Annotated[Optional[IncEx], Doc(\"\\n            Pydantic's `exclude` parameter, passed to Pydantic models to set the\\n            fields to exclude.\\n            \")]=None, by_alias: Annotated[bool, Doc(\"\\n            Pydantic's `by_alias` parameter, passed to Pydantic models to define if\\n            the output should use the alias names (when provided) or the Python\\n            attribute names. In an API, if you set an alias, it's probably because you\\n            want to use it in the result, so you probably want to leave this set to\\n            `True`.\\n            \")]=True, exclude_unset: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_unset` parameter, passed to Pydantic models to define\\n            if it should exclude from the output the fields that were not explicitly\\n            set (and that only had their default values).\\n            \")]=False, exclude_defaults: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_defaults` parameter, passed to Pydantic models to define\\n            if it should exclude from the output the fields that had the same default\\n            value, even when they were explicitly set.\\n            \")]=False, exclude_none: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_none` parameter, passed to Pydantic models to define\\n            if it should exclude from the output any fields that have a `None` value.\\n            \")]=False, custom_encoder: Annotated[Optional[Dict[Any, Callable[[Any], Any]]], Doc(\"\\n            Pydantic's `custom_encoder` parameter, passed to Pydantic models to define\\n            a custom encoder.\\n            \")]=None, sqlalchemy_safe: Annotated[bool, Doc(\"\\n            Exclude from the output any fields that start with the name `_sa`.\\n\\n            This is mainly a hack for compatibility with SQLAlchemy objects, they\\n            store internal SQLAlchemy-specific state in attributes named with `_sa`,\\n            and those objects can't (and shouldn't be) serialized to JSON.\\n            \")]=True) -> Any:\n    \"\"\"\n    Convert any object to something that can be encoded in JSON.\n\n    This is used internally by FastAPI to make sure anything you return can be\n    encoded as JSON before it is sent to the client.\n\n    You can also use it yourself, for example to convert objects before saving them\n    in a database that supports only JSON.\n\n    Read more about it in the\n    [FastAPI docs for JSON Compatible Encoder](https://fastapi.tiangolo.com/tutorial/encoder/).\n    \"\"\"\n    custom_encoder = custom_encoder or {}\n    if custom_encoder:\n        if type(obj) in custom_encoder:\n            return custom_encoder[type(obj)](obj)\n        else:\n            for encoder_type, encoder_instance in custom_encoder.items():\n                if isinstance(obj, encoder_type):\n                    return encoder_instance(obj)\n    if include is not None and (not isinstance(include, (set, dict))):\n        include = set(include)\n    if exclude is not None and (not isinstance(exclude, (set, dict))):\n        exclude = set(exclude)\n    if isinstance(obj, BaseModel):\n        encoders: Dict[Any, Any] = {}\n        if not PYDANTIC_V2:\n            encoders = getattr(obj.__config__, 'json_encoders', {})\n            if custom_encoder:\n                encoders.update(custom_encoder)\n        obj_dict = _model_dump(obj, mode='json', include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, exclude_defaults=exclude_defaults)\n        if '__root__' in obj_dict:\n            obj_dict = obj_dict['__root__']\n        return jsonable_encoder(obj_dict, exclude_none=exclude_none, exclude_defaults=exclude_defaults, custom_encoder=encoders, sqlalchemy_safe=sqlalchemy_safe)\n    if dataclasses.is_dataclass(obj):\n        obj_dict = dataclasses.asdict(obj)\n        return jsonable_encoder(obj_dict, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n    if isinstance(obj, Enum):\n        return obj.value\n    if isinstance(obj, PurePath):\n        return str(obj)\n    if isinstance(obj, (str, int, float, type(None))):\n        return obj\n    if isinstance(obj, UndefinedType):\n        return None\n    if isinstance(obj, dict):\n        encoded_dict = {}\n        allowed_keys = set(obj.keys())\n        if include is not None:\n            allowed_keys &= set(include)\n        if exclude is not None:\n            allowed_keys -= set(exclude)\n        for key, value in obj.items():\n            if (not sqlalchemy_safe or not isinstance(key, str) or (not key.startswith('_sa'))) and (value is not None or not exclude_none) and (key in allowed_keys):\n                encoded_key = jsonable_encoder(key, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n                encoded_value = jsonable_encoder(value, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n                encoded_dict[encoded_key] = encoded_value\n        return encoded_dict\n    if isinstance(obj, (list, set, frozenset, GeneratorType, tuple, deque)):\n        encoded_list = []\n        for item in obj:\n            encoded_list.append(jsonable_encoder(item, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe))\n        return encoded_list\n    if type(obj) in ENCODERS_BY_TYPE:\n        return ENCODERS_BY_TYPE[type(obj)](obj)\n    for encoder, classes_tuple in encoders_by_class_tuples.items():\n        if isinstance(obj, classes_tuple):\n            return encoder(obj)\n    try:\n        data = dict(obj)\n    except Exception as e:\n        errors: List[Exception] = []\n        errors.append(e)\n        try:\n            data = vars(obj)\n        except Exception as e:\n            errors.append(e)\n            raise ValueError(errors) from e\n    return jsonable_encoder(data, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)"
        },
        {
          "name": "jsonable_encoder",
          "body": "def jsonable_encoder(obj: Annotated[Any, Doc('\\n            The input object to convert to JSON.\\n            ')], include: Annotated[Optional[IncEx], Doc(\"\\n            Pydantic's `include` parameter, passed to Pydantic models to set the\\n            fields to include.\\n            \")]=None, exclude: Annotated[Optional[IncEx], Doc(\"\\n            Pydantic's `exclude` parameter, passed to Pydantic models to set the\\n            fields to exclude.\\n            \")]=None, by_alias: Annotated[bool, Doc(\"\\n            Pydantic's `by_alias` parameter, passed to Pydantic models to define if\\n            the output should use the alias names (when provided) or the Python\\n            attribute names. In an API, if you set an alias, it's probably because you\\n            want to use it in the result, so you probably want to leave this set to\\n            `True`.\\n            \")]=True, exclude_unset: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_unset` parameter, passed to Pydantic models to define\\n            if it should exclude from the output the fields that were not explicitly\\n            set (and that only had their default values).\\n            \")]=False, exclude_defaults: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_defaults` parameter, passed to Pydantic models to define\\n            if it should exclude from the output the fields that had the same default\\n            value, even when they were explicitly set.\\n            \")]=False, exclude_none: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_none` parameter, passed to Pydantic models to define\\n            if it should exclude from the output any fields that have a `None` value.\\n            \")]=False, custom_encoder: Annotated[Optional[Dict[Any, Callable[[Any], Any]]], Doc(\"\\n            Pydantic's `custom_encoder` parameter, passed to Pydantic models to define\\n            a custom encoder.\\n            \")]=None, sqlalchemy_safe: Annotated[bool, Doc(\"\\n            Exclude from the output any fields that start with the name `_sa`.\\n\\n            This is mainly a hack for compatibility with SQLAlchemy objects, they\\n            store internal SQLAlchemy-specific state in attributes named with `_sa`,\\n            and those objects can't (and shouldn't be) serialized to JSON.\\n            \")]=True) -> Any:\n    \"\"\"\n    Convert any object to something that can be encoded in JSON.\n\n    This is used internally by FastAPI to make sure anything you return can be\n    encoded as JSON before it is sent to the client.\n\n    You can also use it yourself, for example to convert objects before saving them\n    in a database that supports only JSON.\n\n    Read more about it in the\n    [FastAPI docs for JSON Compatible Encoder](https://fastapi.tiangolo.com/tutorial/encoder/).\n    \"\"\"\n    custom_encoder = custom_encoder or {}\n    if custom_encoder:\n        if type(obj) in custom_encoder:\n            return custom_encoder[type(obj)](obj)\n        else:\n            for encoder_type, encoder_instance in custom_encoder.items():\n                if isinstance(obj, encoder_type):\n                    return encoder_instance(obj)\n    if include is not None and (not isinstance(include, (set, dict))):\n        include = set(include)\n    if exclude is not None and (not isinstance(exclude, (set, dict))):\n        exclude = set(exclude)\n    if isinstance(obj, BaseModel):\n        encoders: Dict[Any, Any] = {}\n        if not PYDANTIC_V2:\n            encoders = getattr(obj.__config__, 'json_encoders', {})\n            if custom_encoder:\n                encoders.update(custom_encoder)\n        obj_dict = _model_dump(obj, mode='json', include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, exclude_defaults=exclude_defaults)\n        if '__root__' in obj_dict:\n            obj_dict = obj_dict['__root__']\n        return jsonable_encoder(obj_dict, exclude_none=exclude_none, exclude_defaults=exclude_defaults, custom_encoder=encoders, sqlalchemy_safe=sqlalchemy_safe)\n    if dataclasses.is_dataclass(obj):\n        obj_dict = dataclasses.asdict(obj)\n        return jsonable_encoder(obj_dict, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n    if isinstance(obj, Enum):\n        return obj.value\n    if isinstance(obj, PurePath):\n        return str(obj)\n    if isinstance(obj, (str, int, float, type(None))):\n        return obj\n    if isinstance(obj, UndefinedType):\n        return None\n    if isinstance(obj, dict):\n        encoded_dict = {}\n        allowed_keys = set(obj.keys())\n        if include is not None:\n            allowed_keys &= set(include)\n        if exclude is not None:\n            allowed_keys -= set(exclude)\n        for key, value in obj.items():\n            if (not sqlalchemy_safe or not isinstance(key, str) or (not key.startswith('_sa'))) and (value is not None or not exclude_none) and (key in allowed_keys):\n                encoded_key = jsonable_encoder(key, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n                encoded_value = jsonable_encoder(value, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n                encoded_dict[encoded_key] = encoded_value\n        return encoded_dict\n    if isinstance(obj, (list, set, frozenset, GeneratorType, tuple, deque)):\n        encoded_list = []\n        for item in obj:\n            encoded_list.append(jsonable_encoder(item, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe))\n        return encoded_list\n    if type(obj) in ENCODERS_BY_TYPE:\n        return ENCODERS_BY_TYPE[type(obj)](obj)\n    for encoder, classes_tuple in encoders_by_class_tuples.items():\n        if isinstance(obj, classes_tuple):\n            return encoder(obj)\n    try:\n        data = dict(obj)\n    except Exception as e:\n        errors: List[Exception] = []\n        errors.append(e)\n        try:\n            data = vars(obj)\n        except Exception as e:\n            errors.append(e)\n            raise ValueError(errors) from e\n    return jsonable_encoder(data, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)"
        }
      ]
    },
    {
      "name": "get_redoc_html",
      "module": "docs",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\openapi\\docs.py",
      "line_number": 161,
      "end_line_number": 253,
      "source_code": "def get_redoc_html(\n    *,\n    openapi_url: Annotated[\n        str,\n        Doc(\n            \"\"\"\n            The OpenAPI URL that ReDoc should load and use.\n\n            This is normally done automatically by FastAPI using the default URL\n            `/openapi.json`.\n            \"\"\"\n        ),\n    ],\n    title: Annotated[\n        str,\n        Doc(\n            \"\"\"\n            The HTML `<title>` content, normally shown in the browser tab.\n            \"\"\"\n        ),\n    ],\n    redoc_js_url: Annotated[\n        str,\n        Doc(\n            \"\"\"\n            The URL to use to load the ReDoc JavaScript.\n\n            It is normally set to a CDN URL.\n            \"\"\"\n        ),\n    ] = \"https://cdn.jsdelivr.net/npm/redoc@next/bundles/redoc.standalone.js\",\n    redoc_favicon_url: Annotated[\n        str,\n        Doc(\n            \"\"\"\n            The URL of the favicon to use. It is normally shown in the browser tab.\n            \"\"\"\n        ),\n    ] = \"https://fastapi.tiangolo.com/img/favicon.png\",\n    with_google_fonts: Annotated[\n        bool,\n        Doc(\n            \"\"\"\n            Load and use Google Fonts.\n            \"\"\"\n        ),\n    ] = True,\n) -> HTMLResponse:\n    \"\"\"\n    Generate and return the HTML response that loads ReDoc for the alternative\n    API docs (normally served at `/redoc`).\n\n    You would only call this function yourself if you needed to override some parts,\n    for example the URLs to use to load ReDoc's JavaScript and CSS.\n\n    Read more about it in the\n    [FastAPI docs for Custom Docs UI Static Assets (Self-Hosting)](https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/).\n    \"\"\"\n    html = f\"\"\"\n    <!DOCTYPE html>\n    <html>\n    <head>\n    <title>{title}</title>\n    <!-- needed for adaptive design -->\n    <meta charset=\"utf-8\"/>\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    \"\"\"\n    if with_google_fonts:\n        html += \"\"\"\n    <link href=\"https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:300,400,700\" rel=\"stylesheet\">\n    \"\"\"\n    html += f\"\"\"\n    <link rel=\"shortcut icon\" href=\"{redoc_favicon_url}\">\n    <!--\n    ReDoc doesn't change outer page styles\n    -->\n    <style>\n      body {{\n        margin: 0;\n        padding: 0;\n      }}\n    </style>\n    </head>\n    <body>\n    <noscript>\n        ReDoc requires Javascript to function. Please enable it to browse the documentation.\n    </noscript>\n    <redoc spec-url=\"{openapi_url}\"></redoc>\n    <script src=\"{redoc_js_url}\"> </script>\n    </body>\n    </html>\n    \"\"\"\n    return HTMLResponse(html)",
      "docstring": "Generate and return the HTML response that loads ReDoc for the alternative\nAPI docs (normally served at `/redoc`).\n\nYou would only call this function yourself if you needed to override some parts,\nfor example the URLs to use to load ReDoc's JavaScript and CSS.\n\nRead more about it in the\n[FastAPI docs for Custom Docs UI Static Assets (Self-Hosting)](https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/).",
      "decorators": [],
      "arguments": [],
      "imports": [
        "json",
        "typing.Any",
        "typing.Dict",
        "typing.Optional",
        "fastapi.encoders.jsonable_encoder",
        "starlette.responses.HTMLResponse",
        "typing_extensions.Annotated",
        "typing_extensions.Doc"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "get_swagger_ui_oauth2_redirect_html",
      "module": "docs",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\openapi\\docs.py",
      "line_number": 256,
      "end_line_number": 344,
      "source_code": "def get_swagger_ui_oauth2_redirect_html() -> HTMLResponse:\n    \"\"\"\n    Generate the HTML response with the OAuth2 redirection for Swagger UI.\n\n    You normally don't need to use or change this.\n    \"\"\"\n    # copied from https://github.com/swagger-api/swagger-ui/blob/v4.14.0/dist/oauth2-redirect.html\n    html = \"\"\"\n    <!doctype html>\n    <html lang=\"en-US\">\n    <head>\n        <title>Swagger UI: OAuth2 Redirect</title>\n    </head>\n    <body>\n    <script>\n        'use strict';\n        function run () {\n            var oauth2 = window.opener.swaggerUIRedirectOauth2;\n            var sentState = oauth2.state;\n            var redirectUrl = oauth2.redirectUrl;\n            var isValid, qp, arr;\n\n            if (/code|token|error/.test(window.location.hash)) {\n                qp = window.location.hash.substring(1).replace('?', '&');\n            } else {\n                qp = location.search.substring(1);\n            }\n\n            arr = qp.split(\"&\");\n            arr.forEach(function (v,i,_arr) { _arr[i] = '\"' + v.replace('=', '\":\"') + '\"';});\n            qp = qp ? JSON.parse('{' + arr.join() + '}',\n                    function (key, value) {\n                        return key === \"\" ? value : decodeURIComponent(value);\n                    }\n            ) : {};\n\n            isValid = qp.state === sentState;\n\n            if ((\n              oauth2.auth.schema.get(\"flow\") === \"accessCode\" ||\n              oauth2.auth.schema.get(\"flow\") === \"authorizationCode\" ||\n              oauth2.auth.schema.get(\"flow\") === \"authorization_code\"\n            ) && !oauth2.auth.code) {\n                if (!isValid) {\n                    oauth2.errCb({\n                        authId: oauth2.auth.name,\n                        source: \"auth\",\n                        level: \"warning\",\n                        message: \"Authorization may be unsafe, passed state was changed in server. The passed state wasn't returned from auth server.\"\n                    });\n                }\n\n                if (qp.code) {\n                    delete oauth2.state;\n                    oauth2.auth.code = qp.code;\n                    oauth2.callback({auth: oauth2.auth, redirectUrl: redirectUrl});\n                } else {\n                    let oauthErrorMsg;\n                    if (qp.error) {\n                        oauthErrorMsg = \"[\"+qp.error+\"]: \" +\n                            (qp.error_description ? qp.error_description+ \". \" : \"no accessCode received from the server. \") +\n                            (qp.error_uri ? \"More info: \"+qp.error_uri : \"\");\n                    }\n\n                    oauth2.errCb({\n                        authId: oauth2.auth.name,\n                        source: \"auth\",\n                        level: \"error\",\n                        message: oauthErrorMsg || \"[Authorization failed]: no accessCode received from the server.\"\n                    });\n                }\n            } else {\n                oauth2.callback({auth: oauth2.auth, token: qp, isValid: isValid, redirectUrl: redirectUrl});\n            }\n            window.close();\n        }\n\n        if (document.readyState !== 'loading') {\n            run();\n        } else {\n            document.addEventListener('DOMContentLoaded', function () {\n                run();\n            });\n        }\n    </script>\n    </body>\n    </html>\n        \"\"\"\n    return HTMLResponse(content=html)",
      "docstring": "Generate the HTML response with the OAuth2 redirection for Swagger UI.\n\nYou normally don't need to use or change this.",
      "decorators": [],
      "arguments": [],
      "imports": [
        "json",
        "typing.Any",
        "typing.Dict",
        "typing.Optional",
        "fastapi.encoders.jsonable_encoder",
        "starlette.responses.HTMLResponse",
        "typing_extensions.Annotated",
        "typing_extensions.Doc"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__get_validators__",
      "module": "models",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\openapi\\models.py",
      "line_number": 26,
      "end_line_number": 27,
      "source_code": "def __get_validators__(cls) -> Iterable[Callable[..., Any]]:\n            yield cls.validate",
      "docstring": null,
      "decorators": [
        "classmethod"
      ],
      "arguments": [
        "cls"
      ],
      "imports": [
        "enum.Enum",
        "typing.Any",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Optional",
        "typing.Set",
        "typing.Type",
        "typing.Union",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.CoreSchema",
        "fastapi._compat.GetJsonSchemaHandler",
        "fastapi._compat.JsonSchemaValue",
        "fastapi._compat._model_rebuild",
        "fastapi._compat.with_info_plain_validator_function",
        "fastapi.logger.logger",
        "pydantic.AnyUrl",
        "pydantic.BaseModel",
        "pydantic.Field",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.TypedDict",
        "typing_extensions.deprecated",
        "email_validator",
        "pydantic.EmailStr"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "validate",
      "module": "models",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\openapi\\models.py",
      "line_number": 30,
      "end_line_number": 35,
      "source_code": "def validate(cls, v: Any) -> str:\n            logger.warning(\n                \"email-validator not installed, email fields will be treated as str.\\n\"\n                \"To install, run: pip install email-validator\"\n            )\n            return str(v)",
      "docstring": null,
      "decorators": [
        "classmethod"
      ],
      "arguments": [
        "cls",
        "v"
      ],
      "imports": [
        "enum.Enum",
        "typing.Any",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Optional",
        "typing.Set",
        "typing.Type",
        "typing.Union",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.CoreSchema",
        "fastapi._compat.GetJsonSchemaHandler",
        "fastapi._compat.JsonSchemaValue",
        "fastapi._compat._model_rebuild",
        "fastapi._compat.with_info_plain_validator_function",
        "fastapi.logger.logger",
        "pydantic.AnyUrl",
        "pydantic.BaseModel",
        "pydantic.Field",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.TypedDict",
        "typing_extensions.deprecated",
        "email_validator",
        "pydantic.EmailStr"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "_validate",
      "module": "models",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\openapi\\models.py",
      "line_number": 38,
      "end_line_number": 43,
      "source_code": "def _validate(cls, __input_value: Any, _: Any) -> str:\n            logger.warning(\n                \"email-validator not installed, email fields will be treated as str.\\n\"\n                \"To install, run: pip install email-validator\"\n            )\n            return str(__input_value)",
      "docstring": null,
      "decorators": [
        "classmethod"
      ],
      "arguments": [
        "cls",
        "__input_value",
        "_"
      ],
      "imports": [
        "enum.Enum",
        "typing.Any",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Optional",
        "typing.Set",
        "typing.Type",
        "typing.Union",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.CoreSchema",
        "fastapi._compat.GetJsonSchemaHandler",
        "fastapi._compat.JsonSchemaValue",
        "fastapi._compat._model_rebuild",
        "fastapi._compat.with_info_plain_validator_function",
        "fastapi.logger.logger",
        "pydantic.AnyUrl",
        "pydantic.BaseModel",
        "pydantic.Field",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.TypedDict",
        "typing_extensions.deprecated",
        "email_validator",
        "pydantic.EmailStr"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__get_pydantic_json_schema__",
      "module": "models",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\openapi\\models.py",
      "line_number": 46,
      "end_line_number": 49,
      "source_code": "def __get_pydantic_json_schema__(\n            cls, core_schema: CoreSchema, handler: GetJsonSchemaHandler\n        ) -> JsonSchemaValue:\n            return {\"type\": \"string\", \"format\": \"email\"}",
      "docstring": null,
      "decorators": [
        "classmethod"
      ],
      "arguments": [
        "cls",
        "core_schema",
        "handler"
      ],
      "imports": [
        "enum.Enum",
        "typing.Any",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Optional",
        "typing.Set",
        "typing.Type",
        "typing.Union",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.CoreSchema",
        "fastapi._compat.GetJsonSchemaHandler",
        "fastapi._compat.JsonSchemaValue",
        "fastapi._compat._model_rebuild",
        "fastapi._compat.with_info_plain_validator_function",
        "fastapi.logger.logger",
        "pydantic.AnyUrl",
        "pydantic.BaseModel",
        "pydantic.Field",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.TypedDict",
        "typing_extensions.deprecated",
        "email_validator",
        "pydantic.EmailStr"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__get_pydantic_core_schema__",
      "module": "models",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\openapi\\models.py",
      "line_number": 52,
      "end_line_number": 55,
      "source_code": "def __get_pydantic_core_schema__(\n            cls, source: Type[Any], handler: Callable[[Any], CoreSchema]\n        ) -> CoreSchema:\n            return with_info_plain_validator_function(cls._validate)",
      "docstring": null,
      "decorators": [
        "classmethod"
      ],
      "arguments": [
        "cls",
        "source",
        "handler"
      ],
      "imports": [
        "enum.Enum",
        "typing.Any",
        "typing.Callable",
        "typing.Dict",
        "typing.Iterable",
        "typing.List",
        "typing.Optional",
        "typing.Set",
        "typing.Type",
        "typing.Union",
        "fastapi._compat.PYDANTIC_V2",
        "fastapi._compat.CoreSchema",
        "fastapi._compat.GetJsonSchemaHandler",
        "fastapi._compat.JsonSchemaValue",
        "fastapi._compat._model_rebuild",
        "fastapi._compat.with_info_plain_validator_function",
        "fastapi.logger.logger",
        "pydantic.AnyUrl",
        "pydantic.BaseModel",
        "pydantic.Field",
        "typing_extensions.Annotated",
        "typing_extensions.Literal",
        "typing_extensions.TypedDict",
        "typing_extensions.deprecated",
        "email_validator",
        "pydantic.EmailStr"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "with_info_plain_validator_function",
          "body": "def with_info_plain_validator_function(function: Callable[..., Any], *, ref: Union[str, None]=None, metadata: Any=None, serialization: Any=None) -> Any:\n    return {}"
        }
      ]
    },
    {
      "name": "get_openapi_security_definitions",
      "module": "utils",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\openapi\\utils.py",
      "line_number": 77,
      "end_line_number": 91,
      "source_code": "def get_openapi_security_definitions(\n    flat_dependant: Dependant,\n) -> Tuple[Dict[str, Any], List[Dict[str, Any]]]:\n    security_definitions = {}\n    operation_security = []\n    for security_requirement in flat_dependant.security_requirements:\n        security_definition = jsonable_encoder(\n            security_requirement.security_scheme.model,\n            by_alias=True,\n            exclude_none=True,\n        )\n        security_name = security_requirement.security_scheme.scheme_name\n        security_definitions[security_name] = security_definition\n        operation_security.append({security_name: security_requirement.scopes})\n    return security_definitions, operation_security",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "flat_dependant"
      ],
      "imports": [
        "http.client",
        "inspect",
        "warnings",
        "typing.Any",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "typing.cast",
        "fastapi.routing",
        "fastapi._compat.GenerateJsonSchema",
        "fastapi._compat.JsonSchemaValue",
        "fastapi._compat.ModelField",
        "fastapi._compat.Undefined",
        "fastapi._compat.get_compat_model_name_map",
        "fastapi._compat.get_definitions",
        "fastapi._compat.get_schema_from_model_field",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.utils._get_flat_fields_from_params",
        "fastapi.dependencies.utils.get_flat_dependant",
        "fastapi.dependencies.utils.get_flat_params",
        "fastapi.encoders.jsonable_encoder",
        "fastapi.openapi.constants.METHODS_WITH_BODY",
        "fastapi.openapi.constants.REF_PREFIX",
        "fastapi.openapi.constants.REF_TEMPLATE",
        "fastapi.openapi.models.OpenAPI",
        "fastapi.params.Body",
        "fastapi.params.ParamTypes",
        "fastapi.responses.Response",
        "fastapi.types.ModelNameMap",
        "fastapi.utils.deep_dict_update",
        "fastapi.utils.generate_operation_id_for_path",
        "fastapi.utils.is_body_allowed_for_status_code",
        "starlette.responses.JSONResponse",
        "starlette.routing.BaseRoute",
        "starlette.status.HTTP_422_UNPROCESSABLE_ENTITY",
        "typing_extensions.Literal"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "jsonable_encoder",
          "body": "def jsonable_encoder(obj: Annotated[Any, Doc('\\n            The input object to convert to JSON.\\n            ')], include: Annotated[Optional[IncEx], Doc(\"\\n            Pydantic's `include` parameter, passed to Pydantic models to set the\\n            fields to include.\\n            \")]=None, exclude: Annotated[Optional[IncEx], Doc(\"\\n            Pydantic's `exclude` parameter, passed to Pydantic models to set the\\n            fields to exclude.\\n            \")]=None, by_alias: Annotated[bool, Doc(\"\\n            Pydantic's `by_alias` parameter, passed to Pydantic models to define if\\n            the output should use the alias names (when provided) or the Python\\n            attribute names. In an API, if you set an alias, it's probably because you\\n            want to use it in the result, so you probably want to leave this set to\\n            `True`.\\n            \")]=True, exclude_unset: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_unset` parameter, passed to Pydantic models to define\\n            if it should exclude from the output the fields that were not explicitly\\n            set (and that only had their default values).\\n            \")]=False, exclude_defaults: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_defaults` parameter, passed to Pydantic models to define\\n            if it should exclude from the output the fields that had the same default\\n            value, even when they were explicitly set.\\n            \")]=False, exclude_none: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_none` parameter, passed to Pydantic models to define\\n            if it should exclude from the output any fields that have a `None` value.\\n            \")]=False, custom_encoder: Annotated[Optional[Dict[Any, Callable[[Any], Any]]], Doc(\"\\n            Pydantic's `custom_encoder` parameter, passed to Pydantic models to define\\n            a custom encoder.\\n            \")]=None, sqlalchemy_safe: Annotated[bool, Doc(\"\\n            Exclude from the output any fields that start with the name `_sa`.\\n\\n            This is mainly a hack for compatibility with SQLAlchemy objects, they\\n            store internal SQLAlchemy-specific state in attributes named with `_sa`,\\n            and those objects can't (and shouldn't be) serialized to JSON.\\n            \")]=True) -> Any:\n    \"\"\"\n    Convert any object to something that can be encoded in JSON.\n\n    This is used internally by FastAPI to make sure anything you return can be\n    encoded as JSON before it is sent to the client.\n\n    You can also use it yourself, for example to convert objects before saving them\n    in a database that supports only JSON.\n\n    Read more about it in the\n    [FastAPI docs for JSON Compatible Encoder](https://fastapi.tiangolo.com/tutorial/encoder/).\n    \"\"\"\n    custom_encoder = custom_encoder or {}\n    if custom_encoder:\n        if type(obj) in custom_encoder:\n            return custom_encoder[type(obj)](obj)\n        else:\n            for encoder_type, encoder_instance in custom_encoder.items():\n                if isinstance(obj, encoder_type):\n                    return encoder_instance(obj)\n    if include is not None and (not isinstance(include, (set, dict))):\n        include = set(include)\n    if exclude is not None and (not isinstance(exclude, (set, dict))):\n        exclude = set(exclude)\n    if isinstance(obj, BaseModel):\n        encoders: Dict[Any, Any] = {}\n        if not PYDANTIC_V2:\n            encoders = getattr(obj.__config__, 'json_encoders', {})\n            if custom_encoder:\n                encoders.update(custom_encoder)\n        obj_dict = _model_dump(obj, mode='json', include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, exclude_defaults=exclude_defaults)\n        if '__root__' in obj_dict:\n            obj_dict = obj_dict['__root__']\n        return jsonable_encoder(obj_dict, exclude_none=exclude_none, exclude_defaults=exclude_defaults, custom_encoder=encoders, sqlalchemy_safe=sqlalchemy_safe)\n    if dataclasses.is_dataclass(obj):\n        obj_dict = dataclasses.asdict(obj)\n        return jsonable_encoder(obj_dict, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n    if isinstance(obj, Enum):\n        return obj.value\n    if isinstance(obj, PurePath):\n        return str(obj)\n    if isinstance(obj, (str, int, float, type(None))):\n        return obj\n    if isinstance(obj, UndefinedType):\n        return None\n    if isinstance(obj, dict):\n        encoded_dict = {}\n        allowed_keys = set(obj.keys())\n        if include is not None:\n            allowed_keys &= set(include)\n        if exclude is not None:\n            allowed_keys -= set(exclude)\n        for key, value in obj.items():\n            if (not sqlalchemy_safe or not isinstance(key, str) or (not key.startswith('_sa'))) and (value is not None or not exclude_none) and (key in allowed_keys):\n                encoded_key = jsonable_encoder(key, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n                encoded_value = jsonable_encoder(value, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n                encoded_dict[encoded_key] = encoded_value\n        return encoded_dict\n    if isinstance(obj, (list, set, frozenset, GeneratorType, tuple, deque)):\n        encoded_list = []\n        for item in obj:\n            encoded_list.append(jsonable_encoder(item, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe))\n        return encoded_list\n    if type(obj) in ENCODERS_BY_TYPE:\n        return ENCODERS_BY_TYPE[type(obj)](obj)\n    for encoder, classes_tuple in encoders_by_class_tuples.items():\n        if isinstance(obj, classes_tuple):\n            return encoder(obj)\n    try:\n        data = dict(obj)\n    except Exception as e:\n        errors: List[Exception] = []\n        errors.append(e)\n        try:\n            data = vars(obj)\n        except Exception as e:\n            errors.append(e)\n            raise ValueError(errors) from e\n    return jsonable_encoder(data, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)"
        }
      ]
    },
    {
      "name": "_get_openapi_operation_parameters",
      "module": "utils",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\openapi\\utils.py",
      "line_number": 94,
      "end_line_number": 146,
      "source_code": "def _get_openapi_operation_parameters(\n    *,\n    dependant: Dependant,\n    schema_generator: GenerateJsonSchema,\n    model_name_map: ModelNameMap,\n    field_mapping: Dict[\n        Tuple[ModelField, Literal[\"validation\", \"serialization\"]], JsonSchemaValue\n    ],\n    separate_input_output_schemas: bool = True,\n) -> List[Dict[str, Any]]:\n    parameters = []\n    flat_dependant = get_flat_dependant(dependant, skip_repeats=True)\n    path_params = _get_flat_fields_from_params(flat_dependant.path_params)\n    query_params = _get_flat_fields_from_params(flat_dependant.query_params)\n    header_params = _get_flat_fields_from_params(flat_dependant.header_params)\n    cookie_params = _get_flat_fields_from_params(flat_dependant.cookie_params)\n    parameter_groups = [\n        (ParamTypes.path, path_params),\n        (ParamTypes.query, query_params),\n        (ParamTypes.header, header_params),\n        (ParamTypes.cookie, cookie_params),\n    ]\n    for param_type, param_group in parameter_groups:\n        for param in param_group:\n            field_info = param.field_info\n            # field_info = cast(Param, field_info)\n            if not getattr(field_info, \"include_in_schema\", True):\n                continue\n            param_schema = get_schema_from_model_field(\n                field=param,\n                schema_generator=schema_generator,\n                model_name_map=model_name_map,\n                field_mapping=field_mapping,\n                separate_input_output_schemas=separate_input_output_schemas,\n            )\n            parameter = {\n                \"name\": param.alias,\n                \"in\": param_type.value,\n                \"required\": param.required,\n                \"schema\": param_schema,\n            }\n            if field_info.description:\n                parameter[\"description\"] = field_info.description\n            openapi_examples = getattr(field_info, \"openapi_examples\", None)\n            example = getattr(field_info, \"example\", None)\n            if openapi_examples:\n                parameter[\"examples\"] = jsonable_encoder(openapi_examples)\n            elif example != Undefined:\n                parameter[\"example\"] = jsonable_encoder(example)\n            if getattr(field_info, \"deprecated\", None):\n                parameter[\"deprecated\"] = True\n            parameters.append(parameter)\n    return parameters",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "http.client",
        "inspect",
        "warnings",
        "typing.Any",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "typing.cast",
        "fastapi.routing",
        "fastapi._compat.GenerateJsonSchema",
        "fastapi._compat.JsonSchemaValue",
        "fastapi._compat.ModelField",
        "fastapi._compat.Undefined",
        "fastapi._compat.get_compat_model_name_map",
        "fastapi._compat.get_definitions",
        "fastapi._compat.get_schema_from_model_field",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.utils._get_flat_fields_from_params",
        "fastapi.dependencies.utils.get_flat_dependant",
        "fastapi.dependencies.utils.get_flat_params",
        "fastapi.encoders.jsonable_encoder",
        "fastapi.openapi.constants.METHODS_WITH_BODY",
        "fastapi.openapi.constants.REF_PREFIX",
        "fastapi.openapi.constants.REF_TEMPLATE",
        "fastapi.openapi.models.OpenAPI",
        "fastapi.params.Body",
        "fastapi.params.ParamTypes",
        "fastapi.responses.Response",
        "fastapi.types.ModelNameMap",
        "fastapi.utils.deep_dict_update",
        "fastapi.utils.generate_operation_id_for_path",
        "fastapi.utils.is_body_allowed_for_status_code",
        "starlette.responses.JSONResponse",
        "starlette.routing.BaseRoute",
        "starlette.status.HTTP_422_UNPROCESSABLE_ENTITY",
        "typing_extensions.Literal"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_flat_dependant",
          "body": "def get_flat_dependant(dependant: Dependant, *, skip_repeats: bool=False, visited: Optional[List[CacheKey]]=None) -> Dependant:\n    if visited is None:\n        visited = []\n    visited.append(dependant.cache_key)\n    flat_dependant = Dependant(path_params=dependant.path_params.copy(), query_params=dependant.query_params.copy(), header_params=dependant.header_params.copy(), cookie_params=dependant.cookie_params.copy(), body_params=dependant.body_params.copy(), security_requirements=dependant.security_requirements.copy(), use_cache=dependant.use_cache, path=dependant.path)\n    for sub_dependant in dependant.dependencies:\n        if skip_repeats and sub_dependant.cache_key in visited:\n            continue\n        flat_sub = get_flat_dependant(sub_dependant, skip_repeats=skip_repeats, visited=visited)\n        flat_dependant.path_params.extend(flat_sub.path_params)\n        flat_dependant.query_params.extend(flat_sub.query_params)\n        flat_dependant.header_params.extend(flat_sub.header_params)\n        flat_dependant.cookie_params.extend(flat_sub.cookie_params)\n        flat_dependant.body_params.extend(flat_sub.body_params)\n        flat_dependant.security_requirements.extend(flat_sub.security_requirements)\n    return flat_dependant"
        },
        {
          "name": "_get_flat_fields_from_params",
          "body": "def _get_flat_fields_from_params(fields: List[ModelField]) -> List[ModelField]:\n    if not fields:\n        return fields\n    first_field = fields[0]\n    if len(fields) == 1 and lenient_issubclass(first_field.type_, BaseModel):\n        fields_to_extract = get_cached_model_fields(first_field.type_)\n        return fields_to_extract\n    return fields"
        },
        {
          "name": "_get_flat_fields_from_params",
          "body": "def _get_flat_fields_from_params(fields: List[ModelField]) -> List[ModelField]:\n    if not fields:\n        return fields\n    first_field = fields[0]\n    if len(fields) == 1 and lenient_issubclass(first_field.type_, BaseModel):\n        fields_to_extract = get_cached_model_fields(first_field.type_)\n        return fields_to_extract\n    return fields"
        },
        {
          "name": "_get_flat_fields_from_params",
          "body": "def _get_flat_fields_from_params(fields: List[ModelField]) -> List[ModelField]:\n    if not fields:\n        return fields\n    first_field = fields[0]\n    if len(fields) == 1 and lenient_issubclass(first_field.type_, BaseModel):\n        fields_to_extract = get_cached_model_fields(first_field.type_)\n        return fields_to_extract\n    return fields"
        },
        {
          "name": "_get_flat_fields_from_params",
          "body": "def _get_flat_fields_from_params(fields: List[ModelField]) -> List[ModelField]:\n    if not fields:\n        return fields\n    first_field = fields[0]\n    if len(fields) == 1 and lenient_issubclass(first_field.type_, BaseModel):\n        fields_to_extract = get_cached_model_fields(first_field.type_)\n        return fields_to_extract\n    return fields"
        },
        {
          "name": "get_schema_from_model_field",
          "body": "def get_schema_from_model_field(*, field: ModelField, schema_generator: GenerateJsonSchema, model_name_map: ModelNameMap, field_mapping: Dict[Tuple[ModelField, Literal['validation', 'serialization']], JsonSchemaValue], separate_input_output_schemas: bool=True) -> Dict[str, Any]:\n    override_mode: Union[Literal['validation'], None] = None if separate_input_output_schemas else 'validation'\n    json_schema = field_mapping[field, override_mode or field.mode]\n    if '$ref' not in json_schema:\n        json_schema['title'] = field.field_info.title or field.alias.title().replace('_', ' ')\n    return json_schema"
        },
        {
          "name": "jsonable_encoder",
          "body": "def jsonable_encoder(obj: Annotated[Any, Doc('\\n            The input object to convert to JSON.\\n            ')], include: Annotated[Optional[IncEx], Doc(\"\\n            Pydantic's `include` parameter, passed to Pydantic models to set the\\n            fields to include.\\n            \")]=None, exclude: Annotated[Optional[IncEx], Doc(\"\\n            Pydantic's `exclude` parameter, passed to Pydantic models to set the\\n            fields to exclude.\\n            \")]=None, by_alias: Annotated[bool, Doc(\"\\n            Pydantic's `by_alias` parameter, passed to Pydantic models to define if\\n            the output should use the alias names (when provided) or the Python\\n            attribute names. In an API, if you set an alias, it's probably because you\\n            want to use it in the result, so you probably want to leave this set to\\n            `True`.\\n            \")]=True, exclude_unset: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_unset` parameter, passed to Pydantic models to define\\n            if it should exclude from the output the fields that were not explicitly\\n            set (and that only had their default values).\\n            \")]=False, exclude_defaults: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_defaults` parameter, passed to Pydantic models to define\\n            if it should exclude from the output the fields that had the same default\\n            value, even when they were explicitly set.\\n            \")]=False, exclude_none: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_none` parameter, passed to Pydantic models to define\\n            if it should exclude from the output any fields that have a `None` value.\\n            \")]=False, custom_encoder: Annotated[Optional[Dict[Any, Callable[[Any], Any]]], Doc(\"\\n            Pydantic's `custom_encoder` parameter, passed to Pydantic models to define\\n            a custom encoder.\\n            \")]=None, sqlalchemy_safe: Annotated[bool, Doc(\"\\n            Exclude from the output any fields that start with the name `_sa`.\\n\\n            This is mainly a hack for compatibility with SQLAlchemy objects, they\\n            store internal SQLAlchemy-specific state in attributes named with `_sa`,\\n            and those objects can't (and shouldn't be) serialized to JSON.\\n            \")]=True) -> Any:\n    \"\"\"\n    Convert any object to something that can be encoded in JSON.\n\n    This is used internally by FastAPI to make sure anything you return can be\n    encoded as JSON before it is sent to the client.\n\n    You can also use it yourself, for example to convert objects before saving them\n    in a database that supports only JSON.\n\n    Read more about it in the\n    [FastAPI docs for JSON Compatible Encoder](https://fastapi.tiangolo.com/tutorial/encoder/).\n    \"\"\"\n    custom_encoder = custom_encoder or {}\n    if custom_encoder:\n        if type(obj) in custom_encoder:\n            return custom_encoder[type(obj)](obj)\n        else:\n            for encoder_type, encoder_instance in custom_encoder.items():\n                if isinstance(obj, encoder_type):\n                    return encoder_instance(obj)\n    if include is not None and (not isinstance(include, (set, dict))):\n        include = set(include)\n    if exclude is not None and (not isinstance(exclude, (set, dict))):\n        exclude = set(exclude)\n    if isinstance(obj, BaseModel):\n        encoders: Dict[Any, Any] = {}\n        if not PYDANTIC_V2:\n            encoders = getattr(obj.__config__, 'json_encoders', {})\n            if custom_encoder:\n                encoders.update(custom_encoder)\n        obj_dict = _model_dump(obj, mode='json', include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, exclude_defaults=exclude_defaults)\n        if '__root__' in obj_dict:\n            obj_dict = obj_dict['__root__']\n        return jsonable_encoder(obj_dict, exclude_none=exclude_none, exclude_defaults=exclude_defaults, custom_encoder=encoders, sqlalchemy_safe=sqlalchemy_safe)\n    if dataclasses.is_dataclass(obj):\n        obj_dict = dataclasses.asdict(obj)\n        return jsonable_encoder(obj_dict, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n    if isinstance(obj, Enum):\n        return obj.value\n    if isinstance(obj, PurePath):\n        return str(obj)\n    if isinstance(obj, (str, int, float, type(None))):\n        return obj\n    if isinstance(obj, UndefinedType):\n        return None\n    if isinstance(obj, dict):\n        encoded_dict = {}\n        allowed_keys = set(obj.keys())\n        if include is not None:\n            allowed_keys &= set(include)\n        if exclude is not None:\n            allowed_keys -= set(exclude)\n        for key, value in obj.items():\n            if (not sqlalchemy_safe or not isinstance(key, str) or (not key.startswith('_sa'))) and (value is not None or not exclude_none) and (key in allowed_keys):\n                encoded_key = jsonable_encoder(key, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n                encoded_value = jsonable_encoder(value, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n                encoded_dict[encoded_key] = encoded_value\n        return encoded_dict\n    if isinstance(obj, (list, set, frozenset, GeneratorType, tuple, deque)):\n        encoded_list = []\n        for item in obj:\n            encoded_list.append(jsonable_encoder(item, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe))\n        return encoded_list\n    if type(obj) in ENCODERS_BY_TYPE:\n        return ENCODERS_BY_TYPE[type(obj)](obj)\n    for encoder, classes_tuple in encoders_by_class_tuples.items():\n        if isinstance(obj, classes_tuple):\n            return encoder(obj)\n    try:\n        data = dict(obj)\n    except Exception as e:\n        errors: List[Exception] = []\n        errors.append(e)\n        try:\n            data = vars(obj)\n        except Exception as e:\n            errors.append(e)\n            raise ValueError(errors) from e\n    return jsonable_encoder(data, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)"
        },
        {
          "name": "jsonable_encoder",
          "body": "def jsonable_encoder(obj: Annotated[Any, Doc('\\n            The input object to convert to JSON.\\n            ')], include: Annotated[Optional[IncEx], Doc(\"\\n            Pydantic's `include` parameter, passed to Pydantic models to set the\\n            fields to include.\\n            \")]=None, exclude: Annotated[Optional[IncEx], Doc(\"\\n            Pydantic's `exclude` parameter, passed to Pydantic models to set the\\n            fields to exclude.\\n            \")]=None, by_alias: Annotated[bool, Doc(\"\\n            Pydantic's `by_alias` parameter, passed to Pydantic models to define if\\n            the output should use the alias names (when provided) or the Python\\n            attribute names. In an API, if you set an alias, it's probably because you\\n            want to use it in the result, so you probably want to leave this set to\\n            `True`.\\n            \")]=True, exclude_unset: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_unset` parameter, passed to Pydantic models to define\\n            if it should exclude from the output the fields that were not explicitly\\n            set (and that only had their default values).\\n            \")]=False, exclude_defaults: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_defaults` parameter, passed to Pydantic models to define\\n            if it should exclude from the output the fields that had the same default\\n            value, even when they were explicitly set.\\n            \")]=False, exclude_none: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_none` parameter, passed to Pydantic models to define\\n            if it should exclude from the output any fields that have a `None` value.\\n            \")]=False, custom_encoder: Annotated[Optional[Dict[Any, Callable[[Any], Any]]], Doc(\"\\n            Pydantic's `custom_encoder` parameter, passed to Pydantic models to define\\n            a custom encoder.\\n            \")]=None, sqlalchemy_safe: Annotated[bool, Doc(\"\\n            Exclude from the output any fields that start with the name `_sa`.\\n\\n            This is mainly a hack for compatibility with SQLAlchemy objects, they\\n            store internal SQLAlchemy-specific state in attributes named with `_sa`,\\n            and those objects can't (and shouldn't be) serialized to JSON.\\n            \")]=True) -> Any:\n    \"\"\"\n    Convert any object to something that can be encoded in JSON.\n\n    This is used internally by FastAPI to make sure anything you return can be\n    encoded as JSON before it is sent to the client.\n\n    You can also use it yourself, for example to convert objects before saving them\n    in a database that supports only JSON.\n\n    Read more about it in the\n    [FastAPI docs for JSON Compatible Encoder](https://fastapi.tiangolo.com/tutorial/encoder/).\n    \"\"\"\n    custom_encoder = custom_encoder or {}\n    if custom_encoder:\n        if type(obj) in custom_encoder:\n            return custom_encoder[type(obj)](obj)\n        else:\n            for encoder_type, encoder_instance in custom_encoder.items():\n                if isinstance(obj, encoder_type):\n                    return encoder_instance(obj)\n    if include is not None and (not isinstance(include, (set, dict))):\n        include = set(include)\n    if exclude is not None and (not isinstance(exclude, (set, dict))):\n        exclude = set(exclude)\n    if isinstance(obj, BaseModel):\n        encoders: Dict[Any, Any] = {}\n        if not PYDANTIC_V2:\n            encoders = getattr(obj.__config__, 'json_encoders', {})\n            if custom_encoder:\n                encoders.update(custom_encoder)\n        obj_dict = _model_dump(obj, mode='json', include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, exclude_defaults=exclude_defaults)\n        if '__root__' in obj_dict:\n            obj_dict = obj_dict['__root__']\n        return jsonable_encoder(obj_dict, exclude_none=exclude_none, exclude_defaults=exclude_defaults, custom_encoder=encoders, sqlalchemy_safe=sqlalchemy_safe)\n    if dataclasses.is_dataclass(obj):\n        obj_dict = dataclasses.asdict(obj)\n        return jsonable_encoder(obj_dict, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n    if isinstance(obj, Enum):\n        return obj.value\n    if isinstance(obj, PurePath):\n        return str(obj)\n    if isinstance(obj, (str, int, float, type(None))):\n        return obj\n    if isinstance(obj, UndefinedType):\n        return None\n    if isinstance(obj, dict):\n        encoded_dict = {}\n        allowed_keys = set(obj.keys())\n        if include is not None:\n            allowed_keys &= set(include)\n        if exclude is not None:\n            allowed_keys -= set(exclude)\n        for key, value in obj.items():\n            if (not sqlalchemy_safe or not isinstance(key, str) or (not key.startswith('_sa'))) and (value is not None or not exclude_none) and (key in allowed_keys):\n                encoded_key = jsonable_encoder(key, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n                encoded_value = jsonable_encoder(value, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n                encoded_dict[encoded_key] = encoded_value\n        return encoded_dict\n    if isinstance(obj, (list, set, frozenset, GeneratorType, tuple, deque)):\n        encoded_list = []\n        for item in obj:\n            encoded_list.append(jsonable_encoder(item, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe))\n        return encoded_list\n    if type(obj) in ENCODERS_BY_TYPE:\n        return ENCODERS_BY_TYPE[type(obj)](obj)\n    for encoder, classes_tuple in encoders_by_class_tuples.items():\n        if isinstance(obj, classes_tuple):\n            return encoder(obj)\n    try:\n        data = dict(obj)\n    except Exception as e:\n        errors: List[Exception] = []\n        errors.append(e)\n        try:\n            data = vars(obj)\n        except Exception as e:\n            errors.append(e)\n            raise ValueError(errors) from e\n    return jsonable_encoder(data, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)"
        }
      ]
    },
    {
      "name": "get_openapi_operation_request_body",
      "module": "utils",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\openapi\\utils.py",
      "line_number": 149,
      "end_line_number": 183,
      "source_code": "def get_openapi_operation_request_body(\n    *,\n    body_field: Optional[ModelField],\n    schema_generator: GenerateJsonSchema,\n    model_name_map: ModelNameMap,\n    field_mapping: Dict[\n        Tuple[ModelField, Literal[\"validation\", \"serialization\"]], JsonSchemaValue\n    ],\n    separate_input_output_schemas: bool = True,\n) -> Optional[Dict[str, Any]]:\n    if not body_field:\n        return None\n    assert isinstance(body_field, ModelField)\n    body_schema = get_schema_from_model_field(\n        field=body_field,\n        schema_generator=schema_generator,\n        model_name_map=model_name_map,\n        field_mapping=field_mapping,\n        separate_input_output_schemas=separate_input_output_schemas,\n    )\n    field_info = cast(Body, body_field.field_info)\n    request_media_type = field_info.media_type\n    required = body_field.required\n    request_body_oai: Dict[str, Any] = {}\n    if required:\n        request_body_oai[\"required\"] = required\n    request_media_content: Dict[str, Any] = {\"schema\": body_schema}\n    if field_info.openapi_examples:\n        request_media_content[\"examples\"] = jsonable_encoder(\n            field_info.openapi_examples\n        )\n    elif field_info.example != Undefined:\n        request_media_content[\"example\"] = jsonable_encoder(field_info.example)\n    request_body_oai[\"content\"] = {request_media_type: request_media_content}\n    return request_body_oai",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "http.client",
        "inspect",
        "warnings",
        "typing.Any",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "typing.cast",
        "fastapi.routing",
        "fastapi._compat.GenerateJsonSchema",
        "fastapi._compat.JsonSchemaValue",
        "fastapi._compat.ModelField",
        "fastapi._compat.Undefined",
        "fastapi._compat.get_compat_model_name_map",
        "fastapi._compat.get_definitions",
        "fastapi._compat.get_schema_from_model_field",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.utils._get_flat_fields_from_params",
        "fastapi.dependencies.utils.get_flat_dependant",
        "fastapi.dependencies.utils.get_flat_params",
        "fastapi.encoders.jsonable_encoder",
        "fastapi.openapi.constants.METHODS_WITH_BODY",
        "fastapi.openapi.constants.REF_PREFIX",
        "fastapi.openapi.constants.REF_TEMPLATE",
        "fastapi.openapi.models.OpenAPI",
        "fastapi.params.Body",
        "fastapi.params.ParamTypes",
        "fastapi.responses.Response",
        "fastapi.types.ModelNameMap",
        "fastapi.utils.deep_dict_update",
        "fastapi.utils.generate_operation_id_for_path",
        "fastapi.utils.is_body_allowed_for_status_code",
        "starlette.responses.JSONResponse",
        "starlette.routing.BaseRoute",
        "starlette.status.HTTP_422_UNPROCESSABLE_ENTITY",
        "typing_extensions.Literal"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(body_field, ModelField)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_schema_from_model_field",
          "body": "def get_schema_from_model_field(*, field: ModelField, schema_generator: GenerateJsonSchema, model_name_map: ModelNameMap, field_mapping: Dict[Tuple[ModelField, Literal['validation', 'serialization']], JsonSchemaValue], separate_input_output_schemas: bool=True) -> Dict[str, Any]:\n    override_mode: Union[Literal['validation'], None] = None if separate_input_output_schemas else 'validation'\n    json_schema = field_mapping[field, override_mode or field.mode]\n    if '$ref' not in json_schema:\n        json_schema['title'] = field.field_info.title or field.alias.title().replace('_', ' ')\n    return json_schema"
        },
        {
          "name": "jsonable_encoder",
          "body": "def jsonable_encoder(obj: Annotated[Any, Doc('\\n            The input object to convert to JSON.\\n            ')], include: Annotated[Optional[IncEx], Doc(\"\\n            Pydantic's `include` parameter, passed to Pydantic models to set the\\n            fields to include.\\n            \")]=None, exclude: Annotated[Optional[IncEx], Doc(\"\\n            Pydantic's `exclude` parameter, passed to Pydantic models to set the\\n            fields to exclude.\\n            \")]=None, by_alias: Annotated[bool, Doc(\"\\n            Pydantic's `by_alias` parameter, passed to Pydantic models to define if\\n            the output should use the alias names (when provided) or the Python\\n            attribute names. In an API, if you set an alias, it's probably because you\\n            want to use it in the result, so you probably want to leave this set to\\n            `True`.\\n            \")]=True, exclude_unset: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_unset` parameter, passed to Pydantic models to define\\n            if it should exclude from the output the fields that were not explicitly\\n            set (and that only had their default values).\\n            \")]=False, exclude_defaults: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_defaults` parameter, passed to Pydantic models to define\\n            if it should exclude from the output the fields that had the same default\\n            value, even when they were explicitly set.\\n            \")]=False, exclude_none: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_none` parameter, passed to Pydantic models to define\\n            if it should exclude from the output any fields that have a `None` value.\\n            \")]=False, custom_encoder: Annotated[Optional[Dict[Any, Callable[[Any], Any]]], Doc(\"\\n            Pydantic's `custom_encoder` parameter, passed to Pydantic models to define\\n            a custom encoder.\\n            \")]=None, sqlalchemy_safe: Annotated[bool, Doc(\"\\n            Exclude from the output any fields that start with the name `_sa`.\\n\\n            This is mainly a hack for compatibility with SQLAlchemy objects, they\\n            store internal SQLAlchemy-specific state in attributes named with `_sa`,\\n            and those objects can't (and shouldn't be) serialized to JSON.\\n            \")]=True) -> Any:\n    \"\"\"\n    Convert any object to something that can be encoded in JSON.\n\n    This is used internally by FastAPI to make sure anything you return can be\n    encoded as JSON before it is sent to the client.\n\n    You can also use it yourself, for example to convert objects before saving them\n    in a database that supports only JSON.\n\n    Read more about it in the\n    [FastAPI docs for JSON Compatible Encoder](https://fastapi.tiangolo.com/tutorial/encoder/).\n    \"\"\"\n    custom_encoder = custom_encoder or {}\n    if custom_encoder:\n        if type(obj) in custom_encoder:\n            return custom_encoder[type(obj)](obj)\n        else:\n            for encoder_type, encoder_instance in custom_encoder.items():\n                if isinstance(obj, encoder_type):\n                    return encoder_instance(obj)\n    if include is not None and (not isinstance(include, (set, dict))):\n        include = set(include)\n    if exclude is not None and (not isinstance(exclude, (set, dict))):\n        exclude = set(exclude)\n    if isinstance(obj, BaseModel):\n        encoders: Dict[Any, Any] = {}\n        if not PYDANTIC_V2:\n            encoders = getattr(obj.__config__, 'json_encoders', {})\n            if custom_encoder:\n                encoders.update(custom_encoder)\n        obj_dict = _model_dump(obj, mode='json', include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, exclude_defaults=exclude_defaults)\n        if '__root__' in obj_dict:\n            obj_dict = obj_dict['__root__']\n        return jsonable_encoder(obj_dict, exclude_none=exclude_none, exclude_defaults=exclude_defaults, custom_encoder=encoders, sqlalchemy_safe=sqlalchemy_safe)\n    if dataclasses.is_dataclass(obj):\n        obj_dict = dataclasses.asdict(obj)\n        return jsonable_encoder(obj_dict, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n    if isinstance(obj, Enum):\n        return obj.value\n    if isinstance(obj, PurePath):\n        return str(obj)\n    if isinstance(obj, (str, int, float, type(None))):\n        return obj\n    if isinstance(obj, UndefinedType):\n        return None\n    if isinstance(obj, dict):\n        encoded_dict = {}\n        allowed_keys = set(obj.keys())\n        if include is not None:\n            allowed_keys &= set(include)\n        if exclude is not None:\n            allowed_keys -= set(exclude)\n        for key, value in obj.items():\n            if (not sqlalchemy_safe or not isinstance(key, str) or (not key.startswith('_sa'))) and (value is not None or not exclude_none) and (key in allowed_keys):\n                encoded_key = jsonable_encoder(key, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n                encoded_value = jsonable_encoder(value, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n                encoded_dict[encoded_key] = encoded_value\n        return encoded_dict\n    if isinstance(obj, (list, set, frozenset, GeneratorType, tuple, deque)):\n        encoded_list = []\n        for item in obj:\n            encoded_list.append(jsonable_encoder(item, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe))\n        return encoded_list\n    if type(obj) in ENCODERS_BY_TYPE:\n        return ENCODERS_BY_TYPE[type(obj)](obj)\n    for encoder, classes_tuple in encoders_by_class_tuples.items():\n        if isinstance(obj, classes_tuple):\n            return encoder(obj)\n    try:\n        data = dict(obj)\n    except Exception as e:\n        errors: List[Exception] = []\n        errors.append(e)\n        try:\n            data = vars(obj)\n        except Exception as e:\n            errors.append(e)\n            raise ValueError(errors) from e\n    return jsonable_encoder(data, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)"
        },
        {
          "name": "jsonable_encoder",
          "body": "def jsonable_encoder(obj: Annotated[Any, Doc('\\n            The input object to convert to JSON.\\n            ')], include: Annotated[Optional[IncEx], Doc(\"\\n            Pydantic's `include` parameter, passed to Pydantic models to set the\\n            fields to include.\\n            \")]=None, exclude: Annotated[Optional[IncEx], Doc(\"\\n            Pydantic's `exclude` parameter, passed to Pydantic models to set the\\n            fields to exclude.\\n            \")]=None, by_alias: Annotated[bool, Doc(\"\\n            Pydantic's `by_alias` parameter, passed to Pydantic models to define if\\n            the output should use the alias names (when provided) or the Python\\n            attribute names. In an API, if you set an alias, it's probably because you\\n            want to use it in the result, so you probably want to leave this set to\\n            `True`.\\n            \")]=True, exclude_unset: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_unset` parameter, passed to Pydantic models to define\\n            if it should exclude from the output the fields that were not explicitly\\n            set (and that only had their default values).\\n            \")]=False, exclude_defaults: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_defaults` parameter, passed to Pydantic models to define\\n            if it should exclude from the output the fields that had the same default\\n            value, even when they were explicitly set.\\n            \")]=False, exclude_none: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_none` parameter, passed to Pydantic models to define\\n            if it should exclude from the output any fields that have a `None` value.\\n            \")]=False, custom_encoder: Annotated[Optional[Dict[Any, Callable[[Any], Any]]], Doc(\"\\n            Pydantic's `custom_encoder` parameter, passed to Pydantic models to define\\n            a custom encoder.\\n            \")]=None, sqlalchemy_safe: Annotated[bool, Doc(\"\\n            Exclude from the output any fields that start with the name `_sa`.\\n\\n            This is mainly a hack for compatibility with SQLAlchemy objects, they\\n            store internal SQLAlchemy-specific state in attributes named with `_sa`,\\n            and those objects can't (and shouldn't be) serialized to JSON.\\n            \")]=True) -> Any:\n    \"\"\"\n    Convert any object to something that can be encoded in JSON.\n\n    This is used internally by FastAPI to make sure anything you return can be\n    encoded as JSON before it is sent to the client.\n\n    You can also use it yourself, for example to convert objects before saving them\n    in a database that supports only JSON.\n\n    Read more about it in the\n    [FastAPI docs for JSON Compatible Encoder](https://fastapi.tiangolo.com/tutorial/encoder/).\n    \"\"\"\n    custom_encoder = custom_encoder or {}\n    if custom_encoder:\n        if type(obj) in custom_encoder:\n            return custom_encoder[type(obj)](obj)\n        else:\n            for encoder_type, encoder_instance in custom_encoder.items():\n                if isinstance(obj, encoder_type):\n                    return encoder_instance(obj)\n    if include is not None and (not isinstance(include, (set, dict))):\n        include = set(include)\n    if exclude is not None and (not isinstance(exclude, (set, dict))):\n        exclude = set(exclude)\n    if isinstance(obj, BaseModel):\n        encoders: Dict[Any, Any] = {}\n        if not PYDANTIC_V2:\n            encoders = getattr(obj.__config__, 'json_encoders', {})\n            if custom_encoder:\n                encoders.update(custom_encoder)\n        obj_dict = _model_dump(obj, mode='json', include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, exclude_defaults=exclude_defaults)\n        if '__root__' in obj_dict:\n            obj_dict = obj_dict['__root__']\n        return jsonable_encoder(obj_dict, exclude_none=exclude_none, exclude_defaults=exclude_defaults, custom_encoder=encoders, sqlalchemy_safe=sqlalchemy_safe)\n    if dataclasses.is_dataclass(obj):\n        obj_dict = dataclasses.asdict(obj)\n        return jsonable_encoder(obj_dict, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n    if isinstance(obj, Enum):\n        return obj.value\n    if isinstance(obj, PurePath):\n        return str(obj)\n    if isinstance(obj, (str, int, float, type(None))):\n        return obj\n    if isinstance(obj, UndefinedType):\n        return None\n    if isinstance(obj, dict):\n        encoded_dict = {}\n        allowed_keys = set(obj.keys())\n        if include is not None:\n            allowed_keys &= set(include)\n        if exclude is not None:\n            allowed_keys -= set(exclude)\n        for key, value in obj.items():\n            if (not sqlalchemy_safe or not isinstance(key, str) or (not key.startswith('_sa'))) and (value is not None or not exclude_none) and (key in allowed_keys):\n                encoded_key = jsonable_encoder(key, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n                encoded_value = jsonable_encoder(value, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n                encoded_dict[encoded_key] = encoded_value\n        return encoded_dict\n    if isinstance(obj, (list, set, frozenset, GeneratorType, tuple, deque)):\n        encoded_list = []\n        for item in obj:\n            encoded_list.append(jsonable_encoder(item, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe))\n        return encoded_list\n    if type(obj) in ENCODERS_BY_TYPE:\n        return ENCODERS_BY_TYPE[type(obj)](obj)\n    for encoder, classes_tuple in encoders_by_class_tuples.items():\n        if isinstance(obj, classes_tuple):\n            return encoder(obj)\n    try:\n        data = dict(obj)\n    except Exception as e:\n        errors: List[Exception] = []\n        errors.append(e)\n        try:\n            data = vars(obj)\n        except Exception as e:\n            errors.append(e)\n            raise ValueError(errors) from e\n    return jsonable_encoder(data, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)"
        }
      ]
    },
    {
      "name": "generate_operation_id",
      "module": "utils",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\openapi\\utils.py",
      "line_number": 186,
      "end_line_number": 198,
      "source_code": "def generate_operation_id(\n    *, route: routing.APIRoute, method: str\n) -> str:  # pragma: nocover\n    warnings.warn(\n        \"fastapi.openapi.utils.generate_operation_id() was deprecated, \"\n        \"it is not used internally, and will be removed soon\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    if route.operation_id:\n        return route.operation_id\n    path: str = route.path_format\n    return generate_operation_id_for_path(name=route.name, path=path, method=method)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "http.client",
        "inspect",
        "warnings",
        "typing.Any",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "typing.cast",
        "fastapi.routing",
        "fastapi._compat.GenerateJsonSchema",
        "fastapi._compat.JsonSchemaValue",
        "fastapi._compat.ModelField",
        "fastapi._compat.Undefined",
        "fastapi._compat.get_compat_model_name_map",
        "fastapi._compat.get_definitions",
        "fastapi._compat.get_schema_from_model_field",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.utils._get_flat_fields_from_params",
        "fastapi.dependencies.utils.get_flat_dependant",
        "fastapi.dependencies.utils.get_flat_params",
        "fastapi.encoders.jsonable_encoder",
        "fastapi.openapi.constants.METHODS_WITH_BODY",
        "fastapi.openapi.constants.REF_PREFIX",
        "fastapi.openapi.constants.REF_TEMPLATE",
        "fastapi.openapi.models.OpenAPI",
        "fastapi.params.Body",
        "fastapi.params.ParamTypes",
        "fastapi.responses.Response",
        "fastapi.types.ModelNameMap",
        "fastapi.utils.deep_dict_update",
        "fastapi.utils.generate_operation_id_for_path",
        "fastapi.utils.is_body_allowed_for_status_code",
        "starlette.responses.JSONResponse",
        "starlette.routing.BaseRoute",
        "starlette.status.HTTP_422_UNPROCESSABLE_ENTITY",
        "typing_extensions.Literal"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "generate_operation_id_for_path",
          "body": "def generate_operation_id_for_path(*, name: str, path: str, method: str) -> str:\n    warnings.warn('fastapi.utils.generate_operation_id_for_path() was deprecated, it is not used internally, and will be removed soon', DeprecationWarning, stacklevel=2)\n    operation_id = f'{name}{path}'\n    operation_id = re.sub('\\\\W', '_', operation_id)\n    operation_id = f'{operation_id}_{method.lower()}'\n    return operation_id"
        }
      ]
    },
    {
      "name": "generate_operation_summary",
      "module": "utils",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\openapi\\utils.py",
      "line_number": 201,
      "end_line_number": 204,
      "source_code": "def generate_operation_summary(*, route: routing.APIRoute, method: str) -> str:\n    if route.summary:\n        return route.summary\n    return route.name.replace(\"_\", \" \").title()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "http.client",
        "inspect",
        "warnings",
        "typing.Any",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "typing.cast",
        "fastapi.routing",
        "fastapi._compat.GenerateJsonSchema",
        "fastapi._compat.JsonSchemaValue",
        "fastapi._compat.ModelField",
        "fastapi._compat.Undefined",
        "fastapi._compat.get_compat_model_name_map",
        "fastapi._compat.get_definitions",
        "fastapi._compat.get_schema_from_model_field",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.utils._get_flat_fields_from_params",
        "fastapi.dependencies.utils.get_flat_dependant",
        "fastapi.dependencies.utils.get_flat_params",
        "fastapi.encoders.jsonable_encoder",
        "fastapi.openapi.constants.METHODS_WITH_BODY",
        "fastapi.openapi.constants.REF_PREFIX",
        "fastapi.openapi.constants.REF_TEMPLATE",
        "fastapi.openapi.models.OpenAPI",
        "fastapi.params.Body",
        "fastapi.params.ParamTypes",
        "fastapi.responses.Response",
        "fastapi.types.ModelNameMap",
        "fastapi.utils.deep_dict_update",
        "fastapi.utils.generate_operation_id_for_path",
        "fastapi.utils.is_body_allowed_for_status_code",
        "starlette.responses.JSONResponse",
        "starlette.routing.BaseRoute",
        "starlette.status.HTTP_422_UNPROCESSABLE_ENTITY",
        "typing_extensions.Literal"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "get_openapi_operation_metadata",
      "module": "utils",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\openapi\\utils.py",
      "line_number": 207,
      "end_line_number": 230,
      "source_code": "def get_openapi_operation_metadata(\n    *, route: routing.APIRoute, method: str, operation_ids: Set[str]\n) -> Dict[str, Any]:\n    operation: Dict[str, Any] = {}\n    if route.tags:\n        operation[\"tags\"] = route.tags\n    operation[\"summary\"] = generate_operation_summary(route=route, method=method)\n    if route.description:\n        operation[\"description\"] = route.description\n    operation_id = route.operation_id or route.unique_id\n    if operation_id in operation_ids:\n        message = (\n            f\"Duplicate Operation ID {operation_id} for function \"\n            + f\"{route.endpoint.__name__}\"\n        )\n        file_name = getattr(route.endpoint, \"__globals__\", {}).get(\"__file__\")\n        if file_name:\n            message += f\" at {file_name}\"\n        warnings.warn(message, stacklevel=1)\n    operation_ids.add(operation_id)\n    operation[\"operationId\"] = operation_id\n    if route.deprecated:\n        operation[\"deprecated\"] = route.deprecated\n    return operation",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "http.client",
        "inspect",
        "warnings",
        "typing.Any",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "typing.cast",
        "fastapi.routing",
        "fastapi._compat.GenerateJsonSchema",
        "fastapi._compat.JsonSchemaValue",
        "fastapi._compat.ModelField",
        "fastapi._compat.Undefined",
        "fastapi._compat.get_compat_model_name_map",
        "fastapi._compat.get_definitions",
        "fastapi._compat.get_schema_from_model_field",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.utils._get_flat_fields_from_params",
        "fastapi.dependencies.utils.get_flat_dependant",
        "fastapi.dependencies.utils.get_flat_params",
        "fastapi.encoders.jsonable_encoder",
        "fastapi.openapi.constants.METHODS_WITH_BODY",
        "fastapi.openapi.constants.REF_PREFIX",
        "fastapi.openapi.constants.REF_TEMPLATE",
        "fastapi.openapi.models.OpenAPI",
        "fastapi.params.Body",
        "fastapi.params.ParamTypes",
        "fastapi.responses.Response",
        "fastapi.types.ModelNameMap",
        "fastapi.utils.deep_dict_update",
        "fastapi.utils.generate_operation_id_for_path",
        "fastapi.utils.is_body_allowed_for_status_code",
        "starlette.responses.JSONResponse",
        "starlette.routing.BaseRoute",
        "starlette.status.HTTP_422_UNPROCESSABLE_ENTITY",
        "typing_extensions.Literal"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "generate_operation_summary",
          "body": "def generate_operation_summary(*, route: routing.APIRoute, method: str) -> str:\n    if route.summary:\n        return route.summary\n    return route.name.replace('_', ' ').title()"
        }
      ]
    },
    {
      "name": "get_openapi_path",
      "module": "utils",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\openapi\\utils.py",
      "line_number": 233,
      "end_line_number": 422,
      "source_code": "def get_openapi_path(\n    *,\n    route: routing.APIRoute,\n    operation_ids: Set[str],\n    schema_generator: GenerateJsonSchema,\n    model_name_map: ModelNameMap,\n    field_mapping: Dict[\n        Tuple[ModelField, Literal[\"validation\", \"serialization\"]], JsonSchemaValue\n    ],\n    separate_input_output_schemas: bool = True,\n) -> Tuple[Dict[str, Any], Dict[str, Any], Dict[str, Any]]:\n    path = {}\n    security_schemes: Dict[str, Any] = {}\n    definitions: Dict[str, Any] = {}\n    assert route.methods is not None, \"Methods must be a list\"\n    if isinstance(route.response_class, DefaultPlaceholder):\n        current_response_class: Type[Response] = route.response_class.value\n    else:\n        current_response_class = route.response_class\n    assert current_response_class, \"A response class is needed to generate OpenAPI\"\n    route_response_media_type: Optional[str] = current_response_class.media_type\n    if route.include_in_schema:\n        for method in route.methods:\n            operation = get_openapi_operation_metadata(\n                route=route, method=method, operation_ids=operation_ids\n            )\n            parameters: List[Dict[str, Any]] = []\n            flat_dependant = get_flat_dependant(route.dependant, skip_repeats=True)\n            security_definitions, operation_security = get_openapi_security_definitions(\n                flat_dependant=flat_dependant\n            )\n            if operation_security:\n                operation.setdefault(\"security\", []).extend(operation_security)\n            if security_definitions:\n                security_schemes.update(security_definitions)\n            operation_parameters = _get_openapi_operation_parameters(\n                dependant=route.dependant,\n                schema_generator=schema_generator,\n                model_name_map=model_name_map,\n                field_mapping=field_mapping,\n                separate_input_output_schemas=separate_input_output_schemas,\n            )\n            parameters.extend(operation_parameters)\n            if parameters:\n                all_parameters = {\n                    (param[\"in\"], param[\"name\"]): param for param in parameters\n                }\n                required_parameters = {\n                    (param[\"in\"], param[\"name\"]): param\n                    for param in parameters\n                    if param.get(\"required\")\n                }\n                # Make sure required definitions of the same parameter take precedence\n                # over non-required definitions\n                all_parameters.update(required_parameters)\n                operation[\"parameters\"] = list(all_parameters.values())\n            if method in METHODS_WITH_BODY:\n                request_body_oai = get_openapi_operation_request_body(\n                    body_field=route.body_field,\n                    schema_generator=schema_generator,\n                    model_name_map=model_name_map,\n                    field_mapping=field_mapping,\n                    separate_input_output_schemas=separate_input_output_schemas,\n                )\n                if request_body_oai:\n                    operation[\"requestBody\"] = request_body_oai\n            if route.callbacks:\n                callbacks = {}\n                for callback in route.callbacks:\n                    if isinstance(callback, routing.APIRoute):\n                        (\n                            cb_path,\n                            cb_security_schemes,\n                            cb_definitions,\n                        ) = get_openapi_path(\n                            route=callback,\n                            operation_ids=operation_ids,\n                            schema_generator=schema_generator,\n                            model_name_map=model_name_map,\n                            field_mapping=field_mapping,\n                            separate_input_output_schemas=separate_input_output_schemas,\n                        )\n                        callbacks[callback.name] = {callback.path: cb_path}\n                operation[\"callbacks\"] = callbacks\n            if route.status_code is not None:\n                status_code = str(route.status_code)\n            else:\n                # It would probably make more sense for all response classes to have an\n                # explicit default status_code, and to extract it from them, instead of\n                # doing this inspection tricks, that would probably be in the future\n                # TODO: probably make status_code a default class attribute for all\n                # responses in Starlette\n                response_signature = inspect.signature(current_response_class.__init__)\n                status_code_param = response_signature.parameters.get(\"status_code\")\n                if status_code_param is not None:\n                    if isinstance(status_code_param.default, int):\n                        status_code = str(status_code_param.default)\n            operation.setdefault(\"responses\", {}).setdefault(status_code, {})[\n                \"description\"\n            ] = route.response_description\n            if route_response_media_type and is_body_allowed_for_status_code(\n                route.status_code\n            ):\n                response_schema = {\"type\": \"string\"}\n                if lenient_issubclass(current_response_class, JSONResponse):\n                    if route.response_field:\n                        response_schema = get_schema_from_model_field(\n                            field=route.response_field,\n                            schema_generator=schema_generator,\n                            model_name_map=model_name_map,\n                            field_mapping=field_mapping,\n                            separate_input_output_schemas=separate_input_output_schemas,\n                        )\n                    else:\n                        response_schema = {}\n                operation.setdefault(\"responses\", {}).setdefault(\n                    status_code, {}\n                ).setdefault(\"content\", {}).setdefault(route_response_media_type, {})[\n                    \"schema\"\n                ] = response_schema\n            if route.responses:\n                operation_responses = operation.setdefault(\"responses\", {})\n                for (\n                    additional_status_code,\n                    additional_response,\n                ) in route.responses.items():\n                    process_response = additional_response.copy()\n                    process_response.pop(\"model\", None)\n                    status_code_key = str(additional_status_code).upper()\n                    if status_code_key == \"DEFAULT\":\n                        status_code_key = \"default\"\n                    openapi_response = operation_responses.setdefault(\n                        status_code_key, {}\n                    )\n                    assert isinstance(\n                        process_response, dict\n                    ), \"An additional response must be a dict\"\n                    field = route.response_fields.get(additional_status_code)\n                    additional_field_schema: Optional[Dict[str, Any]] = None\n                    if field:\n                        additional_field_schema = get_schema_from_model_field(\n                            field=field,\n                            schema_generator=schema_generator,\n                            model_name_map=model_name_map,\n                            field_mapping=field_mapping,\n                            separate_input_output_schemas=separate_input_output_schemas,\n                        )\n                        media_type = route_response_media_type or \"application/json\"\n                        additional_schema = (\n                            process_response.setdefault(\"content\", {})\n                            .setdefault(media_type, {})\n                            .setdefault(\"schema\", {})\n                        )\n                        deep_dict_update(additional_schema, additional_field_schema)\n                    status_text: Optional[str] = status_code_ranges.get(\n                        str(additional_status_code).upper()\n                    ) or http.client.responses.get(int(additional_status_code))\n                    description = (\n                        process_response.get(\"description\")\n                        or openapi_response.get(\"description\")\n                        or status_text\n                        or \"Additional Response\"\n                    )\n                    deep_dict_update(openapi_response, process_response)\n                    openapi_response[\"description\"] = description\n            http422 = str(HTTP_422_UNPROCESSABLE_ENTITY)\n            all_route_params = get_flat_params(route.dependant)\n            if (all_route_params or route.body_field) and not any(\n                status in operation[\"responses\"]\n                for status in [http422, \"4XX\", \"default\"]\n            ):\n                operation[\"responses\"][http422] = {\n                    \"description\": \"Validation Error\",\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\"$ref\": REF_PREFIX + \"HTTPValidationError\"}\n                        }\n                    },\n                }\n                if \"ValidationError\" not in definitions:\n                    definitions.update(\n                        {\n                            \"ValidationError\": validation_error_definition,\n                            \"HTTPValidationError\": validation_error_response_definition,\n                        }\n                    )\n            if route.openapi_extra:\n                deep_dict_update(operation, route.openapi_extra)\n            path[method.lower()] = operation\n    return path, security_schemes, definitions",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "http.client",
        "inspect",
        "warnings",
        "typing.Any",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "typing.cast",
        "fastapi.routing",
        "fastapi._compat.GenerateJsonSchema",
        "fastapi._compat.JsonSchemaValue",
        "fastapi._compat.ModelField",
        "fastapi._compat.Undefined",
        "fastapi._compat.get_compat_model_name_map",
        "fastapi._compat.get_definitions",
        "fastapi._compat.get_schema_from_model_field",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.utils._get_flat_fields_from_params",
        "fastapi.dependencies.utils.get_flat_dependant",
        "fastapi.dependencies.utils.get_flat_params",
        "fastapi.encoders.jsonable_encoder",
        "fastapi.openapi.constants.METHODS_WITH_BODY",
        "fastapi.openapi.constants.REF_PREFIX",
        "fastapi.openapi.constants.REF_TEMPLATE",
        "fastapi.openapi.models.OpenAPI",
        "fastapi.params.Body",
        "fastapi.params.ParamTypes",
        "fastapi.responses.Response",
        "fastapi.types.ModelNameMap",
        "fastapi.utils.deep_dict_update",
        "fastapi.utils.generate_operation_id_for_path",
        "fastapi.utils.is_body_allowed_for_status_code",
        "starlette.responses.JSONResponse",
        "starlette.routing.BaseRoute",
        "starlette.status.HTTP_422_UNPROCESSABLE_ENTITY",
        "typing_extensions.Literal"
      ],
      "fixtures": [],
      "assertions": [
        "assert route.methods is not None, 'Methods must be a list'",
        "assert current_response_class, 'A response class is needed to generate OpenAPI'",
        "assert isinstance(process_response, dict), 'An additional response must be a dict'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_openapi_operation_metadata",
          "body": "def get_openapi_operation_metadata(*, route: routing.APIRoute, method: str, operation_ids: Set[str]) -> Dict[str, Any]:\n    operation: Dict[str, Any] = {}\n    if route.tags:\n        operation['tags'] = route.tags\n    operation['summary'] = generate_operation_summary(route=route, method=method)\n    if route.description:\n        operation['description'] = route.description\n    operation_id = route.operation_id or route.unique_id\n    if operation_id in operation_ids:\n        message = f'Duplicate Operation ID {operation_id} for function ' + f'{route.endpoint.__name__}'\n        file_name = getattr(route.endpoint, '__globals__', {}).get('__file__')\n        if file_name:\n            message += f' at {file_name}'\n        warnings.warn(message, stacklevel=1)\n    operation_ids.add(operation_id)\n    operation['operationId'] = operation_id\n    if route.deprecated:\n        operation['deprecated'] = route.deprecated\n    return operation"
        },
        {
          "name": "get_flat_dependant",
          "body": "def get_flat_dependant(dependant: Dependant, *, skip_repeats: bool=False, visited: Optional[List[CacheKey]]=None) -> Dependant:\n    if visited is None:\n        visited = []\n    visited.append(dependant.cache_key)\n    flat_dependant = Dependant(path_params=dependant.path_params.copy(), query_params=dependant.query_params.copy(), header_params=dependant.header_params.copy(), cookie_params=dependant.cookie_params.copy(), body_params=dependant.body_params.copy(), security_requirements=dependant.security_requirements.copy(), use_cache=dependant.use_cache, path=dependant.path)\n    for sub_dependant in dependant.dependencies:\n        if skip_repeats and sub_dependant.cache_key in visited:\n            continue\n        flat_sub = get_flat_dependant(sub_dependant, skip_repeats=skip_repeats, visited=visited)\n        flat_dependant.path_params.extend(flat_sub.path_params)\n        flat_dependant.query_params.extend(flat_sub.query_params)\n        flat_dependant.header_params.extend(flat_sub.header_params)\n        flat_dependant.cookie_params.extend(flat_sub.cookie_params)\n        flat_dependant.body_params.extend(flat_sub.body_params)\n        flat_dependant.security_requirements.extend(flat_sub.security_requirements)\n    return flat_dependant"
        },
        {
          "name": "get_openapi_security_definitions",
          "body": "def get_openapi_security_definitions(flat_dependant: Dependant) -> Tuple[Dict[str, Any], List[Dict[str, Any]]]:\n    security_definitions = {}\n    operation_security = []\n    for security_requirement in flat_dependant.security_requirements:\n        security_definition = jsonable_encoder(security_requirement.security_scheme.model, by_alias=True, exclude_none=True)\n        security_name = security_requirement.security_scheme.scheme_name\n        security_definitions[security_name] = security_definition\n        operation_security.append({security_name: security_requirement.scopes})\n    return (security_definitions, operation_security)"
        },
        {
          "name": "_get_openapi_operation_parameters",
          "body": "def _get_openapi_operation_parameters(*, dependant: Dependant, schema_generator: GenerateJsonSchema, model_name_map: ModelNameMap, field_mapping: Dict[Tuple[ModelField, Literal['validation', 'serialization']], JsonSchemaValue], separate_input_output_schemas: bool=True) -> List[Dict[str, Any]]:\n    parameters = []\n    flat_dependant = get_flat_dependant(dependant, skip_repeats=True)\n    path_params = _get_flat_fields_from_params(flat_dependant.path_params)\n    query_params = _get_flat_fields_from_params(flat_dependant.query_params)\n    header_params = _get_flat_fields_from_params(flat_dependant.header_params)\n    cookie_params = _get_flat_fields_from_params(flat_dependant.cookie_params)\n    parameter_groups = [(ParamTypes.path, path_params), (ParamTypes.query, query_params), (ParamTypes.header, header_params), (ParamTypes.cookie, cookie_params)]\n    for param_type, param_group in parameter_groups:\n        for param in param_group:\n            field_info = param.field_info\n            if not getattr(field_info, 'include_in_schema', True):\n                continue\n            param_schema = get_schema_from_model_field(field=param, schema_generator=schema_generator, model_name_map=model_name_map, field_mapping=field_mapping, separate_input_output_schemas=separate_input_output_schemas)\n            parameter = {'name': param.alias, 'in': param_type.value, 'required': param.required, 'schema': param_schema}\n            if field_info.description:\n                parameter['description'] = field_info.description\n            openapi_examples = getattr(field_info, 'openapi_examples', None)\n            example = getattr(field_info, 'example', None)\n            if openapi_examples:\n                parameter['examples'] = jsonable_encoder(openapi_examples)\n            elif example != Undefined:\n                parameter['example'] = jsonable_encoder(example)\n            if getattr(field_info, 'deprecated', None):\n                parameter['deprecated'] = True\n            parameters.append(parameter)\n    return parameters"
        },
        {
          "name": "get_flat_params",
          "body": "def get_flat_params(dependant: Dependant) -> List[ModelField]:\n    flat_dependant = get_flat_dependant(dependant, skip_repeats=True)\n    path_params = _get_flat_fields_from_params(flat_dependant.path_params)\n    query_params = _get_flat_fields_from_params(flat_dependant.query_params)\n    header_params = _get_flat_fields_from_params(flat_dependant.header_params)\n    cookie_params = _get_flat_fields_from_params(flat_dependant.cookie_params)\n    return path_params + query_params + header_params + cookie_params"
        },
        {
          "name": "get_openapi_operation_request_body",
          "body": "def get_openapi_operation_request_body(*, body_field: Optional[ModelField], schema_generator: GenerateJsonSchema, model_name_map: ModelNameMap, field_mapping: Dict[Tuple[ModelField, Literal['validation', 'serialization']], JsonSchemaValue], separate_input_output_schemas: bool=True) -> Optional[Dict[str, Any]]:\n    if not body_field:\n        return None\n    assert isinstance(body_field, ModelField)\n    body_schema = get_schema_from_model_field(field=body_field, schema_generator=schema_generator, model_name_map=model_name_map, field_mapping=field_mapping, separate_input_output_schemas=separate_input_output_schemas)\n    field_info = cast(Body, body_field.field_info)\n    request_media_type = field_info.media_type\n    required = body_field.required\n    request_body_oai: Dict[str, Any] = {}\n    if required:\n        request_body_oai['required'] = required\n    request_media_content: Dict[str, Any] = {'schema': body_schema}\n    if field_info.openapi_examples:\n        request_media_content['examples'] = jsonable_encoder(field_info.openapi_examples)\n    elif field_info.example != Undefined:\n        request_media_content['example'] = jsonable_encoder(field_info.example)\n    request_body_oai['content'] = {request_media_type: request_media_content}\n    return request_body_oai"
        },
        {
          "name": "response_signature.parameters.get",
          "body": "def get(self, path: Annotated[str, Doc('\\n                The URL path to be used for this *path operation*.\\n\\n                For example, in `http://example.com/items`, the path is `/items`.\\n                ')], *, response_model: Annotated[Any, Doc(\"\\n                The type to use for the response.\\n\\n                It could be any valid Pydantic *field* type. So, it doesn't have to\\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\\n                etc.\\n\\n                It will be used for:\\n\\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\\n                    show it as the response (JSON Schema).\\n                * Serialization: you could return an arbitrary object and the\\n                    `response_model` would be used to serialize that object into the\\n                    corresponding JSON.\\n                * Filtering: the JSON sent to the client will only contain the data\\n                    (fields) defined in the `response_model`. If you returned an object\\n                    that contains an attribute `password` but the `response_model` does\\n                    not include that field, the JSON sent to the client would not have\\n                    that `password`.\\n                * Validation: whatever you return will be serialized with the\\n                    `response_model`, converting any data as necessary to generate the\\n                    corresponding JSON. But if the data in the object returned is not\\n                    valid, that would mean a violation of the contract with the client,\\n                    so it's an error from the API developer. So, FastAPI will raise an\\n                    error and return a 500 error code (Internal Server Error).\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\\n                \")]=Default(None), status_code: Annotated[Optional[int], Doc('\\n                The default status code to be used for the response.\\n\\n                You could override the status code by returning a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\\n                ')]=None, tags: Annotated[Optional[List[Union[str, Enum]]], Doc('\\n                A list of tags to be applied to the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\\n                ')]=None, dependencies: Annotated[Optional[Sequence[Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to the\\n                *path operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\\n                ')]=None, summary: Annotated[Optional[str], Doc('\\n                A summary for the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, description: Annotated[Optional[str], Doc('\\n                A description for the *path operation*.\\n\\n                If not provided, it will be extracted automatically from the docstring\\n                of the *path operation function*.\\n\\n                It can contain Markdown.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, response_description: Annotated[str, Doc('\\n                The description for the default response.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]='Successful Response', responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses that could be returned by this *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark this *path operation* as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, operation_id: Annotated[Optional[str], Doc('\\n                Custom operation ID to be used by this *path operation*.\\n\\n                By default, it is generated automatically.\\n\\n                If you provide a custom operation ID, you need to make sure it is\\n                unique for the whole API.\\n\\n                You can customize the\\n                operation ID generation with the parameter\\n                `generate_unique_id_function` in the `FastAPI` class.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=None, response_model_include: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to include only certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_exclude: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to exclude certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_by_alias: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response model\\n                should be serialized by alias when an alias is used.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=True, response_model_exclude_unset: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that were not set and\\n                have their default values. This is different from\\n                `response_model_exclude_defaults` in that if the fields are set,\\n                they will be included in the response, even if the value is the same\\n                as the default.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_defaults: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that have the same value\\n                as the default. This is different from `response_model_exclude_unset`\\n                in that if the fields are set but contain the same default values,\\n                they will be excluded from the response.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_none: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data should\\n                exclude fields set to `None`.\\n\\n                This is much simpler (less smart) than `response_model_exclude_unset`\\n                and `response_model_exclude_defaults`. You probably want to use one of\\n                those two instead of this one, as those allow returning `None` values\\n                when it makes sense.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\\n                ')]=False, include_in_schema: Annotated[bool, Doc('\\n                Include this *path operation* in the generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\\n                ')]=True, response_class: Annotated[Type[Response], Doc('\\n                Response class to be used for this *path operation*.\\n\\n                This will not be used if you return a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\\n                ')]=Default(JSONResponse), name: Annotated[Optional[str], Doc('\\n                Name for this *path operation*. Only used internally.\\n                ')]=None, callbacks: Annotated[Optional[List[BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")]=None, openapi_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n                Extra metadata to be included in the OpenAPI schema for this *path\\n                operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\\n                ')]=None, generate_unique_id_function: Annotated[Callable[[routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=Default(generate_unique_id)) -> Callable[[DecoratedCallable], DecoratedCallable]:\n    \"\"\"\n        Add a *path operation* using an HTTP GET operation.\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI\n\n        app = FastAPI()\n\n        @app.get(\"/items/\")\n        def read_items():\n            return [{\"name\": \"Empanada\"}, {\"name\": \"Arepa\"}]\n        ```\n        \"\"\"\n    return self.router.get(path, response_model=response_model, status_code=status_code, tags=tags, dependencies=dependencies, summary=summary, description=description, response_description=response_description, responses=responses, deprecated=deprecated, operation_id=operation_id, response_model_include=response_model_include, response_model_exclude=response_model_exclude, response_model_by_alias=response_model_by_alias, response_model_exclude_unset=response_model_exclude_unset, response_model_exclude_defaults=response_model_exclude_defaults, response_model_exclude_none=response_model_exclude_none, include_in_schema=include_in_schema, response_class=response_class, name=name, callbacks=callbacks, openapi_extra=openapi_extra, generate_unique_id_function=generate_unique_id_function)"
        },
        {
          "name": "is_body_allowed_for_status_code",
          "body": "def is_body_allowed_for_status_code(status_code: Union[int, str, None]) -> bool:\n    if status_code is None:\n        return True\n    if status_code in {'default', '1XX', '2XX', '3XX', '4XX', '5XX'}:\n        return True\n    current_status_code = int(status_code)\n    return not (current_status_code < 200 or current_status_code in {204, 205, 304})"
        },
        {
          "name": "deep_dict_update",
          "body": "def deep_dict_update(main_dict: Dict[Any, Any], update_dict: Dict[Any, Any]) -> None:\n    for key, value in update_dict.items():\n        if key in main_dict and isinstance(main_dict[key], dict) and isinstance(value, dict):\n            deep_dict_update(main_dict[key], value)\n        elif key in main_dict and isinstance(main_dict[key], list) and isinstance(update_dict[key], list):\n            main_dict[key] = main_dict[key] + update_dict[key]\n        else:\n            main_dict[key] = value"
        },
        {
          "name": "route.response_fields.get",
          "body": "def get(self, path: Annotated[str, Doc('\\n                The URL path to be used for this *path operation*.\\n\\n                For example, in `http://example.com/items`, the path is `/items`.\\n                ')], *, response_model: Annotated[Any, Doc(\"\\n                The type to use for the response.\\n\\n                It could be any valid Pydantic *field* type. So, it doesn't have to\\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\\n                etc.\\n\\n                It will be used for:\\n\\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\\n                    show it as the response (JSON Schema).\\n                * Serialization: you could return an arbitrary object and the\\n                    `response_model` would be used to serialize that object into the\\n                    corresponding JSON.\\n                * Filtering: the JSON sent to the client will only contain the data\\n                    (fields) defined in the `response_model`. If you returned an object\\n                    that contains an attribute `password` but the `response_model` does\\n                    not include that field, the JSON sent to the client would not have\\n                    that `password`.\\n                * Validation: whatever you return will be serialized with the\\n                    `response_model`, converting any data as necessary to generate the\\n                    corresponding JSON. But if the data in the object returned is not\\n                    valid, that would mean a violation of the contract with the client,\\n                    so it's an error from the API developer. So, FastAPI will raise an\\n                    error and return a 500 error code (Internal Server Error).\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\\n                \")]=Default(None), status_code: Annotated[Optional[int], Doc('\\n                The default status code to be used for the response.\\n\\n                You could override the status code by returning a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\\n                ')]=None, tags: Annotated[Optional[List[Union[str, Enum]]], Doc('\\n                A list of tags to be applied to the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\\n                ')]=None, dependencies: Annotated[Optional[Sequence[Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to the\\n                *path operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\\n                ')]=None, summary: Annotated[Optional[str], Doc('\\n                A summary for the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, description: Annotated[Optional[str], Doc('\\n                A description for the *path operation*.\\n\\n                If not provided, it will be extracted automatically from the docstring\\n                of the *path operation function*.\\n\\n                It can contain Markdown.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, response_description: Annotated[str, Doc('\\n                The description for the default response.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]='Successful Response', responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses that could be returned by this *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark this *path operation* as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, operation_id: Annotated[Optional[str], Doc('\\n                Custom operation ID to be used by this *path operation*.\\n\\n                By default, it is generated automatically.\\n\\n                If you provide a custom operation ID, you need to make sure it is\\n                unique for the whole API.\\n\\n                You can customize the\\n                operation ID generation with the parameter\\n                `generate_unique_id_function` in the `FastAPI` class.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=None, response_model_include: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to include only certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_exclude: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to exclude certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_by_alias: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response model\\n                should be serialized by alias when an alias is used.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=True, response_model_exclude_unset: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that were not set and\\n                have their default values. This is different from\\n                `response_model_exclude_defaults` in that if the fields are set,\\n                they will be included in the response, even if the value is the same\\n                as the default.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_defaults: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that have the same value\\n                as the default. This is different from `response_model_exclude_unset`\\n                in that if the fields are set but contain the same default values,\\n                they will be excluded from the response.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_none: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data should\\n                exclude fields set to `None`.\\n\\n                This is much simpler (less smart) than `response_model_exclude_unset`\\n                and `response_model_exclude_defaults`. You probably want to use one of\\n                those two instead of this one, as those allow returning `None` values\\n                when it makes sense.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\\n                ')]=False, include_in_schema: Annotated[bool, Doc('\\n                Include this *path operation* in the generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\\n                ')]=True, response_class: Annotated[Type[Response], Doc('\\n                Response class to be used for this *path operation*.\\n\\n                This will not be used if you return a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\\n                ')]=Default(JSONResponse), name: Annotated[Optional[str], Doc('\\n                Name for this *path operation*. Only used internally.\\n                ')]=None, callbacks: Annotated[Optional[List[BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")]=None, openapi_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n                Extra metadata to be included in the OpenAPI schema for this *path\\n                operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\\n                ')]=None, generate_unique_id_function: Annotated[Callable[[routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=Default(generate_unique_id)) -> Callable[[DecoratedCallable], DecoratedCallable]:\n    \"\"\"\n        Add a *path operation* using an HTTP GET operation.\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI\n\n        app = FastAPI()\n\n        @app.get(\"/items/\")\n        def read_items():\n            return [{\"name\": \"Empanada\"}, {\"name\": \"Arepa\"}]\n        ```\n        \"\"\"\n    return self.router.get(path, response_model=response_model, status_code=status_code, tags=tags, dependencies=dependencies, summary=summary, description=description, response_description=response_description, responses=responses, deprecated=deprecated, operation_id=operation_id, response_model_include=response_model_include, response_model_exclude=response_model_exclude, response_model_by_alias=response_model_by_alias, response_model_exclude_unset=response_model_exclude_unset, response_model_exclude_defaults=response_model_exclude_defaults, response_model_exclude_none=response_model_exclude_none, include_in_schema=include_in_schema, response_class=response_class, name=name, callbacks=callbacks, openapi_extra=openapi_extra, generate_unique_id_function=generate_unique_id_function)"
        },
        {
          "name": "deep_dict_update",
          "body": "def deep_dict_update(main_dict: Dict[Any, Any], update_dict: Dict[Any, Any]) -> None:\n    for key, value in update_dict.items():\n        if key in main_dict and isinstance(main_dict[key], dict) and isinstance(value, dict):\n            deep_dict_update(main_dict[key], value)\n        elif key in main_dict and isinstance(main_dict[key], list) and isinstance(update_dict[key], list):\n            main_dict[key] = main_dict[key] + update_dict[key]\n        else:\n            main_dict[key] = value"
        },
        {
          "name": "param.get",
          "body": "def get(self, path: Annotated[str, Doc('\\n                The URL path to be used for this *path operation*.\\n\\n                For example, in `http://example.com/items`, the path is `/items`.\\n                ')], *, response_model: Annotated[Any, Doc(\"\\n                The type to use for the response.\\n\\n                It could be any valid Pydantic *field* type. So, it doesn't have to\\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\\n                etc.\\n\\n                It will be used for:\\n\\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\\n                    show it as the response (JSON Schema).\\n                * Serialization: you could return an arbitrary object and the\\n                    `response_model` would be used to serialize that object into the\\n                    corresponding JSON.\\n                * Filtering: the JSON sent to the client will only contain the data\\n                    (fields) defined in the `response_model`. If you returned an object\\n                    that contains an attribute `password` but the `response_model` does\\n                    not include that field, the JSON sent to the client would not have\\n                    that `password`.\\n                * Validation: whatever you return will be serialized with the\\n                    `response_model`, converting any data as necessary to generate the\\n                    corresponding JSON. But if the data in the object returned is not\\n                    valid, that would mean a violation of the contract with the client,\\n                    so it's an error from the API developer. So, FastAPI will raise an\\n                    error and return a 500 error code (Internal Server Error).\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\\n                \")]=Default(None), status_code: Annotated[Optional[int], Doc('\\n                The default status code to be used for the response.\\n\\n                You could override the status code by returning a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\\n                ')]=None, tags: Annotated[Optional[List[Union[str, Enum]]], Doc('\\n                A list of tags to be applied to the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\\n                ')]=None, dependencies: Annotated[Optional[Sequence[Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to the\\n                *path operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\\n                ')]=None, summary: Annotated[Optional[str], Doc('\\n                A summary for the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, description: Annotated[Optional[str], Doc('\\n                A description for the *path operation*.\\n\\n                If not provided, it will be extracted automatically from the docstring\\n                of the *path operation function*.\\n\\n                It can contain Markdown.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, response_description: Annotated[str, Doc('\\n                The description for the default response.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]='Successful Response', responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses that could be returned by this *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark this *path operation* as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, operation_id: Annotated[Optional[str], Doc('\\n                Custom operation ID to be used by this *path operation*.\\n\\n                By default, it is generated automatically.\\n\\n                If you provide a custom operation ID, you need to make sure it is\\n                unique for the whole API.\\n\\n                You can customize the\\n                operation ID generation with the parameter\\n                `generate_unique_id_function` in the `FastAPI` class.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=None, response_model_include: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to include only certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_exclude: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to exclude certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_by_alias: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response model\\n                should be serialized by alias when an alias is used.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=True, response_model_exclude_unset: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that were not set and\\n                have their default values. This is different from\\n                `response_model_exclude_defaults` in that if the fields are set,\\n                they will be included in the response, even if the value is the same\\n                as the default.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_defaults: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that have the same value\\n                as the default. This is different from `response_model_exclude_unset`\\n                in that if the fields are set but contain the same default values,\\n                they will be excluded from the response.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_none: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data should\\n                exclude fields set to `None`.\\n\\n                This is much simpler (less smart) than `response_model_exclude_unset`\\n                and `response_model_exclude_defaults`. You probably want to use one of\\n                those two instead of this one, as those allow returning `None` values\\n                when it makes sense.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\\n                ')]=False, include_in_schema: Annotated[bool, Doc('\\n                Include this *path operation* in the generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\\n                ')]=True, response_class: Annotated[Type[Response], Doc('\\n                Response class to be used for this *path operation*.\\n\\n                This will not be used if you return a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\\n                ')]=Default(JSONResponse), name: Annotated[Optional[str], Doc('\\n                Name for this *path operation*. Only used internally.\\n                ')]=None, callbacks: Annotated[Optional[List[BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")]=None, openapi_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n                Extra metadata to be included in the OpenAPI schema for this *path\\n                operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\\n                ')]=None, generate_unique_id_function: Annotated[Callable[[routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=Default(generate_unique_id)) -> Callable[[DecoratedCallable], DecoratedCallable]:\n    \"\"\"\n        Add a *path operation* using an HTTP GET operation.\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI\n\n        app = FastAPI()\n\n        @app.get(\"/items/\")\n        def read_items():\n            return [{\"name\": \"Empanada\"}, {\"name\": \"Arepa\"}]\n        ```\n        \"\"\"\n    return self.router.get(path, response_model=response_model, status_code=status_code, tags=tags, dependencies=dependencies, summary=summary, description=description, response_description=response_description, responses=responses, deprecated=deprecated, operation_id=operation_id, response_model_include=response_model_include, response_model_exclude=response_model_exclude, response_model_by_alias=response_model_by_alias, response_model_exclude_unset=response_model_exclude_unset, response_model_exclude_defaults=response_model_exclude_defaults, response_model_exclude_none=response_model_exclude_none, include_in_schema=include_in_schema, response_class=response_class, name=name, callbacks=callbacks, openapi_extra=openapi_extra, generate_unique_id_function=generate_unique_id_function)"
        },
        {
          "name": "get_openapi_path",
          "body": "def get_openapi_path(*, route: routing.APIRoute, operation_ids: Set[str], schema_generator: GenerateJsonSchema, model_name_map: ModelNameMap, field_mapping: Dict[Tuple[ModelField, Literal['validation', 'serialization']], JsonSchemaValue], separate_input_output_schemas: bool=True) -> Tuple[Dict[str, Any], Dict[str, Any], Dict[str, Any]]:\n    path = {}\n    security_schemes: Dict[str, Any] = {}\n    definitions: Dict[str, Any] = {}\n    assert route.methods is not None, 'Methods must be a list'\n    if isinstance(route.response_class, DefaultPlaceholder):\n        current_response_class: Type[Response] = route.response_class.value\n    else:\n        current_response_class = route.response_class\n    assert current_response_class, 'A response class is needed to generate OpenAPI'\n    route_response_media_type: Optional[str] = current_response_class.media_type\n    if route.include_in_schema:\n        for method in route.methods:\n            operation = get_openapi_operation_metadata(route=route, method=method, operation_ids=operation_ids)\n            parameters: List[Dict[str, Any]] = []\n            flat_dependant = get_flat_dependant(route.dependant, skip_repeats=True)\n            security_definitions, operation_security = get_openapi_security_definitions(flat_dependant=flat_dependant)\n            if operation_security:\n                operation.setdefault('security', []).extend(operation_security)\n            if security_definitions:\n                security_schemes.update(security_definitions)\n            operation_parameters = _get_openapi_operation_parameters(dependant=route.dependant, schema_generator=schema_generator, model_name_map=model_name_map, field_mapping=field_mapping, separate_input_output_schemas=separate_input_output_schemas)\n            parameters.extend(operation_parameters)\n            if parameters:\n                all_parameters = {(param['in'], param['name']): param for param in parameters}\n                required_parameters = {(param['in'], param['name']): param for param in parameters if param.get('required')}\n                all_parameters.update(required_parameters)\n                operation['parameters'] = list(all_parameters.values())\n            if method in METHODS_WITH_BODY:\n                request_body_oai = get_openapi_operation_request_body(body_field=route.body_field, schema_generator=schema_generator, model_name_map=model_name_map, field_mapping=field_mapping, separate_input_output_schemas=separate_input_output_schemas)\n                if request_body_oai:\n                    operation['requestBody'] = request_body_oai\n            if route.callbacks:\n                callbacks = {}\n                for callback in route.callbacks:\n                    if isinstance(callback, routing.APIRoute):\n                        cb_path, cb_security_schemes, cb_definitions = get_openapi_path(route=callback, operation_ids=operation_ids, schema_generator=schema_generator, model_name_map=model_name_map, field_mapping=field_mapping, separate_input_output_schemas=separate_input_output_schemas)\n                        callbacks[callback.name] = {callback.path: cb_path}\n                operation['callbacks'] = callbacks\n            if route.status_code is not None:\n                status_code = str(route.status_code)\n            else:\n                response_signature = inspect.signature(current_response_class.__init__)\n                status_code_param = response_signature.parameters.get('status_code')\n                if status_code_param is not None:\n                    if isinstance(status_code_param.default, int):\n                        status_code = str(status_code_param.default)\n            operation.setdefault('responses', {}).setdefault(status_code, {})['description'] = route.response_description\n            if route_response_media_type and is_body_allowed_for_status_code(route.status_code):\n                response_schema = {'type': 'string'}\n                if lenient_issubclass(current_response_class, JSONResponse):\n                    if route.response_field:\n                        response_schema = get_schema_from_model_field(field=route.response_field, schema_generator=schema_generator, model_name_map=model_name_map, field_mapping=field_mapping, separate_input_output_schemas=separate_input_output_schemas)\n                    else:\n                        response_schema = {}\n                operation.setdefault('responses', {}).setdefault(status_code, {}).setdefault('content', {}).setdefault(route_response_media_type, {})['schema'] = response_schema\n            if route.responses:\n                operation_responses = operation.setdefault('responses', {})\n                for additional_status_code, additional_response in route.responses.items():\n                    process_response = additional_response.copy()\n                    process_response.pop('model', None)\n                    status_code_key = str(additional_status_code).upper()\n                    if status_code_key == 'DEFAULT':\n                        status_code_key = 'default'\n                    openapi_response = operation_responses.setdefault(status_code_key, {})\n                    assert isinstance(process_response, dict), 'An additional response must be a dict'\n                    field = route.response_fields.get(additional_status_code)\n                    additional_field_schema: Optional[Dict[str, Any]] = None\n                    if field:\n                        additional_field_schema = get_schema_from_model_field(field=field, schema_generator=schema_generator, model_name_map=model_name_map, field_mapping=field_mapping, separate_input_output_schemas=separate_input_output_schemas)\n                        media_type = route_response_media_type or 'application/json'\n                        additional_schema = process_response.setdefault('content', {}).setdefault(media_type, {}).setdefault('schema', {})\n                        deep_dict_update(additional_schema, additional_field_schema)\n                    status_text: Optional[str] = status_code_ranges.get(str(additional_status_code).upper()) or http.client.responses.get(int(additional_status_code))\n                    description = process_response.get('description') or openapi_response.get('description') or status_text or 'Additional Response'\n                    deep_dict_update(openapi_response, process_response)\n                    openapi_response['description'] = description\n            http422 = str(HTTP_422_UNPROCESSABLE_ENTITY)\n            all_route_params = get_flat_params(route.dependant)\n            if (all_route_params or route.body_field) and (not any((status in operation['responses'] for status in [http422, '4XX', 'default']))):\n                operation['responses'][http422] = {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': REF_PREFIX + 'HTTPValidationError'}}}}\n                if 'ValidationError' not in definitions:\n                    definitions.update({'ValidationError': validation_error_definition, 'HTTPValidationError': validation_error_response_definition})\n            if route.openapi_extra:\n                deep_dict_update(operation, route.openapi_extra)\n            path[method.lower()] = operation\n    return (path, security_schemes, definitions)"
        },
        {
          "name": "get_schema_from_model_field",
          "body": "def get_schema_from_model_field(*, field: ModelField, schema_generator: GenerateJsonSchema, model_name_map: ModelNameMap, field_mapping: Dict[Tuple[ModelField, Literal['validation', 'serialization']], JsonSchemaValue], separate_input_output_schemas: bool=True) -> Dict[str, Any]:\n    override_mode: Union[Literal['validation'], None] = None if separate_input_output_schemas else 'validation'\n    json_schema = field_mapping[field, override_mode or field.mode]\n    if '$ref' not in json_schema:\n        json_schema['title'] = field.field_info.title or field.alias.title().replace('_', ' ')\n    return json_schema"
        },
        {
          "name": "get_schema_from_model_field",
          "body": "def get_schema_from_model_field(*, field: ModelField, schema_generator: GenerateJsonSchema, model_name_map: ModelNameMap, field_mapping: Dict[Tuple[ModelField, Literal['validation', 'serialization']], JsonSchemaValue], separate_input_output_schemas: bool=True) -> Dict[str, Any]:\n    override_mode: Union[Literal['validation'], None] = None if separate_input_output_schemas else 'validation'\n    json_schema = field_mapping[field, override_mode or field.mode]\n    if '$ref' not in json_schema:\n        json_schema['title'] = field.field_info.title or field.alias.title().replace('_', ' ')\n    return json_schema"
        },
        {
          "name": "deep_dict_update",
          "body": "def deep_dict_update(main_dict: Dict[Any, Any], update_dict: Dict[Any, Any]) -> None:\n    for key, value in update_dict.items():\n        if key in main_dict and isinstance(main_dict[key], dict) and isinstance(value, dict):\n            deep_dict_update(main_dict[key], value)\n        elif key in main_dict and isinstance(main_dict[key], list) and isinstance(update_dict[key], list):\n            main_dict[key] = main_dict[key] + update_dict[key]\n        else:\n            main_dict[key] = value"
        },
        {
          "name": "status_code_ranges.get",
          "body": "def get(self, path: Annotated[str, Doc('\\n                The URL path to be used for this *path operation*.\\n\\n                For example, in `http://example.com/items`, the path is `/items`.\\n                ')], *, response_model: Annotated[Any, Doc(\"\\n                The type to use for the response.\\n\\n                It could be any valid Pydantic *field* type. So, it doesn't have to\\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\\n                etc.\\n\\n                It will be used for:\\n\\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\\n                    show it as the response (JSON Schema).\\n                * Serialization: you could return an arbitrary object and the\\n                    `response_model` would be used to serialize that object into the\\n                    corresponding JSON.\\n                * Filtering: the JSON sent to the client will only contain the data\\n                    (fields) defined in the `response_model`. If you returned an object\\n                    that contains an attribute `password` but the `response_model` does\\n                    not include that field, the JSON sent to the client would not have\\n                    that `password`.\\n                * Validation: whatever you return will be serialized with the\\n                    `response_model`, converting any data as necessary to generate the\\n                    corresponding JSON. But if the data in the object returned is not\\n                    valid, that would mean a violation of the contract with the client,\\n                    so it's an error from the API developer. So, FastAPI will raise an\\n                    error and return a 500 error code (Internal Server Error).\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\\n                \")]=Default(None), status_code: Annotated[Optional[int], Doc('\\n                The default status code to be used for the response.\\n\\n                You could override the status code by returning a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\\n                ')]=None, tags: Annotated[Optional[List[Union[str, Enum]]], Doc('\\n                A list of tags to be applied to the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\\n                ')]=None, dependencies: Annotated[Optional[Sequence[Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to the\\n                *path operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\\n                ')]=None, summary: Annotated[Optional[str], Doc('\\n                A summary for the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, description: Annotated[Optional[str], Doc('\\n                A description for the *path operation*.\\n\\n                If not provided, it will be extracted automatically from the docstring\\n                of the *path operation function*.\\n\\n                It can contain Markdown.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, response_description: Annotated[str, Doc('\\n                The description for the default response.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]='Successful Response', responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses that could be returned by this *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark this *path operation* as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, operation_id: Annotated[Optional[str], Doc('\\n                Custom operation ID to be used by this *path operation*.\\n\\n                By default, it is generated automatically.\\n\\n                If you provide a custom operation ID, you need to make sure it is\\n                unique for the whole API.\\n\\n                You can customize the\\n                operation ID generation with the parameter\\n                `generate_unique_id_function` in the `FastAPI` class.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=None, response_model_include: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to include only certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_exclude: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to exclude certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_by_alias: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response model\\n                should be serialized by alias when an alias is used.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=True, response_model_exclude_unset: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that were not set and\\n                have their default values. This is different from\\n                `response_model_exclude_defaults` in that if the fields are set,\\n                they will be included in the response, even if the value is the same\\n                as the default.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_defaults: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that have the same value\\n                as the default. This is different from `response_model_exclude_unset`\\n                in that if the fields are set but contain the same default values,\\n                they will be excluded from the response.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_none: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data should\\n                exclude fields set to `None`.\\n\\n                This is much simpler (less smart) than `response_model_exclude_unset`\\n                and `response_model_exclude_defaults`. You probably want to use one of\\n                those two instead of this one, as those allow returning `None` values\\n                when it makes sense.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\\n                ')]=False, include_in_schema: Annotated[bool, Doc('\\n                Include this *path operation* in the generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\\n                ')]=True, response_class: Annotated[Type[Response], Doc('\\n                Response class to be used for this *path operation*.\\n\\n                This will not be used if you return a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\\n                ')]=Default(JSONResponse), name: Annotated[Optional[str], Doc('\\n                Name for this *path operation*. Only used internally.\\n                ')]=None, callbacks: Annotated[Optional[List[BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")]=None, openapi_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n                Extra metadata to be included in the OpenAPI schema for this *path\\n                operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\\n                ')]=None, generate_unique_id_function: Annotated[Callable[[routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=Default(generate_unique_id)) -> Callable[[DecoratedCallable], DecoratedCallable]:\n    \"\"\"\n        Add a *path operation* using an HTTP GET operation.\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI\n\n        app = FastAPI()\n\n        @app.get(\"/items/\")\n        def read_items():\n            return [{\"name\": \"Empanada\"}, {\"name\": \"Arepa\"}]\n        ```\n        \"\"\"\n    return self.router.get(path, response_model=response_model, status_code=status_code, tags=tags, dependencies=dependencies, summary=summary, description=description, response_description=response_description, responses=responses, deprecated=deprecated, operation_id=operation_id, response_model_include=response_model_include, response_model_exclude=response_model_exclude, response_model_by_alias=response_model_by_alias, response_model_exclude_unset=response_model_exclude_unset, response_model_exclude_defaults=response_model_exclude_defaults, response_model_exclude_none=response_model_exclude_none, include_in_schema=include_in_schema, response_class=response_class, name=name, callbacks=callbacks, openapi_extra=openapi_extra, generate_unique_id_function=generate_unique_id_function)"
        },
        {
          "name": "process_response.get",
          "body": "def get(self, path: Annotated[str, Doc('\\n                The URL path to be used for this *path operation*.\\n\\n                For example, in `http://example.com/items`, the path is `/items`.\\n                ')], *, response_model: Annotated[Any, Doc(\"\\n                The type to use for the response.\\n\\n                It could be any valid Pydantic *field* type. So, it doesn't have to\\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\\n                etc.\\n\\n                It will be used for:\\n\\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\\n                    show it as the response (JSON Schema).\\n                * Serialization: you could return an arbitrary object and the\\n                    `response_model` would be used to serialize that object into the\\n                    corresponding JSON.\\n                * Filtering: the JSON sent to the client will only contain the data\\n                    (fields) defined in the `response_model`. If you returned an object\\n                    that contains an attribute `password` but the `response_model` does\\n                    not include that field, the JSON sent to the client would not have\\n                    that `password`.\\n                * Validation: whatever you return will be serialized with the\\n                    `response_model`, converting any data as necessary to generate the\\n                    corresponding JSON. But if the data in the object returned is not\\n                    valid, that would mean a violation of the contract with the client,\\n                    so it's an error from the API developer. So, FastAPI will raise an\\n                    error and return a 500 error code (Internal Server Error).\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\\n                \")]=Default(None), status_code: Annotated[Optional[int], Doc('\\n                The default status code to be used for the response.\\n\\n                You could override the status code by returning a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\\n                ')]=None, tags: Annotated[Optional[List[Union[str, Enum]]], Doc('\\n                A list of tags to be applied to the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\\n                ')]=None, dependencies: Annotated[Optional[Sequence[Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to the\\n                *path operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\\n                ')]=None, summary: Annotated[Optional[str], Doc('\\n                A summary for the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, description: Annotated[Optional[str], Doc('\\n                A description for the *path operation*.\\n\\n                If not provided, it will be extracted automatically from the docstring\\n                of the *path operation function*.\\n\\n                It can contain Markdown.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, response_description: Annotated[str, Doc('\\n                The description for the default response.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]='Successful Response', responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses that could be returned by this *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark this *path operation* as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, operation_id: Annotated[Optional[str], Doc('\\n                Custom operation ID to be used by this *path operation*.\\n\\n                By default, it is generated automatically.\\n\\n                If you provide a custom operation ID, you need to make sure it is\\n                unique for the whole API.\\n\\n                You can customize the\\n                operation ID generation with the parameter\\n                `generate_unique_id_function` in the `FastAPI` class.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=None, response_model_include: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to include only certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_exclude: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to exclude certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_by_alias: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response model\\n                should be serialized by alias when an alias is used.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=True, response_model_exclude_unset: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that were not set and\\n                have their default values. This is different from\\n                `response_model_exclude_defaults` in that if the fields are set,\\n                they will be included in the response, even if the value is the same\\n                as the default.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_defaults: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that have the same value\\n                as the default. This is different from `response_model_exclude_unset`\\n                in that if the fields are set but contain the same default values,\\n                they will be excluded from the response.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_none: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data should\\n                exclude fields set to `None`.\\n\\n                This is much simpler (less smart) than `response_model_exclude_unset`\\n                and `response_model_exclude_defaults`. You probably want to use one of\\n                those two instead of this one, as those allow returning `None` values\\n                when it makes sense.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\\n                ')]=False, include_in_schema: Annotated[bool, Doc('\\n                Include this *path operation* in the generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\\n                ')]=True, response_class: Annotated[Type[Response], Doc('\\n                Response class to be used for this *path operation*.\\n\\n                This will not be used if you return a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\\n                ')]=Default(JSONResponse), name: Annotated[Optional[str], Doc('\\n                Name for this *path operation*. Only used internally.\\n                ')]=None, callbacks: Annotated[Optional[List[BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")]=None, openapi_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n                Extra metadata to be included in the OpenAPI schema for this *path\\n                operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\\n                ')]=None, generate_unique_id_function: Annotated[Callable[[routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=Default(generate_unique_id)) -> Callable[[DecoratedCallable], DecoratedCallable]:\n    \"\"\"\n        Add a *path operation* using an HTTP GET operation.\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI\n\n        app = FastAPI()\n\n        @app.get(\"/items/\")\n        def read_items():\n            return [{\"name\": \"Empanada\"}, {\"name\": \"Arepa\"}]\n        ```\n        \"\"\"\n    return self.router.get(path, response_model=response_model, status_code=status_code, tags=tags, dependencies=dependencies, summary=summary, description=description, response_description=response_description, responses=responses, deprecated=deprecated, operation_id=operation_id, response_model_include=response_model_include, response_model_exclude=response_model_exclude, response_model_by_alias=response_model_by_alias, response_model_exclude_unset=response_model_exclude_unset, response_model_exclude_defaults=response_model_exclude_defaults, response_model_exclude_none=response_model_exclude_none, include_in_schema=include_in_schema, response_class=response_class, name=name, callbacks=callbacks, openapi_extra=openapi_extra, generate_unique_id_function=generate_unique_id_function)"
        },
        {
          "name": "openapi_response.get",
          "body": "def get(self, path: Annotated[str, Doc('\\n                The URL path to be used for this *path operation*.\\n\\n                For example, in `http://example.com/items`, the path is `/items`.\\n                ')], *, response_model: Annotated[Any, Doc(\"\\n                The type to use for the response.\\n\\n                It could be any valid Pydantic *field* type. So, it doesn't have to\\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\\n                etc.\\n\\n                It will be used for:\\n\\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\\n                    show it as the response (JSON Schema).\\n                * Serialization: you could return an arbitrary object and the\\n                    `response_model` would be used to serialize that object into the\\n                    corresponding JSON.\\n                * Filtering: the JSON sent to the client will only contain the data\\n                    (fields) defined in the `response_model`. If you returned an object\\n                    that contains an attribute `password` but the `response_model` does\\n                    not include that field, the JSON sent to the client would not have\\n                    that `password`.\\n                * Validation: whatever you return will be serialized with the\\n                    `response_model`, converting any data as necessary to generate the\\n                    corresponding JSON. But if the data in the object returned is not\\n                    valid, that would mean a violation of the contract with the client,\\n                    so it's an error from the API developer. So, FastAPI will raise an\\n                    error and return a 500 error code (Internal Server Error).\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\\n                \")]=Default(None), status_code: Annotated[Optional[int], Doc('\\n                The default status code to be used for the response.\\n\\n                You could override the status code by returning a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\\n                ')]=None, tags: Annotated[Optional[List[Union[str, Enum]]], Doc('\\n                A list of tags to be applied to the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\\n                ')]=None, dependencies: Annotated[Optional[Sequence[Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to the\\n                *path operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\\n                ')]=None, summary: Annotated[Optional[str], Doc('\\n                A summary for the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, description: Annotated[Optional[str], Doc('\\n                A description for the *path operation*.\\n\\n                If not provided, it will be extracted automatically from the docstring\\n                of the *path operation function*.\\n\\n                It can contain Markdown.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')]=None, response_description: Annotated[str, Doc('\\n                The description for the default response.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]='Successful Response', responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses that could be returned by this *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark this *path operation* as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')]=None, operation_id: Annotated[Optional[str], Doc('\\n                Custom operation ID to be used by this *path operation*.\\n\\n                By default, it is generated automatically.\\n\\n                If you provide a custom operation ID, you need to make sure it is\\n                unique for the whole API.\\n\\n                You can customize the\\n                operation ID generation with the parameter\\n                `generate_unique_id_function` in the `FastAPI` class.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=None, response_model_include: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to include only certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_exclude: Annotated[Optional[IncEx], Doc('\\n                Configuration passed to Pydantic to exclude certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=None, response_model_by_alias: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response model\\n                should be serialized by alias when an alias is used.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')]=True, response_model_exclude_unset: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that were not set and\\n                have their default values. This is different from\\n                `response_model_exclude_defaults` in that if the fields are set,\\n                they will be included in the response, even if the value is the same\\n                as the default.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_defaults: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that have the same value\\n                as the default. This is different from `response_model_exclude_unset`\\n                in that if the fields are set but contain the same default values,\\n                they will be excluded from the response.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')]=False, response_model_exclude_none: Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data should\\n                exclude fields set to `None`.\\n\\n                This is much simpler (less smart) than `response_model_exclude_unset`\\n                and `response_model_exclude_defaults`. You probably want to use one of\\n                those two instead of this one, as those allow returning `None` values\\n                when it makes sense.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\\n                ')]=False, include_in_schema: Annotated[bool, Doc('\\n                Include this *path operation* in the generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).\\n                ')]=True, response_class: Annotated[Type[Response], Doc('\\n                Response class to be used for this *path operation*.\\n\\n                This will not be used if you return a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\\n                ')]=Default(JSONResponse), name: Annotated[Optional[str], Doc('\\n                Name for this *path operation*. Only used internally.\\n                ')]=None, callbacks: Annotated[Optional[List[BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")]=None, openapi_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n                Extra metadata to be included in the OpenAPI schema for this *path\\n                operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\\n                ')]=None, generate_unique_id_function: Annotated[Callable[[routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')]=Default(generate_unique_id)) -> Callable[[DecoratedCallable], DecoratedCallable]:\n    \"\"\"\n        Add a *path operation* using an HTTP GET operation.\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI\n\n        app = FastAPI()\n\n        @app.get(\"/items/\")\n        def read_items():\n            return [{\"name\": \"Empanada\"}, {\"name\": \"Arepa\"}]\n        ```\n        \"\"\"\n    return self.router.get(path, response_model=response_model, status_code=status_code, tags=tags, dependencies=dependencies, summary=summary, description=description, response_description=response_description, responses=responses, deprecated=deprecated, operation_id=operation_id, response_model_include=response_model_include, response_model_exclude=response_model_exclude, response_model_by_alias=response_model_by_alias, response_model_exclude_unset=response_model_exclude_unset, response_model_exclude_defaults=response_model_exclude_defaults, response_model_exclude_none=response_model_exclude_none, include_in_schema=include_in_schema, response_class=response_class, name=name, callbacks=callbacks, openapi_extra=openapi_extra, generate_unique_id_function=generate_unique_id_function)"
        }
      ]
    },
    {
      "name": "get_fields_from_routes",
      "module": "utils",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\openapi\\utils.py",
      "line_number": 425,
      "end_line_number": 453,
      "source_code": "def get_fields_from_routes(\n    routes: Sequence[BaseRoute],\n) -> List[ModelField]:\n    body_fields_from_routes: List[ModelField] = []\n    responses_from_routes: List[ModelField] = []\n    request_fields_from_routes: List[ModelField] = []\n    callback_flat_models: List[ModelField] = []\n    for route in routes:\n        if getattr(route, \"include_in_schema\", None) and isinstance(\n            route, routing.APIRoute\n        ):\n            if route.body_field:\n                assert isinstance(\n                    route.body_field, ModelField\n                ), \"A request body must be a Pydantic Field\"\n                body_fields_from_routes.append(route.body_field)\n            if route.response_field:\n                responses_from_routes.append(route.response_field)\n            if route.response_fields:\n                responses_from_routes.extend(route.response_fields.values())\n            if route.callbacks:\n                callback_flat_models.extend(get_fields_from_routes(route.callbacks))\n            params = get_flat_params(route.dependant)\n            request_fields_from_routes.extend(params)\n\n    flat_models = callback_flat_models + list(\n        body_fields_from_routes + responses_from_routes + request_fields_from_routes\n    )\n    return flat_models",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "routes"
      ],
      "imports": [
        "http.client",
        "inspect",
        "warnings",
        "typing.Any",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "typing.cast",
        "fastapi.routing",
        "fastapi._compat.GenerateJsonSchema",
        "fastapi._compat.JsonSchemaValue",
        "fastapi._compat.ModelField",
        "fastapi._compat.Undefined",
        "fastapi._compat.get_compat_model_name_map",
        "fastapi._compat.get_definitions",
        "fastapi._compat.get_schema_from_model_field",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.utils._get_flat_fields_from_params",
        "fastapi.dependencies.utils.get_flat_dependant",
        "fastapi.dependencies.utils.get_flat_params",
        "fastapi.encoders.jsonable_encoder",
        "fastapi.openapi.constants.METHODS_WITH_BODY",
        "fastapi.openapi.constants.REF_PREFIX",
        "fastapi.openapi.constants.REF_TEMPLATE",
        "fastapi.openapi.models.OpenAPI",
        "fastapi.params.Body",
        "fastapi.params.ParamTypes",
        "fastapi.responses.Response",
        "fastapi.types.ModelNameMap",
        "fastapi.utils.deep_dict_update",
        "fastapi.utils.generate_operation_id_for_path",
        "fastapi.utils.is_body_allowed_for_status_code",
        "starlette.responses.JSONResponse",
        "starlette.routing.BaseRoute",
        "starlette.status.HTTP_422_UNPROCESSABLE_ENTITY",
        "typing_extensions.Literal"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(route.body_field, ModelField), 'A request body must be a Pydantic Field'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_flat_params",
          "body": "def get_flat_params(dependant: Dependant) -> List[ModelField]:\n    flat_dependant = get_flat_dependant(dependant, skip_repeats=True)\n    path_params = _get_flat_fields_from_params(flat_dependant.path_params)\n    query_params = _get_flat_fields_from_params(flat_dependant.query_params)\n    header_params = _get_flat_fields_from_params(flat_dependant.header_params)\n    cookie_params = _get_flat_fields_from_params(flat_dependant.cookie_params)\n    return path_params + query_params + header_params + cookie_params"
        },
        {
          "name": "get_fields_from_routes",
          "body": "def get_fields_from_routes(routes: Sequence[BaseRoute]) -> List[ModelField]:\n    body_fields_from_routes: List[ModelField] = []\n    responses_from_routes: List[ModelField] = []\n    request_fields_from_routes: List[ModelField] = []\n    callback_flat_models: List[ModelField] = []\n    for route in routes:\n        if getattr(route, 'include_in_schema', None) and isinstance(route, routing.APIRoute):\n            if route.body_field:\n                assert isinstance(route.body_field, ModelField), 'A request body must be a Pydantic Field'\n                body_fields_from_routes.append(route.body_field)\n            if route.response_field:\n                responses_from_routes.append(route.response_field)\n            if route.response_fields:\n                responses_from_routes.extend(route.response_fields.values())\n            if route.callbacks:\n                callback_flat_models.extend(get_fields_from_routes(route.callbacks))\n            params = get_flat_params(route.dependant)\n            request_fields_from_routes.extend(params)\n    flat_models = callback_flat_models + list(body_fields_from_routes + responses_from_routes + request_fields_from_routes)\n    return flat_models"
        }
      ]
    },
    {
      "name": "get_openapi",
      "module": "utils",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\openapi\\utils.py",
      "line_number": 456,
      "end_line_number": 548,
      "source_code": "def get_openapi(\n    *,\n    title: str,\n    version: str,\n    openapi_version: str = \"3.1.0\",\n    summary: Optional[str] = None,\n    description: Optional[str] = None,\n    routes: Sequence[BaseRoute],\n    webhooks: Optional[Sequence[BaseRoute]] = None,\n    tags: Optional[List[Dict[str, Any]]] = None,\n    servers: Optional[List[Dict[str, Union[str, Any]]]] = None,\n    terms_of_service: Optional[str] = None,\n    contact: Optional[Dict[str, Union[str, Any]]] = None,\n    license_info: Optional[Dict[str, Union[str, Any]]] = None,\n    separate_input_output_schemas: bool = True,\n) -> Dict[str, Any]:\n    info: Dict[str, Any] = {\"title\": title, \"version\": version}\n    if summary:\n        info[\"summary\"] = summary\n    if description:\n        info[\"description\"] = description\n    if terms_of_service:\n        info[\"termsOfService\"] = terms_of_service\n    if contact:\n        info[\"contact\"] = contact\n    if license_info:\n        info[\"license\"] = license_info\n    output: Dict[str, Any] = {\"openapi\": openapi_version, \"info\": info}\n    if servers:\n        output[\"servers\"] = servers\n    components: Dict[str, Dict[str, Any]] = {}\n    paths: Dict[str, Dict[str, Any]] = {}\n    webhook_paths: Dict[str, Dict[str, Any]] = {}\n    operation_ids: Set[str] = set()\n    all_fields = get_fields_from_routes(list(routes or []) + list(webhooks or []))\n    model_name_map = get_compat_model_name_map(all_fields)\n    schema_generator = GenerateJsonSchema(ref_template=REF_TEMPLATE)\n    field_mapping, definitions = get_definitions(\n        fields=all_fields,\n        schema_generator=schema_generator,\n        model_name_map=model_name_map,\n        separate_input_output_schemas=separate_input_output_schemas,\n    )\n    for route in routes or []:\n        if isinstance(route, routing.APIRoute):\n            result = get_openapi_path(\n                route=route,\n                operation_ids=operation_ids,\n                schema_generator=schema_generator,\n                model_name_map=model_name_map,\n                field_mapping=field_mapping,\n                separate_input_output_schemas=separate_input_output_schemas,\n            )\n            if result:\n                path, security_schemes, path_definitions = result\n                if path:\n                    paths.setdefault(route.path_format, {}).update(path)\n                if security_schemes:\n                    components.setdefault(\"securitySchemes\", {}).update(\n                        security_schemes\n                    )\n                if path_definitions:\n                    definitions.update(path_definitions)\n    for webhook in webhooks or []:\n        if isinstance(webhook, routing.APIRoute):\n            result = get_openapi_path(\n                route=webhook,\n                operation_ids=operation_ids,\n                schema_generator=schema_generator,\n                model_name_map=model_name_map,\n                field_mapping=field_mapping,\n                separate_input_output_schemas=separate_input_output_schemas,\n            )\n            if result:\n                path, security_schemes, path_definitions = result\n                if path:\n                    webhook_paths.setdefault(webhook.path_format, {}).update(path)\n                if security_schemes:\n                    components.setdefault(\"securitySchemes\", {}).update(\n                        security_schemes\n                    )\n                if path_definitions:\n                    definitions.update(path_definitions)\n    if definitions:\n        components[\"schemas\"] = {k: definitions[k] for k in sorted(definitions)}\n    if components:\n        output[\"components\"] = components\n    output[\"paths\"] = paths\n    if webhook_paths:\n        output[\"webhooks\"] = webhook_paths\n    if tags:\n        output[\"tags\"] = tags\n    return jsonable_encoder(OpenAPI(**output), by_alias=True, exclude_none=True)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "http.client",
        "inspect",
        "warnings",
        "typing.Any",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Sequence",
        "typing.Set",
        "typing.Tuple",
        "typing.Type",
        "typing.Union",
        "typing.cast",
        "fastapi.routing",
        "fastapi._compat.GenerateJsonSchema",
        "fastapi._compat.JsonSchemaValue",
        "fastapi._compat.ModelField",
        "fastapi._compat.Undefined",
        "fastapi._compat.get_compat_model_name_map",
        "fastapi._compat.get_definitions",
        "fastapi._compat.get_schema_from_model_field",
        "fastapi._compat.lenient_issubclass",
        "fastapi.datastructures.DefaultPlaceholder",
        "fastapi.dependencies.models.Dependant",
        "fastapi.dependencies.utils._get_flat_fields_from_params",
        "fastapi.dependencies.utils.get_flat_dependant",
        "fastapi.dependencies.utils.get_flat_params",
        "fastapi.encoders.jsonable_encoder",
        "fastapi.openapi.constants.METHODS_WITH_BODY",
        "fastapi.openapi.constants.REF_PREFIX",
        "fastapi.openapi.constants.REF_TEMPLATE",
        "fastapi.openapi.models.OpenAPI",
        "fastapi.params.Body",
        "fastapi.params.ParamTypes",
        "fastapi.responses.Response",
        "fastapi.types.ModelNameMap",
        "fastapi.utils.deep_dict_update",
        "fastapi.utils.generate_operation_id_for_path",
        "fastapi.utils.is_body_allowed_for_status_code",
        "starlette.responses.JSONResponse",
        "starlette.routing.BaseRoute",
        "starlette.status.HTTP_422_UNPROCESSABLE_ENTITY",
        "typing_extensions.Literal"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_fields_from_routes",
          "body": "def get_fields_from_routes(routes: Sequence[BaseRoute]) -> List[ModelField]:\n    body_fields_from_routes: List[ModelField] = []\n    responses_from_routes: List[ModelField] = []\n    request_fields_from_routes: List[ModelField] = []\n    callback_flat_models: List[ModelField] = []\n    for route in routes:\n        if getattr(route, 'include_in_schema', None) and isinstance(route, routing.APIRoute):\n            if route.body_field:\n                assert isinstance(route.body_field, ModelField), 'A request body must be a Pydantic Field'\n                body_fields_from_routes.append(route.body_field)\n            if route.response_field:\n                responses_from_routes.append(route.response_field)\n            if route.response_fields:\n                responses_from_routes.extend(route.response_fields.values())\n            if route.callbacks:\n                callback_flat_models.extend(get_fields_from_routes(route.callbacks))\n            params = get_flat_params(route.dependant)\n            request_fields_from_routes.extend(params)\n    flat_models = callback_flat_models + list(body_fields_from_routes + responses_from_routes + request_fields_from_routes)\n    return flat_models"
        },
        {
          "name": "get_compat_model_name_map",
          "body": "def get_compat_model_name_map(fields: List[ModelField]) -> ModelNameMap:\n    return {}"
        },
        {
          "name": "get_definitions",
          "body": "def get_definitions(*, fields: List[ModelField], schema_generator: GenerateJsonSchema, model_name_map: ModelNameMap, separate_input_output_schemas: bool=True) -> Tuple[Dict[Tuple[ModelField, Literal['validation', 'serialization']], JsonSchemaValue], Dict[str, Dict[str, Any]]]:\n    override_mode: Union[Literal['validation'], None] = None if separate_input_output_schemas else 'validation'\n    inputs = [(field, override_mode or field.mode, field._type_adapter.core_schema) for field in fields]\n    field_mapping, definitions = schema_generator.generate_definitions(inputs=inputs)\n    return (field_mapping, definitions)"
        },
        {
          "name": "jsonable_encoder",
          "body": "def jsonable_encoder(obj: Annotated[Any, Doc('\\n            The input object to convert to JSON.\\n            ')], include: Annotated[Optional[IncEx], Doc(\"\\n            Pydantic's `include` parameter, passed to Pydantic models to set the\\n            fields to include.\\n            \")]=None, exclude: Annotated[Optional[IncEx], Doc(\"\\n            Pydantic's `exclude` parameter, passed to Pydantic models to set the\\n            fields to exclude.\\n            \")]=None, by_alias: Annotated[bool, Doc(\"\\n            Pydantic's `by_alias` parameter, passed to Pydantic models to define if\\n            the output should use the alias names (when provided) or the Python\\n            attribute names. In an API, if you set an alias, it's probably because you\\n            want to use it in the result, so you probably want to leave this set to\\n            `True`.\\n            \")]=True, exclude_unset: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_unset` parameter, passed to Pydantic models to define\\n            if it should exclude from the output the fields that were not explicitly\\n            set (and that only had their default values).\\n            \")]=False, exclude_defaults: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_defaults` parameter, passed to Pydantic models to define\\n            if it should exclude from the output the fields that had the same default\\n            value, even when they were explicitly set.\\n            \")]=False, exclude_none: Annotated[bool, Doc(\"\\n            Pydantic's `exclude_none` parameter, passed to Pydantic models to define\\n            if it should exclude from the output any fields that have a `None` value.\\n            \")]=False, custom_encoder: Annotated[Optional[Dict[Any, Callable[[Any], Any]]], Doc(\"\\n            Pydantic's `custom_encoder` parameter, passed to Pydantic models to define\\n            a custom encoder.\\n            \")]=None, sqlalchemy_safe: Annotated[bool, Doc(\"\\n            Exclude from the output any fields that start with the name `_sa`.\\n\\n            This is mainly a hack for compatibility with SQLAlchemy objects, they\\n            store internal SQLAlchemy-specific state in attributes named with `_sa`,\\n            and those objects can't (and shouldn't be) serialized to JSON.\\n            \")]=True) -> Any:\n    \"\"\"\n    Convert any object to something that can be encoded in JSON.\n\n    This is used internally by FastAPI to make sure anything you return can be\n    encoded as JSON before it is sent to the client.\n\n    You can also use it yourself, for example to convert objects before saving them\n    in a database that supports only JSON.\n\n    Read more about it in the\n    [FastAPI docs for JSON Compatible Encoder](https://fastapi.tiangolo.com/tutorial/encoder/).\n    \"\"\"\n    custom_encoder = custom_encoder or {}\n    if custom_encoder:\n        if type(obj) in custom_encoder:\n            return custom_encoder[type(obj)](obj)\n        else:\n            for encoder_type, encoder_instance in custom_encoder.items():\n                if isinstance(obj, encoder_type):\n                    return encoder_instance(obj)\n    if include is not None and (not isinstance(include, (set, dict))):\n        include = set(include)\n    if exclude is not None and (not isinstance(exclude, (set, dict))):\n        exclude = set(exclude)\n    if isinstance(obj, BaseModel):\n        encoders: Dict[Any, Any] = {}\n        if not PYDANTIC_V2:\n            encoders = getattr(obj.__config__, 'json_encoders', {})\n            if custom_encoder:\n                encoders.update(custom_encoder)\n        obj_dict = _model_dump(obj, mode='json', include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, exclude_defaults=exclude_defaults)\n        if '__root__' in obj_dict:\n            obj_dict = obj_dict['__root__']\n        return jsonable_encoder(obj_dict, exclude_none=exclude_none, exclude_defaults=exclude_defaults, custom_encoder=encoders, sqlalchemy_safe=sqlalchemy_safe)\n    if dataclasses.is_dataclass(obj):\n        obj_dict = dataclasses.asdict(obj)\n        return jsonable_encoder(obj_dict, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n    if isinstance(obj, Enum):\n        return obj.value\n    if isinstance(obj, PurePath):\n        return str(obj)\n    if isinstance(obj, (str, int, float, type(None))):\n        return obj\n    if isinstance(obj, UndefinedType):\n        return None\n    if isinstance(obj, dict):\n        encoded_dict = {}\n        allowed_keys = set(obj.keys())\n        if include is not None:\n            allowed_keys &= set(include)\n        if exclude is not None:\n            allowed_keys -= set(exclude)\n        for key, value in obj.items():\n            if (not sqlalchemy_safe or not isinstance(key, str) or (not key.startswith('_sa'))) and (value is not None or not exclude_none) and (key in allowed_keys):\n                encoded_key = jsonable_encoder(key, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n                encoded_value = jsonable_encoder(value, by_alias=by_alias, exclude_unset=exclude_unset, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)\n                encoded_dict[encoded_key] = encoded_value\n        return encoded_dict\n    if isinstance(obj, (list, set, frozenset, GeneratorType, tuple, deque)):\n        encoded_list = []\n        for item in obj:\n            encoded_list.append(jsonable_encoder(item, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe))\n        return encoded_list\n    if type(obj) in ENCODERS_BY_TYPE:\n        return ENCODERS_BY_TYPE[type(obj)](obj)\n    for encoder, classes_tuple in encoders_by_class_tuples.items():\n        if isinstance(obj, classes_tuple):\n            return encoder(obj)\n    try:\n        data = dict(obj)\n    except Exception as e:\n        errors: List[Exception] = []\n        errors.append(e)\n        try:\n            data = vars(obj)\n        except Exception as e:\n            errors.append(e)\n            raise ValueError(errors) from e\n    return jsonable_encoder(data, include=include, exclude=exclude, by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none, custom_encoder=custom_encoder, sqlalchemy_safe=sqlalchemy_safe)"
        },
        {
          "name": "get_openapi_path",
          "body": "def get_openapi_path(*, route: routing.APIRoute, operation_ids: Set[str], schema_generator: GenerateJsonSchema, model_name_map: ModelNameMap, field_mapping: Dict[Tuple[ModelField, Literal['validation', 'serialization']], JsonSchemaValue], separate_input_output_schemas: bool=True) -> Tuple[Dict[str, Any], Dict[str, Any], Dict[str, Any]]:\n    path = {}\n    security_schemes: Dict[str, Any] = {}\n    definitions: Dict[str, Any] = {}\n    assert route.methods is not None, 'Methods must be a list'\n    if isinstance(route.response_class, DefaultPlaceholder):\n        current_response_class: Type[Response] = route.response_class.value\n    else:\n        current_response_class = route.response_class\n    assert current_response_class, 'A response class is needed to generate OpenAPI'\n    route_response_media_type: Optional[str] = current_response_class.media_type\n    if route.include_in_schema:\n        for method in route.methods:\n            operation = get_openapi_operation_metadata(route=route, method=method, operation_ids=operation_ids)\n            parameters: List[Dict[str, Any]] = []\n            flat_dependant = get_flat_dependant(route.dependant, skip_repeats=True)\n            security_definitions, operation_security = get_openapi_security_definitions(flat_dependant=flat_dependant)\n            if operation_security:\n                operation.setdefault('security', []).extend(operation_security)\n            if security_definitions:\n                security_schemes.update(security_definitions)\n            operation_parameters = _get_openapi_operation_parameters(dependant=route.dependant, schema_generator=schema_generator, model_name_map=model_name_map, field_mapping=field_mapping, separate_input_output_schemas=separate_input_output_schemas)\n            parameters.extend(operation_parameters)\n            if parameters:\n                all_parameters = {(param['in'], param['name']): param for param in parameters}\n                required_parameters = {(param['in'], param['name']): param for param in parameters if param.get('required')}\n                all_parameters.update(required_parameters)\n                operation['parameters'] = list(all_parameters.values())\n            if method in METHODS_WITH_BODY:\n                request_body_oai = get_openapi_operation_request_body(body_field=route.body_field, schema_generator=schema_generator, model_name_map=model_name_map, field_mapping=field_mapping, separate_input_output_schemas=separate_input_output_schemas)\n                if request_body_oai:\n                    operation['requestBody'] = request_body_oai\n            if route.callbacks:\n                callbacks = {}\n                for callback in route.callbacks:\n                    if isinstance(callback, routing.APIRoute):\n                        cb_path, cb_security_schemes, cb_definitions = get_openapi_path(route=callback, operation_ids=operation_ids, schema_generator=schema_generator, model_name_map=model_name_map, field_mapping=field_mapping, separate_input_output_schemas=separate_input_output_schemas)\n                        callbacks[callback.name] = {callback.path: cb_path}\n                operation['callbacks'] = callbacks\n            if route.status_code is not None:\n                status_code = str(route.status_code)\n            else:\n                response_signature = inspect.signature(current_response_class.__init__)\n                status_code_param = response_signature.parameters.get('status_code')\n                if status_code_param is not None:\n                    if isinstance(status_code_param.default, int):\n                        status_code = str(status_code_param.default)\n            operation.setdefault('responses', {}).setdefault(status_code, {})['description'] = route.response_description\n            if route_response_media_type and is_body_allowed_for_status_code(route.status_code):\n                response_schema = {'type': 'string'}\n                if lenient_issubclass(current_response_class, JSONResponse):\n                    if route.response_field:\n                        response_schema = get_schema_from_model_field(field=route.response_field, schema_generator=schema_generator, model_name_map=model_name_map, field_mapping=field_mapping, separate_input_output_schemas=separate_input_output_schemas)\n                    else:\n                        response_schema = {}\n                operation.setdefault('responses', {}).setdefault(status_code, {}).setdefault('content', {}).setdefault(route_response_media_type, {})['schema'] = response_schema\n            if route.responses:\n                operation_responses = operation.setdefault('responses', {})\n                for additional_status_code, additional_response in route.responses.items():\n                    process_response = additional_response.copy()\n                    process_response.pop('model', None)\n                    status_code_key = str(additional_status_code).upper()\n                    if status_code_key == 'DEFAULT':\n                        status_code_key = 'default'\n                    openapi_response = operation_responses.setdefault(status_code_key, {})\n                    assert isinstance(process_response, dict), 'An additional response must be a dict'\n                    field = route.response_fields.get(additional_status_code)\n                    additional_field_schema: Optional[Dict[str, Any]] = None\n                    if field:\n                        additional_field_schema = get_schema_from_model_field(field=field, schema_generator=schema_generator, model_name_map=model_name_map, field_mapping=field_mapping, separate_input_output_schemas=separate_input_output_schemas)\n                        media_type = route_response_media_type or 'application/json'\n                        additional_schema = process_response.setdefault('content', {}).setdefault(media_type, {}).setdefault('schema', {})\n                        deep_dict_update(additional_schema, additional_field_schema)\n                    status_text: Optional[str] = status_code_ranges.get(str(additional_status_code).upper()) or http.client.responses.get(int(additional_status_code))\n                    description = process_response.get('description') or openapi_response.get('description') or status_text or 'Additional Response'\n                    deep_dict_update(openapi_response, process_response)\n                    openapi_response['description'] = description\n            http422 = str(HTTP_422_UNPROCESSABLE_ENTITY)\n            all_route_params = get_flat_params(route.dependant)\n            if (all_route_params or route.body_field) and (not any((status in operation['responses'] for status in [http422, '4XX', 'default']))):\n                operation['responses'][http422] = {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': REF_PREFIX + 'HTTPValidationError'}}}}\n                if 'ValidationError' not in definitions:\n                    definitions.update({'ValidationError': validation_error_definition, 'HTTPValidationError': validation_error_response_definition})\n            if route.openapi_extra:\n                deep_dict_update(operation, route.openapi_extra)\n            path[method.lower()] = operation\n    return (path, security_schemes, definitions)"
        },
        {
          "name": "get_openapi_path",
          "body": "def get_openapi_path(*, route: routing.APIRoute, operation_ids: Set[str], schema_generator: GenerateJsonSchema, model_name_map: ModelNameMap, field_mapping: Dict[Tuple[ModelField, Literal['validation', 'serialization']], JsonSchemaValue], separate_input_output_schemas: bool=True) -> Tuple[Dict[str, Any], Dict[str, Any], Dict[str, Any]]:\n    path = {}\n    security_schemes: Dict[str, Any] = {}\n    definitions: Dict[str, Any] = {}\n    assert route.methods is not None, 'Methods must be a list'\n    if isinstance(route.response_class, DefaultPlaceholder):\n        current_response_class: Type[Response] = route.response_class.value\n    else:\n        current_response_class = route.response_class\n    assert current_response_class, 'A response class is needed to generate OpenAPI'\n    route_response_media_type: Optional[str] = current_response_class.media_type\n    if route.include_in_schema:\n        for method in route.methods:\n            operation = get_openapi_operation_metadata(route=route, method=method, operation_ids=operation_ids)\n            parameters: List[Dict[str, Any]] = []\n            flat_dependant = get_flat_dependant(route.dependant, skip_repeats=True)\n            security_definitions, operation_security = get_openapi_security_definitions(flat_dependant=flat_dependant)\n            if operation_security:\n                operation.setdefault('security', []).extend(operation_security)\n            if security_definitions:\n                security_schemes.update(security_definitions)\n            operation_parameters = _get_openapi_operation_parameters(dependant=route.dependant, schema_generator=schema_generator, model_name_map=model_name_map, field_mapping=field_mapping, separate_input_output_schemas=separate_input_output_schemas)\n            parameters.extend(operation_parameters)\n            if parameters:\n                all_parameters = {(param['in'], param['name']): param for param in parameters}\n                required_parameters = {(param['in'], param['name']): param for param in parameters if param.get('required')}\n                all_parameters.update(required_parameters)\n                operation['parameters'] = list(all_parameters.values())\n            if method in METHODS_WITH_BODY:\n                request_body_oai = get_openapi_operation_request_body(body_field=route.body_field, schema_generator=schema_generator, model_name_map=model_name_map, field_mapping=field_mapping, separate_input_output_schemas=separate_input_output_schemas)\n                if request_body_oai:\n                    operation['requestBody'] = request_body_oai\n            if route.callbacks:\n                callbacks = {}\n                for callback in route.callbacks:\n                    if isinstance(callback, routing.APIRoute):\n                        cb_path, cb_security_schemes, cb_definitions = get_openapi_path(route=callback, operation_ids=operation_ids, schema_generator=schema_generator, model_name_map=model_name_map, field_mapping=field_mapping, separate_input_output_schemas=separate_input_output_schemas)\n                        callbacks[callback.name] = {callback.path: cb_path}\n                operation['callbacks'] = callbacks\n            if route.status_code is not None:\n                status_code = str(route.status_code)\n            else:\n                response_signature = inspect.signature(current_response_class.__init__)\n                status_code_param = response_signature.parameters.get('status_code')\n                if status_code_param is not None:\n                    if isinstance(status_code_param.default, int):\n                        status_code = str(status_code_param.default)\n            operation.setdefault('responses', {}).setdefault(status_code, {})['description'] = route.response_description\n            if route_response_media_type and is_body_allowed_for_status_code(route.status_code):\n                response_schema = {'type': 'string'}\n                if lenient_issubclass(current_response_class, JSONResponse):\n                    if route.response_field:\n                        response_schema = get_schema_from_model_field(field=route.response_field, schema_generator=schema_generator, model_name_map=model_name_map, field_mapping=field_mapping, separate_input_output_schemas=separate_input_output_schemas)\n                    else:\n                        response_schema = {}\n                operation.setdefault('responses', {}).setdefault(status_code, {}).setdefault('content', {}).setdefault(route_response_media_type, {})['schema'] = response_schema\n            if route.responses:\n                operation_responses = operation.setdefault('responses', {})\n                for additional_status_code, additional_response in route.responses.items():\n                    process_response = additional_response.copy()\n                    process_response.pop('model', None)\n                    status_code_key = str(additional_status_code).upper()\n                    if status_code_key == 'DEFAULT':\n                        status_code_key = 'default'\n                    openapi_response = operation_responses.setdefault(status_code_key, {})\n                    assert isinstance(process_response, dict), 'An additional response must be a dict'\n                    field = route.response_fields.get(additional_status_code)\n                    additional_field_schema: Optional[Dict[str, Any]] = None\n                    if field:\n                        additional_field_schema = get_schema_from_model_field(field=field, schema_generator=schema_generator, model_name_map=model_name_map, field_mapping=field_mapping, separate_input_output_schemas=separate_input_output_schemas)\n                        media_type = route_response_media_type or 'application/json'\n                        additional_schema = process_response.setdefault('content', {}).setdefault(media_type, {}).setdefault('schema', {})\n                        deep_dict_update(additional_schema, additional_field_schema)\n                    status_text: Optional[str] = status_code_ranges.get(str(additional_status_code).upper()) or http.client.responses.get(int(additional_status_code))\n                    description = process_response.get('description') or openapi_response.get('description') or status_text or 'Additional Response'\n                    deep_dict_update(openapi_response, process_response)\n                    openapi_response['description'] = description\n            http422 = str(HTTP_422_UNPROCESSABLE_ENTITY)\n            all_route_params = get_flat_params(route.dependant)\n            if (all_route_params or route.body_field) and (not any((status in operation['responses'] for status in [http422, '4XX', 'default']))):\n                operation['responses'][http422] = {'description': 'Validation Error', 'content': {'application/json': {'schema': {'$ref': REF_PREFIX + 'HTTPValidationError'}}}}\n                if 'ValidationError' not in definitions:\n                    definitions.update({'ValidationError': validation_error_definition, 'HTTPValidationError': validation_error_response_definition})\n            if route.openapi_extra:\n                deep_dict_update(operation, route.openapi_extra)\n            path[method.lower()] = operation\n    return (path, security_schemes, definitions)"
        }
      ]
    },
    {
      "name": "__init__",
      "module": "api_key",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\security\\api_key.py",
      "line_number": 47,
      "end_line_number": 100,
      "source_code": "def __init__(\n        self,\n        *,\n        name: Annotated[\n            str,\n            Doc(\"Query parameter name.\"),\n        ],\n        scheme_name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Security scheme name.\n\n                It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Security scheme description.\n\n                It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        auto_error: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                By default, if the query parameter is not provided, `APIKeyQuery` will\n                automatically cancel the request and send the client an error.\n\n                If `auto_error` is set to `False`, when the query parameter is not\n                available, instead of erroring out, the dependency result will be\n                `None`.\n\n                This is useful when you want to have optional authentication.\n\n                It is also useful when you want to have authentication that can be\n                provided in one of multiple optional ways (for example, in a query\n                parameter or in an HTTP Bearer token).\n                \"\"\"\n            ),\n        ] = True,\n    ):\n        self.model: APIKey = APIKey(\n            **{\"in\": APIKeyIn.query},  # type: ignore[arg-type]\n            name=name,\n            description=description,\n        )\n        self.scheme_name = scheme_name or self.__class__.__name__\n        self.auto_error = auto_error",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "typing.Optional",
        "fastapi.openapi.models.APIKey",
        "fastapi.openapi.models.APIKeyIn",
        "fastapi.security.base.SecurityBase",
        "starlette.exceptions.HTTPException",
        "starlette.requests.Request",
        "starlette.status.HTTP_403_FORBIDDEN",
        "typing_extensions.Annotated",
        "typing_extensions.Doc"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "api_key",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\security\\api_key.py",
      "line_number": 146,
      "end_line_number": 195,
      "source_code": "def __init__(\n        self,\n        *,\n        name: Annotated[str, Doc(\"Header name.\")],\n        scheme_name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Security scheme name.\n\n                It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Security scheme description.\n\n                It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        auto_error: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                By default, if the header is not provided, `APIKeyHeader` will\n                automatically cancel the request and send the client an error.\n\n                If `auto_error` is set to `False`, when the header is not available,\n                instead of erroring out, the dependency result will be `None`.\n\n                This is useful when you want to have optional authentication.\n\n                It is also useful when you want to have authentication that can be\n                provided in one of multiple optional ways (for example, in a header or\n                in an HTTP Bearer token).\n                \"\"\"\n            ),\n        ] = True,\n    ):\n        self.model: APIKey = APIKey(\n            **{\"in\": APIKeyIn.header},  # type: ignore[arg-type]\n            name=name,\n            description=description,\n        )\n        self.scheme_name = scheme_name or self.__class__.__name__\n        self.auto_error = auto_error",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "typing.Optional",
        "fastapi.openapi.models.APIKey",
        "fastapi.openapi.models.APIKeyIn",
        "fastapi.security.base.SecurityBase",
        "starlette.exceptions.HTTPException",
        "starlette.requests.Request",
        "starlette.status.HTTP_403_FORBIDDEN",
        "typing_extensions.Annotated",
        "typing_extensions.Doc"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "api_key",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\security\\api_key.py",
      "line_number": 241,
      "end_line_number": 290,
      "source_code": "def __init__(\n        self,\n        *,\n        name: Annotated[str, Doc(\"Cookie name.\")],\n        scheme_name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Security scheme name.\n\n                It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Security scheme description.\n\n                It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        auto_error: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                By default, if the cookie is not provided, `APIKeyCookie` will\n                automatically cancel the request and send the client an error.\n\n                If `auto_error` is set to `False`, when the cookie is not available,\n                instead of erroring out, the dependency result will be `None`.\n\n                This is useful when you want to have optional authentication.\n\n                It is also useful when you want to have authentication that can be\n                provided in one of multiple optional ways (for example, in a cookie or\n                in an HTTP Bearer token).\n                \"\"\"\n            ),\n        ] = True,\n    ):\n        self.model: APIKey = APIKey(\n            **{\"in\": APIKeyIn.cookie},  # type: ignore[arg-type]\n            name=name,\n            description=description,\n        )\n        self.scheme_name = scheme_name or self.__class__.__name__\n        self.auto_error = auto_error",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "typing.Optional",
        "fastapi.openapi.models.APIKey",
        "fastapi.openapi.models.APIKeyIn",
        "fastapi.security.base.SecurityBase",
        "starlette.exceptions.HTTPException",
        "starlette.requests.Request",
        "starlette.status.HTTP_403_FORBIDDEN",
        "typing_extensions.Annotated",
        "typing_extensions.Doc"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "http",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\security\\http.py",
      "line_number": 70,
      "end_line_number": 80,
      "source_code": "def __init__(\n        self,\n        *,\n        scheme: str,\n        scheme_name: Optional[str] = None,\n        description: Optional[str] = None,\n        auto_error: bool = True,\n    ):\n        self.model = HTTPBaseModel(scheme=scheme, description=description)\n        self.scheme_name = scheme_name or self.__class__.__name__\n        self.auto_error = auto_error",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "binascii",
        "base64.b64decode",
        "typing.Optional",
        "fastapi.exceptions.HTTPException",
        "fastapi.openapi.models.HTTPBase",
        "fastapi.openapi.models.HTTPBearer",
        "fastapi.security.base.SecurityBase",
        "fastapi.security.utils.get_authorization_scheme_param",
        "pydantic.BaseModel",
        "starlette.requests.Request",
        "starlette.status.HTTP_401_UNAUTHORIZED",
        "starlette.status.HTTP_403_FORBIDDEN",
        "typing_extensions.Annotated",
        "typing_extensions.Doc"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "http",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\security\\http.py",
      "line_number": 130,
      "end_line_number": 185,
      "source_code": "def __init__(\n        self,\n        *,\n        scheme_name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Security scheme name.\n\n                It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        realm: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                HTTP Basic authentication realm.\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Security scheme description.\n\n                It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        auto_error: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                By default, if the HTTP Basic authentication is not provided (a\n                header), `HTTPBasic` will automatically cancel the request and send the\n                client an error.\n\n                If `auto_error` is set to `False`, when the HTTP Basic authentication\n                is not available, instead of erroring out, the dependency result will\n                be `None`.\n\n                This is useful when you want to have optional authentication.\n\n                It is also useful when you want to have authentication that can be\n                provided in one of multiple optional ways (for example, in HTTP Basic\n                authentication or in an HTTP Bearer token).\n                \"\"\"\n            ),\n        ] = True,\n    ):\n        self.model = HTTPBaseModel(scheme=\"basic\", description=description)\n        self.scheme_name = scheme_name or self.__class__.__name__\n        self.realm = realm\n        self.auto_error = auto_error",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "binascii",
        "base64.b64decode",
        "typing.Optional",
        "fastapi.exceptions.HTTPException",
        "fastapi.openapi.models.HTTPBase",
        "fastapi.openapi.models.HTTPBearer",
        "fastapi.security.base.SecurityBase",
        "fastapi.security.utils.get_authorization_scheme_param",
        "pydantic.BaseModel",
        "starlette.requests.Request",
        "starlette.status.HTTP_401_UNAUTHORIZED",
        "starlette.status.HTTP_403_FORBIDDEN",
        "typing_extensions.Annotated",
        "typing_extensions.Doc"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "http",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\security\\http.py",
      "line_number": 252,
      "end_line_number": 299,
      "source_code": "def __init__(\n        self,\n        *,\n        bearerFormat: Annotated[Optional[str], Doc(\"Bearer token format.\")] = None,\n        scheme_name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Security scheme name.\n\n                It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Security scheme description.\n\n                It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        auto_error: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                By default, if the HTTP Bearer token is not provided (in an\n                `Authorization` header), `HTTPBearer` will automatically cancel the\n                request and send the client an error.\n\n                If `auto_error` is set to `False`, when the HTTP Bearer token\n                is not available, instead of erroring out, the dependency result will\n                be `None`.\n\n                This is useful when you want to have optional authentication.\n\n                It is also useful when you want to have authentication that can be\n                provided in one of multiple optional ways (for example, in an HTTP\n                Bearer token or in a cookie).\n                \"\"\"\n            ),\n        ] = True,\n    ):\n        self.model = HTTPBearerModel(bearerFormat=bearerFormat, description=description)\n        self.scheme_name = scheme_name or self.__class__.__name__\n        self.auto_error = auto_error",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "binascii",
        "base64.b64decode",
        "typing.Optional",
        "fastapi.exceptions.HTTPException",
        "fastapi.openapi.models.HTTPBase",
        "fastapi.openapi.models.HTTPBearer",
        "fastapi.security.base.SecurityBase",
        "fastapi.security.utils.get_authorization_scheme_param",
        "pydantic.BaseModel",
        "starlette.requests.Request",
        "starlette.status.HTTP_401_UNAUTHORIZED",
        "starlette.status.HTTP_403_FORBIDDEN",
        "typing_extensions.Annotated",
        "typing_extensions.Doc"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "http",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\security\\http.py",
      "line_number": 356,
      "end_line_number": 401,
      "source_code": "def __init__(\n        self,\n        *,\n        scheme_name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Security scheme name.\n\n                It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Security scheme description.\n\n                It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        auto_error: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                By default, if the HTTP Digest is not provided, `HTTPDigest` will\n                automatically cancel the request and send the client an error.\n\n                If `auto_error` is set to `False`, when the HTTP Digest is not\n                available, instead of erroring out, the dependency result will\n                be `None`.\n\n                This is useful when you want to have optional authentication.\n\n                It is also useful when you want to have authentication that can be\n                provided in one of multiple optional ways (for example, in HTTP\n                Digest or in a cookie).\n                \"\"\"\n            ),\n        ] = True,\n    ):\n        self.model = HTTPBaseModel(scheme=\"digest\", description=description)\n        self.scheme_name = scheme_name or self.__class__.__name__\n        self.auto_error = auto_error",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "binascii",
        "base64.b64decode",
        "typing.Optional",
        "fastapi.exceptions.HTTPException",
        "fastapi.openapi.models.HTTPBase",
        "fastapi.openapi.models.HTTPBearer",
        "fastapi.security.base.SecurityBase",
        "fastapi.security.utils.get_authorization_scheme_param",
        "pydantic.BaseModel",
        "starlette.requests.Request",
        "starlette.status.HTTP_401_UNAUTHORIZED",
        "starlette.status.HTTP_403_FORBIDDEN",
        "typing_extensions.Annotated",
        "typing_extensions.Doc"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "oauth2",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\security\\oauth2.py",
      "line_number": 61,
      "end_line_number": 149,
      "source_code": "def __init__(\n        self,\n        *,\n        grant_type: Annotated[\n            Union[str, None],\n            Form(pattern=\"password\"),\n            Doc(\n                \"\"\"\n                The OAuth2 spec says it is required and MUST be the fixed string\n                \"password\". Nevertheless, this dependency class is permissive and\n                allows not passing it. If you want to enforce it, use instead the\n                `OAuth2PasswordRequestFormStrict` dependency.\n                \"\"\"\n            ),\n        ] = None,\n        username: Annotated[\n            str,\n            Form(),\n            Doc(\n                \"\"\"\n                `username` string. The OAuth2 spec requires the exact field name\n                `username`.\n                \"\"\"\n            ),\n        ],\n        password: Annotated[\n            str,\n            Form(),\n            Doc(\n                \"\"\"\n                `password` string. The OAuth2 spec requires the exact field name\n                `password\".\n                \"\"\"\n            ),\n        ],\n        scope: Annotated[\n            str,\n            Form(),\n            Doc(\n                \"\"\"\n                A single string with actually several scopes separated by spaces. Each\n                scope is also a string.\n\n                For example, a single string with:\n\n                ```python\n                \"items:read items:write users:read profile openid\"\n                ````\n\n                would represent the scopes:\n\n                * `items:read`\n                * `items:write`\n                * `users:read`\n                * `profile`\n                * `openid`\n                \"\"\"\n            ),\n        ] = \"\",\n        client_id: Annotated[\n            Union[str, None],\n            Form(),\n            Doc(\n                \"\"\"\n                If there's a `client_id`, it can be sent as part of the form fields.\n                But the OAuth2 specification recommends sending the `client_id` and\n                `client_secret` (if any) using HTTP Basic auth.\n                \"\"\"\n            ),\n        ] = None,\n        client_secret: Annotated[\n            Union[str, None],\n            Form(),\n            Doc(\n                \"\"\"\n                If there's a `client_password` (and a `client_id`), they can be sent\n                as part of the form fields. But the OAuth2 specification recommends\n                sending the `client_id` and `client_secret` (if any) using HTTP Basic\n                auth.\n                \"\"\"\n            ),\n        ] = None,\n    ):\n        self.grant_type = grant_type\n        self.username = username\n        self.password = password\n        self.scopes = scope.split()\n        self.client_id = client_id\n        self.client_secret = client_secret",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "typing.Any",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Union",
        "typing.cast",
        "fastapi.exceptions.HTTPException",
        "fastapi.openapi.models.OAuth2",
        "fastapi.openapi.models.OAuthFlows",
        "fastapi.param_functions.Form",
        "fastapi.security.base.SecurityBase",
        "fastapi.security.utils.get_authorization_scheme_param",
        "starlette.requests.Request",
        "starlette.status.HTTP_401_UNAUTHORIZED",
        "starlette.status.HTTP_403_FORBIDDEN",
        "typing_extensions.Annotated",
        "typing_extensions.Doc"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "Form",
          "body": "def Form(default: Annotated[Any, Doc('\\n            Default value if the parameter field is not set.\\n            ')]=Undefined, *, default_factory: Annotated[Union[Callable[[], Any], None], Doc(\"\\n            A callable to generate the default value.\\n\\n            This doesn't affect `Path` parameters as the value is always required.\\n            The parameter is available only for compatibility.\\n            \")]=_Unset, media_type: Annotated[str, Doc(\"\\n            The media type of this parameter field. Changing it would affect the\\n            generated OpenAPI, but currently it doesn't affect the parsing of the data.\\n            \")]='application/x-www-form-urlencoded', alias: Annotated[Optional[str], Doc(\"\\n            An alternative name for the parameter field.\\n\\n            This will be used to extract the data and for the generated OpenAPI.\\n            It is particularly useful when you can't use the name you want because it\\n            is a Python reserved keyword or similar.\\n            \")]=None, alias_priority: Annotated[Union[int, None], Doc('\\n            Priority of the alias. This affects whether an alias generator is used.\\n            ')]=_Unset, validation_alias: Annotated[Union[str, None], Doc(\"\\n            'Whitelist' validation step. The parameter field will be the single one\\n            allowed by the alias or set of aliases defined.\\n            \")]=None, serialization_alias: Annotated[Union[str, None], Doc(\"\\n            'Blacklist' validation step. The vanilla parameter field will be the\\n            single one of the alias' or set of aliases' fields and all the other\\n            fields will be ignored at serialization time.\\n            \")]=None, title: Annotated[Optional[str], Doc('\\n            Human-readable title.\\n            ')]=None, description: Annotated[Optional[str], Doc('\\n            Human-readable description.\\n            ')]=None, gt: Annotated[Optional[float], Doc('\\n            Greater than. If set, value must be greater than this. Only applicable to\\n            numbers.\\n            ')]=None, ge: Annotated[Optional[float], Doc('\\n            Greater than or equal. If set, value must be greater than or equal to\\n            this. Only applicable to numbers.\\n            ')]=None, lt: Annotated[Optional[float], Doc('\\n            Less than. If set, value must be less than this. Only applicable to numbers.\\n            ')]=None, le: Annotated[Optional[float], Doc('\\n            Less than or equal. If set, value must be less than or equal to this.\\n            Only applicable to numbers.\\n            ')]=None, min_length: Annotated[Optional[int], Doc('\\n            Minimum length for strings.\\n            ')]=None, max_length: Annotated[Optional[int], Doc('\\n            Maximum length for strings.\\n            ')]=None, pattern: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            ')]=None, regex: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            '), deprecated('Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead.')]=None, discriminator: Annotated[Union[str, None], Doc('\\n            Parameter field name for discriminating the type in a tagged union.\\n            ')]=None, strict: Annotated[Union[bool, None], Doc('\\n            If `True`, strict validation is applied to the field.\\n            ')]=_Unset, multiple_of: Annotated[Union[float, None], Doc('\\n            Value must be a multiple of this. Only applicable to numbers.\\n            ')]=_Unset, allow_inf_nan: Annotated[Union[bool, None], Doc('\\n            Allow `inf`, `-inf`, `nan`. Only applicable to numbers.\\n            ')]=_Unset, max_digits: Annotated[Union[int, None], Doc('\\n            Maximum number of allow digits for strings.\\n            ')]=_Unset, decimal_places: Annotated[Union[int, None], Doc('\\n            Maximum number of decimal places allowed for numbers.\\n            ')]=_Unset, examples: Annotated[Optional[List[Any]], Doc('\\n            Example values for this field.\\n            ')]=None, example: Annotated[Optional[Any], deprecated('Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.')]=_Unset, openapi_examples: Annotated[Optional[Dict[str, Example]], Doc(\"\\n            OpenAPI-specific examples.\\n\\n            It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n            Swagger UI (that provides the `/docs` interface) has better support for the\\n            OpenAPI-specific examples than the JSON Schema `examples`, that's the main\\n            use case for this.\\n\\n            Read more about it in the\\n            [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).\\n            \")]=None, deprecated: Annotated[Union[deprecated, str, bool, None], Doc('\\n            Mark this parameter field as deprecated.\\n\\n            It will affect the generated OpenAPI (e.g. visible at `/docs`).\\n            ')]=None, include_in_schema: Annotated[bool, Doc(\"\\n            To include (or not) this parameter field in the generated OpenAPI.\\n            You probably don't need it, but it's available.\\n\\n            This affects the generated OpenAPI (e.g. visible at `/docs`).\\n            \")]=True, json_schema_extra: Annotated[Union[Dict[str, Any], None], Doc('\\n            Any additional JSON schema data.\\n            ')]=None, **extra: Annotated[Any, Doc('\\n            Include extra fields used by the JSON Schema.\\n            '), deprecated('\\n            The `extra` kwargs is deprecated. Use `json_schema_extra` instead.\\n            ')]) -> Any:\n    return params.Form(default=default, default_factory=default_factory, media_type=media_type, alias=alias, alias_priority=alias_priority, validation_alias=validation_alias, serialization_alias=serialization_alias, title=title, description=description, gt=gt, ge=ge, lt=lt, le=le, min_length=min_length, max_length=max_length, pattern=pattern, regex=regex, discriminator=discriminator, strict=strict, multiple_of=multiple_of, allow_inf_nan=allow_inf_nan, max_digits=max_digits, decimal_places=decimal_places, example=example, examples=examples, openapi_examples=openapi_examples, deprecated=deprecated, include_in_schema=include_in_schema, json_schema_extra=json_schema_extra, **extra)"
        },
        {
          "name": "Form",
          "body": "def Form(default: Annotated[Any, Doc('\\n            Default value if the parameter field is not set.\\n            ')]=Undefined, *, default_factory: Annotated[Union[Callable[[], Any], None], Doc(\"\\n            A callable to generate the default value.\\n\\n            This doesn't affect `Path` parameters as the value is always required.\\n            The parameter is available only for compatibility.\\n            \")]=_Unset, media_type: Annotated[str, Doc(\"\\n            The media type of this parameter field. Changing it would affect the\\n            generated OpenAPI, but currently it doesn't affect the parsing of the data.\\n            \")]='application/x-www-form-urlencoded', alias: Annotated[Optional[str], Doc(\"\\n            An alternative name for the parameter field.\\n\\n            This will be used to extract the data and for the generated OpenAPI.\\n            It is particularly useful when you can't use the name you want because it\\n            is a Python reserved keyword or similar.\\n            \")]=None, alias_priority: Annotated[Union[int, None], Doc('\\n            Priority of the alias. This affects whether an alias generator is used.\\n            ')]=_Unset, validation_alias: Annotated[Union[str, None], Doc(\"\\n            'Whitelist' validation step. The parameter field will be the single one\\n            allowed by the alias or set of aliases defined.\\n            \")]=None, serialization_alias: Annotated[Union[str, None], Doc(\"\\n            'Blacklist' validation step. The vanilla parameter field will be the\\n            single one of the alias' or set of aliases' fields and all the other\\n            fields will be ignored at serialization time.\\n            \")]=None, title: Annotated[Optional[str], Doc('\\n            Human-readable title.\\n            ')]=None, description: Annotated[Optional[str], Doc('\\n            Human-readable description.\\n            ')]=None, gt: Annotated[Optional[float], Doc('\\n            Greater than. If set, value must be greater than this. Only applicable to\\n            numbers.\\n            ')]=None, ge: Annotated[Optional[float], Doc('\\n            Greater than or equal. If set, value must be greater than or equal to\\n            this. Only applicable to numbers.\\n            ')]=None, lt: Annotated[Optional[float], Doc('\\n            Less than. If set, value must be less than this. Only applicable to numbers.\\n            ')]=None, le: Annotated[Optional[float], Doc('\\n            Less than or equal. If set, value must be less than or equal to this.\\n            Only applicable to numbers.\\n            ')]=None, min_length: Annotated[Optional[int], Doc('\\n            Minimum length for strings.\\n            ')]=None, max_length: Annotated[Optional[int], Doc('\\n            Maximum length for strings.\\n            ')]=None, pattern: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            ')]=None, regex: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            '), deprecated('Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead.')]=None, discriminator: Annotated[Union[str, None], Doc('\\n            Parameter field name for discriminating the type in a tagged union.\\n            ')]=None, strict: Annotated[Union[bool, None], Doc('\\n            If `True`, strict validation is applied to the field.\\n            ')]=_Unset, multiple_of: Annotated[Union[float, None], Doc('\\n            Value must be a multiple of this. Only applicable to numbers.\\n            ')]=_Unset, allow_inf_nan: Annotated[Union[bool, None], Doc('\\n            Allow `inf`, `-inf`, `nan`. Only applicable to numbers.\\n            ')]=_Unset, max_digits: Annotated[Union[int, None], Doc('\\n            Maximum number of allow digits for strings.\\n            ')]=_Unset, decimal_places: Annotated[Union[int, None], Doc('\\n            Maximum number of decimal places allowed for numbers.\\n            ')]=_Unset, examples: Annotated[Optional[List[Any]], Doc('\\n            Example values for this field.\\n            ')]=None, example: Annotated[Optional[Any], deprecated('Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.')]=_Unset, openapi_examples: Annotated[Optional[Dict[str, Example]], Doc(\"\\n            OpenAPI-specific examples.\\n\\n            It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n            Swagger UI (that provides the `/docs` interface) has better support for the\\n            OpenAPI-specific examples than the JSON Schema `examples`, that's the main\\n            use case for this.\\n\\n            Read more about it in the\\n            [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).\\n            \")]=None, deprecated: Annotated[Union[deprecated, str, bool, None], Doc('\\n            Mark this parameter field as deprecated.\\n\\n            It will affect the generated OpenAPI (e.g. visible at `/docs`).\\n            ')]=None, include_in_schema: Annotated[bool, Doc(\"\\n            To include (or not) this parameter field in the generated OpenAPI.\\n            You probably don't need it, but it's available.\\n\\n            This affects the generated OpenAPI (e.g. visible at `/docs`).\\n            \")]=True, json_schema_extra: Annotated[Union[Dict[str, Any], None], Doc('\\n            Any additional JSON schema data.\\n            ')]=None, **extra: Annotated[Any, Doc('\\n            Include extra fields used by the JSON Schema.\\n            '), deprecated('\\n            The `extra` kwargs is deprecated. Use `json_schema_extra` instead.\\n            ')]) -> Any:\n    return params.Form(default=default, default_factory=default_factory, media_type=media_type, alias=alias, alias_priority=alias_priority, validation_alias=validation_alias, serialization_alias=serialization_alias, title=title, description=description, gt=gt, ge=ge, lt=lt, le=le, min_length=min_length, max_length=max_length, pattern=pattern, regex=regex, discriminator=discriminator, strict=strict, multiple_of=multiple_of, allow_inf_nan=allow_inf_nan, max_digits=max_digits, decimal_places=decimal_places, example=example, examples=examples, openapi_examples=openapi_examples, deprecated=deprecated, include_in_schema=include_in_schema, json_schema_extra=json_schema_extra, **extra)"
        },
        {
          "name": "Form",
          "body": "def Form(default: Annotated[Any, Doc('\\n            Default value if the parameter field is not set.\\n            ')]=Undefined, *, default_factory: Annotated[Union[Callable[[], Any], None], Doc(\"\\n            A callable to generate the default value.\\n\\n            This doesn't affect `Path` parameters as the value is always required.\\n            The parameter is available only for compatibility.\\n            \")]=_Unset, media_type: Annotated[str, Doc(\"\\n            The media type of this parameter field. Changing it would affect the\\n            generated OpenAPI, but currently it doesn't affect the parsing of the data.\\n            \")]='application/x-www-form-urlencoded', alias: Annotated[Optional[str], Doc(\"\\n            An alternative name for the parameter field.\\n\\n            This will be used to extract the data and for the generated OpenAPI.\\n            It is particularly useful when you can't use the name you want because it\\n            is a Python reserved keyword or similar.\\n            \")]=None, alias_priority: Annotated[Union[int, None], Doc('\\n            Priority of the alias. This affects whether an alias generator is used.\\n            ')]=_Unset, validation_alias: Annotated[Union[str, None], Doc(\"\\n            'Whitelist' validation step. The parameter field will be the single one\\n            allowed by the alias or set of aliases defined.\\n            \")]=None, serialization_alias: Annotated[Union[str, None], Doc(\"\\n            'Blacklist' validation step. The vanilla parameter field will be the\\n            single one of the alias' or set of aliases' fields and all the other\\n            fields will be ignored at serialization time.\\n            \")]=None, title: Annotated[Optional[str], Doc('\\n            Human-readable title.\\n            ')]=None, description: Annotated[Optional[str], Doc('\\n            Human-readable description.\\n            ')]=None, gt: Annotated[Optional[float], Doc('\\n            Greater than. If set, value must be greater than this. Only applicable to\\n            numbers.\\n            ')]=None, ge: Annotated[Optional[float], Doc('\\n            Greater than or equal. If set, value must be greater than or equal to\\n            this. Only applicable to numbers.\\n            ')]=None, lt: Annotated[Optional[float], Doc('\\n            Less than. If set, value must be less than this. Only applicable to numbers.\\n            ')]=None, le: Annotated[Optional[float], Doc('\\n            Less than or equal. If set, value must be less than or equal to this.\\n            Only applicable to numbers.\\n            ')]=None, min_length: Annotated[Optional[int], Doc('\\n            Minimum length for strings.\\n            ')]=None, max_length: Annotated[Optional[int], Doc('\\n            Maximum length for strings.\\n            ')]=None, pattern: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            ')]=None, regex: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            '), deprecated('Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead.')]=None, discriminator: Annotated[Union[str, None], Doc('\\n            Parameter field name for discriminating the type in a tagged union.\\n            ')]=None, strict: Annotated[Union[bool, None], Doc('\\n            If `True`, strict validation is applied to the field.\\n            ')]=_Unset, multiple_of: Annotated[Union[float, None], Doc('\\n            Value must be a multiple of this. Only applicable to numbers.\\n            ')]=_Unset, allow_inf_nan: Annotated[Union[bool, None], Doc('\\n            Allow `inf`, `-inf`, `nan`. Only applicable to numbers.\\n            ')]=_Unset, max_digits: Annotated[Union[int, None], Doc('\\n            Maximum number of allow digits for strings.\\n            ')]=_Unset, decimal_places: Annotated[Union[int, None], Doc('\\n            Maximum number of decimal places allowed for numbers.\\n            ')]=_Unset, examples: Annotated[Optional[List[Any]], Doc('\\n            Example values for this field.\\n            ')]=None, example: Annotated[Optional[Any], deprecated('Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.')]=_Unset, openapi_examples: Annotated[Optional[Dict[str, Example]], Doc(\"\\n            OpenAPI-specific examples.\\n\\n            It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n            Swagger UI (that provides the `/docs` interface) has better support for the\\n            OpenAPI-specific examples than the JSON Schema `examples`, that's the main\\n            use case for this.\\n\\n            Read more about it in the\\n            [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).\\n            \")]=None, deprecated: Annotated[Union[deprecated, str, bool, None], Doc('\\n            Mark this parameter field as deprecated.\\n\\n            It will affect the generated OpenAPI (e.g. visible at `/docs`).\\n            ')]=None, include_in_schema: Annotated[bool, Doc(\"\\n            To include (or not) this parameter field in the generated OpenAPI.\\n            You probably don't need it, but it's available.\\n\\n            This affects the generated OpenAPI (e.g. visible at `/docs`).\\n            \")]=True, json_schema_extra: Annotated[Union[Dict[str, Any], None], Doc('\\n            Any additional JSON schema data.\\n            ')]=None, **extra: Annotated[Any, Doc('\\n            Include extra fields used by the JSON Schema.\\n            '), deprecated('\\n            The `extra` kwargs is deprecated. Use `json_schema_extra` instead.\\n            ')]) -> Any:\n    return params.Form(default=default, default_factory=default_factory, media_type=media_type, alias=alias, alias_priority=alias_priority, validation_alias=validation_alias, serialization_alias=serialization_alias, title=title, description=description, gt=gt, ge=ge, lt=lt, le=le, min_length=min_length, max_length=max_length, pattern=pattern, regex=regex, discriminator=discriminator, strict=strict, multiple_of=multiple_of, allow_inf_nan=allow_inf_nan, max_digits=max_digits, decimal_places=decimal_places, example=example, examples=examples, openapi_examples=openapi_examples, deprecated=deprecated, include_in_schema=include_in_schema, json_schema_extra=json_schema_extra, **extra)"
        },
        {
          "name": "Form",
          "body": "def Form(default: Annotated[Any, Doc('\\n            Default value if the parameter field is not set.\\n            ')]=Undefined, *, default_factory: Annotated[Union[Callable[[], Any], None], Doc(\"\\n            A callable to generate the default value.\\n\\n            This doesn't affect `Path` parameters as the value is always required.\\n            The parameter is available only for compatibility.\\n            \")]=_Unset, media_type: Annotated[str, Doc(\"\\n            The media type of this parameter field. Changing it would affect the\\n            generated OpenAPI, but currently it doesn't affect the parsing of the data.\\n            \")]='application/x-www-form-urlencoded', alias: Annotated[Optional[str], Doc(\"\\n            An alternative name for the parameter field.\\n\\n            This will be used to extract the data and for the generated OpenAPI.\\n            It is particularly useful when you can't use the name you want because it\\n            is a Python reserved keyword or similar.\\n            \")]=None, alias_priority: Annotated[Union[int, None], Doc('\\n            Priority of the alias. This affects whether an alias generator is used.\\n            ')]=_Unset, validation_alias: Annotated[Union[str, None], Doc(\"\\n            'Whitelist' validation step. The parameter field will be the single one\\n            allowed by the alias or set of aliases defined.\\n            \")]=None, serialization_alias: Annotated[Union[str, None], Doc(\"\\n            'Blacklist' validation step. The vanilla parameter field will be the\\n            single one of the alias' or set of aliases' fields and all the other\\n            fields will be ignored at serialization time.\\n            \")]=None, title: Annotated[Optional[str], Doc('\\n            Human-readable title.\\n            ')]=None, description: Annotated[Optional[str], Doc('\\n            Human-readable description.\\n            ')]=None, gt: Annotated[Optional[float], Doc('\\n            Greater than. If set, value must be greater than this. Only applicable to\\n            numbers.\\n            ')]=None, ge: Annotated[Optional[float], Doc('\\n            Greater than or equal. If set, value must be greater than or equal to\\n            this. Only applicable to numbers.\\n            ')]=None, lt: Annotated[Optional[float], Doc('\\n            Less than. If set, value must be less than this. Only applicable to numbers.\\n            ')]=None, le: Annotated[Optional[float], Doc('\\n            Less than or equal. If set, value must be less than or equal to this.\\n            Only applicable to numbers.\\n            ')]=None, min_length: Annotated[Optional[int], Doc('\\n            Minimum length for strings.\\n            ')]=None, max_length: Annotated[Optional[int], Doc('\\n            Maximum length for strings.\\n            ')]=None, pattern: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            ')]=None, regex: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            '), deprecated('Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead.')]=None, discriminator: Annotated[Union[str, None], Doc('\\n            Parameter field name for discriminating the type in a tagged union.\\n            ')]=None, strict: Annotated[Union[bool, None], Doc('\\n            If `True`, strict validation is applied to the field.\\n            ')]=_Unset, multiple_of: Annotated[Union[float, None], Doc('\\n            Value must be a multiple of this. Only applicable to numbers.\\n            ')]=_Unset, allow_inf_nan: Annotated[Union[bool, None], Doc('\\n            Allow `inf`, `-inf`, `nan`. Only applicable to numbers.\\n            ')]=_Unset, max_digits: Annotated[Union[int, None], Doc('\\n            Maximum number of allow digits for strings.\\n            ')]=_Unset, decimal_places: Annotated[Union[int, None], Doc('\\n            Maximum number of decimal places allowed for numbers.\\n            ')]=_Unset, examples: Annotated[Optional[List[Any]], Doc('\\n            Example values for this field.\\n            ')]=None, example: Annotated[Optional[Any], deprecated('Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.')]=_Unset, openapi_examples: Annotated[Optional[Dict[str, Example]], Doc(\"\\n            OpenAPI-specific examples.\\n\\n            It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n            Swagger UI (that provides the `/docs` interface) has better support for the\\n            OpenAPI-specific examples than the JSON Schema `examples`, that's the main\\n            use case for this.\\n\\n            Read more about it in the\\n            [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).\\n            \")]=None, deprecated: Annotated[Union[deprecated, str, bool, None], Doc('\\n            Mark this parameter field as deprecated.\\n\\n            It will affect the generated OpenAPI (e.g. visible at `/docs`).\\n            ')]=None, include_in_schema: Annotated[bool, Doc(\"\\n            To include (or not) this parameter field in the generated OpenAPI.\\n            You probably don't need it, but it's available.\\n\\n            This affects the generated OpenAPI (e.g. visible at `/docs`).\\n            \")]=True, json_schema_extra: Annotated[Union[Dict[str, Any], None], Doc('\\n            Any additional JSON schema data.\\n            ')]=None, **extra: Annotated[Any, Doc('\\n            Include extra fields used by the JSON Schema.\\n            '), deprecated('\\n            The `extra` kwargs is deprecated. Use `json_schema_extra` instead.\\n            ')]) -> Any:\n    return params.Form(default=default, default_factory=default_factory, media_type=media_type, alias=alias, alias_priority=alias_priority, validation_alias=validation_alias, serialization_alias=serialization_alias, title=title, description=description, gt=gt, ge=ge, lt=lt, le=le, min_length=min_length, max_length=max_length, pattern=pattern, regex=regex, discriminator=discriminator, strict=strict, multiple_of=multiple_of, allow_inf_nan=allow_inf_nan, max_digits=max_digits, decimal_places=decimal_places, example=example, examples=examples, openapi_examples=openapi_examples, deprecated=deprecated, include_in_schema=include_in_schema, json_schema_extra=json_schema_extra, **extra)"
        },
        {
          "name": "Form",
          "body": "def Form(default: Annotated[Any, Doc('\\n            Default value if the parameter field is not set.\\n            ')]=Undefined, *, default_factory: Annotated[Union[Callable[[], Any], None], Doc(\"\\n            A callable to generate the default value.\\n\\n            This doesn't affect `Path` parameters as the value is always required.\\n            The parameter is available only for compatibility.\\n            \")]=_Unset, media_type: Annotated[str, Doc(\"\\n            The media type of this parameter field. Changing it would affect the\\n            generated OpenAPI, but currently it doesn't affect the parsing of the data.\\n            \")]='application/x-www-form-urlencoded', alias: Annotated[Optional[str], Doc(\"\\n            An alternative name for the parameter field.\\n\\n            This will be used to extract the data and for the generated OpenAPI.\\n            It is particularly useful when you can't use the name you want because it\\n            is a Python reserved keyword or similar.\\n            \")]=None, alias_priority: Annotated[Union[int, None], Doc('\\n            Priority of the alias. This affects whether an alias generator is used.\\n            ')]=_Unset, validation_alias: Annotated[Union[str, None], Doc(\"\\n            'Whitelist' validation step. The parameter field will be the single one\\n            allowed by the alias or set of aliases defined.\\n            \")]=None, serialization_alias: Annotated[Union[str, None], Doc(\"\\n            'Blacklist' validation step. The vanilla parameter field will be the\\n            single one of the alias' or set of aliases' fields and all the other\\n            fields will be ignored at serialization time.\\n            \")]=None, title: Annotated[Optional[str], Doc('\\n            Human-readable title.\\n            ')]=None, description: Annotated[Optional[str], Doc('\\n            Human-readable description.\\n            ')]=None, gt: Annotated[Optional[float], Doc('\\n            Greater than. If set, value must be greater than this. Only applicable to\\n            numbers.\\n            ')]=None, ge: Annotated[Optional[float], Doc('\\n            Greater than or equal. If set, value must be greater than or equal to\\n            this. Only applicable to numbers.\\n            ')]=None, lt: Annotated[Optional[float], Doc('\\n            Less than. If set, value must be less than this. Only applicable to numbers.\\n            ')]=None, le: Annotated[Optional[float], Doc('\\n            Less than or equal. If set, value must be less than or equal to this.\\n            Only applicable to numbers.\\n            ')]=None, min_length: Annotated[Optional[int], Doc('\\n            Minimum length for strings.\\n            ')]=None, max_length: Annotated[Optional[int], Doc('\\n            Maximum length for strings.\\n            ')]=None, pattern: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            ')]=None, regex: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            '), deprecated('Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead.')]=None, discriminator: Annotated[Union[str, None], Doc('\\n            Parameter field name for discriminating the type in a tagged union.\\n            ')]=None, strict: Annotated[Union[bool, None], Doc('\\n            If `True`, strict validation is applied to the field.\\n            ')]=_Unset, multiple_of: Annotated[Union[float, None], Doc('\\n            Value must be a multiple of this. Only applicable to numbers.\\n            ')]=_Unset, allow_inf_nan: Annotated[Union[bool, None], Doc('\\n            Allow `inf`, `-inf`, `nan`. Only applicable to numbers.\\n            ')]=_Unset, max_digits: Annotated[Union[int, None], Doc('\\n            Maximum number of allow digits for strings.\\n            ')]=_Unset, decimal_places: Annotated[Union[int, None], Doc('\\n            Maximum number of decimal places allowed for numbers.\\n            ')]=_Unset, examples: Annotated[Optional[List[Any]], Doc('\\n            Example values for this field.\\n            ')]=None, example: Annotated[Optional[Any], deprecated('Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.')]=_Unset, openapi_examples: Annotated[Optional[Dict[str, Example]], Doc(\"\\n            OpenAPI-specific examples.\\n\\n            It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n            Swagger UI (that provides the `/docs` interface) has better support for the\\n            OpenAPI-specific examples than the JSON Schema `examples`, that's the main\\n            use case for this.\\n\\n            Read more about it in the\\n            [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).\\n            \")]=None, deprecated: Annotated[Union[deprecated, str, bool, None], Doc('\\n            Mark this parameter field as deprecated.\\n\\n            It will affect the generated OpenAPI (e.g. visible at `/docs`).\\n            ')]=None, include_in_schema: Annotated[bool, Doc(\"\\n            To include (or not) this parameter field in the generated OpenAPI.\\n            You probably don't need it, but it's available.\\n\\n            This affects the generated OpenAPI (e.g. visible at `/docs`).\\n            \")]=True, json_schema_extra: Annotated[Union[Dict[str, Any], None], Doc('\\n            Any additional JSON schema data.\\n            ')]=None, **extra: Annotated[Any, Doc('\\n            Include extra fields used by the JSON Schema.\\n            '), deprecated('\\n            The `extra` kwargs is deprecated. Use `json_schema_extra` instead.\\n            ')]) -> Any:\n    return params.Form(default=default, default_factory=default_factory, media_type=media_type, alias=alias, alias_priority=alias_priority, validation_alias=validation_alias, serialization_alias=serialization_alias, title=title, description=description, gt=gt, ge=ge, lt=lt, le=le, min_length=min_length, max_length=max_length, pattern=pattern, regex=regex, discriminator=discriminator, strict=strict, multiple_of=multiple_of, allow_inf_nan=allow_inf_nan, max_digits=max_digits, decimal_places=decimal_places, example=example, examples=examples, openapi_examples=openapi_examples, deprecated=deprecated, include_in_schema=include_in_schema, json_schema_extra=json_schema_extra, **extra)"
        },
        {
          "name": "Form",
          "body": "def Form(default: Annotated[Any, Doc('\\n            Default value if the parameter field is not set.\\n            ')]=Undefined, *, default_factory: Annotated[Union[Callable[[], Any], None], Doc(\"\\n            A callable to generate the default value.\\n\\n            This doesn't affect `Path` parameters as the value is always required.\\n            The parameter is available only for compatibility.\\n            \")]=_Unset, media_type: Annotated[str, Doc(\"\\n            The media type of this parameter field. Changing it would affect the\\n            generated OpenAPI, but currently it doesn't affect the parsing of the data.\\n            \")]='application/x-www-form-urlencoded', alias: Annotated[Optional[str], Doc(\"\\n            An alternative name for the parameter field.\\n\\n            This will be used to extract the data and for the generated OpenAPI.\\n            It is particularly useful when you can't use the name you want because it\\n            is a Python reserved keyword or similar.\\n            \")]=None, alias_priority: Annotated[Union[int, None], Doc('\\n            Priority of the alias. This affects whether an alias generator is used.\\n            ')]=_Unset, validation_alias: Annotated[Union[str, None], Doc(\"\\n            'Whitelist' validation step. The parameter field will be the single one\\n            allowed by the alias or set of aliases defined.\\n            \")]=None, serialization_alias: Annotated[Union[str, None], Doc(\"\\n            'Blacklist' validation step. The vanilla parameter field will be the\\n            single one of the alias' or set of aliases' fields and all the other\\n            fields will be ignored at serialization time.\\n            \")]=None, title: Annotated[Optional[str], Doc('\\n            Human-readable title.\\n            ')]=None, description: Annotated[Optional[str], Doc('\\n            Human-readable description.\\n            ')]=None, gt: Annotated[Optional[float], Doc('\\n            Greater than. If set, value must be greater than this. Only applicable to\\n            numbers.\\n            ')]=None, ge: Annotated[Optional[float], Doc('\\n            Greater than or equal. If set, value must be greater than or equal to\\n            this. Only applicable to numbers.\\n            ')]=None, lt: Annotated[Optional[float], Doc('\\n            Less than. If set, value must be less than this. Only applicable to numbers.\\n            ')]=None, le: Annotated[Optional[float], Doc('\\n            Less than or equal. If set, value must be less than or equal to this.\\n            Only applicable to numbers.\\n            ')]=None, min_length: Annotated[Optional[int], Doc('\\n            Minimum length for strings.\\n            ')]=None, max_length: Annotated[Optional[int], Doc('\\n            Maximum length for strings.\\n            ')]=None, pattern: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            ')]=None, regex: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            '), deprecated('Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead.')]=None, discriminator: Annotated[Union[str, None], Doc('\\n            Parameter field name for discriminating the type in a tagged union.\\n            ')]=None, strict: Annotated[Union[bool, None], Doc('\\n            If `True`, strict validation is applied to the field.\\n            ')]=_Unset, multiple_of: Annotated[Union[float, None], Doc('\\n            Value must be a multiple of this. Only applicable to numbers.\\n            ')]=_Unset, allow_inf_nan: Annotated[Union[bool, None], Doc('\\n            Allow `inf`, `-inf`, `nan`. Only applicable to numbers.\\n            ')]=_Unset, max_digits: Annotated[Union[int, None], Doc('\\n            Maximum number of allow digits for strings.\\n            ')]=_Unset, decimal_places: Annotated[Union[int, None], Doc('\\n            Maximum number of decimal places allowed for numbers.\\n            ')]=_Unset, examples: Annotated[Optional[List[Any]], Doc('\\n            Example values for this field.\\n            ')]=None, example: Annotated[Optional[Any], deprecated('Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.')]=_Unset, openapi_examples: Annotated[Optional[Dict[str, Example]], Doc(\"\\n            OpenAPI-specific examples.\\n\\n            It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n            Swagger UI (that provides the `/docs` interface) has better support for the\\n            OpenAPI-specific examples than the JSON Schema `examples`, that's the main\\n            use case for this.\\n\\n            Read more about it in the\\n            [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).\\n            \")]=None, deprecated: Annotated[Union[deprecated, str, bool, None], Doc('\\n            Mark this parameter field as deprecated.\\n\\n            It will affect the generated OpenAPI (e.g. visible at `/docs`).\\n            ')]=None, include_in_schema: Annotated[bool, Doc(\"\\n            To include (or not) this parameter field in the generated OpenAPI.\\n            You probably don't need it, but it's available.\\n\\n            This affects the generated OpenAPI (e.g. visible at `/docs`).\\n            \")]=True, json_schema_extra: Annotated[Union[Dict[str, Any], None], Doc('\\n            Any additional JSON schema data.\\n            ')]=None, **extra: Annotated[Any, Doc('\\n            Include extra fields used by the JSON Schema.\\n            '), deprecated('\\n            The `extra` kwargs is deprecated. Use `json_schema_extra` instead.\\n            ')]) -> Any:\n    return params.Form(default=default, default_factory=default_factory, media_type=media_type, alias=alias, alias_priority=alias_priority, validation_alias=validation_alias, serialization_alias=serialization_alias, title=title, description=description, gt=gt, ge=ge, lt=lt, le=le, min_length=min_length, max_length=max_length, pattern=pattern, regex=regex, discriminator=discriminator, strict=strict, multiple_of=multiple_of, allow_inf_nan=allow_inf_nan, max_digits=max_digits, decimal_places=decimal_places, example=example, examples=examples, openapi_examples=openapi_examples, deprecated=deprecated, include_in_schema=include_in_schema, json_schema_extra=json_schema_extra, **extra)"
        }
      ]
    },
    {
      "name": "__init__",
      "module": "oauth2",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\security\\oauth2.py",
      "line_number": 216,
      "end_line_number": 305,
      "source_code": "def __init__(\n        self,\n        grant_type: Annotated[\n            str,\n            Form(pattern=\"password\"),\n            Doc(\n                \"\"\"\n                The OAuth2 spec says it is required and MUST be the fixed string\n                \"password\". This dependency is strict about it. If you want to be\n                permissive, use instead the `OAuth2PasswordRequestForm` dependency\n                class.\n                \"\"\"\n            ),\n        ],\n        username: Annotated[\n            str,\n            Form(),\n            Doc(\n                \"\"\"\n                `username` string. The OAuth2 spec requires the exact field name\n                `username`.\n                \"\"\"\n            ),\n        ],\n        password: Annotated[\n            str,\n            Form(),\n            Doc(\n                \"\"\"\n                `password` string. The OAuth2 spec requires the exact field name\n                `password\".\n                \"\"\"\n            ),\n        ],\n        scope: Annotated[\n            str,\n            Form(),\n            Doc(\n                \"\"\"\n                A single string with actually several scopes separated by spaces. Each\n                scope is also a string.\n\n                For example, a single string with:\n\n                ```python\n                \"items:read items:write users:read profile openid\"\n                ````\n\n                would represent the scopes:\n\n                * `items:read`\n                * `items:write`\n                * `users:read`\n                * `profile`\n                * `openid`\n                \"\"\"\n            ),\n        ] = \"\",\n        client_id: Annotated[\n            Union[str, None],\n            Form(),\n            Doc(\n                \"\"\"\n                If there's a `client_id`, it can be sent as part of the form fields.\n                But the OAuth2 specification recommends sending the `client_id` and\n                `client_secret` (if any) using HTTP Basic auth.\n                \"\"\"\n            ),\n        ] = None,\n        client_secret: Annotated[\n            Union[str, None],\n            Form(),\n            Doc(\n                \"\"\"\n                If there's a `client_password` (and a `client_id`), they can be sent\n                as part of the form fields. But the OAuth2 specification recommends\n                sending the `client_id` and `client_secret` (if any) using HTTP Basic\n                auth.\n                \"\"\"\n            ),\n        ] = None,\n    ):\n        super().__init__(\n            grant_type=grant_type,\n            username=username,\n            password=password,\n            scope=scope,\n            client_id=client_id,\n            client_secret=client_secret,\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "grant_type",
        "username",
        "password",
        "scope",
        "client_id",
        "client_secret"
      ],
      "imports": [
        "typing.Any",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Union",
        "typing.cast",
        "fastapi.exceptions.HTTPException",
        "fastapi.openapi.models.OAuth2",
        "fastapi.openapi.models.OAuthFlows",
        "fastapi.param_functions.Form",
        "fastapi.security.base.SecurityBase",
        "fastapi.security.utils.get_authorization_scheme_param",
        "starlette.requests.Request",
        "starlette.status.HTTP_401_UNAUTHORIZED",
        "starlette.status.HTTP_403_FORBIDDEN",
        "typing_extensions.Annotated",
        "typing_extensions.Doc"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "Form",
          "body": "def Form(default: Annotated[Any, Doc('\\n            Default value if the parameter field is not set.\\n            ')]=Undefined, *, default_factory: Annotated[Union[Callable[[], Any], None], Doc(\"\\n            A callable to generate the default value.\\n\\n            This doesn't affect `Path` parameters as the value is always required.\\n            The parameter is available only for compatibility.\\n            \")]=_Unset, media_type: Annotated[str, Doc(\"\\n            The media type of this parameter field. Changing it would affect the\\n            generated OpenAPI, but currently it doesn't affect the parsing of the data.\\n            \")]='application/x-www-form-urlencoded', alias: Annotated[Optional[str], Doc(\"\\n            An alternative name for the parameter field.\\n\\n            This will be used to extract the data and for the generated OpenAPI.\\n            It is particularly useful when you can't use the name you want because it\\n            is a Python reserved keyword or similar.\\n            \")]=None, alias_priority: Annotated[Union[int, None], Doc('\\n            Priority of the alias. This affects whether an alias generator is used.\\n            ')]=_Unset, validation_alias: Annotated[Union[str, None], Doc(\"\\n            'Whitelist' validation step. The parameter field will be the single one\\n            allowed by the alias or set of aliases defined.\\n            \")]=None, serialization_alias: Annotated[Union[str, None], Doc(\"\\n            'Blacklist' validation step. The vanilla parameter field will be the\\n            single one of the alias' or set of aliases' fields and all the other\\n            fields will be ignored at serialization time.\\n            \")]=None, title: Annotated[Optional[str], Doc('\\n            Human-readable title.\\n            ')]=None, description: Annotated[Optional[str], Doc('\\n            Human-readable description.\\n            ')]=None, gt: Annotated[Optional[float], Doc('\\n            Greater than. If set, value must be greater than this. Only applicable to\\n            numbers.\\n            ')]=None, ge: Annotated[Optional[float], Doc('\\n            Greater than or equal. If set, value must be greater than or equal to\\n            this. Only applicable to numbers.\\n            ')]=None, lt: Annotated[Optional[float], Doc('\\n            Less than. If set, value must be less than this. Only applicable to numbers.\\n            ')]=None, le: Annotated[Optional[float], Doc('\\n            Less than or equal. If set, value must be less than or equal to this.\\n            Only applicable to numbers.\\n            ')]=None, min_length: Annotated[Optional[int], Doc('\\n            Minimum length for strings.\\n            ')]=None, max_length: Annotated[Optional[int], Doc('\\n            Maximum length for strings.\\n            ')]=None, pattern: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            ')]=None, regex: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            '), deprecated('Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead.')]=None, discriminator: Annotated[Union[str, None], Doc('\\n            Parameter field name for discriminating the type in a tagged union.\\n            ')]=None, strict: Annotated[Union[bool, None], Doc('\\n            If `True`, strict validation is applied to the field.\\n            ')]=_Unset, multiple_of: Annotated[Union[float, None], Doc('\\n            Value must be a multiple of this. Only applicable to numbers.\\n            ')]=_Unset, allow_inf_nan: Annotated[Union[bool, None], Doc('\\n            Allow `inf`, `-inf`, `nan`. Only applicable to numbers.\\n            ')]=_Unset, max_digits: Annotated[Union[int, None], Doc('\\n            Maximum number of allow digits for strings.\\n            ')]=_Unset, decimal_places: Annotated[Union[int, None], Doc('\\n            Maximum number of decimal places allowed for numbers.\\n            ')]=_Unset, examples: Annotated[Optional[List[Any]], Doc('\\n            Example values for this field.\\n            ')]=None, example: Annotated[Optional[Any], deprecated('Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.')]=_Unset, openapi_examples: Annotated[Optional[Dict[str, Example]], Doc(\"\\n            OpenAPI-specific examples.\\n\\n            It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n            Swagger UI (that provides the `/docs` interface) has better support for the\\n            OpenAPI-specific examples than the JSON Schema `examples`, that's the main\\n            use case for this.\\n\\n            Read more about it in the\\n            [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).\\n            \")]=None, deprecated: Annotated[Union[deprecated, str, bool, None], Doc('\\n            Mark this parameter field as deprecated.\\n\\n            It will affect the generated OpenAPI (e.g. visible at `/docs`).\\n            ')]=None, include_in_schema: Annotated[bool, Doc(\"\\n            To include (or not) this parameter field in the generated OpenAPI.\\n            You probably don't need it, but it's available.\\n\\n            This affects the generated OpenAPI (e.g. visible at `/docs`).\\n            \")]=True, json_schema_extra: Annotated[Union[Dict[str, Any], None], Doc('\\n            Any additional JSON schema data.\\n            ')]=None, **extra: Annotated[Any, Doc('\\n            Include extra fields used by the JSON Schema.\\n            '), deprecated('\\n            The `extra` kwargs is deprecated. Use `json_schema_extra` instead.\\n            ')]) -> Any:\n    return params.Form(default=default, default_factory=default_factory, media_type=media_type, alias=alias, alias_priority=alias_priority, validation_alias=validation_alias, serialization_alias=serialization_alias, title=title, description=description, gt=gt, ge=ge, lt=lt, le=le, min_length=min_length, max_length=max_length, pattern=pattern, regex=regex, discriminator=discriminator, strict=strict, multiple_of=multiple_of, allow_inf_nan=allow_inf_nan, max_digits=max_digits, decimal_places=decimal_places, example=example, examples=examples, openapi_examples=openapi_examples, deprecated=deprecated, include_in_schema=include_in_schema, json_schema_extra=json_schema_extra, **extra)"
        },
        {
          "name": "Form",
          "body": "def Form(default: Annotated[Any, Doc('\\n            Default value if the parameter field is not set.\\n            ')]=Undefined, *, default_factory: Annotated[Union[Callable[[], Any], None], Doc(\"\\n            A callable to generate the default value.\\n\\n            This doesn't affect `Path` parameters as the value is always required.\\n            The parameter is available only for compatibility.\\n            \")]=_Unset, media_type: Annotated[str, Doc(\"\\n            The media type of this parameter field. Changing it would affect the\\n            generated OpenAPI, but currently it doesn't affect the parsing of the data.\\n            \")]='application/x-www-form-urlencoded', alias: Annotated[Optional[str], Doc(\"\\n            An alternative name for the parameter field.\\n\\n            This will be used to extract the data and for the generated OpenAPI.\\n            It is particularly useful when you can't use the name you want because it\\n            is a Python reserved keyword or similar.\\n            \")]=None, alias_priority: Annotated[Union[int, None], Doc('\\n            Priority of the alias. This affects whether an alias generator is used.\\n            ')]=_Unset, validation_alias: Annotated[Union[str, None], Doc(\"\\n            'Whitelist' validation step. The parameter field will be the single one\\n            allowed by the alias or set of aliases defined.\\n            \")]=None, serialization_alias: Annotated[Union[str, None], Doc(\"\\n            'Blacklist' validation step. The vanilla parameter field will be the\\n            single one of the alias' or set of aliases' fields and all the other\\n            fields will be ignored at serialization time.\\n            \")]=None, title: Annotated[Optional[str], Doc('\\n            Human-readable title.\\n            ')]=None, description: Annotated[Optional[str], Doc('\\n            Human-readable description.\\n            ')]=None, gt: Annotated[Optional[float], Doc('\\n            Greater than. If set, value must be greater than this. Only applicable to\\n            numbers.\\n            ')]=None, ge: Annotated[Optional[float], Doc('\\n            Greater than or equal. If set, value must be greater than or equal to\\n            this. Only applicable to numbers.\\n            ')]=None, lt: Annotated[Optional[float], Doc('\\n            Less than. If set, value must be less than this. Only applicable to numbers.\\n            ')]=None, le: Annotated[Optional[float], Doc('\\n            Less than or equal. If set, value must be less than or equal to this.\\n            Only applicable to numbers.\\n            ')]=None, min_length: Annotated[Optional[int], Doc('\\n            Minimum length for strings.\\n            ')]=None, max_length: Annotated[Optional[int], Doc('\\n            Maximum length for strings.\\n            ')]=None, pattern: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            ')]=None, regex: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            '), deprecated('Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead.')]=None, discriminator: Annotated[Union[str, None], Doc('\\n            Parameter field name for discriminating the type in a tagged union.\\n            ')]=None, strict: Annotated[Union[bool, None], Doc('\\n            If `True`, strict validation is applied to the field.\\n            ')]=_Unset, multiple_of: Annotated[Union[float, None], Doc('\\n            Value must be a multiple of this. Only applicable to numbers.\\n            ')]=_Unset, allow_inf_nan: Annotated[Union[bool, None], Doc('\\n            Allow `inf`, `-inf`, `nan`. Only applicable to numbers.\\n            ')]=_Unset, max_digits: Annotated[Union[int, None], Doc('\\n            Maximum number of allow digits for strings.\\n            ')]=_Unset, decimal_places: Annotated[Union[int, None], Doc('\\n            Maximum number of decimal places allowed for numbers.\\n            ')]=_Unset, examples: Annotated[Optional[List[Any]], Doc('\\n            Example values for this field.\\n            ')]=None, example: Annotated[Optional[Any], deprecated('Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.')]=_Unset, openapi_examples: Annotated[Optional[Dict[str, Example]], Doc(\"\\n            OpenAPI-specific examples.\\n\\n            It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n            Swagger UI (that provides the `/docs` interface) has better support for the\\n            OpenAPI-specific examples than the JSON Schema `examples`, that's the main\\n            use case for this.\\n\\n            Read more about it in the\\n            [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).\\n            \")]=None, deprecated: Annotated[Union[deprecated, str, bool, None], Doc('\\n            Mark this parameter field as deprecated.\\n\\n            It will affect the generated OpenAPI (e.g. visible at `/docs`).\\n            ')]=None, include_in_schema: Annotated[bool, Doc(\"\\n            To include (or not) this parameter field in the generated OpenAPI.\\n            You probably don't need it, but it's available.\\n\\n            This affects the generated OpenAPI (e.g. visible at `/docs`).\\n            \")]=True, json_schema_extra: Annotated[Union[Dict[str, Any], None], Doc('\\n            Any additional JSON schema data.\\n            ')]=None, **extra: Annotated[Any, Doc('\\n            Include extra fields used by the JSON Schema.\\n            '), deprecated('\\n            The `extra` kwargs is deprecated. Use `json_schema_extra` instead.\\n            ')]) -> Any:\n    return params.Form(default=default, default_factory=default_factory, media_type=media_type, alias=alias, alias_priority=alias_priority, validation_alias=validation_alias, serialization_alias=serialization_alias, title=title, description=description, gt=gt, ge=ge, lt=lt, le=le, min_length=min_length, max_length=max_length, pattern=pattern, regex=regex, discriminator=discriminator, strict=strict, multiple_of=multiple_of, allow_inf_nan=allow_inf_nan, max_digits=max_digits, decimal_places=decimal_places, example=example, examples=examples, openapi_examples=openapi_examples, deprecated=deprecated, include_in_schema=include_in_schema, json_schema_extra=json_schema_extra, **extra)"
        },
        {
          "name": "Form",
          "body": "def Form(default: Annotated[Any, Doc('\\n            Default value if the parameter field is not set.\\n            ')]=Undefined, *, default_factory: Annotated[Union[Callable[[], Any], None], Doc(\"\\n            A callable to generate the default value.\\n\\n            This doesn't affect `Path` parameters as the value is always required.\\n            The parameter is available only for compatibility.\\n            \")]=_Unset, media_type: Annotated[str, Doc(\"\\n            The media type of this parameter field. Changing it would affect the\\n            generated OpenAPI, but currently it doesn't affect the parsing of the data.\\n            \")]='application/x-www-form-urlencoded', alias: Annotated[Optional[str], Doc(\"\\n            An alternative name for the parameter field.\\n\\n            This will be used to extract the data and for the generated OpenAPI.\\n            It is particularly useful when you can't use the name you want because it\\n            is a Python reserved keyword or similar.\\n            \")]=None, alias_priority: Annotated[Union[int, None], Doc('\\n            Priority of the alias. This affects whether an alias generator is used.\\n            ')]=_Unset, validation_alias: Annotated[Union[str, None], Doc(\"\\n            'Whitelist' validation step. The parameter field will be the single one\\n            allowed by the alias or set of aliases defined.\\n            \")]=None, serialization_alias: Annotated[Union[str, None], Doc(\"\\n            'Blacklist' validation step. The vanilla parameter field will be the\\n            single one of the alias' or set of aliases' fields and all the other\\n            fields will be ignored at serialization time.\\n            \")]=None, title: Annotated[Optional[str], Doc('\\n            Human-readable title.\\n            ')]=None, description: Annotated[Optional[str], Doc('\\n            Human-readable description.\\n            ')]=None, gt: Annotated[Optional[float], Doc('\\n            Greater than. If set, value must be greater than this. Only applicable to\\n            numbers.\\n            ')]=None, ge: Annotated[Optional[float], Doc('\\n            Greater than or equal. If set, value must be greater than or equal to\\n            this. Only applicable to numbers.\\n            ')]=None, lt: Annotated[Optional[float], Doc('\\n            Less than. If set, value must be less than this. Only applicable to numbers.\\n            ')]=None, le: Annotated[Optional[float], Doc('\\n            Less than or equal. If set, value must be less than or equal to this.\\n            Only applicable to numbers.\\n            ')]=None, min_length: Annotated[Optional[int], Doc('\\n            Minimum length for strings.\\n            ')]=None, max_length: Annotated[Optional[int], Doc('\\n            Maximum length for strings.\\n            ')]=None, pattern: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            ')]=None, regex: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            '), deprecated('Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead.')]=None, discriminator: Annotated[Union[str, None], Doc('\\n            Parameter field name for discriminating the type in a tagged union.\\n            ')]=None, strict: Annotated[Union[bool, None], Doc('\\n            If `True`, strict validation is applied to the field.\\n            ')]=_Unset, multiple_of: Annotated[Union[float, None], Doc('\\n            Value must be a multiple of this. Only applicable to numbers.\\n            ')]=_Unset, allow_inf_nan: Annotated[Union[bool, None], Doc('\\n            Allow `inf`, `-inf`, `nan`. Only applicable to numbers.\\n            ')]=_Unset, max_digits: Annotated[Union[int, None], Doc('\\n            Maximum number of allow digits for strings.\\n            ')]=_Unset, decimal_places: Annotated[Union[int, None], Doc('\\n            Maximum number of decimal places allowed for numbers.\\n            ')]=_Unset, examples: Annotated[Optional[List[Any]], Doc('\\n            Example values for this field.\\n            ')]=None, example: Annotated[Optional[Any], deprecated('Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.')]=_Unset, openapi_examples: Annotated[Optional[Dict[str, Example]], Doc(\"\\n            OpenAPI-specific examples.\\n\\n            It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n            Swagger UI (that provides the `/docs` interface) has better support for the\\n            OpenAPI-specific examples than the JSON Schema `examples`, that's the main\\n            use case for this.\\n\\n            Read more about it in the\\n            [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).\\n            \")]=None, deprecated: Annotated[Union[deprecated, str, bool, None], Doc('\\n            Mark this parameter field as deprecated.\\n\\n            It will affect the generated OpenAPI (e.g. visible at `/docs`).\\n            ')]=None, include_in_schema: Annotated[bool, Doc(\"\\n            To include (or not) this parameter field in the generated OpenAPI.\\n            You probably don't need it, but it's available.\\n\\n            This affects the generated OpenAPI (e.g. visible at `/docs`).\\n            \")]=True, json_schema_extra: Annotated[Union[Dict[str, Any], None], Doc('\\n            Any additional JSON schema data.\\n            ')]=None, **extra: Annotated[Any, Doc('\\n            Include extra fields used by the JSON Schema.\\n            '), deprecated('\\n            The `extra` kwargs is deprecated. Use `json_schema_extra` instead.\\n            ')]) -> Any:\n    return params.Form(default=default, default_factory=default_factory, media_type=media_type, alias=alias, alias_priority=alias_priority, validation_alias=validation_alias, serialization_alias=serialization_alias, title=title, description=description, gt=gt, ge=ge, lt=lt, le=le, min_length=min_length, max_length=max_length, pattern=pattern, regex=regex, discriminator=discriminator, strict=strict, multiple_of=multiple_of, allow_inf_nan=allow_inf_nan, max_digits=max_digits, decimal_places=decimal_places, example=example, examples=examples, openapi_examples=openapi_examples, deprecated=deprecated, include_in_schema=include_in_schema, json_schema_extra=json_schema_extra, **extra)"
        },
        {
          "name": "Form",
          "body": "def Form(default: Annotated[Any, Doc('\\n            Default value if the parameter field is not set.\\n            ')]=Undefined, *, default_factory: Annotated[Union[Callable[[], Any], None], Doc(\"\\n            A callable to generate the default value.\\n\\n            This doesn't affect `Path` parameters as the value is always required.\\n            The parameter is available only for compatibility.\\n            \")]=_Unset, media_type: Annotated[str, Doc(\"\\n            The media type of this parameter field. Changing it would affect the\\n            generated OpenAPI, but currently it doesn't affect the parsing of the data.\\n            \")]='application/x-www-form-urlencoded', alias: Annotated[Optional[str], Doc(\"\\n            An alternative name for the parameter field.\\n\\n            This will be used to extract the data and for the generated OpenAPI.\\n            It is particularly useful when you can't use the name you want because it\\n            is a Python reserved keyword or similar.\\n            \")]=None, alias_priority: Annotated[Union[int, None], Doc('\\n            Priority of the alias. This affects whether an alias generator is used.\\n            ')]=_Unset, validation_alias: Annotated[Union[str, None], Doc(\"\\n            'Whitelist' validation step. The parameter field will be the single one\\n            allowed by the alias or set of aliases defined.\\n            \")]=None, serialization_alias: Annotated[Union[str, None], Doc(\"\\n            'Blacklist' validation step. The vanilla parameter field will be the\\n            single one of the alias' or set of aliases' fields and all the other\\n            fields will be ignored at serialization time.\\n            \")]=None, title: Annotated[Optional[str], Doc('\\n            Human-readable title.\\n            ')]=None, description: Annotated[Optional[str], Doc('\\n            Human-readable description.\\n            ')]=None, gt: Annotated[Optional[float], Doc('\\n            Greater than. If set, value must be greater than this. Only applicable to\\n            numbers.\\n            ')]=None, ge: Annotated[Optional[float], Doc('\\n            Greater than or equal. If set, value must be greater than or equal to\\n            this. Only applicable to numbers.\\n            ')]=None, lt: Annotated[Optional[float], Doc('\\n            Less than. If set, value must be less than this. Only applicable to numbers.\\n            ')]=None, le: Annotated[Optional[float], Doc('\\n            Less than or equal. If set, value must be less than or equal to this.\\n            Only applicable to numbers.\\n            ')]=None, min_length: Annotated[Optional[int], Doc('\\n            Minimum length for strings.\\n            ')]=None, max_length: Annotated[Optional[int], Doc('\\n            Maximum length for strings.\\n            ')]=None, pattern: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            ')]=None, regex: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            '), deprecated('Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead.')]=None, discriminator: Annotated[Union[str, None], Doc('\\n            Parameter field name for discriminating the type in a tagged union.\\n            ')]=None, strict: Annotated[Union[bool, None], Doc('\\n            If `True`, strict validation is applied to the field.\\n            ')]=_Unset, multiple_of: Annotated[Union[float, None], Doc('\\n            Value must be a multiple of this. Only applicable to numbers.\\n            ')]=_Unset, allow_inf_nan: Annotated[Union[bool, None], Doc('\\n            Allow `inf`, `-inf`, `nan`. Only applicable to numbers.\\n            ')]=_Unset, max_digits: Annotated[Union[int, None], Doc('\\n            Maximum number of allow digits for strings.\\n            ')]=_Unset, decimal_places: Annotated[Union[int, None], Doc('\\n            Maximum number of decimal places allowed for numbers.\\n            ')]=_Unset, examples: Annotated[Optional[List[Any]], Doc('\\n            Example values for this field.\\n            ')]=None, example: Annotated[Optional[Any], deprecated('Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.')]=_Unset, openapi_examples: Annotated[Optional[Dict[str, Example]], Doc(\"\\n            OpenAPI-specific examples.\\n\\n            It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n            Swagger UI (that provides the `/docs` interface) has better support for the\\n            OpenAPI-specific examples than the JSON Schema `examples`, that's the main\\n            use case for this.\\n\\n            Read more about it in the\\n            [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).\\n            \")]=None, deprecated: Annotated[Union[deprecated, str, bool, None], Doc('\\n            Mark this parameter field as deprecated.\\n\\n            It will affect the generated OpenAPI (e.g. visible at `/docs`).\\n            ')]=None, include_in_schema: Annotated[bool, Doc(\"\\n            To include (or not) this parameter field in the generated OpenAPI.\\n            You probably don't need it, but it's available.\\n\\n            This affects the generated OpenAPI (e.g. visible at `/docs`).\\n            \")]=True, json_schema_extra: Annotated[Union[Dict[str, Any], None], Doc('\\n            Any additional JSON schema data.\\n            ')]=None, **extra: Annotated[Any, Doc('\\n            Include extra fields used by the JSON Schema.\\n            '), deprecated('\\n            The `extra` kwargs is deprecated. Use `json_schema_extra` instead.\\n            ')]) -> Any:\n    return params.Form(default=default, default_factory=default_factory, media_type=media_type, alias=alias, alias_priority=alias_priority, validation_alias=validation_alias, serialization_alias=serialization_alias, title=title, description=description, gt=gt, ge=ge, lt=lt, le=le, min_length=min_length, max_length=max_length, pattern=pattern, regex=regex, discriminator=discriminator, strict=strict, multiple_of=multiple_of, allow_inf_nan=allow_inf_nan, max_digits=max_digits, decimal_places=decimal_places, example=example, examples=examples, openapi_examples=openapi_examples, deprecated=deprecated, include_in_schema=include_in_schema, json_schema_extra=json_schema_extra, **extra)"
        },
        {
          "name": "Form",
          "body": "def Form(default: Annotated[Any, Doc('\\n            Default value if the parameter field is not set.\\n            ')]=Undefined, *, default_factory: Annotated[Union[Callable[[], Any], None], Doc(\"\\n            A callable to generate the default value.\\n\\n            This doesn't affect `Path` parameters as the value is always required.\\n            The parameter is available only for compatibility.\\n            \")]=_Unset, media_type: Annotated[str, Doc(\"\\n            The media type of this parameter field. Changing it would affect the\\n            generated OpenAPI, but currently it doesn't affect the parsing of the data.\\n            \")]='application/x-www-form-urlencoded', alias: Annotated[Optional[str], Doc(\"\\n            An alternative name for the parameter field.\\n\\n            This will be used to extract the data and for the generated OpenAPI.\\n            It is particularly useful when you can't use the name you want because it\\n            is a Python reserved keyword or similar.\\n            \")]=None, alias_priority: Annotated[Union[int, None], Doc('\\n            Priority of the alias. This affects whether an alias generator is used.\\n            ')]=_Unset, validation_alias: Annotated[Union[str, None], Doc(\"\\n            'Whitelist' validation step. The parameter field will be the single one\\n            allowed by the alias or set of aliases defined.\\n            \")]=None, serialization_alias: Annotated[Union[str, None], Doc(\"\\n            'Blacklist' validation step. The vanilla parameter field will be the\\n            single one of the alias' or set of aliases' fields and all the other\\n            fields will be ignored at serialization time.\\n            \")]=None, title: Annotated[Optional[str], Doc('\\n            Human-readable title.\\n            ')]=None, description: Annotated[Optional[str], Doc('\\n            Human-readable description.\\n            ')]=None, gt: Annotated[Optional[float], Doc('\\n            Greater than. If set, value must be greater than this. Only applicable to\\n            numbers.\\n            ')]=None, ge: Annotated[Optional[float], Doc('\\n            Greater than or equal. If set, value must be greater than or equal to\\n            this. Only applicable to numbers.\\n            ')]=None, lt: Annotated[Optional[float], Doc('\\n            Less than. If set, value must be less than this. Only applicable to numbers.\\n            ')]=None, le: Annotated[Optional[float], Doc('\\n            Less than or equal. If set, value must be less than or equal to this.\\n            Only applicable to numbers.\\n            ')]=None, min_length: Annotated[Optional[int], Doc('\\n            Minimum length for strings.\\n            ')]=None, max_length: Annotated[Optional[int], Doc('\\n            Maximum length for strings.\\n            ')]=None, pattern: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            ')]=None, regex: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            '), deprecated('Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead.')]=None, discriminator: Annotated[Union[str, None], Doc('\\n            Parameter field name for discriminating the type in a tagged union.\\n            ')]=None, strict: Annotated[Union[bool, None], Doc('\\n            If `True`, strict validation is applied to the field.\\n            ')]=_Unset, multiple_of: Annotated[Union[float, None], Doc('\\n            Value must be a multiple of this. Only applicable to numbers.\\n            ')]=_Unset, allow_inf_nan: Annotated[Union[bool, None], Doc('\\n            Allow `inf`, `-inf`, `nan`. Only applicable to numbers.\\n            ')]=_Unset, max_digits: Annotated[Union[int, None], Doc('\\n            Maximum number of allow digits for strings.\\n            ')]=_Unset, decimal_places: Annotated[Union[int, None], Doc('\\n            Maximum number of decimal places allowed for numbers.\\n            ')]=_Unset, examples: Annotated[Optional[List[Any]], Doc('\\n            Example values for this field.\\n            ')]=None, example: Annotated[Optional[Any], deprecated('Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.')]=_Unset, openapi_examples: Annotated[Optional[Dict[str, Example]], Doc(\"\\n            OpenAPI-specific examples.\\n\\n            It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n            Swagger UI (that provides the `/docs` interface) has better support for the\\n            OpenAPI-specific examples than the JSON Schema `examples`, that's the main\\n            use case for this.\\n\\n            Read more about it in the\\n            [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).\\n            \")]=None, deprecated: Annotated[Union[deprecated, str, bool, None], Doc('\\n            Mark this parameter field as deprecated.\\n\\n            It will affect the generated OpenAPI (e.g. visible at `/docs`).\\n            ')]=None, include_in_schema: Annotated[bool, Doc(\"\\n            To include (or not) this parameter field in the generated OpenAPI.\\n            You probably don't need it, but it's available.\\n\\n            This affects the generated OpenAPI (e.g. visible at `/docs`).\\n            \")]=True, json_schema_extra: Annotated[Union[Dict[str, Any], None], Doc('\\n            Any additional JSON schema data.\\n            ')]=None, **extra: Annotated[Any, Doc('\\n            Include extra fields used by the JSON Schema.\\n            '), deprecated('\\n            The `extra` kwargs is deprecated. Use `json_schema_extra` instead.\\n            ')]) -> Any:\n    return params.Form(default=default, default_factory=default_factory, media_type=media_type, alias=alias, alias_priority=alias_priority, validation_alias=validation_alias, serialization_alias=serialization_alias, title=title, description=description, gt=gt, ge=ge, lt=lt, le=le, min_length=min_length, max_length=max_length, pattern=pattern, regex=regex, discriminator=discriminator, strict=strict, multiple_of=multiple_of, allow_inf_nan=allow_inf_nan, max_digits=max_digits, decimal_places=decimal_places, example=example, examples=examples, openapi_examples=openapi_examples, deprecated=deprecated, include_in_schema=include_in_schema, json_schema_extra=json_schema_extra, **extra)"
        },
        {
          "name": "Form",
          "body": "def Form(default: Annotated[Any, Doc('\\n            Default value if the parameter field is not set.\\n            ')]=Undefined, *, default_factory: Annotated[Union[Callable[[], Any], None], Doc(\"\\n            A callable to generate the default value.\\n\\n            This doesn't affect `Path` parameters as the value is always required.\\n            The parameter is available only for compatibility.\\n            \")]=_Unset, media_type: Annotated[str, Doc(\"\\n            The media type of this parameter field. Changing it would affect the\\n            generated OpenAPI, but currently it doesn't affect the parsing of the data.\\n            \")]='application/x-www-form-urlencoded', alias: Annotated[Optional[str], Doc(\"\\n            An alternative name for the parameter field.\\n\\n            This will be used to extract the data and for the generated OpenAPI.\\n            It is particularly useful when you can't use the name you want because it\\n            is a Python reserved keyword or similar.\\n            \")]=None, alias_priority: Annotated[Union[int, None], Doc('\\n            Priority of the alias. This affects whether an alias generator is used.\\n            ')]=_Unset, validation_alias: Annotated[Union[str, None], Doc(\"\\n            'Whitelist' validation step. The parameter field will be the single one\\n            allowed by the alias or set of aliases defined.\\n            \")]=None, serialization_alias: Annotated[Union[str, None], Doc(\"\\n            'Blacklist' validation step. The vanilla parameter field will be the\\n            single one of the alias' or set of aliases' fields and all the other\\n            fields will be ignored at serialization time.\\n            \")]=None, title: Annotated[Optional[str], Doc('\\n            Human-readable title.\\n            ')]=None, description: Annotated[Optional[str], Doc('\\n            Human-readable description.\\n            ')]=None, gt: Annotated[Optional[float], Doc('\\n            Greater than. If set, value must be greater than this. Only applicable to\\n            numbers.\\n            ')]=None, ge: Annotated[Optional[float], Doc('\\n            Greater than or equal. If set, value must be greater than or equal to\\n            this. Only applicable to numbers.\\n            ')]=None, lt: Annotated[Optional[float], Doc('\\n            Less than. If set, value must be less than this. Only applicable to numbers.\\n            ')]=None, le: Annotated[Optional[float], Doc('\\n            Less than or equal. If set, value must be less than or equal to this.\\n            Only applicable to numbers.\\n            ')]=None, min_length: Annotated[Optional[int], Doc('\\n            Minimum length for strings.\\n            ')]=None, max_length: Annotated[Optional[int], Doc('\\n            Maximum length for strings.\\n            ')]=None, pattern: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            ')]=None, regex: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            '), deprecated('Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead.')]=None, discriminator: Annotated[Union[str, None], Doc('\\n            Parameter field name for discriminating the type in a tagged union.\\n            ')]=None, strict: Annotated[Union[bool, None], Doc('\\n            If `True`, strict validation is applied to the field.\\n            ')]=_Unset, multiple_of: Annotated[Union[float, None], Doc('\\n            Value must be a multiple of this. Only applicable to numbers.\\n            ')]=_Unset, allow_inf_nan: Annotated[Union[bool, None], Doc('\\n            Allow `inf`, `-inf`, `nan`. Only applicable to numbers.\\n            ')]=_Unset, max_digits: Annotated[Union[int, None], Doc('\\n            Maximum number of allow digits for strings.\\n            ')]=_Unset, decimal_places: Annotated[Union[int, None], Doc('\\n            Maximum number of decimal places allowed for numbers.\\n            ')]=_Unset, examples: Annotated[Optional[List[Any]], Doc('\\n            Example values for this field.\\n            ')]=None, example: Annotated[Optional[Any], deprecated('Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.')]=_Unset, openapi_examples: Annotated[Optional[Dict[str, Example]], Doc(\"\\n            OpenAPI-specific examples.\\n\\n            It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n            Swagger UI (that provides the `/docs` interface) has better support for the\\n            OpenAPI-specific examples than the JSON Schema `examples`, that's the main\\n            use case for this.\\n\\n            Read more about it in the\\n            [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).\\n            \")]=None, deprecated: Annotated[Union[deprecated, str, bool, None], Doc('\\n            Mark this parameter field as deprecated.\\n\\n            It will affect the generated OpenAPI (e.g. visible at `/docs`).\\n            ')]=None, include_in_schema: Annotated[bool, Doc(\"\\n            To include (or not) this parameter field in the generated OpenAPI.\\n            You probably don't need it, but it's available.\\n\\n            This affects the generated OpenAPI (e.g. visible at `/docs`).\\n            \")]=True, json_schema_extra: Annotated[Union[Dict[str, Any], None], Doc('\\n            Any additional JSON schema data.\\n            ')]=None, **extra: Annotated[Any, Doc('\\n            Include extra fields used by the JSON Schema.\\n            '), deprecated('\\n            The `extra` kwargs is deprecated. Use `json_schema_extra` instead.\\n            ')]) -> Any:\n    return params.Form(default=default, default_factory=default_factory, media_type=media_type, alias=alias, alias_priority=alias_priority, validation_alias=validation_alias, serialization_alias=serialization_alias, title=title, description=description, gt=gt, ge=ge, lt=lt, le=le, min_length=min_length, max_length=max_length, pattern=pattern, regex=regex, discriminator=discriminator, strict=strict, multiple_of=multiple_of, allow_inf_nan=allow_inf_nan, max_digits=max_digits, decimal_places=decimal_places, example=example, examples=examples, openapi_examples=openapi_examples, deprecated=deprecated, include_in_schema=include_in_schema, json_schema_extra=json_schema_extra, **extra)"
        }
      ]
    },
    {
      "name": "__init__",
      "module": "oauth2",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\security\\oauth2.py",
      "line_number": 321,
      "end_line_number": 377,
      "source_code": "def __init__(\n        self,\n        *,\n        flows: Annotated[\n            Union[OAuthFlowsModel, Dict[str, Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                The dictionary of OAuth2 flows.\n                \"\"\"\n            ),\n        ] = OAuthFlowsModel(),\n        scheme_name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Security scheme name.\n\n                It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Security scheme description.\n\n                It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        auto_error: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                By default, if no HTTP Authorization header is provided, required for\n                OAuth2 authentication, it will automatically cancel the request and\n                send the client an error.\n\n                If `auto_error` is set to `False`, when the HTTP Authorization header\n                is not available, instead of erroring out, the dependency result will\n                be `None`.\n\n                This is useful when you want to have optional authentication.\n\n                It is also useful when you want to have authentication that can be\n                provided in one of multiple optional ways (for example, with OAuth2\n                or in a cookie).\n                \"\"\"\n            ),\n        ] = True,\n    ):\n        self.model = OAuth2Model(\n            flows=cast(OAuthFlowsModel, flows), description=description\n        )\n        self.scheme_name = scheme_name or self.__class__.__name__\n        self.auto_error = auto_error",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "typing.Any",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Union",
        "typing.cast",
        "fastapi.exceptions.HTTPException",
        "fastapi.openapi.models.OAuth2",
        "fastapi.openapi.models.OAuthFlows",
        "fastapi.param_functions.Form",
        "fastapi.security.base.SecurityBase",
        "fastapi.security.utils.get_authorization_scheme_param",
        "starlette.requests.Request",
        "starlette.status.HTTP_401_UNAUTHORIZED",
        "starlette.status.HTTP_403_FORBIDDEN",
        "typing_extensions.Annotated",
        "typing_extensions.Doc"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "oauth2",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\security\\oauth2.py",
      "line_number": 400,
      "end_line_number": 471,
      "source_code": "def __init__(\n        self,\n        tokenUrl: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The URL to obtain the OAuth2 token. This would be the *path operation*\n                that has `OAuth2PasswordRequestForm` as a dependency.\n                \"\"\"\n            ),\n        ],\n        scheme_name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Security scheme name.\n\n                It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        scopes: Annotated[\n            Optional[Dict[str, str]],\n            Doc(\n                \"\"\"\n                The OAuth2 scopes that would be required by the *path operations* that\n                use this dependency.\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Security scheme description.\n\n                It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        auto_error: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                By default, if no HTTP Authorization header is provided, required for\n                OAuth2 authentication, it will automatically cancel the request and\n                send the client an error.\n\n                If `auto_error` is set to `False`, when the HTTP Authorization header\n                is not available, instead of erroring out, the dependency result will\n                be `None`.\n\n                This is useful when you want to have optional authentication.\n\n                It is also useful when you want to have authentication that can be\n                provided in one of multiple optional ways (for example, with OAuth2\n                or in a cookie).\n                \"\"\"\n            ),\n        ] = True,\n    ):\n        if not scopes:\n            scopes = {}\n        flows = OAuthFlowsModel(\n            password=cast(Any, {\"tokenUrl\": tokenUrl, \"scopes\": scopes})\n        )\n        super().__init__(\n            flows=flows,\n            scheme_name=scheme_name,\n            description=description,\n            auto_error=auto_error,\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "tokenUrl",
        "scheme_name",
        "scopes",
        "description",
        "auto_error"
      ],
      "imports": [
        "typing.Any",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Union",
        "typing.cast",
        "fastapi.exceptions.HTTPException",
        "fastapi.openapi.models.OAuth2",
        "fastapi.openapi.models.OAuthFlows",
        "fastapi.param_functions.Form",
        "fastapi.security.base.SecurityBase",
        "fastapi.security.utils.get_authorization_scheme_param",
        "starlette.requests.Request",
        "starlette.status.HTTP_401_UNAUTHORIZED",
        "starlette.status.HTTP_403_FORBIDDEN",
        "typing_extensions.Annotated",
        "typing_extensions.Doc"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "oauth2",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\security\\oauth2.py",
      "line_number": 494,
      "end_line_number": 581,
      "source_code": "def __init__(\n        self,\n        authorizationUrl: str,\n        tokenUrl: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The URL to obtain the OAuth2 token.\n                \"\"\"\n            ),\n        ],\n        refreshUrl: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                The URL to refresh the token and obtain a new one.\n                \"\"\"\n            ),\n        ] = None,\n        scheme_name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Security scheme name.\n\n                It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        scopes: Annotated[\n            Optional[Dict[str, str]],\n            Doc(\n                \"\"\"\n                The OAuth2 scopes that would be required by the *path operations* that\n                use this dependency.\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Security scheme description.\n\n                It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        auto_error: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                By default, if no HTTP Authorization header is provided, required for\n                OAuth2 authentication, it will automatically cancel the request and\n                send the client an error.\n\n                If `auto_error` is set to `False`, when the HTTP Authorization header\n                is not available, instead of erroring out, the dependency result will\n                be `None`.\n\n                This is useful when you want to have optional authentication.\n\n                It is also useful when you want to have authentication that can be\n                provided in one of multiple optional ways (for example, with OAuth2\n                or in a cookie).\n                \"\"\"\n            ),\n        ] = True,\n    ):\n        if not scopes:\n            scopes = {}\n        flows = OAuthFlowsModel(\n            authorizationCode=cast(\n                Any,\n                {\n                    \"authorizationUrl\": authorizationUrl,\n                    \"tokenUrl\": tokenUrl,\n                    \"refreshUrl\": refreshUrl,\n                    \"scopes\": scopes,\n                },\n            )\n        )\n        super().__init__(\n            flows=flows,\n            scheme_name=scheme_name,\n            description=description,\n            auto_error=auto_error,\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "authorizationUrl",
        "tokenUrl",
        "refreshUrl",
        "scheme_name",
        "scopes",
        "description",
        "auto_error"
      ],
      "imports": [
        "typing.Any",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Union",
        "typing.cast",
        "fastapi.exceptions.HTTPException",
        "fastapi.openapi.models.OAuth2",
        "fastapi.openapi.models.OAuthFlows",
        "fastapi.param_functions.Form",
        "fastapi.security.base.SecurityBase",
        "fastapi.security.utils.get_authorization_scheme_param",
        "starlette.requests.Request",
        "starlette.status.HTTP_401_UNAUTHORIZED",
        "starlette.status.HTTP_403_FORBIDDEN",
        "typing_extensions.Annotated",
        "typing_extensions.Doc"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "oauth2",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\security\\oauth2.py",
      "line_number": 611,
      "end_line_number": 638,
      "source_code": "def __init__(\n        self,\n        scopes: Annotated[\n            Optional[List[str]],\n            Doc(\n                \"\"\"\n                This will be filled by FastAPI.\n                \"\"\"\n            ),\n        ] = None,\n    ):\n        self.scopes: Annotated[\n            List[str],\n            Doc(\n                \"\"\"\n                The list of all the scopes required by dependencies.\n                \"\"\"\n            ),\n        ] = scopes or []\n        self.scope_str: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                All the scopes required by all the dependencies in a single string\n                separated by spaces, as defined in the OAuth2 specification.\n                \"\"\"\n            ),\n        ] = \" \".join(self.scopes)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self",
        "scopes"
      ],
      "imports": [
        "typing.Any",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Union",
        "typing.cast",
        "fastapi.exceptions.HTTPException",
        "fastapi.openapi.models.OAuth2",
        "fastapi.openapi.models.OAuthFlows",
        "fastapi.param_functions.Form",
        "fastapi.security.base.SecurityBase",
        "fastapi.security.utils.get_authorization_scheme_param",
        "starlette.requests.Request",
        "starlette.status.HTTP_401_UNAUTHORIZED",
        "starlette.status.HTTP_403_FORBIDDEN",
        "typing_extensions.Annotated",
        "typing_extensions.Doc"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "__init__",
      "module": "open_id_connect_url",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\security\\open_id_connect_url.py",
      "line_number": 17,
      "end_line_number": 73,
      "source_code": "def __init__(\n        self,\n        *,\n        openIdConnectUrl: Annotated[\n            str,\n            Doc(\n                \"\"\"\n            The OpenID Connect URL.\n            \"\"\"\n            ),\n        ],\n        scheme_name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Security scheme name.\n\n                It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Security scheme description.\n\n                It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        auto_error: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                By default, if no HTTP Authorization header is provided, required for\n                OpenID Connect authentication, it will automatically cancel the request\n                and send the client an error.\n\n                If `auto_error` is set to `False`, when the HTTP Authorization header\n                is not available, instead of erroring out, the dependency result will\n                be `None`.\n\n                This is useful when you want to have optional authentication.\n\n                It is also useful when you want to have authentication that can be\n                provided in one of multiple optional ways (for example, with OpenID\n                Connect or in a cookie).\n                \"\"\"\n            ),\n        ] = True,\n    ):\n        self.model = OpenIdConnectModel(\n            openIdConnectUrl=openIdConnectUrl, description=description\n        )\n        self.scheme_name = scheme_name or self.__class__.__name__\n        self.auto_error = auto_error",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "self"
      ],
      "imports": [
        "typing.Optional",
        "fastapi.openapi.models.OpenIdConnect",
        "fastapi.security.base.SecurityBase",
        "starlette.exceptions.HTTPException",
        "starlette.requests.Request",
        "starlette.status.HTTP_403_FORBIDDEN",
        "typing_extensions.Annotated",
        "typing_extensions.Doc"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "get_authorization_scheme_param",
      "module": "utils",
      "class_name": null,
      "file_path": "..\\data\\fastapi\\fastapi\\security\\utils.py",
      "line_number": 4,
      "end_line_number": 10,
      "source_code": "def get_authorization_scheme_param(\n    authorization_header_value: Optional[str],\n) -> Tuple[str, str]:\n    if not authorization_header_value:\n        return \"\", \"\"\n    scheme, _, param = authorization_header_value.partition(\" \")\n    return scheme, param",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "authorization_header_value"
      ],
      "imports": [
        "typing.Optional",
        "typing.Tuple"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    }
  ]
}