{
  "tests": [
    {
      "name": "test_simple_url_for_getting",
      "module": "test_url_building",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_building.py",
      "line_number": 55,
      "end_line_number": 62,
      "source_code": "def test_simple_url_for_getting(simple_app):\n    for letter in string.ascii_letters:\n        url = simple_app.url_for(letter)\n\n        assert url == f\"/{letter}\"\n        request, response = simple_app.test_client.get(url)\n        assert response.status == 200\n        assert response.text == letter",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "simple_app"
      ],
      "imports": [
        "string",
        "urllib.parse.parse_qsl",
        "urllib.parse.urlsplit",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert url == f'/{letter}'",
        "assert response.status == 200",
        "assert response.text == letter"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "simple_app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "simple_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_simple_url_for_getting_with_more_params",
      "module": "test_url_building",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_building.py",
      "line_number": 74,
      "end_line_number": 82,
      "source_code": "def test_simple_url_for_getting_with_more_params(app, args, url):\n    @app.route(\"/myurl\")\n    def passes(request):\n        return text(\"this should pass\")\n\n    assert url == app.url_for(\"passes\", **args)\n    request, response = app.test_client.get(url)\n    assert response.status == 200\n    assert response.text == \"this should pass\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('args,url', [(URL_FOR_ARGS1, URL_FOR_VALUE1), (URL_FOR_ARGS2, URL_FOR_VALUE2), (URL_FOR_ARGS3, URL_FOR_VALUE3), (URL_FOR_ARGS4, URL_FOR_VALUE4)])"
      ],
      "arguments": [
        "app",
        "args",
        "url"
      ],
      "imports": [
        "string",
        "urllib.parse.parse_qsl",
        "urllib.parse.urlsplit",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert url == app.url_for('passes', **args)",
        "assert response.status == 200",
        "assert response.text == 'this should pass'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_url_for_with_server_name",
      "module": "test_url_building",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_building.py",
      "line_number": 85,
      "end_line_number": 98,
      "source_code": "def test_url_for_with_server_name(app):\n    server_name = f\"{test_host}:{test_port}\"\n    app.config.update({\"SERVER_NAME\": server_name})\n    path = \"/myurl\"\n\n    @app.route(path)\n    def passes(request):\n        return text(\"this should pass\")\n\n    url = f\"http://{server_name}{path}\"\n    assert url == app.url_for(\"passes\", _server=None, _external=True)\n    request, response = app.test_client.get(url)\n    assert response.status == 200\n    assert response.text == \"this should pass\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "string",
        "urllib.parse.parse_qsl",
        "urllib.parse.urlsplit",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert url == app.url_for('passes', _server=None, _external=True)",
        "assert response.status == 200",
        "assert response.text == 'this should pass'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_fails_if_endpoint_not_found",
      "module": "test_url_building",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_building.py",
      "line_number": 101,
      "end_line_number": 110,
      "source_code": "def test_fails_if_endpoint_not_found():\n    app = Sanic(\"app\")\n\n    @app.route(\"/fail\")\n    def fail(request):\n        return text(\"this should fail\")\n\n    with pytest.raises(URLBuildError) as e:\n        app.url_for(\"passes\")\n        e.match(\"Endpoint with name `app.passes` was not found\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "string",
        "urllib.parse.parse_qsl",
        "urllib.parse.urlsplit",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_fails_url_build_if_param_not_passed",
      "module": "test_url_building",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_building.py",
      "line_number": 113,
      "end_line_number": 130,
      "source_code": "def test_fails_url_build_if_param_not_passed(app):\n    url = \"/\"\n\n    for letter in string.ascii_lowercase:\n        url += f\"<{letter}>/\"\n\n    @app.route(url)\n    def fail(request):\n        return text(\"this should fail\")\n\n    fail_args = list(string.ascii_lowercase)\n    fail_args.pop()\n\n    fail_kwargs = {fail_arg: fail_arg for fail_arg in fail_args}\n\n    with pytest.raises(URLBuildError) as e:\n        app.url_for(\"fail\", **fail_kwargs)\n        assert e.match(\"Required parameter `z` was not passed to url_for\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "string",
        "urllib.parse.parse_qsl",
        "urllib.parse.urlsplit",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert e.match('Required parameter `z` was not passed to url_for')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_fails_url_build_if_params_not_passed",
      "module": "test_url_building",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_building.py",
      "line_number": 133,
      "end_line_number": 140,
      "source_code": "def test_fails_url_build_if_params_not_passed(app):\n    @app.route(\"/fail\")\n    def fail(request):\n        return text(\"this should fail\")\n\n    with pytest.raises(ValueError) as e:\n        app.url_for(\"fail\", _scheme=\"http\")\n        assert e.match(\"When specifying _scheme, _external must be True\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "string",
        "urllib.parse.parse_qsl",
        "urllib.parse.urlsplit",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert e.match('When specifying _scheme, _external must be True')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_fails_with_int_message",
      "module": "test_url_building",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_building.py",
      "line_number": 157,
      "end_line_number": 172,
      "source_code": "def test_fails_with_int_message(app):\n    @app.route(COMPLEX_PARAM_URL)\n    def fail(request):\n        return text(\"this should fail\")\n\n    failing_kwargs = dict(PASSING_KWARGS)\n    failing_kwargs[\"foo\"] = \"not_int\"\n\n    with pytest.raises(URLBuildError) as e:\n        app.url_for(\"fail\", **failing_kwargs)\n\n    expected_error = (\n        r'Value \"not_int\" for parameter `foo` '\n        r\"does not match pattern for type `int`: ^-?\\d+$\"\n    )\n    assert str(e.value) == expected_error",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "string",
        "urllib.parse.parse_qsl",
        "urllib.parse.urlsplit",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(e.value) == expected_error"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_passes_with_negative_int_message",
      "module": "test_url_building",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_building.py",
      "line_number": 175,
      "end_line_number": 188,
      "source_code": "def test_passes_with_negative_int_message(app):\n    @app.route(\"path/<possibly_neg:int>/another-word\")\n    def good(request, possibly_neg):\n        assert isinstance(possibly_neg, int)\n        return text(f\"this should pass with `{possibly_neg}`\")\n\n    u_plus_3 = app.url_for(\"good\", possibly_neg=3)\n    assert u_plus_3 == \"/path/3/another-word\", u_plus_3\n    request, response = app.test_client.get(u_plus_3)\n    assert response.text == \"this should pass with `3`\"\n    u_neg_3 = app.url_for(\"good\", possibly_neg=-3)\n    assert u_neg_3 == \"/path/-3/another-word\", u_neg_3\n    request, response = app.test_client.get(u_neg_3)\n    assert response.text == \"this should pass with `-3`\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "string",
        "urllib.parse.parse_qsl",
        "urllib.parse.urlsplit",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert u_plus_3 == '/path/3/another-word', u_plus_3",
        "assert response.text == 'this should pass with `3`'",
        "assert u_neg_3 == '/path/-3/another-word', u_neg_3",
        "assert response.text == 'this should pass with `-3`'",
        "assert isinstance(possibly_neg, int)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_fails_with_two_letter_string_message",
      "module": "test_url_building",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_building.py",
      "line_number": 191,
      "end_line_number": 204,
      "source_code": "def test_fails_with_two_letter_string_message(app):\n    @app.route(COMPLEX_PARAM_URL)\n    def fail(request):\n        return text(\"this should fail\")\n\n    failing_kwargs = dict(PASSING_KWARGS)\n    failing_kwargs[\"two_letter_string\"] = \"foobar\"\n\n    with pytest.raises(URLBuildError) as e:\n        app.url_for(\"fail\", **failing_kwargs)\n        e.match(\n            'Value \"foobar\" for parameter `two_letter_string` '\n            \"does not satisfy pattern ^[A-z]{2}$\"\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "string",
        "urllib.parse.parse_qsl",
        "urllib.parse.urlsplit",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_fails_with_number_message",
      "module": "test_url_building",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_building.py",
      "line_number": 207,
      "end_line_number": 221,
      "source_code": "def test_fails_with_number_message(app):\n    @app.route(COMPLEX_PARAM_URL)\n    def fail(request):\n        return text(\"this should fail\")\n\n    failing_kwargs = dict(PASSING_KWARGS)\n    failing_kwargs[\"some_number\"] = \"foo\"\n\n    with pytest.raises(URLBuildError) as e:\n        app.url_for(\"fail\", **failing_kwargs)\n        e.match(\n            'Value \"foo\" for parameter `some_number` '\n            r\"does not match pattern for type \"\n            r\"`float`: ^-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)$\"\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "string",
        "urllib.parse.parse_qsl",
        "urllib.parse.urlsplit",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_passes_with_negative_number_message",
      "module": "test_url_building",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_building.py",
      "line_number": 225,
      "end_line_number": 235,
      "source_code": "def test_passes_with_negative_number_message(app, number):\n    @app.route(\"path/<possibly_neg:float>/another-word\")\n    def good(request, possibly_neg):\n        assert isinstance(possibly_neg, (int, float))\n        return text(f\"this should pass with `{possibly_neg}`\")\n\n    u = app.url_for(\"good\", possibly_neg=number)\n    assert u == f\"/path/{number}/another-word\", u\n    request, response = app.test_client.get(u)\n    # For ``number``,it has been cast to a float - so a ``3`` becomes a ``3.0``\n    assert response.text == f\"this should pass with `{float(number)}`\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('number', [3, -3, 13.123, -13.123])"
      ],
      "arguments": [
        "app",
        "number"
      ],
      "imports": [
        "string",
        "urllib.parse.parse_qsl",
        "urllib.parse.urlsplit",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert u == f'/path/{number}/another-word', u",
        "assert response.text == f'this should pass with `{float(number)}`'",
        "assert isinstance(possibly_neg, (int, float))"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_adds_other_supplied_values_as_query_string",
      "module": "test_url_building",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_building.py",
      "line_number": 238,
      "end_line_number": 252,
      "source_code": "def test_adds_other_supplied_values_as_query_string(app):\n    @app.route(COMPLEX_PARAM_URL)\n    def passes(request):\n        return text(\"this should pass\")\n\n    new_kwargs = dict(PASSING_KWARGS)\n    new_kwargs[\"added_value_one\"] = \"one\"\n    new_kwargs[\"added_value_two\"] = \"two\"\n\n    url = app.url_for(\"passes\", **new_kwargs)\n\n    query = dict(parse_qsl(urlsplit(url).query))\n\n    assert query[\"added_value_one\"] == \"one\"\n    assert query[\"added_value_two\"] == \"two\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "string",
        "urllib.parse.parse_qsl",
        "urllib.parse.urlsplit",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert query['added_value_one'] == 'one'",
        "assert query['added_value_two'] == 'two'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_blueprints_are_named_correctly",
      "module": "test_url_building",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_building.py",
      "line_number": 284,
      "end_line_number": 289,
      "source_code": "def test_blueprints_are_named_correctly(blueprint_app):\n    first_url = blueprint_app.url_for(\"first.foo\")\n    assert first_url == \"/first/foo\"\n\n    second_url = blueprint_app.url_for(\"second.bar\")\n    assert second_url == \"/second/foo\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "blueprint_app"
      ],
      "imports": [
        "string",
        "urllib.parse.parse_qsl",
        "urllib.parse.urlsplit",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert first_url == '/first/foo'",
        "assert second_url == '/second/foo'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "blueprint_app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "blueprint_app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_blueprints_work_with_params",
      "module": "test_url_building",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_building.py",
      "line_number": 292,
      "end_line_number": 297,
      "source_code": "def test_blueprints_work_with_params(blueprint_app):\n    first_url = blueprint_app.url_for(\"first.foo_with_param\", param=\"bar\")\n    assert first_url == \"/first/foo/bar\"\n\n    second_url = blueprint_app.url_for(\"second.bar_with_param\", param=\"bar\")\n    assert second_url == \"/second/foo/bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "blueprint_app"
      ],
      "imports": [
        "string",
        "urllib.parse.parse_qsl",
        "urllib.parse.urlsplit",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert first_url == '/first/foo/bar'",
        "assert second_url == '/second/foo/bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "blueprint_app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "blueprint_app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_methodview_naming",
      "module": "test_url_building",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_building.py",
      "line_number": 341,
      "end_line_number": 346,
      "source_code": "def test_methodview_naming(methodview_app):\n    viewone_url = methodview_app.url_for(\"ViewOne\")\n    viewtwo_url = methodview_app.url_for(\"ViewTwo\")\n\n    assert viewone_url == \"/view_one\"\n    assert viewtwo_url == \"/view_two\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "methodview_app"
      ],
      "imports": [
        "string",
        "urllib.parse.parse_qsl",
        "urllib.parse.urlsplit",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert viewone_url == '/view_one'",
        "assert viewtwo_url == '/view_two'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "methodview_app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "methodview_app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_versioning",
      "module": "test_url_building",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_building.py",
      "line_number": 360,
      "end_line_number": 365,
      "source_code": "def test_versioning(app, path, version, expected):\n    @app.route(path, version=version)\n    def handler(*_): ...\n\n    url = app.url_for(\"handler\")\n    assert url == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('path,version,expected', (('/foo', 1, '/v1/foo'), ('/foo', 1.1, '/v1.1/foo'), ('/foo', '1', '/v1/foo'), ('/foo', '1.1', '/v1.1/foo'), ('/foo', '1.0.1', '/v1.0.1/foo'), ('/foo', 'v1.0.1', '/v1.0.1/foo')))"
      ],
      "arguments": [
        "app",
        "path",
        "version",
        "expected"
      ],
      "imports": [
        "string",
        "urllib.parse.parse_qsl",
        "urllib.parse.urlsplit",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert url == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_test_client_port_none",
      "module": "test_test_client_port",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_test_client_port.py",
      "line_number": 11,
      "end_line_number": 22,
      "source_code": "def test_test_client_port_none(app):\n    @app.get(\"/get\")\n    def handler(request):\n        return text(\"OK\")\n\n    test_client = SanicTestClient(app, port=None)\n\n    request, response = test_client.get(\"/get\")\n    assert response.text == \"OK\"\n\n    request, response = test_client.post(\"/get\")\n    assert response.status == 405",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert response.status == 405"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_test_client_port_default",
      "module": "test_test_client_port",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_test_client_port.py",
      "line_number": 25,
      "end_line_number": 35,
      "source_code": "def test_test_client_port_default(app):\n    @app.get(\"/get\")\n    def handler(request):\n        return json(request.transport.get_extra_info(\"sockname\")[1])\n\n    test_client = SanicTestClient(app)\n    assert test_client.port == PORT  # Can be None before request\n\n    request, response = test_client.get(\"/get\")\n    assert test_client.port > 0\n    assert response.json == test_client.port",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert test_client.port == PORT",
        "assert test_client.port > 0",
        "assert response.json == test_client.port"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_payload_too_large_from_error_handler",
      "module": "test_payload_too_large",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_payload_too_large.py",
      "line_number": 5,
      "end_line_number": 18,
      "source_code": "def test_payload_too_large_from_error_handler(app):\n    app.config.REQUEST_MAX_SIZE = 1\n\n    @app.route(\"/1\")\n    async def handler1(request):\n        return text(\"OK\")\n\n    @app.exception(PayloadTooLarge)\n    def handler_exception(request, exception):\n        return text(\"Payload Too Large from error_handler.\", 413)\n\n    _, response = app.test_client.get(\"/1\", gather_request=False)\n    assert response.status == 413\n    assert response.text == \"Payload Too Large from error_handler.\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "sanic.exceptions.PayloadTooLarge",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 413",
        "assert response.text == 'Payload Too Large from error_handler.'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.exception",
          "body": "@app.route('/')\ndef exception(request):\n    raise SanicExceptionTestException(\"You won't see me\")"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_payload_too_large_at_data_received_default",
      "module": "test_payload_too_large",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_payload_too_large.py",
      "line_number": 21,
      "end_line_number": 30,
      "source_code": "def test_payload_too_large_at_data_received_default(app):\n    app.config.REQUEST_MAX_SIZE = 1\n\n    @app.route(\"/1\")\n    async def handler2(request):\n        return text(\"OK\")\n\n    _, response = app.test_client.get(\"/1\", gather_request=False)\n    assert response.status == 413\n    assert \"Request header\" in response.text",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "sanic.exceptions.PayloadTooLarge",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 413",
        "assert 'Request header' in response.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_payload_too_large_at_on_header_default",
      "module": "test_payload_too_large",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_payload_too_large.py",
      "line_number": 33,
      "end_line_number": 43,
      "source_code": "def test_payload_too_large_at_on_header_default(app):\n    app.config.REQUEST_MAX_SIZE = 500\n\n    @app.post(\"/1\")\n    async def handler3(request):\n        return text(\"OK\")\n\n    data = \"a\" * 1000\n    _, response = app.test_client.post(\"/1\", gather_request=False, data=data)\n    assert response.status == 413\n    assert \"Request body\" in response.text",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "sanic.exceptions.PayloadTooLarge",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 413",
        "assert 'Request body' in response.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_imports",
      "module": "test_init",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_init.py",
      "line_number": 24,
      "end_line_number": 25,
      "source_code": "def test_imports(item):\n    import_module(\"sanic\", item)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('item', ('__version__', 'Sanic', 'Blueprint', 'HTTPMethod', 'HTTPResponse', 'Request', 'Websocket', 'empty', 'file', 'html', 'json', 'redirect', 'text'))"
      ],
      "arguments": [
        "item"
      ],
      "imports": [
        "importlib.import_module",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_body_can_be_retrieved",
      "module": "test_response_json",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response_json.py",
      "line_number": 27,
      "end_line_number": 29,
      "source_code": "def test_body_can_be_retrieved(json_app: Sanic):\n    _, resp = json_app.test_client.get(\"/json\")\n    assert resp.body == json_dumps(JSON_BODY).encode()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_app"
      ],
      "imports": [
        "json",
        "functools.partial",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.exceptions.SanicException",
        "sanic.response.json",
        "sanic.response.types.JSONResponse"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.body == json_dumps(JSON_BODY).encode()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_body_can_be_set",
      "module": "test_response_json",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response_json.py",
      "line_number": 32,
      "end_line_number": 40,
      "source_code": "def test_body_can_be_set(json_app: Sanic):\n    new_body = b'{\"hello\":\"world\"}'\n\n    @json_app.on_response\n    def set_body(request: Request, response: JSONResponse):\n        response.body = new_body\n\n    _, resp = json_app.test_client.get(\"/json\")\n    assert resp.body == new_body",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_app"
      ],
      "imports": [
        "json",
        "functools.partial",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.exceptions.SanicException",
        "sanic.response.json",
        "sanic.response.types.JSONResponse"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.body == new_body"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_raw_body_can_be_retrieved",
      "module": "test_response_json",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response_json.py",
      "line_number": 43,
      "end_line_number": 48,
      "source_code": "def test_raw_body_can_be_retrieved(json_app: Sanic):\n    @json_app.on_response\n    def check_body(request: Request, response: JSONResponse):\n        assert response.raw_body == JSON_BODY\n\n    json_app.test_client.get(\"/json\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_app"
      ],
      "imports": [
        "json",
        "functools.partial",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.exceptions.SanicException",
        "sanic.response.json",
        "sanic.response.types.JSONResponse"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.raw_body == JSON_BODY"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_raw_body_can_be_set",
      "module": "test_response_json",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response_json.py",
      "line_number": 51,
      "end_line_number": 60,
      "source_code": "def test_raw_body_can_be_set(json_app: Sanic):\n    new_body = {\"hello\": \"world\"}\n\n    @json_app.on_response\n    def set_body(request: Request, response: JSONResponse):\n        response.raw_body = new_body\n        assert response.raw_body == new_body\n        assert response.body == json_dumps(new_body).encode()\n\n    json_app.test_client.get(\"/json\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_app"
      ],
      "imports": [
        "json",
        "functools.partial",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.exceptions.SanicException",
        "sanic.response.json",
        "sanic.response.types.JSONResponse"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.raw_body == new_body",
        "assert response.body == json_dumps(new_body).encode()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_raw_body_cant_be_retrieved_after_body_set",
      "module": "test_response_json",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response_json.py",
      "line_number": 63,
      "end_line_number": 72,
      "source_code": "def test_raw_body_cant_be_retrieved_after_body_set(json_app: Sanic):\n    new_body = b'{\"hello\":\"world\"}'\n\n    @json_app.on_response\n    def check_raw_body(request: Request, response: JSONResponse):\n        response.body = new_body\n        with pytest.raises(SanicException):\n            response.raw_body\n\n    json_app.test_client.get(\"/json\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_app"
      ],
      "imports": [
        "json",
        "functools.partial",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.exceptions.SanicException",
        "sanic.response.json",
        "sanic.response.types.JSONResponse"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_raw_body_can_be_reset_after_body_set",
      "module": "test_response_json",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response_json.py",
      "line_number": 75,
      "end_line_number": 85,
      "source_code": "def test_raw_body_can_be_reset_after_body_set(json_app: Sanic):\n    new_body = b'{\"hello\":\"world\"}'\n    new_new_body = {\"lorem\": \"ipsum\"}\n\n    @json_app.on_response\n    def set_bodies(request: Request, response: JSONResponse):\n        response.body = new_body\n        response.raw_body = new_new_body\n\n    _, resp = json_app.test_client.get(\"/json\")\n    assert resp.body == json_dumps(new_new_body).encode()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_app"
      ],
      "imports": [
        "json",
        "functools.partial",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.exceptions.SanicException",
        "sanic.response.json",
        "sanic.response.types.JSONResponse"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.body == json_dumps(new_new_body).encode()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_set_body_method",
      "module": "test_response_json",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response_json.py",
      "line_number": 88,
      "end_line_number": 96,
      "source_code": "def test_set_body_method(json_app: Sanic):\n    new_body = {\"lorem\": \"ipsum\"}\n\n    @json_app.on_response\n    def set_body(request: Request, response: JSONResponse):\n        response.set_body(new_body)\n\n    _, resp = json_app.test_client.get(\"/json\")\n    assert resp.body == json_dumps(new_body).encode()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_app"
      ],
      "imports": [
        "json",
        "functools.partial",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.exceptions.SanicException",
        "sanic.response.json",
        "sanic.response.types.JSONResponse"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.body == json_dumps(new_body).encode()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response.set_body",
          "body": "@json_app.on_response\ndef set_body(request: Request, response: JSONResponse):\n    response.body = new_body"
        }
      ]
    },
    {
      "name": "test_set_body_method_after_body_set",
      "module": "test_response_json",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response_json.py",
      "line_number": 99,
      "end_line_number": 109,
      "source_code": "def test_set_body_method_after_body_set(json_app: Sanic):\n    new_body = b'{\"hello\":\"world\"}'\n    new_new_body = {\"lorem\": \"ipsum\"}\n\n    @json_app.on_response\n    def set_body(request: Request, response: JSONResponse):\n        response.body = new_body\n        response.set_body(new_new_body)\n\n    _, resp = json_app.test_client.get(\"/json\")\n    assert resp.body == json_dumps(new_new_body).encode()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_app"
      ],
      "imports": [
        "json",
        "functools.partial",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.exceptions.SanicException",
        "sanic.response.json",
        "sanic.response.types.JSONResponse"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.body == json_dumps(new_new_body).encode()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response.set_body",
          "body": "@json_app.on_response\ndef set_body(request: Request, response: JSONResponse):\n    response.body = new_body"
        }
      ]
    },
    {
      "name": "test_custom_dumps_and_kwargs",
      "module": "test_response_json",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response_json.py",
      "line_number": 112,
      "end_line_number": 121,
      "source_code": "def test_custom_dumps_and_kwargs(json_app: Sanic):\n    custom_dumps = Mock(return_value=\"custom\")\n\n    @json_app.get(\"/json-custom\")\n    async def handle_custom(request: Request):\n        return json_response(JSON_BODY, dumps=custom_dumps, prry=\"platypus\")\n\n    _, resp = json_app.test_client.get(\"/json-custom\")\n    assert resp.body == \"custom\".encode()\n    custom_dumps.assert_called_once_with(JSON_BODY, prry=\"platypus\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_app"
      ],
      "imports": [
        "json",
        "functools.partial",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.exceptions.SanicException",
        "sanic.response.json",
        "sanic.response.types.JSONResponse"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.body == 'custom'.encode()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "json_app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "json_response",
          "body": "@app.get('/json')\ndef json_response(request):\n    return json({'format': request.route.extra.error_format})"
        }
      ]
    },
    {
      "name": "test_override_dumps_and_kwargs",
      "module": "test_response_json",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response_json.py",
      "line_number": 124,
      "end_line_number": 140,
      "source_code": "def test_override_dumps_and_kwargs(json_app: Sanic):\n    custom_dumps_1 = Mock(return_value=\"custom1\")\n    custom_dumps_2 = Mock(return_value=\"custom2\")\n\n    @json_app.get(\"/json-custom\")\n    async def handle_custom(request: Request):\n        return json_response(JSON_BODY, dumps=custom_dumps_1, prry=\"platypus\")\n\n    @json_app.on_response\n    def set_body(request: Request, response: JSONResponse):\n        response.set_body(JSON_BODY, dumps=custom_dumps_2, platypus=\"prry\")\n\n    _, resp = json_app.test_client.get(\"/json-custom\")\n\n    assert resp.body == \"custom2\".encode()\n    custom_dumps_1.assert_called_once_with(JSON_BODY, prry=\"platypus\")\n    custom_dumps_2.assert_called_once_with(JSON_BODY, platypus=\"prry\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_app"
      ],
      "imports": [
        "json",
        "functools.partial",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.exceptions.SanicException",
        "sanic.response.json",
        "sanic.response.types.JSONResponse"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.body == 'custom2'.encode()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "json_app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "json_response",
          "body": "@app.get('/json')\ndef json_response(request):\n    return json({'format': request.route.extra.error_format})"
        },
        {
          "name": "response.set_body",
          "body": "@json_app.on_response\ndef set_body(request: Request, response: JSONResponse):\n    response.body = new_body"
        }
      ]
    },
    {
      "name": "test_append",
      "module": "test_response_json",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response_json.py",
      "line_number": 143,
      "end_line_number": 153,
      "source_code": "def test_append(json_app: Sanic):\n    @json_app.get(\"/json-append\")\n    async def handler_append(request: Request):\n        return json_response([\"a\", \"b\"], status=200)\n\n    @json_app.on_response\n    def do_append(request: Request, response: JSONResponse):\n        response.append(\"c\")\n\n    _, resp = json_app.test_client.get(\"/json-append\")\n    assert resp.body == json_dumps([\"a\", \"b\", \"c\"]).encode()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_app"
      ],
      "imports": [
        "json",
        "functools.partial",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.exceptions.SanicException",
        "sanic.response.json",
        "sanic.response.types.JSONResponse"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.body == json_dumps(['a', 'b', 'c']).encode()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "json_app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "json_response",
          "body": "@app.get('/json')\ndef json_response(request):\n    return json({'format': request.route.extra.error_format})"
        }
      ]
    },
    {
      "name": "test_extend",
      "module": "test_response_json",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response_json.py",
      "line_number": 156,
      "end_line_number": 166,
      "source_code": "def test_extend(json_app: Sanic):\n    @json_app.get(\"/json-extend\")\n    async def handler_extend(request: Request):\n        return json_response([\"a\", \"b\"], status=200)\n\n    @json_app.on_response\n    def do_extend(request: Request, response: JSONResponse):\n        response.extend([\"c\", \"d\"])\n\n    _, resp = json_app.test_client.get(\"/json-extend\")\n    assert resp.body == json_dumps([\"a\", \"b\", \"c\", \"d\"]).encode()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_app"
      ],
      "imports": [
        "json",
        "functools.partial",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.exceptions.SanicException",
        "sanic.response.json",
        "sanic.response.types.JSONResponse"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.body == json_dumps(['a', 'b', 'c', 'd']).encode()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "json_app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "json_response",
          "body": "@app.get('/json')\ndef json_response(request):\n    return json({'format': request.route.extra.error_format})"
        }
      ]
    },
    {
      "name": "test_update",
      "module": "test_response_json",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response_json.py",
      "line_number": 169,
      "end_line_number": 179,
      "source_code": "def test_update(json_app: Sanic):\n    @json_app.get(\"/json-update\")\n    async def handler_update(request: Request):\n        return json_response({\"a\": \"b\"}, status=200)\n\n    @json_app.on_response\n    def do_update(request: Request, response: JSONResponse):\n        response.update({\"c\": \"d\"}, e=\"f\")\n\n    _, resp = json_app.test_client.get(\"/json-update\")\n    assert resp.body == json_dumps({\"a\": \"b\", \"c\": \"d\", \"e\": \"f\"}).encode()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_app"
      ],
      "imports": [
        "json",
        "functools.partial",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.exceptions.SanicException",
        "sanic.response.json",
        "sanic.response.types.JSONResponse"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.body == json_dumps({'a': 'b', 'c': 'd', 'e': 'f'}).encode()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "json_app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "json_response",
          "body": "@app.get('/json')\ndef json_response(request):\n    return json({'format': request.route.extra.error_format})"
        }
      ]
    },
    {
      "name": "test_pop_dict",
      "module": "test_response_json",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response_json.py",
      "line_number": 182,
      "end_line_number": 196,
      "source_code": "def test_pop_dict(json_app: Sanic):\n    @json_app.get(\"/json-pop\")\n    async def handler_pop(request: Request):\n        return json_response({\"a\": \"b\", \"c\": \"d\"}, status=200)\n\n    @json_app.on_response\n    def do_pop(request: Request, response: JSONResponse):\n        val = response.pop(\"c\")\n        assert val == \"d\"\n\n        val_default = response.pop(\"e\", \"f\")\n        assert val_default == \"f\"\n\n    _, resp = json_app.test_client.get(\"/json-pop\")\n    assert resp.body == json_dumps({\"a\": \"b\"}).encode()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_app"
      ],
      "imports": [
        "json",
        "functools.partial",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.exceptions.SanicException",
        "sanic.response.json",
        "sanic.response.types.JSONResponse"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.body == json_dumps({'a': 'b'}).encode()",
        "assert val == 'd'",
        "assert val_default == 'f'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "json_app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "json_response",
          "body": "@app.get('/json')\ndef json_response(request):\n    return json({'format': request.route.extra.error_format})"
        }
      ]
    },
    {
      "name": "test_pop_list",
      "module": "test_response_json",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response_json.py",
      "line_number": 199,
      "end_line_number": 215,
      "source_code": "def test_pop_list(json_app: Sanic):\n    @json_app.get(\"/json-pop\")\n    async def handler_pop(request: Request):\n        return json_response([\"a\", \"b\"], status=200)\n\n    @json_app.on_response\n    def do_pop(request: Request, response: JSONResponse):\n        val = response.pop(0)\n        assert val == \"a\"\n\n        with pytest.raises(\n            TypeError, match=\"pop doesn't accept a default argument for lists\"\n        ):\n            response.pop(21, \"nah nah\")\n\n    _, resp = json_app.test_client.get(\"/json-pop\")\n    assert resp.body == json_dumps([\"b\"]).encode()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_app"
      ],
      "imports": [
        "json",
        "functools.partial",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.exceptions.SanicException",
        "sanic.response.json",
        "sanic.response.types.JSONResponse"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.body == json_dumps(['b']).encode()",
        "assert val == 'a'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "json_app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "json_response",
          "body": "@app.get('/json')\ndef json_response(request):\n    return json({'format': request.route.extra.error_format})"
        }
      ]
    },
    {
      "name": "test_json_response_class_sets_proper_content_type",
      "module": "test_response_json",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response_json.py",
      "line_number": 218,
      "end_line_number": 224,
      "source_code": "def test_json_response_class_sets_proper_content_type(json_app: Sanic):\n    @json_app.get(\"/json-class\")\n    async def handler(request: Request):\n        return JSONResponse(JSON_BODY)\n\n    _, resp = json_app.test_client.get(\"/json-class\")\n    assert resp.headers[\"content-type\"] == \"application/json\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_app"
      ],
      "imports": [
        "json",
        "functools.partial",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.exceptions.SanicException",
        "sanic.response.json",
        "sanic.response.types.JSONResponse"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.headers['content-type'] == 'application/json'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "json_app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_overload_dynamic_routes",
      "module": "test_dynamic_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_dynamic_routes.py",
      "line_number": 16,
      "end_line_number": 26,
      "source_code": "def test_overload_dynamic_routes(app, method, attr, expected):\n    @app.route(\"/overload/<param>\", methods=[\"GET\"])\n    async def handler1(request, param):\n        return text(\"OK1 \" + param)\n\n    @app.route(\"/overload/<param>\", methods=[\"POST\", \"PUT\"])\n    async def handler2(request, param):\n        return text(\"OK2 \" + param)\n\n    request, response = getattr(app.test_client, method)(\"/overload/test\")\n    assert getattr(response, attr) == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('method,attr, expected', [('get', 'text', 'OK1 test'), ('post', 'text', 'OK2 test'), ('put', 'text', 'OK2 test')])"
      ],
      "arguments": [
        "app",
        "method",
        "attr",
        "expected"
      ],
      "imports": [
        "pytest",
        "sanic_routing.exceptions.RouteExists",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert getattr(response, attr) == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_overload_dynamic_routes_exist",
      "module": "test_dynamic_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_dynamic_routes.py",
      "line_number": 29,
      "end_line_number": 44,
      "source_code": "def test_overload_dynamic_routes_exist(app):\n    @app.route(\"/overload/<param>\", methods=[\"GET\"])\n    async def handler1(request, param):\n        return text(\"OK1 \" + param)\n\n    @app.route(\"/overload/<param>\", methods=[\"POST\", \"PUT\"])\n    async def handler2(request, param):\n        return text(\"OK2 \" + param)\n\n    # if this doesn't raise an error, than at least the below should happen:\n    # assert response.text == 'Duplicated'\n    with pytest.raises(RouteExists):\n\n        @app.route(\"/overload/<param>\", methods=[\"PUT\", \"DELETE\"])\n        async def handler3(request, param):\n            return text(\"Duplicated\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic_routing.exceptions.RouteExists",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_keep_alive_timeout_reuse",
      "module": "test_keep_alive_timeout",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_keep_alive_timeout.py",
      "line_number": 64,
      "end_line_number": 95,
      "source_code": "def test_keep_alive_timeout_reuse(port):\n    \"\"\"If the server keep-alive timeout and client keep-alive timeout are\n    both longer than the delay, the client _and_ server will successfully\n    reuse the existing connection.\"\"\"\n    loops = 0\n    while True:\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n        client = ReusableClient(\n            keep_alive_timeout_app_reuse, loop=loop, port=port\n        )\n        try:\n            with client:\n                headers = {\"Connection\": \"keep-alive\"}\n                request, response = client.get(\"/1\", headers=headers)\n                assert response.status == 200\n                assert response.text == \"OK\"\n                assert request.protocol.state[\"requests_count\"] == 1\n\n                loop.run_until_complete(aio_sleep(1))\n\n                request, response = client.get(\"/1\")\n                assert response.status == 200\n                assert response.text == \"OK\"\n                assert request.protocol.state[\"requests_count\"] == 2\n        except OSError:\n            loops += 1\n            if loops > MAX_LOOPS:\n                raise\n            continue\n        else:\n            break",
      "docstring": "If the server keep-alive timeout and client keep-alive timeout are\nboth longer than the delay, the client _and_ server will successfully\nreuse the existing connection.",
      "decorators": [
        "pytest.mark.skipif(bool(environ.get('SANIC_NO_UVLOOP')) or OS_IS_WINDOWS, reason='Not testable with current client')"
      ],
      "arguments": [
        "port"
      ],
      "imports": [
        "asyncio",
        "platform",
        "asyncio.sleep",
        "itertools.count",
        "os.environ",
        "pytest",
        "sanic_testing.reusable.ReusableClient",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'OK'",
        "assert request.protocol.state['requests_count'] == 1",
        "assert response.status == 200",
        "assert response.text == 'OK'",
        "assert request.protocol.state['requests_count'] == 2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "environ.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_keep_alive_client_timeout",
      "module": "test_keep_alive_timeout",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_keep_alive_timeout.py",
      "line_number": 104,
      "end_line_number": 134,
      "source_code": "def test_keep_alive_client_timeout(port):\n    \"\"\"If the server keep-alive timeout is longer than the client\n    keep-alive timeout, client will try to create a new connection here.\"\"\"\n    loops = 0\n    while True:\n        try:\n            loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(loop)\n            client = ReusableClient(\n                keep_alive_app_client_timeout, loop=loop, port=port\n            )\n            with client:\n                headers = {\"Connection\": \"keep-alive\"}\n                request, response = client.get(\n                    \"/1\", headers=headers, timeout=1\n                )\n\n                assert response.status == 200\n                assert response.text == \"OK\"\n                assert request.protocol.state[\"requests_count\"] == 1\n\n                loop.run_until_complete(aio_sleep(2))\n                request, response = client.get(\"/1\", timeout=1)\n                assert request.protocol.state[\"requests_count\"] == 1\n        except OSError:\n            loops += 1\n            if loops > MAX_LOOPS:\n                raise\n            continue\n        else:\n            break",
      "docstring": "If the server keep-alive timeout is longer than the client\nkeep-alive timeout, client will try to create a new connection here.",
      "decorators": [
        "pytest.mark.skipif(bool(environ.get('SANIC_NO_UVLOOP')) or OS_IS_WINDOWS or platform.system() != 'Linux', reason='Not testable with current client')"
      ],
      "arguments": [
        "port"
      ],
      "imports": [
        "asyncio",
        "platform",
        "asyncio.sleep",
        "itertools.count",
        "os.environ",
        "pytest",
        "sanic_testing.reusable.ReusableClient",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'OK'",
        "assert request.protocol.state['requests_count'] == 1",
        "assert request.protocol.state['requests_count'] == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "environ.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_keep_alive_server_timeout",
      "module": "test_keep_alive_timeout",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_keep_alive_timeout.py",
      "line_number": 141,
      "end_line_number": 174,
      "source_code": "def test_keep_alive_server_timeout(port):\n    \"\"\"If the client keep-alive timeout is longer than the server\n    keep-alive timeout, the client will either a 'Connection reset' error\n    _or_ a new connection. Depending on how the event-loop handles the\n    broken server connection.\"\"\"\n    loops = 0\n    while True:\n        try:\n            loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(loop)\n            client = ReusableClient(\n                keep_alive_app_server_timeout, loop=loop, port=port\n            )\n            with client:\n                headers = {\"Connection\": \"keep-alive\"}\n                request, response = client.get(\n                    \"/1\", headers=headers, timeout=60\n                )\n\n                assert response.status == 200\n                assert response.text == \"OK\"\n                assert request.protocol.state[\"requests_count\"] == 1\n\n                loop.run_until_complete(aio_sleep(3))\n                request, response = client.get(\"/1\", timeout=60)\n\n                assert request.protocol.state[\"requests_count\"] == 1\n        except OSError:\n            loops += 1\n            if loops > MAX_LOOPS:\n                raise\n            continue\n        else:\n            break",
      "docstring": "If the client keep-alive timeout is longer than the server\nkeep-alive timeout, the client will either a 'Connection reset' error\n_or_ a new connection. Depending on how the event-loop handles the\nbroken server connection.",
      "decorators": [
        "pytest.mark.skipif(bool(environ.get('SANIC_NO_UVLOOP')) or OS_IS_WINDOWS, reason='Not testable with current client')"
      ],
      "arguments": [
        "port"
      ],
      "imports": [
        "asyncio",
        "platform",
        "asyncio.sleep",
        "itertools.count",
        "os.environ",
        "pytest",
        "sanic_testing.reusable.ReusableClient",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'OK'",
        "assert request.protocol.state['requests_count'] == 1",
        "assert request.protocol.state['requests_count'] == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "environ.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_keep_alive_connection_context",
      "module": "test_keep_alive_timeout",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_keep_alive_timeout.py",
      "line_number": 181,
      "end_line_number": 211,
      "source_code": "def test_keep_alive_connection_context(port):\n    loops = 0\n    while True:\n        try:\n            loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(loop)\n            client = ReusableClient(\n                keep_alive_app_context, loop=loop, port=port\n            )\n            with client:\n                headers = {\"Connection\": \"keep-alive\"}\n                request1, _ = client.post(\"/ctx\", headers=headers)\n\n                loop.run_until_complete(aio_sleep(1))\n                request2, response = client.get(\"/ctx\")\n\n                assert response.text == \"hello\"\n                assert id(request1.conn_info.ctx) == id(request2.conn_info.ctx)\n                assert (\n                    request1.conn_info.ctx.foo\n                    == request2.conn_info.ctx.foo\n                    == \"hello\"\n                )\n                assert request2.protocol.state[\"requests_count\"] == 2\n        except OSError:\n            loops += 1\n            if loops > MAX_LOOPS:\n                raise\n            continue\n        else:\n            break",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(bool(environ.get('SANIC_NO_UVLOOP')) or OS_IS_WINDOWS, reason='Not testable with current client')"
      ],
      "arguments": [
        "port"
      ],
      "imports": [
        "asyncio",
        "platform",
        "asyncio.sleep",
        "itertools.count",
        "os.environ",
        "pytest",
        "sanic_testing.reusable.ReusableClient",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'hello'",
        "assert id(request1.conn_info.ctx) == id(request2.conn_info.ctx)",
        "assert request1.conn_info.ctx.foo == request2.conn_info.ctx.foo == 'hello'",
        "assert request2.protocol.state['requests_count'] == 2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "environ.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_versioned_named_routes_get",
      "module": "test_named_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_named_routes.py",
      "line_number": 21,
      "end_line_number": 75,
      "source_code": "def test_versioned_named_routes_get(method):\n    app = Sanic(\"app\")\n\n    bp = Blueprint(\"test_bp\", url_prefix=\"/bp\")\n\n    method = method.lower()\n    route_name = f\"route_{method}\"\n    route_name2 = f\"route2_{method}\"\n\n    func = getattr(app, method)\n    if callable(func):\n\n        @func(f\"/{method}\", version=1, name=route_name)\n        def handler(request):\n            return text(\"OK\")\n\n    else:\n        raise\n\n    func = getattr(bp, method)\n    if callable(func):\n\n        @func(f\"/{method}\", version=1, name=route_name2)\n        def handler2(request):\n            return text(\"OK\")\n\n    else:\n        raise\n\n    app.blueprint(bp)\n\n    assert (\n        app.router.routes_all[\n            (\n                \"v1\",\n                method,\n            )\n        ].name\n        == f\"app.{route_name}\"\n    )\n\n    route = app.router.routes_all[\n        (\n            \"v1\",\n            \"bp\",\n            method,\n        )\n    ]\n    assert route.name == f\"app.test_bp.{route_name2}\"\n\n    assert app.url_for(route_name) == f\"/v1/{method}\"\n    url = app.url_for(f\"test_bp.{route_name2}\")\n    assert url == f\"/v1/bp/{method}\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler\")",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('method', HTTP_METHODS)"
      ],
      "arguments": [
        "method"
      ],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.router.routes_all['v1', method].name == f'app.{route_name}'",
        "assert route.name == f'app.test_bp.{route_name2}'",
        "assert app.url_for(route_name) == f'/v1/{method}'",
        "assert url == f'/v1/bp/{method}'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_shorthand_default_routes_get",
      "module": "test_named_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_named_routes.py",
      "line_number": 78,
      "end_line_number": 86,
      "source_code": "def test_shorthand_default_routes_get():\n    app = Sanic(\"app\")\n\n    @app.get(\"/get\")\n    def handler(request):\n        return text(\"OK\")\n\n    assert app.router.routes_all[(\"get\",)].name == \"app.handler\"\n    assert app.url_for(\"handler\") == \"/get\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.router.routes_all['get',].name == 'app.handler'",
        "assert app.url_for('handler') == '/get'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_shorthand_named_routes_get",
      "module": "test_named_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_named_routes.py",
      "line_number": 89,
      "end_line_number": 119,
      "source_code": "def test_shorthand_named_routes_get():\n    app = Sanic(\"app\")\n    bp = Blueprint(\"test_bp\", url_prefix=\"/bp\")\n\n    @app.get(\"/get\", name=\"route_get\")\n    def handler(request):\n        return text(\"OK\")\n\n    @bp.get(\"/get\", name=\"route_bp\")\n    def handler2(request):\n        return text(\"Blueprint\")\n\n    app.blueprint(bp)\n\n    assert app.router.routes_all[(\"get\",)].name == \"app.route_get\"\n    assert app.url_for(\"route_get\") == \"/get\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler\")\n\n    assert (\n        app.router.routes_all[\n            (\n                \"bp\",\n                \"get\",\n            )\n        ].name\n        == \"app.test_bp.route_bp\"\n    )\n    assert app.url_for(\"test_bp.route_bp\") == \"/bp/get\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"test_bp.handler2\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.router.routes_all['get',].name == 'app.route_get'",
        "assert app.url_for('route_get') == '/get'",
        "assert app.router.routes_all['bp', 'get'].name == 'app.test_bp.route_bp'",
        "assert app.url_for('test_bp.route_bp') == '/bp/get'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_shorthand_named_routes_post",
      "module": "test_named_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_named_routes.py",
      "line_number": 122,
      "end_line_number": 132,
      "source_code": "def test_shorthand_named_routes_post():\n    app = Sanic(\"app\")\n\n    @app.post(\"/post\", name=\"route_name\")\n    def handler(request):\n        return text(\"OK\")\n\n    assert app.router.routes_all[(\"post\",)].name == \"app.route_name\"\n    assert app.url_for(\"route_name\") == \"/post\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.router.routes_all['post',].name == 'app.route_name'",
        "assert app.url_for('route_name') == '/post'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_shorthand_named_routes_put",
      "module": "test_named_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_named_routes.py",
      "line_number": 135,
      "end_line_number": 145,
      "source_code": "def test_shorthand_named_routes_put():\n    app = Sanic(\"app\")\n\n    @app.put(\"/put\", name=\"route_put\")\n    def handler(request):\n        return text(\"OK\")\n\n    assert app.router.routes_all[(\"put\",)].name == \"app.route_put\"\n    assert app.url_for(\"route_put\") == \"/put\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.router.routes_all['put',].name == 'app.route_put'",
        "assert app.url_for('route_put') == '/put'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_shorthand_named_routes_delete",
      "module": "test_named_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_named_routes.py",
      "line_number": 148,
      "end_line_number": 158,
      "source_code": "def test_shorthand_named_routes_delete():\n    app = Sanic(\"app\")\n\n    @app.delete(\"/delete\", name=\"route_delete\")\n    def handler(request):\n        return text(\"OK\")\n\n    assert app.router.routes_all[(\"delete\",)].name == \"app.route_delete\"\n    assert app.url_for(\"route_delete\") == \"/delete\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.router.routes_all['delete',].name == 'app.route_delete'",
        "assert app.url_for('route_delete') == '/delete'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.delete",
          "body": "def delete(self, request):\n    return text('I am delete method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_shorthand_named_routes_patch",
      "module": "test_named_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_named_routes.py",
      "line_number": 161,
      "end_line_number": 171,
      "source_code": "def test_shorthand_named_routes_patch():\n    app = Sanic(\"app\")\n\n    @app.patch(\"/patch\", name=\"route_patch\")\n    def handler(request):\n        return text(\"OK\")\n\n    assert app.router.routes_all[(\"patch\",)].name == \"app.route_patch\"\n    assert app.url_for(\"route_patch\") == \"/patch\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.router.routes_all['patch',].name == 'app.route_patch'",
        "assert app.url_for('route_patch') == '/patch'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "app.patch('/patch', name='route_patch')"
      ],
      "methods_under_test": [
        {
          "name": "app.patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_shorthand_named_routes_head",
      "module": "test_named_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_named_routes.py",
      "line_number": 174,
      "end_line_number": 184,
      "source_code": "def test_shorthand_named_routes_head():\n    app = Sanic(\"app\")\n\n    @app.head(\"/head\", name=\"route_head\")\n    def handler(request):\n        return text(\"OK\")\n\n    assert app.router.routes_all[(\"head\",)].name == \"app.route_head\"\n    assert app.url_for(\"route_head\") == \"/head\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.router.routes_all['head',].name == 'app.route_head'",
        "assert app.url_for('route_head') == '/head'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.head",
          "body": "def head(self, request):\n    return text('', headers={'method': 'HEAD'})"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_shorthand_named_routes_options",
      "module": "test_named_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_named_routes.py",
      "line_number": 187,
      "end_line_number": 197,
      "source_code": "def test_shorthand_named_routes_options():\n    app = Sanic(\"app\")\n\n    @app.options(\"/options\", name=\"route_options\")\n    def handler(request):\n        return text(\"OK\")\n\n    assert app.router.routes_all[(\"options\",)].name == \"app.route_options\"\n    assert app.url_for(\"route_options\") == \"/options\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.router.routes_all['options',].name == 'app.route_options'",
        "assert app.url_for('route_options') == '/options'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.options",
          "body": "def options(self, request):\n    return text('', headers={'method': 'OPTIONS'})"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_named_static_routes",
      "module": "test_named_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_named_routes.py",
      "line_number": 200,
      "end_line_number": 221,
      "source_code": "def test_named_static_routes():\n    app = Sanic(\"app\")\n\n    @app.route(\"/test\", name=\"route_test\")\n    async def handler1(request):\n        return text(\"OK1\")\n\n    @app.route(\"/pizazz\", name=\"route_pizazz\")\n    async def handler2(request):\n        return text(\"OK2\")\n\n    assert app.router.routes_all[(\"test\",)].name == \"app.route_test\"\n    assert app.router.routes_static[(\"test\",)][0].name == \"app.route_test\"\n    assert app.url_for(\"route_test\") == \"/test\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler1\")\n\n    assert app.router.routes_all[(\"pizazz\",)].name == \"app.route_pizazz\"\n    assert app.router.routes_static[(\"pizazz\",)][0].name == \"app.route_pizazz\"\n    assert app.url_for(\"route_pizazz\") == \"/pizazz\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler2\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.router.routes_all['test',].name == 'app.route_test'",
        "assert app.router.routes_static['test',][0].name == 'app.route_test'",
        "assert app.url_for('route_test') == '/test'",
        "assert app.router.routes_all['pizazz',].name == 'app.route_pizazz'",
        "assert app.router.routes_static['pizazz',][0].name == 'app.route_pizazz'",
        "assert app.url_for('route_pizazz') == '/pizazz'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_named_dynamic_route",
      "module": "test_named_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_named_routes.py",
      "line_number": 224,
      "end_line_number": 244,
      "source_code": "def test_named_dynamic_route():\n    app = Sanic(\"app\")\n    results = []\n\n    @app.route(\"/folder/<name>\", name=\"route_dynamic\")\n    async def handler(request, name):\n        results.append(name)\n        return text(\"OK\")\n\n    assert (\n        app.router.routes_all[\n            (\n                \"folder\",\n                \"<name:str>\",\n            )\n        ].name\n        == \"app.route_dynamic\"\n    )\n    assert app.url_for(\"route_dynamic\", name=\"test\") == \"/folder/test\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.router.routes_all['folder', '<name:str>'].name == 'app.route_dynamic'",
        "assert app.url_for('route_dynamic', name='test') == '/folder/test'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_dynamic_named_route_regex",
      "module": "test_named_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_named_routes.py",
      "line_number": 247,
      "end_line_number": 263,
      "source_code": "def test_dynamic_named_route_regex():\n    app = Sanic(\"app\")\n\n    @app.route(\"/folder/<folder_id:[A-Za-z0-9]{0,4}>\", name=\"route_re\")\n    async def handler(request, folder_id):\n        return text(\"OK\")\n\n    route = app.router.routes_all[\n        (\n            \"folder\",\n            \"<folder_id:[A-Za-z0-9]{0,4}>\",\n        )\n    ]\n    assert route.name == \"app.route_re\"\n    assert app.url_for(\"route_re\", folder_id=\"test\") == \"/folder/test\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert route.name == 'app.route_re'",
        "assert app.url_for('route_re', folder_id='test') == '/folder/test'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_dynamic_named_route_path",
      "module": "test_named_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_named_routes.py",
      "line_number": 266,
      "end_line_number": 282,
      "source_code": "def test_dynamic_named_route_path():\n    app = Sanic(\"app\")\n\n    @app.route(\"/<path:path>/info\", name=\"route_dynamic_path\")\n    async def handler(request, path):\n        return text(\"OK\")\n\n    route = app.router.routes_all[\n        (\n            \"<path:path>\",\n            \"info\",\n        )\n    ]\n    assert route.name == \"app.route_dynamic_path\"\n    assert app.url_for(\"route_dynamic_path\", path=\"path/1\") == \"/path/1/info\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert route.name == 'app.route_dynamic_path'",
        "assert app.url_for('route_dynamic_path', path='path/1') == '/path/1/info'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_dynamic_named_route_unhashable",
      "module": "test_named_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_named_routes.py",
      "line_number": 285,
      "end_line_number": 305,
      "source_code": "def test_dynamic_named_route_unhashable():\n    app = Sanic(\"app\")\n\n    @app.route(\n        \"/folder/<unhashable:[A-Za-z0-9/]+>/end/\", name=\"route_unhashable\"\n    )\n    async def handler(request, unhashable):\n        return text(\"OK\")\n\n    route = app.router.routes_all[\n        (\n            \"folder\",\n            \"<unhashable:[A-Za-z0-9/]+>\",\n            \"end\",\n        )\n    ]\n    assert route.name == \"app.route_unhashable\"\n    url = app.url_for(\"route_unhashable\", unhashable=\"test/asdf\")\n    assert url == \"/folder/test/asdf/end\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert route.name == 'app.route_unhashable'",
        "assert url == '/folder/test/asdf/end'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_websocket_named_route",
      "module": "test_named_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_named_routes.py",
      "line_number": 308,
      "end_line_number": 320,
      "source_code": "def test_websocket_named_route():\n    app = Sanic(\"app\")\n    ev = asyncio.Event()\n\n    @app.websocket(\"/ws\", name=\"route_ws\")\n    async def handler(request, ws):\n        assert ws.subprotocol is None\n        ev.set()\n\n    assert app.router.routes_all[(\"ws\",)].name == \"app.route_ws\"\n    assert app.url_for(\"route_ws\") == \"/ws\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.router.routes_all['ws',].name == 'app.route_ws'",
        "assert app.url_for('route_ws') == '/ws'",
        "assert ws.subprotocol is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_websocket_named_route_with_subprotocols",
      "module": "test_named_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_named_routes.py",
      "line_number": 323,
      "end_line_number": 334,
      "source_code": "def test_websocket_named_route_with_subprotocols():\n    app = Sanic(\"app\")\n    results = []\n\n    @app.websocket(\"/ws\", subprotocols=[\"foo\", \"bar\"], name=\"route_ws\")\n    async def handler(request, ws):\n        results.append(ws.subprotocol)\n\n    assert app.router.routes_all[(\"ws\",)].name == \"app.route_ws\"\n    assert app.url_for(\"route_ws\") == \"/ws\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.router.routes_all['ws',].name == 'app.route_ws'",
        "assert app.url_for('route_ws') == '/ws'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_static_add_named_route",
      "module": "test_named_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_named_routes.py",
      "line_number": 337,
      "end_line_number": 359,
      "source_code": "def test_static_add_named_route():\n    app = Sanic(\"app\")\n\n    async def handler1(request):\n        return text(\"OK1\")\n\n    async def handler2(request):\n        return text(\"OK2\")\n\n    app.add_route(handler1, \"/test\", name=\"route_test\")\n    app.add_route(handler2, \"/test2\", name=\"route_test2\")\n\n    assert app.router.routes_all[(\"test\",)].name == \"app.route_test\"\n    assert app.router.routes_static[(\"test\",)][0].name == \"app.route_test\"\n    assert app.url_for(\"route_test\") == \"/test\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler1\")\n\n    assert app.router.routes_all[(\"test2\",)].name == \"app.route_test2\"\n    assert app.router.routes_static[(\"test2\",)][0].name == \"app.route_test2\"\n    assert app.url_for(\"route_test2\") == \"/test2\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler2\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.router.routes_all['test',].name == 'app.route_test'",
        "assert app.router.routes_static['test',][0].name == 'app.route_test'",
        "assert app.url_for('route_test') == '/test'",
        "assert app.router.routes_all['test2',].name == 'app.route_test2'",
        "assert app.router.routes_static['test2',][0].name == 'app.route_test2'",
        "assert app.url_for('route_test2') == '/test2'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_dynamic_add_named_route",
      "module": "test_named_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_named_routes.py",
      "line_number": 362,
      "end_line_number": 377,
      "source_code": "def test_dynamic_add_named_route():\n    app = Sanic(\"app\")\n    results = []\n\n    async def handler(request, name):\n        results.append(name)\n        return text(\"OK\")\n\n    app.add_route(handler, \"/folder/<name>\", name=\"route_dynamic\")\n    assert (\n        app.router.routes_all[(\"folder\", \"<name:str>\")].name\n        == \"app.route_dynamic\"\n    )\n    assert app.url_for(\"route_dynamic\", name=\"test\") == \"/folder/test\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.router.routes_all['folder', '<name:str>'].name == 'app.route_dynamic'",
        "assert app.url_for('route_dynamic', name='test') == '/folder/test'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_dynamic_add_named_route_unhashable",
      "module": "test_named_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_named_routes.py",
      "line_number": 380,
      "end_line_number": 402,
      "source_code": "def test_dynamic_add_named_route_unhashable():\n    app = Sanic(\"app\")\n\n    async def handler(request, unhashable):\n        return text(\"OK\")\n\n    app.add_route(\n        handler,\n        \"/folder/<unhashable:[A-Za-z0-9/]+>/end/\",\n        name=\"route_unhashable\",\n    )\n    route = app.router.routes_all[\n        (\n            \"folder\",\n            \"<unhashable:[A-Za-z0-9/]+>\",\n            \"end\",\n        )\n    ]\n    assert route.name == \"app.route_unhashable\"\n    url = app.url_for(\"route_unhashable\", unhashable=\"folder1\")\n    assert url == \"/folder/folder1/end\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert route.name == 'app.route_unhashable'",
        "assert url == '/folder/folder1/end'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_overload_routes",
      "module": "test_named_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_named_routes.py",
      "line_number": 405,
      "end_line_number": 439,
      "source_code": "def test_overload_routes():\n    app = Sanic(\"app\")\n\n    @app.route(\"/overload\", methods=[\"GET\"], name=\"route_first\")\n    async def handler1(request):\n        return text(\"OK1\")\n\n    @app.route(\"/overload\", methods=[\"POST\", \"PUT\"], name=\"route_second\")\n    async def handler2(request):\n        return text(\"OK2\")\n\n    request, response = app.test_client.get(app.url_for(\"route_first\"))\n    assert response.text == \"OK1\"\n\n    request, response = app.test_client.post(app.url_for(\"route_first\"))\n    assert response.text == \"OK2\"\n\n    request, response = app.test_client.put(app.url_for(\"route_first\"))\n    assert response.text == \"OK2\"\n\n    request, response = app.test_client.get(app.url_for(\"route_second\"))\n    assert response.text == \"OK1\"\n\n    request, response = app.test_client.post(app.url_for(\"route_second\"))\n    assert response.text == \"OK2\"\n\n    request, response = app.test_client.put(app.url_for(\"route_second\"))\n    assert response.text == \"OK2\"\n\n    assert app.router.routes_all[(\"overload\",)].name == \"app.route_first\"\n    with pytest.raises(URLBuildError):\n        app.url_for(\"handler1\")\n\n    assert app.url_for(\"route_first\") == \"/overload\"\n    assert app.url_for(\"route_second\") == app.url_for(\"route_first\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.URLBuildError",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK1'",
        "assert response.text == 'OK2'",
        "assert response.text == 'OK2'",
        "assert response.text == 'OK1'",
        "assert response.text == 'OK2'",
        "assert response.text == 'OK2'",
        "assert app.router.routes_all['overload',].name == 'app.route_first'",
        "assert app.url_for('route_first') == '/overload'",
        "assert app.url_for('route_second') == app.url_for('route_first')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_http1_response_has_alt_svc",
      "module": "test_http_alt_svc",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_http_alt_svc.py",
      "line_number": 17,
      "end_line_number": 64,
      "source_code": "def test_http1_response_has_alt_svc(port):\n    Sanic._app_registry.clear()\n    app = Sanic(\"TestAltSvc\")\n    app.config.TOUCHUP = True\n    response = b\"\"\n\n    @app.get(\"/\")\n    async def handler(*_):\n        return empty()\n\n    @app.after_server_start\n    async def do_request(*_):\n        nonlocal response\n\n        app.router.reset()\n        app.router.finalize()\n\n        client = RawClient(app.state.host, app.state.port)\n        await client.connect()\n        await client.send(\n            \"\"\"\n            GET / HTTP/1.1\n            host: localhost:7777\n\n            \"\"\"\n        )\n        response = await client.recv(1024)\n        await client.close()\n\n    @app.after_server_start\n    def shutdown(*_):\n        app.stop()\n\n    app.prepare(\n        version=3,\n        ssl={\n            \"cert\": localhost_dir / \"fullchain.pem\",\n            \"key\": localhost_dir / \"privkey.pem\",\n        },\n        port=port,\n    )\n    app.prepare(\n        version=1,\n        port=port,\n    )\n    Sanic.serve_single(app)\n\n    assert f'alt-svc: h3=\":{port}\"\\r\\n'.encode() in response",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(sys.version_info < (3, 9), reason='Not supported in 3.7')"
      ],
      "arguments": [
        "port"
      ],
      "imports": [
        "sys",
        "pathlib.Path",
        "pytest",
        "sanic.app.Sanic",
        "sanic.response.empty",
        "tests.client.RawClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert f'alt-svc: h3=\":{port}\"\\r\\n'.encode() in response"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.router.reset",
          "body": "@pytest.fixture(autouse=True)\ndef reset():\n    try:\n        del os.environ['SANIC_MOTD_OUTPUT']\n    except KeyError:\n        ..."
        },
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        },
        {
          "name": "client.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "client.recv",
          "body": "def recv(**kwargs):\n    nonlocal runner\n    nonlocal raw\n    method = raw.recv_until if 'until' in kwargs else raw.recv\n    return runner._run(method(**kwargs))"
        }
      ]
    },
    {
      "name": "test_multiprocessing",
      "module": "test_multiprocessing",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_multiprocessing.py",
      "line_number": 28,
      "end_line_number": 48,
      "source_code": "def test_multiprocessing(app, port):\n    \"\"\"Tests that the number of children we produce is correct\"\"\"\n    # Selects a number at random so we can spot check\n    num_workers = random.choice(range(2, multiprocessing.cpu_count() * 2 + 1))\n    process_list = set()\n\n    @app.after_server_start\n    async def shutdown(app):\n        await sleep(2.1)\n        app.stop()\n\n    def stop_on_alarm(*args):\n        for process in multiprocessing.active_children():\n            process_list.add(process.pid)\n\n    signal.signal(signal.SIGALRM, stop_on_alarm)\n    signal.alarm(2)\n    with use_context(\"fork\"):\n        app.run(HOST, port, workers=num_workers, debug=True)\n\n    assert len(process_list) == num_workers + 1",
      "docstring": "Tests that the number of children we produce is correct",
      "decorators": [
        "pytest.mark.skipif(not hasattr(signal, 'SIGALRM'), reason='SIGALRM is not implemented for this platform, we have to come up with another timeout strategy to test these')",
        "pytest.mark.skipif(sys.platform not in ('linux', 'darwin'), reason='This test requires fork context')"
      ],
      "arguments": [
        "app",
        "port"
      ],
      "imports": [
        "logging",
        "multiprocessing",
        "pickle",
        "random",
        "signal",
        "sys",
        "asyncio.sleep",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic.Blueprint",
        "sanic.text",
        "sanic.compat.use_context",
        "sanic.log.logger"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(process_list) == num_workers + 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        },
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ]
    },
    {
      "name": "test_multiprocessing_with_blueprint",
      "module": "test_multiprocessing",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_multiprocessing.py",
      "line_number": 59,
      "end_line_number": 81,
      "source_code": "def test_multiprocessing_with_blueprint(app: object, port) -> object:\n    # Selects a number at random so we can spot check\n    num_workers = random.choice(range(2, multiprocessing.cpu_count() * 2 + 1))\n    process_list = set()\n\n    @app.after_server_start\n    async def shutdown(app):\n        await sleep(2.1)\n        app.stop()\n\n    def stop_on_alarm(*args):\n        for process in multiprocessing.active_children():\n            process_list.add(process.pid)\n\n    signal.signal(signal.SIGALRM, stop_on_alarm)\n    signal.alarm(2)\n\n    bp = Blueprint(\"test_text\")\n    app.blueprint(bp)\n    with use_context(\"fork\"):\n        app.run(HOST, port, workers=num_workers, debug=True)\n\n    assert len(process_list) == num_workers + 1",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(not hasattr(signal, 'SIGALRM'), reason='SIGALRM is not implemented for this platform')",
        "pytest.mark.skipif(sys.platform not in ('linux', 'darwin'), reason='This test requires fork context')"
      ],
      "arguments": [
        "app",
        "port"
      ],
      "imports": [
        "logging",
        "multiprocessing",
        "pickle",
        "random",
        "signal",
        "sys",
        "asyncio.sleep",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic.Blueprint",
        "sanic.text",
        "sanic.compat.use_context",
        "sanic.log.logger"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(process_list) == num_workers + 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        },
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ]
    },
    {
      "name": "test_pickle_app",
      "module": "test_multiprocessing",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_multiprocessing.py",
      "line_number": 96,
      "end_line_number": 105,
      "source_code": "def test_pickle_app(app, protocol, port):\n    app.route(\"/\")(handler)\n    app.after_server_start(stop)\n    app.router.reset()\n    app.signal_router.reset()\n    p_app = pickle.dumps(app, protocol=protocol)\n    del app\n    up_p_app = pickle.loads(p_app)\n    assert up_p_app\n    up_p_app.run(single_process=True, port=port)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('protocol', [3, 4])"
      ],
      "arguments": [
        "app",
        "protocol",
        "port"
      ],
      "imports": [
        "logging",
        "multiprocessing",
        "pickle",
        "random",
        "signal",
        "sys",
        "asyncio.sleep",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic.Blueprint",
        "sanic.text",
        "sanic.compat.use_context",
        "sanic.log.logger"
      ],
      "fixtures": [],
      "assertions": [
        "assert up_p_app"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.router.reset",
          "body": "@pytest.fixture(autouse=True)\ndef reset():\n    try:\n        del os.environ['SANIC_MOTD_OUTPUT']\n    except KeyError:\n        ..."
        },
        {
          "name": "app.signal_router.reset",
          "body": "@pytest.fixture(autouse=True)\ndef reset():\n    try:\n        del os.environ['SANIC_MOTD_OUTPUT']\n    except KeyError:\n        ..."
        },
        {
          "name": "up_p_app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ]
    },
    {
      "name": "test_pickle_app_with_bp",
      "module": "test_multiprocessing",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_multiprocessing.py",
      "line_number": 109,
      "end_line_number": 120,
      "source_code": "def test_pickle_app_with_bp(app, protocol, port):\n    bp = Blueprint(\"test_text\")\n    bp.route(\"/\")(handler)\n    bp.after_server_start(stop)\n    app.blueprint(bp)\n    app.router.reset()\n    app.signal_router.reset()\n    p_app = pickle.dumps(app, protocol=protocol)\n    del app\n    up_p_app = pickle.loads(p_app)\n    assert up_p_app\n    up_p_app.run(single_process=True, port=port)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('protocol', [3, 4])"
      ],
      "arguments": [
        "app",
        "protocol",
        "port"
      ],
      "imports": [
        "logging",
        "multiprocessing",
        "pickle",
        "random",
        "signal",
        "sys",
        "asyncio.sleep",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic.Blueprint",
        "sanic.text",
        "sanic.compat.use_context",
        "sanic.log.logger"
      ],
      "fixtures": [],
      "assertions": [
        "assert up_p_app"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.router.reset",
          "body": "@pytest.fixture(autouse=True)\ndef reset():\n    try:\n        del os.environ['SANIC_MOTD_OUTPUT']\n    except KeyError:\n        ..."
        },
        {
          "name": "app.signal_router.reset",
          "body": "@pytest.fixture(autouse=True)\ndef reset():\n    try:\n        del os.environ['SANIC_MOTD_OUTPUT']\n    except KeyError:\n        ..."
        },
        {
          "name": "up_p_app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ]
    },
    {
      "name": "test_pickle_app_with_static",
      "module": "test_multiprocessing",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_multiprocessing.py",
      "line_number": 124,
      "end_line_number": 134,
      "source_code": "def test_pickle_app_with_static(app, protocol):\n    app.route(\"/\")(handler)\n    app.after_server_start(stop)\n    app.static(\"/static\", \"/tmp/static\")\n    app.router.reset()\n    app.signal_router.reset()\n    p_app = pickle.dumps(app, protocol=protocol)\n    del app\n    up_p_app = pickle.loads(p_app)\n    assert up_p_app\n    up_p_app.run(single_process=True)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('protocol', [3, 4])"
      ],
      "arguments": [
        "app",
        "protocol"
      ],
      "imports": [
        "logging",
        "multiprocessing",
        "pickle",
        "random",
        "signal",
        "sys",
        "asyncio.sleep",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic.Blueprint",
        "sanic.text",
        "sanic.compat.use_context",
        "sanic.log.logger"
      ],
      "fixtures": [],
      "assertions": [
        "assert up_p_app"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.router.reset",
          "body": "@pytest.fixture(autouse=True)\ndef reset():\n    try:\n        del os.environ['SANIC_MOTD_OUTPUT']\n    except KeyError:\n        ..."
        },
        {
          "name": "app.signal_router.reset",
          "body": "@pytest.fixture(autouse=True)\ndef reset():\n    try:\n        del os.environ['SANIC_MOTD_OUTPUT']\n    except KeyError:\n        ..."
        },
        {
          "name": "up_p_app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ]
    },
    {
      "name": "test_main_process_event",
      "module": "test_multiprocessing",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_multiprocessing.py",
      "line_number": 141,
      "end_line_number": 174,
      "source_code": "def test_main_process_event(app, caplog, port):\n    # Selects a number at random so we can spot check\n    num_workers = random.choice(range(2, multiprocessing.cpu_count() * 2 + 1))\n\n    app.after_server_start(stop)\n\n    @app.listener(\"main_process_start\")\n    def main_process_start(app, loop):\n        logger.info(\"main_process_start\")\n\n    @app.listener(\"main_process_stop\")\n    def main_process_stop(app, loop):\n        logger.info(\"main_process_stop\")\n\n    @app.main_process_start\n    def main_process_start2(app, loop):\n        logger.info(\"main_process_start\")\n\n    @app.main_process_stop\n    def main_process_stop2(app, loop):\n        logger.info(\"main_process_stop\")\n\n    with use_context(\"fork\"):\n        with caplog.at_level(logging.INFO):\n            app.run(HOST, port, workers=num_workers)\n\n    assert (\n        caplog.record_tuples.count((\"sanic.root\", 20, \"main_process_start\"))\n        == 2\n    )\n    assert (\n        caplog.record_tuples.count((\"sanic.root\", 20, \"main_process_stop\"))\n        == 2\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(sys.platform not in ('linux', 'darwin'), reason='This test requires fork context')"
      ],
      "arguments": [
        "app",
        "caplog",
        "port"
      ],
      "imports": [
        "logging",
        "multiprocessing",
        "pickle",
        "random",
        "signal",
        "sys",
        "asyncio.sleep",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic.Blueprint",
        "sanic.text",
        "sanic.compat.use_context",
        "sanic.log.logger"
      ],
      "fixtures": [],
      "assertions": [
        "assert caplog.record_tuples.count(('sanic.root', 20, 'main_process_start')) == 2",
        "assert caplog.record_tuples.count(('sanic.root', 20, 'main_process_stop')) == 2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ]
    },
    {
      "name": "test_change_encoder",
      "module": "test_json_encoding",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_json_encoding.py",
      "line_number": 56,
      "end_line_number": 58,
      "source_code": "def test_change_encoder():\n    Sanic(\"Test\", dumps=sdumps)\n    assert BaseHTTPResponse._dumps == sdumps",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "sys",
        "dataclasses.asdict",
        "dataclasses.dataclass",
        "functools.partial",
        "json.dumps",
        "string.ascii_lowercase",
        "typing.Dict",
        "pytest",
        "sanic.Sanic",
        "sanic.response.BaseHTTPResponse",
        "sanic.response.json",
        "ujson",
        "ujson.dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert BaseHTTPResponse._dumps == sdumps"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_change_encoder_to_some_custom",
      "module": "test_json_encoding",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_json_encoding.py",
      "line_number": 61,
      "end_line_number": 66,
      "source_code": "def test_change_encoder_to_some_custom():\n    def my_custom_encoder():\n        return \"foo\"\n\n    Sanic(\"Test\", dumps=my_custom_encoder)\n    assert BaseHTTPResponse._dumps == my_custom_encoder",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "sys",
        "dataclasses.asdict",
        "dataclasses.dataclass",
        "functools.partial",
        "json.dumps",
        "string.ascii_lowercase",
        "typing.Dict",
        "pytest",
        "sanic.Sanic",
        "sanic.response.BaseHTTPResponse",
        "sanic.response.json",
        "ujson",
        "ujson.dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert BaseHTTPResponse._dumps == my_custom_encoder"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_json_response_ujson",
      "module": "test_json_encoding",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_json_encoding.py",
      "line_number": 70,
      "end_line_number": 84,
      "source_code": "def test_json_response_ujson(payload: Dict[str, Foo]):\n    \"\"\"ujson will look at __json__\"\"\"\n    response = json(payload)\n    assert response.body == b'{\"foo\":{\"bar\":\"bar\"}}'\n\n    with pytest.raises(\n        TypeError, match=\"Object of type Foo is not JSON serializable\"\n    ):\n        json(payload, dumps=sdumps)\n\n    Sanic(\"Test\", dumps=sdumps)\n    with pytest.raises(\n        TypeError, match=\"Object of type Foo is not JSON serializable\"\n    ):\n        json(payload)",
      "docstring": "ujson will look at __json__",
      "decorators": [
        "pytest.mark.skipif(NO_UJSON is True, reason='ujson not installed')"
      ],
      "arguments": [
        "payload"
      ],
      "imports": [
        "sys",
        "dataclasses.asdict",
        "dataclasses.dataclass",
        "functools.partial",
        "json.dumps",
        "string.ascii_lowercase",
        "typing.Dict",
        "pytest",
        "sanic.Sanic",
        "sanic.response.BaseHTTPResponse",
        "sanic.response.json",
        "ujson",
        "ujson.dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.body == b'{\"foo\":{\"bar\":\"bar\"}}'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_json_response_json",
      "module": "test_json_encoding",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_json_encoding.py",
      "line_number": 94,
      "end_line_number": 107,
      "source_code": "def test_json_response_json():\n    \"\"\"One of the easiest ways to tell the difference is that ujson cannot\n    serialize over 64 bits\"\"\"\n    too_big_for_ujson = 111111111111111111111\n\n    with pytest.raises(OverflowError, match=\"int too big to convert\"):\n        json(too_big_for_ujson)\n\n    response = json(too_big_for_ujson, dumps=sdumps)\n    assert sys.getsizeof(response.body) == 54\n\n    Sanic(\"Test\", dumps=sdumps)\n    response = json(too_big_for_ujson)\n    assert sys.getsizeof(response.body) == 54",
      "docstring": "One of the easiest ways to tell the difference is that ujson cannot\nserialize over 64 bits",
      "decorators": [
        "pytest.mark.skipif(NO_UJSON is True or ujson_version >= (5, 4, 0), reason='ujson not installed or version is 5.4.0 or newer, which can handle arbitrary size integers')"
      ],
      "arguments": [],
      "imports": [
        "sys",
        "dataclasses.asdict",
        "dataclasses.dataclass",
        "functools.partial",
        "json.dumps",
        "string.ascii_lowercase",
        "typing.Dict",
        "pytest",
        "sanic.Sanic",
        "sanic.response.BaseHTTPResponse",
        "sanic.response.json",
        "ujson",
        "ujson.dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert sys.getsizeof(response.body) == 54",
        "assert sys.getsizeof(response.body) == 54"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_custom_context",
      "module": "test_request_data",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request_data.py",
      "line_number": 12,
      "end_line_number": 64,
      "source_code": "def test_custom_context(app):\n    @app.middleware(\"request\")\n    def store(request):\n        request.ctx.user = \"sanic\"\n        request.ctx.session = None\n\n    @app.route(\"/\")\n    def handler(request):\n        # Accessing non-existent key should fail with AttributeError\n        try:\n            invalid = request.ctx.missing\n        except AttributeError as e:\n            invalid = str(e)\n        return json(\n            {\n                \"user\": request.ctx.user,\n                \"session\": request.ctx.session,\n                \"has_user\": hasattr(request.ctx, \"user\"),\n                \"has_session\": hasattr(request.ctx, \"session\"),\n                \"has_missing\": hasattr(request.ctx, \"missing\"),\n                \"invalid\": invalid,\n            }\n        )\n\n    @app.middleware(\"response\")\n    def modify(request, response):\n        # Using response-middleware to access request ctx\n        try:\n            user = request.ctx.user\n        except AttributeError as e:\n            user = str(e)\n        try:\n            invalid = request.ctx.missing\n        except AttributeError as e:\n            invalid = str(e)\n\n        j = loads(response.body)\n        j[\"response_mw_valid\"] = user\n        j[\"response_mw_invalid\"] = invalid\n        return json(j)\n\n    request, response = app.test_client.get(\"/\")\n    assert response.json == {\n        \"user\": \"sanic\",\n        \"session\": None,\n        \"has_user\": True,\n        \"has_session\": True,\n        \"has_missing\": False,\n        \"invalid\": \"'types.SimpleNamespace' object has no attribute 'missing'\",\n        \"response_mw_valid\": \"sanic\",\n        \"response_mw_invalid\": \"'types.SimpleNamespace' object has no\"\n        \" attribute 'missing'\",\n    }",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "random",
        "sanic.response.json",
        "ujson.loads",
        "json.loads"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json == {'user': 'sanic', 'session': None, 'has_user': True, 'has_session': True, 'has_missing': False, 'invalid': \"'types.SimpleNamespace' object has no attribute 'missing'\", 'response_mw_valid': 'sanic', 'response_mw_invalid': \"'types.SimpleNamespace' object has no attribute 'missing'\"}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_app_injection",
      "module": "test_request_data",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request_data.py",
      "line_number": 67,
      "end_line_number": 81,
      "source_code": "def test_app_injection(app):\n    expected = random.choice(range(0, 100))\n\n    @app.listener(\"after_server_start\")\n    async def inject_data(app, loop):\n        app.ctx.injected = expected\n\n    @app.get(\"/\")\n    async def handler(request):\n        return json({\"injected\": request.app.ctx.injected})\n\n    request, response = app.test_client.get(\"/\")\n\n    response_json = loads(response.text)\n    assert response_json[\"injected\"] == expected",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "random",
        "sanic.response.json",
        "ujson.loads",
        "json.loads"
      ],
      "fixtures": [],
      "assertions": [
        "assert response_json['injected'] == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_middleware_request",
      "module": "test_middleware",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware.py",
      "line_number": 16,
      "end_line_number": 30,
      "source_code": "def test_middleware_request(app):\n    results = []\n\n    @app.middleware\n    async def handler1(request):\n        results.append(request)\n\n    @app.route(\"/\")\n    async def handler2(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/\")\n\n    assert response.text == \"OK\"\n    assert type(results[0]) is Request",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "asyncio.CancelledError",
        "asyncio.sleep",
        "itertools.count",
        "sanic.exceptions.NotFound",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert type(results[0]) is Request"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_middleware_request_as_convenience",
      "module": "test_middleware",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware.py",
      "line_number": 33,
      "end_line_number": 52,
      "source_code": "def test_middleware_request_as_convenience(app):\n    results = []\n\n    @app.on_request\n    async def handler1(request):\n        results.append(request)\n\n    @app.on_request()\n    async def handler2(request):\n        results.append(request)\n\n    @app.route(\"/\")\n    async def handler3(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/\")\n\n    assert response.text == \"OK\"\n    assert type(results[0]) is Request\n    assert type(results[1]) is Request",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "asyncio.CancelledError",
        "asyncio.sleep",
        "itertools.count",
        "sanic.exceptions.NotFound",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert type(results[0]) is Request",
        "assert type(results[1]) is Request"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_middleware_response",
      "module": "test_middleware",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware.py",
      "line_number": 55,
      "end_line_number": 76,
      "source_code": "def test_middleware_response(app):\n    results = []\n\n    @app.middleware(\"request\")\n    async def process_request(request):\n        results.append(request)\n\n    @app.middleware(\"response\")\n    async def process_response(request, response):\n        results.append(request)\n        results.append(response)\n\n    @app.route(\"/\")\n    async def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/\")\n\n    assert response.text == \"OK\"\n    assert type(results[0]) is Request\n    assert type(results[1]) is Request\n    assert isinstance(results[2], HTTPResponse)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "asyncio.CancelledError",
        "asyncio.sleep",
        "itertools.count",
        "sanic.exceptions.NotFound",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert type(results[0]) is Request",
        "assert type(results[1]) is Request",
        "assert isinstance(results[2], HTTPResponse)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_middleware_response_as_convenience",
      "module": "test_middleware",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware.py",
      "line_number": 79,
      "end_line_number": 107,
      "source_code": "def test_middleware_response_as_convenience(app):\n    results = []\n\n    @app.on_request\n    async def process_request(request):\n        results.append(request)\n\n    @app.on_response\n    async def process_response_1(request, response):\n        results.append(request)\n        results.append(response)\n\n    @app.on_response()\n    async def process_response_2(request, response):\n        results.append(request)\n        results.append(response)\n\n    @app.route(\"/\")\n    async def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/\")\n\n    assert response.text == \"OK\"\n    assert type(results[0]) is Request\n    assert type(results[1]) is Request\n    assert isinstance(results[2], HTTPResponse)\n    assert type(results[3]) is Request\n    assert isinstance(results[4], HTTPResponse)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "asyncio.CancelledError",
        "asyncio.sleep",
        "itertools.count",
        "sanic.exceptions.NotFound",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert type(results[0]) is Request",
        "assert type(results[1]) is Request",
        "assert isinstance(results[2], HTTPResponse)",
        "assert type(results[3]) is Request",
        "assert isinstance(results[4], HTTPResponse)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_middleware_response_as_convenience_called",
      "module": "test_middleware",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware.py",
      "line_number": 110,
      "end_line_number": 131,
      "source_code": "def test_middleware_response_as_convenience_called(app):\n    results = []\n\n    @app.on_request()\n    async def process_request(request):\n        results.append(request)\n\n    @app.on_response()\n    async def process_response(request, response):\n        results.append(request)\n        results.append(response)\n\n    @app.route(\"/\")\n    async def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/\")\n\n    assert response.text == \"OK\"\n    assert type(results[0]) is Request\n    assert type(results[1]) is Request\n    assert isinstance(results[2], HTTPResponse)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "asyncio.CancelledError",
        "asyncio.sleep",
        "itertools.count",
        "sanic.exceptions.NotFound",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert type(results[0]) is Request",
        "assert type(results[1]) is Request",
        "assert isinstance(results[2], HTTPResponse)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_middleware_response_exception",
      "module": "test_middleware",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware.py",
      "line_number": 134,
      "end_line_number": 152,
      "source_code": "def test_middleware_response_exception(app):\n    result = {\"status_code\": \"middleware not run\"}\n\n    @app.middleware(\"response\")\n    async def process_response(request, response):\n        result[\"status_code\"] = response.status\n        return response\n\n    @app.exception(NotFound)\n    async def error_handler(request, exception):\n        return text(\"OK\", exception.status_code)\n\n    @app.route(\"/\")\n    async def handler(request):\n        return text(\"FAIL\")\n\n    request, response = app.test_client.get(\"/page_not_found\")\n    assert response.text == \"OK\"\n    assert result[\"status_code\"] == 404",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "asyncio.CancelledError",
        "asyncio.sleep",
        "itertools.count",
        "sanic.exceptions.NotFound",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert result['status_code'] == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.exception",
          "body": "@app.route('/')\ndef exception(request):\n    raise SanicExceptionTestException(\"You won't see me\")"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_middleware_response_raise_cancelled_error",
      "module": "test_middleware",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware.py",
      "line_number": 155,
      "end_line_number": 174,
      "source_code": "def test_middleware_response_raise_cancelled_error(app, caplog):\n    app.config.RESPONSE_TIMEOUT = 1\n\n    @app.middleware(\"response\")\n    async def process_response(request, response):\n        raise CancelledError(\"CancelledError at response middleware\")\n\n    @app.get(\"/\")\n    def handler(request):\n        return text(\"OK\")\n\n    with caplog.at_level(logging.ERROR):\n        reqrequest, response = app.test_client.get(\"/\")\n\n        assert response.status == 500\n        assert (\n            \"sanic.error\",\n            logging.ERROR,\n            \"Exception occurred while handling uri: 'http://127.0.0.1:42101/'\",\n        ) not in caplog.record_tuples",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "caplog"
      ],
      "imports": [
        "logging",
        "asyncio.CancelledError",
        "asyncio.sleep",
        "itertools.count",
        "sanic.exceptions.NotFound",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert ('sanic.error', logging.ERROR, \"Exception occurred while handling uri: 'http://127.0.0.1:42101/'\") not in caplog.record_tuples"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_middleware_response_raise_exception",
      "module": "test_middleware",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware.py",
      "line_number": 177,
      "end_line_number": 198,
      "source_code": "def test_middleware_response_raise_exception(app, caplog):\n    @app.middleware(\"response\")\n    async def process_response(request, response):\n        raise Exception(\"Exception at response middleware\")\n\n    app.route(\"/\")(lambda x: x)\n    with caplog.at_level(logging.ERROR):\n        reqrequest, response = app.test_client.get(\"/fail\")\n\n    assert response.status == 404\n    # 404 errors are not logged\n    assert (\n        \"sanic.error\",\n        logging.ERROR,\n        \"Exception occurred while handling uri: 'http://127.0.0.1:42101/'\",\n    ) not in caplog.record_tuples\n    # Middleware exception ignored but logged\n    assert (\n        \"sanic.error\",\n        logging.ERROR,\n        \"Exception occurred in one of response middleware handlers\",\n    ) in caplog.record_tuples",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "caplog"
      ],
      "imports": [
        "logging",
        "asyncio.CancelledError",
        "asyncio.sleep",
        "itertools.count",
        "sanic.exceptions.NotFound",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 404",
        "assert ('sanic.error', logging.ERROR, \"Exception occurred while handling uri: 'http://127.0.0.1:42101/'\") not in caplog.record_tuples",
        "assert ('sanic.error', logging.ERROR, 'Exception occurred in one of response middleware handlers') in caplog.record_tuples"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_middleware_override_request",
      "module": "test_middleware",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware.py",
      "line_number": 201,
      "end_line_number": 213,
      "source_code": "def test_middleware_override_request(app):\n    @app.middleware\n    async def halt_request(request):\n        return text(\"OK\")\n\n    @app.route(\"/\")\n    async def handler(request):\n        return text(\"FAIL\")\n\n    _, response = app.test_client.get(\"/\", gather_request=False)\n\n    assert response.status == 200\n    assert response.text == \"OK\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "asyncio.CancelledError",
        "asyncio.sleep",
        "itertools.count",
        "sanic.exceptions.NotFound",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_middleware_override_response",
      "module": "test_middleware",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware.py",
      "line_number": 216,
      "end_line_number": 228,
      "source_code": "def test_middleware_override_response(app):\n    @app.middleware(\"response\")\n    async def process_response(request, response):\n        return text(\"OK\")\n\n    @app.route(\"/\")\n    async def handler(request):\n        return text(\"FAIL\")\n\n    request, response = app.test_client.get(\"/\")\n\n    assert response.status == 200\n    assert response.text == \"OK\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "asyncio.CancelledError",
        "asyncio.sleep",
        "itertools.count",
        "sanic.exceptions.NotFound",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_middleware_order",
      "module": "test_middleware",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware.py",
      "line_number": 231,
      "end_line_number": 265,
      "source_code": "def test_middleware_order(app):\n    order = []\n\n    @app.middleware(\"request\")\n    async def request1(request):\n        order.append(1)\n\n    @app.middleware(\"request\")\n    async def request2(request):\n        order.append(2)\n\n    @app.middleware(\"request\")\n    async def request3(request):\n        order.append(3)\n\n    @app.middleware(\"response\")\n    async def response1(request, response):\n        order.append(6)\n\n    @app.middleware(\"response\")\n    async def response2(request, response):\n        order.append(5)\n\n    @app.middleware(\"response\")\n    async def response3(request, response):\n        order.append(4)\n\n    @app.route(\"/\")\n    async def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/\")\n\n    assert response.status == 200\n    assert order == [1, 2, 3, 4, 5, 6]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "asyncio.CancelledError",
        "asyncio.sleep",
        "itertools.count",
        "sanic.exceptions.NotFound",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert order == [1, 2, 3, 4, 5, 6]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_request_middleware_executes_once",
      "module": "test_middleware",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware.py",
      "line_number": 268,
      "end_line_number": 285,
      "source_code": "def test_request_middleware_executes_once(app):\n    i = count()\n\n    @app.middleware(\"request\")\n    async def inc(request):\n        nonlocal i\n        next(i)\n\n    @app.route(\"/\")\n    async def handler(request):\n        await request.app._run_request_middleware(request)\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/\")\n    assert next(i) == 1\n\n    request, response = app.test_client.get(\"/\")\n    assert next(i) == 3",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "asyncio.CancelledError",
        "asyncio.sleep",
        "itertools.count",
        "sanic.exceptions.NotFound",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert next(i) == 1",
        "assert next(i) == 3"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_middleware_added_response",
      "module": "test_middleware",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware.py",
      "line_number": 288,
      "end_line_number": 299,
      "source_code": "def test_middleware_added_response(app):\n    @app.on_response\n    def display(_, response):\n        response[\"foo\"] = \"bar\"\n        return json(response)\n\n    @app.get(\"/\")\n    async def handler(request):\n        return {}\n\n    _, response = app.test_client.get(\"/\")\n    assert response.json[\"foo\"] == \"bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "asyncio.CancelledError",
        "asyncio.sleep",
        "itertools.count",
        "sanic.exceptions.NotFound",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json['foo'] == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_middleware_return_response",
      "module": "test_middleware",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware.py",
      "line_number": 302,
      "end_line_number": 323,
      "source_code": "def test_middleware_return_response(app):\n    response_middleware_run_count = 0\n    request_middleware_run_count = 0\n\n    @app.on_response\n    def response(_, response):\n        nonlocal response_middleware_run_count\n        response_middleware_run_count += 1\n\n    @app.on_request\n    def request(_):\n        nonlocal request_middleware_run_count\n        request_middleware_run_count += 1\n\n    @app.get(\"/\")\n    async def handler(request):\n        resp1 = await request.respond()\n        return resp1\n\n    app.test_client.get(\"/\")\n    assert response_middleware_run_count == 1\n    assert request_middleware_run_count == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "asyncio.CancelledError",
        "asyncio.sleep",
        "itertools.count",
        "sanic.exceptions.NotFound",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response_middleware_run_count == 1",
        "assert request_middleware_run_count == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_middleware_run_on_timeout",
      "module": "test_middleware",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware.py",
      "line_number": 326,
      "end_line_number": 349,
      "source_code": "def test_middleware_run_on_timeout(app):\n    app.config.RESPONSE_TIMEOUT = 0.1\n    response_middleware_run_count = 0\n    request_middleware_run_count = 0\n\n    @app.on_response\n    def response(_, response):\n        nonlocal response_middleware_run_count\n        response_middleware_run_count += 1\n\n    @app.on_request\n    def request(_):\n        nonlocal request_middleware_run_count\n        request_middleware_run_count += 1\n\n    @app.get(\"/\")\n    async def handler(request):\n        resp1 = await request.respond()\n        await sleep(1)\n        return resp1\n\n    app.test_client.get(\"/\")\n    assert request_middleware_run_count == 1\n    assert response_middleware_run_count == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "asyncio.CancelledError",
        "asyncio.sleep",
        "itertools.count",
        "sanic.exceptions.NotFound",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request_middleware_run_count == 1",
        "assert response_middleware_run_count == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_add_signal",
      "module": "test_signals",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_signals.py",
      "line_number": 15,
      "end_line_number": 20,
      "source_code": "def test_add_signal(app):\n    def sync_signal(*_): ...\n\n    app.add_signal(sync_signal, \"foo.bar.baz\")\n\n    assert len(app.signal_router.routes) == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "enum.Enum",
        "itertools.count",
        "pytest",
        "sanic_routing.exceptions.NotFound",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.empty",
        "sanic.exceptions.InvalidSignal",
        "sanic.exceptions.SanicException",
        "sanic.signals.Event"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(app.signal_router.routes) == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_add_signal_method_handler",
      "module": "test_signals",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_signals.py",
      "line_number": 23,
      "end_line_number": 45,
      "source_code": "def test_add_signal_method_handler(app):\n    counter = 0\n\n    class TestSanic(Sanic):\n        def __init__(self, *args, **kwargs):\n            super().__init__(*args, **kwargs)\n            self.add_signal(\n                self.after_routing_signal_handler, \"http.routing.after\"\n            )\n\n        def after_routing_signal_handler(self, *args, **kwargs):\n            nonlocal counter\n            counter += 1\n\n    app = TestSanic(\"Test\")\n    assert len(app.signal_router.routes) == 1\n\n    @app.route(\"/\")\n    async def handler(_):\n        return empty()\n\n    app.test_client.get(\"/\")\n    assert counter == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "enum.Enum",
        "itertools.count",
        "pytest",
        "sanic_routing.exceptions.NotFound",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.empty",
        "sanic.exceptions.InvalidSignal",
        "sanic.exceptions.SanicException",
        "sanic.signals.Event"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(app.signal_router.routes) == 1",
        "assert counter == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_add_signal_decorator",
      "module": "test_signals",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_signals.py",
      "line_number": 48,
      "end_line_number": 56,
      "source_code": "def test_add_signal_decorator(app):\n    @app.signal(\"foo.bar.baz\")\n    def sync_signal(*_): ...\n\n    @app.signal(\"foo.bar.baz\")\n    async def async_signal(*_): ...\n\n    assert len(app.signal_router.routes) == 2\n    assert len(app.signal_router.dynamic_routes) == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "enum.Enum",
        "itertools.count",
        "pytest",
        "sanic_routing.exceptions.NotFound",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.empty",
        "sanic.exceptions.InvalidSignal",
        "sanic.exceptions.SanicException",
        "sanic.signals.Event"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(app.signal_router.routes) == 2",
        "assert len(app.signal_router.dynamic_routes) == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_invalid_signal",
      "module": "test_signals",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_signals.py",
      "line_number": 68,
      "end_line_number": 72,
      "source_code": "def test_invalid_signal(app, signal):\n    with pytest.raises(InvalidSignal, match=f\"Invalid signal event: {signal}\"):\n\n        @app.signal(signal)\n        def handler(): ...",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('signal', ('<foo>.bar.bax', 'foo.<bar>.baz', 'foo.bar', 'foo.bar.baz.qux'))"
      ],
      "arguments": [
        "app",
        "signal"
      ],
      "imports": [
        "asyncio",
        "enum.Enum",
        "itertools.count",
        "pytest",
        "sanic_routing.exceptions.NotFound",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.empty",
        "sanic.exceptions.InvalidSignal",
        "sanic.exceptions.SanicException",
        "sanic.signals.Event"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_bad_finalize",
      "module": "test_signals",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_signals.py",
      "line_number": 562,
      "end_line_number": 575,
      "source_code": "def test_bad_finalize(app):\n    counter = 0\n\n    @app.signal(\"foo.bar.baz\")\n    def sync_signal(amount):\n        nonlocal counter\n        counter += amount\n\n    with pytest.raises(\n        RuntimeError, match=\"Cannot finalize signals outside of event loop\"\n    ):\n        app.signal_router.finalize()\n\n    assert counter == 0",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "enum.Enum",
        "itertools.count",
        "pytest",
        "sanic_routing.exceptions.NotFound",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.empty",
        "sanic.exceptions.InvalidSignal",
        "sanic.exceptions.SanicException",
        "sanic.signals.Event"
      ],
      "fixtures": [],
      "assertions": [
        "assert counter == 0"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_event_on_bp_not_registered",
      "module": "test_signals",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_signals.py",
      "line_number": 632,
      "end_line_number": 642,
      "source_code": "def test_event_on_bp_not_registered():\n    bp = Blueprint(\"bp\")\n\n    @bp.signal(\"foo.bar.baz\")\n    def bp_signal(): ...\n\n    with pytest.raises(\n        SanicException,\n        match=\"<Blueprint bp> has not yet been registered to an app\",\n    ):\n        bp.event(\"foo.bar.baz\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "enum.Enum",
        "itertools.count",
        "pytest",
        "sanic_routing.exceptions.NotFound",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.empty",
        "sanic.exceptions.InvalidSignal",
        "sanic.exceptions.SanicException",
        "sanic.signals.Event"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_signal_reservation",
      "module": "test_signals",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_signals.py",
      "line_number": 655,
      "end_line_number": 663,
      "source_code": "def test_signal_reservation(app, event, expected):\n    if not expected:\n        with pytest.raises(\n            InvalidSignal,\n            match=f\"Cannot declare reserved signal event: {event}\",\n        ):\n            app.signal(event)(lambda: ...)\n    else:\n        app.signal(event)(lambda: ...)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('event,expected', (('foo.bar.baz', True), ('server.init.before', True), ('server.init.somethingelse', False), ('http.request.start', False), ('sanic.notice.anything', True)))"
      ],
      "arguments": [
        "app",
        "event",
        "expected"
      ],
      "imports": [
        "asyncio",
        "enum.Enum",
        "itertools.count",
        "pytest",
        "sanic_routing.exceptions.NotFound",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.empty",
        "sanic.exceptions.InvalidSignal",
        "sanic.exceptions.SanicException",
        "sanic.signals.Event"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_report_exception_runs",
      "module": "test_signals",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_signals.py",
      "line_number": 687,
      "end_line_number": 700,
      "source_code": "def test_report_exception_runs(app: Sanic):\n    event = asyncio.Event()\n\n    @app.report_exception\n    async def catch_any_exception(app: Sanic, exception: Exception):\n        event.set()\n\n    @app.route(\"/\")\n    async def handler(request):\n        1 / 0\n\n    app.test_client.get(\"/\")\n\n    assert event.is_set()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "enum.Enum",
        "itertools.count",
        "pytest",
        "sanic_routing.exceptions.NotFound",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.empty",
        "sanic.exceptions.InvalidSignal",
        "sanic.exceptions.SanicException",
        "sanic.signals.Event"
      ],
      "fixtures": [],
      "assertions": [
        "assert event.is_set()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_report_exception_runs_once_inline",
      "module": "test_signals",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_signals.py",
      "line_number": 703,
      "end_line_number": 722,
      "source_code": "def test_report_exception_runs_once_inline(app: Sanic):\n    event = asyncio.Event()\n    c = count()\n\n    @app.report_exception\n    async def catch_any_exception(app: Sanic, exception: Exception):\n        event.set()\n        next(c)\n\n    @app.route(\"/\")\n    async def handler(request): ...\n\n    @app.signal(Event.HTTP_ROUTING_AFTER.value)\n    async def after_routing(**_):\n        1 / 0\n\n    app.test_client.get(\"/\")\n\n    assert event.is_set()\n    assert next(c) == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "enum.Enum",
        "itertools.count",
        "pytest",
        "sanic_routing.exceptions.NotFound",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.empty",
        "sanic.exceptions.InvalidSignal",
        "sanic.exceptions.SanicException",
        "sanic.signals.Event"
      ],
      "fixtures": [],
      "assertions": [
        "assert event.is_set()",
        "assert next(c) == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_report_exception_runs_once_custom",
      "module": "test_signals",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_signals.py",
      "line_number": 725,
      "end_line_number": 746,
      "source_code": "def test_report_exception_runs_once_custom(app: Sanic):\n    event = asyncio.Event()\n    c = count()\n\n    @app.report_exception\n    async def catch_any_exception(app: Sanic, exception: Exception):\n        event.set()\n        next(c)\n\n    @app.route(\"/\")\n    async def handler(request):\n        await app.dispatch(\"one.two.three\")\n        return empty()\n\n    @app.signal(\"one.two.three\")\n    async def one_two_three(**_):\n        1 / 0\n\n    app.test_client.get(\"/\")\n\n    assert event.is_set()\n    assert next(c) == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "enum.Enum",
        "itertools.count",
        "pytest",
        "sanic_routing.exceptions.NotFound",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.empty",
        "sanic.exceptions.InvalidSignal",
        "sanic.exceptions.SanicException",
        "sanic.signals.Event"
      ],
      "fixtures": [],
      "assertions": [
        "assert event.is_set()",
        "assert next(c) == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_report_exception_runs_task",
      "module": "test_signals",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_signals.py",
      "line_number": 749,
      "end_line_number": 772,
      "source_code": "def test_report_exception_runs_task(app: Sanic):\n    c = count()\n\n    async def task_1():\n        next(c)\n\n    async def task_2(app):\n        next(c)\n\n    @app.report_exception\n    async def catch_any_exception(app: Sanic, exception: Exception):\n        next(c)\n\n    @app.route(\"/\")\n    async def handler(request):\n        app.add_task(task_1)\n        app.add_task(task_1())\n        app.add_task(task_2)\n        app.add_task(task_2(app))\n        return empty()\n\n    app.test_client.get(\"/\")\n\n    assert next(c) == 4",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "enum.Enum",
        "itertools.count",
        "pytest",
        "sanic_routing.exceptions.NotFound",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.empty",
        "sanic.exceptions.InvalidSignal",
        "sanic.exceptions.SanicException",
        "sanic.signals.Event"
      ],
      "fixtures": [],
      "assertions": [
        "assert next(c) == 4"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.add_task",
          "body": "def add_task(self, func):\n    loop = asyncio.get_event_loop()\n    self.stay_active_task = loop.create_task(func(self))"
        },
        {
          "name": "app.add_task",
          "body": "def add_task(self, func):\n    loop = asyncio.get_event_loop()\n    self.stay_active_task = loop.create_task(func(self))"
        },
        {
          "name": "app.add_task",
          "body": "def add_task(self, func):\n    loop = asyncio.get_event_loop()\n    self.stay_active_task = loop.create_task(func(self))"
        },
        {
          "name": "app.add_task",
          "body": "def add_task(self, func):\n    loop = asyncio.get_event_loop()\n    self.stay_active_task = loop.create_task(func(self))"
        }
      ]
    },
    {
      "name": "test_no_exceptions_when_cancel_pending_request",
      "module": "test_graceful_shutdown",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_graceful_shutdown.py",
      "line_number": 12,
      "end_line_number": 31,
      "source_code": "def test_no_exceptions_when_cancel_pending_request(\n    app, caplog: LogCaptureFixture, port\n):\n    app.config.GRACEFUL_SHUTDOWN_TIMEOUT = 1\n\n    @app.get(\"/\")\n    async def handler(request):\n        await asyncio.sleep(5)\n\n    @app.listener(\"after_server_start\")\n    async def _request(sanic, loop):\n        connect = asyncio.open_connection(\"127.0.0.1\", port)\n        _, writer = await connect\n        writer.write(b\"GET / HTTP/1.1\\r\\n\\r\\n\")\n        app.stop()\n\n    with caplog.at_level(logging.INFO):\n        app.run(single_process=True, access_log=True, port=port)\n\n    assert \"Request: GET http:/// stopped. Transport is closed.\" in caplog.text",
      "docstring": null,
      "decorators": [
        "pytest.mark.xfail(reason='This test runs fine locally, but fails on CI')"
      ],
      "arguments": [
        "app",
        "caplog",
        "port"
      ],
      "imports": [
        "asyncio",
        "logging",
        "pytest",
        "pytest.LogCaptureFixture",
        "sanic.response.empty"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'Request: GET http:/// stopped. Transport is closed.' in caplog.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        },
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ]
    },
    {
      "name": "test_completes_request",
      "module": "test_graceful_shutdown",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_graceful_shutdown.py",
      "line_number": 34,
      "end_line_number": 61,
      "source_code": "def test_completes_request(app, caplog: LogCaptureFixture, port):\n    app.config.GRACEFUL_SHUTDOWN_TIMEOUT = 1\n\n    @app.get(\"/\")\n    async def handler(request):\n        await asyncio.sleep(0.5)\n        return empty()\n\n    @app.listener(\"after_server_start\")\n    async def _request(sanic, loop):\n        connect = asyncio.open_connection(\"127.0.0.1\", port)\n        _, writer = await connect\n        writer.write(b\"GET / HTTP/1.1\\r\\n\\r\\n\")\n        app.stop()\n\n    with caplog.at_level(logging.INFO):\n        app.run(single_process=True, access_log=True, port=port)\n\n    assert (\"sanic.access\", 20, \"\") in caplog.record_tuples\n\n    # Make sure that the server starts shutdown process before access log\n    index_stopping = 0\n    for idx, record in enumerate(caplog.records):\n        if record.message.startswith(\"Stopping worker\"):\n            index_stopping = idx\n            break\n    index_request = caplog.record_tuples.index((\"sanic.access\", 20, \"\"))\n    assert index_request > index_stopping > 0",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "caplog",
        "port"
      ],
      "imports": [
        "asyncio",
        "logging",
        "pytest",
        "pytest.LogCaptureFixture",
        "sanic.response.empty"
      ],
      "fixtures": [],
      "assertions": [
        "assert ('sanic.access', 20, '') in caplog.record_tuples",
        "assert index_request > index_stopping > 0"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "caplog.record_tuples.index",
          "body": "@app.route('/', name='hostindex', host='example.com')\n@app.route('/path', name='hostpath', host='path.example.com')\ndef index(request):\n    pass"
        },
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        },
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ]
    },
    {
      "name": "test_response_body_not_a_string",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 41,
      "end_line_number": 51,
      "source_code": "def test_response_body_not_a_string(app):\n    \"\"\"Test when a response body sent from the application is not a string\"\"\"\n    random_num = choice(range(1000))\n\n    @app.route(\"/hello\")\n    async def hello_route(request: Request):\n        return text(random_num)\n\n    request, response = app.test_client.get(\"/hello\")\n    assert response.status == 500\n    assert b\"Internal Server Error\" in response.body",
      "docstring": "Test when a response body sent from the application is not a string",
      "decorators": [
        "pytest.mark.filterwarnings('ignore:Types other than str will be')"
      ],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert b'Internal Server Error' in response.body"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_method_not_allowed",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 63,
      "end_line_number": 100,
      "source_code": "def test_method_not_allowed():\n    app = Sanic(\"app\")\n\n    @app.get(\"/\")\n    async def test_get(request: Request):\n        return response.json({\"hello\": \"world\"})\n\n    request, response = app.test_client.head(\"/\")\n    assert set(response.headers[\"Allow\"].split(\", \")) == {\n        \"GET\",\n    }\n\n    request, response = app.test_client.post(\"/\")\n    assert set(response.headers[\"Allow\"].split(\", \")) == {\n        \"GET\",\n    }\n\n    app.router.reset()\n\n    @app.post(\"/\")\n    async def test_post(request: Request):\n        return response.json({\"hello\": \"world\"})\n\n    request, response = app.test_client.head(\"/\")\n    assert response.status == 405\n    assert set(response.headers[\"Allow\"].split(\", \")) == {\n        \"GET\",\n        \"POST\",\n    }\n    assert response.headers[\"Content-Length\"] == \"0\"\n\n    request, response = app.test_client.patch(\"/\")\n    assert response.status == 405\n    assert set(response.headers[\"Allow\"].split(\", \")) == {\n        \"GET\",\n        \"POST\",\n    }\n    assert response.headers[\"Content-Length\"] == \"0\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert set(response.headers['Allow'].split(', ')) == {'GET'}",
        "assert set(response.headers['Allow'].split(', ')) == {'GET'}",
        "assert response.status == 405",
        "assert set(response.headers['Allow'].split(', ')) == {'GET', 'POST'}",
        "assert response.headers['Content-Length'] == '0'",
        "assert response.status == 405",
        "assert set(response.headers['Allow'].split(', ')) == {'GET', 'POST'}",
        "assert response.headers['Content-Length'] == '0'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "app.test_client.patch('/')"
      ],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.head",
          "body": "def head(self, request):\n    return text('', headers={'method': 'HEAD'})"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.router.reset",
          "body": "@pytest.fixture(autouse=True)\ndef reset():\n    try:\n        del os.environ['SANIC_MOTD_OUTPUT']\n    except KeyError:\n        ..."
        },
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.head",
          "body": "def head(self, request):\n    return text('', headers={'method': 'HEAD'})"
        },
        {
          "name": "app.test_client.patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ]
    },
    {
      "name": "test_response_header",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 103,
      "end_line_number": 114,
      "source_code": "def test_response_header(app):\n    @app.get(\"/\")\n    async def test(request: Request):\n        return json({\"ok\": True}, headers={\"CONTENT-TYPE\": \"application/json\"})\n\n    request, response = app.test_client.get(\"/\")\n    for key, value in {\n        \"connection\": \"keep-alive\",\n        \"content-length\": \"11\",\n        \"content-type\": \"application/json\",\n    }.items():\n        assert response.headers[key] == value",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.headers[key] == value"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_response_content_length",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 117,
      "end_line_number": 147,
      "source_code": "def test_response_content_length(app):\n    @app.get(\"/response_with_space\")\n    async def response_with_space(request: Request):\n        return json(\n            {\"message\": \"Data\", \"details\": \"Some Details\"},\n            headers={\"CONTENT-TYPE\": \"application/json\"},\n        )\n\n    @app.get(\"/response_without_space\")\n    async def response_without_space(request: Request):\n        return json(\n            {\"message\": \"Data\", \"details\": \"Some Details\"},\n            headers={\"CONTENT-TYPE\": \"application/json\"},\n        )\n\n    _, response = app.test_client.get(\"/response_with_space\")\n    content_length_for_response_with_space = response.headers.get(\n        \"Content-Length\"\n    )\n\n    _, response = app.test_client.get(\"/response_without_space\")\n    content_length_for_response_without_space = response.headers.get(\n        \"Content-Length\"\n    )\n\n    assert (\n        content_length_for_response_with_space\n        == content_length_for_response_without_space\n    )\n\n    assert content_length_for_response_with_space == \"43\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert content_length_for_response_with_space == content_length_for_response_without_space",
        "assert content_length_for_response_with_space == '43'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response.headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response.headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_response_content_length_with_different_data_types",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 150,
      "end_line_number": 160,
      "source_code": "def test_response_content_length_with_different_data_types(app):\n    @app.get(\"/\")\n    async def get_data_with_different_types(request: Request):\n        # Indentation issues in the Response is intentional. Please do not fix\n        return json(\n            {\"bool\": True, \"none\": None, \"string\": \"string\", \"number\": -1},\n            headers={\"CONTENT-TYPE\": \"application/json\"},\n        )\n\n    _, response = app.test_client.get(\"/\")\n    assert response.headers.get(\"Content-Length\") == \"55\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.headers.get('Content-Length') == '55'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response.headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_json_response",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 192,
      "end_line_number": 202,
      "source_code": "def test_json_response(json_app):\n    from sanic.response import json_dumps\n\n    request, response = json_app.test_client.get(\"/\")\n    assert response.status == 200\n    assert response.text == json_dumps(JSON_DATA)\n    assert response.json == JSON_DATA\n\n    request, response = json_app.test_client.get(\"/precondition\")\n    assert response.status == 412\n    assert response.json == JSON_DATA",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == json_dumps(JSON_DATA)",
        "assert response.json == JSON_DATA",
        "assert response.status == 412",
        "assert response.json == JSON_DATA"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_no_content",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 205,
      "end_line_number": 226,
      "source_code": "def test_no_content(json_app):\n    request, response = json_app.test_client.get(\"/no-content\")\n    assert response.status == 204\n    assert response.text == \"\"\n    assert \"Content-Length\" not in response.headers\n\n    request, response = json_app.test_client.get(\"/no-content/unmodified\")\n    assert response.status == 304\n    assert response.text == \"\"\n    assert \"Content-Length\" not in response.headers\n    assert \"Content-Type\" not in response.headers\n\n    request, response = json_app.test_client.get(\"/unmodified\")\n    assert response.status == 304\n    assert response.text == \"\"\n    assert \"Content-Length\" not in response.headers\n    assert \"Content-Type\" not in response.headers\n\n    request, response = json_app.test_client.delete(\"/\")\n    assert response.status == 204\n    assert response.text == \"\"\n    assert \"Content-Length\" not in response.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "json_app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 204",
        "assert response.text == ''",
        "assert 'Content-Length' not in response.headers",
        "assert response.status == 304",
        "assert response.text == ''",
        "assert 'Content-Length' not in response.headers",
        "assert 'Content-Type' not in response.headers",
        "assert response.status == 304",
        "assert response.text == ''",
        "assert 'Content-Length' not in response.headers",
        "assert 'Content-Type' not in response.headers",
        "assert response.status == 204",
        "assert response.text == ''",
        "assert 'Content-Length' not in response.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "json_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "json_app.test_client.delete",
          "body": "def delete(self, request):\n    return text('I am delete method')"
        }
      ]
    },
    {
      "name": "test_chunked_streaming_adds_correct_headers",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 251,
      "end_line_number": 257,
      "source_code": "def test_chunked_streaming_adds_correct_headers(streaming_app):\n    request, response = streaming_app.test_client.get(\"/\")\n    assert response.headers[\"Transfer-Encoding\"] == \"chunked\"\n    assert response.headers[\"Content-Type\"] == \"text/csv\"\n    # Content-Length is not allowed by HTTP/1.1 specification\n    # when \"Transfer-Encoding: chunked\" is used\n    assert \"Content-Length\" not in response.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "streaming_app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.headers['Transfer-Encoding'] == 'chunked'",
        "assert response.headers['Content-Type'] == 'text/csv'",
        "assert 'Content-Length' not in response.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "streaming_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_chunked_streaming_returns_correct_content",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 260,
      "end_line_number": 262,
      "source_code": "def test_chunked_streaming_returns_correct_content(streaming_app):\n    request, response = streaming_app.test_client.get(\"/\")\n    assert response.text == \"foo,bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "streaming_app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'foo,bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "streaming_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_non_chunked_streaming_adds_correct_headers",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 271,
      "end_line_number": 276,
      "source_code": "def test_non_chunked_streaming_adds_correct_headers(non_chunked_streaming_app):\n    request, response = non_chunked_streaming_app.test_client.get(\"/\")\n\n    assert \"Transfer-Encoding\" not in response.headers\n    assert response.headers[\"Content-Type\"] == \"text/csv\"\n    assert response.headers[\"Content-Length\"] == \"7\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "non_chunked_streaming_app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'Transfer-Encoding' not in response.headers",
        "assert response.headers['Content-Type'] == 'text/csv'",
        "assert response.headers['Content-Length'] == '7'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "non_chunked_streaming_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_non_chunked_streaming_returns_correct_content",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 289,
      "end_line_number": 293,
      "source_code": "def test_non_chunked_streaming_returns_correct_content(\n    non_chunked_streaming_app,\n):\n    request, response = non_chunked_streaming_app.test_client.get(\"/\")\n    assert response.text == \"foo,bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "non_chunked_streaming_app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'foo,bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "non_chunked_streaming_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_stream_response_with_cookies",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 296,
      "end_line_number": 312,
      "source_code": "def test_stream_response_with_cookies(app):\n    @app.route(\"/\")\n    async def test(request: Request):\n        headers = Header()\n        cookies = CookieJar(headers)\n        cookies[\"test\"] = \"modified\"\n        cookies[\"test\"] = \"pass\"\n        response = await request.respond(\n            content_type=\"text/csv\", headers=headers\n        )\n\n        await response.send(\"foo,\")\n        await asyncio.sleep(0.001)\n        await response.send(\"bar\")\n\n    request, response = app.test_client.get(\"/\")\n    assert response.cookies[\"test\"] == \"pass\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.cookies['test'] == 'pass'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "response.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        }
      ]
    },
    {
      "name": "test_stream_response_without_cookies",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 315,
      "end_line_number": 321,
      "source_code": "def test_stream_response_without_cookies(app):\n    @app.route(\"/\")\n    async def test(request: Request):\n        await sample_streaming_fn(request)\n\n    request, response = app.test_client.get(\"/\")\n    assert response.cookies == {}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.cookies == {}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_file_response",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 358,
      "end_line_number": 372,
      "source_code": "def test_file_response(app: Sanic, file_name, static_file_directory, status):\n    @app.route(\"/files/<filename>\", methods=[\"GET\"])\n    def file_route(request, filename):\n        file_path = os.path.join(static_file_directory, filename)\n        file_path = os.path.abspath(unquote(file_path))\n        return file(\n            file_path,\n            status=status,\n            mime_type=guess_type(file_path)[0] or \"text/plain\",\n        )\n\n    request, response = app.test_client.get(f\"/files/{file_name}\")\n    assert response.status == status\n    assert response.body == get_file_content(static_file_directory, file_name)\n    assert \"Content-Disposition\" not in response.headers",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt', 'python.png'])",
        "pytest.mark.parametrize('status', [200, 401])"
      ],
      "arguments": [
        "app",
        "file_name",
        "static_file_directory",
        "status"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == status",
        "assert response.body == get_file_content(static_file_directory, file_name)",
        "assert 'Content-Disposition' not in response.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ]
    },
    {
      "name": "test_file_response_custom_filename",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 383,
      "end_line_number": 398,
      "source_code": "def test_file_response_custom_filename(\n    app: Sanic, source, dest, static_file_directory\n):\n    @app.route(\"/files/<filename>\", methods=[\"GET\"])\n    def file_route(request, filename):\n        file_path = os.path.join(static_file_directory, filename)\n        file_path = os.path.abspath(unquote(file_path))\n        return file(file_path, filename=dest)\n\n    request, response = app.test_client.get(f\"/files/{source}\")\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, source)\n    assert (\n        response.headers[\"Content-Disposition\"]\n        == f'attachment; filename=\"{dest}\"'\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('source,dest', [('test.file', 'my_file.txt'), ('decode me.txt', 'readme.md'), ('python.png', 'logo.png')])"
      ],
      "arguments": [
        "app",
        "source",
        "dest",
        "static_file_directory"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, source)",
        "assert response.headers['Content-Disposition'] == f'attachment; filename=\"{dest}\"'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ]
    },
    {
      "name": "test_file_head_response",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 402,
      "end_line_number": 429,
      "source_code": "def test_file_head_response(app: Sanic, file_name, static_file_directory):\n    @app.route(\"/files/<filename>\", methods=[\"GET\", \"HEAD\"])\n    async def file_route(request, filename):\n        file_path = os.path.join(static_file_directory, filename)\n        file_path = os.path.abspath(unquote(file_path))\n        stats = await async_os.stat(file_path)\n        headers = {}\n        headers[\"Accept-Ranges\"] = \"bytes\"\n        headers[\"Content-Length\"] = str(stats.st_size)\n        if request.method == \"HEAD\":\n            return HTTPResponse(\n                headers=headers,\n                content_type=guess_type(file_path)[0] or \"text/plain\",\n            )\n        else:\n            return file(\n                file_path,\n                headers=headers,\n                mime_type=guess_type(file_path)[0] or \"text/plain\",\n            )\n\n    request, response = app.test_client.head(f\"/files/{file_name}\")\n    assert response.status == 200\n    assert \"Accept-Ranges\" in response.headers\n    assert \"Content-Length\" in response.headers\n    assert int(response.headers[\"Content-Length\"]) == len(\n        get_file_content(static_file_directory, file_name)\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt'])"
      ],
      "arguments": [
        "app",
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert 'Accept-Ranges' in response.headers",
        "assert 'Content-Length' in response.headers",
        "assert int(response.headers['Content-Length']) == len(get_file_content(static_file_directory, file_name))"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.head",
          "body": "def head(self, request):\n    return text('', headers={'method': 'HEAD'})"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ]
    },
    {
      "name": "test_file_stream_response",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 435,
      "end_line_number": 449,
      "source_code": "def test_file_stream_response(app: Sanic, file_name, static_file_directory):\n    @app.route(\"/files/<filename>\", methods=[\"GET\"])\n    def file_route(request, filename):\n        file_path = os.path.join(static_file_directory, filename)\n        file_path = os.path.abspath(unquote(file_path))\n        return file_stream(\n            file_path,\n            chunk_size=32,\n            mime_type=guess_type(file_path)[0] or \"text/plain\",\n        )\n\n    request, response = app.test_client.get(f\"/files/{file_name}\")\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, file_name)\n    assert \"Content-Disposition\" not in response.headers",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt', 'python.png'])"
      ],
      "arguments": [
        "app",
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, file_name)",
        "assert 'Content-Disposition' not in response.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ]
    },
    {
      "name": "test_file_stream_response_custom_filename",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 460,
      "end_line_number": 475,
      "source_code": "def test_file_stream_response_custom_filename(\n    app: Sanic, source, dest, static_file_directory\n):\n    @app.route(\"/files/<filename>\", methods=[\"GET\"])\n    def file_route(request, filename):\n        file_path = os.path.join(static_file_directory, filename)\n        file_path = os.path.abspath(unquote(file_path))\n        return file_stream(file_path, chunk_size=32, filename=dest)\n\n    request, response = app.test_client.get(f\"/files/{source}\")\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, source)\n    assert (\n        response.headers[\"Content-Disposition\"]\n        == f'attachment; filename=\"{dest}\"'\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('source,dest', [('test.file', 'my_file.txt'), ('decode me.txt', 'readme.md'), ('python.png', 'logo.png')])"
      ],
      "arguments": [
        "app",
        "source",
        "dest",
        "static_file_directory"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, source)",
        "assert response.headers['Content-Disposition'] == f'attachment; filename=\"{dest}\"'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ]
    },
    {
      "name": "test_file_stream_head_response",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 479,
      "end_line_number": 515,
      "source_code": "def test_file_stream_head_response(\n    app: Sanic, file_name, static_file_directory\n):\n    @app.route(\"/files/<filename>\", methods=[\"GET\", \"HEAD\"])\n    async def file_route(request, filename):\n        file_path = os.path.join(static_file_directory, filename)\n        file_path = os.path.abspath(unquote(file_path))\n        headers = {}\n        headers[\"Accept-Ranges\"] = \"bytes\"\n        if request.method == \"HEAD\":\n            # Return a normal HTTPResponse, not a\n            # StreamingHTTPResponse for a HEAD request\n            stats = await async_os.stat(file_path)\n            headers[\"Content-Length\"] = str(stats.st_size)\n            return HTTPResponse(\n                headers=headers,\n                content_type=guess_type(file_path)[0] or \"text/plain\",\n            )\n        else:\n            return file_stream(\n                file_path,\n                chunk_size=32,\n                headers=headers,\n                mime_type=guess_type(file_path)[0] or \"text/plain\",\n            )\n\n    request, response = app.test_client.head(f\"/files/{file_name}\")\n    assert response.status == 200\n    # A HEAD request should never be streamed/chunked.\n    if \"Transfer-Encoding\" in response.headers:\n        assert response.headers[\"Transfer-Encoding\"] != \"chunked\"\n    assert \"Accept-Ranges\" in response.headers\n    # A HEAD request should get the Content-Length too\n    assert \"Content-Length\" in response.headers\n    assert int(response.headers[\"Content-Length\"]) == len(\n        get_file_content(static_file_directory, file_name)\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt'])"
      ],
      "arguments": [
        "app",
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert 'Accept-Ranges' in response.headers",
        "assert 'Content-Length' in response.headers",
        "assert int(response.headers['Content-Length']) == len(get_file_content(static_file_directory, file_name))",
        "assert response.headers['Transfer-Encoding'] != 'chunked'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.head",
          "body": "def head(self, request):\n    return text('', headers={'method': 'HEAD'})"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ]
    },
    {
      "name": "test_file_stream_response_range",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 524,
      "end_line_number": 548,
      "source_code": "def test_file_stream_response_range(\n    app: Sanic, file_name, static_file_directory, size, start, end\n):\n    Range = namedtuple(\"Range\", [\"size\", \"start\", \"end\", \"total\"])\n    total = len(get_file_content(static_file_directory, file_name))\n    range = Range(size=size, start=start, end=end, total=total)\n\n    @app.route(\"/files/<filename>\", methods=[\"GET\"])\n    def file_route(request, filename):\n        file_path = os.path.join(static_file_directory, filename)\n        file_path = os.path.abspath(unquote(file_path))\n        return file_stream(\n            file_path,\n            chunk_size=32,\n            mime_type=guess_type(file_path)[0] or \"text/plain\",\n            _range=range,\n        )\n\n    request, response = app.test_client.get(f\"/files/{file_name}\")\n    assert response.status == 206\n    assert \"Content-Range\" in response.headers\n    assert (\n        response.headers[\"Content-Range\"]\n        == f\"bytes {range.start}-{range.end}/{range.total}\"\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt', 'python.png'])",
        "pytest.mark.parametrize('size,start,end', [(1024, 0, 1024), (4096, 1024, 8192)])"
      ],
      "arguments": [
        "app",
        "file_name",
        "static_file_directory",
        "size",
        "start",
        "end"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 206",
        "assert 'Content-Range' in response.headers",
        "assert response.headers['Content-Range'] == f'bytes {range.start}-{range.end}/{range.total}'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ]
    },
    {
      "name": "test_raw_response",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 551,
      "end_line_number": 558,
      "source_code": "def test_raw_response(app):\n    @app.get(\"/test\")\n    def handler(request: Request):\n        return raw(b\"raw_response\")\n\n    request, response = app.test_client.get(\"/test\")\n    assert response.content_type == DEFAULT_HTTP_CONTENT_TYPE\n    assert response.body == b\"raw_response\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.content_type == DEFAULT_HTTP_CONTENT_TYPE",
        "assert response.body == b'raw_response'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_empty_response",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 561,
      "end_line_number": 568,
      "source_code": "def test_empty_response(app):\n    @app.get(\"/test\")\n    def handler(request: Request):\n        return empty()\n\n    request, response = app.test_client.get(\"/test\")\n    assert response.content_type is None\n    assert response.body == b\"\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.content_type is None",
        "assert response.body == b''"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_direct_response_stream",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 571,
      "end_line_number": 583,
      "source_code": "def test_direct_response_stream(app: Sanic):\n    @app.route(\"/\")\n    async def test(request: Request):\n        response = await request.respond(content_type=\"text/csv\")\n        await response.send(\"foo,\")\n        await response.send(\"bar\")\n        await response.eof()\n\n    _, response = app.test_client.get(\"/\")\n    assert response.text == \"foo,bar\"\n    assert response.headers[\"Transfer-Encoding\"] == \"chunked\"\n    assert response.headers[\"Content-Type\"] == \"text/csv\"\n    assert \"Content-Length\" not in response.headers",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'foo,bar'",
        "assert response.headers['Transfer-Encoding'] == 'chunked'",
        "assert response.headers['Content-Type'] == 'text/csv'",
        "assert 'Content-Length' not in response.headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "response.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        }
      ]
    },
    {
      "name": "test_multiple_responses",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 601,
      "end_line_number": 698,
      "source_code": "def test_multiple_responses(\n    app: Sanic,\n    caplog: LogCaptureFixture,\n    message_in_records: Callable[[List[LogRecord], str], bool],\n):\n    @app.route(\"/1\")\n    async def handler1(request: Request):\n        response = await request.respond()\n        await response.send(\"foo\")\n        response = await request.respond()\n\n    @app.route(\"/2\")\n    async def handler2(request: Request):\n        response = await request.respond()\n        response = await request.respond()\n        await response.send(\"foo\")\n\n    @app.get(\"/3\")\n    async def handler3(request: Request):\n        response = await request.respond()\n        await response.send(\"foo,\")\n        response = await request.respond()\n        await response.send(\"bar\")\n\n    @app.get(\"/4\")\n    async def handler4(request: Request):\n        await request.respond(headers={\"one\": \"one\"})\n        return json({\"foo\": \"bar\"}, headers={\"one\": \"two\"})\n\n    @app.get(\"/5\")\n    async def handler5(request: Request):\n        response = await request.respond(headers={\"one\": \"one\"})\n        await response.send(\"foo\")\n        return json({\"foo\": \"bar\"}, headers={\"one\": \"two\"})\n\n    @app.get(\"/6\")\n    async def handler6(request: Request):\n        response = await request.respond(headers={\"one\": \"one\"})\n        await response.send(\"foo, \")\n        json_response = json({\"foo\": \"bar\"}, headers={\"one\": \"two\"})\n        await response.send(\"bar\")\n        return json_response\n\n    error_msg0 = \"Second respond call is not allowed.\"\n\n    error_msg1 = (\n        \"The error response will not be sent to the client for the following \"\n        'exception:\"Second respond call is not allowed.\". A previous '\n        \"response has at least partially been sent.\"\n    )\n\n    error_msg2 = (\n        \"The response object returned by the route handler \"\n        \"will not be sent to client. The request has already \"\n        \"been responded to.\"\n    )\n\n    with caplog.at_level(ERROR):\n        _, response = app.test_client.get(\"/1\")\n        assert response.status == 200\n        assert message_in_records(caplog.records, error_msg0)\n        assert message_in_records(caplog.records, error_msg1)\n\n    with caplog.at_level(ERROR):\n        _, response = app.test_client.get(\"/2\")\n        assert response.status == 500\n        assert \"500 \u2014 Internal Server Error\" in response.text\n\n    with caplog.at_level(ERROR):\n        _, response = app.test_client.get(\"/3\")\n        assert response.status == 200\n        assert \"foo,\" in response.text\n        assert message_in_records(caplog.records, error_msg0)\n        assert message_in_records(caplog.records, error_msg1)\n\n    with caplog.at_level(ERROR):\n        _, response = app.test_client.get(\"/4\")\n        assert response.status == 200\n        assert \"foo\" not in response.text\n        assert \"one\" in response.headers\n        assert response.headers[\"one\"] == \"one\"\n\n        assert message_in_records(caplog.records, error_msg2)\n\n    with caplog.at_level(ERROR):\n        _, response = app.test_client.get(\"/5\")\n        assert response.status == 200\n        assert \"foo\" in response.text\n        assert \"one\" in response.headers\n        assert response.headers[\"one\"] == \"one\"\n        assert message_in_records(caplog.records, error_msg2)\n\n    with caplog.at_level(ERROR):\n        _, response = app.test_client.get(\"/6\")\n        assert \"foo, bar\" in response.text\n        assert \"one\" in response.headers\n        assert response.headers[\"one\"] == \"one\"\n        assert message_in_records(caplog.records, error_msg2)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "caplog",
        "message_in_records"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert message_in_records(caplog.records, error_msg0)",
        "assert message_in_records(caplog.records, error_msg1)",
        "assert response.status == 500",
        "assert '500 \u2014 Internal Server Error' in response.text",
        "assert response.status == 200",
        "assert 'foo,' in response.text",
        "assert message_in_records(caplog.records, error_msg0)",
        "assert message_in_records(caplog.records, error_msg1)",
        "assert response.status == 200",
        "assert 'foo' not in response.text",
        "assert 'one' in response.headers",
        "assert response.headers['one'] == 'one'",
        "assert message_in_records(caplog.records, error_msg2)",
        "assert response.status == 200",
        "assert 'foo' in response.text",
        "assert 'one' in response.headers",
        "assert response.headers['one'] == 'one'",
        "assert message_in_records(caplog.records, error_msg2)",
        "assert 'foo, bar' in response.text",
        "assert 'one' in response.headers",
        "assert response.headers['one'] == 'one'",
        "assert message_in_records(caplog.records, error_msg2)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "message_in_records",
          "body": "@pytest.fixture(scope='function')\ndef message_in_records():\n\n    def msg_in_log(records: List[LogRecord], msg: str):\n        error_captured = False\n        for record in records:\n            if msg in record.message:\n                error_captured = True\n                break\n        return error_captured\n    return msg_in_log"
        },
        {
          "name": "message_in_records",
          "body": "@pytest.fixture(scope='function')\ndef message_in_records():\n\n    def msg_in_log(records: List[LogRecord], msg: str):\n        error_captured = False\n        for record in records:\n            if msg in record.message:\n                error_captured = True\n                break\n        return error_captured\n    return msg_in_log"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "message_in_records",
          "body": "@pytest.fixture(scope='function')\ndef message_in_records():\n\n    def msg_in_log(records: List[LogRecord], msg: str):\n        error_captured = False\n        for record in records:\n            if msg in record.message:\n                error_captured = True\n                break\n        return error_captured\n    return msg_in_log"
        },
        {
          "name": "message_in_records",
          "body": "@pytest.fixture(scope='function')\ndef message_in_records():\n\n    def msg_in_log(records: List[LogRecord], msg: str):\n        error_captured = False\n        for record in records:\n            if msg in record.message:\n                error_captured = True\n                break\n        return error_captured\n    return msg_in_log"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "message_in_records",
          "body": "@pytest.fixture(scope='function')\ndef message_in_records():\n\n    def msg_in_log(records: List[LogRecord], msg: str):\n        error_captured = False\n        for record in records:\n            if msg in record.message:\n                error_captured = True\n                break\n        return error_captured\n    return msg_in_log"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "message_in_records",
          "body": "@pytest.fixture(scope='function')\ndef message_in_records():\n\n    def msg_in_log(records: List[LogRecord], msg: str):\n        error_captured = False\n        for record in records:\n            if msg in record.message:\n                error_captured = True\n                break\n        return error_captured\n    return msg_in_log"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "message_in_records",
          "body": "@pytest.fixture(scope='function')\ndef message_in_records():\n\n    def msg_in_log(records: List[LogRecord], msg: str):\n        error_captured = False\n        for record in records:\n            if msg in record.message:\n                error_captured = True\n                break\n        return error_captured\n    return msg_in_log"
        },
        {
          "name": "response.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "response.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "response.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "response.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "response.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "response.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "response.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        }
      ]
    },
    {
      "name": "test_send_response_after_eof_should_fail",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 701,
      "end_line_number": 729,
      "source_code": "def test_send_response_after_eof_should_fail(\n    app: Sanic,\n    caplog: LogCaptureFixture,\n    message_in_records: Callable[[List[LogRecord], str], bool],\n):\n    @app.get(\"/\")\n    async def handler(request: Request):\n        response = await request.respond()\n        await response.send(\"foo, \")\n        await response.eof()\n        await response.send(\"bar\")\n\n    error_msg1 = (\n        \"The error response will not be sent to the client for the following \"\n        'exception:\"Response stream was ended, no more response '\n        'data is allowed to be sent.\". A previous '\n        \"response has at least partially been sent.\"\n    )\n\n    error_msg2 = (\n        \"Response stream was ended, no more response \"\n        \"data is allowed to be sent.\"\n    )\n\n    with caplog.at_level(ERROR):\n        _, response = app.test_client.get(\"/\")\n        assert \"foo, \" in response.text\n        assert message_in_records(caplog.records, error_msg1)\n        assert message_in_records(caplog.records, error_msg2)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "caplog",
        "message_in_records"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'foo, ' in response.text",
        "assert message_in_records(caplog.records, error_msg1)",
        "assert message_in_records(caplog.records, error_msg2)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "message_in_records",
          "body": "@pytest.fixture(scope='function')\ndef message_in_records():\n\n    def msg_in_log(records: List[LogRecord], msg: str):\n        error_captured = False\n        for record in records:\n            if msg in record.message:\n                error_captured = True\n                break\n        return error_captured\n    return msg_in_log"
        },
        {
          "name": "message_in_records",
          "body": "@pytest.fixture(scope='function')\ndef message_in_records():\n\n    def msg_in_log(records: List[LogRecord], msg: str):\n        error_captured = False\n        for record in records:\n            if msg in record.message:\n                error_captured = True\n                break\n        return error_captured\n    return msg_in_log"
        },
        {
          "name": "response.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "response.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        }
      ]
    },
    {
      "name": "test_file_response_headers",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 768,
      "end_line_number": 856,
      "source_code": "def test_file_response_headers(\n    app: Sanic, file_name: str, static_file_directory: str\n):\n    test_last_modified = datetime.now()\n    test_max_age = 10\n    test_expires = test_last_modified.timestamp() + test_max_age\n\n    @app.route(\"/files/cached/<filename>\", methods=[\"GET\"])\n    def file_route_cache(request: Request, filename: str):\n        file_path = (\n            Path(static_file_directory) / unquote(filename)\n        ).absolute()\n        return file(\n            file_path, max_age=test_max_age, last_modified=test_last_modified\n        )\n\n    @app.route(\n        \"/files/cached_default_last_modified/<filename>\", methods=[\"GET\"]\n    )\n    def file_route_cache_default_last_modified(\n        request: Request, filename: str\n    ):\n        file_path = (\n            Path(static_file_directory) / unquote(filename)\n        ).absolute()\n        return file(file_path, max_age=test_max_age)\n\n    @app.route(\"/files/no_cache/<filename>\", methods=[\"GET\"])\n    def file_route_no_cache(request: Request, filename: str):\n        file_path = (\n            Path(static_file_directory) / unquote(filename)\n        ).absolute()\n        return file(file_path)\n\n    @app.route(\"/files/no_store/<filename>\", methods=[\"GET\"])\n    def file_route_no_store(request: Request, filename: str):\n        file_path = (\n            Path(static_file_directory) / unquote(filename)\n        ).absolute()\n        return file(file_path, no_store=True)\n\n    _, response = app.test_client.get(f\"/files/cached/{file_name}\")\n    assert response.body == get_file_content(static_file_directory, file_name)\n    headers = response.headers\n    assert (\n        \"cache-control\" in headers\n        and f\"max-age={test_max_age}\" in headers.get(\"cache-control\")\n        and \"public\" in headers.get(\"cache-control\")\n    )\n    assert (\n        \"expires\" in headers\n        and headers.get(\"expires\")[:-6]\n        == formatdate(test_expires, usegmt=True)[:-6]\n        # [:-6] to allow at most 1 min difference\n        # It's minimal for cases like:\n        # Thu, 26 May 2022 05:36:59 GMT\n        # AND\n        # Thu, 26 May 2022 05:37:00 GMT\n    )\n    assert response.status == 200\n    assert \"last-modified\" in headers and headers.get(\n        \"last-modified\"\n    ) == formatdate(test_last_modified.timestamp(), usegmt=True)\n\n    _, response = app.test_client.get(\n        f\"/files/cached_default_last_modified/{file_name}\"\n    )\n    file_last_modified = get_file_last_modified_timestamp(\n        static_file_directory, file_name\n    )\n    headers = response.headers\n    assert \"last-modified\" in headers and headers.get(\n        \"last-modified\"\n    ) == formatdate(file_last_modified, usegmt=True)\n    assert response.status == 200\n\n    _, response = app.test_client.get(f\"/files/no_cache/{file_name}\")\n    headers = response.headers\n    assert \"cache-control\" in headers and \"no-cache\" == headers.get(\n        \"cache-control\"\n    )\n    assert response.status == 200\n\n    _, response = app.test_client.get(f\"/files/no_store/{file_name}\")\n    headers = response.headers\n    assert \"cache-control\" in headers and \"no-store\" == headers.get(\n        \"cache-control\"\n    )\n    assert response.status == 200",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt', 'python.png'])"
      ],
      "arguments": [
        "app",
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.body == get_file_content(static_file_directory, file_name)",
        "assert 'cache-control' in headers and f'max-age={test_max_age}' in headers.get('cache-control') and ('public' in headers.get('cache-control'))",
        "assert 'expires' in headers and headers.get('expires')[:-6] == formatdate(test_expires, usegmt=True)[:-6]",
        "assert response.status == 200",
        "assert 'last-modified' in headers and headers.get('last-modified') == formatdate(test_last_modified.timestamp(), usegmt=True)",
        "assert 'last-modified' in headers and headers.get('last-modified') == formatdate(file_last_modified, usegmt=True)",
        "assert response.status == 200",
        "assert 'cache-control' in headers and 'no-cache' == headers.get('cache-control')",
        "assert response.status == 200",
        "assert 'cache-control' in headers and 'no-store' == headers.get('cache-control')",
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_last_modified_timestamp",
          "body": "def get_file_last_modified_timestamp(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    return (static_file_directory / file_name).stat().st_mtime"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        },
        {
          "name": "headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_file_validate",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 859,
      "end_line_number": 900,
      "source_code": "def test_file_validate(app: Sanic, static_file_directory: str):\n    file_name = \"test_validate.txt\"\n    static_file_directory = Path(static_file_directory)\n    file_path = static_file_directory / file_name\n    file_path = file_path.absolute()\n    test_max_age = 10\n\n    with open(file_path, \"w+\") as f:\n        f.write(\"foo\\n\")\n\n    @app.route(\"/validate\", methods=[\"GET\"])\n    def file_route_cache(request: Request):\n        return file(\n            file_path,\n            request_headers=request.headers,\n            max_age=test_max_age,\n            validate_when_requested=True,\n        )\n\n    _, response = app.test_client.get(\"/validate\")\n    assert response.status == 200\n    assert response.body == b\"foo\\n\"\n    last_modified = response.headers[\"Last-Modified\"]\n\n    time.sleep(1)\n    with open(file_path, \"a\") as f:\n        f.write(\"bar\\n\")\n    _, response = app.test_client.get(\n        \"/validate\", headers={\"If-Modified-Since\": last_modified}\n    )\n\n    assert response.status == 200\n    assert response.body == b\"foo\\nbar\\n\"\n\n    last_modified = response.headers[\"Last-Modified\"]\n    _, response = app.test_client.get(\n        \"/validate\", headers={\"if-modified-since\": last_modified}\n    )\n    assert response.status == 304\n    assert response.body == b\"\"\n\n    file_path.unlink()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "static_file_directory"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == b'foo\\n'",
        "assert response.status == 200",
        "assert response.body == b'foo\\nbar\\n'",
        "assert response.status == 304",
        "assert response.body == b''"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_file_validating_invalid_header",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 906,
      "end_line_number": 935,
      "source_code": "def test_file_validating_invalid_header(\n    app: Sanic, file_name: str, static_file_directory: str\n):\n    @app.route(\"/files/<filename>\", methods=[\"GET\"])\n    def file_route(request: Request, filename: str):\n        handler_file_path = (\n            Path(static_file_directory) / unquote(filename)\n        ).absolute()\n\n        return file(\n            handler_file_path,\n            request_headers=request.headers,\n            validate_when_requested=True,\n        )\n\n    _, response = app.test_client.get(f\"/files/{file_name}\")\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, file_name)\n\n    _, response = app.test_client.get(\n        f\"/files/{file_name}\", headers={\"if-modified-since\": \"invalid-value\"}\n    )\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, file_name)\n\n    _, response = app.test_client.get(\n        f\"/files/{file_name}\", headers={\"if-modified-since\": \"\"}\n    )\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, file_name)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt', 'python.png'])"
      ],
      "arguments": [
        "app",
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, file_name)",
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, file_name)",
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, file_name)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ]
    },
    {
      "name": "test_file_validating_304_response_file_route",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 941,
      "end_line_number": 965,
      "source_code": "def test_file_validating_304_response_file_route(\n    app: Sanic, file_name: str, static_file_directory: str\n):\n    @app.route(\"/files/<filename>\", methods=[\"GET\"])\n    def file_route(request: Request, filename: str):\n        handler_file_path = (\n            Path(static_file_directory) / unquote(filename)\n        ).absolute()\n\n        return file(\n            handler_file_path,\n            request_headers=request.headers,\n            validate_when_requested=True,\n        )\n\n    _, response = app.test_client.get(f\"/files/{file_name}\")\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, file_name)\n\n    _, response = app.test_client.get(\n        f\"/files/{file_name}\",\n        headers={\"if-modified-since\": response.headers[\"Last-Modified\"]},\n    )\n    assert response.status == 304\n    assert response.body == b\"\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt', 'python.png'])"
      ],
      "arguments": [
        "app",
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, file_name)",
        "assert response.status == 304",
        "assert response.body == b''"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ]
    },
    {
      "name": "test_file_validating_304_response",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 971,
      "end_line_number": 990,
      "source_code": "def test_file_validating_304_response(\n    app: Sanic, file_name: str, static_file_directory: str\n):\n    app.static(\"static\", Path(static_file_directory) / file_name)\n\n    _, response = app.test_client.get(\"/static\")\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, file_name)\n    last_modified = parsedate_to_datetime(response.headers[\"Last-Modified\"])\n    last_modified += timedelta(seconds=1)\n    _, response = app.test_client.get(\n        \"/static\",\n        headers={\n            \"if-modified-since\": formatdate(\n                last_modified.timestamp(), usegmt=True\n            )\n        },\n    )\n    assert response.status == 304\n    assert response.body == b\"\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt', 'python.png'])"
      ],
      "arguments": [
        "app",
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, file_name)",
        "assert response.status == 304",
        "assert response.body == b''"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ]
    },
    {
      "name": "test_stream_response_with_default_headers",
      "module": "test_response",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response.py",
      "line_number": 993,
      "end_line_number": 1004,
      "source_code": "def test_stream_response_with_default_headers(app: Sanic):\n    async def sample_streaming_fn(response_):\n        await response_.write(\"foo\")\n\n    @app.route(\"/\")\n    async def test(request: Request):\n        return ResponseStream(sample_streaming_fn, content_type=\"text/csv\")\n\n    _, response = app.test_client.get(\"/\")\n    assert response.text == \"foo\"\n    assert response.headers[\"Transfer-Encoding\"] == \"chunked\"\n    assert response.headers[\"Content-Type\"] == \"text/csv\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "time",
        "collections.namedtuple",
        "datetime.datetime",
        "datetime.timedelta",
        "email.utils.formatdate",
        "email.utils.parsedate_to_datetime",
        "logging.ERROR",
        "logging.LogRecord",
        "mimetypes.guess_type",
        "pathlib.Path",
        "random.choice",
        "typing.Callable",
        "typing.List",
        "typing.Union",
        "urllib.parse.unquote",
        "pytest",
        "aiofiles.os",
        "pytest.LogCaptureFixture",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.cookies.CookieJar",
        "sanic.response.HTTPResponse",
        "sanic.response.ResponseStream",
        "sanic.response.empty",
        "sanic.response.file",
        "sanic.response.file_stream",
        "sanic.response.json",
        "sanic.response.raw",
        "sanic.response.text",
        "sanic.response.json_dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'foo'",
        "assert response.headers['Transfer-Encoding'] == 'chunked'",
        "assert response.headers['Content-Type'] == 'text/csv'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_sync",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 34,
      "end_line_number": 41,
      "source_code": "def test_sync(app):\n    @app.route(\"/\")\n    def handler(request):\n        return text(\"Hello\")\n\n    request, response = app.test_client.get(\"/\")\n\n    assert response.body == b\"Hello\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.body == b'Hello'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_ip",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 55,
      "end_line_number": 62,
      "source_code": "def test_ip(app):\n    @app.route(\"/\")\n    def handler(request):\n        return text(f\"{request.ip}\")\n\n    request, response = app.test_client.get(\"/\")\n\n    assert response.body == b\"127.0.0.1\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.body == b'127.0.0.1'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_text",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 81,
      "end_line_number": 88,
      "source_code": "def test_text(app):\n    @app.route(\"/\")\n    async def handler(request):\n        return text(\"Hello\")\n\n    request, response = app.test_client.get(\"/\")\n\n    assert response.body == b\"Hello\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.body == b'Hello'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_html",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 91,
      "end_line_number": 123,
      "source_code": "def test_html(app):\n    class Foo:\n        def __html__(self):\n            return \"<h1>Foo</h1>\"\n\n        def _repr_html_(self):\n            return \"<h1>Foo object repr</h1>\"\n\n    class Bar:\n        def _repr_html_(self):\n            return \"<h1>Bar object repr</h1>\"\n\n    @app.route(\"/\")\n    async def handler(request):\n        return html(\"<h1>Hello</h1>\")\n\n    @app.route(\"/foo\")\n    async def handler_foo(request):\n        return html(Foo())\n\n    @app.route(\"/bar\")\n    async def handler_bar(request):\n        return html(Bar())\n\n    request, response = app.test_client.get(\"/\")\n    assert response.content_type == \"text/html; charset=utf-8\"\n    assert response.body == b\"<h1>Hello</h1>\"\n\n    request, response = app.test_client.get(\"/foo\")\n    assert response.body == b\"<h1>Foo</h1>\"\n\n    request, response = app.test_client.get(\"/bar\")\n    assert response.body == b\"<h1>Bar object repr</h1>\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.content_type == 'text/html; charset=utf-8'",
        "assert response.body == b'<h1>Hello</h1>'",
        "assert response.body == b'<h1>Foo</h1>'",
        "assert response.body == b'<h1>Bar object repr</h1>'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_headers",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 137,
      "end_line_number": 145,
      "source_code": "def test_headers(app):\n    @app.route(\"/\")\n    async def handler(request):\n        headers = {\"spam\": \"great\"}\n        return text(\"Hello\", headers=headers)\n\n    request, response = app.test_client.get(\"/\")\n\n    assert response.headers.get(\"spam\") == \"great\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.headers.get('spam') == 'great'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response.headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_non_str_headers",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 160,
      "end_line_number": 168,
      "source_code": "def test_non_str_headers(app):\n    @app.route(\"/\")\n    async def handler(request):\n        headers = {\"answer\": 42}\n        return text(\"Hello\", headers=headers)\n\n    request, response = app.test_client.get(\"/\")\n\n    assert response.headers.get(\"answer\") == \"42\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.headers.get('answer') == '42'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response.headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_invalid_response",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 183,
      "end_line_number": 194,
      "source_code": "def test_invalid_response(app):\n    @app.exception(ServerError)\n    def handler_exception(request, exception):\n        return text(\"Internal Server Error.\", 500)\n\n    @app.route(\"/\")\n    async def handler(request):\n        return \"This should fail\"\n\n    request, response = app.test_client.get(\"/\")\n    assert response.status == 500\n    assert response.body == b\"Internal Server Error.\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert response.body == b'Internal Server Error.'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.exception",
          "body": "@app.route('/')\ndef exception(request):\n    raise SanicExceptionTestException(\"You won't see me\")"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_json",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 212,
      "end_line_number": 221,
      "source_code": "def test_json(app):\n    @app.route(\"/\")\n    async def handler(request):\n        return json({\"test\": True})\n\n    request, response = app.test_client.get(\"/\")\n\n    results = json_loads(response.text)\n\n    assert results.get(\"test\") is True",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert results.get('test') is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "results.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_empty_json",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 237,
      "end_line_number": 245,
      "source_code": "def test_empty_json(app):\n    @app.route(\"/\")\n    async def handler(request):\n        assert request.json is None\n        return json(request.json)\n\n    request, response = app.test_client.get(\"/\")\n    assert response.status == 200\n    assert response.body == b\"null\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == b'null'",
        "assert request.json is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_echo_json",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 260,
      "end_line_number": 269,
      "source_code": "def test_echo_json(app):\n    @app.post(\"/\")\n    async def handler(request):\n        return json(request.json)\n\n    data = {\"foo\": \"bar\"}\n    request, response = app.test_client.post(\"/\", json=data)\n\n    assert response.status == 200\n    assert response.json == data",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.json == data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_invalid_json",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 285,
      "end_line_number": 293,
      "source_code": "def test_invalid_json(app):\n    @app.post(\"/\")\n    async def handler(request):\n        return json(request.json)\n\n    data = \"I am not json\"\n    request, response = app.test_client.post(\"/\", data=data)\n\n    assert response.status == 400",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 400"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_query_string",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 308,
      "end_line_number": 321,
      "source_code": "def test_query_string(app):\n    @app.route(\"/\")\n    async def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\n        \"/\", params=[(\"test1\", \"1\"), (\"test2\", \"false\"), (\"test2\", \"true\")]\n    )\n\n    assert request.args.get(\"test1\") == \"1\"\n    assert request.args.get(\"test2\") == \"false\"\n    assert request.args.getlist(\"test2\") == [\"false\", \"true\"]\n    assert request.args.getlist(\"test1\") == [\"1\"]\n    assert request.args.get(\"test3\", default=\"My value\") == \"My value\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.args.get('test1') == '1'",
        "assert request.args.get('test2') == 'false'",
        "assert request.args.getlist('test2') == ['false', 'true']",
        "assert request.args.getlist('test1') == ['1']",
        "assert request.args.get('test3', default='My value') == 'My value'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "request.args.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "request.args.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "request.args.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_popped_stays_popped",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 324,
      "end_line_number": 332,
      "source_code": "def test_popped_stays_popped(app):\n    @app.route(\"/\")\n    async def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/\", params=[(\"test1\", \"1\")])\n\n    assert request.args.pop(\"test1\") == [\"1\"]\n    assert \"test1\" not in request.args",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.args.pop('test1') == ['1']",
        "assert 'test1' not in request.args"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_uri_template",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 352,
      "end_line_number": 358,
      "source_code": "def test_uri_template(app):\n    @app.route(\"/foo/<id:int>/bar/<name:[A-z]+>\")\n    async def handler(request, id, name):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/foo/123/bar/baz\")\n    assert request.uri_template == \"/foo/<id:int>/bar/<name:[A-z]+>\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.uri_template == '/foo/<id:int>/bar/<name:[A-z]+>'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_token",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 384,
      "end_line_number": 400,
      "source_code": "def test_token(app, auth_type, token):\n    @app.route(\"/\")\n    async def handler(request):\n        return text(\"OK\")\n\n    if token:\n        headers = {\n            \"content-type\": \"application/json\",\n            \"Authorization\": f\"{auth_type} {token}\"\n            if auth_type\n            else f\"{token}\",\n        }\n    else:\n        headers = {\"content-type\": \"application/json\"}\n\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert request.token == token",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize(('auth_type', 'token'), [(None, 'a1d895e0-553a-421a-8e22-5ff8ecb48cbf'), ('Token', 'a1d895e0-553a-421a-8e22-5ff8ecb48cbf'), ('Bearer', 'a1d895e0-553a-421a-8e22-5ff8ecb48cbf'), (None, None)])"
      ],
      "arguments": [
        "app",
        "auth_type",
        "token"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.token == token"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_credentials",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 423,
      "end_line_number": 459,
      "source_code": "def test_credentials(app, capfd, auth_type, token, username, password):\n    @app.route(\"/\")\n    async def handler(request):\n        return text(\"OK\")\n\n    if token:\n        headers = {\n            \"content-type\": \"application/json\",\n            \"Authorization\": f\"{auth_type} {token}\"\n            if auth_type\n            else f\"{token}\",\n        }\n    else:\n        headers = {\"content-type\": \"application/json\"}\n\n    request, response = app.test_client.get(\"/\", headers=headers)\n\n    if auth_type == \"Basic\":\n        assert request.credentials.username == username\n        assert request.credentials.password == password\n    else:\n        _, err = capfd.readouterr()\n        with pytest.raises(AttributeError):\n            request.credentials.password\n            assert \"Password is available for Basic Auth only\" in err\n            request.credentials.username\n            assert \"Username is available for Basic Auth only\" in err\n\n    if token:\n        assert request.credentials.token == token\n        assert request.credentials.auth_type == auth_type\n    else:\n        assert request.credentials is None\n        assert not hasattr(request.credentials, \"token\")\n        assert not hasattr(request.credentials, \"auth_type\")\n        assert not hasattr(request.credentials, \"_username\")\n        assert not hasattr(request.credentials, \"_password\")",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize(('auth_type', 'token', 'username', 'password'), [(None, 'a1d895e0-553a-421a-8e22-5ff8ecb48cbf', None, None), ('Token', 'a1d895e0-553a-421a-8e22-5ff8ecb48cbf', None, None), ('Bearer', 'a1d895e0-553a-421a-8e22-5ff8ecb48cbf', None, None), ('Basic', encode_basic_auth_credentials('some_username', 'some_pass'), 'some_username', 'some_pass'), (None, None, None, None)])"
      ],
      "arguments": [
        "app",
        "capfd",
        "auth_type",
        "token",
        "username",
        "password"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.credentials.username == username",
        "assert request.credentials.password == password",
        "assert request.credentials.token == token",
        "assert request.credentials.auth_type == auth_type",
        "assert request.credentials is None",
        "assert not hasattr(request.credentials, 'token')",
        "assert not hasattr(request.credentials, 'auth_type')",
        "assert not hasattr(request.credentials, '_username')",
        "assert not hasattr(request.credentials, '_password')",
        "assert 'Password is available for Basic Auth only' in err",
        "assert 'Username is available for Basic Auth only' in err"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "encode_basic_auth_credentials",
          "body": "def encode_basic_auth_credentials(username, password):\n    return base64.b64encode(f'{username}:{password}'.encode()).decode('ascii')"
        }
      ]
    },
    {
      "name": "test_content_type",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 462,
      "end_line_number": 474,
      "source_code": "def test_content_type(app):\n    @app.route(\"/\")\n    async def handler(request):\n        return text(request.content_type)\n\n    request, response = app.test_client.get(\"/\")\n    assert request.content_type == DEFAULT_HTTP_CONTENT_TYPE\n    assert response.body.decode() == DEFAULT_HTTP_CONTENT_TYPE\n\n    headers = {\"content-type\": \"application/json\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert request.content_type == \"application/json\"\n    assert response.body == b\"application/json\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.content_type == DEFAULT_HTTP_CONTENT_TYPE",
        "assert response.body.decode() == DEFAULT_HTTP_CONTENT_TYPE",
        "assert request.content_type == 'application/json'",
        "assert response.body == b'application/json'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_standard_forwarded",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 493,
      "end_line_number": 605,
      "source_code": "def test_standard_forwarded(app):\n    @app.route(\"/\")\n    async def handler(request):\n        return json(request.forwarded)\n\n    # Without configured FORWARDED_SECRET, x-headers should be respected\n    app.config.PROXIES_COUNT = 1\n    app.config.REAL_IP_HEADER = \"x-real-ip\"\n    headers = {\n        \"Forwarded\": (\n            'for=1.1.1.1, for=injected;host=\"'\n            ', for=\"[::2]\";proto=https;host=me.tld;'\n            'path=\"/app/\";secret=mySecret'\n            \",for=broken;;secret=b0rked\"\n            \", for=127.0.0.3;scheme=http;port=1234\"\n        ),\n        \"X-Real-IP\": \"127.0.0.2\",\n        \"X-Forwarded-For\": \"127.0.1.1\",\n        \"X-Scheme\": \"ws\",\n        \"Host\": \"local.site\",\n    }\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert response.json == {\"for\": \"127.0.0.2\", \"proto\": \"ws\"}\n    assert request.remote_addr == \"127.0.0.2\"\n    assert request.client_ip == \"127.0.0.2\"\n    assert request.scheme == \"ws\"\n    assert request.server_name == \"local.site\"\n    assert request.server_port == 80\n\n    app.config.FORWARDED_SECRET = \"mySecret\"\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert response.json == {\n        \"for\": \"[::2]\",\n        \"proto\": \"https\",\n        \"host\": \"me.tld\",\n        \"path\": \"/app/\",\n        \"secret\": \"mySecret\",\n    }\n    assert request.remote_addr == \"[::2]\"\n    assert request.server_name == \"me.tld\"\n    assert request.scheme == \"https\"\n    assert request.server_port == 443\n\n    # Empty Forwarded header -> use X-headers\n    headers[\"Forwarded\"] = \"\"\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert response.json == {\"for\": \"127.0.0.2\", \"proto\": \"ws\"}\n\n    # Header present but not matching anything\n    request, response = app.test_client.get(\"/\", headers={\"Forwarded\": \".\"})\n    assert response.json == {}\n\n    # Forwarded header present but no matching secret -> use X-headers\n    headers = {\n        \"Forwarded\": \"for=1.1.1.1;secret=x, for=127.0.0.1\",\n        \"X-Real-IP\": \"127.0.0.2\",\n    }\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert response.json == {\"for\": \"127.0.0.2\"}\n    assert request.remote_addr == \"127.0.0.2\"\n\n    # Different formatting and hitting both ends of the header\n    headers = {\"Forwarded\": 'Secret=\"mySecret\";For=127.0.0.4;Port=1234'}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert response.json == {\n        \"for\": \"127.0.0.4\",\n        \"port\": 1234,\n        \"secret\": \"mySecret\",\n    }\n\n    # Test escapes (modify this if you see anyone implementing quoted-pairs)\n    headers = {\"Forwarded\": 'for=test;quoted=\"\\\\,x=x;y=\\\\\";secret=mySecret'}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert response.json == {\n        \"for\": \"test\",\n        \"quoted\": \"\\\\,x=x;y=\\\\\",\n        \"secret\": \"mySecret\",\n    }\n\n    # Secret insulated by malformed field #1\n    headers = {\"Forwarded\": \"for=test;secret=mySecret;b0rked;proto=wss;\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert response.json == {\"for\": \"test\", \"secret\": \"mySecret\"}\n\n    # Secret insulated by malformed field #2\n    headers = {\"Forwarded\": \"for=test;b0rked;secret=mySecret;proto=wss\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert response.json == {\"proto\": \"wss\", \"secret\": \"mySecret\"}\n\n    # Unexpected termination should not lose existing acceptable values\n    headers = {\"Forwarded\": \"b0rked;secret=mySecret;proto=wss\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert response.json == {\"proto\": \"wss\", \"secret\": \"mySecret\"}\n\n    # Field normalization\n    headers = {\n        \"Forwarded\": 'PROTO=WSS;BY=\"CAFE::8000\";FOR=unknown;PORT=X;HOST=\"A:2\";'\n        'PATH=\"/With%20Spaces%22Quoted%22/sanicApp?key=val\";SECRET=mySecret'\n    }\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert response.json == {\n        \"proto\": \"wss\",\n        \"by\": \"[cafe::8000]\",\n        \"host\": \"a:2\",\n        \"path\": '/With Spaces\"Quoted\"/sanicApp?key=val',\n        \"secret\": \"mySecret\",\n    }\n\n    # Using \"by\" field as secret\n    app.config.FORWARDED_SECRET = \"_proxySecret\"\n    headers = {\"Forwarded\": \"for=1.2.3.4; by=_proxySecret\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert response.json == {\"for\": \"1.2.3.4\", \"by\": \"_proxySecret\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json == {'for': '127.0.0.2', 'proto': 'ws'}",
        "assert request.remote_addr == '127.0.0.2'",
        "assert request.client_ip == '127.0.0.2'",
        "assert request.scheme == 'ws'",
        "assert request.server_name == 'local.site'",
        "assert request.server_port == 80",
        "assert response.json == {'for': '[::2]', 'proto': 'https', 'host': 'me.tld', 'path': '/app/', 'secret': 'mySecret'}",
        "assert request.remote_addr == '[::2]'",
        "assert request.server_name == 'me.tld'",
        "assert request.scheme == 'https'",
        "assert request.server_port == 443",
        "assert response.json == {'for': '127.0.0.2', 'proto': 'ws'}",
        "assert response.json == {}",
        "assert response.json == {'for': '127.0.0.2'}",
        "assert request.remote_addr == '127.0.0.2'",
        "assert response.json == {'for': '127.0.0.4', 'port': 1234, 'secret': 'mySecret'}",
        "assert response.json == {'for': 'test', 'quoted': '\\\\,x=x;y=\\\\', 'secret': 'mySecret'}",
        "assert response.json == {'for': 'test', 'secret': 'mySecret'}",
        "assert response.json == {'proto': 'wss', 'secret': 'mySecret'}",
        "assert response.json == {'proto': 'wss', 'secret': 'mySecret'}",
        "assert response.json == {'proto': 'wss', 'by': '[cafe::8000]', 'host': 'a:2', 'path': '/With Spaces\"Quoted\"/sanicApp?key=val', 'secret': 'mySecret'}",
        "assert response.json == {'for': '1.2.3.4', 'by': '_proxySecret'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_remote_addr_with_two_proxies",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 727,
      "end_line_number": 765,
      "source_code": "def test_remote_addr_with_two_proxies(app):\n    app.config.PROXIES_COUNT = 2\n    app.config.REAL_IP_HEADER = \"x-real-ip\"\n\n    @app.route(\"/\")\n    async def handler(request):\n        return text(request.remote_addr)\n\n    headers = {\"X-Real-IP\": \"127.0.0.2\", \"X-Forwarded-For\": \"127.0.1.1\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert request.remote_addr == \"127.0.0.2\"\n    assert response.body == b\"127.0.0.2\"\n\n    headers = {\"X-Forwarded-For\": \"127.0.1.1\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert request.remote_addr == \"\"\n    assert request.client_ip == \"127.0.0.1\"\n    assert response.body == b\"\"\n\n    headers = {\"X-Forwarded-For\": \"127.0.0.1, 127.0.1.2\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert request.remote_addr == \"127.0.0.1\"\n    assert response.body == b\"127.0.0.1\"\n\n    request, response = app.test_client.get(\"/\")\n    assert request.remote_addr == \"\"\n    assert response.body == b\"\"\n\n    headers = {\"X-Forwarded-For\": \"127.0.0.1, ,   ,,127.0.1.2\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert request.remote_addr == \"127.0.0.1\"\n    assert response.body == b\"127.0.0.1\"\n\n    headers = {\n        \"X-Forwarded-For\": \", 127.0.2.2, ,  ,127.0.0.1, ,   ,,127.0.1.2\"\n    }\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert request.remote_addr == \"127.0.0.1\"\n    assert response.body == b\"127.0.0.1\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.remote_addr == '127.0.0.2'",
        "assert response.body == b'127.0.0.2'",
        "assert request.remote_addr == ''",
        "assert request.client_ip == '127.0.0.1'",
        "assert response.body == b''",
        "assert request.remote_addr == '127.0.0.1'",
        "assert response.body == b'127.0.0.1'",
        "assert request.remote_addr == ''",
        "assert response.body == b''",
        "assert request.remote_addr == '127.0.0.1'",
        "assert response.body == b'127.0.0.1'",
        "assert request.remote_addr == '127.0.0.1'",
        "assert response.body == b'127.0.0.1'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_remote_addr_without_proxy",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 809,
      "end_line_number": 829,
      "source_code": "def test_remote_addr_without_proxy(app):\n    app.config.PROXIES_COUNT = 0\n\n    @app.route(\"/\")\n    async def handler(request):\n        return text(request.remote_addr)\n\n    headers = {\"X-Real-IP\": \"127.0.0.2\", \"X-Forwarded-For\": \"127.0.1.1\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert request.remote_addr == \"\"\n    assert response.body == b\"\"\n\n    headers = {\"X-Forwarded-For\": \"127.0.1.1\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert request.remote_addr == \"\"\n    assert response.body == b\"\"\n\n    headers = {\"X-Forwarded-For\": \"127.0.0.1, 127.0.1.2\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert request.remote_addr == \"\"\n    assert response.body == b\"\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.remote_addr == ''",
        "assert response.body == b''",
        "assert request.remote_addr == ''",
        "assert response.body == b''",
        "assert request.remote_addr == ''",
        "assert response.body == b''"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_remote_addr_custom_headers",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 856,
      "end_line_number": 878,
      "source_code": "def test_remote_addr_custom_headers(app):\n    app.config.PROXIES_COUNT = 1\n    app.config.REAL_IP_HEADER = \"Client-IP\"\n    app.config.FORWARDED_FOR_HEADER = \"Forwarded\"\n\n    @app.route(\"/\")\n    async def handler(request):\n        return text(request.remote_addr)\n\n    headers = {\"X-Real-IP\": \"127.0.0.2\", \"Forwarded\": \"127.0.1.1\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert request.remote_addr == \"127.0.1.1\"\n    assert response.body == b\"127.0.1.1\"\n\n    headers = {\"X-Forwarded-For\": \"127.0.1.1\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert request.remote_addr == \"\"\n    assert response.body == b\"\"\n\n    headers = {\"Client-IP\": \"127.0.0.2\", \"Forwarded\": \"127.0.1.1\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert request.remote_addr == \"127.0.0.2\"\n    assert response.body == b\"127.0.0.2\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.remote_addr == '127.0.1.1'",
        "assert response.body == b'127.0.1.1'",
        "assert request.remote_addr == ''",
        "assert response.body == b''",
        "assert request.remote_addr == '127.0.0.2'",
        "assert response.body == b'127.0.0.2'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_forwarded_scheme",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 907,
      "end_line_number": 925,
      "source_code": "def test_forwarded_scheme(app):\n    @app.route(\"/\")\n    async def handler(request):\n        return text(request.remote_addr)\n\n    app.config.PROXIES_COUNT = 1\n    request, response = app.test_client.get(\"/\")\n    assert request.scheme == \"http\"\n\n    request, response = app.test_client.get(\n        \"/\",\n        headers={\"X-Forwarded-For\": \"127.1.2.3\", \"X-Forwarded-Proto\": \"https\"},\n    )\n    assert request.scheme == \"https\"\n\n    request, response = app.test_client.get(\n        \"/\", headers={\"X-Forwarded-For\": \"127.1.2.3\", \"X-Scheme\": \"https\"}\n    )\n    assert request.scheme == \"https\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.scheme == 'http'",
        "assert request.scheme == 'https'",
        "assert request.scheme == 'https'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_match_info",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 928,
      "end_line_number": 936,
      "source_code": "def test_match_info(app):\n    @app.route(\"/api/v1/user/<user_id>/\")\n    async def handler(request, user_id):\n        return json(request.match_info)\n\n    request, response = app.test_client.get(\"/api/v1/user/sanic_user/\")\n\n    assert request.match_info == {\"user_id\": \"sanic_user\"}\n    assert json_loads(response.text) == {\"user_id\": \"sanic_user\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.match_info == {'user_id': 'sanic_user'}",
        "assert json_loads(response.text) == {'user_id': 'sanic_user'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_post_json",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 956,
      "end_line_number": 970,
      "source_code": "def test_post_json(app):\n    @app.route(\"/\", methods=[\"POST\"])\n    async def handler(request):\n        return text(\"OK\")\n\n    payload = {\"test\": \"OK\"}\n    headers = {\"content-type\": \"application/json\"}\n\n    request, response = app.test_client.post(\n        \"/\", data=json_dumps(payload), headers=headers\n    )\n\n    assert request.json.get(\"test\") == \"OK\"\n    assert request.json.get(\"test\") == \"OK\"  # for request.parsed_json\n    assert response.body == b\"OK\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.json.get('test') == 'OK'",
        "assert request.json.get('test') == 'OK'",
        "assert response.body == b'OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "request.json.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "request.json.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_post_form_urlencoded",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 991,
      "end_line_number": 1004,
      "source_code": "def test_post_form_urlencoded(app):\n    @app.route(\"/\", methods=[\"POST\"])\n    async def handler(request):\n        return text(\"OK\")\n\n    payload = \"test=OK\"\n    headers = {\"content-type\": \"application/x-www-form-urlencoded\"}\n\n    request, response = app.test_client.post(\n        \"/\", data=payload, headers=headers\n    )\n\n    assert request.form.get(\"test\") == \"OK\"\n    assert request.form.get(\"test\") == \"OK\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.form.get('test') == 'OK'",
        "assert request.form.get('test') == 'OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "request.form.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "request.form.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_post_form_urlencoded_keep_blanks",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1024,
      "end_line_number": 1038,
      "source_code": "def test_post_form_urlencoded_keep_blanks(app):\n    @app.route(\"/\", methods=[\"POST\"])\n    async def handler(request):\n        request.get_form(keep_blank_values=True)\n        return text(\"OK\")\n\n    payload = \"test=\"\n    headers = {\"content-type\": \"application/x-www-form-urlencoded\"}\n\n    request, response = app.test_client.post(\n        \"/\", data=payload, headers=headers\n    )\n\n    assert request.form.get(\"test\") == \"\"\n    assert request.form.get(\"test\") == \"\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.form.get('test') == ''",
        "assert request.form.get('test') == ''"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "request.form.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "request.form.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_post_form_urlencoded_drop_blanks",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1059,
      "end_line_number": 1071,
      "source_code": "def test_post_form_urlencoded_drop_blanks(app):\n    @app.route(\"/\", methods=[\"POST\"])\n    async def handler(request):\n        return text(\"OK\")\n\n    payload = \"test=\"\n    headers = {\"content-type\": \"application/x-www-form-urlencoded\"}\n\n    request, response = app.test_client.post(\n        \"/\", data=payload, headers=headers\n    )\n\n    assert \"test\" not in request.form.keys()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'test' not in request.form.keys()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_post_form_multipart_form_data",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1105,
      "end_line_number": 1114,
      "source_code": "def test_post_form_multipart_form_data(app, payload):\n    @app.route(\"/\", methods=[\"POST\"])\n    async def handler(request):\n        return text(\"OK\")\n\n    headers = {\"content-type\": \"multipart/form-data; boundary=----sanic\"}\n\n    request, response = app.test_client.post(data=payload, headers=headers)\n\n    assert request.form.get(\"test\") == \"OK\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('payload', ['------sanic\\r\\nContent-Disposition: form-data; name=\"test\"\\r\\n\\r\\nOK\\r\\n------sanic--\\r\\n', '------sanic\\r\\ncontent-disposition: form-data; name=\"test\"\\r\\n\\r\\nOK\\r\\n------sanic--\\r\\n'])"
      ],
      "arguments": [
        "app",
        "payload"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.form.get('test') == 'OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "request.form.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_url_attributes_no_ssl",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1155,
      "end_line_number": 1169,
      "source_code": "def test_url_attributes_no_ssl(app, path, query, expected_url):\n    async def handler(request):\n        return text(\"OK\")\n\n    app.add_route(handler, path)\n\n    request, response = app.test_client.get(path + f\"?{query}\")\n    assert request.url == expected_url.format(HOST, request.server_port)\n\n    parsed = urlparse(request.url)\n\n    assert parsed.scheme == request.scheme\n    assert parsed.path == request.path\n    assert parsed.query == request.query_string\n    assert parsed.netloc == request.host",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('path,query,expected_url', [('/foo', '', 'http://{}:{}/foo'), ('/bar/baz', '', 'http://{}:{}/bar/baz'), ('/moo/boo', 'arg1=val1', 'http://{}:{}/moo/boo?arg1=val1')])"
      ],
      "arguments": [
        "app",
        "path",
        "query",
        "expected_url"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.url == expected_url.format(HOST, request.server_port)",
        "assert parsed.scheme == request.scheme",
        "assert parsed.path == request.path",
        "assert parsed.query == request.query_string",
        "assert parsed.netloc == request.host"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_form_with_multiple_values",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1198,
      "end_line_number": 1211,
      "source_code": "def test_form_with_multiple_values(app):\n    @app.route(\"/\", methods=[\"POST\"])\n    async def handler(request):\n        return text(\"OK\")\n\n    payload = \"selectedItems=v1&selectedItems=v2&selectedItems=v3\"\n\n    headers = {\"content-type\": \"application/x-www-form-urlencoded\"}\n\n    request, response = app.test_client.post(\n        \"/\", data=payload, headers=headers\n    )\n\n    assert request.form.getlist(\"selectedItems\") == [\"v1\", \"v2\", \"v3\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.form.getlist('selectedItems') == ['v1', 'v2', 'v3']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_request_string_representation",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1231,
      "end_line_number": 1237,
      "source_code": "def test_request_string_representation(app):\n    @app.route(\"/\", methods=[\"GET\"])\n    async def get(request):\n        return text(\"OK\")\n\n    request, _ = app.test_client.get(\"/\")\n    assert repr(request) == \"<Request: GET />\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(request) == '<Request: GET />'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_request_multipart_files",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1327,
      "end_line_number": 1335,
      "source_code": "def test_request_multipart_files(app, payload, filename):\n    @app.route(\"/\", methods=[\"POST\"])\n    async def post(request):\n        return text(\"OK\")\n\n    headers = {\"content-type\": \"multipart/form-data; boundary=----sanic\"}\n\n    request, _ = app.test_client.post(data=payload, headers=headers)\n    assert request.files.get(\"test\").name == filename",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('payload,filename', [('------sanic\\r\\nContent-Disposition: form-data; filename=\"filename\"; name=\"test\"\\r\\n\\r\\nOK\\r\\n------sanic--\\r\\n', 'filename'), ('------sanic\\r\\ncontent-disposition: form-data; filename=\"filename\"; name=\"test\"\\r\\n\\r\\ncontent-type: application/json; {\"field\": \"value\"}\\r\\n------sanic--\\r\\n', 'filename'), ('------sanic\\r\\nContent-Disposition: form-data; filename=\"\"; name=\"test\"\\r\\n\\r\\nOK\\r\\n------sanic--\\r\\n', ''), ('------sanic\\r\\ncontent-disposition: form-data; filename=\"\"; name=\"test\"\\r\\n\\r\\ncontent-type: application/json; {\"field\": \"value\"}\\r\\n------sanic--\\r\\n', ''), ('------sanic\\r\\nContent-Disposition: form-data; filename*=\"utf-8\\'\\'filename_%C2%A0_test\"; name=\"test\"\\r\\n\\r\\nOK\\r\\n------sanic--\\r\\n', 'filename_\\xa0_test'), ('------sanic\\r\\ncontent-disposition: form-data; filename*=\"utf-8\\'\\'filename_%C2%A0_test\"; name=\"test\"\\r\\n\\r\\ncontent-type: application/json; {\"field\": \"value\"}\\r\\n------sanic--\\r\\n', 'filename_\\xa0_test'), ('------sanic\\r\\ncontent-disposition: form-data; filename*=\"utf-8\\'\\'filename_%C3%A4_test\"; name=\"test\"\\r\\n\\r\\nOK\\r\\n------sanic--\\r\\n', 'filename_\u00e4_test'), ('------sanic\\r\\ncontent-disposition: form-data; filename*=\"utf-8\\'\\'filename_a%CC%88_test\"; name=\"test\"\\r\\n\\r\\nOK\\r\\n------sanic--\\r\\n', 'filename_\u00e4_test')])"
      ],
      "arguments": [
        "app",
        "payload",
        "filename"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.files.get('test').name == filename"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "request.files.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_request_multipart_file_with_json_content_type",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1407,
      "end_line_number": 1426,
      "source_code": "def test_request_multipart_file_with_json_content_type(app):\n    @app.route(\"/\", methods=[\"POST\"])\n    async def post(request):\n        return text(\"OK\")\n\n    payload = (\n        \"------sanic\\r\\n\"\n        'Content-Disposition: form-data; name=\"file\";'\n        ' filename=\"test.json\"\\r\\n'\n        \"Content-Type: application/json\\r\\n\"\n        \"Content-Length: 0\"\n        \"\\r\\n\"\n        \"\\r\\n\"\n        \"------sanic--\"\n    )\n\n    headers = {\"content-type\": \"multipart/form-data; boundary=------sanic\"}\n\n    request, _ = app.test_client.post(data=payload, headers=headers)\n    assert request.files.get(\"file\").type == \"application/json\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.files.get('file').type == 'application/json'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "request.files.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_request_multipart_file_without_field_name",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1452,
      "end_line_number": 1475,
      "source_code": "def test_request_multipart_file_without_field_name(app, caplog):\n    @app.route(\"/\", methods=[\"POST\"])\n    async def post(request):\n        return text(\"OK\")\n\n    payload = (\n        '------sanic\\r\\nContent-Disposition: form-data; filename=\"test.json\"'\n        \"\\r\\nContent-Type: application/json\\r\\n\\r\\n\\r\\n------sanic--\"\n    )\n\n    headers = {\"content-type\": \"multipart/form-data; boundary=------sanic\"}\n\n    request, _ = app.test_client.post(\n        data=payload, headers=headers, debug=True\n    )\n    with caplog.at_level(logging.DEBUG):\n        request.form\n\n    assert caplog.record_tuples[-1] == (\n        \"sanic.root\",\n        logging.DEBUG,\n        \"Form-data field does not have a 'name' parameter \"\n        \"in the Content-Disposition header\",\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "caplog"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert caplog.record_tuples[-1] == ('sanic.root', logging.DEBUG, \"Form-data field does not have a 'name' parameter in the Content-Disposition header\")"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_request_multipart_file_duplicate_filed_name",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1478,
      "end_line_number": 1510,
      "source_code": "def test_request_multipart_file_duplicate_filed_name(app):\n    @app.route(\"/\", methods=[\"POST\"])\n    async def post(request):\n        return text(\"OK\")\n\n    payload = (\n        \"--e73ffaa8b1b2472b8ec848de833cb05b\\r\\n\"\n        'Content-Disposition: form-data; name=\"file\"\\r\\n'\n        \"Content-Type: application/octet-stream\\r\\n\"\n        \"Content-Length: 15\\r\\n\"\n        \"\\r\\n\"\n        '{\"test\":\"json\"}\\r\\n'\n        \"--e73ffaa8b1b2472b8ec848de833cb05b\\r\\n\"\n        'Content-Disposition: form-data; name=\"file\"\\r\\n'\n        \"Content-Type: application/octet-stream\\r\\n\"\n        \"Content-Length: 15\\r\\n\"\n        \"\\r\\n\"\n        '{\"test\":\"json2\"}\\r\\n'\n        \"--e73ffaa8b1b2472b8ec848de833cb05b--\\r\\n\"\n    )\n\n    headers = {\n        \"Content-Type\": \"multipart/form-data;\"\n        \" boundary=e73ffaa8b1b2472b8ec848de833cb05b\"\n    }\n\n    request, _ = app.test_client.post(\n        data=payload, headers=headers, debug=True\n    )\n    assert request.form.getlist(\"file\") == [\n        '{\"test\":\"json\"}',\n        '{\"test\":\"json2\"}',\n    ]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.form.getlist('file') == ['{\"test\":\"json\"}', '{\"test\":\"json2\"}']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_request_multipart_with_multiple_files_and_type",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1547,
      "end_line_number": 1565,
      "source_code": "def test_request_multipart_with_multiple_files_and_type(app):\n    @app.route(\"/\", methods=[\"POST\"])\n    async def post(request):\n        return text(\"OK\")\n\n    payload = (\n        '------sanic\\r\\nContent-Disposition: form-data; name=\"file\";'\n        ' filename=\"test.json\"'\n        \"\\r\\nContent-Type: application/json\\r\\n\\r\\n\\r\\n\"\n        '------sanic\\r\\nContent-Disposition: form-data; name=\"file\";'\n        ' filename=\"some_file.pdf\"\\r\\n'\n        \"Content-Type: application/pdf\\r\\n\\r\\n\\r\\n------sanic--\"\n    )\n    headers = {\"content-type\": \"multipart/form-data; boundary=------sanic\"}\n\n    request, _ = app.test_client.post(data=payload, headers=headers)\n    assert len(request.files.getlist(\"file\")) == 2\n    assert request.files.getlist(\"file\")[0].type == \"application/json\"\n    assert request.files.getlist(\"file\")[1].type == \"application/pdf\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(request.files.getlist('file')) == 2",
        "assert request.files.getlist('file')[0].type == 'application/json'",
        "assert request.files.getlist('file')[1].type == 'application/pdf'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_request_repr",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1590,
      "end_line_number": 1599,
      "source_code": "def test_request_repr(app):\n    @app.get(\"/\")\n    def handler(request):\n        return text(\"pass\")\n\n    request, response = app.test_client.get(\"/\")\n    assert repr(request) == \"<Request: GET />\"\n\n    request.method = None\n    assert repr(request) == \"<Request: None />\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(request) == '<Request: GET />'",
        "assert repr(request) == '<Request: None />'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_request_bool",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1615,
      "end_line_number": 1621,
      "source_code": "def test_request_bool(app):\n    @app.get(\"/\")\n    def handler(request):\n        return text(\"pass\")\n\n    request, response = app.test_client.get(\"/\")\n    assert bool(request)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert bool(request)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_request_parsing_form_failed",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1624,
      "end_line_number": 1643,
      "source_code": "def test_request_parsing_form_failed(app, caplog):\n    @app.route(\"/\", methods=[\"POST\"])\n    async def handler(request):\n        return text(\"OK\")\n\n    payload = \"test=OK\"\n    headers = {\"content-type\": \"multipart/form-data\"}\n\n    request, response = app.test_client.post(\n        \"/\", data=payload, headers=headers\n    )\n\n    with caplog.at_level(logging.ERROR):\n        request.form\n\n    assert caplog.record_tuples[-1] == (\n        \"sanic.error\",\n        logging.ERROR,\n        \"Failed when parsing form\",\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "caplog"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert caplog.record_tuples[-1] == ('sanic.error', logging.ERROR, 'Failed when parsing form')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_request_args_no_query_string",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1669,
      "end_line_number": 1676,
      "source_code": "def test_request_args_no_query_string(app):\n    @app.get(\"/\")\n    def handler(request):\n        return text(\"pass\")\n\n    request, response = app.test_client.get(\"/\")\n\n    assert request.args == {}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.args == {}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_request_query_args",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1690,
      "end_line_number": 1723,
      "source_code": "def test_request_query_args(app):\n    # test multiple params with the same key\n    params = [(\"test\", \"value1\"), (\"test\", \"value2\")]\n\n    @app.get(\"/\")\n    def handler(request):\n        return text(\"pass\")\n\n    request, response = app.test_client.get(\"/\", params=params)\n\n    assert request.query_args == params\n\n    # test cached value\n    assert (\n        request.parsed_not_grouped_args[(False, False, \"utf-8\", \"replace\")]\n        == request.query_args\n    )\n\n    # test params directly in the url\n    request, response = app.test_client.get(\"/?test=value1&test=value2\")\n\n    assert request.query_args == params\n\n    # test unique params\n    params = [(\"test1\", \"value1\"), (\"test2\", \"value2\")]\n\n    request, response = app.test_client.get(\"/\", params=params)\n\n    assert request.query_args == params\n\n    # test no params\n    request, response = app.test_client.get(\"/\")\n\n    assert not request.query_args",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.query_args == params",
        "assert request.parsed_not_grouped_args[False, False, 'utf-8', 'replace'] == request.query_args",
        "assert request.query_args == params",
        "assert request.query_args == params",
        "assert not request.query_args"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_request_query_args_custom_parsing",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1763,
      "end_line_number": 1793,
      "source_code": "def test_request_query_args_custom_parsing(app):\n    @app.get(\"/\")\n    def handler(request):\n        return text(\"pass\")\n\n    request, response = app.test_client.get(\n        \"/?test1=value1&test2=&test3=value3\"\n    )\n\n    assert request.get_query_args(keep_blank_values=True) == [\n        (\"test1\", \"value1\"),\n        (\"test2\", \"\"),\n        (\"test3\", \"value3\"),\n    ]\n    assert request.query_args == [(\"test1\", \"value1\"), (\"test3\", \"value3\")]\n    assert request.get_query_args(keep_blank_values=False) == [\n        (\"test1\", \"value1\"),\n        (\"test3\", \"value3\"),\n    ]\n\n    assert request.get_args(keep_blank_values=True) == RequestParameters(\n        {\"test1\": [\"value1\"], \"test2\": [\"\"], \"test3\": [\"value3\"]}\n    )\n\n    assert request.args == RequestParameters(\n        {\"test1\": [\"value1\"], \"test3\": [\"value3\"]}\n    )\n\n    assert request.get_args(keep_blank_values=False) == RequestParameters(\n        {\"test1\": [\"value1\"], \"test3\": [\"value3\"]}\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.get_query_args(keep_blank_values=True) == [('test1', 'value1'), ('test2', ''), ('test3', 'value3')]",
        "assert request.query_args == [('test1', 'value1'), ('test3', 'value3')]",
        "assert request.get_query_args(keep_blank_values=False) == [('test1', 'value1'), ('test3', 'value3')]",
        "assert request.get_args(keep_blank_values=True) == RequestParameters({'test1': ['value1'], 'test2': [''], 'test3': ['value3']})",
        "assert request.args == RequestParameters({'test1': ['value1'], 'test3': ['value3']})",
        "assert request.get_args(keep_blank_values=False) == RequestParameters({'test1': ['value1'], 'test3': ['value3']})"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_request_cookies",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1830,
      "end_line_number": 1840,
      "source_code": "def test_request_cookies(app):\n    cookies = {\"test\": \"OK\"}\n\n    @app.get(\"/\")\n    def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/\", cookies=cookies)\n\n    assert len(request.cookies) == len(cookies)\n    assert request.cookies[\"test\"] == cookies[\"test\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(request.cookies) == len(cookies)",
        "assert request.cookies['test'] == cookies['test']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_request_cookies_without_cookies",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1857,
      "end_line_number": 1864,
      "source_code": "def test_request_cookies_without_cookies(app):\n    @app.get(\"/\")\n    def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/\")\n\n    assert request.cookies == {}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.cookies == {}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_request_port",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1878,
      "end_line_number": 1886,
      "source_code": "def test_request_port(app):\n    @app.get(\"/\")\n    def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/\")\n\n    port = request.port\n    assert isinstance(port, int)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(port, int)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_request_socket",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1901,
      "end_line_number": 1915,
      "source_code": "def test_request_socket(app):\n    @app.get(\"/\")\n    def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/\")\n\n    socket = request.socket\n    assert isinstance(socket, tuple)\n\n    ip = socket[0]\n    port = socket[1]\n\n    assert ip == request.ip\n    assert port == request.port",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(socket, tuple)",
        "assert ip == request.ip",
        "assert port == request.port"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_request_server_name",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1918,
      "end_line_number": 1924,
      "source_code": "def test_request_server_name(app):\n    @app.get(\"/\")\n    def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/\")\n    assert request.server_name == \"127.0.0.1\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.server_name == '127.0.0.1'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_request_server_name_in_host_header",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1927,
      "end_line_number": 1945,
      "source_code": "def test_request_server_name_in_host_header(app):\n    @app.get(\"/\")\n    def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\n        \"/\", headers={\"Host\": \"my-server:5555\"}\n    )\n    assert request.server_name == \"my-server\"\n\n    request, response = app.test_client.get(\n        \"/\", headers={\"Host\": \"[2a00:1450:400f:80c::200e]:5555\"}\n    )\n    assert request.server_name == \"[2a00:1450:400f:80c::200e]\"\n\n    request, response = app.test_client.get(\n        \"/\", headers={\"Host\": \"mal_formed\"}\n    )\n    assert request.server_name == \"\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.server_name == 'my-server'",
        "assert request.server_name == '[2a00:1450:400f:80c::200e]'",
        "assert request.server_name == ''"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_request_server_name_forwarded",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1948,
      "end_line_number": 1962,
      "source_code": "def test_request_server_name_forwarded(app):\n    @app.get(\"/\")\n    def handler(request):\n        return text(\"OK\")\n\n    app.config.PROXIES_COUNT = 1\n    request, response = app.test_client.get(\n        \"/\",\n        headers={\n            \"Host\": \"my-server:5555\",\n            \"X-Forwarded-For\": \"127.1.2.3\",\n            \"X-Forwarded-Host\": \"your-server\",\n        },\n    )\n    assert request.server_name == \"your-server\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.server_name == 'your-server'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_request_server_port",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1965,
      "end_line_number": 1972,
      "source_code": "def test_request_server_port(app):\n    @app.get(\"/\")\n    def handler(request):\n        return text(\"OK\")\n\n    test_client = SanicTestClient(app)\n    request, response = test_client.get(\"/\", headers={\"Host\": \"my-server\"})\n    assert request.server_port == 80",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.server_port == 80"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_request_server_port_in_host_header",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1975,
      "end_line_number": 1996,
      "source_code": "def test_request_server_port_in_host_header(app):\n    @app.get(\"/\")\n    def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\n        \"/\", headers={\"Host\": \"my-server:5555\"}\n    )\n    assert request.server_port == 5555\n\n    request, response = app.test_client.get(\n        \"/\", headers={\"Host\": \"[2a00:1450:400f:80c::200e]:5555\"}\n    )\n    assert request.server_port == 5555\n\n    request, response = app.test_client.get(\n        \"/\", headers={\"Host\": \"mal_formed:5555\"}\n    )\n    if PORT is None:\n        assert request.server_port != 5555\n    else:\n        assert request.server_port == app.test_client.port",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.server_port == 5555",
        "assert request.server_port == 5555",
        "assert request.server_port != 5555",
        "assert request.server_port == app.test_client.port"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_request_server_port_forwarded",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 1999,
      "end_line_number": 2013,
      "source_code": "def test_request_server_port_forwarded(app):\n    @app.get(\"/\")\n    def handler(request):\n        return text(\"OK\")\n\n    app.config.PROXIES_COUNT = 1\n    request, response = app.test_client.get(\n        \"/\",\n        headers={\n            \"Host\": \"my-server:5555\",\n            \"X-Forwarded-For\": \"127.1.2.3\",\n            \"X-Forwarded-Port\": \"4444\",\n        },\n    )\n    assert request.server_port == 4444",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.server_port == 4444"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_request_form_invalid_content_type",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 2016,
      "end_line_number": 2023,
      "source_code": "def test_request_form_invalid_content_type(app):\n    @app.route(\"/\", methods=[\"POST\"])\n    async def post(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.post(\"/\", json={\"test\": \"OK\"})\n\n    assert request.form == {}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.form == {}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_server_name_and_url_for",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 2026,
      "end_line_number": 2040,
      "source_code": "def test_server_name_and_url_for(app):\n    @app.get(\"/foo\")\n    def handler(request):\n        return text(\"ok\")\n\n    app.config.SERVER_NAME = \"my-server\"  # This means default port\n    assert app.url_for(\"handler\", _external=True) == \"http://my-server/foo\"\n    request, response = app.test_client.get(\"/foo\")\n    assert request.url_for(\"handler\") == \"http://my-server/foo\"\n\n    app.config.SERVER_NAME = \"https://my-server/path\"\n    request, response = app.test_client.get(\"/foo\")\n    url = \"https://my-server/path/foo\"\n    assert app.url_for(\"handler\", _external=True) == url\n    assert request.url_for(\"handler\") == url",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.url_for('handler', _external=True) == 'http://my-server/foo'",
        "assert request.url_for('handler') == 'http://my-server/foo'",
        "assert app.url_for('handler', _external=True) == url",
        "assert request.url_for('handler') == url"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "request.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "request.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_url_for_with_forwarded_request",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 2043,
      "end_line_number": 2079,
      "source_code": "def test_url_for_with_forwarded_request(app):\n    @app.get(\"/\")\n    def handler(request):\n        return text(\"OK\")\n\n    @app.get(\"/another_view/\")\n    def view_name(request):\n        return text(\"OK\")\n\n    app.config.SERVER_NAME = \"my-server\"\n    app.config.PROXIES_COUNT = 1\n    request, response = app.test_client.get(\n        \"/\",\n        headers={\n            \"X-Forwarded-For\": \"127.1.2.3\",\n            \"X-Forwarded-Proto\": \"https\",\n            \"X-Forwarded-Port\": \"6789\",\n        },\n    )\n    assert app.url_for(\"view_name\") == \"/another_view\"\n    assert (\n        app.url_for(\"view_name\", _external=True)\n        == \"http://my-server/another_view\"\n    )\n    assert (\n        request.url_for(\"view_name\") == \"https://my-server:6789/another_view\"\n    )\n\n    request, response = app.test_client.get(\n        \"/\",\n        headers={\n            \"X-Forwarded-For\": \"127.1.2.3\",\n            \"X-Forwarded-Proto\": \"https\",\n            \"X-Forwarded-Port\": \"443\",\n        },\n    )\n    assert request.url_for(\"view_name\") == \"https://my-server/another_view\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.url_for('view_name') == '/another_view'",
        "assert app.url_for('view_name', _external=True) == 'http://my-server/another_view'",
        "assert request.url_for('view_name') == 'https://my-server:6789/another_view'",
        "assert request.url_for('view_name') == 'https://my-server/another_view'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "request.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "request.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_endpoint_basic",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 2093,
      "end_line_number": 2102,
      "source_code": "def test_endpoint_basic():\n    app = Sanic(name=\"Test\")\n\n    @app.route(\"/\")\n    def my_unique_handler(request):\n        return text(\"Hello\")\n\n    request, response = app.test_client.get(\"/\")\n\n    assert request.endpoint == \"Test.my_unique_handler\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.endpoint == 'Test.my_unique_handler'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_endpoint_named_app",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 2118,
      "end_line_number": 2127,
      "source_code": "def test_endpoint_named_app():\n    app = Sanic(\"named\")\n\n    @app.route(\"/\")\n    def my_unique_handler(request):\n        return text(\"Hello\")\n\n    request, response = app.test_client.get(\"/\")\n\n    assert request.endpoint == \"named.my_unique_handler\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.endpoint == 'named.my_unique_handler'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_endpoint_blueprint",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 2143,
      "end_line_number": 2155,
      "source_code": "def test_endpoint_blueprint():\n    bp = Blueprint(\"my_blueprint\", url_prefix=\"/bp\")\n\n    @bp.route(\"/\")\n    async def bp_root(request):\n        return text(\"Hello\")\n\n    app = Sanic(\"named\")\n    app.blueprint(bp)\n\n    request, response = app.test_client.get(\"/bp\")\n\n    assert request.endpoint == \"named.my_blueprint.bp_root\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.endpoint == 'named.my_blueprint.bp_root'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_url_for_without_server_name",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 2174,
      "end_line_number": 2187,
      "source_code": "def test_url_for_without_server_name(app):\n    @app.route(\"/sample\")\n    def sample(request):\n        return json({\"url\": request.url_for(\"url_for\")})\n\n    @app.route(\"/url-for\")\n    def url_for(request):\n        return text(\"url-for\")\n\n    request, response = app.test_client.get(\"/sample\")\n    assert (\n        response.json[\"url\"]\n        == f\"http://127.0.0.1:{request.server_port}/url-for\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json['url'] == f'http://127.0.0.1:{request.server_port}/url-for'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "request.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_safe_method_with_body_ignored",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 2190,
      "end_line_number": 2204,
      "source_code": "def test_safe_method_with_body_ignored(app):\n    @app.get(\"/\")\n    async def handler(request):\n        return text(\"OK\")\n\n    payload = {\"test\": \"OK\"}\n    headers = {\"content-type\": \"application/json\"}\n\n    request, response = app.test_client.request(\n        \"/\", http_method=\"get\", data=json_dumps(payload), headers=headers\n    )\n\n    assert request.body == b\"\"\n    assert request.json is None\n    assert response.body == b\"OK\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.body == b''",
        "assert request.json is None",
        "assert response.body == b'OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.request",
          "body": "@app.on_request\ndef request(_):\n    nonlocal request_middleware_run_count\n    request_middleware_run_count += 1"
        }
      ]
    },
    {
      "name": "test_safe_method_with_body",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 2207,
      "end_line_number": 2221,
      "source_code": "def test_safe_method_with_body(app):\n    @app.get(\"/\", ignore_body=False)\n    async def handler(request):\n        return text(\"OK\")\n\n    payload = {\"test\": \"OK\"}\n    headers = {\"content-type\": \"application/json\"}\n    data = json_dumps(payload)\n    request, response = app.test_client.request(\n        \"/\", http_method=\"get\", data=data, headers=headers\n    )\n\n    assert request.body == data.encode(\"utf-8\")\n    assert request.json.get(\"test\") == \"OK\"\n    assert response.body == b\"OK\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.body == data.encode('utf-8')",
        "assert request.json.get('test') == 'OK'",
        "assert response.body == b'OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.request",
          "body": "@app.on_request\ndef request(_):\n    nonlocal request_middleware_run_count\n    request_middleware_run_count += 1"
        },
        {
          "name": "request.json.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_conflicting_body_methods_overload",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 2241,
      "end_line_number": 2286,
      "source_code": "def test_conflicting_body_methods_overload(app: Sanic):\n    @app.put(\"/\", name=\"one\")\n    @app.put(\"/p/\", name=\"two\")\n    @app.put(\"/p/<foo>\", name=\"three\")\n    async def put(request, foo=None):\n        return json(\n            {\"name\": request.route.name, \"body\": str(request.body), \"foo\": foo}\n        )\n\n    @app.delete(\"/p/<foo>\")\n    async def delete(request, foo):\n        return json(\n            {\"name\": request.route.name, \"body\": str(request.body), \"foo\": foo}\n        )\n\n    payload = {\"test\": \"OK\"}\n    data = str(json_dumps(payload).encode())\n\n    _, response = app.test_client.put(\"/\", json=payload)\n    assert response.status == 200\n    assert response.json == {\n        \"name\": \"test_conflicting_body_methods_overload.one\",\n        \"foo\": None,\n        \"body\": data,\n    }\n    _, response = app.test_client.put(\"/p\", json=payload)\n    assert response.status == 200\n    assert response.json == {\n        \"name\": \"test_conflicting_body_methods_overload.two\",\n        \"foo\": None,\n        \"body\": data,\n    }\n    _, response = app.test_client.put(\"/p/test\", json=payload)\n    assert response.status == 200\n    assert response.json == {\n        \"name\": \"test_conflicting_body_methods_overload.three\",\n        \"foo\": \"test\",\n        \"body\": data,\n    }\n    _, response = app.test_client.delete(\"/p/test\")\n    assert response.status == 200\n    assert response.json == {\n        \"name\": \"test_conflicting_body_methods_overload.delete\",\n        \"foo\": \"test\",\n        \"body\": str(\"\".encode()),\n    }",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.json == {'name': 'test_conflicting_body_methods_overload.one', 'foo': None, 'body': data}",
        "assert response.status == 200",
        "assert response.json == {'name': 'test_conflicting_body_methods_overload.two', 'foo': None, 'body': data}",
        "assert response.status == 200",
        "assert response.json == {'name': 'test_conflicting_body_methods_overload.three', 'foo': 'test', 'body': data}",
        "assert response.status == 200",
        "assert response.json == {'name': 'test_conflicting_body_methods_overload.delete', 'foo': 'test', 'body': str(''.encode())}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.delete",
          "body": "def delete(self, request):\n    return text('I am delete method')"
        },
        {
          "name": "app.test_client.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.test_client.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.test_client.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.test_client.delete",
          "body": "def delete(self, request):\n    return text('I am delete method')"
        }
      ]
    },
    {
      "name": "test_handler_overload",
      "module": "test_requests",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_requests.py",
      "line_number": 2305,
      "end_line_number": 2324,
      "source_code": "def test_handler_overload(app: Sanic):\n    @app.get(\n        \"/long/sub/route/param_a/<param_a:str>/param_b/<param_b:str>\",\n        name=\"one\",\n    )\n    @app.post(\"/long/sub/route/\", name=\"two\")\n    def handler(request, **kwargs):\n        return json(kwargs)\n\n    _, response = app.test_client.get(\n        \"/long/sub/route/param_a/foo/param_b/bar\"\n    )\n    assert response.status == 200\n    assert response.json == {\n        \"param_a\": \"foo\",\n        \"param_b\": \"bar\",\n    }\n    _, response = app.test_client.post(\"/long/sub/route\")\n    assert response.status == 200\n    assert response.json == {}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "logging",
        "json.dumps",
        "json.loads",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.ASGI_BASE_URL",
        "sanic_testing.testing.ASGI_PORT",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.DEFAULT_HTTP_CONTENT_TYPE",
        "sanic.exceptions.ServerError",
        "sanic.request.RequestParameters",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.json == {'param_a': 'foo', 'param_b': 'bar'}",
        "assert response.status == 200",
        "assert response.json == {}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_static_directory_view",
      "module": "test_static_directory",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static_directory.py",
      "line_number": 21,
      "end_line_number": 27,
      "source_code": "def test_static_directory_view(app: Sanic, static_file_directory: str):\n    app.static(\"/static\", static_file_directory, directory_view=True)\n\n    _, response = app.test_client.get(\"/static/\")\n    assert response.status == 200\n    assert response.content_type == \"text/html; charset=utf-8\"\n    assert \"<title>Directory Viewer</title>\" in response.text",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "static_file_directory"
      ],
      "imports": [
        "os",
        "pathlib.Path",
        "pytest",
        "sanic.Sanic",
        "sanic.handlers.directory.DirectoryHandler"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.content_type == 'text/html; charset=utf-8'",
        "assert '<title>Directory Viewer</title>' in response.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_static_index_single",
      "module": "test_static_directory",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static_directory.py",
      "line_number": 30,
      "end_line_number": 38,
      "source_code": "def test_static_index_single(app: Sanic, static_file_directory: str):\n    app.static(\"/static\", static_file_directory, index=\"test.html\")\n\n    _, response = app.test_client.get(\"/static/\")\n    assert response.status == 200\n    assert response.body == get_file_content(\n        static_file_directory, \"test.html\"\n    )\n    assert response.headers[\"Content-Type\"] == \"text/html\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "static_file_directory"
      ],
      "imports": [
        "os",
        "pathlib.Path",
        "pytest",
        "sanic.Sanic",
        "sanic.handlers.directory.DirectoryHandler"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, 'test.html')",
        "assert response.headers['Content-Type'] == 'text/html'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ]
    },
    {
      "name": "test_static_index_single_not_found",
      "module": "test_static_directory",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static_directory.py",
      "line_number": 41,
      "end_line_number": 45,
      "source_code": "def test_static_index_single_not_found(app: Sanic, static_file_directory: str):\n    app.static(\"/static\", static_file_directory, index=\"index.html\")\n\n    _, response = app.test_client.get(\"/static/\")\n    assert response.status == 404",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "static_file_directory"
      ],
      "imports": [
        "os",
        "pathlib.Path",
        "pytest",
        "sanic.Sanic",
        "sanic.handlers.directory.DirectoryHandler"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_static_index_multiple",
      "module": "test_static_directory",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static_directory.py",
      "line_number": 48,
      "end_line_number": 60,
      "source_code": "def test_static_index_multiple(app: Sanic, static_file_directory: str):\n    app.static(\n        \"/static\",\n        static_file_directory,\n        index=[\"index.html\", \"test.html\"],\n    )\n\n    _, response = app.test_client.get(\"/static/\")\n    assert response.status == 200\n    assert response.body == get_file_content(\n        static_file_directory, \"test.html\"\n    )\n    assert response.headers[\"Content-Type\"] == \"text/html\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "static_file_directory"
      ],
      "imports": [
        "os",
        "pathlib.Path",
        "pytest",
        "sanic.Sanic",
        "sanic.handlers.directory.DirectoryHandler"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, 'test.html')",
        "assert response.headers['Content-Type'] == 'text/html'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ]
    },
    {
      "name": "test_static_directory_view_and_index",
      "module": "test_static_directory",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static_directory.py",
      "line_number": 63,
      "end_line_number": 83,
      "source_code": "def test_static_directory_view_and_index(\n    app: Sanic, static_file_directory: str\n):\n    app.static(\n        \"/static\",\n        static_file_directory,\n        directory_view=True,\n        index=\"foo.txt\",\n    )\n\n    _, response = app.test_client.get(\"/static/nested/\")\n    assert response.status == 200\n    assert response.content_type == \"text/html; charset=utf-8\"\n    assert \"<title>Directory Viewer</title>\" in response.text\n\n    _, response = app.test_client.get(\"/static/nested/dir/\")\n    assert response.status == 200\n    assert response.body == get_file_content(\n        f\"{static_file_directory}/nested/dir\", \"foo.txt\"\n    )\n    assert response.content_type == \"text/plain\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "static_file_directory"
      ],
      "imports": [
        "os",
        "pathlib.Path",
        "pytest",
        "sanic.Sanic",
        "sanic.handlers.directory.DirectoryHandler"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.content_type == 'text/html; charset=utf-8'",
        "assert '<title>Directory Viewer</title>' in response.text",
        "assert response.status == 200",
        "assert response.body == get_file_content(f'{static_file_directory}/nested/dir', 'foo.txt')",
        "assert response.content_type == 'text/plain'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ]
    },
    {
      "name": "test_static_directory_handler",
      "module": "test_static_directory",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static_directory.py",
      "line_number": 86,
      "end_line_number": 105,
      "source_code": "def test_static_directory_handler(app: Sanic, static_file_directory: str):\n    dh = DirectoryHandler(\n        \"/static\",\n        Path(static_file_directory),\n        directory_view=True,\n        index=\"foo.txt\",\n    )\n    app.static(\"/static\", static_file_directory, directory_handler=dh)\n\n    _, response = app.test_client.get(\"/static/nested/\")\n    assert response.status == 200\n    assert response.content_type == \"text/html; charset=utf-8\"\n    assert \"<title>Directory Viewer</title>\" in response.text\n\n    _, response = app.test_client.get(\"/static/nested/dir/\")\n    assert response.status == 200\n    assert response.body == get_file_content(\n        f\"{static_file_directory}/nested/dir\", \"foo.txt\"\n    )\n    assert response.content_type == \"text/plain\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "static_file_directory"
      ],
      "imports": [
        "os",
        "pathlib.Path",
        "pytest",
        "sanic.Sanic",
        "sanic.handlers.directory.DirectoryHandler"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.content_type == 'text/html; charset=utf-8'",
        "assert '<title>Directory Viewer</title>' in response.text",
        "assert response.status == 200",
        "assert response.body == get_file_content(f'{static_file_directory}/nested/dir', 'foo.txt')",
        "assert response.content_type == 'text/plain'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ]
    },
    {
      "name": "test_static_directory_handler_fails",
      "module": "test_static_directory",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static_directory.py",
      "line_number": 108,
      "end_line_number": 123,
      "source_code": "def test_static_directory_handler_fails(app: Sanic):\n    dh = DirectoryHandler(\n        \"/static\",\n        Path(\"\"),\n        directory_view=True,\n        index=\"foo.txt\",\n    )\n    message = (\n        \"When explicitly setting directory_handler, you cannot \"\n        \"set either directory_view or index. Instead, pass \"\n        \"these arguments to your DirectoryHandler instance.\"\n    )\n    with pytest.raises(ValueError, match=message):\n        app.static(\"/static\", \"\", directory_handler=dh, directory_view=True)\n    with pytest.raises(ValueError, match=message):\n        app.static(\"/static\", \"\", directory_handler=dh, index=\"index.html\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "os",
        "pathlib.Path",
        "pytest",
        "sanic.Sanic",
        "sanic.handlers.directory.DirectoryHandler"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ws_handler",
      "module": "test_ws_handlers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_ws_handlers.py",
      "line_number": 63,
      "end_line_number": 77,
      "source_code": "def test_ws_handler(\n    app: Sanic,\n    simple_ws_mimic_client: MimicClientType,\n):\n    @app.websocket(\"/ws\")\n    async def ws_echo_handler(request: Request, ws: Websocket):\n        while True:\n            msg = await ws.recv()\n            await ws.send(msg)\n\n    _, ws_proxy = app.test_client.websocket(\n        \"/ws\", mimic=simple_ws_mimic_client\n    )\n    assert ws_proxy.client_sent == [\"test 1\", \"test 2\", \"\"]\n    assert ws_proxy.client_received == [\"test 1\", \"test 2\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "simple_ws_mimic_client"
      ],
      "imports": [
        "base64",
        "secrets",
        "typing.Any",
        "typing.Callable",
        "typing.Coroutine",
        "pytest",
        "websockets.client.WebSocketClientProtocol",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.Websocket"
      ],
      "fixtures": [],
      "assertions": [
        "assert ws_proxy.client_sent == ['test 1', 'test 2', '']",
        "assert ws_proxy.client_received == ['test 1', 'test 2']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "ws.recv",
          "body": "def recv(**kwargs):\n    nonlocal runner\n    nonlocal raw\n    method = raw.recv_until if 'until' in kwargs else raw.recv\n    return runner._run(method(**kwargs))"
        },
        {
          "name": "ws.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        }
      ]
    },
    {
      "name": "test_ws_handler_invalid_upgrade",
      "module": "test_ws_handlers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_ws_handlers.py",
      "line_number": 80,
      "end_line_number": 94,
      "source_code": "def test_ws_handler_invalid_upgrade(app: Sanic):\n    @app.websocket(\"/ws\")\n    async def ws_echo_handler(request: Request, ws: Websocket):\n        async for msg in ws:\n            await ws.send(msg)\n\n    ws_key = base64.b64encode(secrets.token_bytes(16)).decode(\"utf-8\")\n    invalid_upgrade_headers = {\n        \"Upgrade\": \"websocket\",\n        # \"Connection\": \"Upgrade\",\n        \"Sec-WebSocket-Key\": ws_key,\n        \"Sec-WebSocket-Version\": \"13\",\n    }\n    _, response = app.test_client.get(\"/ws\", headers=invalid_upgrade_headers)\n    assert response.status == 426",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "base64",
        "secrets",
        "typing.Any",
        "typing.Callable",
        "typing.Coroutine",
        "pytest",
        "websockets.client.WebSocketClientProtocol",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.Websocket"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 426"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "ws.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        }
      ]
    },
    {
      "name": "test_ws_handler_async_for",
      "module": "test_ws_handlers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_ws_handlers.py",
      "line_number": 97,
      "end_line_number": 110,
      "source_code": "def test_ws_handler_async_for(\n    app: Sanic,\n    simple_ws_mimic_client: MimicClientType,\n):\n    @app.websocket(\"/ws\")\n    async def ws_echo_handler(request: Request, ws: Websocket):\n        async for msg in ws:\n            await ws.send(msg)\n\n    _, ws_proxy = app.test_client.websocket(\n        \"/ws\", mimic=simple_ws_mimic_client\n    )\n    assert ws_proxy.client_sent == [\"test 1\", \"test 2\", \"\"]\n    assert ws_proxy.client_received == [\"test 1\", \"test 2\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "simple_ws_mimic_client"
      ],
      "imports": [
        "base64",
        "secrets",
        "typing.Any",
        "typing.Callable",
        "typing.Coroutine",
        "pytest",
        "websockets.client.WebSocketClientProtocol",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.Websocket"
      ],
      "fixtures": [],
      "assertions": [
        "assert ws_proxy.client_sent == ['test 1', 'test 2', '']",
        "assert ws_proxy.client_received == ['test 1', 'test 2']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "ws.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        }
      ]
    },
    {
      "name": "test_request_url",
      "module": "test_ws_handlers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_ws_handlers.py",
      "line_number": 114,
      "end_line_number": 146,
      "source_code": "def test_request_url(\n    app: Sanic,\n    simple_ws_mimic_client: MimicClientType,\n    proxy: str,\n):\n    @app.websocket(\"/ws\")\n    async def ws_url_handler(request: Request, ws: Websocket):\n        request.headers[\"forwarded\"] = (\n            \"for=[2001:db8::1];proto=https;host=example.com;by=proxy\"\n        )\n\n        await ws.recv()\n        await ws.send(request.url)\n        await ws.recv()\n        await ws.send(request.url_for(\"ws_url_handler\"))\n        await ws.recv()\n\n    app.config.FORWARDED_SECRET = proxy\n    app.config.SERVER_NAME = (\n        \"https://example.com\" if proxy == \"servername\" else \"\"\n    )\n    _, ws_proxy = app.test_client.websocket(\n        \"/ws\",\n        mimic=simple_ws_mimic_client,\n    )\n    assert ws_proxy.client_sent == [\"test 1\", \"test 2\", \"\"]\n    assert ws_proxy.client_received[0] == ws_proxy.client_received[1]\n    if proxy == \"servername\":\n        assert ws_proxy.client_received[0] == \"wss://example.com/ws\"\n        assert ws_proxy.client_received[1] == \"wss://example.com/ws\"\n    else:\n        assert ws_proxy.client_received[0].startswith(\"ws://127.0.0.1\")\n        assert ws_proxy.client_received[1].startswith(\"ws://127.0.0.1\")",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('proxy', ['', 'proxy', 'servername'])"
      ],
      "arguments": [
        "app",
        "simple_ws_mimic_client",
        "proxy"
      ],
      "imports": [
        "base64",
        "secrets",
        "typing.Any",
        "typing.Callable",
        "typing.Coroutine",
        "pytest",
        "websockets.client.WebSocketClientProtocol",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.Websocket"
      ],
      "fixtures": [],
      "assertions": [
        "assert ws_proxy.client_sent == ['test 1', 'test 2', '']",
        "assert ws_proxy.client_received[0] == ws_proxy.client_received[1]",
        "assert ws_proxy.client_received[0] == 'wss://example.com/ws'",
        "assert ws_proxy.client_received[1] == 'wss://example.com/ws'",
        "assert ws_proxy.client_received[0].startswith('ws://127.0.0.1')",
        "assert ws_proxy.client_received[1].startswith('ws://127.0.0.1')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "ws.recv",
          "body": "def recv(**kwargs):\n    nonlocal runner\n    nonlocal raw\n    method = raw.recv_until if 'until' in kwargs else raw.recv\n    return runner._run(method(**kwargs))"
        },
        {
          "name": "ws.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "ws.recv",
          "body": "def recv(**kwargs):\n    nonlocal runner\n    nonlocal raw\n    method = raw.recv_until if 'until' in kwargs else raw.recv\n    return runner._run(method(**kwargs))"
        },
        {
          "name": "ws.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "ws.recv",
          "body": "def recv(**kwargs):\n    nonlocal runner\n    nonlocal raw\n    method = raw.recv_until if 'until' in kwargs else raw.recv\n    return runner._run(method(**kwargs))"
        },
        {
          "name": "request.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_ws_signals",
      "module": "test_ws_handlers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_ws_handlers.py",
      "line_number": 149,
      "end_line_number": 160,
      "source_code": "def test_ws_signals(\n    app: Sanic,\n    simple_ws_mimic_client: MimicClientType,\n):\n    signalapp(app)\n\n    app.ctx.seq = []\n    _, ws_proxy = app.test_client.websocket(\n        \"/ws\", mimic=simple_ws_mimic_client\n    )\n    assert ws_proxy.client_received == [\"before: test 1\", \"after: test 2\"]\n    assert app.ctx.seq == [\"before\", \"ws\", \"after\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "simple_ws_mimic_client"
      ],
      "imports": [
        "base64",
        "secrets",
        "typing.Any",
        "typing.Callable",
        "typing.Coroutine",
        "pytest",
        "websockets.client.WebSocketClientProtocol",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.Websocket"
      ],
      "fixtures": [],
      "assertions": [
        "assert ws_proxy.client_received == ['before: test 1', 'after: test 2']",
        "assert app.ctx.seq == ['before', 'ws', 'after']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "signalapp",
          "body": "def signalapp(app):\n\n    @app.signal('websocket.handler.before')\n    async def ws_before(request: Request, websocket: Websocket):\n        app.ctx.seq.append('before')\n        print('before')\n        await websocket.send('before: ' + await websocket.recv())\n        print('before2')\n\n    @app.signal('websocket.handler.after')\n    async def ws_after(request: Request, websocket: Websocket):\n        app.ctx.seq.append('after')\n        await websocket.send('after: ' + await websocket.recv())\n        await websocket.recv()\n\n    @app.signal('websocket.handler.exception')\n    async def ws_exception(request: Request, websocket: Websocket, exception: Exception):\n        app.ctx.seq.append('exception')\n        await websocket.send(f'exception: {exception}')\n        await websocket.recv()\n\n    @app.websocket('/ws')\n    async def ws_handler(request: Request, ws: Websocket):\n        app.ctx.seq.append('ws')\n\n    @app.websocket('/wserror')\n    async def ws_error(request: Request, ws: Websocket):\n        print('wserr')\n        app.ctx.seq.append('wserror')\n        raise Exception(await ws.recv())\n        print('wserr2')"
        }
      ]
    },
    {
      "name": "test_ws_signals_exception",
      "module": "test_ws_handlers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_ws_handlers.py",
      "line_number": 163,
      "end_line_number": 174,
      "source_code": "def test_ws_signals_exception(\n    app: Sanic,\n    simple_ws_mimic_client: MimicClientType,\n):\n    signalapp(app)\n\n    app.ctx.seq = []\n    _, ws_proxy = app.test_client.websocket(\n        \"/wserror\", mimic=simple_ws_mimic_client\n    )\n    assert ws_proxy.client_received == [\"before: test 1\", \"exception: test 2\"]\n    assert app.ctx.seq == [\"before\", \"wserror\", \"exception\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "simple_ws_mimic_client"
      ],
      "imports": [
        "base64",
        "secrets",
        "typing.Any",
        "typing.Callable",
        "typing.Coroutine",
        "pytest",
        "websockets.client.WebSocketClientProtocol",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.Websocket"
      ],
      "fixtures": [],
      "assertions": [
        "assert ws_proxy.client_received == ['before: test 1', 'exception: test 2']",
        "assert app.ctx.seq == ['before', 'wserror', 'exception']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "signalapp",
          "body": "def signalapp(app):\n\n    @app.signal('websocket.handler.before')\n    async def ws_before(request: Request, websocket: Websocket):\n        app.ctx.seq.append('before')\n        print('before')\n        await websocket.send('before: ' + await websocket.recv())\n        print('before2')\n\n    @app.signal('websocket.handler.after')\n    async def ws_after(request: Request, websocket: Websocket):\n        app.ctx.seq.append('after')\n        await websocket.send('after: ' + await websocket.recv())\n        await websocket.recv()\n\n    @app.signal('websocket.handler.exception')\n    async def ws_exception(request: Request, websocket: Websocket, exception: Exception):\n        app.ctx.seq.append('exception')\n        await websocket.send(f'exception: {exception}')\n        await websocket.recv()\n\n    @app.websocket('/ws')\n    async def ws_handler(request: Request, ws: Websocket):\n        app.ctx.seq.append('ws')\n\n    @app.websocket('/wserror')\n    async def ws_error(request: Request, ws: Websocket):\n        print('wserr')\n        app.ctx.seq.append('wserror')\n        raise Exception(await ws.recv())\n        print('wserr2')"
        }
      ]
    },
    {
      "name": "test_has_message_body",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_helpers.py",
      "line_number": 9,
      "end_line_number": 19,
      "source_code": "def test_has_message_body():\n    tests = (\n        (100, False),\n        (102, False),\n        (204, False),\n        (200, True),\n        (304, False),\n        (400, True),\n    )\n    for status_code, expected in tests:\n        assert helpers.has_message_body(status_code) is expected",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "inspect",
        "pytest",
        "sanic.helpers",
        "sanic.config.Config"
      ],
      "fixtures": [],
      "assertions": [
        "assert helpers.has_message_body(status_code) is expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_is_entity_header",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_helpers.py",
      "line_number": 22,
      "end_line_number": 30,
      "source_code": "def test_is_entity_header():\n    tests = (\n        (\"allow\", True),\n        (\"extension-header\", True),\n        (\"\", False),\n        (\"test\", False),\n    )\n    for header, expected in tests:\n        assert helpers.is_entity_header(header) is expected",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "inspect",
        "pytest",
        "sanic.helpers",
        "sanic.config.Config"
      ],
      "fixtures": [],
      "assertions": [
        "assert helpers.is_entity_header(header) is expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_is_hop_by_hop_header",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_helpers.py",
      "line_number": 33,
      "end_line_number": 41,
      "source_code": "def test_is_hop_by_hop_header():\n    tests = (\n        (\"connection\", True),\n        (\"upgrade\", True),\n        (\"\", False),\n        (\"test\", False),\n    )\n    for header, expected in tests:\n        assert helpers.is_hop_by_hop_header(header) is expected",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "inspect",
        "pytest",
        "sanic.helpers",
        "sanic.config.Config"
      ],
      "fixtures": [],
      "assertions": [
        "assert helpers.is_hop_by_hop_header(header) is expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_import_string_class",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_helpers.py",
      "line_number": 44,
      "end_line_number": 46,
      "source_code": "def test_import_string_class():\n    obj = helpers.import_string(\"sanic.config.Config\")\n    assert isinstance(obj, Config)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "inspect",
        "pytest",
        "sanic.helpers",
        "sanic.config.Config"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(obj, Config)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_import_string_module",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_helpers.py",
      "line_number": 49,
      "end_line_number": 51,
      "source_code": "def test_import_string_module():\n    module = helpers.import_string(\"sanic.config\")\n    assert inspect.ismodule(module)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "inspect",
        "pytest",
        "sanic.helpers",
        "sanic.config.Config"
      ],
      "fixtures": [],
      "assertions": [
        "assert inspect.ismodule(module)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_import_string_exception",
      "module": "test_helpers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_helpers.py",
      "line_number": 54,
      "end_line_number": 56,
      "source_code": "def test_import_string_exception():\n    with pytest.raises(ImportError):\n        helpers.import_string(\"test.test.test\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "inspect",
        "pytest",
        "sanic.helpers",
        "sanic.config.Config"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_vanilla_sanic",
      "module": "test_naming",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_naming.py",
      "line_number": 23,
      "end_line_number": 29,
      "source_code": "def test_vanilla_sanic():\n    app = factory(Sanic, Blueprint)\n    _, foo_response = app.test_client.get(\"/\")\n    _, bar_response = app.test_client.get(\"/bar/\")\n\n    assert foo_response.text == \"Foo.handler\"\n    assert bar_response.text == \"Foo.Bar.handler\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "typing.Type",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert foo_response.text == 'Foo.handler'",
        "assert bar_response.text == 'Foo.Bar.handler'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "factory",
          "body": "def factory(sanic_cls: Type[Sanic], blueprint_cls: Type[Blueprint]):\n    app = sanic_cls('Foo')\n    bp = blueprint_cls('Bar', url_prefix='/bar')\n\n    @app.get('/')\n    async def handler(request):\n        return text(request.name)\n\n    @bp.get('/')\n    async def handler(request):\n        return text(request.name)\n    app.blueprint(bp)\n    return app"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_custom_app",
      "module": "test_naming",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_naming.py",
      "line_number": 32,
      "end_line_number": 43,
      "source_code": "def test_custom_app():\n    class Custom(Sanic):\n        def generate_name(self, *objects):\n            existing = self._generate_name(*objects)\n            return existing.replace(\"Foo\", \"CHANGED_APP\")\n\n    app = factory(Custom, Blueprint)\n    _, foo_response = app.test_client.get(\"/\")\n    _, bar_response = app.test_client.get(\"/bar/\")\n\n    assert foo_response.text == \"CHANGED_APP.handler\"\n    assert bar_response.text == \"CHANGED_APP.Bar.handler\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "typing.Type",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert foo_response.text == 'CHANGED_APP.handler'",
        "assert bar_response.text == 'CHANGED_APP.Bar.handler'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "factory",
          "body": "def factory(sanic_cls: Type[Sanic], blueprint_cls: Type[Blueprint]):\n    app = sanic_cls('Foo')\n    bp = blueprint_cls('Bar', url_prefix='/bar')\n\n    @app.get('/')\n    async def handler(request):\n        return text(request.name)\n\n    @bp.get('/')\n    async def handler(request):\n        return text(request.name)\n    app.blueprint(bp)\n    return app"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_custom_blueprint",
      "module": "test_naming",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_naming.py",
      "line_number": 46,
      "end_line_number": 57,
      "source_code": "def test_custom_blueprint():\n    class Custom(Blueprint):\n        def generate_name(self, *objects):\n            existing = self._generate_name(*objects)\n            return existing.replace(\"Bar\", \"CHANGED_BP\")\n\n    app = factory(Sanic, Custom)\n    _, foo_response = app.test_client.get(\"/\")\n    _, bar_response = app.test_client.get(\"/bar/\")\n\n    assert foo_response.text == \"Foo.handler\"\n    assert bar_response.text == \"Foo.CHANGED_BP.handler\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "typing.Type",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert foo_response.text == 'Foo.handler'",
        "assert bar_response.text == 'Foo.CHANGED_BP.handler'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "factory",
          "body": "def factory(sanic_cls: Type[Sanic], blueprint_cls: Type[Blueprint]):\n    app = sanic_cls('Foo')\n    bp = blueprint_cls('Bar', url_prefix='/bar')\n\n    @app.get('/')\n    async def handler(request):\n        return text(request.name)\n\n    @bp.get('/')\n    async def handler(request):\n        return text(request.name)\n    app.blueprint(bp)\n    return app"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_app_str",
      "module": "test_base",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_base.py",
      "line_number": 17,
      "end_line_number": 18,
      "source_code": "def test_app_str(app):\n    assert str(app) == \"<Sanic my_app>\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.exceptions.SanicException"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(app) == '<Sanic my_app>'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_app_repr",
      "module": "test_base",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_base.py",
      "line_number": 21,
      "end_line_number": 22,
      "source_code": "def test_app_repr(app):\n    assert repr(app) == 'Sanic(name=\"my_app\")'",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.exceptions.SanicException"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(app) == 'Sanic(name=\"my_app\")'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_bp_str",
      "module": "test_base",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_base.py",
      "line_number": 25,
      "end_line_number": 26,
      "source_code": "def test_bp_str(bp):\n    assert str(bp) == \"<Blueprint my_bp>\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "bp"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.exceptions.SanicException"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(bp) == '<Blueprint my_bp>'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_bp_repr",
      "module": "test_base",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_base.py",
      "line_number": 29,
      "end_line_number": 33,
      "source_code": "def test_bp_repr(bp):\n    assert repr(bp) == (\n        'Blueprint(name=\"my_bp\", url_prefix=None, host=None, '\n        \"version=None, strict_slashes=None)\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "bp"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.exceptions.SanicException"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(bp) == 'Blueprint(name=\"my_bp\", url_prefix=None, host=None, version=None, strict_slashes=None)'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_bp_repr_with_values",
      "module": "test_base",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_base.py",
      "line_number": 36,
      "end_line_number": 44,
      "source_code": "def test_bp_repr_with_values(bp):\n    bp.host = \"example.com\"\n    bp.url_prefix = \"/foo\"\n    bp.version = 3\n    bp.strict_slashes = True\n    assert repr(bp) == (\n        'Blueprint(name=\"my_bp\", url_prefix=\"/foo\", host=\"example.com\", '\n        \"version=3, strict_slashes=True)\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "bp"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.exceptions.SanicException"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(bp) == 'Blueprint(name=\"my_bp\", url_prefix=\"/foo\", host=\"example.com\", version=3, strict_slashes=True)'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_names_okay",
      "module": "test_base",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_base.py",
      "line_number": 65,
      "end_line_number": 70,
      "source_code": "def test_names_okay(name):\n    app = Sanic(name)\n    bp = Blueprint(name)\n\n    assert app.name == name\n    assert bp.name == name",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('name', ('something', 'some-thing', 'some_thing', 'Something', 'SomeThing', 'Some-Thing', 'Some_Thing', 'SomeThing123', 'something123', 'some-thing123', 'some_thing123', 'some-Thing123', 'some_Thing123'))"
      ],
      "arguments": [
        "name"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.exceptions.SanicException"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.name == name",
        "assert bp.name == name"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_names_not_okay",
      "module": "test_base",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_base.py",
      "line_number": 81,
      "end_line_number": 97,
      "source_code": "def test_names_not_okay(name):\n    app_message = (\n        f\"Sanic instance named '{name}' uses an invalid format. Names must \"\n        \"begin with a character and may only contain alphanumeric \"\n        \"characters, _, or -.\"\n    )\n    bp_message = (\n        f\"Blueprint instance named '{name}' uses an invalid format. Names \"\n        \"must begin with a character and may only contain alphanumeric \"\n        \"characters, _, or -.\"\n    )\n\n    with pytest.raises(SanicException, match=app_message):\n        Sanic(name)\n\n    with pytest.raises(SanicException, match=bp_message):\n        Blueprint(name)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('name', ('123something', 'some thing', 'something!'))"
      ],
      "arguments": [
        "name"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.exceptions.SanicException"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_change_decoder",
      "module": "test_json_decoding",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_json_decoding.py",
      "line_number": 24,
      "end_line_number": 26,
      "source_code": "def test_change_decoder():\n    Sanic(\"Test\", loads=sloads)\n    assert Request._loads == sloads",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "json.loads",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.json",
        "ujson.loads"
      ],
      "fixtures": [],
      "assertions": [
        "assert Request._loads == sloads"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_change_decoder_to_some_custom",
      "module": "test_json_decoding",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_json_decoding.py",
      "line_number": 29,
      "end_line_number": 46,
      "source_code": "def test_change_decoder_to_some_custom():\n    def my_custom_decoder(some_str: str):\n        dict = sloads(some_str)\n        dict[\"some_key\"] = \"new_value\"\n        return dict\n\n    app = Sanic(\"Test\", loads=my_custom_decoder)\n    assert Request._loads == my_custom_decoder\n\n    req_body = {\"some_key\": \"some_value\"}\n\n    @app.post(\"/test\")\n    def handler(request):\n        new_json = request.json\n        return json(new_json)\n\n    req, res = app.test_client.post(\"/test\", json=req_body)\n    assert sloads(res.body) == {\"some_key\": \"new_value\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "json.loads",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.json",
        "ujson.loads"
      ],
      "fixtures": [],
      "assertions": [
        "assert Request._loads == my_custom_decoder",
        "assert sloads(res.body) == {'some_key': 'new_value'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_default_decoder",
      "module": "test_json_decoding",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_json_decoding.py",
      "line_number": 50,
      "end_line_number": 52,
      "source_code": "def test_default_decoder():\n    Sanic(\"Test\")\n    assert Request._loads == uloads",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(NO_UJSON is True, reason='ujson not installed')"
      ],
      "arguments": [],
      "imports": [
        "json.loads",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.json",
        "ujson.loads"
      ],
      "fixtures": [],
      "assertions": [
        "assert Request._loads == uloads"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_add_register_priority",
      "module": "test_middleware_priority",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware_priority.py",
      "line_number": 43,
      "end_line_number": 53,
      "source_code": "def test_add_register_priority(app: Sanic):\n    def foo(*_): ...\n\n    app.register_middleware(foo, priority=999)\n    assert len(app.request_middleware) == 1\n    assert len(app.response_middleware) == 0\n    assert app.request_middleware[0].priority == 999  # type: ignore\n    app.register_middleware(foo, attach_to=\"response\", priority=999)\n    assert len(app.request_middleware) == 1\n    assert len(app.response_middleware) == 1\n    assert app.response_middleware[0].priority == 999",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "functools.partial",
        "pytest",
        "sanic.Sanic",
        "sanic.middleware.Middleware",
        "sanic.middleware.MiddlewareLocation",
        "sanic.response.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(app.request_middleware) == 1",
        "assert len(app.response_middleware) == 0",
        "assert app.request_middleware[0].priority == 999",
        "assert len(app.request_middleware) == 1",
        "assert len(app.response_middleware) == 1",
        "assert app.response_middleware[0].priority == 999"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_add_register_named_priority",
      "module": "test_middleware_priority",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware_priority.py",
      "line_number": 56,
      "end_line_number": 68,
      "source_code": "def test_add_register_named_priority(app: Sanic):\n    def foo(*_): ...\n\n    app.register_named_middleware(foo, route_names=[\"foo\"], priority=999)\n    assert len(app.named_request_middleware) == 1\n    assert len(app.named_response_middleware) == 0\n    assert app.named_request_middleware[\"foo\"][0].priority == 999  # type: ignore\n    app.register_named_middleware(\n        foo, attach_to=\"response\", route_names=[\"foo\"], priority=999\n    )\n    assert len(app.named_request_middleware) == 1\n    assert len(app.named_response_middleware) == 1\n    assert app.named_response_middleware[\"foo\"][0].priority == 999",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "functools.partial",
        "pytest",
        "sanic.Sanic",
        "sanic.middleware.Middleware",
        "sanic.middleware.MiddlewareLocation",
        "sanic.response.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(app.named_request_middleware) == 1",
        "assert len(app.named_response_middleware) == 0",
        "assert app.named_request_middleware['foo'][0].priority == 999",
        "assert len(app.named_request_middleware) == 1",
        "assert len(app.named_response_middleware) == 1",
        "assert app.named_response_middleware['foo'][0].priority == 999"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_add_decorator_priority",
      "module": "test_middleware_priority",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware_priority.py",
      "line_number": 71,
      "end_line_number": 81,
      "source_code": "def test_add_decorator_priority(app: Sanic):\n    def foo(*_): ...\n\n    app.middleware(foo, priority=999)\n    assert len(app.request_middleware) == 1\n    assert len(app.response_middleware) == 0\n    assert app.request_middleware[0].priority == 999  # type: ignore\n    app.middleware(foo, attach_to=\"response\", priority=999)\n    assert len(app.request_middleware) == 1\n    assert len(app.response_middleware) == 1\n    assert app.response_middleware[0].priority == 999",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "functools.partial",
        "pytest",
        "sanic.Sanic",
        "sanic.middleware.Middleware",
        "sanic.middleware.MiddlewareLocation",
        "sanic.response.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(app.request_middleware) == 1",
        "assert len(app.response_middleware) == 0",
        "assert app.request_middleware[0].priority == 999",
        "assert len(app.request_middleware) == 1",
        "assert len(app.response_middleware) == 1",
        "assert app.response_middleware[0].priority == 999"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_add_convenience_priority",
      "module": "test_middleware_priority",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware_priority.py",
      "line_number": 84,
      "end_line_number": 94,
      "source_code": "def test_add_convenience_priority(app: Sanic):\n    def foo(*_): ...\n\n    app.on_request(foo, priority=999)\n    assert len(app.request_middleware) == 1\n    assert len(app.response_middleware) == 0\n    assert app.request_middleware[0].priority == 999  # type: ignore\n    app.on_response(foo, priority=999)\n    assert len(app.request_middleware) == 1\n    assert len(app.response_middleware) == 1\n    assert app.response_middleware[0].priority == 999",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "functools.partial",
        "pytest",
        "sanic.Sanic",
        "sanic.middleware.Middleware",
        "sanic.middleware.MiddlewareLocation",
        "sanic.response.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(app.request_middleware) == 1",
        "assert len(app.response_middleware) == 0",
        "assert app.request_middleware[0].priority == 999",
        "assert len(app.request_middleware) == 1",
        "assert len(app.response_middleware) == 1",
        "assert app.response_middleware[0].priority == 999"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_add_conflicting_priority",
      "module": "test_middleware_priority",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware_priority.py",
      "line_number": 97,
      "end_line_number": 103,
      "source_code": "def test_add_conflicting_priority(app: Sanic):\n    def foo(*_): ...\n\n    middleware = Middleware(foo, MiddlewareLocation.REQUEST, priority=998)\n    app.register_middleware(middleware=middleware, priority=999)\n    assert app.request_middleware[0].priority == 999  # type: ignore\n    middleware.priority == 998",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "functools.partial",
        "pytest",
        "sanic.Sanic",
        "sanic.middleware.Middleware",
        "sanic.middleware.MiddlewareLocation",
        "sanic.response.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.request_middleware[0].priority == 999"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_add_conflicting_priority_named",
      "module": "test_middleware_priority",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware_priority.py",
      "line_number": 106,
      "end_line_number": 114,
      "source_code": "def test_add_conflicting_priority_named(app: Sanic):\n    def foo(*_): ...\n\n    middleware = Middleware(foo, MiddlewareLocation.REQUEST, priority=998)\n    app.register_named_middleware(\n        middleware=middleware, route_names=[\"foo\"], priority=999\n    )\n    assert app.named_request_middleware[\"foo\"][0].priority == 999  # type: ignore\n    middleware.priority == 998",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "functools.partial",
        "pytest",
        "sanic.Sanic",
        "sanic.middleware.Middleware",
        "sanic.middleware.MiddlewareLocation",
        "sanic.response.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.named_request_middleware['foo'][0].priority == 999"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_request_middleware_order_priority",
      "module": "test_middleware_priority",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware_priority.py",
      "line_number": 121,
      "end_line_number": 139,
      "source_code": "def test_request_middleware_order_priority(app: Sanic, expected, priorities):\n    order = []\n\n    def add_ident(request, ident):\n        order.append(ident)\n\n    @app.get(\"/\")\n    def handler(request):\n        return json(None)\n\n    for ident, priority in enumerate(priorities):\n        kwargs = {}\n        if priority is not None:\n            kwargs[\"priority\"] = priority\n        app.on_request(partial(add_ident, ident=ident), **kwargs)\n\n    app.test_client.get(\"/\")\n\n    assert order == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('expected,priorities', PRIORITY_TEST_CASES)"
      ],
      "arguments": [
        "app",
        "expected",
        "priorities"
      ],
      "imports": [
        "functools.partial",
        "pytest",
        "sanic.Sanic",
        "sanic.middleware.Middleware",
        "sanic.middleware.MiddlewareLocation",
        "sanic.response.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert order == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_response_middleware_order_priority",
      "module": "test_middleware_priority",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_middleware_priority.py",
      "line_number": 146,
      "end_line_number": 164,
      "source_code": "def test_response_middleware_order_priority(app: Sanic, expected, priorities):\n    order = []\n\n    def add_ident(request, response, ident):\n        order.append(ident)\n\n    @app.get(\"/\")\n    def handler(request):\n        return json(None)\n\n    for ident, priority in enumerate(priorities):\n        kwargs = {}\n        if priority is not None:\n            kwargs[\"priority\"] = priority\n        app.on_response(partial(add_ident, ident=ident), **kwargs)\n\n    app.test_client.get(\"/\")\n\n    assert order[::-1] == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('expected,priorities', PRIORITY_TEST_CASES)"
      ],
      "arguments": [
        "app",
        "expected",
        "priorities"
      ],
      "imports": [
        "functools.partial",
        "pytest",
        "sanic.Sanic",
        "sanic.middleware.Middleware",
        "sanic.middleware.MiddlewareLocation",
        "sanic.response.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert order[::-1] == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_bad_request_response",
      "module": "test_bad_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_bad_request.py",
      "line_number": 6,
      "end_line_number": 26,
      "source_code": "def test_bad_request_response(app: Sanic):\n    lines = []\n\n    app.get(\"/\")(lambda x: ...)\n\n    @app.listener(\"after_server_start\")\n    async def _request(sanic, loop):\n        nonlocal lines\n        connect = asyncio.open_connection(\"127.0.0.1\", 42101)\n        reader, writer = await connect\n        writer.write(b\"not http\\r\\n\\r\\n\")\n        while True:\n            line = await reader.readline()\n            if not line:\n                break\n            lines.append(line)\n        app.stop()\n\n    app.run(host=\"127.0.0.1\", port=42101, debug=False, single_process=True)\n    assert lines[0] == b\"HTTP/1.1 400 Bad Request\\r\\n\"\n    assert b\"Bad Request\" in lines[-2]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "sanic.Sanic"
      ],
      "fixtures": [],
      "assertions": [
        "assert lines[0] == b'HTTP/1.1 400 Bad Request\\r\\n'",
        "assert b'Bad Request' in lines[-2]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        }
      ]
    },
    {
      "name": "test_unix_socket_creation",
      "module": "test_unix_socket",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_unix_socket.py",
      "line_number": 60,
      "end_line_number": 84,
      "source_code": "def test_unix_socket_creation(caplog: LogCaptureFixture):\n    from socket import AF_UNIX, socket\n\n    with socket(AF_UNIX) as sock:\n        sock.bind(SOCKPATH)\n    assert os.path.exists(SOCKPATH)\n    ino = os.stat(SOCKPATH).st_ino\n\n    app = Sanic(name=\"test\")\n\n    @app.after_server_start\n    def running(app: Sanic):\n        assert os.path.exists(SOCKPATH)\n        assert ino != os.stat(SOCKPATH).st_ino\n        app.stop()\n\n    with caplog.at_level(logging.INFO):\n        app.run(unix=SOCKPATH, single_process=True)\n\n    assert (\n        \"sanic.root\",\n        logging.INFO,\n        f\"Goin' Fast @ {SOCKPATH} http://...\",\n    ) in caplog.record_tuples\n    assert not os.path.exists(SOCKPATH)",
      "docstring": null,
      "decorators": [
        "pytest.mark.xfail(reason='Flaky Test on Non Linux Infra')"
      ],
      "arguments": [
        "caplog"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "asyncio.AbstractEventLoop",
        "asyncio.sleep",
        "pathlib.Path",
        "string.ascii_lowercase",
        "httpcore",
        "httpx",
        "pytest",
        "pytest.LogCaptureFixture",
        "sanic.Sanic",
        "sanic.compat.use_context",
        "sanic.request.Request",
        "sanic.response.text",
        "socket.AF_UNIX",
        "socket.socket",
        "socket.AF_UNIX",
        "socket.socket"
      ],
      "fixtures": [],
      "assertions": [
        "assert os.path.exists(SOCKPATH)",
        "assert ('sanic.root', logging.INFO, f\"Goin' Fast @ {SOCKPATH} http://...\") in caplog.record_tuples",
        "assert not os.path.exists(SOCKPATH)",
        "assert os.path.exists(SOCKPATH)",
        "assert ino != os.stat(SOCKPATH).st_ino"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        },
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ]
    },
    {
      "name": "test_invalid_paths",
      "module": "test_unix_socket",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_unix_socket.py",
      "line_number": 88,
      "end_line_number": 92,
      "source_code": "def test_invalid_paths(path: str):\n    app = Sanic(name=\"test\")\n    #\n    with pytest.raises((FileExistsError, FileNotFoundError)):\n        app.run(unix=path, single_process=True)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('path', ('.', 'no-such-directory/sanictest.sock'))"
      ],
      "arguments": [
        "path"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "asyncio.AbstractEventLoop",
        "asyncio.sleep",
        "pathlib.Path",
        "string.ascii_lowercase",
        "httpcore",
        "httpx",
        "pytest",
        "pytest.LogCaptureFixture",
        "sanic.Sanic",
        "sanic.compat.use_context",
        "sanic.request.Request",
        "sanic.response.text",
        "socket.AF_UNIX",
        "socket.socket",
        "socket.AF_UNIX",
        "socket.socket"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ]
    },
    {
      "name": "test_dont_replace_file",
      "module": "test_unix_socket",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_unix_socket.py",
      "line_number": 95,
      "end_line_number": 105,
      "source_code": "def test_dont_replace_file():\n    SOCKPATH.write_text(\"File, not socket\")\n\n    app = Sanic(name=\"test\")\n\n    @app.after_server_start\n    def stop(app: Sanic):\n        app.stop()\n\n    with pytest.raises(FileExistsError):\n        app.run(unix=SOCKPATH, single_process=True)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "os",
        "sys",
        "asyncio.AbstractEventLoop",
        "asyncio.sleep",
        "pathlib.Path",
        "string.ascii_lowercase",
        "httpcore",
        "httpx",
        "pytest",
        "pytest.LogCaptureFixture",
        "sanic.Sanic",
        "sanic.compat.use_context",
        "sanic.request.Request",
        "sanic.response.text",
        "socket.AF_UNIX",
        "socket.socket",
        "socket.AF_UNIX",
        "socket.socket"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        },
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ]
    },
    {
      "name": "test_dont_follow_symlink",
      "module": "test_unix_socket",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_unix_socket.py",
      "line_number": 108,
      "end_line_number": 122,
      "source_code": "def test_dont_follow_symlink():\n    from socket import AF_UNIX, socket\n\n    with socket(AF_UNIX) as sock:\n        sock.bind(SOCKPATH2)\n    os.symlink(SOCKPATH2, SOCKPATH)\n\n    app = Sanic(name=\"test\")\n\n    @app.after_server_start\n    def stop(app: Sanic):\n        app.stop()\n\n    with pytest.raises(FileExistsError):\n        app.run(unix=SOCKPATH, single_process=True)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "os",
        "sys",
        "asyncio.AbstractEventLoop",
        "asyncio.sleep",
        "pathlib.Path",
        "string.ascii_lowercase",
        "httpcore",
        "httpx",
        "pytest",
        "pytest.LogCaptureFixture",
        "sanic.Sanic",
        "sanic.compat.use_context",
        "sanic.request.Request",
        "sanic.response.text",
        "socket.AF_UNIX",
        "socket.socket",
        "socket.AF_UNIX",
        "socket.socket"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        },
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ]
    },
    {
      "name": "test_socket_deleted_while_running",
      "module": "test_unix_socket",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_unix_socket.py",
      "line_number": 125,
      "end_line_number": 133,
      "source_code": "def test_socket_deleted_while_running():\n    app = Sanic(name=\"test\")\n\n    @app.after_server_start\n    async def hack(app: Sanic):\n        os.unlink(SOCKPATH)\n        app.stop()\n\n    app.run(host=\"myhost.invalid\", unix=SOCKPATH, single_process=True)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "os",
        "sys",
        "asyncio.AbstractEventLoop",
        "asyncio.sleep",
        "pathlib.Path",
        "string.ascii_lowercase",
        "httpcore",
        "httpx",
        "pytest",
        "pytest.LogCaptureFixture",
        "sanic.Sanic",
        "sanic.compat.use_context",
        "sanic.request.Request",
        "sanic.response.text",
        "socket.AF_UNIX",
        "socket.socket",
        "socket.AF_UNIX",
        "socket.socket"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        }
      ]
    },
    {
      "name": "test_socket_replaced_with_file",
      "module": "test_unix_socket",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_unix_socket.py",
      "line_number": 136,
      "end_line_number": 146,
      "source_code": "def test_socket_replaced_with_file():\n    app = Sanic(name=\"test\")\n\n    @app.after_server_start\n    async def hack(app: Sanic):\n        os.unlink(SOCKPATH)\n        with open(SOCKPATH, \"w\") as f:\n            f.write(\"Not a socket\")\n        app.stop()\n\n    app.run(host=\"myhost.invalid\", unix=SOCKPATH, single_process=True)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "os",
        "sys",
        "asyncio.AbstractEventLoop",
        "asyncio.sleep",
        "pathlib.Path",
        "string.ascii_lowercase",
        "httpcore",
        "httpx",
        "pytest",
        "pytest.LogCaptureFixture",
        "sanic.Sanic",
        "sanic.compat.use_context",
        "sanic.request.Request",
        "sanic.response.text",
        "socket.AF_UNIX",
        "socket.socket",
        "socket.AF_UNIX",
        "socket.socket"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        }
      ]
    },
    {
      "name": "test_unix_connection",
      "module": "test_unix_socket",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_unix_socket.py",
      "line_number": 149,
      "end_line_number": 170,
      "source_code": "def test_unix_connection():\n    app = Sanic(name=\"test\")\n\n    @app.get(\"/\")\n    def handler(request: Request):\n        return text(f\"{request.conn_info.server}\")\n\n    @app.after_server_start\n    async def client(app: Sanic):\n        if httpx_version >= (0, 20):\n            transport = httpx.AsyncHTTPTransport(uds=SOCKPATH)\n        else:\n            transport = httpcore.AsyncConnectionPool(uds=SOCKPATH)\n        try:\n            async with httpx.AsyncClient(transport=transport) as client:\n                r = await client.get(\"http://myhost.invalid/\")\n                assert r.status_code == 200\n                assert r.text == os.path.abspath(SOCKPATH)\n        finally:\n            app.stop()\n\n    app.run(host=\"myhost.invalid\", unix=SOCKPATH, single_process=True)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "os",
        "sys",
        "asyncio.AbstractEventLoop",
        "asyncio.sleep",
        "pathlib.Path",
        "string.ascii_lowercase",
        "httpcore",
        "httpx",
        "pytest",
        "pytest.LogCaptureFixture",
        "sanic.Sanic",
        "sanic.compat.use_context",
        "sanic.request.Request",
        "sanic.response.text",
        "socket.AF_UNIX",
        "socket.socket",
        "socket.AF_UNIX",
        "socket.socket"
      ],
      "fixtures": [],
      "assertions": [
        "assert r.status_code == 200",
        "assert r.text == os.path.abspath(SOCKPATH)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        },
        {
          "name": "client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_unix_connection_multiple_workers",
      "module": "test_unix_socket",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_unix_socket.py",
      "line_number": 193,
      "end_line_number": 198,
      "source_code": "def test_unix_connection_multiple_workers():\n    with use_context(\"fork\"):\n        app_multi = Sanic(name=\"test\")\n        app_multi.get(\"/\")(handler)\n        app_multi.listener(\"after_server_start\")(client)\n        app_multi.run(host=\"myhost.invalid\", unix=SOCKPATH, workers=2)",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(sys.platform not in ('linux', 'darwin'), reason='This test requires fork context')"
      ],
      "arguments": [],
      "imports": [
        "logging",
        "os",
        "sys",
        "asyncio.AbstractEventLoop",
        "asyncio.sleep",
        "pathlib.Path",
        "string.ascii_lowercase",
        "httpcore",
        "httpx",
        "pytest",
        "pytest.LogCaptureFixture",
        "sanic.Sanic",
        "sanic.compat.use_context",
        "sanic.request.Request",
        "sanic.response.text",
        "socket.AF_UNIX",
        "socket.socket",
        "socket.AF_UNIX",
        "socket.socket"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app_multi.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "app_multi.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_listeners_triggered",
      "module": "test_asgi",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_asgi.py",
      "line_number": 65,
      "end_line_number": 163,
      "source_code": "def test_listeners_triggered(caplog):\n    app = Sanic(\"app\")\n    before_server_start = False\n    after_server_start = False\n    before_server_stop = False\n    after_server_stop = False\n\n    @app.listener(\"before_server_start\")\n    def do_before_server_start(*args, **kwargs):\n        nonlocal before_server_start\n        before_server_start = True\n\n    @app.listener(\"after_server_start\")\n    def do_after_server_start(*args, **kwargs):\n        nonlocal after_server_start\n        after_server_start = True\n\n    @app.listener(\"before_server_stop\")\n    def do_before_server_stop(*args, **kwargs):\n        nonlocal before_server_stop\n        before_server_stop = True\n\n    @app.listener(\"after_server_stop\")\n    def do_after_server_stop(*args, **kwargs):\n        nonlocal after_server_stop\n        after_server_stop = True\n\n    @app.route(\"/\")\n    def handler(request):\n        return text(\"...\")\n\n    class CustomServer(uvicorn.Server):\n        def install_signal_handlers(self):\n            pass\n\n    config = uvicorn.Config(\n        app=app, loop=\"asyncio\", limit_max_requests=0, port=get_port()\n    )\n    server = CustomServer(config=config)\n\n    start_message = (\n        'You have set a listener for \"before_server_start\" in ASGI mode. '\n        \"It will be executed as early as possible, but not before the ASGI \"\n        \"server is started.\"\n    )\n    stop_message = (\n        'You have set a listener for \"after_server_stop\" in ASGI mode. '\n        \"It will be executed as late as possible, but not after the ASGI \"\n        \"server is stopped.\"\n    )\n\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    assert before_server_start\n    assert after_server_start\n    assert before_server_stop\n    assert after_server_stop\n\n    app.state.mode = Mode.DEBUG\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    app.state.verbosity = 2\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) in caplog.record_tuples",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "caplog"
      ],
      "imports": [
        "asyncio",
        "logging",
        "collections.deque",
        "collections.namedtuple",
        "unittest.mock.call",
        "pytest",
        "uvicorn",
        "httpx.Headers",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.application.state.Mode",
        "sanic.asgi.Lifespan",
        "sanic.asgi.MockTransport",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.ServiceUnavailable",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.server.websockets.connection.WebSocketConnection",
        "sanic.signals.RESERVED_NAMESPACES",
        "conftest.get_port",
        "unittest.mock.AsyncMock",
        "tests.asyncmock.AsyncMock"
      ],
      "fixtures": [],
      "assertions": [
        "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
        "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
        "assert before_server_start",
        "assert after_server_start",
        "assert before_server_stop",
        "assert after_server_stop",
        "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
        "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
        "assert ('sanic.root', logging.DEBUG, start_message) in caplog.record_tuples",
        "assert ('sanic.root', logging.DEBUG, stop_message) in caplog.record_tuples"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "server.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "server.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "server.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "get_port",
          "body": "def get_port():\n    sock = socket.socket()\n    sock.bind(('', 0))\n    return sock.getsockname()[1]"
        }
      ]
    },
    {
      "name": "test_listeners_triggered_async",
      "module": "test_asgi",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_asgi.py",
      "line_number": 166,
      "end_line_number": 264,
      "source_code": "def test_listeners_triggered_async(app, caplog):\n    before_server_start = False\n    after_server_start = False\n    before_server_stop = False\n    after_server_stop = False\n\n    @app.listener(\"before_server_start\")\n    async def do_before_server_start(*args, **kwargs):\n        nonlocal before_server_start\n        before_server_start = True\n\n    @app.listener(\"after_server_start\")\n    async def do_after_server_start(*args, **kwargs):\n        nonlocal after_server_start\n        after_server_start = True\n\n    @app.listener(\"before_server_stop\")\n    async def do_before_server_stop(*args, **kwargs):\n        nonlocal before_server_stop\n        before_server_stop = True\n\n    @app.listener(\"after_server_stop\")\n    async def do_after_server_stop(*args, **kwargs):\n        nonlocal after_server_stop\n        after_server_stop = True\n\n    @app.route(\"/\")\n    def handler(request):\n        return text(\"...\")\n\n    class CustomServer(uvicorn.Server):\n        def install_signal_handlers(self):\n            pass\n\n    config = uvicorn.Config(\n        app=app, loop=\"asyncio\", limit_max_requests=0, port=get_port()\n    )\n    server = CustomServer(config=config)\n\n    start_message = (\n        'You have set a listener for \"before_server_start\" in ASGI mode. '\n        \"It will be executed as early as possible, but not before the ASGI \"\n        \"server is started.\"\n    )\n    stop_message = (\n        'You have set a listener for \"after_server_stop\" in ASGI mode. '\n        \"It will be executed as late as possible, but not after the ASGI \"\n        \"server is stopped.\"\n    )\n\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    assert before_server_start\n    assert after_server_start\n    assert before_server_stop\n    assert after_server_stop\n\n    app.state.mode = Mode.DEBUG\n    app.state.verbosity = 0\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    app.state.verbosity = 2\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) in caplog.record_tuples",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "caplog"
      ],
      "imports": [
        "asyncio",
        "logging",
        "collections.deque",
        "collections.namedtuple",
        "unittest.mock.call",
        "pytest",
        "uvicorn",
        "httpx.Headers",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.application.state.Mode",
        "sanic.asgi.Lifespan",
        "sanic.asgi.MockTransport",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.ServiceUnavailable",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.server.websockets.connection.WebSocketConnection",
        "sanic.signals.RESERVED_NAMESPACES",
        "conftest.get_port",
        "unittest.mock.AsyncMock",
        "tests.asyncmock.AsyncMock"
      ],
      "fixtures": [],
      "assertions": [
        "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
        "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
        "assert before_server_start",
        "assert after_server_start",
        "assert before_server_stop",
        "assert after_server_stop",
        "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
        "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
        "assert ('sanic.root', logging.DEBUG, start_message) in caplog.record_tuples",
        "assert ('sanic.root', logging.DEBUG, stop_message) in caplog.record_tuples"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "server.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "server.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "server.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "get_port",
          "body": "def get_port():\n    sock = socket.socket()\n    sock.bind(('', 0))\n    return sock.getsockname()[1]"
        }
      ]
    },
    {
      "name": "test_non_default_uvloop_config_raises_warning",
      "module": "test_asgi",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_asgi.py",
      "line_number": 267,
      "end_line_number": 293,
      "source_code": "def test_non_default_uvloop_config_raises_warning(app):\n    app.config.USE_UVLOOP = True\n\n    class CustomServer(uvicorn.Server):\n        def install_signal_handlers(self):\n            pass\n\n    config = uvicorn.Config(\n        app=app, loop=\"asyncio\", limit_max_requests=0, port=get_port()\n    )\n    server = CustomServer(config=config)\n\n    with pytest.warns(UserWarning) as records:\n        server.run()\n\n    msg = \"\"\n    for record in records:\n        _msg = str(record.message)\n        if _msg.startswith(\"You have set the USE_UVLOOP configuration\"):\n            msg = _msg\n            break\n\n    assert msg == (\n        \"You have set the USE_UVLOOP configuration option, but Sanic \"\n        \"cannot control the event loop when running in ASGI mode.\"\n        \"This option will be ignored.\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "collections.deque",
        "collections.namedtuple",
        "unittest.mock.call",
        "pytest",
        "uvicorn",
        "httpx.Headers",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.application.state.Mode",
        "sanic.asgi.Lifespan",
        "sanic.asgi.MockTransport",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.ServiceUnavailable",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.server.websockets.connection.WebSocketConnection",
        "sanic.signals.RESERVED_NAMESPACES",
        "conftest.get_port",
        "unittest.mock.AsyncMock",
        "tests.asyncmock.AsyncMock"
      ],
      "fixtures": [],
      "assertions": [
        "assert msg == 'You have set the USE_UVLOOP configuration option, but Sanic cannot control the event loop when running in ASGI mode.This option will be ignored.'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "server.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "get_port",
          "body": "def get_port():\n    sock = socket.socket()\n    sock.bind(('', 0))\n    return sock.getsockname()[1]"
        }
      ]
    },
    {
      "name": "test_improper_websocket_connection",
      "module": "test_asgi",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_asgi.py",
      "line_number": 416,
      "end_line_number": 422,
      "source_code": "def test_improper_websocket_connection(transport, send, receive):\n    with pytest.raises(BadRequest):\n        transport.get_websocket_connection()\n\n    transport.create_websocket_connection(send, receive)\n    connection = transport.get_websocket_connection()\n    assert isinstance(connection, WebSocketConnection)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "transport",
        "send",
        "receive"
      ],
      "imports": [
        "asyncio",
        "logging",
        "collections.deque",
        "collections.namedtuple",
        "unittest.mock.call",
        "pytest",
        "uvicorn",
        "httpx.Headers",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.application.state.Mode",
        "sanic.asgi.Lifespan",
        "sanic.asgi.MockTransport",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.ServiceUnavailable",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.server.websockets.connection.WebSocketConnection",
        "sanic.signals.RESERVED_NAMESPACES",
        "conftest.get_port",
        "unittest.mock.AsyncMock",
        "tests.asyncmock.AsyncMock"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(connection, WebSocketConnection)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_static_file",
      "module": "test_url_for_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_for_static.py",
      "line_number": 37,
      "end_line_number": 118,
      "source_code": "def test_static_file(static_file_directory, file_name):\n    app = Sanic(\"qq\")\n    app.static(\n        \"/testing.file\", get_file_path(static_file_directory, file_name)\n    )\n    app.static(\n        \"/testing2.file\",\n        get_file_path(static_file_directory, file_name),\n        name=\"testing_file\",\n    )\n\n    app.router.finalize()\n\n    uri = app.url_for(\"static\")\n    uri2 = app.url_for(\"static\", filename=\"any\")\n    uri3 = app.url_for(\"static\", name=\"static\", filename=\"any\")\n\n    assert uri == \"/testing.file\"\n    assert uri == uri2\n    assert uri2 == uri3\n\n    app.router.reset()\n\n    request, response = app.test_client.get(uri)\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, file_name)\n\n    app.router.reset()\n\n    bp = Blueprint(\"test_bp_static\", url_prefix=\"/bp\")\n\n    bp.static(\"/testing.file\", get_file_path(static_file_directory, file_name))\n    bp.static(\n        \"/testing2.file\",\n        get_file_path(static_file_directory, file_name),\n        name=\"testing_file\",\n    )\n\n    app.blueprint(bp)\n\n    uris = [\n        app.url_for(\"static\", name=\"test_bp_static.static\"),\n        app.url_for(\"static\", name=\"test_bp_static.static\", filename=\"any\"),\n        app.url_for(\"test_bp_static.static\"),\n        app.url_for(\"test_bp_static.static\", filename=\"any\"),\n    ]\n\n    assert all(uri == \"/bp/testing.file\" for uri in uris)\n\n    request, response = app.test_client.get(uri)\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, file_name)\n\n    # test for other parameters\n    uri = app.url_for(\"static\", _external=True, _server=\"http://localhost\")\n    assert uri == \"http://localhost/testing.file\"\n\n    uri = app.url_for(\n        \"static\",\n        name=\"test_bp_static.static\",\n        _external=True,\n        _server=\"http://localhost\",\n    )\n    assert uri == \"http://localhost/bp/testing.file\"\n\n    # test for defined name\n    uri = app.url_for(\"static\", name=\"testing_file\")\n    assert uri == \"/testing2.file\"\n\n    request, response = app.test_client.get(uri)\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, file_name)\n\n    uri = app.url_for(\"static\", name=\"test_bp_static.testing_file\")\n    assert uri == \"/bp/testing2.file\"\n    assert uri == app.url_for(\n        \"static\", name=\"test_bp_static.testing_file\", filename=\"any\"\n    )\n\n    request, response = app.test_client.get(uri)\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, file_name)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt', 'python.png'])"
      ],
      "arguments": [
        "static_file_directory",
        "file_name"
      ],
      "imports": [
        "inspect",
        "os",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint"
      ],
      "fixtures": [],
      "assertions": [
        "assert uri == '/testing.file'",
        "assert uri == uri2",
        "assert uri2 == uri3",
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, file_name)",
        "assert all((uri == '/bp/testing.file' for uri in uris))",
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, file_name)",
        "assert uri == 'http://localhost/testing.file'",
        "assert uri == 'http://localhost/bp/testing.file'",
        "assert uri == '/testing2.file'",
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, file_name)",
        "assert uri == '/bp/testing2.file'",
        "assert uri == app.url_for('static', name='test_bp_static.testing_file', filename='any')",
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, file_name)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.router.reset",
          "body": "@pytest.fixture(autouse=True)\ndef reset():\n    try:\n        del os.environ['SANIC_MOTD_OUTPUT']\n    except KeyError:\n        ..."
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.router.reset",
          "body": "@pytest.fixture(autouse=True)\ndef reset():\n    try:\n        del os.environ['SANIC_MOTD_OUTPUT']\n    except KeyError:\n        ..."
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ]
    },
    {
      "name": "test_static_directory",
      "module": "test_url_for_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_for_static.py",
      "line_number": 123,
      "end_line_number": 180,
      "source_code": "def test_static_directory(file_name, base_uri, static_file_directory):\n    app = Sanic(\"base\")\n\n    app.static(base_uri, static_file_directory)\n    base_uri2 = base_uri + \"/2\"\n    app.static(base_uri2, static_file_directory, name=\"uploads\")\n\n    uri = app.url_for(\"static\", name=\"static\", filename=file_name)\n    assert uri == f\"{base_uri}/{file_name}\"\n\n    request, response = app.test_client.get(uri)\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, file_name)\n\n    uri2 = app.url_for(\"static\", name=\"static\", filename=\"/\" + file_name)\n    uri3 = app.url_for(\"static\", filename=file_name)\n    uri4 = app.url_for(\"static\", filename=\"/\" + file_name)\n    uri5 = app.url_for(\"static\", name=\"uploads\", filename=file_name)\n    uri6 = app.url_for(\"static\", name=\"uploads\", filename=\"/\" + file_name)\n\n    assert uri == uri2\n    assert uri2 == uri3\n    assert uri3 == uri4\n\n    assert uri5 == f\"{base_uri2}/{file_name}\"\n    assert uri5 == uri6\n\n    bp = Blueprint(\"test_bp_static\", url_prefix=\"/bp\")\n\n    bp.static(base_uri, static_file_directory)\n    bp.static(base_uri2, static_file_directory, name=\"uploads\")\n\n    app.router.reset()\n    app.blueprint(bp)\n\n    uri = app.url_for(\n        \"static\", name=\"test_bp_static.static\", filename=file_name\n    )\n    uri2 = app.url_for(\n        \"static\", name=\"test_bp_static.static\", filename=\"/\" + file_name\n    )\n\n    uri4 = app.url_for(\n        \"static\", name=\"test_bp_static.uploads\", filename=file_name\n    )\n    uri5 = app.url_for(\n        \"static\", name=\"test_bp_static.uploads\", filename=\"/\" + file_name\n    )\n\n    assert uri == f\"/bp{base_uri}/{file_name}\"\n    assert uri == uri2\n\n    assert uri4 == f\"/bp{base_uri2}/{file_name}\"\n    assert uri4 == uri5\n\n    request, response = app.test_client.get(uri)\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, file_name)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt'])",
        "pytest.mark.parametrize('base_uri', ['/static', '', '/dir'])"
      ],
      "arguments": [
        "file_name",
        "base_uri",
        "static_file_directory"
      ],
      "imports": [
        "inspect",
        "os",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint"
      ],
      "fixtures": [],
      "assertions": [
        "assert uri == f'{base_uri}/{file_name}'",
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, file_name)",
        "assert uri == uri2",
        "assert uri2 == uri3",
        "assert uri3 == uri4",
        "assert uri5 == f'{base_uri2}/{file_name}'",
        "assert uri5 == uri6",
        "assert uri == f'/bp{base_uri}/{file_name}'",
        "assert uri == uri2",
        "assert uri4 == f'/bp{base_uri2}/{file_name}'",
        "assert uri4 == uri5",
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, file_name)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.router.reset",
          "body": "@pytest.fixture(autouse=True)\ndef reset():\n    try:\n        del os.environ['SANIC_MOTD_OUTPUT']\n    except KeyError:\n        ..."
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ]
    },
    {
      "name": "test_static_head_request",
      "module": "test_url_for_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_for_static.py",
      "line_number": 184,
      "end_line_number": 226,
      "source_code": "def test_static_head_request(file_name, static_file_directory):\n    app = Sanic(\"base\")\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n\n    bp = Blueprint(\"test_bp_static\", url_prefix=\"/bp\")\n    bp.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n    app.blueprint(bp)\n\n    uri = app.url_for(\"static\")\n    assert uri == \"/testing.file\"\n    assert uri == app.url_for(\"static\", name=\"static\")\n    assert uri == app.url_for(\"static\", name=\"static\", filename=\"any\")\n\n    request, response = app.test_client.head(uri)\n    assert response.status == 200\n    assert \"Accept-Ranges\" in response.headers\n    assert \"Content-Length\" in response.headers\n    assert int(response.headers[\"Content-Length\"]) == len(\n        get_file_content(static_file_directory, file_name)\n    )\n\n    # blueprint\n    uri = app.url_for(\"static\", name=\"test_bp_static.static\")\n    assert uri == \"/bp/testing.file\"\n    assert uri == app.url_for(\n        \"static\", name=\"test_bp_static.static\", filename=\"any\"\n    )\n\n    request, response = app.test_client.head(uri)\n    assert response.status == 200\n    assert \"Accept-Ranges\" in response.headers\n    assert \"Content-Length\" in response.headers\n    assert int(response.headers[\"Content-Length\"]) == len(\n        get_file_content(static_file_directory, file_name)\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt'])"
      ],
      "arguments": [
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "inspect",
        "os",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint"
      ],
      "fixtures": [],
      "assertions": [
        "assert uri == '/testing.file'",
        "assert uri == app.url_for('static', name='static')",
        "assert uri == app.url_for('static', name='static', filename='any')",
        "assert response.status == 200",
        "assert 'Accept-Ranges' in response.headers",
        "assert 'Content-Length' in response.headers",
        "assert int(response.headers['Content-Length']) == len(get_file_content(static_file_directory, file_name))",
        "assert uri == '/bp/testing.file'",
        "assert uri == app.url_for('static', name='test_bp_static.static', filename='any')",
        "assert response.status == 200",
        "assert 'Accept-Ranges' in response.headers",
        "assert 'Content-Length' in response.headers",
        "assert int(response.headers['Content-Length']) == len(get_file_content(static_file_directory, file_name))"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.head",
          "body": "def head(self, request):\n    return text('', headers={'method': 'HEAD'})"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.head",
          "body": "def head(self, request):\n    return text('', headers={'method': 'HEAD'})"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ]
    },
    {
      "name": "test_static_content_range_correct",
      "module": "test_url_for_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_for_static.py",
      "line_number": 230,
      "end_line_number": 278,
      "source_code": "def test_static_content_range_correct(file_name, static_file_directory):\n    app = Sanic(\"base\")\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n\n    bp = Blueprint(\"test_bp_static\", url_prefix=\"/bp\")\n    bp.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n    app.blueprint(bp)\n\n    headers = {\"Range\": \"bytes=12-19\"}\n    uri = app.url_for(\"static\")\n    assert uri == \"/testing.file\"\n    assert uri == app.url_for(\"static\", name=\"static\")\n    assert uri == app.url_for(\"static\", name=\"static\", filename=\"any\")\n\n    request, response = app.test_client.get(uri, headers=headers)\n    assert response.status == 206\n    assert \"Content-Length\" in response.headers\n    assert \"Content-Range\" in response.headers\n    static_content = bytes(get_file_content(static_file_directory, file_name))[\n        12:20\n    ]\n    assert int(response.headers[\"Content-Length\"]) == len(static_content)\n    assert response.body == static_content\n\n    # blueprint\n    uri = app.url_for(\"static\", name=\"test_bp_static.static\")\n    assert uri == \"/bp/testing.file\"\n    assert uri == app.url_for(\n        \"static\", name=\"test_bp_static.static\", filename=\"any\"\n    )\n    assert uri == app.url_for(\"test_bp_static.static\")\n\n    request, response = app.test_client.get(uri, headers=headers)\n    assert response.status == 206\n    assert \"Content-Length\" in response.headers\n    assert \"Content-Range\" in response.headers\n    static_content = bytes(get_file_content(static_file_directory, file_name))[\n        12:20\n    ]\n    assert int(response.headers[\"Content-Length\"]) == len(static_content)\n    assert response.body == static_content",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt'])"
      ],
      "arguments": [
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "inspect",
        "os",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint"
      ],
      "fixtures": [],
      "assertions": [
        "assert uri == '/testing.file'",
        "assert uri == app.url_for('static', name='static')",
        "assert uri == app.url_for('static', name='static', filename='any')",
        "assert response.status == 206",
        "assert 'Content-Length' in response.headers",
        "assert 'Content-Range' in response.headers",
        "assert int(response.headers['Content-Length']) == len(static_content)",
        "assert response.body == static_content",
        "assert uri == '/bp/testing.file'",
        "assert uri == app.url_for('static', name='test_bp_static.static', filename='any')",
        "assert uri == app.url_for('test_bp_static.static')",
        "assert response.status == 206",
        "assert 'Content-Length' in response.headers",
        "assert 'Content-Range' in response.headers",
        "assert int(response.headers['Content-Length']) == len(static_content)",
        "assert response.body == static_content"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ]
    },
    {
      "name": "test_static_content_range_front",
      "module": "test_url_for_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_for_static.py",
      "line_number": 282,
      "end_line_number": 331,
      "source_code": "def test_static_content_range_front(file_name, static_file_directory):\n    app = Sanic(\"base\")\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n\n    bp = Blueprint(\"test_bp_static\", url_prefix=\"/bp\")\n    bp.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n    app.blueprint(bp)\n\n    headers = {\"Range\": \"bytes=12-\"}\n    uri = app.url_for(\"static\")\n    assert uri == \"/testing.file\"\n    assert uri == app.url_for(\"static\", name=\"static\")\n    assert uri == app.url_for(\"static\", name=\"static\", filename=\"any\")\n\n    request, response = app.test_client.get(uri, headers=headers)\n    assert response.status == 206\n    assert \"Content-Length\" in response.headers\n    assert \"Content-Range\" in response.headers\n    static_content = bytes(get_file_content(static_file_directory, file_name))[\n        12:\n    ]\n    assert int(response.headers[\"Content-Length\"]) == len(static_content)\n    assert response.body == static_content\n\n    # blueprint\n    uri = app.url_for(\"static\", name=\"test_bp_static.static\")\n    assert uri == \"/bp/testing.file\"\n    assert uri == app.url_for(\n        \"static\", name=\"test_bp_static.static\", filename=\"any\"\n    )\n    assert uri == app.url_for(\"test_bp_static.static\")\n    assert uri == app.url_for(\"test_bp_static.static\", filename=\"any\")\n\n    request, response = app.test_client.get(uri, headers=headers)\n    assert response.status == 206\n    assert \"Content-Length\" in response.headers\n    assert \"Content-Range\" in response.headers\n    static_content = bytes(get_file_content(static_file_directory, file_name))[\n        12:\n    ]\n    assert int(response.headers[\"Content-Length\"]) == len(static_content)\n    assert response.body == static_content",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt'])"
      ],
      "arguments": [
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "inspect",
        "os",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint"
      ],
      "fixtures": [],
      "assertions": [
        "assert uri == '/testing.file'",
        "assert uri == app.url_for('static', name='static')",
        "assert uri == app.url_for('static', name='static', filename='any')",
        "assert response.status == 206",
        "assert 'Content-Length' in response.headers",
        "assert 'Content-Range' in response.headers",
        "assert int(response.headers['Content-Length']) == len(static_content)",
        "assert response.body == static_content",
        "assert uri == '/bp/testing.file'",
        "assert uri == app.url_for('static', name='test_bp_static.static', filename='any')",
        "assert uri == app.url_for('test_bp_static.static')",
        "assert uri == app.url_for('test_bp_static.static', filename='any')",
        "assert response.status == 206",
        "assert 'Content-Length' in response.headers",
        "assert 'Content-Range' in response.headers",
        "assert int(response.headers['Content-Length']) == len(static_content)",
        "assert response.body == static_content"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ]
    },
    {
      "name": "test_static_content_range_back",
      "module": "test_url_for_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_for_static.py",
      "line_number": 335,
      "end_line_number": 384,
      "source_code": "def test_static_content_range_back(file_name, static_file_directory):\n    app = Sanic(\"base\")\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n\n    bp = Blueprint(\"test_bp_static\", url_prefix=\"/bp\")\n    bp.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n    app.blueprint(bp)\n\n    headers = {\"Range\": \"bytes=-12\"}\n    uri = app.url_for(\"static\")\n    assert uri == \"/testing.file\"\n    assert uri == app.url_for(\"static\", name=\"static\")\n    assert uri == app.url_for(\"static\", name=\"static\", filename=\"any\")\n\n    request, response = app.test_client.get(uri, headers=headers)\n    assert response.status == 206\n    assert \"Content-Length\" in response.headers\n    assert \"Content-Range\" in response.headers\n    static_content = bytes(get_file_content(static_file_directory, file_name))[\n        -12:\n    ]\n    assert int(response.headers[\"Content-Length\"]) == len(static_content)\n    assert response.body == static_content\n\n    # blueprint\n    uri = app.url_for(\"static\", name=\"test_bp_static.static\")\n    assert uri == \"/bp/testing.file\"\n    assert uri == app.url_for(\n        \"static\", name=\"test_bp_static.static\", filename=\"any\"\n    )\n    assert uri == app.url_for(\"test_bp_static.static\")\n    assert uri == app.url_for(\"test_bp_static.static\", filename=\"any\")\n\n    request, response = app.test_client.get(uri, headers=headers)\n    assert response.status == 206\n    assert \"Content-Length\" in response.headers\n    assert \"Content-Range\" in response.headers\n    static_content = bytes(get_file_content(static_file_directory, file_name))[\n        -12:\n    ]\n    assert int(response.headers[\"Content-Length\"]) == len(static_content)\n    assert response.body == static_content",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt'])"
      ],
      "arguments": [
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "inspect",
        "os",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint"
      ],
      "fixtures": [],
      "assertions": [
        "assert uri == '/testing.file'",
        "assert uri == app.url_for('static', name='static')",
        "assert uri == app.url_for('static', name='static', filename='any')",
        "assert response.status == 206",
        "assert 'Content-Length' in response.headers",
        "assert 'Content-Range' in response.headers",
        "assert int(response.headers['Content-Length']) == len(static_content)",
        "assert response.body == static_content",
        "assert uri == '/bp/testing.file'",
        "assert uri == app.url_for('static', name='test_bp_static.static', filename='any')",
        "assert uri == app.url_for('test_bp_static.static')",
        "assert uri == app.url_for('test_bp_static.static', filename='any')",
        "assert response.status == 206",
        "assert 'Content-Length' in response.headers",
        "assert 'Content-Range' in response.headers",
        "assert int(response.headers['Content-Length']) == len(static_content)",
        "assert response.body == static_content"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ]
    },
    {
      "name": "test_static_content_range_empty",
      "module": "test_url_for_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_for_static.py",
      "line_number": 388,
      "end_line_number": 438,
      "source_code": "def test_static_content_range_empty(file_name, static_file_directory):\n    app = Sanic(\"base\")\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n\n    bp = Blueprint(\"test_bp_static\", url_prefix=\"/bp\")\n    bp.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n    app.blueprint(bp)\n\n    uri = app.url_for(\"static\")\n    assert uri == \"/testing.file\"\n    assert uri == app.url_for(\"static\", name=\"static\")\n    assert uri == app.url_for(\"static\", name=\"static\", filename=\"any\")\n\n    request, response = app.test_client.get(uri)\n    assert response.status == 200\n    assert \"Content-Length\" in response.headers\n    assert \"Content-Range\" not in response.headers\n    assert int(response.headers[\"Content-Length\"]) == len(\n        get_file_content(static_file_directory, file_name)\n    )\n    assert response.body == bytes(\n        get_file_content(static_file_directory, file_name)\n    )\n\n    # blueprint\n    uri = app.url_for(\"static\", name=\"test_bp_static.static\")\n    assert uri == \"/bp/testing.file\"\n    assert uri == app.url_for(\n        \"static\", name=\"test_bp_static.static\", filename=\"any\"\n    )\n    assert uri == app.url_for(\"test_bp_static.static\")\n    assert uri == app.url_for(\"test_bp_static.static\", filename=\"any\")\n\n    request, response = app.test_client.get(uri)\n    assert response.status == 200\n    assert \"Content-Length\" in response.headers\n    assert \"Content-Range\" not in response.headers\n    assert int(response.headers[\"Content-Length\"]) == len(\n        get_file_content(static_file_directory, file_name)\n    )\n    assert response.body == bytes(\n        get_file_content(static_file_directory, file_name)\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt'])"
      ],
      "arguments": [
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "inspect",
        "os",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint"
      ],
      "fixtures": [],
      "assertions": [
        "assert uri == '/testing.file'",
        "assert uri == app.url_for('static', name='static')",
        "assert uri == app.url_for('static', name='static', filename='any')",
        "assert response.status == 200",
        "assert 'Content-Length' in response.headers",
        "assert 'Content-Range' not in response.headers",
        "assert int(response.headers['Content-Length']) == len(get_file_content(static_file_directory, file_name))",
        "assert response.body == bytes(get_file_content(static_file_directory, file_name))",
        "assert uri == '/bp/testing.file'",
        "assert uri == app.url_for('static', name='test_bp_static.static', filename='any')",
        "assert uri == app.url_for('test_bp_static.static')",
        "assert uri == app.url_for('test_bp_static.static', filename='any')",
        "assert response.status == 200",
        "assert 'Content-Length' in response.headers",
        "assert 'Content-Range' not in response.headers",
        "assert int(response.headers['Content-Length']) == len(get_file_content(static_file_directory, file_name))",
        "assert response.body == bytes(get_file_content(static_file_directory, file_name))"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ]
    },
    {
      "name": "test_static_content_range_error",
      "module": "test_url_for_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_for_static.py",
      "line_number": 442,
      "end_line_number": 487,
      "source_code": "def test_static_content_range_error(app, file_name, static_file_directory):\n    app = Sanic(\"base\")\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n\n    bp = Blueprint(\"test_bp_static\", url_prefix=\"/bp\")\n    bp.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n    app.blueprint(bp)\n\n    headers = {\"Range\": \"bytes=1-0\"}\n    uri = app.url_for(\"static\")\n    assert uri == \"/testing.file\"\n    assert uri == app.url_for(\"static\", name=\"static\")\n    assert uri == app.url_for(\"static\", name=\"static\", filename=\"any\")\n\n    request, response = app.test_client.get(uri, headers=headers)\n    assert response.status == 416\n    assert \"Content-Length\" in response.headers\n    assert \"Content-Range\" in response.headers\n    assert response.headers[\"Content-Range\"] == \"bytes */%s\" % (\n        len(get_file_content(static_file_directory, file_name)),\n    )\n\n    # blueprint\n    uri = app.url_for(\"static\", name=\"test_bp_static.static\")\n    assert uri == \"/bp/testing.file\"\n    assert uri == app.url_for(\n        \"static\", name=\"test_bp_static.static\", filename=\"any\"\n    )\n    assert uri == app.url_for(\"test_bp_static.static\")\n    assert uri == app.url_for(\"test_bp_static.static\", filename=\"any\")\n\n    request, response = app.test_client.get(uri, headers=headers)\n    assert response.status == 416\n    assert \"Content-Length\" in response.headers\n    assert \"Content-Range\" in response.headers\n    assert response.headers[\"Content-Range\"] == \"bytes */%s\" % (\n        len(get_file_content(static_file_directory, file_name)),\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt'])"
      ],
      "arguments": [
        "app",
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "inspect",
        "os",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint"
      ],
      "fixtures": [],
      "assertions": [
        "assert uri == '/testing.file'",
        "assert uri == app.url_for('static', name='static')",
        "assert uri == app.url_for('static', name='static', filename='any')",
        "assert response.status == 416",
        "assert 'Content-Length' in response.headers",
        "assert 'Content-Range' in response.headers",
        "assert response.headers['Content-Range'] == 'bytes */%s' % (len(get_file_content(static_file_directory, file_name)),)",
        "assert uri == '/bp/testing.file'",
        "assert uri == app.url_for('static', name='test_bp_static.static', filename='any')",
        "assert uri == app.url_for('test_bp_static.static')",
        "assert uri == app.url_for('test_bp_static.static', filename='any')",
        "assert response.status == 416",
        "assert 'Content-Length' in response.headers",
        "assert 'Content-Range' in response.headers",
        "assert response.headers['Content-Range'] == 'bytes */%s' % (len(get_file_content(static_file_directory, file_name)),)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ]
    },
    {
      "name": "test_request_cookies",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 16,
      "end_line_number": 27,
      "source_code": "def test_request_cookies():\n    cdict = parse_cookie(\"foo=one; foo=two; abc = xyz;;bare;=bare2\")\n    assert cdict == {\n        \"foo\": [\"one\", \"two\"],\n        \"abc\": [\"xyz\"],\n        \"\": [\"bare\", \"bare2\"],\n    }\n    c = CookieRequestParameters(cdict)\n    assert c.getlist(\"foo\") == [\"one\", \"two\"]\n    assert c.getlist(\"abc\") == [\"xyz\"]\n    assert c.getlist(\"\") == [\"bare\", \"bare2\"]\n    assert c.getlist(\"bare\") == []",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert cdict == {'foo': ['one', 'two'], 'abc': ['xyz'], '': ['bare', 'bare2']}",
        "assert c.getlist('foo') == ['one', 'two']",
        "assert c.getlist('abc') == ['xyz']",
        "assert c.getlist('') == ['bare', 'bare2']",
        "assert c.getlist('bare') == []"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_cookies",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 35,
      "end_line_number": 48,
      "source_code": "def test_cookies(app):\n    @app.route(\"/\")\n    def handler(request):\n        cookie_value = request.cookies[\"test\"]\n        response = text(f\"Cookies are: {cookie_value}\")\n        response.cookies[\"right_back\"] = \"at you\"\n        return response\n\n    request, response = app.test_client.get(\"/\", cookies={\"test\": \"working!\"})\n    response_cookies = SimpleCookie()\n    response_cookies.load(response.headers.get(\"Set-Cookie\", {}))\n\n    assert response.text == \"Cookies are: working!\"\n    assert response_cookies[\"right_back\"].value == \"at you\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'Cookies are: working!'",
        "assert response_cookies['right_back'].value == 'at you'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response_cookies.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        },
        {
          "name": "response.headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_false_cookies_encoded",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 71,
      "end_line_number": 81,
      "source_code": "def test_false_cookies_encoded(app, httponly, expected):\n    @app.route(\"/\")\n    def handler(request):\n        response = text(\"hello cookies\")\n        response.cookies[\"hello\"] = \"world\"\n        response.cookies[\"hello\"][\"httponly\"] = httponly\n        return text(response.cookies[\"hello\"].encode(\"utf8\").decode())\n\n    request, response = app.test_client.get(\"/\")\n\n    assert (\"HttpOnly\" in response.text) == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('httponly,expected', [(False, False), (True, True)])"
      ],
      "arguments": [
        "app",
        "httponly",
        "expected"
      ],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert ('HttpOnly' in response.text) == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_false_cookies",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 85,
      "end_line_number": 97,
      "source_code": "def test_false_cookies(app, httponly, expected):\n    @app.route(\"/\")\n    def handler(request):\n        response = text(\"hello cookies\")\n        response.cookies[\"right_back\"] = \"at you\"\n        response.cookies[\"right_back\"][\"httponly\"] = httponly\n        return response\n\n    request, response = app.test_client.get(\"/\")\n    response_cookies = SimpleCookie()\n    response_cookies.load(response.headers.get(\"Set-Cookie\", {}))\n\n    assert (\"HttpOnly\" in response_cookies[\"right_back\"].output()) == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('httponly,expected', [(False, False), (True, True)])"
      ],
      "arguments": [
        "app",
        "httponly",
        "expected"
      ],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert ('HttpOnly' in response_cookies['right_back'].output()) == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response_cookies.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        },
        {
          "name": "response.headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_http2_cookies",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 100,
      "end_line_number": 110,
      "source_code": "def test_http2_cookies(app):\n    @app.route(\"/\")\n    async def handler(request):\n        cookie_value = request.cookies[\"test\"]\n        response = text(f\"Cookies are: {cookie_value}\")\n        return response\n\n    headers = {\"cookie\": \"test=working!\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n\n    assert response.text == \"Cookies are: working!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'Cookies are: working!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_cookie_options",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 113,
      "end_line_number": 129,
      "source_code": "def test_cookie_options(app):\n    @app.route(\"/\")\n    def handler(request):\n        response = text(\"OK\")\n        response.cookies[\"test\"] = \"at you\"\n        response.cookies[\"test\"][\"httponly\"] = True\n        response.cookies[\"test\"][\"expires\"] = datetime.now() + timedelta(\n            seconds=10\n        )\n        return response\n\n    request, response = app.test_client.get(\"/\")\n    response_cookies = SimpleCookie()\n    response_cookies.load(response.headers.get(\"Set-Cookie\", {}))\n\n    assert response_cookies[\"test\"].value == \"at you\"\n    assert response_cookies[\"test\"][\"httponly\"] is True",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert response_cookies['test'].value == 'at you'",
        "assert response_cookies['test']['httponly'] is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response_cookies.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        },
        {
          "name": "response.headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_cookie_deletion",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 132,
      "end_line_number": 149,
      "source_code": "def test_cookie_deletion(app):\n    cookie_jar = None\n\n    @app.route(\"/\")\n    def handler(request):\n        nonlocal cookie_jar\n        response = text(\"OK\")\n        del response.cookies[\"one\"]\n        response.cookies[\"two\"] = \"testing\"\n        del response.cookies[\"two\"]\n        cookie_jar = response.cookies\n        return response\n\n    _, response = app.test_client.get(\"/\")\n\n    assert cookie_jar.get_cookie(\"one\").max_age == 0\n    assert cookie_jar.get_cookie(\"two\").max_age == 0\n    assert len(response.cookies) == 0",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert cookie_jar.get_cookie('one').max_age == 0",
        "assert cookie_jar.get_cookie('two').max_age == 0",
        "assert len(response.cookies) == 0"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "cookie_jar.get_cookie",
          "body": "@app.get('/cookie')\ndef get_cookie(request):\n    response = text(\"There's a cookie up in this response\")\n    response.cookies['test'] = 'Cookie1'\n    response.cookies['test']['httponly'] = True\n    response.cookies['c2'] = 'Cookie2'\n    response.cookies['c2']['httponly'] = False\n    return response"
        },
        {
          "name": "cookie_jar.get_cookie",
          "body": "@app.get('/cookie')\ndef get_cookie(request):\n    response = text(\"There's a cookie up in this response\")\n    response.cookies['test'] = 'Cookie1'\n    response.cookies['test']['httponly'] = True\n    response.cookies['c2'] = 'Cookie2'\n    response.cookies['c2']['httponly'] = False\n    return response"
        }
      ]
    },
    {
      "name": "test_cookie_reserved_cookie",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 152,
      "end_line_number": 155,
      "source_code": "def test_cookie_reserved_cookie():\n    with pytest.raises(expected_exception=KeyError) as e:\n        Cookie(\"domain\", \"testdomain.com\")\n        assert e.message == \"Cookie name is a reserved word\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert e.message == 'Cookie name is a reserved word'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_cookie_illegal_key_format",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 158,
      "end_line_number": 161,
      "source_code": "def test_cookie_illegal_key_format():\n    with pytest.raises(expected_exception=KeyError) as e:\n        Cookie(\"test\u00e5\", \"test\")\n        assert e.message == \"Cookie key contains illegal characters\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert e.message == 'Cookie key contains illegal characters'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_cookie_set_unknown_property",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 164,
      "end_line_number": 168,
      "source_code": "def test_cookie_set_unknown_property():\n    c = Cookie(\"test_cookie\", \"value\")\n    with pytest.raises(expected_exception=KeyError) as e:\n        c[\"invalid\"] = \"value\"\n        assert e.message == \"Unknown cookie property\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert e.message == 'Unknown cookie property'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_cookie_set_same_key",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 171,
      "end_line_number": 183,
      "source_code": "def test_cookie_set_same_key(app):\n    cookies = {\"test\": \"wait\"}\n\n    @app.get(\"/\")\n    def handler(request):\n        response = text(\"pass\")\n        response.cookies[\"test\"] = \"modified\"\n        response.cookies[\"test\"] = \"pass\"\n        return response\n\n    request, response = app.test_client.get(\"/\", cookies=cookies)\n    assert response.status == 200\n    assert response.cookies[\"test\"] == \"pass\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.cookies['test'] == 'pass'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_cookie_max_age",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 187,
      "end_line_number": 225,
      "source_code": "def test_cookie_max_age(app, max_age):\n    cookies = {\"test\": \"wait\"}\n\n    @app.get(\"/\")\n    def handler(request):\n        response = text(\"pass\")\n        response.cookies[\"test\"] = \"pass\"\n        response.cookies[\"test\"][\"max-age\"] = max_age\n        return response\n\n    request, response = app.test_client.get(\n        \"/\", cookies=cookies, raw_cookies=True\n    )\n    assert response.status == 200\n\n    cookie = response.cookies.get(\"test\")\n    if (\n        str(max_age).isdigit()\n        and int(max_age) == float(max_age)\n        and int(max_age) != 0\n    ):\n        cookie_expires = datetime.utcfromtimestamp(\n            response.raw_cookies[\"test\"].expires\n        ).replace(microsecond=0)\n\n        # Grabbing utcnow after the response may lead to it being off slightly.\n        # Therefore, we 0 out the microseconds, and accept the test if there\n        # is a 1 second difference.\n        expires = datetime.utcnow().replace(microsecond=0) + timedelta(\n            seconds=int(max_age)\n        )\n\n        assert cookie == \"pass\"\n        assert (\n            cookie_expires == expires\n            or cookie_expires == expires + timedelta(seconds=-1)\n        )\n    else:\n        assert cookie is None",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('max_age', ['0', 30, '30'])"
      ],
      "arguments": [
        "app",
        "max_age"
      ],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert cookie == 'pass'",
        "assert cookie_expires == expires or cookie_expires == expires + timedelta(seconds=-1)",
        "assert cookie is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response.cookies.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_cookie_bad_max_age",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 229,
      "end_line_number": 242,
      "source_code": "def test_cookie_bad_max_age(app, max_age):\n    cookies = {\"test\": \"wait\"}\n\n    @app.get(\"/\")\n    def handler(request):\n        response = text(\"pass\")\n        response.cookies[\"test\"] = \"pass\"\n        response.cookies[\"test\"][\"max-age\"] = max_age\n        return response\n\n    request, response = app.test_client.get(\n        \"/\", cookies=cookies, raw_cookies=True\n    )\n    assert response.status == 500",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('max_age', [30.0, 30.1, 'test'])"
      ],
      "arguments": [
        "app",
        "max_age"
      ],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_cookie_expires",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 246,
      "end_line_number": 267,
      "source_code": "def test_cookie_expires(app: Sanic, expires: timedelta):\n    expires_time = datetime.utcnow().replace(microsecond=0) + expires\n    cookies = {\"test\": \"wait\"}\n\n    @app.get(\"/\")\n    def handler(request):\n        response = text(\"pass\")\n        response.cookies[\"test\"] = \"pass\"\n        response.cookies[\"test\"][\"expires\"] = expires_time\n        return response\n\n    request, response = app.test_client.get(\n        \"/\", cookies=cookies, raw_cookies=True\n    )\n\n    cookie_expires = datetime.utcfromtimestamp(\n        response.raw_cookies[\"test\"].expires\n    ).replace(microsecond=0)\n\n    assert response.status == 200\n    assert response.cookies[\"test\"] == \"pass\"\n    assert cookie_expires == expires_time",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('expires', [timedelta(seconds=60)])"
      ],
      "arguments": [
        "app",
        "expires"
      ],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.cookies['test'] == 'pass'",
        "assert cookie_expires == expires_time"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_cookie_expires_illegal_instance_type",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 271,
      "end_line_number": 275,
      "source_code": "def test_cookie_expires_illegal_instance_type(expires):\n    c = Cookie(\"test_cookie\", \"value\")\n    with pytest.raises(expected_exception=TypeError) as e:\n        c[\"expires\"] = expires\n        assert e.message == \"Cookie 'expires' property must be a datetime\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('expires', ['Fri, 21-Dec-2018 15:30:00 GMT'])"
      ],
      "arguments": [
        "expires"
      ],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert e.message == \"Cookie 'expires' property must be a datetime\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_request_with_duplicate_cookie_key",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 279,
      "end_line_number": 286,
      "source_code": "def test_request_with_duplicate_cookie_key(value):\n    headers = Header({\"Cookie\": value})\n    request = Request(b\"/\", headers, \"1.1\", \"GET\", Mock(), Mock())\n\n    assert request.cookies[\"foo\"] == \"one\"\n    assert request.cookies.get(\"foo\") == \"one\"\n    assert request.cookies.getlist(\"foo\") == [\"one\", \"two\"]\n    assert request.cookies.get(\"bar\") is None",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('value', ('foo=one; foo=two', 'foo=one;foo=two'))"
      ],
      "arguments": [
        "value"
      ],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.cookies['foo'] == 'one'",
        "assert request.cookies.get('foo') == 'one'",
        "assert request.cookies.getlist('foo') == ['one', 'two']",
        "assert request.cookies.get('bar') is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "request.cookies.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "request.cookies.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_cookie_jar_cookies",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 289,
      "end_line_number": 296,
      "source_code": "def test_cookie_jar_cookies():\n    headers = Header()\n    jar = CookieJar(headers)\n    jar.add_cookie(\"foo\", \"one\")\n    jar.add_cookie(\"foo\", \"two\", domain=\"example.com\")\n\n    assert len(jar.cookies) == 2\n    assert len(headers) == 2",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(jar.cookies) == 2",
        "assert len(headers) == 2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_cookie_jar_has_cookie",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 299,
      "end_line_number": 308,
      "source_code": "def test_cookie_jar_has_cookie():\n    headers = Header()\n    jar = CookieJar(headers)\n    jar.add_cookie(\"foo\", \"one\")\n    jar.add_cookie(\"foo\", \"two\", domain=\"example.com\")\n\n    assert jar.has_cookie(\"foo\")\n    assert jar.has_cookie(\"foo\", domain=\"example.com\")\n    assert not jar.has_cookie(\"foo\", path=\"/unknown\")\n    assert not jar.has_cookie(\"bar\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert jar.has_cookie('foo')",
        "assert jar.has_cookie('foo', domain='example.com')",
        "assert not jar.has_cookie('foo', path='/unknown')",
        "assert not jar.has_cookie('bar')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_cookie_jar_get_cookie",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 311,
      "end_line_number": 320,
      "source_code": "def test_cookie_jar_get_cookie():\n    headers = Header()\n    jar = CookieJar(headers)\n    cookie1 = jar.add_cookie(\"foo\", \"one\")\n    cookie2 = jar.add_cookie(\"foo\", \"two\", domain=\"example.com\")\n\n    assert jar.get_cookie(\"foo\") is cookie1\n    assert jar.get_cookie(\"foo\", domain=\"example.com\") is cookie2\n    assert jar.get_cookie(\"foo\", path=\"/unknown\") is None\n    assert jar.get_cookie(\"bar\") is None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert jar.get_cookie('foo') is cookie1",
        "assert jar.get_cookie('foo', domain='example.com') is cookie2",
        "assert jar.get_cookie('foo', path='/unknown') is None",
        "assert jar.get_cookie('bar') is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "jar.get_cookie",
          "body": "@app.get('/cookie')\ndef get_cookie(request):\n    response = text(\"There's a cookie up in this response\")\n    response.cookies['test'] = 'Cookie1'\n    response.cookies['test']['httponly'] = True\n    response.cookies['c2'] = 'Cookie2'\n    response.cookies['c2']['httponly'] = False\n    return response"
        },
        {
          "name": "jar.get_cookie",
          "body": "@app.get('/cookie')\ndef get_cookie(request):\n    response = text(\"There's a cookie up in this response\")\n    response.cookies['test'] = 'Cookie1'\n    response.cookies['test']['httponly'] = True\n    response.cookies['c2'] = 'Cookie2'\n    response.cookies['c2']['httponly'] = False\n    return response"
        },
        {
          "name": "jar.get_cookie",
          "body": "@app.get('/cookie')\ndef get_cookie(request):\n    response = text(\"There's a cookie up in this response\")\n    response.cookies['test'] = 'Cookie1'\n    response.cookies['test']['httponly'] = True\n    response.cookies['c2'] = 'Cookie2'\n    response.cookies['c2']['httponly'] = False\n    return response"
        },
        {
          "name": "jar.get_cookie",
          "body": "@app.get('/cookie')\ndef get_cookie(request):\n    response = text(\"There's a cookie up in this response\")\n    response.cookies['test'] = 'Cookie1'\n    response.cookies['test']['httponly'] = True\n    response.cookies['c2'] = 'Cookie2'\n    response.cookies['c2']['httponly'] = False\n    return response"
        }
      ]
    },
    {
      "name": "test_cookie_jar_add_cookie_encode",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 323,
      "end_line_number": 348,
      "source_code": "def test_cookie_jar_add_cookie_encode():\n    headers = Header()\n    jar = CookieJar(headers)\n    jar.add_cookie(\"foo\", \"one\")\n    jar.add_cookie(\n        \"foo\",\n        \"two\",\n        domain=\"example.com\",\n        path=\"/something\",\n        secure=True,\n        max_age=999,\n        httponly=True,\n        samesite=\"strict\",\n    )\n    jar.add_cookie(\"foo\", \"three\", secure_prefix=True)\n    jar.add_cookie(\"foo\", \"four\", host_prefix=True)\n    jar.add_cookie(\"foo\", \"five\", host_prefix=True, partitioned=True)\n\n    encoded = [cookie.encode(\"ascii\") for cookie in jar.cookies]\n    assert encoded == [\n        b\"foo=one; Path=/; SameSite=Lax; Secure\",\n        b\"foo=two; Path=/something; Domain=example.com; Max-Age=999; SameSite=Strict; Secure; HttpOnly\",  # noqa\n        b\"__Secure-foo=three; Path=/; SameSite=Lax; Secure\",\n        b\"__Host-foo=four; Path=/; SameSite=Lax; Secure\",\n        b\"__Host-foo=five; Path=/; SameSite=Lax; Secure; Partitioned\",\n    ]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert encoded == [b'foo=one; Path=/; SameSite=Lax; Secure', b'foo=two; Path=/something; Domain=example.com; Max-Age=999; SameSite=Strict; Secure; HttpOnly', b'__Secure-foo=three; Path=/; SameSite=Lax; Secure', b'__Host-foo=four; Path=/; SameSite=Lax; Secure', b'__Host-foo=five; Path=/; SameSite=Lax; Secure; Partitioned']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_cookie_jar_old_school_cookie_encode",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 351,
      "end_line_number": 367,
      "source_code": "def test_cookie_jar_old_school_cookie_encode():\n    headers = Header()\n    jar = CookieJar(headers)\n    jar[\"foo\"] = \"one\"\n    jar[\"bar\"] = \"two\"\n    jar[\"bar\"][\"domain\"] = \"example.com\"\n    jar[\"bar\"][\"path\"] = \"/something\"\n    jar[\"bar\"][\"secure\"] = True\n    jar[\"bar\"][\"max-age\"] = 999\n    jar[\"bar\"][\"httponly\"] = True\n    jar[\"bar\"][\"samesite\"] = \"strict\"\n\n    encoded = [cookie.encode(\"ascii\") for cookie in jar.cookies]\n    assert encoded == [\n        b\"foo=one; Path=/\",\n        b\"bar=two; Path=/something; Domain=example.com; Max-Age=999; SameSite=Strict; Secure; HttpOnly\",  # noqa\n    ]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert encoded == [b'foo=one; Path=/', b'bar=two; Path=/something; Domain=example.com; Max-Age=999; SameSite=Strict; Secure; HttpOnly']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_cookie_jar_delete_cookie_encode",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 370,
      "end_line_number": 380,
      "source_code": "def test_cookie_jar_delete_cookie_encode():\n    headers = Header()\n    jar = CookieJar(headers)\n    jar.delete_cookie(\"foo\")\n    jar.delete_cookie(\"foo\", domain=\"example.com\")\n\n    encoded = [cookie.encode(\"ascii\") for cookie in jar.cookies]\n    assert encoded == [\n        b'foo=\"\"; Path=/; Max-Age=0; Secure',\n        b'foo=\"\"; Path=/; Domain=example.com; Max-Age=0; Secure',\n    ]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert encoded == [b'foo=\"\"; Path=/; Max-Age=0; Secure', b'foo=\"\"; Path=/; Domain=example.com; Max-Age=0; Secure']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_cookie_jar_delete_nonsecure_cookie",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 383,
      "end_line_number": 391,
      "source_code": "def test_cookie_jar_delete_nonsecure_cookie():\n    headers = Header()\n    jar = CookieJar(headers)\n    jar.delete_cookie(\"foo\", domain=\"example.com\", secure=False)\n\n    encoded = [cookie.encode(\"ascii\") for cookie in jar.cookies]\n    assert encoded == [\n        b'foo=\"\"; Path=/; Domain=example.com; Max-Age=0',\n    ]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert encoded == [b'foo=\"\"; Path=/; Domain=example.com; Max-Age=0']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_cookie_jar_delete_existing_cookie",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 394,
      "end_line_number": 407,
      "source_code": "def test_cookie_jar_delete_existing_cookie():\n    headers = Header()\n    jar = CookieJar(headers)\n    jar.add_cookie(\n        \"foo\", \"test\", secure=True, domain=\"example.com\", samesite=\"Strict\"\n    )\n    jar.delete_cookie(\"foo\", domain=\"example.com\", secure=True)\n\n    encoded = [cookie.encode(\"ascii\") for cookie in jar.cookies]\n    # deletion cookie contains samesite=Strict as was in original cookie\n    assert encoded == [\n        b'foo=\"\"; Path=/; Domain=example.com; Max-Age=0; '\n        b\"SameSite=Strict; Secure\",\n    ]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert encoded == [b'foo=\"\"; Path=/; Domain=example.com; Max-Age=0; SameSite=Strict; Secure']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_cookie_jar_delete_existing_nonsecure_cookie",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 410,
      "end_line_number": 422,
      "source_code": "def test_cookie_jar_delete_existing_nonsecure_cookie():\n    headers = Header()\n    jar = CookieJar(headers)\n    jar.add_cookie(\n        \"foo\", \"test\", secure=False, domain=\"example.com\", samesite=\"Strict\"\n    )\n    jar.delete_cookie(\"foo\", domain=\"example.com\", secure=False)\n\n    encoded = [cookie.encode(\"ascii\") for cookie in jar.cookies]\n    # deletion cookie contains samesite=Strict as was in original cookie\n    assert encoded == [\n        b'foo=\"\"; Path=/; Domain=example.com; Max-Age=0; SameSite=Strict',\n    ]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert encoded == [b'foo=\"\"; Path=/; Domain=example.com; Max-Age=0; SameSite=Strict']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_cookie_jar_delete_existing_nonsecure_cookie_bad_prefix",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 425,
      "end_line_number": 442,
      "source_code": "def test_cookie_jar_delete_existing_nonsecure_cookie_bad_prefix():\n    headers = Header()\n    jar = CookieJar(headers)\n    jar.add_cookie(\n        \"foo\", \"test\", secure=False, domain=\"example.com\", samesite=\"Strict\"\n    )\n    message = (\n        \"Cannot set host_prefix on a cookie without \"\n        \"path='/', domain=None, and secure=True\"\n    )\n    with pytest.raises(ServerError, match=message):\n        jar.delete_cookie(\n            \"foo\",\n            domain=\"example.com\",\n            secure=False,\n            secure_prefix=True,\n            host_prefix=True,\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_cookie_jar_old_school_delete_encode",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 445,
      "end_line_number": 453,
      "source_code": "def test_cookie_jar_old_school_delete_encode():\n    headers = Header()\n    jar = CookieJar(headers)\n    del jar[\"foo\"]\n\n    encoded = [cookie.encode(\"ascii\") for cookie in jar.cookies]\n    assert encoded == [\n        b'foo=\"\"; Path=/; Max-Age=0; Secure',\n    ]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert encoded == [b'foo=\"\"; Path=/; Max-Age=0; Secure']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_bad_cookie_prarms",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 456,
      "end_line_number": 504,
      "source_code": "def test_bad_cookie_prarms():\n    headers = Header()\n    jar = CookieJar(headers)\n\n    with pytest.raises(\n        ServerError,\n        match=(\n            \"Both host_prefix and secure_prefix were requested. \"\n            \"A cookie should have only one prefix.\"\n        ),\n    ):\n        jar.add_cookie(\"foo\", \"bar\", host_prefix=True, secure_prefix=True)\n\n    with pytest.raises(\n        ServerError,\n        match=\"Cannot set host_prefix on a cookie without secure=True\",\n    ):\n        jar.add_cookie(\"foo\", \"bar\", host_prefix=True, secure=False)\n\n    with pytest.raises(\n        ServerError,\n        match=\"Cannot set host_prefix on a cookie unless path='/'\",\n    ):\n        jar.add_cookie(\n            \"foo\", \"bar\", host_prefix=True, secure=True, path=\"/foo\"\n        )\n\n    with pytest.raises(\n        ServerError,\n        match=\"Cannot set host_prefix on a cookie with a defined domain\",\n    ):\n        jar.add_cookie(\n            \"foo\", \"bar\", host_prefix=True, secure=True, domain=\"foo.bar\"\n        )\n\n    with pytest.raises(\n        ServerError,\n        match=\"Cannot set secure_prefix on a cookie without secure=True\",\n    ):\n        jar.add_cookie(\"foo\", \"bar\", secure_prefix=True, secure=False)\n\n    with pytest.raises(\n        ServerError,\n        match=(\n            \"Cannot create a partitioned cookie without \"\n            \"also setting host_prefix=True\"\n        ),\n    ):\n        jar.add_cookie(\"foo\", \"bar\", partitioned=True)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_cookie_accessors",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 507,
      "end_line_number": 573,
      "source_code": "def test_cookie_accessors(app: Sanic):\n    @app.get(\"/\")\n    async def handler(request: Request):\n        return json(\n            {\n                \"getitem\": {\n                    \"one\": request.cookies[\"one\"],\n                    \"two\": request.cookies[\"two\"],\n                    \"three\": request.cookies[\"three\"],\n                },\n                \"get\": {\n                    \"one\": request.cookies.get(\"one\", \"fallback\"),\n                    \"two\": request.cookies.get(\"two\", \"fallback\"),\n                    \"three\": request.cookies.get(\"three\", \"fallback\"),\n                    \"four\": request.cookies.get(\"four\", \"fallback\"),\n                },\n                \"getlist\": {\n                    \"one\": request.cookies.getlist(\"one\"),\n                    \"two\": request.cookies.getlist(\"two\"),\n                    \"three\": request.cookies.getlist(\"three\"),\n                    \"four\": request.cookies.getlist(\"four\"),\n                    \"five\": request.cookies.getlist(\"five\", [\"fallback\"]),\n                },\n                \"getattr\": {\n                    \"one\": request.cookies.one,\n                    \"two\": request.cookies.two,\n                    \"three\": request.cookies.three,\n                    \"four\": request.cookies.four,\n                },\n            }\n        )\n\n    _, response = app.test_client.get(\n        \"/\",\n        cookies={\n            \"__Host-one\": \"1\",\n            \"__Secure-two\": \"2\",\n            \"three\": \"3\",\n        },\n    )\n\n    assert response.json == {\n        \"getitem\": {\n            \"one\": \"1\",\n            \"two\": \"2\",\n            \"three\": \"3\",\n        },\n        \"get\": {\n            \"one\": \"1\",\n            \"two\": \"2\",\n            \"three\": \"3\",\n            \"four\": \"fallback\",\n        },\n        \"getlist\": {\n            \"one\": [\"1\"],\n            \"two\": [\"2\"],\n            \"three\": [\"3\"],\n            \"four\": [],\n            \"five\": [\"fallback\"],\n        },\n        \"getattr\": {\n            \"one\": \"1\",\n            \"two\": \"2\",\n            \"three\": \"3\",\n            \"four\": \"\",\n        },\n    }",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json == {'getitem': {'one': '1', 'two': '2', 'three': '3'}, 'get': {'one': '1', 'two': '2', 'three': '3', 'four': 'fallback'}, 'getlist': {'one': ['1'], 'two': ['2'], 'three': ['3'], 'four': [], 'five': ['fallback']}, 'getattr': {'one': '1', 'two': '2', 'three': '3', 'four': ''}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "request.cookies.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "request.cookies.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "request.cookies.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "request.cookies.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_cookie_accessor_hyphens",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 576,
      "end_line_number": 579,
      "source_code": "def test_cookie_accessor_hyphens():\n    cookies = CookieRequestParameters({\"session-token\": [\"abc123\"]})\n\n    assert cookies.get(\"session-token\") == cookies.session_token",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert cookies.get('session-token') == cookies.session_token"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "cookies.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_cookie_passthru",
      "module": "test_cookies",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cookies.py",
      "line_number": 582,
      "end_line_number": 598,
      "source_code": "def test_cookie_passthru(app):\n    cookie_jar = None\n\n    @app.route(\"/\")\n    def handler(request):\n        nonlocal cookie_jar\n        response = text(\"OK\")\n        response.add_cookie(\"one\", \"1\", host_prefix=True)\n        response.delete_cookie(\"two\", secure_prefix=True)\n        cookie_jar = response.cookies\n        return response\n\n    _, response = app.test_client.get(\"/\")\n\n    assert cookie_jar.get_cookie(\"two\", secure_prefix=True).max_age == 0\n    assert len(response.cookies) == 1\n    assert response.cookies[\"__Host-one\"] == \"1\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "datetime.datetime",
        "datetime.timedelta",
        "http.cookies.SimpleCookie",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.cookies.Cookie",
        "sanic.cookies.CookieJar",
        "sanic.cookies.request.CookieRequestParameters",
        "sanic.cookies.request.parse_cookie",
        "sanic.exceptions.ServerError",
        "sanic.response.text",
        "sanic.response.convenience.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert cookie_jar.get_cookie('two', secure_prefix=True).max_age == 0",
        "assert len(response.cookies) == 1",
        "assert response.cookies['__Host-one'] == '1'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "cookie_jar.get_cookie",
          "body": "@app.get('/cookie')\ndef get_cookie(request):\n    response = text(\"There's a cookie up in this response\")\n    response.cookies['test'] = 'Cookie1'\n    response.cookies['test']['httponly'] = True\n    response.cookies['c2'] = 'Cookie2'\n    response.cookies['c2']['httponly'] = False\n    return response"
        }
      ]
    },
    {
      "name": "test_string_compat",
      "module": "test_constants",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_constants.py",
      "line_number": 9,
      "end_line_number": 12,
      "source_code": "def test_string_compat(enum):\n    for key in enum.__members__.keys():\n        assert key.upper() == getattr(enum, key).upper()\n        assert key.lower() == getattr(enum, key).lower()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('enum', (HTTPMethod, Server, Mode))"
      ],
      "arguments": [
        "enum"
      ],
      "imports": [
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.application.constants.Mode",
        "sanic.application.constants.Server",
        "sanic.application.constants.ServerStage",
        "sanic.constants.HTTP_METHODS",
        "sanic.constants.HTTPMethod"
      ],
      "fixtures": [],
      "assertions": [
        "assert key.upper() == getattr(enum, key).upper()",
        "assert key.lower() == getattr(enum, key).lower()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_http_methods",
      "module": "test_constants",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_constants.py",
      "line_number": 15,
      "end_line_number": 17,
      "source_code": "def test_http_methods():\n    for value in HTTPMethod.__members__.values():\n        assert value in HTTP_METHODS",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.application.constants.Mode",
        "sanic.application.constants.Server",
        "sanic.application.constants.ServerStage",
        "sanic.constants.HTTP_METHODS",
        "sanic.constants.HTTPMethod"
      ],
      "fixtures": [],
      "assertions": [
        "assert value in HTTP_METHODS"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_server_stage",
      "module": "test_constants",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_constants.py",
      "line_number": 20,
      "end_line_number": 21,
      "source_code": "def test_server_stage():\n    assert ServerStage.SERVING > ServerStage.PARTIAL > ServerStage.STOPPED",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.application.constants.Mode",
        "sanic.application.constants.Server",
        "sanic.application.constants.ServerStage",
        "sanic.constants.HTTP_METHODS",
        "sanic.constants.HTTPMethod"
      ],
      "fixtures": [],
      "assertions": [
        "assert ServerStage.SERVING > ServerStage.PARTIAL > ServerStage.STOPPED"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_use_in_routes",
      "module": "test_constants",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_constants.py",
      "line_number": 24,
      "end_line_number": 35,
      "source_code": "def test_use_in_routes(app: Sanic):\n    @app.route(\"/\", methods=[HTTPMethod.GET, HTTPMethod.POST])\n    def handler(_):\n        return text(\"It works\")\n\n    _, response = app.test_client.get(\"/\")\n    assert response.status == 200\n    assert response.text == \"It works\"\n\n    _, response = app.test_client.post(\"/\")\n    assert response.status == 200\n    assert response.text == \"It works\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.application.constants.Mode",
        "sanic.application.constants.Server",
        "sanic.application.constants.ServerStage",
        "sanic.constants.HTTP_METHODS",
        "sanic.constants.HTTPMethod"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'It works'",
        "assert response.status == 200",
        "assert response.text == 'It works'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_bp",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 20,
      "end_line_number": 30,
      "source_code": "def test_bp(app: Sanic):\n    bp = Blueprint(\"test_text\")\n\n    @bp.route(\"/\")\n    def handler(request):\n        return text(\"Hello\")\n\n    app.blueprint(bp)\n    request, response = app.test_client.get(\"/\")\n\n    assert response.text == \"Hello\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'Hello'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_bp_app_access",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 33,
      "end_line_number": 44,
      "source_code": "def test_bp_app_access(app: Sanic):\n    bp = Blueprint(\"test\")\n\n    with pytest.raises(\n        SanicException,\n        match=\"<Blueprint test> has not yet been registered to an app\",\n    ):\n        bp.apps\n\n    app.blueprint(bp)\n\n    assert app in bp.apps",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert app in bp.apps"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_versioned_routes_get",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 67,
      "end_line_number": 87,
      "source_code": "def test_versioned_routes_get(app, method):\n    bp = Blueprint(\"test_text\")\n\n    method = method.lower()\n\n    func = getattr(bp, method)\n    if callable(func):\n\n        @func(f\"/{method}\", version=1)\n        def handler(request):\n            return text(\"OK\")\n\n    else:\n        raise Exception(f\"{func} is not callable\")\n\n    app.blueprint(bp)\n\n    client_method = getattr(app.test_client, method)\n\n    request, response = client_method(f\"/v1/{method}\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('method', HTTP_METHODS)"
      ],
      "arguments": [
        "app",
        "method"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_bp_strict_slash",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 90,
      "end_line_number": 114,
      "source_code": "def test_bp_strict_slash(app: Sanic):\n    bp = Blueprint(\"test_text\")\n\n    @bp.get(\"/get\", strict_slashes=True)\n    def get_handler(request):\n        return text(\"OK\")\n\n    @bp.post(\"/post/\", strict_slashes=True)\n    def post_handler(request):\n        return text(\"OK\")\n\n    app.blueprint(bp)\n\n    request, response = app.test_client.get(\"/get\")\n    assert response.text == \"OK\"\n    assert response.json is None\n\n    request, response = app.test_client.get(\"/get/\")\n    assert response.status == 404\n\n    request, response = app.test_client.post(\"/post/\")\n    assert response.text == \"OK\"\n\n    request, response = app.test_client.post(\"/post\")\n    assert response.status == 404",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert response.json is None",
        "assert response.status == 404",
        "assert response.text == 'OK'",
        "assert response.status == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "bp.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_bp_strict_slash_default_value",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 117,
      "end_line_number": 134,
      "source_code": "def test_bp_strict_slash_default_value(app: Sanic):\n    bp = Blueprint(\"test_text\", strict_slashes=True)\n\n    @bp.get(\"/get\")\n    def get_handler(request):\n        return text(\"OK\")\n\n    @bp.post(\"/post/\")\n    def post_handler(request):\n        return text(\"OK\")\n\n    app.blueprint(bp)\n\n    request, response = app.test_client.get(\"/get/\")\n    assert response.status == 404\n\n    request, response = app.test_client.post(\"/post\")\n    assert response.status == 404",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 404",
        "assert response.status == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "bp.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_bp_strict_slash_without_passing_default_value",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 137,
      "end_line_number": 154,
      "source_code": "def test_bp_strict_slash_without_passing_default_value(app: Sanic):\n    bp = Blueprint(\"test_text\")\n\n    @bp.get(\"/get\")\n    def get_handler(request):\n        return text(\"OK\")\n\n    @bp.post(\"/post/\")\n    def post_handler(request):\n        return text(\"OK\")\n\n    app.blueprint(bp)\n\n    request, response = app.test_client.get(\"/get/\")\n    assert response.text == \"OK\"\n\n    request, response = app.test_client.post(\"/post\")\n    assert response.text == \"OK\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert response.text == 'OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "bp.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_bp_strict_slash_default_value_can_be_overwritten",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 157,
      "end_line_number": 174,
      "source_code": "def test_bp_strict_slash_default_value_can_be_overwritten(app: Sanic):\n    bp = Blueprint(\"test_text\", strict_slashes=True)\n\n    @bp.get(\"/get\", strict_slashes=False)\n    def get_handler(request):\n        return text(\"OK\")\n\n    @bp.post(\"/post/\", strict_slashes=False)\n    def post_handler(request):\n        return text(\"OK\")\n\n    app.blueprint(bp)\n\n    request, response = app.test_client.get(\"/get/\")\n    assert response.text == \"OK\"\n\n    request, response = app.test_client.post(\"/post\")\n    assert response.text == \"OK\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert response.text == 'OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "bp.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_bp_with_url_prefix",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 177,
      "end_line_number": 187,
      "source_code": "def test_bp_with_url_prefix(app: Sanic):\n    bp = Blueprint(\"test_text\", url_prefix=\"/test1\")\n\n    @bp.route(\"/\")\n    def handler(request):\n        return text(\"Hello\")\n\n    app.blueprint(bp)\n    request, response = app.test_client.get(\"/test1/\")\n\n    assert response.text == \"Hello\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'Hello'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_several_bp_with_url_prefix",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 190,
      "end_line_number": 208,
      "source_code": "def test_several_bp_with_url_prefix(app: Sanic):\n    bp = Blueprint(\"test_text\", url_prefix=\"/test1\")\n    bp2 = Blueprint(\"test_text2\", url_prefix=\"/test2\")\n\n    @bp.route(\"/\")\n    def handler(request):\n        return text(\"Hello\")\n\n    @bp2.route(\"/\")\n    def handler2(request):\n        return text(\"Hello2\")\n\n    app.blueprint(bp)\n    app.blueprint(bp2)\n    request, response = app.test_client.get(\"/test1/\")\n    assert response.text == \"Hello\"\n\n    request, response = app.test_client.get(\"/test2/\")\n    assert response.text == \"Hello2\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'Hello'",
        "assert response.text == 'Hello2'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_bp_with_host",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 211,
      "end_line_number": 230,
      "source_code": "def test_bp_with_host(app: Sanic):\n    bp = Blueprint(\"test_bp_host\", url_prefix=\"/test1\", host=\"example.com\")\n\n    @bp.route(\"/\")\n    def handler1(request):\n        return text(\"Hello\")\n\n    @bp.route(\"/\", host=\"sub.example.com\")\n    def handler2(request):\n        return text(\"Hello subdomain!\")\n\n    app.blueprint(bp)\n    headers = {\"Host\": \"example.com\"}\n\n    request, response = app.test_client.get(\"/test1/\", headers=headers)\n    assert response.text == \"Hello\"\n\n    headers = {\"Host\": \"sub.example.com\"}\n    request, response = app.test_client.get(\"/test1/\", headers=headers)\n    assert response.body == b\"Hello subdomain!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'Hello'",
        "assert response.body == b'Hello subdomain!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_several_bp_with_host",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 233,
      "end_line_number": 274,
      "source_code": "def test_several_bp_with_host(app: Sanic):\n    bp = Blueprint(\n        \"test_text\",\n        url_prefix=\"/test\",\n        host=\"example.com\",\n        strict_slashes=True,\n    )\n    bp2 = Blueprint(\n        \"test_text2\",\n        url_prefix=\"/test\",\n        host=\"sub.example.com\",\n        strict_slashes=True,\n    )\n\n    @bp.route(\"/\")\n    def handler(request):\n        return text(\"Hello\")\n\n    @bp2.route(\"/\")\n    def handler1(request):\n        return text(\"Hello2\")\n\n    @bp2.route(\"/other/\")\n    def handler2(request):\n        return text(\"Hello3\")\n\n    app.blueprint(bp)\n    app.blueprint(bp2)\n\n    assert bp.host == \"example.com\"\n    headers = {\"Host\": \"example.com\"}\n    request, response = app.test_client.get(\"/test/\", headers=headers)\n\n    assert response.text == \"Hello\"\n\n    assert bp2.host == \"sub.example.com\"\n    headers = {\"Host\": \"sub.example.com\"}\n    request, response = app.test_client.get(\"/test/\", headers=headers)\n\n    assert response.text == \"Hello2\"\n    request, response = app.test_client.get(\"/test/other/\", headers=headers)\n    assert response.text == \"Hello3\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert bp.host == 'example.com'",
        "assert response.text == 'Hello'",
        "assert bp2.host == 'sub.example.com'",
        "assert response.text == 'Hello2'",
        "assert response.text == 'Hello3'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_bp_with_host_list",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 277,
      "end_line_number": 308,
      "source_code": "def test_bp_with_host_list(app: Sanic):\n    bp = Blueprint(\n        \"test_bp_host\",\n        url_prefix=\"/test1\",\n        host=[\"example.com\", \"sub.example.com\"],\n    )\n\n    @bp.route(\"/\")\n    def handler1(request):\n        return text(\"Hello\")\n\n    @bp.route(\"/\", host=[\"sub1.example.com\"])\n    def handler2(request):\n        return text(\"Hello subdomain!\")\n\n    app.blueprint(bp)\n    headers = {\"Host\": \"example.com\"}\n    request, response = app.test_client.get(\"/test1/\", headers=headers)\n    assert response.text == \"Hello\"\n\n    headers = {\"Host\": \"sub.example.com\"}\n    request, response = app.test_client.get(\"/test1/\", headers=headers)\n    assert response.text == \"Hello\"\n\n    headers = {\"Host\": \"sub1.example.com\"}\n    request, response = app.test_client.get(\"/test1/\", headers=headers)\n\n    assert response.text == \"Hello subdomain!\"\n\n    route_names = [r.name for r in app.router.routes]\n    assert \"test_bp_with_host_list.test_bp_host.handler1\" in route_names\n    assert \"test_bp_with_host_list.test_bp_host.handler2\" in route_names",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'Hello'",
        "assert response.text == 'Hello'",
        "assert response.text == 'Hello subdomain!'",
        "assert 'test_bp_with_host_list.test_bp_host.handler1' in route_names",
        "assert 'test_bp_with_host_list.test_bp_host.handler2' in route_names"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_several_bp_with_host_list",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 311,
      "end_line_number": 360,
      "source_code": "def test_several_bp_with_host_list(app: Sanic):\n    bp = Blueprint(\n        \"test_text\",\n        url_prefix=\"/test\",\n        host=[\"example.com\", \"sub.example.com\"],\n    )\n    bp2 = Blueprint(\n        \"test_text2\",\n        url_prefix=\"/test\",\n        host=[\"sub1.example.com\", \"sub2.example.com\"],\n    )\n\n    @bp.route(\"/\")\n    def handler(request):\n        return text(\"Hello\")\n\n    @bp2.route(\"/\")\n    def handler1(request):\n        return text(\"Hello2\")\n\n    @bp2.route(\"/other/\")\n    def handler2(request):\n        return text(\"Hello3\")\n\n    app.blueprint(bp)\n    app.blueprint(bp2)\n\n    assert bp.host == [\"example.com\", \"sub.example.com\"]\n    headers = {\"Host\": \"example.com\"}\n    request, response = app.test_client.get(\"/test/\", headers=headers)\n    assert response.text == \"Hello\"\n\n    assert bp.host == [\"example.com\", \"sub.example.com\"]\n    headers = {\"Host\": \"sub.example.com\"}\n    request, response = app.test_client.get(\"/test/\", headers=headers)\n    assert response.text == \"Hello\"\n\n    assert bp2.host == [\"sub1.example.com\", \"sub2.example.com\"]\n    headers = {\"Host\": \"sub1.example.com\"}\n    request, response = app.test_client.get(\"/test/\", headers=headers)\n    assert response.text == \"Hello2\"\n    request, response = app.test_client.get(\"/test/other/\", headers=headers)\n    assert response.text == \"Hello3\"\n\n    assert bp2.host == [\"sub1.example.com\", \"sub2.example.com\"]\n    headers = {\"Host\": \"sub2.example.com\"}\n    request, response = app.test_client.get(\"/test/\", headers=headers)\n    assert response.text == \"Hello2\"\n    request, response = app.test_client.get(\"/test/other/\", headers=headers)\n    assert response.text == \"Hello3\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert bp.host == ['example.com', 'sub.example.com']",
        "assert response.text == 'Hello'",
        "assert bp.host == ['example.com', 'sub.example.com']",
        "assert response.text == 'Hello'",
        "assert bp2.host == ['sub1.example.com', 'sub2.example.com']",
        "assert response.text == 'Hello2'",
        "assert response.text == 'Hello3'",
        "assert bp2.host == ['sub1.example.com', 'sub2.example.com']",
        "assert response.text == 'Hello2'",
        "assert response.text == 'Hello3'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_bp_middleware",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 363,
      "end_line_number": 379,
      "source_code": "def test_bp_middleware(app: Sanic):\n    blueprint = Blueprint(\"test_bp_middleware\")\n\n    @blueprint.middleware(\"response\")\n    async def process_response(request, response):\n        return text(\"OK\")\n\n    @app.route(\"/\")\n    async def handler(request):\n        return text(\"FAIL\")\n\n    app.blueprint(blueprint)\n\n    request, response = app.test_client.get(\"/\")\n\n    assert response.status == 200\n    assert response.text == \"FAIL\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'FAIL'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_bp_middleware_with_route",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 382,
      "end_line_number": 402,
      "source_code": "def test_bp_middleware_with_route(app: Sanic):\n    blueprint = Blueprint(\"test_bp_middleware\")\n\n    @blueprint.middleware(\"response\")\n    async def process_response(request, response):\n        return text(\"OK\")\n\n    @app.route(\"/\")\n    async def handler(request):\n        return text(\"FAIL\")\n\n    @blueprint.route(\"/bp\")\n    async def bp_handler(request):\n        return text(\"FAIL\")\n\n    app.blueprint(blueprint)\n\n    request, response = app.test_client.get(\"/bp\")\n\n    assert response.status == 200\n    assert response.text == \"OK\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_bp_middleware_order",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 405,
      "end_line_number": 442,
      "source_code": "def test_bp_middleware_order(app: Sanic):\n    blueprint = Blueprint(\"test_bp_middleware_order\")\n    order = []\n\n    @blueprint.middleware(\"request\")\n    def mw_1(request):\n        order.append(1)\n\n    @blueprint.middleware(\"request\")\n    def mw_2(request):\n        order.append(2)\n\n    @blueprint.middleware(\"request\")\n    def mw_3(request):\n        order.append(3)\n\n    @blueprint.middleware(\"response\")\n    def mw_4(request, response):\n        order.append(6)\n\n    @blueprint.middleware(\"response\")\n    def mw_5(request, response):\n        order.append(5)\n\n    @blueprint.middleware(\"response\")\n    def mw_6(request, response):\n        order.append(4)\n\n    @blueprint.route(\"/\")\n    def process_response(request):\n        return text(\"OK\")\n\n    app.blueprint(blueprint)\n    order.clear()\n    request, response = app.test_client.get(\"/\")\n\n    assert response.status == 200\n    assert order == [1, 2, 3, 4, 5, 6]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert order == [1, 2, 3, 4, 5, 6]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_bp_exception_handler",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 445,
      "end_line_number": 474,
      "source_code": "def test_bp_exception_handler(app: Sanic):\n    blueprint = Blueprint(\"test_middleware\")\n\n    @blueprint.route(\"/1\")\n    def handler_1(request):\n        raise BadRequest(\"OK\")\n\n    @blueprint.route(\"/2\")\n    def handler_2(request):\n        raise ServerError(\"OK\")\n\n    @blueprint.route(\"/3\")\n    def handler_3(request):\n        raise NotFound(\"OK\")\n\n    @blueprint.exception(NotFound, ServerError)\n    def handler_exception(request, exception):\n        return text(\"OK\")\n\n    app.blueprint(blueprint)\n\n    request, response = app.test_client.get(\"/1\")\n    assert response.status == 400\n\n    request, response = app.test_client.get(\"/2\")\n    assert response.status == 200\n    assert response.text == \"OK\"\n\n    request, response = app.test_client.get(\"/3\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 400",
        "assert response.status == 200",
        "assert response.text == 'OK'",
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "blueprint.exception",
          "body": "@app.route('/')\ndef exception(request):\n    raise SanicExceptionTestException(\"You won't see me\")"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_bp_exception_handler_applied",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 477,
      "end_line_number": 504,
      "source_code": "def test_bp_exception_handler_applied(app: Sanic):\n    class Error(Exception):\n        pass\n\n    handled = Blueprint(\"handled\")\n    nothandled = Blueprint(\"nothandled\")\n\n    @handled.exception(Error)\n    def handle_error(req, e):\n        return text(\"handled {}\".format(e))\n\n    @handled.route(\"/ok\")\n    def ok(request):\n        raise Error(\"uh oh\")\n\n    @nothandled.route(\"/notok\")\n    def notok(request):\n        raise Error(\"uh oh\")\n\n    app.blueprint(handled)\n    app.blueprint(nothandled)\n\n    _, response = app.test_client.get(\"/ok\")\n    assert response.status == 200\n    assert response.text == \"handled uh oh\"\n\n    _, response = app.test_client.get(\"/notok\")\n    assert response.status == 500",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'handled uh oh'",
        "assert response.status == 500"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "handled.exception",
          "body": "@app.route('/')\ndef exception(request):\n    raise SanicExceptionTestException(\"You won't see me\")"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_bp_exception_handler_not_applied",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 507,
      "end_line_number": 526,
      "source_code": "def test_bp_exception_handler_not_applied(app: Sanic):\n    class Error(Exception):\n        pass\n\n    handled = Blueprint(\"handled\")\n    nothandled = Blueprint(\"nothandled\")\n\n    @handled.exception(Error)\n    def handle_error(req, e):\n        return text(\"handled {}\".format(e))\n\n    @nothandled.route(\"/notok\")\n    def notok(request):\n        raise Error(\"uh oh\")\n\n    app.blueprint(handled)\n    app.blueprint(nothandled)\n\n    _, response = app.test_client.get(\"/notok\")\n    assert response.status == 500",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "handled.exception",
          "body": "@app.route('/')\ndef exception(request):\n    raise SanicExceptionTestException(\"You won't see me\")"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_bp_listeners",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 529,
      "end_line_number": 563,
      "source_code": "def test_bp_listeners(app: Sanic):\n    app.route(\"/\")(lambda x: x)\n    blueprint = Blueprint(\"test_middleware\")\n\n    order = []\n\n    @blueprint.listener(\"before_server_start\")\n    def handler_1(sanic, loop):\n        order.append(1)\n\n    @blueprint.listener(\"after_server_start\")\n    def handler_2(sanic, loop):\n        order.append(2)\n\n    @blueprint.listener(\"after_server_start\")\n    def handler_3(sanic, loop):\n        order.append(3)\n\n    @blueprint.listener(\"before_server_stop\")\n    def handler_4(sanic, loop):\n        order.append(5)\n\n    @blueprint.listener(\"before_server_stop\")\n    def handler_5(sanic, loop):\n        order.append(4)\n\n    @blueprint.listener(\"after_server_stop\")\n    def handler_6(sanic, loop):\n        order.append(6)\n\n    app.blueprint(blueprint)\n\n    request, response = app.test_client.get(\"/\")\n\n    assert order == [1, 2, 3, 4, 5, 6]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert order == [1, 2, 3, 4, 5, 6]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_bp_static",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 566,
      "end_line_number": 579,
      "source_code": "def test_bp_static(app: Sanic):\n    current_file = inspect.getfile(inspect.currentframe())\n    with open(current_file, \"rb\") as file:\n        current_file_contents = file.read()\n\n    blueprint = Blueprint(\"test_static\")\n\n    blueprint.static(\"/testing.file\", current_file)\n\n    app.blueprint(blueprint)\n\n    request, response = app.test_client.get(\"/testing.file\")\n    assert response.status == 200\n    assert response.body == current_file_contents",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == current_file_contents"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_bp_static_content_type",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 583,
      "end_line_number": 601,
      "source_code": "def test_bp_static_content_type(app, file_name):\n    # This is done here, since no other test loads a file here\n    current_file = inspect.getfile(inspect.currentframe())\n    current_directory = os.path.dirname(os.path.abspath(current_file))\n    static_directory = os.path.join(current_directory, \"static\")\n\n    blueprint = Blueprint(\"test_static\")\n    blueprint.static(\n        \"/testing.file\",\n        get_file_path(static_directory, file_name),\n        content_type=\"text/html; charset=utf-8\",\n    )\n\n    app.blueprint(blueprint)\n\n    request, response = app.test_client.get(\"/testing.file\")\n    assert response.status == 200\n    assert response.body == get_file_content(static_directory, file_name)\n    assert response.headers[\"Content-Type\"] == \"text/html; charset=utf-8\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.html'])"
      ],
      "arguments": [
        "app",
        "file_name"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == get_file_content(static_directory, file_name)",
        "assert response.headers['Content-Type'] == 'text/html; charset=utf-8'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ]
    },
    {
      "name": "test_bp_shorthand",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 604,
      "end_line_number": 686,
      "source_code": "def test_bp_shorthand(app: Sanic):\n    blueprint = Blueprint(\"test_shorhand_routes\")\n    ev = asyncio.Event()\n\n    @blueprint.get(\"/get\")\n    def handler(request):\n        return text(\"OK\")\n\n    @blueprint.put(\"/put\")\n    def put_handler(request):\n        return text(\"OK\")\n\n    @blueprint.post(\"/post\")\n    def post_handler(request):\n        return text(\"OK\")\n\n    @blueprint.head(\"/head\")\n    def head_handler(request):\n        return text(\"OK\")\n\n    @blueprint.options(\"/options\")\n    def options_handler(request):\n        return text(\"OK\")\n\n    @blueprint.patch(\"/patch\")\n    def patch_handler(request):\n        return text(\"OK\")\n\n    @blueprint.delete(\"/delete\")\n    def delete_handler(request):\n        return text(\"OK\")\n\n    @blueprint.websocket(\"/ws/\", strict_slashes=True)\n    async def websocket_handler(request, ws):\n        ev.set()\n\n    app.blueprint(blueprint)\n\n    request, response = app.test_client.get(\"/get\")\n    assert response.body == b\"OK\"\n\n    request, response = app.test_client.post(\"/get\")\n    assert response.status == 405\n\n    request, response = app.test_client.put(\"/put\")\n    assert response.body == b\"OK\"\n\n    request, response = app.test_client.get(\"/post\")\n    assert response.status == 405\n\n    request, response = app.test_client.post(\"/post\")\n    assert response.body == b\"OK\"\n\n    request, response = app.test_client.get(\"/post\")\n    assert response.status == 405\n\n    request, response = app.test_client.head(\"/head\")\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/head\")\n    assert response.status == 405\n\n    request, response = app.test_client.options(\"/options\")\n    assert response.body == b\"OK\"\n\n    request, response = app.test_client.get(\"/options\")\n    assert response.status == 405\n\n    request, response = app.test_client.patch(\"/patch\")\n    assert response.body == b\"OK\"\n\n    request, response = app.test_client.get(\"/patch\")\n    assert response.status == 405\n\n    request, response = app.test_client.delete(\"/delete\")\n    assert response.body == b\"OK\"\n\n    request, response = app.test_client.get(\"/delete\")\n    assert response.status == 405\n\n    request, response = app.test_client.websocket(\"/ws/\")\n    assert response.opened is True\n    assert ev.is_set()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.body == b'OK'",
        "assert response.status == 405",
        "assert response.body == b'OK'",
        "assert response.status == 405",
        "assert response.body == b'OK'",
        "assert response.status == 405",
        "assert response.status == 200",
        "assert response.status == 405",
        "assert response.body == b'OK'",
        "assert response.status == 405",
        "assert response.body == b'OK'",
        "assert response.status == 405",
        "assert response.body == b'OK'",
        "assert response.status == 405",
        "assert response.opened is True",
        "assert ev.is_set()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "blueprint.patch('/patch')",
        "app.test_client.patch('/patch')"
      ],
      "methods_under_test": [
        {
          "name": "blueprint.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "blueprint.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "blueprint.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "blueprint.head",
          "body": "def head(self, request):\n    return text('', headers={'method': 'HEAD'})"
        },
        {
          "name": "blueprint.options",
          "body": "def options(self, request):\n    return text('', headers={'method': 'OPTIONS'})"
        },
        {
          "name": "blueprint.patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "blueprint.delete",
          "body": "def delete(self, request):\n    return text('I am delete method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.head",
          "body": "def head(self, request):\n    return text('', headers={'method': 'HEAD'})"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.options",
          "body": "def options(self, request):\n    return text('', headers={'method': 'OPTIONS'})"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.delete",
          "body": "def delete(self, request):\n    return text('I am delete method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_bp_group",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 689,
      "end_line_number": 726,
      "source_code": "def test_bp_group(app: Sanic):\n    deep_0 = Blueprint(\"deep_0\", url_prefix=\"/deep\")\n    deep_1 = Blueprint(\"deep_1\", url_prefix=\"/deep1\")\n\n    @deep_0.route(\"/\")\n    def handler(request):\n        return text(\"D0_OK\")\n\n    @deep_1.route(\"/bottom\")\n    def bottom_handler(request):\n        return text(\"D1B_OK\")\n\n    mid_0 = Blueprint.group(deep_0, deep_1, url_prefix=\"/mid\")\n    mid_1 = Blueprint(\"mid_tier\", url_prefix=\"/mid1\")\n\n    @mid_1.route(\"/\")\n    def handler1(request):\n        return text(\"M1_OK\")\n\n    top = Blueprint.group(mid_0, mid_1)\n\n    app.blueprint(top)\n\n    @app.route(\"/\")\n    def handler2(request):\n        return text(\"TOP_OK\")\n\n    request, response = app.test_client.get(\"/\")\n    assert response.text == \"TOP_OK\"\n\n    request, response = app.test_client.get(\"/mid1\")\n    assert response.text == \"M1_OK\"\n\n    request, response = app.test_client.get(\"/mid/deep\")\n    assert response.text == \"D0_OK\"\n\n    request, response = app.test_client.get(\"/mid/deep1/bottom\")\n    assert response.text == \"D1B_OK\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'TOP_OK'",
        "assert response.text == 'M1_OK'",
        "assert response.text == 'D0_OK'",
        "assert response.text == 'D1B_OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_bp_group_with_default_url_prefix",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 729,
      "end_line_number": 771,
      "source_code": "def test_bp_group_with_default_url_prefix(app: Sanic):\n    from sanic.response import json\n\n    bp_resources = Blueprint(\"bp_resources\")\n\n    @bp_resources.get(\"/\")\n    def list_resources_handler(request):\n        resource = {}\n        return json([resource])\n\n    bp_resource = Blueprint(\"bp_resource\", url_prefix=\"/<resource_id>\")\n\n    @bp_resource.get(\"/\")\n    def get_resource_hander(request, resource_id):\n        resource = {\"resource_id\": resource_id}\n        return json(resource)\n\n    bp_resources_group = Blueprint.group(\n        bp_resources, bp_resource, url_prefix=\"/resources\"\n    )\n    bp_api_v1 = Blueprint(\"bp_api_v1\")\n\n    @bp_api_v1.get(\"/info\")\n    def api_v1_info(request):\n        return text(\"api_version: v1\")\n\n    bp_api_v1_group = Blueprint.group(\n        bp_api_v1, bp_resources_group, url_prefix=\"/v1\"\n    )\n    bp_api_group = Blueprint.group(bp_api_v1_group, url_prefix=\"/api\")\n    app.blueprint(bp_api_group)\n\n    request, response = app.test_client.get(\"/api/v1/info\")\n    assert response.text == \"api_version: v1\"\n\n    request, response = app.test_client.get(\"/api/v1/resources\")\n    assert response.json == [{}]\n\n    from uuid import uuid4\n\n    resource_id = str(uuid4())\n    request, response = app.test_client.get(f\"/api/v1/resources/{resource_id}\")\n    assert response.json == {\"resource_id\": resource_id}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'api_version: v1'",
        "assert response.json == [{}]",
        "assert response.json == {'resource_id': resource_id}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "bp_resources.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp_resource.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp_api_v1.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_blueprint_middleware_with_args",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 774,
      "end_line_number": 801,
      "source_code": "def test_blueprint_middleware_with_args(app: Sanic):\n    bp = Blueprint(name=\"with_args_bp\", url_prefix=\"/wa\")\n\n    @bp.middleware\n    def middleware_with_no_tag(request: Request):\n        if request.headers.get(\"content-type\") == \"application/json\":\n            request.headers[\"accepts\"] = \"plain/text\"\n        else:\n            request.headers[\"accepts\"] = \"application/json\"\n\n    @bp.route(\"/\")\n    def default_route(request):\n        if request.headers.get(\"accepts\") == \"application/json\":\n            return json({\"test\": \"value\"})\n        else:\n            return text(\"value\")\n\n    app.blueprint(bp)\n\n    _, response = app.test_client.get(\n        \"/wa\", headers={\"content-type\": \"application/json\"}\n    )\n    assert response.text == \"value\"\n\n    _, response = app.test_client.get(\n        \"/wa\", headers={\"content-type\": \"plain/text\"}\n    )\n    assert response.json.get(\"test\") == \"value\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'value'",
        "assert response.json.get('test') == 'value'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response.json.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "request.headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "request.headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_static_blueprint_name",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 805,
      "end_line_number": 829,
      "source_code": "def test_static_blueprint_name(static_file_directory, file_name):\n    app = Sanic(\"app\")\n    current_file = inspect.getfile(inspect.currentframe())\n    with open(current_file, \"rb\") as file:\n        file.read()\n\n    bp = Blueprint(name=\"static\", url_prefix=\"/static\", strict_slashes=False)\n\n    bp.static(\n        \"/test.file/\",\n        get_file_path(static_file_directory, file_name),\n        name=\"static.testing\",\n        strict_slashes=True,\n    )\n\n    app.blueprint(bp)\n\n    uri = app.url_for(\"static\", name=\"static.testing\")\n    assert uri == \"/static/test.file/\"\n\n    _, response = app.test_client.get(\"/static/test.file\")\n    assert response.status == 404\n\n    _, response = app.test_client.get(\"/static/test.file/\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file'])"
      ],
      "arguments": [
        "static_file_directory",
        "file_name"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert uri == '/static/test.file/'",
        "assert response.status == 404",
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        }
      ]
    },
    {
      "name": "test_static_blueprintp_mw",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 833,
      "end_line_number": 860,
      "source_code": "def test_static_blueprintp_mw(app: Sanic, static_file_directory, file_name):\n    current_file = inspect.getfile(inspect.currentframe())  # type: ignore\n    with open(current_file, \"rb\") as file:\n        file.read()\n\n    triggered = False\n\n    bp = Blueprint(name=\"test_mw\", url_prefix=\"\")\n\n    @bp.middleware(\"request\")\n    def bp_mw1(request):\n        nonlocal triggered\n        triggered = True\n\n    bp.static(\n        \"/test.file\",\n        get_file_path(static_file_directory, file_name),\n        strict_slashes=True,\n        name=\"static\",\n    )\n\n    app.blueprint(bp)\n\n    uri = app.url_for(\"test_mw.static\")\n    assert uri == \"/test.file\"\n\n    _, response = app.test_client.get(\"/test.file\")\n    assert triggered is True",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file'])"
      ],
      "arguments": [
        "app",
        "static_file_directory",
        "file_name"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert uri == '/test.file'",
        "assert triggered is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        }
      ]
    },
    {
      "name": "test_websocket_route",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 863,
      "end_line_number": 877,
      "source_code": "def test_websocket_route(app: Sanic):\n    event = asyncio.Event()\n\n    async def websocket_handler(request, ws):\n        assert ws.subprotocol is None\n        event.set()\n\n    bp = Blueprint(name=\"handler\", url_prefix=\"/ws\")\n    bp.add_websocket_route(websocket_handler, \"/test\", name=\"test\")\n\n    app.blueprint(bp)\n\n    _, response = app.test_client.websocket(\"/ws/test\")\n    assert response.opened is True\n    assert event.is_set()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.opened is True",
        "assert event.is_set()",
        "assert ws.subprotocol is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_duplicate_blueprint",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 880,
      "end_line_number": 893,
      "source_code": "def test_duplicate_blueprint(app: Sanic):\n    bp_name = \"bp\"\n    bp = Blueprint(bp_name)\n    bp1 = Blueprint(bp_name)\n\n    app.blueprint(bp)\n\n    with pytest.raises(AssertionError) as excinfo:\n        app.blueprint(bp1)\n\n    assert str(excinfo.value) == (\n        f'A blueprint with the name \"{bp_name}\" is already registered.  '\n        \"Blueprint names must be unique.\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(excinfo.value) == f'A blueprint with the name \"{bp_name}\" is already registered.  Blueprint names must be unique.'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_strict_slashes_behavior_adoption",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 896,
      "end_line_number": 938,
      "source_code": "def test_strict_slashes_behavior_adoption():\n    app = Sanic(\"app\")\n    app.strict_slashes = True\n    bp = Blueprint(\"bp\")\n    bp2 = Blueprint(\"bp2\", strict_slashes=False)\n\n    @app.get(\"/test\")\n    def handler_test(request):\n        return text(\"Test\")\n\n    @app.get(\"/f1\", strict_slashes=False)\n    def f1(request):\n        return text(\"f1\")\n\n    @bp.get(\"/one\", strict_slashes=False)\n    def one(request):\n        return text(\"one\")\n\n    @bp.get(\"/second\")\n    def second(request):\n        return text(\"second\")\n\n    @bp2.get(\"/third\")\n    def third(request):\n        return text(\"third\")\n\n    app.blueprint(bp)\n    app.blueprint(bp2)\n\n    assert app.test_client.get(\"/test\")[1].status == 200\n    assert app.test_client.get(\"/test/\")[1].status == 404\n\n    assert app.test_client.get(\"/one\")[1].status == 200\n    assert app.test_client.get(\"/one/\")[1].status == 200\n\n    assert app.test_client.get(\"/second\")[1].status == 200\n    assert app.test_client.get(\"/second/\")[1].status == 404\n\n    assert app.test_client.get(\"/third\")[1].status == 200\n    assert app.test_client.get(\"/third/\")[1].status == 200\n\n    assert app.test_client.get(\"/f1\")[1].status == 200\n    assert app.test_client.get(\"/f1/\")[1].status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.test_client.get('/test')[1].status == 200",
        "assert app.test_client.get('/test/')[1].status == 404",
        "assert app.test_client.get('/one')[1].status == 200",
        "assert app.test_client.get('/one/')[1].status == 200",
        "assert app.test_client.get('/second')[1].status == 200",
        "assert app.test_client.get('/second/')[1].status == 404",
        "assert app.test_client.get('/third')[1].status == 200",
        "assert app.test_client.get('/third/')[1].status == 200",
        "assert app.test_client.get('/f1')[1].status == 200",
        "assert app.test_client.get('/f1/')[1].status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp2.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_blueprint_group_versioning",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 941,
      "end_line_number": 982,
      "source_code": "def test_blueprint_group_versioning():\n    app = Sanic(name=\"blueprint-group-test\")\n\n    bp1 = Blueprint(name=\"bp1\", url_prefix=\"/bp1\")\n    bp2 = Blueprint(name=\"bp2\", url_prefix=\"/bp2\", version=2)\n\n    bp3 = Blueprint(name=\"bp3\", url_prefix=\"/bp3\")\n\n    @bp3.get(\"/r1\")\n    async def bp3_r1(request):\n        return json({\"from\": \"bp3/r1\"})\n\n    @bp1.get(\"/pre-group\")\n    async def pre_group(request):\n        return json({\"from\": \"bp1/pre-group\"})\n\n    group = Blueprint.group([bp1, bp2], url_prefix=\"/group1\", version=1)\n\n    group2 = Blueprint.group([bp3])\n\n    @bp1.get(\"/r1\")\n    async def r1(request):\n        return json({\"from\": \"bp1/r1\"})\n\n    @bp2.get(\"/r2\")\n    async def r2(request):\n        return json({\"from\": \"bp2/r2\"})\n\n    @bp2.get(\"/r3\", version=3)\n    async def r3(request):\n        return json({\"from\": \"bp2/r3\"})\n\n    app.blueprint([group, group2])\n\n    assert app.test_client.get(\"/v1/group1/bp1/r1/\")[1].status == 200\n    assert app.test_client.get(\"/v2/group1/bp2/r2\")[1].status == 200\n    assert app.test_client.get(\"/v1/group1/bp1/pre-group\")[1].status == 200\n    assert app.test_client.get(\"/v3/group1/bp2/r3\")[1].status == 200\n    assert app.test_client.get(\"/bp3/r1\")[1].status == 200\n\n    assert group.version == 1\n    assert group2.strict_slashes is None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.test_client.get('/v1/group1/bp1/r1/')[1].status == 200",
        "assert app.test_client.get('/v2/group1/bp2/r2')[1].status == 200",
        "assert app.test_client.get('/v1/group1/bp1/pre-group')[1].status == 200",
        "assert app.test_client.get('/v3/group1/bp2/r3')[1].status == 200",
        "assert app.test_client.get('/bp3/r1')[1].status == 200",
        "assert group.version == 1",
        "assert group2.strict_slashes is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "bp3.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp1.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp1.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp2.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp2.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_blueprint_group_strict_slashes",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 985,
      "end_line_number": 1033,
      "source_code": "def test_blueprint_group_strict_slashes():\n    app = Sanic(name=\"blueprint-group-test\")\n    bp1 = Blueprint(name=\"bp1\", url_prefix=None, strict_slashes=False)\n\n    bp2 = Blueprint(\n        name=\"bp2\", version=3, url_prefix=\"/bp2\", strict_slashes=None\n    )\n\n    bp3 = Blueprint(\n        name=\"bp3\", version=None, url_prefix=\"/bp3/\", strict_slashes=None\n    )\n\n    @bp1.get(\"/r1\")\n    async def bp1_r1(request):\n        return json({\"from\": \"bp1/r1\"})\n\n    @bp2.get(\"/r1\")\n    async def bp2_r1(request):\n        return json({\"from\": \"bp2/r1\"})\n\n    @bp2.get(\"/r2/\")\n    async def bp2_r2(request):\n        return json({\"from\": \"bp2/r2\"})\n\n    @bp3.get(\"/r1\")\n    async def bp3_r1(request):\n        return json({\"from\": \"bp3/r1\"})\n\n    group = Blueprint.group(\n        [bp1, bp2],\n        url_prefix=\"/slash-check/\",\n        version=1.3,\n        strict_slashes=True,\n    )\n\n    group2 = Blueprint.group(\n        [bp3], url_prefix=\"/other-prefix/\", version=\"v2\", strict_slashes=False\n    )\n\n    app.blueprint(group)\n    app.blueprint(group2)\n\n    assert app.test_client.get(\"/v1.3/slash-check/r1\")[1].status == 200\n    assert app.test_client.get(\"/v1.3/slash-check/r1/\")[1].status == 200\n    assert app.test_client.get(\"/v3/slash-check/bp2/r1\")[1].status == 200\n    assert app.test_client.get(\"/v3/slash-check/bp2/r1/\")[1].status == 404\n    assert app.test_client.get(\"/v3/slash-check/bp2/r2\")[1].status == 404\n    assert app.test_client.get(\"/v3/slash-check/bp2/r2/\")[1].status == 200\n    assert app.test_client.get(\"/v2/other-prefix/bp3/r1\")[1].status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.test_client.get('/v1.3/slash-check/r1')[1].status == 200",
        "assert app.test_client.get('/v1.3/slash-check/r1/')[1].status == 200",
        "assert app.test_client.get('/v3/slash-check/bp2/r1')[1].status == 200",
        "assert app.test_client.get('/v3/slash-check/bp2/r1/')[1].status == 404",
        "assert app.test_client.get('/v3/slash-check/bp2/r2')[1].status == 404",
        "assert app.test_client.get('/v3/slash-check/bp2/r2/')[1].status == 200",
        "assert app.test_client.get('/v2/other-prefix/bp3/r1')[1].status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "bp1.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp2.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp2.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp3.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_blueprint_registered_multiple_apps",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 1036,
      "end_line_number": 1050,
      "source_code": "def test_blueprint_registered_multiple_apps():\n    app1 = Sanic(\"app1\")\n    app2 = Sanic(\"app2\")\n    bp = Blueprint(\"bp\")\n\n    @bp.get(\"/\")\n    async def handler(request):\n        return text(request.route.name)\n\n    app1.blueprint(bp)\n    app2.blueprint(bp)\n\n    for app in (app1, app2):\n        _, response = app.test_client.get(\"/\")\n        assert response.text == f\"{app.name}.bp.handler\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == f'{app.name}.bp.handler'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "bp.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_bp_set_attribute_warning",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 1053,
      "end_line_number": 1060,
      "source_code": "def test_bp_set_attribute_warning():\n    bp = Blueprint(\"bp\")\n    message = (\n        \"Setting variables on Blueprint instances is not allowed. You should \"\n        \"change your Blueprint instance to use instance.ctx.foo instead.\"\n    )\n    with pytest.raises(AttributeError, match=message):\n        bp.foo = 1",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_early_registration",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 1063,
      "end_line_number": 1088,
      "source_code": "def test_early_registration(app: Sanic):\n    assert len(app.router.routes) == 0\n\n    bp = Blueprint(\"bp\")\n\n    @bp.get(\"/one\")\n    async def one(_):\n        return text(\"one\")\n\n    app.blueprint(bp)\n\n    assert len(app.router.routes) == 1\n\n    @bp.get(\"/two\")\n    async def two(_):\n        return text(\"two\")\n\n    @bp.get(\"/three\")\n    async def three(_):\n        return text(\"three\")\n\n    assert len(app.router.routes) == 3\n\n    for path in (\"one\", \"two\", \"three\"):\n        _, response = app.test_client.get(f\"/{path}\")\n        assert response.text == path",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(app.router.routes) == 0",
        "assert len(app.router.routes) == 1",
        "assert len(app.router.routes) == 3",
        "assert response.text == path"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "bp.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_remove_double_slashes_defined_on_bp",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 1091,
      "end_line_number": 1100,
      "source_code": "def test_remove_double_slashes_defined_on_bp(app: Sanic):\n    bp = Blueprint(\"bp\", url_prefix=\"/foo/\", strict_slashes=True)\n\n    @bp.get(\"/\")\n    async def handler(_): ...\n\n    app.blueprint(bp)\n    app.router.finalize()\n\n    assert app.router.routes[0].path == \"foo/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.router.routes[0].path == 'foo/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "bp.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_remove_double_slashes_defined_on_register",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 1103,
      "end_line_number": 1112,
      "source_code": "def test_remove_double_slashes_defined_on_register(app: Sanic):\n    bp = Blueprint(\"bp\")\n\n    @bp.get(\"/\")\n    async def index(_): ...\n\n    app.blueprint(bp, url_prefix=\"/foo/\", strict_slashes=True)\n    app.router.finalize()\n\n    assert app.router.routes[0].path == \"foo/\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.router.routes[0].path == 'foo/'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "bp.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_blueprint_copy_returns_blueprint_with_the_name_of_original_blueprint",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 1115,
      "end_line_number": 1125,
      "source_code": "def test_blueprint_copy_returns_blueprint_with_the_name_of_original_blueprint(\n    app: Sanic,\n):\n    # arrange\n    bp = Blueprint(\"bp\")\n\n    # act\n    actual = bp.copy(\"new_bp_name\")\n\n    # assert\n    assert bp.name == actual.copied_from",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert bp.name == actual.copied_from"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_blueprint_copy_returns_blueprint_with_overwritten_properties",
      "module": "test_blueprints",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprints.py",
      "line_number": 1128,
      "end_line_number": 1152,
      "source_code": "def test_blueprint_copy_returns_blueprint_with_overwritten_properties(\n    app: Sanic,\n):\n    # arrange\n    bp = Blueprint(\"bp\")\n    to_override_attrs = expected = dict(\n        url_prefix=\"v2\",\n        version=\"v2\",\n        version_prefix=\"v2\",\n        allow_route_overwrite=True,\n        strict_slashes=True,\n    )\n\n    # act\n    actual = bp.copy(\n        \"new_bp_name\",\n        **to_override_attrs,\n    )\n\n    # assert\n    assert all(\n        value == getattr(actual, key)\n        for key, value in expected.items()\n        if hasattr(actual, key)\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "inspect",
        "os",
        "pytest",
        "sanic.app.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.response.json",
        "uuid.uuid4"
      ],
      "fixtures": [],
      "assertions": [
        "assert all((value == getattr(actual, key) for (key, value) in expected.items() if hasattr(actual, key)))"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_dev",
      "module": "test_prepare",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_prepare.py",
      "line_number": 30,
      "end_line_number": 34,
      "source_code": "def test_dev(app: Sanic):\n    app.prepare(dev=True)\n\n    assert app.state.is_debug\n    assert app.state.auto_reload",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "pathlib.Path",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.application.state.ApplicationServerInfo"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.state.is_debug",
        "assert app.state.auto_reload"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_motd_display",
      "module": "test_prepare",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_prepare.py",
      "line_number": 37,
      "end_line_number": 41,
      "source_code": "def test_motd_display(app: Sanic):\n    app.prepare(motd_display={\"foo\": \"bar\"})\n\n    assert app.config.MOTD_DISPLAY[\"foo\"] == \"bar\"\n    del app.config.MOTD_DISPLAY[\"foo\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "pathlib.Path",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.application.state.ApplicationServerInfo"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.config.MOTD_DISPLAY['foo'] == 'bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_reload_dir",
      "module": "test_prepare",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_prepare.py",
      "line_number": 45,
      "end_line_number": 59,
      "source_code": "def test_reload_dir(app: Sanic, dirs, caplog):\n    messages = []\n    with caplog.at_level(logging.WARNING):\n        app.prepare(reload_dir=dirs)\n\n    if isinstance(dirs, str):\n        dirs = (dirs,)\n        for d in dirs:\n            assert Path(d) in app.state.reload_dirs\n            messages.append(\n                f\"Directory {d} could not be located\",\n            )\n\n    for message in messages:\n        assert (\"sanic.root\", logging.WARNING, message) in caplog.record_tuples",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('dirs', ('./foo', ('./foo', './bar')))"
      ],
      "arguments": [
        "app",
        "dirs",
        "caplog"
      ],
      "imports": [
        "logging",
        "os",
        "pathlib.Path",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.application.state.ApplicationServerInfo"
      ],
      "fixtures": [],
      "assertions": [
        "assert ('sanic.root', logging.WARNING, message) in caplog.record_tuples",
        "assert Path(d) in app.state.reload_dirs"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_fast",
      "module": "test_prepare",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_prepare.py",
      "line_number": 62,
      "end_line_number": 85,
      "source_code": "def test_fast(app: Sanic, caplog):\n    @app.after_server_start\n    async def stop(app, _):\n        app.stop()\n\n    try:\n        workers = len(os.sched_getaffinity(0))\n    except AttributeError:\n        workers = os.cpu_count() or 1\n\n    with caplog.at_level(logging.INFO):\n        app.prepare(fast=True)\n\n    assert app.state.fast\n    assert app.state.workers == workers\n\n    messages = [m[2] for m in caplog.record_tuples]\n\n    if workers == 1:\n        worker_fragment = \"single worker\"\n    else:\n        worker_fragment = f\"w/ {workers} workers\"\n\n    assert f\"mode: production, goin' fast {worker_fragment}\" in messages",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "caplog"
      ],
      "imports": [
        "logging",
        "os",
        "pathlib.Path",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.application.state.ApplicationServerInfo"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.state.fast",
        "assert app.state.workers == workers",
        "assert f\"mode: production, goin' fast {worker_fragment}\" in messages"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        }
      ]
    },
    {
      "name": "test_no_request_id_not_called",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 14,
      "end_line_number": 19,
      "source_code": "def test_no_request_id_not_called(monkeypatch):\n    monkeypatch.setattr(uuid, \"uuid4\", Mock())\n    request = Request(b\"/\", {}, None, \"GET\", None, None)\n\n    assert request._id is None\n    uuid.uuid4.assert_not_called()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert request._id is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_request_id_generates_from_request",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 22,
      "end_line_number": 30,
      "source_code": "def test_request_id_generates_from_request(monkeypatch):\n    monkeypatch.setattr(Request, \"generate_id\", Mock())\n    Request.generate_id.return_value = 1\n    request = Request(b\"/\", {}, None, \"GET\", None, Mock())\n    request.app.config.REQUEST_ID_HEADER = \"foo\"\n\n    for _ in range(10):\n        request.id\n    Request.generate_id.assert_called_once_with(request)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_request_id_defaults_uuid",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 33,
      "end_line_number": 40,
      "source_code": "def test_request_id_defaults_uuid():\n    request = Request(b\"/\", {}, None, \"GET\", None, Mock())\n    request.app.config.REQUEST_ID_HEADER = \"foo\"\n\n    assert isinstance(request.id, UUID)\n\n    # Makes sure that it has been cached and not called multiple times\n    assert request.id == request.id == request._id",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(request.id, UUID)",
        "assert request.id == request.id == request._id"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_name_none",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 43,
      "end_line_number": 46,
      "source_code": "def test_name_none():\n    request = Request(b\"/\", {}, None, \"GET\", None, None)\n\n    assert request.name is None",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.name is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_name_from_route",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 49,
      "end_line_number": 54,
      "source_code": "def test_name_from_route():\n    request = Request(b\"/\", {}, None, \"GET\", None, None)\n    route = Mock()\n    request.route = route\n\n    assert request.name == route.name",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.name == route.name"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_name_from_set",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 57,
      "end_line_number": 61,
      "source_code": "def test_name_from_set():\n    request = Request(b\"/\", {}, None, \"GET\", None, None)\n    request._name = \"foo\"\n\n    assert request.name == \"foo\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.name == 'foo'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_request_id",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 72,
      "end_line_number": 83,
      "source_code": "def test_request_id(request_id, expected_type):\n    app = Sanic(\"req-generator\")\n\n    @app.get(\"/\")\n    async def get(request):\n        return response.empty()\n\n    request, _ = app.test_client.get(\n        \"/\", headers={\"X-REQUEST-ID\": f\"{request_id}\"}\n    )\n    assert request.id == request_id\n    assert type(request.id) == expected_type",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('request_id,expected_type', ((99, int), (uuid4(), UUID), ('foo', str)))"
      ],
      "arguments": [
        "request_id",
        "expected_type"
      ],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.id == request_id",
        "assert type(request.id) == expected_type"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_custom_generator",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 86,
      "end_line_number": 103,
      "source_code": "def test_custom_generator():\n    REQUEST_ID = 99\n\n    class FooRequest(Request):\n        @classmethod\n        def generate_id(cls, request):\n            return int(request.headers[\"some-other-request-id\"]) * 2\n\n    app = Sanic(\"req-generator\", request_class=FooRequest)\n\n    @app.get(\"/\")\n    async def get(request):\n        return response.empty()\n\n    request, _ = app.test_client.get(\n        \"/\", headers={\"SOME-OTHER-REQUEST-ID\": f\"{REQUEST_ID}\"}\n    )\n    assert request.id == REQUEST_ID * 2",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.id == REQUEST_ID * 2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_route_assigned_to_request",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 106,
      "end_line_number": 112,
      "source_code": "def test_route_assigned_to_request(app):\n    @app.get(\"/\")\n    async def get(request):\n        return response.empty()\n\n    request, _ = app.test_client.get(\"/\")\n    assert request.route is list(app.router.routes)[0]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.route is list(app.router.routes)[0]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_protocol_attribute",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 115,
      "end_line_number": 127,
      "source_code": "def test_protocol_attribute(app):\n    retrieved = None\n\n    @app.get(\"/\")\n    async def get(request):\n        nonlocal retrieved\n        retrieved = request.protocol\n        return response.empty()\n\n    headers = {\"Connection\": \"keep-alive\"}\n    _ = app.test_client.get(\"/\", headers=headers)\n\n    assert isinstance(retrieved, HttpProtocol)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(retrieved, HttpProtocol)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_ipv6_address_is_not_wrapped",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 130,
      "end_line_number": 145,
      "source_code": "def test_ipv6_address_is_not_wrapped(app):\n    @app.get(\"/\")\n    async def get(request):\n        return response.json(\n            {\n                \"client_ip\": request.conn_info.client_ip,\n                \"client\": request.conn_info.client,\n            }\n        )\n\n    request, resp = app.test_client.get(\"/\", host=\"::1\")\n\n    assert request.route is list(app.router.routes)[0]\n    assert resp.json[\"client\"] == \"[::1]\"\n    assert resp.json[\"client_ip\"] == \"::1\"\n    assert request.ip == \"::1\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.route is list(app.router.routes)[0]",
        "assert resp.json['client'] == '[::1]'",
        "assert resp.json['client_ip'] == '::1'",
        "assert request.ip == '::1'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_request_accept",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 148,
      "end_line_number": 195,
      "source_code": "def test_request_accept():\n    app = Sanic(\"req-generator\")\n\n    @app.get(\"/\")\n    async def get(request):\n        return response.empty()\n\n    header_value = \"text/plain;format=flowed, text/plain, text/*, */*\"\n    request, _ = app.test_client.get(\n        \"/\",\n        headers={\"Accept\": header_value},\n    )\n    assert str(request.accept) == header_value\n    match = request.accept.match(\n        \"*/*;format=flowed\",\n        \"text/plain;format=flowed\",\n        \"text/plain\",\n        \"text/*\",\n        \"*/*\",\n    )\n    assert match == \"*/*;format=flowed\"\n    assert match.header.mime == \"text/plain\"\n    assert match.header.params == {\"format\": \"flowed\"}\n\n    header_value = (\n        \"text/plain; q=0.5,   text/html, text/x-dvi; q=0.8, text/x-c\"\n    )\n    request, _ = app.test_client.get(\n        \"/\",\n        headers={\"Accept\": header_value},\n    )\n    assert [str(i) for i in request.accept] == [\n        \"text/html\",\n        \"text/x-c\",\n        \"text/x-dvi;q=0.8\",\n        \"text/plain;q=0.5\",\n    ]\n    match = request.accept.match(\n        \"application/json\",\n        \"text/plain\",  # Has lower q in accept header\n        \"text/html;format=flowed\",  # Params mismatch\n        \"text/*\",  # Matches\n        \"*/*\",\n    )\n    assert match == \"text/*\"\n    assert match.header.mime == \"text/html\"\n    assert match.header.q == 1.0\n    assert not match.header.params",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(request.accept) == header_value",
        "assert match == '*/*;format=flowed'",
        "assert match.header.mime == 'text/plain'",
        "assert match.header.params == {'format': 'flowed'}",
        "assert [str(i) for i in request.accept] == ['text/html', 'text/x-c', 'text/x-dvi;q=0.8', 'text/plain;q=0.5']",
        "assert match == 'text/*'",
        "assert match.header.mime == 'text/html'",
        "assert match.header.q == 1.0",
        "assert not match.header.params"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_bad_url_parse",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 198,
      "end_line_number": 209,
      "source_code": "def test_bad_url_parse():\n    message = \"Bad URL: my.redacted-domain.com:443\"\n    with pytest.raises(BadURL, match=message):\n        Request(\n            b\"my.redacted-domain.com:443\",\n            Mock(),\n            Mock(),\n            Mock(),\n            Mock(),\n            Mock(),\n            Mock(),\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_request_scope_raises_exception_when_no_asgi",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 212,
      "end_line_number": 222,
      "source_code": "def test_request_scope_raises_exception_when_no_asgi():\n    app = Sanic(\"no_asgi\")\n\n    @app.get(\"/\")\n    async def get(request):\n        return request.scope\n\n    request, response = app.test_client.get(\"/\")\n    assert response.status == 500\n    with pytest.raises(NotImplementedError):\n        _ = request.scope",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_cannot_get_request_outside_of_cycle",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 238,
      "end_line_number": 240,
      "source_code": "def test_cannot_get_request_outside_of_cycle():\n    with pytest.raises(SanicException, match=\"No current request\"):\n        Request.get_current()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_get_current_request",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 243,
      "end_line_number": 249,
      "source_code": "def test_get_current_request(app):\n    @app.get(\"/\")\n    async def get(request):\n        return response.json({\"same\": request is Request.get_current()})\n\n    _, resp = app.test_client.get(\"/\")\n    assert resp.json[\"same\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.json['same']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_request_stream_id",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 252,
      "end_line_number": 261,
      "source_code": "def test_request_stream_id(app):\n    @app.get(\"/\")\n    async def get(request):\n        try:\n            request.stream_id\n        except Exception as e:\n            return response.text(str(e))\n\n    _, resp = app.test_client.get(\"/\")\n    assert resp.text == \"Stream ID is only a property of a HTTP/3 request\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.text == 'Stream ID is only a property of a HTTP/3 request'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_request_safe",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 276,
      "end_line_number": 278,
      "source_code": "def test_request_safe(method, safe):\n    request = Request(b\"/\", {}, None, method, None, None)\n    assert request.is_safe is safe",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('method,safe', (('DELETE', False), ('GET', True), ('HEAD', True), ('OPTIONS', True), ('PATCH', False), ('POST', False), ('PUT', False)))"
      ],
      "arguments": [
        "method",
        "safe"
      ],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.is_safe is safe"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_request_idempotent",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 293,
      "end_line_number": 295,
      "source_code": "def test_request_idempotent(method, idempotent):\n    request = Request(b\"/\", {}, None, method, None, None)\n    assert request.is_idempotent is idempotent",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('method,idempotent', (('DELETE', True), ('GET', True), ('HEAD', True), ('OPTIONS', True), ('PATCH', False), ('POST', False), ('PUT', True)))"
      ],
      "arguments": [
        "method",
        "idempotent"
      ],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.is_idempotent is idempotent"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_request_cacheable",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 310,
      "end_line_number": 312,
      "source_code": "def test_request_cacheable(method, cacheable):\n    request = Request(b\"/\", {}, None, method, None, None)\n    assert request.is_cacheable is cacheable",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('method,cacheable', (('DELETE', False), ('GET', True), ('HEAD', True), ('OPTIONS', False), ('PATCH', False), ('POST', False), ('PUT', False)))"
      ],
      "arguments": [
        "method",
        "cacheable"
      ],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.is_cacheable is cacheable"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_custom_ctx",
      "module": "test_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request.py",
      "line_number": 315,
      "end_line_number": 338,
      "source_code": "def test_custom_ctx():\n    class CustomContext:\n        FOO = \"foo\"\n\n    class CustomRequest(Request[Sanic, CustomContext]):\n        @staticmethod\n        def make_context() -> CustomContext:\n            return CustomContext()\n\n    app = Sanic(\"Test\", request_class=CustomRequest)\n\n    @app.get(\"/\")\n    async def handler(request: CustomRequest):\n        return response.json(\n            [\n                isinstance(request, CustomRequest),\n                isinstance(request.ctx, CustomContext),\n                request.ctx.FOO,\n            ]\n        )\n\n    _, resp = app.test_client.get(\"/\")\n\n    assert resp.json == [True, True, \"foo\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "uuid",
        "unittest.mock.Mock",
        "uuid.UUID",
        "uuid.uuid4",
        "pytest",
        "sanic.Sanic",
        "sanic.response",
        "sanic.exceptions.BadURL",
        "sanic.exceptions.SanicException",
        "sanic.request.Request",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert resp.json == [True, True, 'foo']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_load_from_object",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 48,
      "end_line_number": 52,
      "source_code": "def test_load_from_object(app: Sanic):\n    app.config.load(ConfigTest)\n    assert \"CONFIG_VALUE\" in app.config\n    assert app.config.CONFIG_VALUE == \"should be used\"\n    assert \"not_for_config\" not in app.config",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'CONFIG_VALUE' in app.config",
        "assert app.config.CONFIG_VALUE == 'should be used'",
        "assert 'not_for_config' not in app.config"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.config.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        }
      ]
    },
    {
      "name": "test_load_from_object_string",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 55,
      "end_line_number": 59,
      "source_code": "def test_load_from_object_string(app: Sanic):\n    app.config.load(\"tests.test_config.ConfigTest\")\n    assert \"CONFIG_VALUE\" in app.config\n    assert app.config.CONFIG_VALUE == \"should be used\"\n    assert \"not_for_config\" not in app.config",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'CONFIG_VALUE' in app.config",
        "assert app.config.CONFIG_VALUE == 'should be used'",
        "assert 'not_for_config' not in app.config"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.config.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        }
      ]
    },
    {
      "name": "test_load_from_instance",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 62,
      "end_line_number": 68,
      "source_code": "def test_load_from_instance(app: Sanic):\n    app.config.load(ConfigTest())\n    assert \"CONFIG_VALUE\" in app.config\n    assert app.config.CONFIG_VALUE == \"should be used\"\n    assert app.config.ANOTHER_VALUE == \"should be used\"\n    assert \"not_for_config\" not in app.config\n    assert \"another_not_for_config\" not in app.config",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'CONFIG_VALUE' in app.config",
        "assert app.config.CONFIG_VALUE == 'should be used'",
        "assert app.config.ANOTHER_VALUE == 'should be used'",
        "assert 'not_for_config' not in app.config",
        "assert 'another_not_for_config' not in app.config"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.config.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        }
      ]
    },
    {
      "name": "test_load_from_object_string_exception",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 71,
      "end_line_number": 73,
      "source_code": "def test_load_from_object_string_exception(app: Sanic):\n    with pytest.raises(ImportError):\n        app.config.load(\"test_config.Config.test\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.config.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        }
      ]
    },
    {
      "name": "test_auto_env_prefix",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 76,
      "end_line_number": 80,
      "source_code": "def test_auto_env_prefix():\n    environ[\"SANIC_TEST_ANSWER\"] = \"42\"\n    app = Sanic(name=\"Test\")\n    assert app.config.TEST_ANSWER == 42\n    del environ[\"SANIC_TEST_ANSWER\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.config.TEST_ANSWER == 42"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_auto_bool_env_prefix",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 83,
      "end_line_number": 87,
      "source_code": "def test_auto_bool_env_prefix():\n    environ[\"SANIC_TEST_ANSWER\"] = \"True\"\n    app = Sanic(name=\"Test\")\n    assert app.config.TEST_ANSWER is True\n    del environ[\"SANIC_TEST_ANSWER\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.config.TEST_ANSWER is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_empty_load_env_prefix",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 91,
      "end_line_number": 95,
      "source_code": "def test_empty_load_env_prefix(env_prefix):\n    environ[\"SANIC_TEST_ANSWER\"] = \"42\"\n    app = Sanic(name=\"Test\", env_prefix=env_prefix)\n    assert getattr(app.config, \"TEST_ANSWER\", None) is None\n    del environ[\"SANIC_TEST_ANSWER\"]",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('env_prefix', [None, ''])"
      ],
      "arguments": [
        "env_prefix"
      ],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert getattr(app.config, 'TEST_ANSWER', None) is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_env_prefix",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 98,
      "end_line_number": 102,
      "source_code": "def test_env_prefix():\n    environ[\"MYAPP_TEST_ANSWER\"] = \"42\"\n    app = Sanic(name=\"Test\", env_prefix=\"MYAPP_\")\n    assert app.config.TEST_ANSWER == 42\n    del environ[\"MYAPP_TEST_ANSWER\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.config.TEST_ANSWER == 42"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_env_prefix_float_values",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 105,
      "end_line_number": 109,
      "source_code": "def test_env_prefix_float_values():\n    environ[\"MYAPP_TEST_ROI\"] = \"2.3\"\n    app = Sanic(name=\"Test\", env_prefix=\"MYAPP_\")\n    assert app.config.TEST_ROI == 2.3\n    del environ[\"MYAPP_TEST_ROI\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.config.TEST_ROI == 2.3"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_env_prefix_string_value",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 112,
      "end_line_number": 116,
      "source_code": "def test_env_prefix_string_value():\n    environ[\"MYAPP_TEST_TOKEN\"] = \"somerandomtesttoken\"\n    app = Sanic(name=\"Test\", env_prefix=\"MYAPP_\")\n    assert app.config.TEST_TOKEN == \"somerandomtesttoken\"\n    del environ[\"MYAPP_TEST_TOKEN\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.config.TEST_TOKEN == 'somerandomtesttoken'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_env_w_custom_converter",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 119,
      "end_line_number": 126,
      "source_code": "def test_env_w_custom_converter():\n    environ[\"SANIC_TEST_ANSWER\"] = \"42\"\n\n    config = Config(converters=[UltimateAnswer])\n    app = Sanic(name=\"Test\", config=config)\n    assert isinstance(app.config.TEST_ANSWER, UltimateAnswer)\n    assert app.config.TEST_ANSWER.answer == 42\n    del environ[\"SANIC_TEST_ANSWER\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(app.config.TEST_ANSWER, UltimateAnswer)",
        "assert app.config.TEST_ANSWER.answer == 42"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_env_lowercase",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 129,
      "end_line_number": 133,
      "source_code": "def test_env_lowercase():\n    environ[\"SANIC_test_answer\"] = \"42\"\n    app = Sanic(name=\"Test\")\n    assert \"test_answer\" not in app.config\n    del environ[\"SANIC_test_answer\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'test_answer' not in app.config"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_add_converter_multiple_times",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 136,
      "end_line_number": 148,
      "source_code": "def test_add_converter_multiple_times(caplog):\n    def converter(): ...\n\n    message = (\n        \"Configuration value converter 'converter' has already been registered\"\n    )\n    config = Config()\n    config.register_type(converter)\n    with caplog.at_level(logging.WARNING):\n        config.register_type(converter)\n\n    assert (\"sanic.error\", logging.WARNING, message) in caplog.record_tuples\n    assert len(config._converters) == 5",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "caplog"
      ],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert ('sanic.error', logging.WARNING, message) in caplog.record_tuples",
        "assert len(config._converters) == 5"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_load_from_file",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 151,
      "end_line_number": 167,
      "source_code": "def test_load_from_file(app: Sanic):\n    config = dedent(\n        \"\"\"\n    VALUE = 'some value'\n    condition = 1 == 1\n    if condition:\n        CONDITIONAL = 'should be set'\n    \"\"\"\n    )\n    with temp_path() as config_path:\n        config_path.write_text(config)\n        app.config.load(str(config_path))\n        assert \"VALUE\" in app.config\n        assert app.config.VALUE == \"some value\"\n        assert \"CONDITIONAL\" in app.config\n        assert app.config.CONDITIONAL == \"should be set\"\n        assert \"condition\" not in app.config",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'VALUE' in app.config",
        "assert app.config.VALUE == 'some value'",
        "assert 'CONDITIONAL' in app.config",
        "assert app.config.CONDITIONAL == 'should be set'",
        "assert 'condition' not in app.config"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "temp_path",
          "body": "@contextmanager\ndef temp_path():\n    \"\"\"a simple cross platform replacement for NamedTemporaryFile\"\"\"\n    with TemporaryDirectory() as td:\n        yield Path(td, 'file')"
        },
        {
          "name": "app.config.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        }
      ]
    },
    {
      "name": "test_load_from_missing_file",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 170,
      "end_line_number": 172,
      "source_code": "def test_load_from_missing_file(app: Sanic):\n    with pytest.raises(IOError):\n        app.config.load(\"non-existent file\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.config.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        }
      ]
    },
    {
      "name": "test_load_from_envvar",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 175,
      "end_line_number": 182,
      "source_code": "def test_load_from_envvar(app: Sanic):\n    config = \"VALUE = 'some value'\"\n    with temp_path() as config_path:\n        config_path.write_text(config)\n        environ[\"APP_CONFIG\"] = str(config_path)\n        app.config.load(\"${APP_CONFIG}\")\n        assert \"VALUE\" in app.config\n        assert app.config.VALUE == \"some value\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'VALUE' in app.config",
        "assert app.config.VALUE == 'some value'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "temp_path",
          "body": "@contextmanager\ndef temp_path():\n    \"\"\"a simple cross platform replacement for NamedTemporaryFile\"\"\"\n    with TemporaryDirectory() as td:\n        yield Path(td, 'file')"
        },
        {
          "name": "app.config.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        }
      ]
    },
    {
      "name": "test_load_from_missing_envvar",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 185,
      "end_line_number": 192,
      "source_code": "def test_load_from_missing_envvar(app: Sanic):\n    with pytest.raises(IOError) as e:\n        app.config.load(\"non-existent variable\")\n        assert str(e.value) == (\n            \"The environment variable 'non-existent \"\n            \"variable' is not set and thus configuration \"\n            \"could not be loaded.\"\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(e.value) == \"The environment variable 'non-existent variable' is not set and thus configuration could not be loaded.\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.config.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        }
      ]
    },
    {
      "name": "test_load_config_from_file_invalid_syntax",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 195,
      "end_line_number": 201,
      "source_code": "def test_load_config_from_file_invalid_syntax(app: Sanic):\n    config = \"VALUE = some value\"\n    with temp_path() as config_path:\n        config_path.write_text(config)\n\n        with pytest.raises(PyFileError):\n            app.config.load(config_path)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "temp_path",
          "body": "@contextmanager\ndef temp_path():\n    \"\"\"a simple cross platform replacement for NamedTemporaryFile\"\"\"\n    with TemporaryDirectory() as td:\n        yield Path(td, 'file')"
        },
        {
          "name": "app.config.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        }
      ]
    },
    {
      "name": "test_overwrite_exisiting_config",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 204,
      "end_line_number": 211,
      "source_code": "def test_overwrite_exisiting_config(app: Sanic):\n    app.config.DEFAULT = 1\n\n    class Config:\n        DEFAULT = 2\n\n    app.config.load(Config)\n    assert app.config.DEFAULT == 2",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.config.DEFAULT == 2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.config.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        }
      ]
    },
    {
      "name": "test_overwrite_exisiting_config_ignore_lowercase",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 214,
      "end_line_number": 221,
      "source_code": "def test_overwrite_exisiting_config_ignore_lowercase(app: Sanic):\n    app.config.default = 1\n\n    class Config:\n        default = 2\n\n    app.config.load(Config)\n    assert app.config.default == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.config.default == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.config.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        }
      ]
    },
    {
      "name": "test_missing_config",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 224,
      "end_line_number": 226,
      "source_code": "def test_missing_config(app: Sanic):\n    with pytest.raises(AttributeError, match=\"Config has no 'NON_EXISTENT'\"):\n        _ = app.config.NON_EXISTENT",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_config_defaults",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 229,
      "end_line_number": 235,
      "source_code": "def test_config_defaults():\n    \"\"\"\n    load DEFAULT_CONFIG\n    \"\"\"\n    conf = Config()\n    for key, value in DEFAULT_CONFIG.items():\n        assert getattr(conf, key) == value",
      "docstring": "load DEFAULT_CONFIG",
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert getattr(conf, key) == value"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_config_custom_defaults",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 238,
      "end_line_number": 253,
      "source_code": "def test_config_custom_defaults():\n    \"\"\"\n    we should have all the variables from defaults rewriting them with\n    custom defaults passed in\n    Config\n    \"\"\"\n    custom_defaults = {\n        \"REQUEST_MAX_SIZE\": 1,\n        \"KEEP_ALIVE\": False,\n        \"ACCESS_LOG\": False,\n    }\n    conf = Config(defaults=custom_defaults)\n    for key, value in DEFAULT_CONFIG.items():\n        if key in custom_defaults.keys():\n            value = custom_defaults[key]\n        assert getattr(conf, key) == value",
      "docstring": "we should have all the variables from defaults rewriting them with\ncustom defaults passed in\nConfig",
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert getattr(conf, key) == value"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_config_custom_defaults_with_env",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 256,
      "end_line_number": 289,
      "source_code": "def test_config_custom_defaults_with_env():\n    \"\"\"\n    test that environment variables has higher priority than DEFAULT_CONFIG\n    and passed defaults dict\n    \"\"\"\n    custom_defaults = {\n        \"REQUEST_MAX_SIZE123\": 1,\n        \"KEEP_ALIVE123\": False,\n        \"ACCESS_LOG123\": False,\n    }\n\n    environ_defaults = {\n        \"SANIC_REQUEST_MAX_SIZE123\": \"2\",\n        \"SANIC_KEEP_ALIVE123\": \"True\",\n        \"SANIC_ACCESS_LOG123\": \"False\",\n    }\n\n    for key, value in environ_defaults.items():\n        environ[key] = value\n\n    conf = Config(defaults=custom_defaults)\n    for key, value in DEFAULT_CONFIG.items():\n        if \"SANIC_\" + key in environ_defaults.keys():\n            value = environ_defaults[\"SANIC_\" + key]\n            try:\n                value = int(value)\n            except ValueError:\n                if value in [\"True\", \"False\"]:\n                    value = value == \"True\"\n\n        assert getattr(conf, key) == value\n\n    for key, value in environ_defaults.items():\n        del environ[key]",
      "docstring": "test that environment variables has higher priority than DEFAULT_CONFIG\nand passed defaults dict",
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert getattr(conf, key) == value"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_config_access_log_passing_in_run",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 293,
      "end_line_number": 301,
      "source_code": "def test_config_access_log_passing_in_run(app: Sanic, access_log):\n    assert app.config.ACCESS_LOG is False\n\n    @app.listener(\"after_server_start\")\n    async def _request(sanic, loop):\n        app.stop()\n\n    app.run(port=1340, access_log=access_log, single_process=True)\n    assert app.config.ACCESS_LOG is access_log",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('access_log', (True, False))"
      ],
      "arguments": [
        "app",
        "access_log"
      ],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.config.ACCESS_LOG is False",
        "assert app.config.ACCESS_LOG is access_log"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        }
      ]
    },
    {
      "name": "test_config_rewrite_keep_alive",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 323,
      "end_line_number": 335,
      "source_code": "def test_config_rewrite_keep_alive():\n    config = Config()\n    assert config.KEEP_ALIVE == DEFAULT_CONFIG[\"KEEP_ALIVE\"]\n    config = Config(keep_alive=True)\n    assert config.KEEP_ALIVE is True\n    config = Config(keep_alive=False)\n    assert config.KEEP_ALIVE is False\n\n    # use defaults\n    config = Config(defaults={\"KEEP_ALIVE\": False})\n    assert config.KEEP_ALIVE is False\n    config = Config(defaults={\"KEEP_ALIVE\": True})\n    assert config.KEEP_ALIVE is True",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert config.KEEP_ALIVE == DEFAULT_CONFIG['KEEP_ALIVE']",
        "assert config.KEEP_ALIVE is True",
        "assert config.KEEP_ALIVE is False",
        "assert config.KEEP_ALIVE is False",
        "assert config.KEEP_ALIVE is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_update",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 354,
      "end_line_number": 356,
      "source_code": "def test_update(app: Sanic, conf_object):\n    app.update_config(conf_object)\n    assert app.config[\"TEST_SETTING_VALUE\"] == 1",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('conf_object', [_test_setting_as_dict, _test_setting_as_class, _test_setting_as_module], ids=['from_dict', 'from_class', 'from_file'])"
      ],
      "arguments": [
        "app",
        "conf_object"
      ],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.config['TEST_SETTING_VALUE'] == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_update_from_lowercase_key",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 359,
      "end_line_number": 362,
      "source_code": "def test_update_from_lowercase_key(app: Sanic):\n    d = {\"test_setting_value\": 1}\n    app.update_config(d)\n    assert \"test_setting_value\" not in app.config",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'test_setting_value' not in app.config"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_config_set_methods",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 365,
      "end_line_number": 409,
      "source_code": "def test_config_set_methods(app: Sanic, monkeypatch: MonkeyPatch):\n    post_set = Mock()\n    monkeypatch.setattr(Config, \"_post_set\", post_set)\n\n    app.config.FOO = 1\n    post_set.assert_called_once_with(\"FOO\", 1)\n    post_set.reset_mock()\n\n    app.config[\"FOO\"] = 2\n    post_set.assert_called_once_with(\"FOO\", 2)\n    post_set.reset_mock()\n\n    app.config.update({\"FOO\": 3})\n    post_set.assert_called_once_with(\"FOO\", 3)\n    post_set.reset_mock()\n\n    app.config.update([(\"FOO\", 4)])\n    post_set.assert_called_once_with(\"FOO\", 4)\n    post_set.reset_mock()\n\n    app.config.update(FOO=5)\n    post_set.assert_called_once_with(\"FOO\", 5)\n    post_set.reset_mock()\n\n    app.config.update({\"FOO\": 6}, {\"BAR\": 7})\n    post_set.assert_has_calls(\n        calls=[\n            call(\"FOO\", 6),\n            call(\"BAR\", 7),\n        ]\n    )\n    post_set.reset_mock()\n\n    app.config.update({\"FOO\": 8}, BAR=9)\n    post_set.assert_has_calls(\n        calls=[\n            call(\"FOO\", 8),\n            call(\"BAR\", 9),\n        ],\n        any_order=True,\n    )\n    post_set.reset_mock()\n\n    app.config.update_config({\"FOO\": 10})\n    post_set.assert_called_once_with(\"FOO\", 10)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "monkeypatch"
      ],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "post_set.reset_mock",
          "body": "def reset_mock(self, *args, **kwargs):\n    super().reset_mock(*args, **kwargs)\n    self.await_count = 0"
        },
        {
          "name": "post_set.reset_mock",
          "body": "def reset_mock(self, *args, **kwargs):\n    super().reset_mock(*args, **kwargs)\n    self.await_count = 0"
        },
        {
          "name": "post_set.reset_mock",
          "body": "def reset_mock(self, *args, **kwargs):\n    super().reset_mock(*args, **kwargs)\n    self.await_count = 0"
        },
        {
          "name": "post_set.reset_mock",
          "body": "def reset_mock(self, *args, **kwargs):\n    super().reset_mock(*args, **kwargs)\n    self.await_count = 0"
        },
        {
          "name": "post_set.reset_mock",
          "body": "def reset_mock(self, *args, **kwargs):\n    super().reset_mock(*args, **kwargs)\n    self.await_count = 0"
        },
        {
          "name": "post_set.reset_mock",
          "body": "def reset_mock(self, *args, **kwargs):\n    super().reset_mock(*args, **kwargs)\n    self.await_count = 0"
        },
        {
          "name": "post_set.reset_mock",
          "body": "def reset_mock(self, *args, **kwargs):\n    super().reset_mock(*args, **kwargs)\n    self.await_count = 0"
        }
      ]
    },
    {
      "name": "test_negative_proxy_count",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 412,
      "end_line_number": 421,
      "source_code": "def test_negative_proxy_count(app: Sanic):\n    app.config.PROXIES_COUNT = -1\n\n    message = (\n        \"PROXIES_COUNT cannot be negative. \"\n        \"https://sanic.readthedocs.io/en/latest/sanic/config.html\"\n        \"#proxy-configuration\"\n    )\n    with pytest.raises(ValueError, match=message):\n        app.prepare()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_convert_local_cert_creator",
      "module": "test_config",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_config.py",
      "line_number": 435,
      "end_line_number": 439,
      "source_code": "def test_convert_local_cert_creator(passed, expected):\n    os.environ[\"SANIC_LOCAL_CERT_CREATOR\"] = passed\n    app = Sanic(\"Test\")\n    assert app.config.LOCAL_CERT_CREATOR is expected\n    del os.environ[\"SANIC_LOCAL_CERT_CREATOR\"]",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('passed,expected', (('auto', LocalCertCreator.AUTO), ('mkcert', LocalCertCreator.MKCERT), ('trustme', LocalCertCreator.TRUSTME), ('AUTO', LocalCertCreator.AUTO), ('MKCERT', LocalCertCreator.MKCERT), ('TRUSTME', LocalCertCreator.TRUSTME)))"
      ],
      "arguments": [
        "passed",
        "expected"
      ],
      "imports": [
        "logging",
        "os",
        "contextlib.contextmanager",
        "os.environ",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.config.Config",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.PyFileError",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.config.LOCAL_CERT_CREATOR is expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_create_task",
      "module": "test_create_task",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_create_task.py",
      "line_number": 12,
      "end_line_number": 36,
      "source_code": "def test_create_task(app):\n    e = Event()\n\n    async def coro():\n        await asyncio.sleep(0.05)\n        e.set()\n\n    @app.route(\"/early\")\n    def not_set(request):\n        return text(str(e.is_set()))\n\n    @app.route(\"/late\")\n    async def set(request):\n        await asyncio.sleep(0.1)\n        return text(str(e.is_set()))\n\n    app.add_task(coro)\n\n    request, response = app.test_client.get(\"/early\")\n    assert response.body == b\"False\"\n\n    app.signal_router.reset()\n    app.add_task(coro)\n    request, response = app.test_client.get(\"/late\")\n    assert response.body == b\"True\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "sys",
        "threading.Event",
        "pytest",
        "sanic.exceptions.SanicException",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.body == b'False'",
        "assert response.body == b'True'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.add_task",
          "body": "def add_task(self, func):\n    loop = asyncio.get_event_loop()\n    self.stay_active_task = loop.create_task(func(self))"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.signal_router.reset",
          "body": "@pytest.fixture(autouse=True)\ndef reset():\n    try:\n        del os.environ['SANIC_MOTD_OUTPUT']\n    except KeyError:\n        ..."
        },
        {
          "name": "app.add_task",
          "body": "def add_task(self, func):\n    loop = asyncio.get_event_loop()\n    self.stay_active_task = loop.create_task(func(self))"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_create_task_with_app_arg",
      "module": "test_create_task",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_create_task.py",
      "line_number": 39,
      "end_line_number": 54,
      "source_code": "def test_create_task_with_app_arg(app):\n    @app.after_server_start\n    async def setup_q(app, _):\n        app.ctx.q = asyncio.Queue()\n\n    @app.route(\"/\")\n    async def not_set(request):\n        return text(await request.app.ctx.q.get())\n\n    async def coro(app):\n        await app.ctx.q.put(app.name)\n\n    app.add_task(coro)\n\n    _, response = app.test_client.get(\"/\")\n    assert response.text == \"test_create_task_with_app_arg\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "sys",
        "threading.Event",
        "pytest",
        "sanic.exceptions.SanicException",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'test_create_task_with_app_arg'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.add_task",
          "body": "def add_task(self, func):\n    loop = asyncio.get_event_loop()\n    self.stay_active_task = loop.create_task(func(self))"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.ctx.q.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "request.app.ctx.q.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_create_named_task",
      "module": "test_create_task",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_create_task.py",
      "line_number": 58,
      "end_line_number": 76,
      "source_code": "def test_create_named_task(app, port):\n    async def dummy(): ...\n\n    @app.before_server_start\n    async def setup(app, _):\n        app.add_task(dummy, name=\"dummy_task\")\n\n    @app.after_server_start\n    async def stop(app, _):\n        task = app.get_task(\"dummy_task\")\n\n        assert app._task_registry\n        assert isinstance(task, asyncio.Task)\n\n        assert task.get_name() == \"dummy_task\"\n\n        app.stop()\n\n    app.run(single_process=True, port=port)",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(sys.version_info < (3, 8), reason='Not supported in 3.7')"
      ],
      "arguments": [
        "app",
        "port"
      ],
      "imports": [
        "asyncio",
        "sys",
        "threading.Event",
        "pytest",
        "sanic.exceptions.SanicException",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert app._task_registry",
        "assert isinstance(task, asyncio.Task)",
        "assert task.get_name() == 'dummy_task'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "app.add_task",
          "body": "def add_task(self, func):\n    loop = asyncio.get_event_loop()\n    self.stay_active_task = loop.create_task(func(self))"
        },
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        }
      ]
    },
    {
      "name": "test_named_task_called",
      "module": "test_create_task",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_create_task.py",
      "line_number": 79,
      "end_line_number": 95,
      "source_code": "def test_named_task_called(app):\n    e = Event()\n\n    async def coro():\n        e.set()\n\n    @app.route(\"/\")\n    async def isset(request):\n        await asyncio.sleep(0.05)\n        return text(str(e.is_set()))\n\n    @app.before_server_start\n    async def setup(app, _):\n        app.add_task(coro, name=\"dummy_task\")\n\n    request, response = app.test_client.get(\"/\")\n    assert response.body == b\"True\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "sys",
        "threading.Event",
        "pytest",
        "sanic.exceptions.SanicException",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.body == b'True'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.add_task",
          "body": "def add_task(self, func):\n    loop = asyncio.get_event_loop()\n    self.stay_active_task = loop.create_task(func(self))"
        }
      ]
    },
    {
      "name": "test_create_named_task_fails_outside_app",
      "module": "test_create_task",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_create_task.py",
      "line_number": 99,
      "end_line_number": 109,
      "source_code": "def test_create_named_task_fails_outside_app(app):\n    async def dummy(): ...\n\n    message = \"Cannot name task outside of a running application\"\n    with pytest.raises(RuntimeError, match=message):\n        app.add_task(dummy, name=\"dummy_task\")\n    assert not app._task_registry\n\n    message = 'Registered task named \"dummy_task\" not found.'\n    with pytest.raises(SanicException, match=message):\n        app.get_task(\"dummy_task\")",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(sys.version_info < (3, 8), reason='Not supported in 3.7')"
      ],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "sys",
        "threading.Event",
        "pytest",
        "sanic.exceptions.SanicException",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert not app._task_registry"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.add_task",
          "body": "def add_task(self, func):\n    loop = asyncio.get_event_loop()\n    self.stay_active_task = loop.create_task(func(self))"
        }
      ]
    },
    {
      "name": "test_matching",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 125,
      "end_line_number": 177,
      "source_code": "def test_matching(path, headers, expected):\n    app = Sanic(\"dev\")\n    bp1 = Blueprint(\"bp1\", url_prefix=\"/bp1\")\n    bp2 = Blueprint(\"bp2\", url_prefix=\"/bp2\", strict_slashes=True)\n    bp3 = Blueprint(\"bp3\", url_prefix=\"/bp3\", strict_slashes=False)\n    bp4 = Blueprint(\"bp4\", url_prefix=\"/bp4\", host=\"maybe.com\")\n\n    def handler(request):\n        return text(\"Hello!\")\n\n    defs = (\n        (\"/\", None, None),\n        (\"/host\", None, \"matching.com\"),\n        (\"/without\", None, None),\n        (\"/with/\", None, None),\n        (\"/expwithout\", False, None),\n        (\"/expwith/\", False, None),\n        (\"/without/strict\", True, None),\n        (\"/with/strict/\", True, None),\n    )\n    for uri, strict_slashes, host in defs:\n        params = {\"uri\": uri}\n        if strict_slashes is not None:\n            params[\"strict_slashes\"] = strict_slashes\n        if host is not None:\n            params[\"host\"] = host\n        app.route(**params)(handler)\n        bp1.route(**params)(handler)\n        bp2.route(**params)(handler)\n        bp3.route(**params)(handler)\n        bp4.route(**params)(handler)\n\n    app.blueprint(bp1)\n    app.blueprint(bp2)\n    app.blueprint(bp3)\n    app.blueprint(bp4)\n\n    app.router.finalize()\n\n    request = Request(path, headers, None, \"GET\", None, app)\n\n    try:\n        app.router.get(\n            request.path, request.method, request.headers.get(\"host\")\n        )\n    except NotFound:\n        response = 404\n    except Exception:\n        response = 500\n    else:\n        response = 200\n\n    assert response == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('path,headers,expected', ((b'/', {}, 200), (b'/', {'host': 'maybe.com'}, 200), (b'/host', {'host': 'matching.com'}, 200), (b'/host', {'host': 'wrong.com'}, 404), (b'/without', {}, 200), (b'/without/', {}, 200), (b'/with', {}, 200), (b'/with/', {}, 200), (b'/expwithout', {}, 200), (b'/expwithout/', {}, 200), (b'/expwith', {}, 200), (b'/expwith/', {}, 200), (b'/without/strict', {}, 200), (b'/without/strict/', {}, 404), (b'/with/strict', {}, 404), (b'/with/strict/', {}, 200), (b'/bp1', {}, 200), (b'/bp1', {'host': 'maybe.com'}, 200), (b'/bp1/host', {'host': 'matching.com'}, 200), (b'/bp1/host', {'host': 'wrong.com'}, 404), (b'/bp1/without', {}, 200), (b'/bp1/without/', {}, 200), (b'/bp1/with', {}, 200), (b'/bp1/with/', {}, 200), (b'/bp1/expwithout', {}, 200), (b'/bp1/expwithout/', {}, 200), (b'/bp1/expwith', {}, 200), (b'/bp1/expwith/', {}, 200), (b'/bp1/without/strict', {}, 200), (b'/bp1/without/strict/', {}, 404), (b'/bp1/with/strict', {}, 404), (b'/bp1/with/strict/', {}, 200), (b'/bp2/', {}, 200), (b'/bp2/', {'host': 'maybe.com'}, 200), (b'/bp2/host', {'host': 'matching.com'}, 200), (b'/bp2/host', {'host': 'wrong.com'}, 404), (b'/bp2/without', {}, 200), (b'/bp2/without/', {}, 404), (b'/bp2/with', {}, 404), (b'/bp2/with/', {}, 200), (b'/bp2/expwithout', {}, 200), (b'/bp2/expwithout/', {}, 200), (b'/bp2/expwith', {}, 200), (b'/bp2/expwith/', {}, 200), (b'/bp2/without/strict', {}, 200), (b'/bp2/without/strict/', {}, 404), (b'/bp2/with/strict', {}, 404), (b'/bp2/with/strict/', {}, 200), (b'/bp3', {}, 200), (b'/bp3', {'host': 'maybe.com'}, 200), (b'/bp3/host', {'host': 'matching.com'}, 200), (b'/bp3/host', {'host': 'wrong.com'}, 404), (b'/bp3/without', {}, 200), (b'/bp3/without/', {}, 200), (b'/bp3/with', {}, 200), (b'/bp3/with/', {}, 200), (b'/bp3/expwithout', {}, 200), (b'/bp3/expwithout/', {}, 200), (b'/bp3/expwith', {}, 200), (b'/bp3/expwith/', {}, 200), (b'/bp3/without/strict', {}, 200), (b'/bp3/without/strict/', {}, 404), (b'/bp3/with/strict', {}, 404), (b'/bp3/with/strict/', {}, 200), (b'/bp4', {}, 404), (b'/bp4', {'host': 'maybe.com'}, 200), (b'/bp4/host', {'host': 'matching.com'}, 200), (b'/bp4/host', {'host': 'wrong.com'}, 404), (b'/bp4/without', {}, 404), (b'/bp4/without/', {}, 404), (b'/bp4/with', {}, 404), (b'/bp4/with/', {}, 404), (b'/bp4/expwithout', {}, 404), (b'/bp4/expwithout/', {}, 404), (b'/bp4/expwith', {}, 404), (b'/bp4/expwith/', {}, 404), (b'/bp4/without/strict', {}, 404), (b'/bp4/without/strict/', {}, 404), (b'/bp4/with/strict', {}, 404), (b'/bp4/with/strict/', {}, 404)))"
      ],
      "arguments": [
        "path",
        "headers",
        "expected"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.router.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "request.headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_versioned_routes_get",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 186,
      "end_line_number": 202,
      "source_code": "def test_versioned_routes_get(app, method):\n    method = method.lower()\n\n    func = getattr(app, method)\n    if callable(func):\n\n        @func(f\"/{method}\", version=1)\n        def handler(request):\n            return text(\"OK\")\n\n    else:\n        raise Exception(f\"Method: {method} is not callable\")\n\n    client_method = getattr(app.test_client, method)\n\n    request, response = client_method(f\"/v1/{method}\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('method', HTTP_METHODS)"
      ],
      "arguments": [
        "app",
        "method"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_shorthand_routes_get",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 205,
      "end_line_number": 214,
      "source_code": "def test_shorthand_routes_get(app):\n    @app.get(\"/get\")\n    def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/get\")\n    assert response.text == \"OK\"\n\n    request, response = app.test_client.post(\"/get\")\n    assert response.status == 405",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert response.status == 405"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_shorthand_routes_multiple",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 217,
      "end_line_number": 231,
      "source_code": "def test_shorthand_routes_multiple(app):\n    @app.get(\"/get\")\n    def get_handler(request):\n        return text(\"OK\")\n\n    @app.options(\"/get\")\n    def options_handler(request):\n        return text(\"\")\n\n    request, response = app.test_client.get(\"/get/\")\n    assert response.status == 200\n    assert response.text == \"OK\"\n\n    request, response = app.test_client.options(\"/get/\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'OK'",
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.options",
          "body": "def options(self, request):\n    return text('', headers={'method': 'OPTIONS'})"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.options",
          "body": "def options(self, request):\n    return text('', headers={'method': 'OPTIONS'})"
        }
      ]
    },
    {
      "name": "test_route_strict_slash",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 234,
      "end_line_number": 253,
      "source_code": "def test_route_strict_slash(app):\n    @app.get(\"/get\", strict_slashes=True)\n    def handler1(request):\n        return text(\"OK\")\n\n    @app.post(\"/post/\", strict_slashes=True)\n    def handler2(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/get\")\n    assert response.text == \"OK\"\n\n    request, response = app.test_client.get(\"/get/\")\n    assert response.status == 404\n\n    request, response = app.test_client.post(\"/post/\")\n    assert response.text == \"OK\"\n\n    request, response = app.test_client.post(\"/post\")\n    assert response.status == 404",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert response.status == 404",
        "assert response.text == 'OK'",
        "assert response.status == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_route_invalid_parameter_syntax",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 256,
      "end_line_number": 263,
      "source_code": "def test_route_invalid_parameter_syntax(app):\n    with pytest.raises(InvalidUsage):\n\n        @app.get(\"/get/<:str>\", strict_slashes=True)\n        def handler(request):\n            return text(\"OK\")\n\n        request, response = app.test_client.get(\"/get\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_route_strict_slash_default_value",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 266,
      "end_line_number": 274,
      "source_code": "def test_route_strict_slash_default_value():\n    app = Sanic(\"test_route_strict_slash\", strict_slashes=True)\n\n    @app.get(\"/get\")\n    def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/get/\")\n    assert response.status == 404",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_route_strict_slash_without_passing_default_value",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 277,
      "end_line_number": 283,
      "source_code": "def test_route_strict_slash_without_passing_default_value(app):\n    @app.get(\"/get\")\n    def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/get/\")\n    assert response.text == \"OK\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_route_strict_slash_default_value_can_be_overwritten",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 286,
      "end_line_number": 294,
      "source_code": "def test_route_strict_slash_default_value_can_be_overwritten():\n    app = Sanic(\"test_route_strict_slash\", strict_slashes=True)\n\n    @app.get(\"/get\", strict_slashes=False)\n    def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/get/\")\n    assert response.text == \"OK\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_route_slashes_overload",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 297,
      "end_line_number": 316,
      "source_code": "def test_route_slashes_overload(app):\n    @app.get(\"/hello/\")\n    def handler_get(request):\n        return text(\"OK\")\n\n    @app.post(\"/hello/\")\n    def handler_post(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/hello\")\n    assert response.text == \"OK\"\n\n    request, response = app.test_client.get(\"/hello/\")\n    assert response.text == \"OK\"\n\n    request, response = app.test_client.post(\"/hello\")\n    assert response.text == \"OK\"\n\n    request, response = app.test_client.post(\"/hello/\")\n    assert response.text == \"OK\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert response.text == 'OK'",
        "assert response.text == 'OK'",
        "assert response.text == 'OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_route_optional_slash",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 319,
      "end_line_number": 328,
      "source_code": "def test_route_optional_slash(app):\n    @app.get(\"/get\")\n    def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/get\")\n    assert response.text == \"OK\"\n\n    request, response = app.test_client.get(\"/get/\")\n    assert response.text == \"OK\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert response.text == 'OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_route_strict_slashes_set_to_false_and_host_is_a_list",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 331,
      "end_line_number": 369,
      "source_code": "def test_route_strict_slashes_set_to_false_and_host_is_a_list(app):\n    # Part of regression test for issue #1120\n    test_client = SanicTestClient(app, port=42101)\n    site1 = f\"127.0.0.1:{test_client.port}\"\n\n    # before fix, this raises a RouteExists error\n    @app.get(\"/get\", host=[site1, \"site2.com\"], strict_slashes=False)\n    def get_handler(request):\n        return text(\"OK\")\n\n    request, response = test_client.get(\"http://\" + site1 + \"/get\")\n    assert response.text == \"OK\"\n\n    app.router.finalized = False\n\n    @app.post(\"/post\", host=[site1, \"site2.com\"], strict_slashes=False)\n    def post_handler(request):\n        return text(\"OK\")\n\n    request, response = test_client.post(\"http://\" + site1 + \"/post\")\n    assert response.text == \"OK\"\n\n    app.router.finalized = False\n\n    @app.put(\"/put\", host=[site1, \"site2.com\"], strict_slashes=False)\n    def put_handler(request):\n        return text(\"OK\")\n\n    request, response = test_client.put(\"http://\" + site1 + \"/put\")\n    assert response.text == \"OK\"\n\n    app.router.finalized = False\n\n    @app.delete(\"/delete\", host=[site1, \"site2.com\"], strict_slashes=False)\n    def delete_handler(request):\n        return text(\"OK\")\n\n    request, response = test_client.delete(\"http://\" + site1 + \"/delete\")\n    assert response.text == \"OK\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert response.text == 'OK'",
        "assert response.text == 'OK'",
        "assert response.text == 'OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "test_client.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.delete",
          "body": "def delete(self, request):\n    return text('I am delete method')"
        },
        {
          "name": "test_client.delete",
          "body": "def delete(self, request):\n    return text('I am delete method')"
        }
      ]
    },
    {
      "name": "test_shorthand_routes_post",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 372,
      "end_line_number": 381,
      "source_code": "def test_shorthand_routes_post(app):\n    @app.post(\"/post\")\n    def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.post(\"/post\")\n    assert response.text == \"OK\"\n\n    request, response = app.test_client.get(\"/post\")\n    assert response.status == 405",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert response.status == 405"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_shorthand_routes_put",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 384,
      "end_line_number": 393,
      "source_code": "def test_shorthand_routes_put(app):\n    @app.put(\"/put\")\n    def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.put(\"/put\")\n    assert response.text == \"OK\"\n\n    request, response = app.test_client.get(\"/put\")\n    assert response.status == 405",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert response.status == 405"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.test_client.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_shorthand_routes_delete",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 396,
      "end_line_number": 405,
      "source_code": "def test_shorthand_routes_delete(app):\n    @app.delete(\"/delete\")\n    def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.delete(\"/delete\")\n    assert response.text == \"OK\"\n\n    request, response = app.test_client.get(\"/delete\")\n    assert response.status == 405",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert response.status == 405"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.delete",
          "body": "def delete(self, request):\n    return text('I am delete method')"
        },
        {
          "name": "app.test_client.delete",
          "body": "def delete(self, request):\n    return text('I am delete method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_shorthand_routes_patch",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 408,
      "end_line_number": 417,
      "source_code": "def test_shorthand_routes_patch(app):\n    @app.patch(\"/patch\")\n    def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.patch(\"/patch\")\n    assert response.text == \"OK\"\n\n    request, response = app.test_client.get(\"/patch\")\n    assert response.status == 405",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert response.status == 405"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "app.patch('/patch')",
        "app.test_client.patch('/patch')"
      ],
      "methods_under_test": [
        {
          "name": "app.patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "app.test_client.patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_shorthand_routes_head",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 420,
      "end_line_number": 429,
      "source_code": "def test_shorthand_routes_head(app):\n    @app.head(\"/head\")\n    def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.head(\"/head\")\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/head\")\n    assert response.status == 405",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.status == 405"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.head",
          "body": "def head(self, request):\n    return text('', headers={'method': 'HEAD'})"
        },
        {
          "name": "app.test_client.head",
          "body": "def head(self, request):\n    return text('', headers={'method': 'HEAD'})"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_shorthand_routes_options",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 432,
      "end_line_number": 441,
      "source_code": "def test_shorthand_routes_options(app):\n    @app.options(\"/options\")\n    def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.options(\"/options\")\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/options\")\n    assert response.status == 405",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.status == 405"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.options",
          "body": "def options(self, request):\n    return text('', headers={'method': 'OPTIONS'})"
        },
        {
          "name": "app.test_client.options",
          "body": "def options(self, request):\n    return text('', headers={'method': 'OPTIONS'})"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_static_routes",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 444,
      "end_line_number": 457,
      "source_code": "def test_static_routes(app):\n    @app.route(\"/test\")\n    async def handler1(request):\n        return text(\"OK1\")\n\n    @app.route(\"/pizazz\")\n    async def handler2(request):\n        return text(\"OK2\")\n\n    request, response = app.test_client.get(\"/test\")\n    assert response.text == \"OK1\"\n\n    request, response = app.test_client.get(\"/pizazz\")\n    assert response.text == \"OK2\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK1'",
        "assert response.text == 'OK2'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_dynamic_route",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 460,
      "end_line_number": 473,
      "source_code": "def test_dynamic_route(app):\n    results = []\n\n    @app.route(\"/folder/<name>\")\n    async def handler(request, name):\n        results.append(name)\n        return text(\"OK\")\n\n    app.router.finalize(False)\n\n    request, response = app.test_client.get(\"/folder/test123\")\n\n    assert response.text == \"OK\"\n    assert results[0] == \"test123\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert results[0] == 'test123'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_dynamic_route_string",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 476,
      "end_line_number": 492,
      "source_code": "def test_dynamic_route_string(app):\n    results = []\n\n    @app.route(\"/folder/<name:str>\")\n    async def handler(request, name):\n        results.append(name)\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/folder/test123\")\n\n    assert response.text == \"OK\"\n    assert results[0] == \"test123\"\n\n    request, response = app.test_client.get(\"/folder/favicon.ico\")\n\n    assert response.text == \"OK\"\n    assert results[1] == \"favicon.ico\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert results[0] == 'test123'",
        "assert response.text == 'OK'",
        "assert results[1] == 'favicon.ico'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_dynamic_route_int",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 495,
      "end_line_number": 508,
      "source_code": "def test_dynamic_route_int(app):\n    results = []\n\n    @app.route(\"/folder/<folder_id:int>\")\n    async def handler(request, folder_id):\n        results.append(folder_id)\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/folder/12345\")\n    assert response.text == \"OK\"\n    assert isinstance(results[0], int)\n\n    request, response = app.test_client.get(\"/folder/asdf\")\n    assert response.status == 404",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert isinstance(results[0], int)",
        "assert response.status == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_dynamic_route_number",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 511,
      "end_line_number": 536,
      "source_code": "def test_dynamic_route_number(app):\n    results = []\n\n    @app.route(\"/weight/<weight:float>\")\n    async def handler(request, weight):\n        results.append(weight)\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/weight/12345\")\n    assert response.text == \"OK\"\n    assert isinstance(results[0], float)\n\n    request, response = app.test_client.get(\"/weight/1234.56\")\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/weight/.12\")\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/weight/12.\")\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/weight/1234-56\")\n    assert response.status == 404\n\n    request, response = app.test_client.get(\"/weight/12.34.56\")\n    assert response.status == 404",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert isinstance(results[0], float)",
        "assert response.status == 200",
        "assert response.status == 200",
        "assert response.status == 200",
        "assert response.status == 404",
        "assert response.status == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_dynamic_route_regex",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 539,
      "end_line_number": 554,
      "source_code": "def test_dynamic_route_regex(app):\n    @app.route(\"/folder/<folder_id:[A-Za-z0-9]{0,4}>\")\n    async def handler(request, folder_id):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/folder/test\")\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/folder/test1\")\n    assert response.status == 404\n\n    request, response = app.test_client.get(\"/folder/test-123\")\n    assert response.status == 404\n\n    request, response = app.test_client.get(\"/folder/\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.status == 404",
        "assert response.status == 404",
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_dynamic_route_uuid",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 557,
      "end_line_number": 577,
      "source_code": "def test_dynamic_route_uuid(app):\n    import uuid\n\n    results = []\n\n    @app.route(\"/quirky/<unique_id:uuid>\")\n    async def handler(request, unique_id):\n        results.append(unique_id)\n        return text(\"OK\")\n\n    url = \"/quirky/123e4567-e89b-12d3-a456-426655440000\"\n    request, response = app.test_client.get(url)\n    assert response.text == \"OK\"\n    assert isinstance(results[0], uuid.UUID)\n\n    generated_uuid = uuid.uuid4()\n    request, response = app.test_client.get(f\"/quirky/{generated_uuid}\")\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/quirky/non-existing\")\n    assert response.status == 404",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert isinstance(results[0], uuid.UUID)",
        "assert response.status == 200",
        "assert response.status == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_dynamic_route_path",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 580,
      "end_line_number": 603,
      "source_code": "def test_dynamic_route_path(app):\n    @app.route(\"/<path:path>/info\")\n    async def handler(request, path):\n        return text(\"OK\")\n\n    app.router.finalize()\n\n    request, response = app.test_client.get(\"/path/1/info\")\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/info\")\n    assert response.status == 404\n\n    app.router.reset()\n\n    @app.route(\"/<path:path>\")\n    async def handler1(request, path):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/info\")\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/whatever/you/set\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.status == 404",
        "assert response.status == 200",
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.router.reset",
          "body": "@pytest.fixture(autouse=True)\ndef reset():\n    try:\n        del os.environ['SANIC_MOTD_OUTPUT']\n    except KeyError:\n        ..."
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_dynamic_route_unhashable",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 606,
      "end_line_number": 621,
      "source_code": "def test_dynamic_route_unhashable(app):\n    @app.route(\"/folder/<unhashable:[A-Za-z0-9/]+>/end/\")\n    async def handler(request, unhashable):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/folder/test/asdf/end/\")\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/folder/test///////end/\")\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/folder/test/end/\")\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/folder/test/nope/\")\n    assert response.status == 404",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.status == 200",
        "assert response.status == 200",
        "assert response.status == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_websocket_route",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 625,
      "end_line_number": 636,
      "source_code": "def test_websocket_route(app, url):\n    ev = asyncio.Event()\n\n    @app.websocket(url)\n    async def handler(request, ws):\n        assert request.scheme == \"ws\"\n        assert ws.subprotocol is None\n        ev.set()\n\n    request, response = app.test_client.websocket(url)\n    assert response.opened is True\n    assert ev.is_set()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('url', ['/ws', 'ws'])"
      ],
      "arguments": [
        "app",
        "url"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.opened is True",
        "assert ev.is_set()",
        "assert request.scheme == 'ws'",
        "assert ws.subprotocol is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_websocket_route_invalid_handler",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 639,
      "end_line_number": 648,
      "source_code": "def test_websocket_route_invalid_handler(app):\n    with pytest.raises(ValueError) as e:\n\n        @app.websocket(\"/\")\n        async def handler(): ...\n\n    assert e.match(\n        r\"Required parameter `request` and/or `ws` missing in the \"\n        r\"handler\\(\\) route\\?\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert e.match('Required parameter `request` and/or `ws` missing in the handler\\\\(\\\\) route\\\\?')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_websocket_route_with_subprotocols",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 678,
      "end_line_number": 691,
      "source_code": "def test_websocket_route_with_subprotocols(app, subprotocols, expected):\n    results = []\n\n    @app.websocket(\"/ws\", subprotocols=[\"zero\", \"one\", \"two\", \"three\"])\n    async def handler(request, ws):\n        nonlocal results\n        results = ws.subprotocol\n        assert ws.subprotocol is not None\n\n    _, response = SanicTestClient(app).websocket(\n        \"/ws\", subprotocols=subprotocols\n    )\n    assert response.opened is True\n    assert results == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('subprotocols,expected', ((['one'], 'one'), (['three', 'one'], 'one'), (['tree'], None), (None, None)))"
      ],
      "arguments": [
        "app",
        "subprotocols",
        "expected"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.opened is True",
        "assert results == expected",
        "assert ws.subprotocol is not None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_add_webscoket_route",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 695,
      "end_line_number": 705,
      "source_code": "def test_add_webscoket_route(app, strict_slashes):\n    ev = asyncio.Event()\n\n    async def handler(request, ws):\n        assert ws.subprotocol is None\n        ev.set()\n\n    app.add_websocket_route(handler, \"/ws\", strict_slashes=strict_slashes)\n    request, response = app.test_client.websocket(\"/ws\")\n    assert response.opened is True\n    assert ev.is_set()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('strict_slashes', [True, False, None])"
      ],
      "arguments": [
        "app",
        "strict_slashes"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.opened is True",
        "assert ev.is_set()",
        "assert ws.subprotocol is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_add_webscoket_route_with_version",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 708,
      "end_line_number": 718,
      "source_code": "def test_add_webscoket_route_with_version(app):\n    ev = asyncio.Event()\n\n    async def handler(request, ws):\n        assert ws.subprotocol is None\n        ev.set()\n\n    app.add_websocket_route(handler, \"/ws\", version=1)\n    request, response = app.test_client.websocket(\"/v1/ws\")\n    assert response.opened is True\n    assert ev.is_set()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.opened is True",
        "assert ev.is_set()",
        "assert ws.subprotocol is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_route_duplicate",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 721,
      "end_line_number": 740,
      "source_code": "def test_route_duplicate(app):\n    with pytest.raises(RouteExists):\n\n        @app.route(\"/test\")\n        async def handler1(request):\n            pass\n\n        @app.route(\"/test\")\n        async def handler2(request):\n            pass\n\n    with pytest.raises(RouteExists):\n\n        @app.route(\"/test/<dynamic>/\")\n        async def handler3(request, dynamic):\n            pass\n\n        @app.route(\"/test/<dynamic>/\")\n        async def handler4(request, dynamic):\n            pass",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_double_stack_route",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 743,
      "end_line_number": 752,
      "source_code": "def test_double_stack_route(app):\n    @app.route(\"/test/1\", name=\"test1\")\n    @app.route(\"/test/2\", name=\"test2\")\n    async def handler1(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/test/1\")\n    assert response.status == 200\n    request, response = app.test_client.get(\"/test/2\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_method_not_allowed",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 772,
      "end_line_number": 781,
      "source_code": "def test_method_not_allowed(app):\n    @app.route(\"/test\", methods=[\"GET\"])\n    async def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/test\")\n    assert response.status == 200\n\n    request, response = app.test_client.post(\"/test\")\n    assert response.status == 405",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.status == 405"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_static_add_route",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 785,
      "end_line_number": 799,
      "source_code": "def test_static_add_route(app, strict_slashes):\n    async def handler1(request):\n        return text(\"OK1\")\n\n    async def handler2(request):\n        return text(\"OK2\")\n\n    app.add_route(handler1, \"/test\", strict_slashes=strict_slashes)\n    app.add_route(handler2, \"/test2\", strict_slashes=strict_slashes)\n\n    request, response = app.test_client.get(\"/test\")\n    assert response.text == \"OK1\"\n\n    request, response = app.test_client.get(\"/test2\")\n    assert response.text == \"OK2\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('strict_slashes', [True, False, None])"
      ],
      "arguments": [
        "app",
        "strict_slashes"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK1'",
        "assert response.text == 'OK2'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_unquote_add_route",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 803,
      "end_line_number": 814,
      "source_code": "def test_unquote_add_route(app, unquote):\n    async def handler1(_, foo):\n        return text(foo)\n\n    app.add_route(handler1, \"/<foo>\", unquote=unquote)\n    value = \"\u554a\" if unquote else r\"%E5%95%8A\"\n\n    _, response = app.test_client.get(\"/\u554a\")\n    assert response.text == value\n\n    _, response = app.test_client.get(r\"/%E5%95%8A\")\n    assert response.text == value",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('unquote', [True, False, None])"
      ],
      "arguments": [
        "app",
        "unquote"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == value",
        "assert response.text == value"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_dynamic_add_route",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 817,
      "end_line_number": 828,
      "source_code": "def test_dynamic_add_route(app):\n    results = []\n\n    async def handler(request, name):\n        results.append(name)\n        return text(\"OK\")\n\n    app.add_route(handler, \"/folder/<name>\")\n    request, response = app.test_client.get(\"/folder/test123\")\n\n    assert response.text == \"OK\"\n    assert results[0] == \"test123\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert results[0] == 'test123'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_dynamic_add_route_string",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 831,
      "end_line_number": 847,
      "source_code": "def test_dynamic_add_route_string(app):\n    results = []\n\n    async def handler(request, name):\n        results.append(name)\n        return text(\"OK\")\n\n    app.add_route(handler, \"/folder/<name:str>\")\n    request, response = app.test_client.get(\"/folder/test123\")\n\n    assert response.text == \"OK\"\n    assert results[0] == \"test123\"\n\n    request, response = app.test_client.get(\"/folder/favicon.ico\")\n\n    assert response.text == \"OK\"\n    assert results[1] == \"favicon.ico\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert results[0] == 'test123'",
        "assert response.text == 'OK'",
        "assert results[1] == 'favicon.ico'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_dynamic_add_route_int",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 850,
      "end_line_number": 864,
      "source_code": "def test_dynamic_add_route_int(app):\n    results = []\n\n    async def handler(request, folder_id):\n        results.append(folder_id)\n        return text(\"OK\")\n\n    app.add_route(handler, \"/folder/<folder_id:int>\")\n\n    request, response = app.test_client.get(\"/folder/12345\")\n    assert response.text == \"OK\"\n    assert isinstance(results[0], int)\n\n    request, response = app.test_client.get(\"/folder/asdf\")\n    assert response.status == 404",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert isinstance(results[0], int)",
        "assert response.status == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_dynamic_add_route_number",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 867,
      "end_line_number": 893,
      "source_code": "def test_dynamic_add_route_number(app):\n    results = []\n\n    async def handler(request, weight):\n        results.append(weight)\n        return text(\"OK\")\n\n    app.add_route(handler, \"/weight/<weight:float>\")\n\n    request, response = app.test_client.get(\"/weight/12345\")\n    assert response.text == \"OK\"\n    assert isinstance(results[0], float)\n\n    request, response = app.test_client.get(\"/weight/1234.56\")\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/weight/.12\")\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/weight/12.\")\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/weight/1234-56\")\n    assert response.status == 404\n\n    request, response = app.test_client.get(\"/weight/12.34.56\")\n    assert response.status == 404",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK'",
        "assert isinstance(results[0], float)",
        "assert response.status == 200",
        "assert response.status == 200",
        "assert response.status == 200",
        "assert response.status == 404",
        "assert response.status == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_dynamic_add_route_regex",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 896,
      "end_line_number": 912,
      "source_code": "def test_dynamic_add_route_regex(app):\n    async def handler(request, folder_id):\n        return text(\"OK\")\n\n    app.add_route(handler, \"/folder/<folder_id:[A-Za-z0-9]{0,4}>\")\n\n    request, response = app.test_client.get(\"/folder/test\")\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/folder/test1\")\n    assert response.status == 404\n\n    request, response = app.test_client.get(\"/folder/test-123\")\n    assert response.status == 404\n\n    request, response = app.test_client.get(\"/folder/\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.status == 404",
        "assert response.status == 404",
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_dynamic_add_route_unhashable",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 915,
      "end_line_number": 931,
      "source_code": "def test_dynamic_add_route_unhashable(app):\n    async def handler(request, unhashable):\n        return text(\"OK\")\n\n    app.add_route(handler, \"/folder/<unhashable:[A-Za-z0-9/]+>/end/\")\n\n    request, response = app.test_client.get(\"/folder/test/asdf/end/\")\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/folder/test///////end/\")\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/folder/test/end/\")\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/folder/test/nope/\")\n    assert response.status == 404",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.status == 200",
        "assert response.status == 200",
        "assert response.status == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_add_route_duplicate",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 934,
      "end_line_number": 955,
      "source_code": "def test_add_route_duplicate(app):\n    with pytest.raises(RouteExists):\n\n        async def handler1(request):\n            pass\n\n        async def handler2(request):\n            pass\n\n        app.add_route(handler1, \"/test\")\n        app.add_route(handler2, \"/test\")\n\n    with pytest.raises(RouteExists):\n\n        async def handler1(request, dynamic):\n            pass\n\n        async def handler2(request, dynamic):\n            pass\n\n        app.add_route(handler1, \"/test/<dynamic>/\")\n        app.add_route(handler2, \"/test/<dynamic>/\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_add_route_method_not_allowed",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 958,
      "end_line_number": 968,
      "source_code": "def test_add_route_method_not_allowed(app):\n    async def handler(request):\n        return text(\"OK\")\n\n    app.add_route(handler, \"/test\", methods=[\"GET\"])\n\n    request, response = app.test_client.get(\"/test\")\n    assert response.status == 200\n\n    request, response = app.test_client.post(\"/test\")\n    assert response.status == 405",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.status == 405"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_removing_slash",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 971,
      "end_line_number": 980,
      "source_code": "def test_removing_slash(app):\n    @app.get(\"/rest/<resource>\")\n    def get(_):\n        pass\n\n    @app.post(\"/rest/<resource>\")\n    def post(_):\n        pass\n\n    assert len(app.router.routes_all.keys()) == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(app.router.routes_all.keys()) == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_overload_routes",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 983,
      "end_line_number": 1009,
      "source_code": "def test_overload_routes(app):\n    @app.route(\"/overload\", methods=[\"GET\"])\n    async def handler1(request):\n        return text(\"OK1\")\n\n    @app.route(\"/overload\", methods=[\"POST\", \"PUT\"])\n    async def handler2(request):\n        return text(\"OK2\")\n\n    request, response = app.test_client.get(\"/overload\")\n    assert response.text == \"OK1\"\n\n    request, response = app.test_client.post(\"/overload\")\n    assert response.text == \"OK2\"\n\n    request, response = app.test_client.put(\"/overload\")\n    assert response.text == \"OK2\"\n\n    request, response = app.test_client.delete(\"/overload\")\n    assert response.status == 405\n\n    app.router.reset()\n    with pytest.raises(RouteExists):\n\n        @app.route(\"/overload\", methods=[\"PUT\", \"DELETE\"])\n        async def handler3(request):\n            return text(\"Duplicated\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK1'",
        "assert response.text == 'OK2'",
        "assert response.text == 'OK2'",
        "assert response.status == 405"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.test_client.delete",
          "body": "def delete(self, request):\n    return text('I am delete method')"
        },
        {
          "name": "app.router.reset",
          "body": "@pytest.fixture(autouse=True)\ndef reset():\n    try:\n        del os.environ['SANIC_MOTD_OUTPUT']\n    except KeyError:\n        ..."
        }
      ]
    },
    {
      "name": "test_unmergeable_overload_routes",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 1012,
      "end_line_number": 1049,
      "source_code": "def test_unmergeable_overload_routes(app):\n    @app.route(\"/overload_whole\", methods=None)\n    async def handler1(request):\n        return text(\"OK1\")\n\n    @app.route(\"/overload_whole\", methods=[\"POST\", \"PUT\"])\n    async def handler2(request):\n        return text(\"OK1\")\n\n    assert len(app.router.static_routes) == 1\n    assert len(app.router.static_routes[(\"overload_whole\",)].methods) == 3\n\n    request, response = app.test_client.get(\"/overload_whole\")\n    assert response.text == \"OK1\"\n\n    request, response = app.test_client.post(\"/overload_whole\")\n    assert response.text == \"OK1\"\n\n    request, response = app.test_client.put(\"/overload_whole\")\n    assert response.text == \"OK1\"\n\n    app.router.reset()\n\n    @app.route(\"/overload_part\", methods=[\"GET\"])\n    async def handler3(request):\n        return text(\"OK1\")\n\n    with pytest.raises(RouteExists):\n\n        @app.route(\"/overload_part\")\n        async def handler4(request):\n            return text(\"Duplicated\")\n\n    request, response = app.test_client.get(\"/overload_part\")\n    assert response.text == \"OK1\"\n\n    request, response = app.test_client.post(\"/overload_part\")\n    assert response.status == 405",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(app.router.static_routes) == 1",
        "assert len(app.router.static_routes['overload_whole',].methods) == 3",
        "assert response.text == 'OK1'",
        "assert response.text == 'OK1'",
        "assert response.text == 'OK1'",
        "assert response.text == 'OK1'",
        "assert response.status == 405"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.router.reset",
          "body": "@pytest.fixture(autouse=True)\ndef reset():\n    try:\n        del os.environ['SANIC_MOTD_OUTPUT']\n    except KeyError:\n        ..."
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_unicode_routes",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 1052,
      "end_line_number": 1067,
      "source_code": "def test_unicode_routes(app):\n    @app.get(\"/\u4f60\u597d\")\n    def handler1(request):\n        return text(\"OK1\")\n\n    request, response = app.test_client.get(\"/\u4f60\u597d\")\n    assert response.text == \"OK1\"\n\n    app.router.reset()\n\n    @app.route(\"/overload/<param>\", methods=[\"GET\"], unquote=True)\n    async def handler2(request, param):\n        return text(\"OK2 \" + param)\n\n    request, response = app.test_client.get(\"/overload/\u4f60\u597d\")\n    assert response.text == \"OK2 \u4f60\u597d\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'OK1'",
        "assert response.text == 'OK2 \u4f60\u597d'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.router.reset",
          "body": "@pytest.fixture(autouse=True)\ndef reset():\n    try:\n        del os.environ['SANIC_MOTD_OUTPUT']\n    except KeyError:\n        ..."
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_uri_with_different_method_and_different_params",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 1070,
      "end_line_number": 1085,
      "source_code": "def test_uri_with_different_method_and_different_params(app):\n    @app.route(\"/ads/<ad_id>\", methods=[\"GET\"])\n    async def ad_get(request, ad_id):\n        return json({\"ad_id\": ad_id})\n\n    @app.route(\"/ads/<action>\", methods=[\"POST\"])\n    async def ad_post(request, action):\n        return json({\"action\": action})\n\n    request, response = app.test_client.get(\"/ads/1234\")\n    assert response.status == 200\n    assert response.json == {\"ad_id\": \"1234\"}\n\n    request, response = app.test_client.post(\"/ads/post\")\n    assert response.status == 200\n    assert response.json == {\"action\": \"post\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.json == {'ad_id': '1234'}",
        "assert response.status == 200",
        "assert response.json == {'action': 'post'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_uri_with_different_method_and_same_params",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 1088,
      "end_line_number": 1103,
      "source_code": "def test_uri_with_different_method_and_same_params(app):\n    @app.route(\"/ads/<ad_id>\", methods=[\"GET\"])\n    async def ad_get(request, ad_id):\n        return json({\"ad_id\": ad_id})\n\n    @app.route(\"/ads/<ad_id>\", methods=[\"POST\"])\n    async def ad_post(request, ad_id):\n        return json({\"ad_id\": ad_id})\n\n    request, response = app.test_client.get(\"/ads/1234\")\n    assert response.status == 200\n    assert response.json == {\"ad_id\": \"1234\"}\n\n    request, response = app.test_client.post(\"/ads/post\")\n    assert response.status == 200\n    assert response.json == {\"ad_id\": \"post\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.json == {'ad_id': '1234'}",
        "assert response.status == 200",
        "assert response.json == {'ad_id': 'post'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_route_raise_ParameterNameConflicts",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 1106,
      "end_line_number": 1112,
      "source_code": "def test_route_raise_ParameterNameConflicts(app):\n    @app.get(\"/api/v1/<user>/<user>/\")\n    def handler(request, user):\n        return text(\"OK\")\n\n    with pytest.raises(ParameterNameConflicts):\n        app.router.finalize()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_route_invalid_host",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 1115,
      "end_line_number": 1125,
      "source_code": "def test_route_invalid_host(app):\n    host = 321\n    with pytest.raises(ValueError) as excinfo:\n\n        @app.get(\"/test\", host=host)\n        def handler(request):\n            return text(\"pass\")\n\n    assert str(excinfo.value) == (\n        \"Expected either string or Iterable of \" \"host strings, not {!r}\"\n    ).format(host)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(excinfo.value) == 'Expected either string or Iterable of host strings, not {!r}'.format(host)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_route_with_regex_group",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 1128,
      "end_line_number": 1134,
      "source_code": "def test_route_with_regex_group(app):\n    @app.route(r\"/path/to/<ext:file\\.(txt)>\")\n    async def handler(request, ext):\n        return text(ext)\n\n    _, response = app.test_client.get(\"/path/to/file.txt\")\n    assert response.text == \"txt\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'txt'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_route_with_regex_named_group",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 1137,
      "end_line_number": 1143,
      "source_code": "def test_route_with_regex_named_group(app):\n    @app.route(r\"/path/to/<ext:file\\.(?P<ext>txt)>\")\n    async def handler(request, ext):\n        return text(ext)\n\n    _, response = app.test_client.get(\"/path/to/file.txt\")\n    assert response.text == \"txt\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'txt'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_route_with_regex_named_group_invalid",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 1146,
      "end_line_number": 1156,
      "source_code": "def test_route_with_regex_named_group_invalid(app):\n    @app.route(r\"/path/to/<ext:file\\.(?P<wrong>txt)>\")\n    async def handler(request, ext):\n        return text(ext)\n\n    with pytest.raises(InvalidUsage) as e:\n        app.router.finalize()\n\n    assert e.match(\n        re.escape(\"Named group (wrong) must match your named parameter (ext)\")\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert e.match(re.escape('Named group (wrong) must match your named parameter (ext)'))"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_route_with_regex_group_ambiguous",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 1159,
      "end_line_number": 1172,
      "source_code": "def test_route_with_regex_group_ambiguous(app):\n    @app.route(r\"/path/to/<ext:file(?:\\.)(txt)>\")\n    async def handler(request, ext):\n        return text(ext)\n\n    with pytest.raises(InvalidUsage) as e:\n        app.router.finalize()\n\n    assert e.match(\n        re.escape(\n            r\"Could not compile pattern file(?:\\.)(txt). Try using a named \"\n            \"group instead: '(?P<ext>your_matching_group)'\"\n        )\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert e.match(re.escape(\"Could not compile pattern file(?:\\\\.)(txt). Try using a named group instead: '(?P<ext>your_matching_group)'\"))"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_route_with_bad_named_param",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 1175,
      "end_line_number": 1181,
      "source_code": "def test_route_with_bad_named_param(app):\n    @app.route(\"/foo/<__bar__>\")\n    async def handler(request):\n        return text(\"...\")\n\n    with pytest.raises(SanicException):\n        app.router.finalize()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_routes_with_and_without_slash_definitions",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 1184,
      "end_line_number": 1237,
      "source_code": "def test_routes_with_and_without_slash_definitions(app):\n    bar = Blueprint(\"bar\", url_prefix=\"bar\")\n    baz = Blueprint(\"baz\", url_prefix=\"/baz\")\n    fizz = Blueprint(\"fizz\", url_prefix=\"fizz/\")\n    buzz = Blueprint(\"buzz\", url_prefix=\"/buzz/\")\n\n    instances = (\n        (app, \"foo\"),\n        (bar, \"bar\"),\n        (baz, \"baz\"),\n        (fizz, \"fizz\"),\n        (buzz, \"buzz\"),\n    )\n\n    for instance, term in instances:\n        route = f\"/{term}\" if isinstance(instance, Sanic) else \"\"\n\n        @instance.get(route, strict_slashes=True)\n        def get_without(request):\n            return text(f\"{term}_without\")\n\n        @instance.get(f\"{route}/\", strict_slashes=True)\n        def get_with(request):\n            return text(f\"{term}_with\")\n\n        @instance.post(route, strict_slashes=True)\n        def post_without(request):\n            return text(f\"{term}_without\")\n\n        @instance.post(f\"{route}/\", strict_slashes=True)\n        def post_with(request):\n            return text(f\"{term}_with\")\n\n    app.blueprint(bar)\n    app.blueprint(baz)\n    app.blueprint(fizz)\n    app.blueprint(buzz)\n\n    for _, term in instances:\n        _, response = app.test_client.get(f\"/{term}\")\n        assert response.status == 200\n        assert response.text == f\"{term}_without\"\n\n        _, response = app.test_client.get(f\"/{term}/\")\n        assert response.status == 200\n        assert response.text == f\"{term}_with\"\n\n        _, response = app.test_client.post(f\"/{term}\")\n        assert response.status == 200\n        assert response.text == f\"{term}_without\"\n\n        _, response = app.test_client.post(f\"/{term}/\")\n        assert response.status == 200\n        assert response.text == f\"{term}_with\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == f'{term}_without'",
        "assert response.status == 200",
        "assert response.text == f'{term}_with'",
        "assert response.status == 200",
        "assert response.text == f'{term}_without'",
        "assert response.status == 200",
        "assert response.text == f'{term}_with'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "instance.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "instance.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "instance.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "instance.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_added_route_ctx_kwargs",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 1240,
      "end_line_number": 1248,
      "source_code": "def test_added_route_ctx_kwargs(app):\n    @app.route(\"/\", ctx_foo=\"foo\", ctx_bar=99)\n    async def handler(request: Request):\n        return empty()\n\n    request, _ = app.test_client.get(\"/\")\n\n    assert request.route.ctx.foo == \"foo\"\n    assert request.route.ctx.bar == 99",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.route.ctx.foo == 'foo'",
        "assert request.route.ctx.bar == 99"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_added_bad_route_kwargs",
      "module": "test_routes",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_routes.py",
      "line_number": 1251,
      "end_line_number": 1256,
      "source_code": "def test_added_bad_route_kwargs(app):\n    message = \"Unexpected keyword arguments: foo, bar\"\n    with pytest.raises(TypeError, match=message):\n\n        @app.route(\"/\", foo=\"foo\", bar=99)\n        async def handler(request: Request): ...",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "re",
        "pytest",
        "sanic_routing.exceptions.InvalidUsage",
        "sanic_routing.exceptions.ParameterNameConflicts",
        "sanic_routing.exceptions.RouteExists",
        "sanic_testing.testing.SanicTestClient",
        "sanic.Blueprint",
        "sanic.Sanic",
        "sanic.constants.HTTP_METHODS",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.response.text",
        "uuid"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_methods",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_views.py",
      "line_number": 11,
      "end_line_number": 37,
      "source_code": "def test_methods(app, method):\n    class DummyView(HTTPMethodView):\n        async def get(self, request):\n            return text(\"\", headers={\"method\": \"GET\"})\n\n        def post(self, request):\n            return text(\"\", headers={\"method\": \"POST\"})\n\n        async def put(self, request):\n            return text(\"\", headers={\"method\": \"PUT\"})\n\n        def head(self, request):\n            return text(\"\", headers={\"method\": \"HEAD\"})\n\n        def options(self, request):\n            return text(\"\", headers={\"method\": \"OPTIONS\"})\n\n        async def patch(self, request):\n            return text(\"\", headers={\"method\": \"PATCH\"})\n\n        def delete(self, request):\n            return text(\"\", headers={\"method\": \"DELETE\"})\n\n    app.add_route(DummyView.as_view(), \"/\")\n\n    request, response = getattr(app.test_client, method.lower())(\"/\")\n    assert response.headers[\"method\"] == method",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('method', HTTP_METHODS)"
      ],
      "arguments": [
        "app",
        "method"
      ],
      "imports": [
        "pytest",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.headers['method'] == method"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_unexisting_methods",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_views.py",
      "line_number": 40,
      "end_line_number": 49,
      "source_code": "def test_unexisting_methods(app):\n    class DummyView(HTTPMethodView):\n        def get(self, request):\n            return text(\"I am get method\")\n\n    app.add_route(DummyView.as_view(), \"/\")\n    request, response = app.test_client.get(\"/\")\n    assert response.body == b\"I am get method\"\n    request, response = app.test_client.post(\"/\")\n    assert b\"Method POST not allowed for URL /\" in response.body",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.body == b'I am get method'",
        "assert b'Method POST not allowed for URL /' in response.body"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_argument_methods",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_views.py",
      "line_number": 52,
      "end_line_number": 61,
      "source_code": "def test_argument_methods(app):\n    class DummyView(HTTPMethodView):\n        def get(self, request, my_param_here):\n            return text(\"I am get method with %s\" % my_param_here)\n\n    app.add_route(DummyView.as_view(), \"/<my_param_here>\")\n\n    request, response = app.test_client.get(\"/test123\")\n\n    assert response.text == \"I am get method with test123\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'I am get method with test123'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_with_bp",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_views.py",
      "line_number": 64,
      "end_line_number": 76,
      "source_code": "def test_with_bp(app):\n    bp = Blueprint(\"test_text\")\n\n    class DummyView(HTTPMethodView):\n        def get(self, request):\n            return text(\"I am get method\")\n\n    bp.add_route(DummyView.as_view(), \"/\")\n\n    app.blueprint(bp)\n    request, response = app.test_client.get(\"/\")\n\n    assert response.text == \"I am get method\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'I am get method'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_with_attach",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_views.py",
      "line_number": 79,
      "end_line_number": 88,
      "source_code": "def test_with_attach(app):\n    class DummyView(HTTPMethodView):\n        def get(self, request):\n            return text(\"I am get method\")\n\n    DummyView.attach(app, \"/\")\n\n    request, response = app.test_client.get(\"/\")\n\n    assert response.text == \"I am get method\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'I am get method'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_with_sub_init",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_views.py",
      "line_number": 91,
      "end_line_number": 98,
      "source_code": "def test_with_sub_init(app):\n    class DummyView(HTTPMethodView, attach=app, uri=\"/\"):\n        def get(self, request):\n            return text(\"I am get method\")\n\n    request, response = app.test_client.get(\"/\")\n\n    assert response.text == \"I am get method\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'I am get method'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_with_attach_and_bp",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_views.py",
      "line_number": 101,
      "end_line_number": 113,
      "source_code": "def test_with_attach_and_bp(app):\n    bp = Blueprint(\"test_text\")\n\n    class DummyView(HTTPMethodView):\n        def get(self, request):\n            return text(\"I am get method\")\n\n    DummyView.attach(bp, \"/\")\n\n    app.blueprint(bp)\n    request, response = app.test_client.get(\"/\")\n\n    assert response.text == \"I am get method\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'I am get method'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_with_sub_init_and_bp",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_views.py",
      "line_number": 116,
      "end_line_number": 126,
      "source_code": "def test_with_sub_init_and_bp(app):\n    bp = Blueprint(\"test_text\")\n\n    class DummyView(HTTPMethodView, attach=bp, uri=\"/\"):\n        def get(self, request):\n            return text(\"I am get method\")\n\n    app.blueprint(bp)\n    request, response = app.test_client.get(\"/\")\n\n    assert response.text == \"I am get method\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'I am get method'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_with_bp_with_url_prefix",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_views.py",
      "line_number": 129,
      "end_line_number": 141,
      "source_code": "def test_with_bp_with_url_prefix(app):\n    bp = Blueprint(\"test_text\", url_prefix=\"/test1\")\n\n    class DummyView(HTTPMethodView):\n        def get(self, request):\n            return text(\"I am get method\")\n\n    bp.add_route(DummyView.as_view(), \"/\")\n\n    app.blueprint(bp)\n    request, response = app.test_client.get(\"/test1/\")\n\n    assert response.text == \"I am get method\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'I am get method'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_with_middleware",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_views.py",
      "line_number": 144,
      "end_line_number": 160,
      "source_code": "def test_with_middleware(app):\n    class DummyView(HTTPMethodView):\n        def get(self, request):\n            return text(\"I am get method\")\n\n    app.add_route(DummyView.as_view(), \"/\")\n\n    results = []\n\n    @app.middleware\n    async def handler(request):\n        results.append(request)\n\n    request, response = app.test_client.get(\"/\")\n\n    assert response.text == \"I am get method\"\n    assert type(results[0]) is Request",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'I am get method'",
        "assert type(results[0]) is Request"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_with_middleware_response",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_views.py",
      "line_number": 163,
      "end_line_number": 186,
      "source_code": "def test_with_middleware_response(app):\n    results = []\n\n    @app.middleware(\"request\")\n    async def process_request(request):\n        results.append(request)\n\n    @app.middleware(\"response\")\n    async def process_response(request, response):\n        results.append(request)\n        results.append(response)\n\n    class DummyView(HTTPMethodView):\n        def get(self, request):\n            return text(\"I am get method\")\n\n    app.add_route(DummyView.as_view(), \"/\")\n\n    request, response = app.test_client.get(\"/\")\n\n    assert response.text == \"I am get method\"\n    assert type(results[0]) is Request\n    assert type(results[1]) is Request\n    assert isinstance(results[2], HTTPResponse)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'I am get method'",
        "assert type(results[0]) is Request",
        "assert type(results[1]) is Request",
        "assert isinstance(results[2], HTTPResponse)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_with_custom_class_methods",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_views.py",
      "line_number": 189,
      "end_line_number": 204,
      "source_code": "def test_with_custom_class_methods(app):\n    class DummyView(HTTPMethodView):\n        global_var = 0\n\n        def _iternal_method(self):\n            self.global_var += 10\n\n        def get(self, request):\n            self._iternal_method()\n            return text(\n                f\"I am get method and global var \" f\"is {self.global_var}\"\n            )\n\n    app.add_route(DummyView.as_view(), \"/\")\n    request, response = app.test_client.get(\"/\")\n    assert response.text == \"I am get method and global var is 10\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'I am get method and global var is 10'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "self._iternal_method",
          "body": "def _iternal_method(self):\n    self.global_var += 10"
        }
      ]
    },
    {
      "name": "test_with_decorator",
      "module": "test_views",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_views.py",
      "line_number": 207,
      "end_line_number": 226,
      "source_code": "def test_with_decorator(app):\n    results = []\n\n    def stupid_decorator(view):\n        def decorator(*args, **kwargs):\n            results.append(1)\n            return view(*args, **kwargs)\n\n        return decorator\n\n    class DummyView(HTTPMethodView):\n        decorators = [stupid_decorator]\n\n        def get(self, request):\n            return text(\"I am get method\")\n\n    app.add_route(DummyView.as_view(), \"/\")\n    request, response = app.test_client.get(\"/\")\n    assert response.text == \"I am get method\"\n    assert results[0] == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic.blueprints.Blueprint",
        "sanic.constants.HTTP_METHODS",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text",
        "sanic.views.HTTPMethodView"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'I am get method'",
        "assert results[0] == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_vhosts",
      "module": "test_vhosts",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_vhosts.py",
      "line_number": 9,
      "end_line_number": 26,
      "source_code": "def test_vhosts():\n    app = Sanic(\"app\")\n\n    @app.route(\"/\", host=\"example.com\")\n    async def handler1(request):\n        return text(\"You're at example.com!\")\n\n    @app.route(\"/\", host=\"subdomain.example.com\")\n    async def handler2(request):\n        return text(\"You're at subdomain.example.com!\")\n\n    headers = {\"Host\": \"example.com\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert response.text == \"You're at example.com!\"\n\n    headers = {\"Host\": \"subdomain.example.com\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert response.text == \"You're at subdomain.example.com!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "sanic_routing.exceptions.RouteExists",
        "sanic.Sanic",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == \"You're at example.com!\"",
        "assert response.text == \"You're at subdomain.example.com!\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_vhosts_with_list",
      "module": "test_vhosts",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_vhosts.py",
      "line_number": 29,
      "end_line_number": 40,
      "source_code": "def test_vhosts_with_list(app):\n    @app.route(\"/\", host=[\"hello.com\", \"world.com\"])\n    async def handler(request):\n        return text(\"Hello, world!\")\n\n    headers = {\"Host\": \"hello.com\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert response.text == \"Hello, world!\"\n\n    headers = {\"Host\": \"world.com\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert response.text == \"Hello, world!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic_routing.exceptions.RouteExists",
        "sanic.Sanic",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'Hello, world!'",
        "assert response.text == 'Hello, world!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_vhosts_with_defaults",
      "module": "test_vhosts",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_vhosts.py",
      "line_number": 43,
      "end_line_number": 56,
      "source_code": "def test_vhosts_with_defaults(app):\n    @app.route(\"/\", host=\"hello.com\")\n    async def handler1(request):\n        return text(\"Hello, world!\")\n\n    with pytest.raises(RouteExists):\n\n        @app.route(\"/\")\n        async def handler2(request):\n            return text(\"default\")\n\n    headers = {\"Host\": \"hello.com\"}\n    request, response = app.test_client.get(\"/\", headers=headers)\n    assert response.text == \"Hello, world!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic_routing.exceptions.RouteExists",
        "sanic.Sanic",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'Hello, world!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_get_logo_returns_expected_logo",
      "module": "test_logo",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_logo.py",
      "line_number": 25,
      "end_line_number": 29,
      "source_code": "def test_get_logo_returns_expected_logo(tty, full, expected):\n    with patch(\"sys.stdout.isatty\") as isatty:\n        isatty.return_value = tty\n        logo = get_logo(full=full)\n    assert logo is expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('tty,full,expected', ((True, False, COLOR_LOGO), (True, True, FULL_COLOR_LOGO), (False, False, BASE_LOGO), (False, True, BASE_LOGO)))"
      ],
      "arguments": [
        "tty",
        "full",
        "expected"
      ],
      "imports": [
        "os",
        "sys",
        "unittest.mock.patch",
        "pytest",
        "sanic.application.logo.BASE_LOGO",
        "sanic.application.logo.COLOR_LOGO",
        "sanic.application.logo.FULL_COLOR_LOGO",
        "sanic.application.logo.get_logo"
      ],
      "fixtures": [],
      "assertions": [
        "assert logo is expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ]
    },
    {
      "name": "test_get_logo_returns_no_colors_on_apple_terminal",
      "module": "test_logo",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_logo.py",
      "line_number": 32,
      "end_line_number": 41,
      "source_code": "def test_get_logo_returns_no_colors_on_apple_terminal():\n    platform = sys.platform\n    sys.platform = \"darwin\"\n    os.environ[\"TERM_PROGRAM\"] = \"Apple_Terminal\"\n    with patch(\"sys.stdout.isatty\") as isatty:\n        isatty.return_value = False\n        logo = get_logo()\n    assert \"\\033\" not in logo\n    sys.platform = platform\n    del os.environ[\"TERM_PROGRAM\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "os",
        "sys",
        "unittest.mock.patch",
        "pytest",
        "sanic.application.logo.BASE_LOGO",
        "sanic.application.logo.COLOR_LOGO",
        "sanic.application.logo.FULL_COLOR_LOGO",
        "sanic.application.logo.get_logo"
      ],
      "fixtures": [],
      "assertions": [
        "assert '\\x1b' not in logo"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ]
    },
    {
      "name": "test_bp_group_indexing",
      "module": "test_blueprint_group",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprint_group.py",
      "line_number": 18,
      "end_line_number": 26,
      "source_code": "def test_bp_group_indexing(app: Sanic):\n    blueprint_1 = Blueprint(\"blueprint_1\", url_prefix=\"/bp1\")\n    blueprint_2 = Blueprint(\"blueprint_2\", url_prefix=\"/bp2\")\n\n    group = Blueprint.group(blueprint_1, blueprint_2)\n    assert group[0] == blueprint_1\n\n    with raises(expected_exception=IndexError):\n        _ = group[3]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "pytest.raises",
        "sanic.app.Sanic",
        "sanic.blueprint_group.BlueprintGroup",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert group[0] == blueprint_1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_bp_group_set_item_by_index",
      "module": "test_blueprint_group",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprint_group.py",
      "line_number": 29,
      "end_line_number": 36,
      "source_code": "def test_bp_group_set_item_by_index(app: Sanic):\n    blueprint_1 = Blueprint(\"blueprint_1\", url_prefix=\"/bp1\")\n    blueprint_2 = Blueprint(\"blueprint_2\", url_prefix=\"/bp2\")\n\n    group = Blueprint.group(blueprint_1, blueprint_2)\n    group[0] = blueprint_2\n\n    assert group[0] == blueprint_2",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "pytest.raises",
        "sanic.app.Sanic",
        "sanic.blueprint_group.BlueprintGroup",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert group[0] == blueprint_2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_bp_group_with_additional_route_params",
      "module": "test_blueprint_group",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprint_group.py",
      "line_number": 39,
      "end_line_number": 101,
      "source_code": "def test_bp_group_with_additional_route_params(app: Sanic):\n    blueprint_1 = Blueprint(\"blueprint_1\", url_prefix=\"/bp1\")\n    blueprint_2 = Blueprint(\"blueprint_2\", url_prefix=\"/bp2\")\n\n    @blueprint_1.route(\n        \"/request_path\", methods=frozenset({\"PUT\", \"POST\"}), version=2\n    )\n    def blueprint_1_v2_method_with_put_and_post(request: Request):\n        if request.method == \"PUT\":\n            return text(\"PUT_OK\")\n        elif request.method == \"POST\":\n            return text(\"POST_OK\")\n\n    @blueprint_2.route(\n        \"/route/<param>\", methods=frozenset({\"DELETE\", \"PATCH\"}), name=\"test\"\n    )\n    def blueprint_2_named_method(request: Request, param):\n        if request.method == \"DELETE\":\n            return text(f\"DELETE_{param}\")\n        elif request.method == \"PATCH\":\n            return text(f\"PATCH_{param}\")\n\n    blueprint_group = Blueprint.group(\n        blueprint_1, blueprint_2, url_prefix=\"/api\"\n    )\n\n    @blueprint_group.middleware(\"request\")\n    def authenticate_request(request: Request):\n        global AUTH\n        auth = request.headers.get(\"authorization\")\n        if auth:\n            # Dummy auth check. We can have anything here and it's fine.\n            if AUTH not in auth:\n                return text(\"Unauthorized\", status=401)\n        else:\n            return text(\"Unauthorized\", status=401)\n\n    @blueprint_group.middleware(\"response\")\n    def enhance_response_middleware(request: Request, response: HTTPResponse):\n        response.headers.add(\"x-test-middleware\", \"value\")\n\n    app.blueprint(blueprint_group)\n\n    header = {\"authorization\": \" \".join([\"Basic\", AUTH])}\n    _, response = app.test_client.put(\n        \"/v2/api/bp1/request_path\", headers=header\n    )\n    assert response.text == \"PUT_OK\"\n    assert response.headers.get(\"x-test-middleware\") == \"value\"\n\n    _, response = app.test_client.post(\n        \"/v2/api/bp1/request_path\", headers=header\n    )\n    assert response.text == \"POST_OK\"\n\n    _, response = app.test_client.delete(\"/api/bp2/route/bp2\", headers=header)\n    assert response.text == \"DELETE_bp2\"\n\n    _, response = app.test_client.patch(\"/api/bp2/route/bp2\", headers=header)\n    assert response.text == \"PATCH_bp2\"\n\n    _, response = app.test_client.put(\"/v2/api/bp1/request_path\")\n    assert response.status == 401",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "pytest.raises",
        "sanic.app.Sanic",
        "sanic.blueprint_group.BlueprintGroup",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'PUT_OK'",
        "assert response.headers.get('x-test-middleware') == 'value'",
        "assert response.text == 'POST_OK'",
        "assert response.text == 'DELETE_bp2'",
        "assert response.text == 'PATCH_bp2'",
        "assert response.status == 401"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "app.test_client.patch('/api/bp2/route/bp2', headers=header)"
      ],
      "methods_under_test": [
        {
          "name": "app.test_client.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.delete",
          "body": "def delete(self, request):\n    return text('I am delete method')"
        },
        {
          "name": "app.test_client.patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "app.test_client.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "request.headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response.headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_bp_group",
      "module": "test_blueprint_group",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprint_group.py",
      "line_number": 104,
      "end_line_number": 213,
      "source_code": "def test_bp_group(app: Sanic):\n    blueprint_1 = Blueprint(\"blueprint_1\", url_prefix=\"/bp1\")\n    blueprint_2 = Blueprint(\"blueprint_2\", url_prefix=\"/bp2\")\n\n    @blueprint_1.route(\"/\")\n    def blueprint_1_default_route(request):\n        return text(\"BP1_OK\")\n\n    @blueprint_1.route(\"/invalid\")\n    def blueprint_1_error(request: Request):\n        raise BadRequest(\"Invalid\")\n\n    @blueprint_2.route(\"/\")\n    def blueprint_2_default_route(request):\n        return text(\"BP2_OK\")\n\n    @blueprint_2.route(\"/error\")\n    def blueprint_2_error(request: Request):\n        raise ServerError(\"Error\")\n\n    blueprint_group_1 = Blueprint.group(\n        blueprint_1, blueprint_2, url_prefix=\"/bp\"\n    )\n\n    blueprint_3 = Blueprint(\"blueprint_3\", url_prefix=\"/bp3\")\n\n    @blueprint_group_1.exception(BadRequest)\n    def handle_group_exception(request, exception):\n        return text(\"BP1_ERR_OK\")\n\n    @blueprint_group_1.middleware(\"request\")\n    def blueprint_group_1_middleware(request):\n        global MIDDLEWARE_INVOKE_COUNTER\n        MIDDLEWARE_INVOKE_COUNTER[\"request\"] += 1\n\n    @blueprint_group_1.middleware\n    def blueprint_group_1_middleware_not_called(request):\n        global MIDDLEWARE_INVOKE_COUNTER\n        MIDDLEWARE_INVOKE_COUNTER[\"request\"] += 1\n\n    @blueprint_group_1.on_request\n    def blueprint_group_1_convenience_1(request):\n        global MIDDLEWARE_INVOKE_COUNTER\n        MIDDLEWARE_INVOKE_COUNTER[\"request\"] += 1\n\n    @blueprint_group_1.on_request()\n    def blueprint_group_1_convenience_2(request):\n        global MIDDLEWARE_INVOKE_COUNTER\n        MIDDLEWARE_INVOKE_COUNTER[\"request\"] += 1\n\n    @blueprint_3.route(\"/\")\n    def blueprint_3_default_route(request):\n        return text(\"BP3_OK\")\n\n    @blueprint_3.route(\"/forbidden\")\n    def blueprint_3_forbidden(request: Request):\n        raise Forbidden(\"Forbidden\")\n\n    blueprint_group_2 = Blueprint.group(\n        blueprint_group_1, blueprint_3, url_prefix=\"/api\"\n    )\n\n    @blueprint_group_2.exception(SanicException)\n    def handle_non_handled_exception(request, exception):\n        return text(\"BP2_ERR_OK\")\n\n    @blueprint_group_2.middleware(\"response\")\n    def blueprint_group_2_middleware(request, response):\n        global MIDDLEWARE_INVOKE_COUNTER\n        MIDDLEWARE_INVOKE_COUNTER[\"response\"] += 1\n\n    @blueprint_group_2.on_response\n    def blueprint_group_2_middleware_convenience_1(request, response):\n        global MIDDLEWARE_INVOKE_COUNTER\n        MIDDLEWARE_INVOKE_COUNTER[\"response\"] += 1\n\n    @blueprint_group_2.on_response()\n    def blueprint_group_2_middleware_convenience_2(request, response):\n        global MIDDLEWARE_INVOKE_COUNTER\n        MIDDLEWARE_INVOKE_COUNTER[\"response\"] += 1\n\n    app.blueprint(blueprint_group_2)\n\n    @app.route(\"/\")\n    def app_default_route(request):\n        return text(\"APP_OK\")\n\n    _, response = app.test_client.get(\"/\")\n    assert response.text == \"APP_OK\"\n\n    _, response = app.test_client.get(\"/api/bp/bp1\")\n    assert response.text == \"BP1_OK\"\n\n    _, response = app.test_client.get(\"/api/bp/bp1/invalid\")\n    assert response.text == \"BP1_ERR_OK\"\n\n    _, response = app.test_client.get(\"/api/bp/bp2\")\n    assert response.text == \"BP2_OK\"\n\n    _, response = app.test_client.get(\"/api/bp/bp2/error\")\n    assert response.text == \"BP2_ERR_OK\"\n\n    _, response = app.test_client.get(\"/api/bp3\")\n    assert response.text == \"BP3_OK\"\n\n    _, response = app.test_client.get(\"/api/bp3/forbidden\")\n    assert response.text == \"BP2_ERR_OK\"\n\n    assert MIDDLEWARE_INVOKE_COUNTER[\"response\"] == 18\n    assert MIDDLEWARE_INVOKE_COUNTER[\"request\"] == 16",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "pytest.raises",
        "sanic.app.Sanic",
        "sanic.blueprint_group.BlueprintGroup",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'APP_OK'",
        "assert response.text == 'BP1_OK'",
        "assert response.text == 'BP1_ERR_OK'",
        "assert response.text == 'BP2_OK'",
        "assert response.text == 'BP2_ERR_OK'",
        "assert response.text == 'BP3_OK'",
        "assert response.text == 'BP2_ERR_OK'",
        "assert MIDDLEWARE_INVOKE_COUNTER['response'] == 18",
        "assert MIDDLEWARE_INVOKE_COUNTER['request'] == 16"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "blueprint_group_1.exception",
          "body": "@app.route('/')\ndef exception(request):\n    raise SanicExceptionTestException(\"You won't see me\")"
        },
        {
          "name": "blueprint_group_2.exception",
          "body": "@app.route('/')\ndef exception(request):\n    raise SanicExceptionTestException(\"You won't see me\")"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_bp_group_list_operations",
      "module": "test_blueprint_group",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprint_group.py",
      "line_number": 216,
      "end_line_number": 249,
      "source_code": "def test_bp_group_list_operations(app: Sanic):\n    blueprint_1 = Blueprint(\"blueprint_1\", url_prefix=\"/bp1\")\n    blueprint_2 = Blueprint(\"blueprint_2\", url_prefix=\"/bp2\")\n\n    @blueprint_1.route(\"/\")\n    def blueprint_1_default_route(request):\n        return text(\"BP1_OK\")\n\n    @blueprint_2.route(\"/\")\n    def blueprint_2_default_route(request):\n        return text(\"BP2_OK\")\n\n    blueprint_group_1 = Blueprint.group(\n        blueprint_1, blueprint_2, url_prefix=\"/bp\"\n    )\n\n    blueprint_3 = Blueprint(\"blueprint_2\", url_prefix=\"/bp3\")\n\n    @blueprint_3.route(\"/second\")\n    def blueprint_3_second_route(request):\n        return text(\"BP3_OK\")\n\n    assert len(blueprint_group_1) == 2\n\n    blueprint_group_1.append(blueprint_3)\n    assert len(blueprint_group_1) == 3\n\n    del blueprint_group_1[2]\n    assert len(blueprint_group_1) == 2\n\n    blueprint_group_1[1] = blueprint_3\n    assert len(blueprint_group_1) == 2\n\n    assert blueprint_group_1.url_prefix == \"/bp\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "pytest.raises",
        "sanic.app.Sanic",
        "sanic.blueprint_group.BlueprintGroup",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(blueprint_group_1) == 2",
        "assert len(blueprint_group_1) == 3",
        "assert len(blueprint_group_1) == 2",
        "assert len(blueprint_group_1) == 2",
        "assert blueprint_group_1.url_prefix == '/bp'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_bp_group_as_list",
      "module": "test_blueprint_group",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprint_group.py",
      "line_number": 252,
      "end_line_number": 256,
      "source_code": "def test_bp_group_as_list():\n    blueprint_1 = Blueprint(\"blueprint_1\", url_prefix=\"/bp1\")\n    blueprint_2 = Blueprint(\"blueprint_2\", url_prefix=\"/bp2\")\n    blueprint_group_1 = Blueprint.group([blueprint_1, blueprint_2])\n    assert len(blueprint_group_1) == 2",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "pytest.raises",
        "sanic.app.Sanic",
        "sanic.blueprint_group.BlueprintGroup",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(blueprint_group_1) == 2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_bp_group_as_nested_group",
      "module": "test_blueprint_group",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprint_group.py",
      "line_number": 259,
      "end_line_number": 265,
      "source_code": "def test_bp_group_as_nested_group():\n    blueprint_1 = Blueprint(\"blueprint_1\", url_prefix=\"/bp1\")\n    blueprint_2 = Blueprint(\"blueprint_2\", url_prefix=\"/bp2\")\n    blueprint_group_1 = Blueprint.group(\n        Blueprint.group(blueprint_1, blueprint_2)\n    )\n    assert len(blueprint_group_1) == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "pytest.raises",
        "sanic.app.Sanic",
        "sanic.blueprint_group.BlueprintGroup",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(blueprint_group_1) == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_blueprint_group_insert",
      "module": "test_blueprint_group",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprint_group.py",
      "line_number": 268,
      "end_line_number": 302,
      "source_code": "def test_blueprint_group_insert():\n    blueprint_1 = Blueprint(\n        \"blueprint_1\", url_prefix=\"/bp1\", strict_slashes=True, version=1\n    )\n    blueprint_2 = Blueprint(\"blueprint_2\", url_prefix=\"/bp2\")\n    blueprint_3 = Blueprint(\"blueprint_3\", url_prefix=None)\n    group = BlueprintGroup(\n        url_prefix=\"/test\", version=1.3, strict_slashes=False\n    )\n    group.insert(0, blueprint_1)\n    group.insert(0, blueprint_2)\n    group.insert(0, blueprint_3)\n\n    @blueprint_1.route(\"/\")\n    def blueprint_1_default_route(request):\n        return text(\"BP1_OK\")\n\n    @blueprint_2.route(\"/\")\n    def blueprint_2_default_route(request):\n        return text(\"BP2_OK\")\n\n    @blueprint_3.route(\"/\")\n    def blueprint_3_default_route(request):\n        return text(\"BP3_OK\")\n\n    app = Sanic(\"PropTest\")\n    app.blueprint(group)\n    app.router.finalize()\n\n    routes = [(route.path, route.strict) for route in app.router.routes]\n\n    assert len(routes) == 3\n    assert (\"v1/test/bp1/\", True) in routes\n    assert (\"v1.3/test/bp2\", False) in routes\n    assert (\"v1.3/test\", False) in routes",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "pytest.raises",
        "sanic.app.Sanic",
        "sanic.blueprint_group.BlueprintGroup",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(routes) == 3",
        "assert ('v1/test/bp1/', True) in routes",
        "assert ('v1.3/test/bp2', False) in routes",
        "assert ('v1.3/test', False) in routes"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_bp_group_properties",
      "module": "test_blueprint_group",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprint_group.py",
      "line_number": 305,
      "end_line_number": 337,
      "source_code": "def test_bp_group_properties():\n    blueprint_1 = Blueprint(\"blueprint_1\", url_prefix=\"/bp1\")\n    blueprint_2 = Blueprint(\"blueprint_2\", url_prefix=\"/bp2\")\n    group = Blueprint.group(\n        blueprint_1,\n        blueprint_2,\n        version=1,\n        version_prefix=\"/api/v\",\n        url_prefix=\"/grouped\",\n        strict_slashes=True,\n    )\n    primary = Blueprint.group(group, url_prefix=\"/primary\")\n\n    @blueprint_1.route(\"/\")\n    def blueprint_1_default_route(request):\n        return text(\"BP1_OK\")\n\n    @blueprint_2.route(\"/\")\n    def blueprint_2_default_route(request):\n        return text(\"BP2_OK\")\n\n    app = Sanic(\"PropTest\")\n    app.blueprint(group)\n    app.blueprint(primary)\n    app.router.finalize()\n\n    routes = [route.path for route in app.router.routes]\n\n    assert len(routes) == 4\n    assert \"api/v1/grouped/bp1/\" in routes\n    assert \"api/v1/grouped/bp2/\" in routes\n    assert \"api/v1/primary/grouped/bp1\" in routes\n    assert \"api/v1/primary/grouped/bp2\" in routes",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "pytest.raises",
        "sanic.app.Sanic",
        "sanic.blueprint_group.BlueprintGroup",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(routes) == 4",
        "assert 'api/v1/grouped/bp1/' in routes",
        "assert 'api/v1/grouped/bp2/' in routes",
        "assert 'api/v1/primary/grouped/bp1' in routes",
        "assert 'api/v1/primary/grouped/bp2' in routes"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_nested_bp_group_properties",
      "module": "test_blueprint_group",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprint_group.py",
      "line_number": 340,
      "end_line_number": 354,
      "source_code": "def test_nested_bp_group_properties():\n    one = Blueprint(\"one\", url_prefix=\"/one\")\n    two = Blueprint.group(one)\n    three = Blueprint.group(two, url_prefix=\"/three\")\n\n    @one.route(\"/four\")\n    def handler(request):\n        return text(\"pi\")\n\n    app = Sanic(\"PropTest\")\n    app.blueprint(three)\n    app.router.finalize()\n\n    routes = [route.path for route in app.router.routes]\n    assert routes == [\"three/one/four\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "pytest.raises",
        "sanic.app.Sanic",
        "sanic.blueprint_group.BlueprintGroup",
        "sanic.blueprints.Blueprint",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert routes == ['three/one/four']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_route",
      "module": "test_versioning",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_versioning.py",
      "line_number": 14,
      "end_line_number": 18,
      "source_code": "def test_route(app, handler):\n    app.route(\"/\", version=1)(handler)\n\n    _, response = app.test_client.get(\"/v1\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "handler"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_bp",
      "module": "test_versioning",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_versioning.py",
      "line_number": 21,
      "end_line_number": 27,
      "source_code": "def test_bp(app, handler):\n    bp = Blueprint(\"Test\", version=1)\n    bp.route(\"/\")(handler)\n    app.blueprint(bp)\n\n    _, response = app.test_client.get(\"/v1\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "handler"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_bp_use_route",
      "module": "test_versioning",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_versioning.py",
      "line_number": 30,
      "end_line_number": 36,
      "source_code": "def test_bp_use_route(app, handler):\n    bp = Blueprint(\"Test\", version=1)\n    bp.route(\"/\", version=1.1)(handler)\n    app.blueprint(bp)\n\n    _, response = app.test_client.get(\"/v1.1\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "handler"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_bp_group",
      "module": "test_versioning",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_versioning.py",
      "line_number": 39,
      "end_line_number": 46,
      "source_code": "def test_bp_group(app, handler):\n    bp = Blueprint(\"Test\")\n    bp.route(\"/\")(handler)\n    group = Blueprint.group(bp, version=1)\n    app.blueprint(group)\n\n    _, response = app.test_client.get(\"/v1\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "handler"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_bp_group_use_bp",
      "module": "test_versioning",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_versioning.py",
      "line_number": 49,
      "end_line_number": 56,
      "source_code": "def test_bp_group_use_bp(app, handler):\n    bp = Blueprint(\"Test\", version=1.1)\n    bp.route(\"/\")(handler)\n    group = Blueprint.group(bp, version=1)\n    app.blueprint(group)\n\n    _, response = app.test_client.get(\"/v1.1\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "handler"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_bp_group_use_registration",
      "module": "test_versioning",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_versioning.py",
      "line_number": 59,
      "end_line_number": 66,
      "source_code": "def test_bp_group_use_registration(app, handler):\n    bp = Blueprint(\"Test\", version=1.1)\n    bp.route(\"/\")(handler)\n    group = Blueprint.group(bp, version=1)\n    app.blueprint(group, version=1.2)\n\n    _, response = app.test_client.get(\"/v1.2\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "handler"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_bp_group_use_route",
      "module": "test_versioning",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_versioning.py",
      "line_number": 69,
      "end_line_number": 76,
      "source_code": "def test_bp_group_use_route(app, handler):\n    bp = Blueprint(\"Test\", version=1.1)\n    bp.route(\"/\", version=1.3)(handler)\n    group = Blueprint.group(bp, version=1)\n    app.blueprint(group, version=1.2)\n\n    _, response = app.test_client.get(\"/v1.3\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "handler"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_version_prefix_route",
      "module": "test_versioning",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_versioning.py",
      "line_number": 79,
      "end_line_number": 83,
      "source_code": "def test_version_prefix_route(app, handler):\n    app.route(\"/\", version=1, version_prefix=\"/api/v\")(handler)\n\n    _, response = app.test_client.get(\"/api/v1\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "handler"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_version_prefix_bp",
      "module": "test_versioning",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_versioning.py",
      "line_number": 86,
      "end_line_number": 92,
      "source_code": "def test_version_prefix_bp(app, handler):\n    bp = Blueprint(\"Test\", version=1, version_prefix=\"/api/v\")\n    bp.route(\"/\")(handler)\n    app.blueprint(bp)\n\n    _, response = app.test_client.get(\"/api/v1\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "handler"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_version_prefix_bp_use_route",
      "module": "test_versioning",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_versioning.py",
      "line_number": 95,
      "end_line_number": 101,
      "source_code": "def test_version_prefix_bp_use_route(app, handler):\n    bp = Blueprint(\"Test\", version=1, version_prefix=\"/ignore/v\")\n    bp.route(\"/\", version=1.1, version_prefix=\"/api/v\")(handler)\n    app.blueprint(bp)\n\n    _, response = app.test_client.get(\"/api/v1.1\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "handler"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_version_prefix_bp_group",
      "module": "test_versioning",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_versioning.py",
      "line_number": 104,
      "end_line_number": 111,
      "source_code": "def test_version_prefix_bp_group(app, handler):\n    bp = Blueprint(\"Test\")\n    bp.route(\"/\")(handler)\n    group = Blueprint.group(bp, version=1, version_prefix=\"/api/v\")\n    app.blueprint(group)\n\n    _, response = app.test_client.get(\"/api/v1\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "handler"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_version_prefix_bp_group_use_bp",
      "module": "test_versioning",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_versioning.py",
      "line_number": 114,
      "end_line_number": 121,
      "source_code": "def test_version_prefix_bp_group_use_bp(app, handler):\n    bp = Blueprint(\"Test\", version=1.1, version_prefix=\"/api/v\")\n    bp.route(\"/\")(handler)\n    group = Blueprint.group(bp, version=1, version_prefix=\"/ignore/v\")\n    app.blueprint(group)\n\n    _, response = app.test_client.get(\"/api/v1.1\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "handler"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_version_prefix_bp_group_use_registration",
      "module": "test_versioning",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_versioning.py",
      "line_number": 124,
      "end_line_number": 131,
      "source_code": "def test_version_prefix_bp_group_use_registration(app, handler):\n    bp = Blueprint(\"Test\", version=1.1, version_prefix=\"/alsoignore/v\")\n    bp.route(\"/\")(handler)\n    group = Blueprint.group(bp, version=1, version_prefix=\"/ignore/v\")\n    app.blueprint(group, version=1.2, version_prefix=\"/api/v\")\n\n    _, response = app.test_client.get(\"/api/v1.2\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "handler"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_version_prefix_bp_group_use_route",
      "module": "test_versioning",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_versioning.py",
      "line_number": 134,
      "end_line_number": 141,
      "source_code": "def test_version_prefix_bp_group_use_route(app, handler):\n    bp = Blueprint(\"Test\", version=1.1, version_prefix=\"/alsoignore/v\")\n    bp.route(\"/\", version=1.3, version_prefix=\"/api/v\")(handler)\n    group = Blueprint.group(bp, version=1, version_prefix=\"/ignore/v\")\n    app.blueprint(group, version=1.2, version_prefix=\"/stillignoring/v\")\n\n    _, response = app.test_client.get(\"/api/v1.3\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "handler"
      ],
      "imports": [
        "pytest",
        "sanic.Blueprint",
        "sanic.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_utf8_query_string",
      "module": "test_utf8",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_utf8.py",
      "line_number": 11,
      "end_line_number": 17,
      "source_code": "def test_utf8_query_string(app):\n    @app.route(\"/\")\n    async def handler(request):\n        return text(\"OK\")\n\n    request, response = app.test_client.get(\"/\", params=[(\"utf8\", \"\u2713\")])\n    assert request.args.get(\"utf8\") == \"\u2713\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "json.dumps",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.args.get('utf8') == '\u2713'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "request.args.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_utf8_response",
      "module": "test_utf8",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_utf8.py",
      "line_number": 20,
      "end_line_number": 26,
      "source_code": "def test_utf8_response(app):\n    @app.route(\"/\")\n    async def handler(request):\n        return text(\"\u2713\")\n\n    request, response = app.test_client.get(\"/\")\n    assert response.text == \"\u2713\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "json.dumps",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == '\u2713'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_utf8_post_json",
      "module": "test_utf8",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_utf8.py",
      "line_number": 39,
      "end_line_number": 52,
      "source_code": "def test_utf8_post_json(app):\n    @app.post(\"/\")\n    async def handler(request):\n        return text(\"OK\")\n\n    payload = {\"test\": \"\u2713\"}\n    headers = {\"content-type\": \"application/json\"}\n\n    request, response = app.test_client.post(\n        \"/\", data=json_dumps(payload), headers=headers\n    )\n\n    assert request.json.get(\"test\") == \"\u2713\"\n    assert response.text == \"OK\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "json.dumps",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.json.get('test') == '\u2713'",
        "assert response.text == 'OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "request.json.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_invalid_usage_exception_handler",
      "module": "test_exceptions_handler",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions_handler.py",
      "line_number": 89,
      "end_line_number": 91,
      "source_code": "def test_invalid_usage_exception_handler(exception_handler_app: Sanic):\n    request, response = exception_handler_app.test_client.get(\"/1\")\n    assert response.status == 400",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "exception_handler_app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "typing.Callable",
        "typing.List",
        "unittest.mock.Mock",
        "pytest",
        "bs4.BeautifulSoup",
        "pytest.LogCaptureFixture",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.handlers",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.ServerError",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 400"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_handler_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_server_error_exception_handler",
      "module": "test_exceptions_handler",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions_handler.py",
      "line_number": 94,
      "end_line_number": 97,
      "source_code": "def test_server_error_exception_handler(exception_handler_app: Sanic):\n    request, response = exception_handler_app.test_client.get(\"/2\")\n    assert response.status == 200\n    assert response.text == \"OK\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "exception_handler_app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "typing.Callable",
        "typing.List",
        "unittest.mock.Mock",
        "pytest",
        "bs4.BeautifulSoup",
        "pytest.LogCaptureFixture",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.handlers",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.ServerError",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_handler_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_not_found_exception_handler",
      "module": "test_exceptions_handler",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions_handler.py",
      "line_number": 100,
      "end_line_number": 102,
      "source_code": "def test_not_found_exception_handler(exception_handler_app: Sanic):\n    request, response = exception_handler_app.test_client.get(\"/3\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "exception_handler_app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "typing.Callable",
        "typing.List",
        "unittest.mock.Mock",
        "pytest",
        "bs4.BeautifulSoup",
        "pytest.LogCaptureFixture",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.handlers",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.ServerError",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_handler_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_text_exception__handler",
      "module": "test_exceptions_handler",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions_handler.py",
      "line_number": 105,
      "end_line_number": 108,
      "source_code": "def test_text_exception__handler(exception_handler_app: Sanic):\n    request, response = exception_handler_app.test_client.get(\"/random\")\n    assert response.status == 200\n    assert response.text == \"Done.\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "exception_handler_app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "typing.Callable",
        "typing.List",
        "unittest.mock.Mock",
        "pytest",
        "bs4.BeautifulSoup",
        "pytest.LogCaptureFixture",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.handlers",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.ServerError",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'Done.'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_handler_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_async_exception_handler",
      "module": "test_exceptions_handler",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions_handler.py",
      "line_number": 111,
      "end_line_number": 114,
      "source_code": "def test_async_exception_handler(exception_handler_app: Sanic):\n    request, response = exception_handler_app.test_client.get(\"/7\")\n    assert response.status == 200\n    assert response.text == \"foo,bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "exception_handler_app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "typing.Callable",
        "typing.List",
        "unittest.mock.Mock",
        "pytest",
        "bs4.BeautifulSoup",
        "pytest.LogCaptureFixture",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.handlers",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.ServerError",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'foo,bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_handler_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_html_traceback_output_in_debug_mode",
      "module": "test_exceptions_handler",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions_handler.py",
      "line_number": 117,
      "end_line_number": 129,
      "source_code": "def test_html_traceback_output_in_debug_mode(exception_handler_app: Sanic):\n    request, response = exception_handler_app.test_client.get(\"/4\", debug=True)\n    assert response.status == 500\n    soup = BeautifulSoup(response.body, \"html.parser\")\n    html = str(soup)\n\n    assert \"handler_4\" in html\n    assert \"foo = bar\" in html\n\n    summary_text = soup.select(\"h3\")[0].text\n    assert \"NameError: name 'bar' is not defined\" == summary_text\n    request_text = soup.select(\"h2\")[-1].text\n    assert \"GET /4\" == request_text",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "exception_handler_app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "typing.Callable",
        "typing.List",
        "unittest.mock.Mock",
        "pytest",
        "bs4.BeautifulSoup",
        "pytest.LogCaptureFixture",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.handlers",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.ServerError",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert 'handler_4' in html",
        "assert 'foo = bar' in html",
        "assert \"NameError: name 'bar' is not defined\" == summary_text",
        "assert 'GET /4' == request_text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_handler_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_inherited_exception_handler",
      "module": "test_exceptions_handler",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions_handler.py",
      "line_number": 132,
      "end_line_number": 134,
      "source_code": "def test_inherited_exception_handler(exception_handler_app: Sanic):\n    request, response = exception_handler_app.test_client.get(\"/5\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "exception_handler_app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "typing.Callable",
        "typing.List",
        "unittest.mock.Mock",
        "pytest",
        "bs4.BeautifulSoup",
        "pytest.LogCaptureFixture",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.handlers",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.ServerError",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_handler_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_chained_exception_handler",
      "module": "test_exceptions_handler",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions_handler.py",
      "line_number": 137,
      "end_line_number": 152,
      "source_code": "def test_chained_exception_handler(exception_handler_app: Sanic):\n    request, response = exception_handler_app.test_client.get(\n        \"/6/0\", debug=True\n    )\n    assert response.status == 500\n\n    soup = BeautifulSoup(response.body, \"html.parser\")\n    html = str(soup)\n\n    assert \"handler_6\" in html\n    assert \"foo = 1 / arg\" in html\n    assert \"ValueError\" in html\n    assert \"GET /6\" in html\n\n    summary_text = soup.select(\"h3\")[0].text\n    assert \"ZeroDivisionError: division by zero\" == summary_text",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "exception_handler_app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "typing.Callable",
        "typing.List",
        "unittest.mock.Mock",
        "pytest",
        "bs4.BeautifulSoup",
        "pytest.LogCaptureFixture",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.handlers",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.ServerError",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert 'handler_6' in html",
        "assert 'foo = 1 / arg' in html",
        "assert 'ValueError' in html",
        "assert 'GET /6' in html",
        "assert 'ZeroDivisionError: division by zero' == summary_text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_handler_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_exception_handler_lookup",
      "module": "test_exceptions_handler",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions_handler.py",
      "line_number": 155,
      "end_line_number": 200,
      "source_code": "def test_exception_handler_lookup(exception_handler_app: Sanic):\n    class CustomError(Exception):\n        pass\n\n    class CustomServerError(ServerError):\n        pass\n\n    def custom_error_handler():\n        pass\n\n    def server_error_handler():\n        pass\n\n    def import_error_handler():\n        pass\n\n    try:\n        ModuleNotFoundError  # noqa: F823\n    except Exception:\n\n        class ModuleNotFoundError(ImportError):\n            pass\n\n    handler = ErrorHandler()\n    handler.add(ImportError, import_error_handler)\n    handler.add(CustomError, custom_error_handler)\n    handler.add(ServerError, server_error_handler)\n\n    assert handler.lookup(ImportError(), None) == import_error_handler\n    assert handler.lookup(ModuleNotFoundError(), None) == import_error_handler\n    assert handler.lookup(CustomError(), None) == custom_error_handler\n    assert handler.lookup(ServerError(\"Error\"), None) == server_error_handler\n    assert (\n        handler.lookup(CustomServerError(\"Error\"), None)\n        == server_error_handler\n    )\n\n    # once again to ensure there is no caching bug\n    assert handler.lookup(ImportError(), None) == import_error_handler\n    assert handler.lookup(ModuleNotFoundError(), None) == import_error_handler\n    assert handler.lookup(CustomError(), None) == custom_error_handler\n    assert handler.lookup(ServerError(\"Error\"), None) == server_error_handler\n    assert (\n        handler.lookup(CustomServerError(\"Error\"), None)\n        == server_error_handler\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "exception_handler_app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "typing.Callable",
        "typing.List",
        "unittest.mock.Mock",
        "pytest",
        "bs4.BeautifulSoup",
        "pytest.LogCaptureFixture",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.handlers",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.ServerError",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert handler.lookup(ImportError(), None) == import_error_handler",
        "assert handler.lookup(ModuleNotFoundError(), None) == import_error_handler",
        "assert handler.lookup(CustomError(), None) == custom_error_handler",
        "assert handler.lookup(ServerError('Error'), None) == server_error_handler",
        "assert handler.lookup(CustomServerError('Error'), None) == server_error_handler",
        "assert handler.lookup(ImportError(), None) == import_error_handler",
        "assert handler.lookup(ModuleNotFoundError(), None) == import_error_handler",
        "assert handler.lookup(CustomError(), None) == custom_error_handler",
        "assert handler.lookup(ServerError('Error'), None) == server_error_handler",
        "assert handler.lookup(CustomServerError('Error'), None) == server_error_handler"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_exception_handler_processed_request_middleware",
      "module": "test_exceptions_handler",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions_handler.py",
      "line_number": 203,
      "end_line_number": 208,
      "source_code": "def test_exception_handler_processed_request_middleware(\n    exception_handler_app: Sanic,\n):\n    request, response = exception_handler_app.test_client.get(\"/8\")\n    assert response.status == 200\n    assert response.text == \"Done.\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "exception_handler_app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "typing.Callable",
        "typing.List",
        "unittest.mock.Mock",
        "pytest",
        "bs4.BeautifulSoup",
        "pytest.LogCaptureFixture",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.handlers",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.ServerError",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'Done.'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_handler_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_error_handler_noisy_log",
      "module": "test_exceptions_handler",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions_handler.py",
      "line_number": 211,
      "end_line_number": 225,
      "source_code": "def test_error_handler_noisy_log(\n    exception_handler_app: Sanic, monkeypatch: MonkeyPatch\n):\n    err_logger = Mock()\n    monkeypatch.setattr(handlers.error, \"error_logger\", err_logger)\n\n    exception_handler_app.config[\"NOISY_EXCEPTIONS\"] = False\n    exception_handler_app.test_client.get(\"/1\")\n    err_logger.exception.assert_not_called()\n\n    exception_handler_app.config[\"NOISY_EXCEPTIONS\"] = True\n    request, _ = exception_handler_app.test_client.get(\"/1\")\n    err_logger.exception.assert_called_with(\n        \"Exception occurred while handling uri: %s\", repr(request.url)\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "exception_handler_app",
        "monkeypatch"
      ],
      "imports": [
        "asyncio",
        "logging",
        "typing.Callable",
        "typing.List",
        "unittest.mock.Mock",
        "pytest",
        "bs4.BeautifulSoup",
        "pytest.LogCaptureFixture",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.handlers",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.ServerError",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_handler_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "exception_handler_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_exception_handler_response_was_sent",
      "module": "test_exceptions_handler",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions_handler.py",
      "line_number": 228,
      "end_line_number": 266,
      "source_code": "def test_exception_handler_response_was_sent(\n    app: Sanic,\n    caplog: LogCaptureFixture,\n    message_in_records: Callable[[List[logging.LogRecord], str], bool],\n):\n    exception_handler_ran = False\n\n    @app.exception(ServerError)\n    async def exception_handler(request, exception):\n        nonlocal exception_handler_ran\n        exception_handler_ran = True\n        return text(\"Error\")\n\n    @app.route(\"/1\")\n    async def handler1(request: Request):\n        response = await request.respond()\n        await response.send(\"some text\")\n        raise ServerError(\"Exception\")\n\n    @app.route(\"/2\")\n    async def handler2(request: Request):\n        await request.respond()\n        raise ServerError(\"Exception\")\n\n    with caplog.at_level(logging.WARNING):\n        _, response = app.test_client.get(\"/1\")\n        assert \"some text\" in response.text\n\n    message_in_records(\n        caplog.records,\n        (\n            \"An error occurred while handling the request after at \"\n            \"least some part of the response was sent to the client. \"\n            \"Therefore, the response from your custom exception \"\n        ),\n    )\n\n    _, response = app.test_client.get(\"/2\")\n    assert \"Error\" in response.text",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "caplog",
        "message_in_records"
      ],
      "imports": [
        "asyncio",
        "logging",
        "typing.Callable",
        "typing.List",
        "unittest.mock.Mock",
        "pytest",
        "bs4.BeautifulSoup",
        "pytest.LogCaptureFixture",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.handlers",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.ServerError",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'Error' in response.text",
        "assert 'some text' in response.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.exception",
          "body": "@app.route('/')\ndef exception(request):\n    raise SanicExceptionTestException(\"You won't see me\")"
        },
        {
          "name": "message_in_records",
          "body": "@pytest.fixture(scope='function')\ndef message_in_records():\n\n    def msg_in_log(records: List[LogRecord], msg: str):\n        error_captured = False\n        for record in records:\n            if msg in record.message:\n                error_captured = True\n                break\n        return error_captured\n    return msg_in_log"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        }
      ]
    },
    {
      "name": "test_errir_on_duplicate",
      "module": "test_exceptions_handler",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions_handler.py",
      "line_number": 269,
      "end_line_number": 280,
      "source_code": "def test_errir_on_duplicate(app: Sanic):\n    @app.exception(ServerError)\n    async def exception_handler_1(request, exception): ...\n\n    message = (\n        \"Duplicate exception handler definition on: route=__ALL_ROUTES__ and \"\n        \"exception=<class 'sanic.exceptions.ServerError'>\"\n    )\n    with pytest.raises(ServerError, match=message):\n\n        @app.exception(ServerError)\n        async def exception_handler_2(request, exception): ...",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "typing.Callable",
        "typing.List",
        "unittest.mock.Mock",
        "pytest",
        "bs4.BeautifulSoup",
        "pytest.LogCaptureFixture",
        "pytest.MonkeyPatch",
        "sanic.Sanic",
        "sanic.handlers",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.ServerError",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.exception",
          "body": "@app.route('/')\ndef exception(request):\n    raise SanicExceptionTestException(\"You won't see me\")"
        },
        {
          "name": "app.exception",
          "body": "@app.route('/')\ndef exception(request):\n    raise SanicExceptionTestException(\"You won't see me\")"
        }
      ]
    },
    {
      "name": "test_annotated_handlers",
      "module": "test_handler_annotations",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_handler_annotations.py",
      "line_number": 17,
      "end_line_number": 39,
      "source_code": "def test_annotated_handlers(app, idx, path, expectation):\n    def build_response(num, foo):\n        return json({\"num\": num, \"type\": type(foo).__name__})\n\n    @app.get(\"/<foo>\")\n    def handler0(_, foo: str):\n        return build_response(0, foo)\n\n    @app.get(\"/<foo>\")\n    def handler1(_, foo: int):\n        return build_response(1, foo)\n\n    @app.get(\"/<foo>\")\n    def handler2(_, foo: float):\n        return build_response(2, foo)\n\n    @app.get(\"/<foo>\")\n    def handler3(_, foo: UUID):\n        return build_response(3, foo)\n\n    _, response = app.test_client.get(path)\n    assert response.json[\"num\"] == idx\n    assert response.json[\"type\"] == expectation",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('idx,path,expectation', ((0, '/abc', 'str'), (1, '/123', 'int'), (2, '/123.5', 'float'), (3, '/8af729fe-2b94-4a95-a168-c07068568429', 'UUID')))"
      ],
      "arguments": [
        "app",
        "idx",
        "path",
        "expectation"
      ],
      "imports": [
        "uuid.UUID",
        "pytest",
        "sanic.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json['num'] == idx",
        "assert response.json['type'] == expectation"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "build_response",
          "body": "def build_response(num, foo):\n    return json({'num': num, 'type': type(foo).__name__})"
        },
        {
          "name": "build_response",
          "body": "def build_response(num, foo):\n    return json({'num': num, 'type': type(foo).__name__})"
        },
        {
          "name": "build_response",
          "body": "def build_response(num, foo):\n    return json({'num': num, 'type': type(foo).__name__})"
        },
        {
          "name": "build_response",
          "body": "def build_response(num, foo):\n    return json({'num': num, 'type': type(foo).__name__})"
        }
      ]
    },
    {
      "name": "test_no_sugar",
      "module": "test_coffee",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_coffee.py",
      "line_number": 19,
      "end_line_number": 24,
      "source_code": "def test_no_sugar(sugar):\n    if sugar:\n        with pytest.raises(SanicException):\n            assert has_sugar(sugar)\n    else:\n        assert not has_sugar(sugar)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('sugar', (True, False))"
      ],
      "arguments": [
        "sugar"
      ],
      "imports": [
        "logging",
        "unittest.mock.patch",
        "pytest",
        "sanic.application.logo.COFFEE_LOGO",
        "sanic.application.logo.get_logo",
        "sanic.exceptions.SanicException"
      ],
      "fixtures": [],
      "assertions": [
        "assert not has_sugar(sugar)",
        "assert has_sugar(sugar)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "has_sugar",
          "body": "def has_sugar(value):\n    if value:\n        raise SanicException('I said no sugar please')\n    return False"
        },
        {
          "name": "has_sugar",
          "body": "def has_sugar(value):\n    if value:\n        raise SanicException('I said no sugar please')\n    return False"
        }
      ]
    },
    {
      "name": "test_get_logo_returns_expected_logo",
      "module": "test_coffee",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_coffee.py",
      "line_number": 27,
      "end_line_number": 31,
      "source_code": "def test_get_logo_returns_expected_logo():\n    with patch(\"sys.stdout.isatty\") as isatty:\n        isatty.return_value = True\n        logo = get_logo(coffee=True)\n    assert logo is COFFEE_LOGO",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "unittest.mock.patch",
        "pytest",
        "sanic.application.logo.COFFEE_LOGO",
        "sanic.application.logo.get_logo",
        "sanic.exceptions.SanicException"
      ],
      "fixtures": [],
      "assertions": [
        "assert logo is COFFEE_LOGO"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ]
    },
    {
      "name": "test_logo_true",
      "module": "test_coffee",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_coffee.py",
      "line_number": 34,
      "end_line_number": 48,
      "source_code": "def test_logo_true(app, caplog):\n    @app.after_server_start\n    async def shutdown(*_):\n        app.stop()\n\n    with patch(\"sys.stdout.isatty\") as isatty:\n        isatty.return_value = True\n        with caplog.at_level(logging.DEBUG):\n            app.make_coffee(single_process=True)\n\n    # Only in the regular logo\n    assert \"    \u2584\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2588\u2588    \" not in caplog.text\n\n    # Only in the coffee logo\n    assert \"    \u2588\u2588       \u2588\u2588\u2580\u2580\u2584   \" in caplog.text",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "caplog"
      ],
      "imports": [
        "logging",
        "unittest.mock.patch",
        "pytest",
        "sanic.application.logo.COFFEE_LOGO",
        "sanic.application.logo.get_logo",
        "sanic.exceptions.SanicException"
      ],
      "fixtures": [],
      "assertions": [
        "assert '    \u2584\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2588\u2588    ' not in caplog.text",
        "assert '    \u2588\u2588       \u2588\u2588\u2580\u2580\u2584   ' in caplog.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        },
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ]
    },
    {
      "name": "test_custom_request",
      "module": "test_custom_request",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_custom_request.py",
      "line_number": 19,
      "end_line_number": 46,
      "source_code": "def test_custom_request():\n    app = Sanic(name=\"Test\", request_class=CustomRequest)\n\n    @app.route(\"/post\", methods=[\"POST\"])\n    async def post_handler(request):\n        return text(\"OK\")\n\n    @app.route(\"/get\")\n    async def get_handler(request):\n        return text(\"OK\")\n\n    payload = {\"test\": \"OK\"}\n    headers = {\"content-type\": \"application/json\"}\n\n    request, response = app.test_client.post(\n        \"/post\", data=json_dumps(payload), headers=headers\n    )\n\n    assert request.body == b'{\"TEST\":\"OK\"}'\n    assert request.json.get(\"TEST\") == \"OK\"\n    assert response.text == \"OK\"\n    assert response.status == 200\n\n    request, response = app.test_client.get(\"/get\")\n\n    assert request.body == b\"\"\n    assert response.text == \"OK\"\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "io.BytesIO",
        "sanic.Sanic",
        "sanic.request.Request",
        "sanic.response.json_dumps",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.body == b'{\"TEST\":\"OK\"}'",
        "assert request.json.get('TEST') == 'OK'",
        "assert response.text == 'OK'",
        "assert response.status == 200",
        "assert request.body == b''",
        "assert response.text == 'OK'",
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "request.json.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_redirect_default_302",
      "module": "test_redirect",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_redirect.py",
      "line_number": 41,
      "end_line_number": 51,
      "source_code": "def test_redirect_default_302(redirect_app):\n    \"\"\"\n    We expect a 302 default status code and the headers to be set.\n    \"\"\"\n    request, response = redirect_app.test_client.get(\n        \"/redirect_init\", allow_redirects=False\n    )\n\n    assert response.status == 302\n    assert response.headers[\"Location\"] == \"/redirect_target\"\n    assert response.headers[\"Content-Type\"] == \"text/html; charset=utf-8\"",
      "docstring": "We expect a 302 default status code and the headers to be set.",
      "decorators": [],
      "arguments": [
        "redirect_app"
      ],
      "imports": [
        "urllib.parse.quote",
        "pytest",
        "sanic.response.redirect",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 302",
        "assert response.headers['Location'] == '/redirect_target'",
        "assert response.headers['Content-Type'] == 'text/html; charset=utf-8'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "redirect_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_redirect_headers_none",
      "module": "test_redirect",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_redirect.py",
      "line_number": 54,
      "end_line_number": 60,
      "source_code": "def test_redirect_headers_none(redirect_app):\n    request, response = redirect_app.test_client.get(\n        uri=\"/redirect_init\", headers=None, allow_redirects=False\n    )\n\n    assert response.status == 302\n    assert response.headers[\"Location\"] == \"/redirect_target\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "redirect_app"
      ],
      "imports": [
        "urllib.parse.quote",
        "pytest",
        "sanic.response.redirect",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 302",
        "assert response.headers['Location'] == '/redirect_target'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "redirect_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_redirect_with_301",
      "module": "test_redirect",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_redirect.py",
      "line_number": 63,
      "end_line_number": 72,
      "source_code": "def test_redirect_with_301(redirect_app):\n    \"\"\"\n    Test redirection with a different status code.\n    \"\"\"\n    request, response = redirect_app.test_client.get(\n        \"/redirect_init_with_301\", allow_redirects=False\n    )\n\n    assert response.status == 301\n    assert response.headers[\"Location\"] == \"/redirect_target\"",
      "docstring": "Test redirection with a different status code.",
      "decorators": [],
      "arguments": [
        "redirect_app"
      ],
      "imports": [
        "urllib.parse.quote",
        "pytest",
        "sanic.response.redirect",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 301",
        "assert response.headers['Location'] == '/redirect_target'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "redirect_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_get_then_redirect_follow_redirect",
      "module": "test_redirect",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_redirect.py",
      "line_number": 75,
      "end_line_number": 84,
      "source_code": "def test_get_then_redirect_follow_redirect(redirect_app):\n    \"\"\"\n    With `allow_redirects` we expect a 200.\n    \"\"\"\n    request, response = redirect_app.test_client.get(\n        \"/redirect_init\", allow_redirects=True\n    )\n\n    assert response.status == 200\n    assert response.text == \"OK\"",
      "docstring": "With `allow_redirects` we expect a 200.",
      "decorators": [],
      "arguments": [
        "redirect_app"
      ],
      "imports": [
        "urllib.parse.quote",
        "pytest",
        "sanic.response.redirect",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "redirect_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_chained_redirect",
      "module": "test_redirect",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_redirect.py",
      "line_number": 87,
      "end_line_number": 96,
      "source_code": "def test_chained_redirect(redirect_app):\n    \"\"\"Test test_client is working for redirection\"\"\"\n    request, response = redirect_app.test_client.get(\"/1\")\n    assert request.url.endswith(\"/1\")\n    assert response.status == 200\n    assert response.text == \"OK\"\n    try:\n        assert response.url.endswith(\"/3\")\n    except AttributeError:\n        assert response.url.path.endswith(\"/3\")",
      "docstring": "Test test_client is working for redirection",
      "decorators": [],
      "arguments": [
        "redirect_app"
      ],
      "imports": [
        "urllib.parse.quote",
        "pytest",
        "sanic.response.redirect",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.url.endswith('/1')",
        "assert response.status == 200",
        "assert response.text == 'OK'",
        "assert response.url.endswith('/3')",
        "assert response.url.path.endswith('/3')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "redirect_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_redirect_with_header_injection",
      "module": "test_redirect",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_redirect.py",
      "line_number": 99,
      "end_line_number": 109,
      "source_code": "def test_redirect_with_header_injection(redirect_app):\n    \"\"\"\n    Test redirection to a URL with header and body injections.\n    \"\"\"\n    request, response = redirect_app.test_client.get(\n        \"/redirect_with_header_injection\", allow_redirects=False\n    )\n\n    assert response.status == 302\n    assert \"test-header\" not in response.headers\n    assert not response.text.startswith(\"test-body\")",
      "docstring": "Test redirection to a URL with header and body injections.",
      "decorators": [],
      "arguments": [
        "redirect_app"
      ],
      "imports": [
        "urllib.parse.quote",
        "pytest",
        "sanic.response.redirect",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 302",
        "assert 'test-header' not in response.headers",
        "assert not response.text.startswith('test-body')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "redirect_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_redirect_with_params",
      "module": "test_redirect",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_redirect.py",
      "line_number": 120,
      "end_line_number": 135,
      "source_code": "def test_redirect_with_params(app, test_str):\n    use_in_uri = quote(test_str)\n\n    @app.route(\"/api/v1/test/<test>/\")\n    async def init_handler(request, test):\n        return redirect(f\"/api/v2/test/{use_in_uri}/\")\n\n    @app.route(\"/api/v2/test/<test>/\", unquote=True)\n    async def target_handler(request, test):\n        assert test == quote(test_str)\n        return text(\"OK\")\n\n    _, response = app.test_client.get(f\"/api/v1/test/{use_in_uri}/\")\n    assert response.status == 200\n\n    assert response.body == b\"OK\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('test_str', ['sanic-test', 'sanictest', 'sanic test'])"
      ],
      "arguments": [
        "app",
        "test_str"
      ],
      "imports": [
        "urllib.parse.quote",
        "pytest",
        "sanic.response.redirect",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == b'OK'",
        "assert test == quote(test_str)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_no_body_requests",
      "module": "test_pipelining",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_pipelining.py",
      "line_number": 6,
      "end_line_number": 24,
      "source_code": "def test_no_body_requests(app, port):\n    @app.get(\"/\")\n    async def handler(request):\n        return json(\n            {\n                \"request_id\": str(request.id),\n                \"connection_id\": id(request.conn_info),\n            }\n        )\n\n    client = ReusableClient(app, port=port)\n\n    with client:\n        _, response1 = client.get(\"/\")\n        _, response2 = client.get(\"/\")\n\n    assert response1.status == response2.status == 200\n    assert response1.json[\"request_id\"] != response2.json[\"request_id\"]\n    assert response1.json[\"connection_id\"] == response2.json[\"connection_id\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "port"
      ],
      "imports": [
        "sanic_testing.reusable.ReusableClient",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response1.status == response2.status == 200",
        "assert response1.json['request_id'] != response2.json['request_id']",
        "assert response1.json['connection_id'] == response2.json['connection_id']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_json_body_requests",
      "module": "test_pipelining",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_pipelining.py",
      "line_number": 27,
      "end_line_number": 47,
      "source_code": "def test_json_body_requests(app, port):\n    @app.post(\"/\")\n    async def handler(request):\n        return json(\n            {\n                \"request_id\": str(request.id),\n                \"connection_id\": id(request.conn_info),\n                \"foo\": request.json.get(\"foo\"),\n            }\n        )\n\n    client = ReusableClient(app, port=port)\n\n    with client:\n        _, response1 = client.post(\"/\", json={\"foo\": True})\n        _, response2 = client.post(\"/\", json={\"foo\": True})\n\n    assert response1.status == response2.status == 200\n    assert response1.json[\"foo\"] is response2.json[\"foo\"] is True\n    assert response1.json[\"request_id\"] != response2.json[\"request_id\"]\n    assert response1.json[\"connection_id\"] == response2.json[\"connection_id\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "port"
      ],
      "imports": [
        "sanic_testing.reusable.ReusableClient",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response1.status == response2.status == 200",
        "assert response1.json['foo'] is response2.json['foo'] is True",
        "assert response1.json['request_id'] != response2.json['request_id']",
        "assert response1.json['connection_id'] == response2.json['connection_id']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "request.json.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_streaming_body_requests",
      "module": "test_pipelining",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_pipelining.py",
      "line_number": 50,
      "end_line_number": 77,
      "source_code": "def test_streaming_body_requests(app, port):\n    @app.post(\"/\", stream=True)\n    async def handler(request):\n        data = [part.decode(\"utf-8\") async for part in request.stream]\n        return json(\n            {\n                \"request_id\": str(request.id),\n                \"connection_id\": id(request.conn_info),\n                \"data\": data,\n            }\n        )\n\n    data = [\"hello\", \"world\"]\n\n    client = ReusableClient(app, port=port)\n\n    async def stream(data):\n        for value in data:\n            yield value.encode(\"utf-8\")\n\n    with client:\n        _, response1 = client.post(\"/\", data=stream(data))\n        _, response2 = client.post(\"/\", data=stream(data))\n\n    assert response1.status == response2.status == 200\n    assert response1.json[\"data\"] == response2.json[\"data\"] == data\n    assert response1.json[\"request_id\"] != response2.json[\"request_id\"]\n    assert response1.json[\"connection_id\"] == response2.json[\"connection_id\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "port"
      ],
      "imports": [
        "sanic_testing.reusable.ReusableClient",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response1.status == response2.status == 200",
        "assert response1.json['data'] == response2.json['data'] == data",
        "assert response1.json['request_id'] != response2.json['request_id']",
        "assert response1.json['connection_id'] == response2.json['connection_id']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_bad_headers",
      "module": "test_pipelining",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_pipelining.py",
      "line_number": 80,
      "end_line_number": 100,
      "source_code": "def test_bad_headers(app, port):\n    @app.get(\"/\")\n    async def handler(request):\n        return text(\"\")\n\n    @app.on_response\n    async def reqid(request, response):\n        response.headers[\"x-request-id\"] = request.id\n\n    client = ReusableClient(app, port=port)\n    bad_headers = {\"bad\": \"bad\" * 5_000}\n\n    with client:\n        _, response1 = client.get(\"/\")\n        _, response2 = client.get(\"/\", headers=bad_headers)\n\n    assert response1.status == 200\n    assert response2.status == 413\n    assert (\n        response1.headers[\"x-request-id\"] != response2.headers[\"x-request-id\"]\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "port"
      ],
      "imports": [
        "sanic_testing.reusable.ReusableClient",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response1.status == 200",
        "assert response2.status == 413",
        "assert response1.headers['x-request-id'] != response2.headers['x-request-id']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_deprecation",
      "module": "test_deprecation",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_deprecation.py",
      "line_number": 7,
      "end_line_number": 10,
      "source_code": "def test_deprecation():\n    message = r\"\\[DEPRECATION v9\\.9\\] hello\"\n    with pytest.warns(DeprecationWarning, match=message):\n        deprecation(\"hello\", 9.9)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "sanic.Sanic",
        "sanic.log.deprecation"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_deprecation_filter",
      "module": "test_deprecation",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_deprecation.py",
      "line_number": 17,
      "end_line_number": 20,
      "source_code": "def test_deprecation_filter(app: Sanic, filter, expected, recwarn):\n    app.config.DEPRECATION_FILTER = filter\n    deprecation(\"hello\", 9.9)\n    assert len(recwarn) == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('filter,expected', (('default', 1), ('once', 1), ('ignore', 0)))"
      ],
      "arguments": [
        "app",
        "filter",
        "expected",
        "recwarn"
      ],
      "imports": [
        "pytest",
        "sanic.Sanic",
        "sanic.log.deprecation"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(recwarn) == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_single_listener",
      "module": "test_server_events",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_server_events.py",
      "line_number": 56,
      "end_line_number": 62,
      "source_code": "def test_single_listener(app, listener_name):\n    \"\"\"Test that listeners on their own work\"\"\"\n    output = []\n    # Register listener\n    app.listener(listener_name)(create_listener(listener_name, output))\n    start_stop_app(app)\n    assert app.name + listener_name == output.pop()",
      "docstring": "Test that listeners on their own work",
      "decorators": [
        "pytest.mark.parametrize('listener_name', AVAILABLE_LISTENERS)"
      ],
      "arguments": [
        "app",
        "listener_name"
      ],
      "imports": [
        "asyncio",
        "signal",
        "contextlib.closing",
        "socket.socket",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic.Blueprint",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.SanicException",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.name + listener_name == output.pop()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "start_stop_app",
          "body": "def start_stop_app(random_name_app, **run_kwargs):\n\n    @random_name_app.after_server_start\n    async def shutdown(app):\n        await asyncio.sleep(1.1)\n        app.stop()\n    try:\n        random_name_app.run(HOST, get_port(), single_process=True, **run_kwargs)\n    except KeyboardInterrupt:\n        pass"
        },
        {
          "name": "create_listener",
          "body": "def create_listener(listener_name, in_list):\n\n    async def _listener(app, loop):\n        print(f'DEBUG MESSAGE FOR PYTEST for {listener_name}')\n        in_list.insert(0, app.name + listener_name)\n    return _listener"
        }
      ]
    },
    {
      "name": "test_single_listener_no_loop",
      "module": "test_server_events",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_server_events.py",
      "line_number": 66,
      "end_line_number": 72,
      "source_code": "def test_single_listener_no_loop(app, listener_name):\n    \"\"\"Test that listeners on their own work\"\"\"\n    output = []\n    # Register listener\n    app.listener(listener_name)(create_listener_no_loop(listener_name, output))\n    start_stop_app(app)\n    assert app.name + listener_name == output.pop()",
      "docstring": "Test that listeners on their own work",
      "decorators": [
        "pytest.mark.parametrize('listener_name', AVAILABLE_LISTENERS)"
      ],
      "arguments": [
        "app",
        "listener_name"
      ],
      "imports": [
        "asyncio",
        "signal",
        "contextlib.closing",
        "socket.socket",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic.Blueprint",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.SanicException",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.name + listener_name == output.pop()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "start_stop_app",
          "body": "def start_stop_app(random_name_app, **run_kwargs):\n\n    @random_name_app.after_server_start\n    async def shutdown(app):\n        await asyncio.sleep(1.1)\n        app.stop()\n    try:\n        random_name_app.run(HOST, get_port(), single_process=True, **run_kwargs)\n    except KeyboardInterrupt:\n        pass"
        },
        {
          "name": "create_listener_no_loop",
          "body": "def create_listener_no_loop(listener_name, in_list):\n\n    async def _listener(app):\n        print(f'DEBUG MESSAGE FOR PYTEST for {listener_name}')\n        in_list.insert(0, app.name + listener_name)\n    return _listener"
        }
      ]
    },
    {
      "name": "test_register_listener",
      "module": "test_server_events",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_server_events.py",
      "line_number": 76,
      "end_line_number": 86,
      "source_code": "def test_register_listener(app, listener_name):\n    \"\"\"\n    Test that listeners on their own work with\n    app.register_listener method\n    \"\"\"\n    output = []\n    # Register listener\n    listener = create_listener(listener_name, output)\n    app.register_listener(listener, event=listener_name)\n    start_stop_app(app)\n    assert app.name + listener_name == output.pop()",
      "docstring": "Test that listeners on their own work with\napp.register_listener method",
      "decorators": [
        "pytest.mark.parametrize('listener_name', AVAILABLE_LISTENERS)"
      ],
      "arguments": [
        "app",
        "listener_name"
      ],
      "imports": [
        "asyncio",
        "signal",
        "contextlib.closing",
        "socket.socket",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic.Blueprint",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.SanicException",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.name + listener_name == output.pop()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "create_listener",
          "body": "def create_listener(listener_name, in_list):\n\n    async def _listener(app, loop):\n        print(f'DEBUG MESSAGE FOR PYTEST for {listener_name}')\n        in_list.insert(0, app.name + listener_name)\n    return _listener"
        },
        {
          "name": "start_stop_app",
          "body": "def start_stop_app(random_name_app, **run_kwargs):\n\n    @random_name_app.after_server_start\n    async def shutdown(app):\n        await asyncio.sleep(1.1)\n        app.stop()\n    try:\n        random_name_app.run(HOST, get_port(), single_process=True, **run_kwargs)\n    except KeyboardInterrupt:\n        pass"
        }
      ]
    },
    {
      "name": "test_all_listeners",
      "module": "test_server_events",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_server_events.py",
      "line_number": 89,
      "end_line_number": 96,
      "source_code": "def test_all_listeners(app):\n    output = []\n    for listener_name in AVAILABLE_LISTENERS:\n        listener = create_listener(listener_name, output)\n        app.listener(listener_name)(listener)\n    start_stop_app(app)\n    for listener_name in AVAILABLE_LISTENERS:\n        assert app.name + listener_name == output.pop()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "signal",
        "contextlib.closing",
        "socket.socket",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic.Blueprint",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.SanicException",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.name + listener_name == output.pop()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "start_stop_app",
          "body": "def start_stop_app(random_name_app, **run_kwargs):\n\n    @random_name_app.after_server_start\n    async def shutdown(app):\n        await asyncio.sleep(1.1)\n        app.stop()\n    try:\n        random_name_app.run(HOST, get_port(), single_process=True, **run_kwargs)\n    except KeyboardInterrupt:\n        pass"
        },
        {
          "name": "create_listener",
          "body": "def create_listener(listener_name, in_list):\n\n    async def _listener(app, loop):\n        print(f'DEBUG MESSAGE FOR PYTEST for {listener_name}')\n        in_list.insert(0, app.name + listener_name)\n    return _listener"
        }
      ]
    },
    {
      "name": "test_all_listeners_as_convenience",
      "module": "test_server_events",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_server_events.py",
      "line_number": 99,
      "end_line_number": 107,
      "source_code": "def test_all_listeners_as_convenience(app):\n    output = []\n    for listener_name in AVAILABLE_LISTENERS:\n        listener = create_listener(listener_name, output)\n        method = getattr(app, listener_name)\n        method(listener)\n    start_stop_app(app)\n    for listener_name in AVAILABLE_LISTENERS:\n        assert app.name + listener_name == output.pop()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "signal",
        "contextlib.closing",
        "socket.socket",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic.Blueprint",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.SanicException",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.name + listener_name == output.pop()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "start_stop_app",
          "body": "def start_stop_app(random_name_app, **run_kwargs):\n\n    @random_name_app.after_server_start\n    async def shutdown(app):\n        await asyncio.sleep(1.1)\n        app.stop()\n    try:\n        random_name_app.run(HOST, get_port(), single_process=True, **run_kwargs)\n    except KeyboardInterrupt:\n        pass"
        },
        {
          "name": "create_listener",
          "body": "def create_listener(listener_name, in_list):\n\n    async def _listener(app, loop):\n        print(f'DEBUG MESSAGE FOR PYTEST for {listener_name}')\n        in_list.insert(0, app.name + listener_name)\n    return _listener"
        }
      ]
    },
    {
      "name": "test_create_server_trigger_events",
      "module": "test_server_events",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_server_events.py",
      "line_number": 143,
      "end_line_number": 201,
      "source_code": "def test_create_server_trigger_events(app):\n    \"\"\"Test if create_server can trigger server events\"\"\"\n\n    def stop_on_alarm(signum, frame):\n        raise KeyboardInterrupt(\"...\")\n\n    flag1 = False\n    flag2 = False\n    flag3 = False\n\n    async def stop(app, loop):\n        nonlocal flag1\n        flag1 = True\n\n    async def before_stop(app, loop):\n        nonlocal flag2\n        flag2 = True\n\n    async def after_stop(app, loop):\n        nonlocal flag3\n        flag3 = True\n\n    app.listener(\"after_server_start\")(stop)\n    app.listener(\"before_server_stop\")(before_stop)\n    app.listener(\"after_server_stop\")(after_stop)\n\n    loop = asyncio.get_event_loop()\n\n    # Use random port for tests\n\n    signal.signal(signal.SIGALRM, stop_on_alarm)\n    signal.alarm(1)\n    with closing(socket()) as sock:\n        sock.bind((\"127.0.0.1\", 0))\n\n        serv_coro = app.create_server(\n            return_asyncio_server=True, sock=sock, debug=True\n        )\n        serv_task = asyncio.ensure_future(serv_coro, loop=loop)\n        server = loop.run_until_complete(serv_task)\n        loop.run_until_complete(server.startup())\n        loop.run_until_complete(server.after_start())\n        try:\n            loop.run_forever()\n        except KeyboardInterrupt:\n            loop.stop()\n        finally:\n            # Run the on_stop function if provided\n            loop.run_until_complete(server.before_stop())\n\n            # Wait for server to close\n            close_task = server.close()\n            loop.run_until_complete(close_task)\n\n            # Complete all tasks on the loop\n            for connection in server.connections:\n                connection.close_if_idle()\n            loop.run_until_complete(server.after_stop())\n        assert flag1 and flag2 and flag3",
      "docstring": "Test if create_server can trigger server events",
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "signal",
        "contextlib.closing",
        "socket.socket",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic.Blueprint",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.SanicException",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert flag1 and flag2 and flag3"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "loop.stop",
          "body": "def stop(app):\n    app.stop()"
        }
      ]
    },
    {
      "name": "test_reload_listeners_attached",
      "module": "test_server_events",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_server_events.py",
      "line_number": 217,
      "end_line_number": 226,
      "source_code": "def test_reload_listeners_attached(app):\n    async def dummy(*_): ...\n\n    app.reload_process_start(dummy)\n    app.reload_process_stop(dummy)\n    app.listener(\"reload_process_start\")(dummy)\n    app.listener(\"reload_process_stop\")(dummy)\n\n    assert len(app.listeners.get(\"reload_process_start\")) == 2\n    assert len(app.listeners.get(\"reload_process_stop\")) == 2",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "signal",
        "contextlib.closing",
        "socket.socket",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic.Blueprint",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.SanicException",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(app.listeners.get('reload_process_start')) == 2",
        "assert len(app.listeners.get('reload_process_stop')) == 2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.reload_process_start",
          "body": "@app.reload_process_start\ndef reload_process_start(_):\n    results.append('reload_process_start')"
        },
        {
          "name": "app.reload_process_stop",
          "body": "@app.reload_process_stop\ndef reload_process_stop(_):\n    results.append('reload_process_stop')"
        },
        {
          "name": "app.listeners.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.listeners.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_priority_ordering",
      "module": "test_server_events",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_server_events.py",
      "line_number": 229,
      "end_line_number": 274,
      "source_code": "def test_priority_ordering(app):\n    output = []\n    bp = Blueprint(\"bp\")\n\n    @app.before_server_start\n    async def first(app):\n        output.append(\"first\")\n\n    @app.listener(\"before_server_start\", priority=2)\n    async def second(app):\n        output.append(\"second\")\n\n    @app.before_server_start(priority=3)\n    async def third(app):\n        output.append(\"third\")\n\n    @bp.before_server_start\n    async def bp_first(app):\n        output.append(\"bp_first\")\n\n    @bp.listener(\"before_server_start\", priority=2)\n    async def bp_second(app):\n        output.append(\"bp_second\")\n\n    @bp.before_server_start(priority=3)\n    async def bp_third(app):\n        output.append(\"bp_third\")\n\n    @app.before_server_start\n    async def fourth(app):\n        output.append(\"fourth\")\n\n    app.blueprint(bp)\n    start_stop_app(app)\n\n    # The order of the listeners is:\n    # priority descending, app before bp, definition order ascending\n    assert output == [\n        \"third\",\n        \"bp_third\",\n        \"second\",\n        \"bp_second\",\n        \"first\",\n        \"fourth\",\n        \"bp_first\",\n    ]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "signal",
        "contextlib.closing",
        "socket.socket",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic.Blueprint",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.SanicException",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert output == ['third', 'bp_third', 'second', 'bp_second', 'first', 'fourth', 'bp_first']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "start_stop_app",
          "body": "def start_stop_app(random_name_app, **run_kwargs):\n\n    @random_name_app.after_server_start\n    async def shutdown(app):\n        await asyncio.sleep(1.1)\n        app.stop()\n    try:\n        random_name_app.run(HOST, get_port(), single_process=True, **run_kwargs)\n    except KeyboardInterrupt:\n        pass"
        }
      ]
    },
    {
      "name": "test_app",
      "module": "test_http",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_http.py",
      "line_number": 21,
      "end_line_number": 33,
      "source_code": "def test_app(app: Sanic):\n    app.config.KEEP_ALIVE_TIMEOUT = 1\n\n    @app.get(\"/\")\n    async def base_handler(request):\n        return text(\"111122223333444455556666777788889999\")\n\n    @app.post(\"/upload\", stream=True)\n    async def upload_handler(request):\n        data = [part.decode(\"utf-8\") async for part in request.stream]\n        return json(data)\n\n    return app",
      "docstring": null,
      "decorators": [
        "pytest.fixture"
      ],
      "arguments": [
        "app"
      ],
      "imports": [
        "json",
        "collections.namedtuple",
        "pathlib.Path",
        "sys.version_info",
        "pytest",
        "sanic_testing.reusable.ReusableClient",
        "sanic.json",
        "sanic.text",
        "sanic.app.Sanic",
        "tests.client.RawClient"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_full_message",
      "module": "test_http",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_http.py",
      "line_number": 67,
      "end_line_number": 80,
      "source_code": "def test_full_message(client):\n    client.send(\n        \"\"\"\n        GET / HTTP/1.1\n        host: localhost:7777\n\n        \"\"\"\n    )\n    response = client.recv()\n\n    # AltSvcCheck touchup removes the Alt-Svc header from the\n    # response in the Python 3.9+ in this case\n    assert len(response) == (151 if version_info < (3, 9) else 140)\n    assert b\"200 OK\" in response",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "client"
      ],
      "imports": [
        "json",
        "collections.namedtuple",
        "pathlib.Path",
        "sys.version_info",
        "pytest",
        "sanic_testing.reusable.ReusableClient",
        "sanic.json",
        "sanic.text",
        "sanic.app.Sanic",
        "tests.client.RawClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(response) == (151 if version_info < (3, 9) else 140)",
        "assert b'200 OK' in response"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "client.recv",
          "body": "def recv(**kwargs):\n    nonlocal runner\n    nonlocal raw\n    method = raw.recv_until if 'until' in kwargs else raw.recv\n    return runner._run(method(**kwargs))"
        }
      ]
    },
    {
      "name": "test_transfer_chunked",
      "module": "test_http",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_http.py",
      "line_number": 83,
      "end_line_number": 98,
      "source_code": "def test_transfer_chunked(client):\n    client.send(\n        \"\"\"\n        POST /upload HTTP/1.1\n        transfer-encoding: chunked\n\n        \"\"\"\n    )\n    client.send(b\"3\\r\\nfoo\\r\\n\")\n    client.send(b\"3\\r\\nbar\\r\\n\")\n    client.send(b\"0\\r\\n\\r\\n\")\n    response = client.recv()\n    _, body = response.rsplit(b\"\\r\\n\\r\\n\", 1)\n    data = stdjson.loads(body)\n\n    assert data == [\"foo\", \"bar\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "client"
      ],
      "imports": [
        "json",
        "collections.namedtuple",
        "pathlib.Path",
        "sys.version_info",
        "pytest",
        "sanic_testing.reusable.ReusableClient",
        "sanic.json",
        "sanic.text",
        "sanic.app.Sanic",
        "tests.client.RawClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert data == ['foo', 'bar']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "client.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "client.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "client.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "client.recv",
          "body": "def recv(**kwargs):\n    nonlocal runner\n    nonlocal raw\n    method = raw.recv_until if 'until' in kwargs else raw.recv\n    return runner._run(method(**kwargs))"
        }
      ]
    },
    {
      "name": "test_url_encoding",
      "module": "test_http",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_http.py",
      "line_number": 101,
      "end_line_number": 112,
      "source_code": "def test_url_encoding(client):\n    client.send(\n        \"\"\"\n        GET /invalid\\xa0url HTTP/1.1\n\n        \"\"\"\n    )\n    response = client.recv()\n    headers, body = response.rsplit(b\"\\r\\n\\r\\n\", 1)\n\n    assert b\"400 Bad Request\" in headers\n    assert b\"URL may only contain US-ASCII characters.\" in body",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "client"
      ],
      "imports": [
        "json",
        "collections.namedtuple",
        "pathlib.Path",
        "sys.version_info",
        "pytest",
        "sanic_testing.reusable.ReusableClient",
        "sanic.json",
        "sanic.text",
        "sanic.app.Sanic",
        "tests.client.RawClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert b'400 Bad Request' in headers",
        "assert b'URL may only contain US-ASCII characters.' in body"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "client.recv",
          "body": "def recv(**kwargs):\n    nonlocal runner\n    nonlocal raw\n    method = raw.recv_until if 'until' in kwargs else raw.recv\n    return runner._run(method(**kwargs))"
        }
      ]
    },
    {
      "name": "test_invalid_content_length",
      "module": "test_http",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_http.py",
      "line_number": 124,
      "end_line_number": 139,
      "source_code": "def test_invalid_content_length(content_length, client):\n    body = b\"Hello\" * 10\n    client.send(\n        b\"POST /upload HTTP/1.1\\r\\n\"\n        + b\"content-length: \"\n        + content_length\n        + b\"\\r\\n\\r\\n\"\n        + body\n        + b\"\\r\\n\\r\\n\"\n    )\n\n    response = client.recv()\n    headers, body = response.rsplit(b\"\\r\\n\\r\\n\", 1)\n\n    assert b\"400 Bad Request\" in headers\n    assert b\"Bad content-length\" in body",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('content_length', (b'-50', b'+50', b'5_0', b'50.5'))"
      ],
      "arguments": [
        "content_length",
        "client"
      ],
      "imports": [
        "json",
        "collections.namedtuple",
        "pathlib.Path",
        "sys.version_info",
        "pytest",
        "sanic_testing.reusable.ReusableClient",
        "sanic.json",
        "sanic.text",
        "sanic.app.Sanic",
        "tests.client.RawClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert b'400 Bad Request' in headers",
        "assert b'Bad content-length' in body"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "client.recv",
          "body": "def recv(**kwargs):\n    nonlocal runner\n    nonlocal raw\n    method = raw.recv_until if 'until' in kwargs else raw.recv\n    return runner._run(method(**kwargs))"
        }
      ]
    },
    {
      "name": "test_invalid_chunk_length",
      "module": "test_http",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_http.py",
      "line_number": 151,
      "end_line_number": 167,
      "source_code": "def test_invalid_chunk_length(chunk_length, client):\n    body = b\"Hello\" * 10\n    client.send(\n        b\"POST /upload HTTP/1.1\\r\\n\"\n        + b\"transfer-encoding: chunked\\r\\n\\r\\n\"\n        + chunk_length\n        + b\"\\r\\n\"\n        + body\n        + b\"\\r\\n\"\n        + b\"0\\r\\n\\r\\n\"\n    )\n\n    response = client.recv()\n    headers, body = response.rsplit(b\"\\r\\n\\r\\n\", 1)\n\n    assert b\"400 Bad Request\" in headers\n    assert b\"Bad chunked encoding\" in body",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('chunk_length', (b'-50', b'+50', b'5_0', b'50.5'))"
      ],
      "arguments": [
        "chunk_length",
        "client"
      ],
      "imports": [
        "json",
        "collections.namedtuple",
        "pathlib.Path",
        "sys.version_info",
        "pytest",
        "sanic_testing.reusable.ReusableClient",
        "sanic.json",
        "sanic.text",
        "sanic.app.Sanic",
        "tests.client.RawClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert b'400 Bad Request' in headers",
        "assert b'Bad chunked encoding' in body"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "client.recv",
          "body": "def recv(**kwargs):\n    nonlocal runner\n    nonlocal raw\n    method = raw.recv_until if 'until' in kwargs else raw.recv\n    return runner._run(method(**kwargs))"
        }
      ]
    },
    {
      "name": "test_smuggle",
      "module": "test_http",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_http.py",
      "line_number": 170,
      "end_line_number": 193,
      "source_code": "def test_smuggle(client):\n    client.send(\n        \"\"\"\n        POST /upload HTTP/1.1\n        Content-Length: 5\n        Transfer-Encoding: chunked\n        Transfer-Encoding: xchunked\n\n        5\n        hello\n        0\n\n        GET / HTTP/1.1\n        \n        \"\"\"  # noqa\n    )\n\n    response = client.recv()\n    num_responses = response.count(b\"HTTP/1.1\")\n    assert num_responses == 1\n\n    headers, body = response.rsplit(b\"\\r\\n\\r\\n\", 1)\n    assert b\"400 Bad Request\" in headers\n    assert b\"Bad Request\" in body",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "client"
      ],
      "imports": [
        "json",
        "collections.namedtuple",
        "pathlib.Path",
        "sys.version_info",
        "pytest",
        "sanic_testing.reusable.ReusableClient",
        "sanic.json",
        "sanic.text",
        "sanic.app.Sanic",
        "tests.client.RawClient"
      ],
      "fixtures": [],
      "assertions": [
        "assert num_responses == 1",
        "assert b'400 Bad Request' in headers",
        "assert b'Bad Request' in body"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "client.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "client.recv",
          "body": "def recv(**kwargs):\n    nonlocal runner\n    nonlocal raw\n    method = raw.recv_until if 'until' in kwargs else raw.recv\n    return runner._run(method(**kwargs))"
        }
      ]
    },
    {
      "name": "test_logo_base",
      "module": "test_motd",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_motd.py",
      "line_number": 23,
      "end_line_number": 27,
      "source_code": "def test_logo_base(app, run_startup):\n    logs = run_startup(app)\n\n    assert logs[0][1] == logging.DEBUG\n    assert logs[0][2] == BASE_LOGO",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "run_startup"
      ],
      "imports": [
        "logging",
        "os",
        "platform",
        "sys",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.__version__",
        "sanic.application.logo.BASE_LOGO",
        "sanic.application.motd.MOTD",
        "sanic.application.motd.MOTDTTY"
      ],
      "fixtures": [],
      "assertions": [
        "assert logs[0][1] == logging.DEBUG",
        "assert logs[0][2] == BASE_LOGO"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "run_startup",
          "body": "@pytest.fixture(scope='function')\ndef run_startup(caplog):\n\n    def run(app):\n        nonlocal caplog\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n        with caplog.at_level(logging.DEBUG):\n            server = app.create_server(debug=True, return_asyncio_server=True, port=PORT)\n            loop._stopping = False\n            _server = loop.run_until_complete(server)\n            _server.close()\n            loop.run_until_complete(_server.wait_closed())\n            app.stop()\n        return caplog.record_tuples\n    return run"
        }
      ]
    },
    {
      "name": "test_motd_with_expected_info",
      "module": "test_motd",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_motd.py",
      "line_number": 30,
      "end_line_number": 38,
      "source_code": "def test_motd_with_expected_info(app, run_startup):\n    logs = run_startup(app)\n\n    assert logs[1][2] == f\"Sanic v{__version__}\"\n    assert logs[3][2] == \"app: test_motd_with_expected_info\"\n    assert logs[4][2] == \"mode: debug, single worker\"\n    assert logs[5][2] == \"server: sanic, HTTP/1.1\"\n    assert logs[6][2] == f\"python: {platform.python_version()}\"\n    assert logs[7][2] == f\"platform: {platform.platform()}\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "run_startup"
      ],
      "imports": [
        "logging",
        "os",
        "platform",
        "sys",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.__version__",
        "sanic.application.logo.BASE_LOGO",
        "sanic.application.motd.MOTD",
        "sanic.application.motd.MOTDTTY"
      ],
      "fixtures": [],
      "assertions": [
        "assert logs[1][2] == f'Sanic v{__version__}'",
        "assert logs[3][2] == 'app: test_motd_with_expected_info'",
        "assert logs[4][2] == 'mode: debug, single worker'",
        "assert logs[5][2] == 'server: sanic, HTTP/1.1'",
        "assert logs[6][2] == f'python: {platform.python_version()}'",
        "assert logs[7][2] == f'platform: {platform.platform()}'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "run_startup",
          "body": "@pytest.fixture(scope='function')\ndef run_startup(caplog):\n\n    def run(app):\n        nonlocal caplog\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n        with caplog.at_level(logging.DEBUG):\n            server = app.create_server(debug=True, return_asyncio_server=True, port=PORT)\n            loop._stopping = False\n            _server = loop.run_until_complete(server)\n            _server.close()\n            loop.run_until_complete(_server.wait_closed())\n            app.stop()\n        return caplog.record_tuples\n    return run"
        }
      ]
    },
    {
      "name": "test_motd_init",
      "module": "test_motd",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_motd.py",
      "line_number": 41,
      "end_line_number": 47,
      "source_code": "def test_motd_init():\n    _orig = MOTDTTY.set_variables\n    MOTDTTY.set_variables = Mock()\n    motd = MOTDTTY(None, \"\", {}, {})\n\n    motd.set_variables.assert_called_once()\n    MOTDTTY.set_variables = _orig",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "os",
        "platform",
        "sys",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.__version__",
        "sanic.application.logo.BASE_LOGO",
        "sanic.application.motd.MOTD",
        "sanic.application.motd.MOTDTTY"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_motd_display",
      "module": "test_motd",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_motd.py",
      "line_number": 50,
      "end_line_number": 69,
      "source_code": "def test_motd_display(caplog):\n    motd = MOTDTTY(\"       foobar        \", \"\", {\"one\": \"1\"}, {\"two\": \"2\"})\n\n    with caplog.at_level(logging.INFO):\n        motd.display()\n\n    version_line = f\"Sanic v{__version__}\".center(motd.centering_length)\n    assert (\n        \"\".join(caplog.messages)\n        == f\"\"\"\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502 {version_line} \u2502\n  \u2502                                \u2502\n  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n  \u2502        foobar         \u2502 one: 1 \u2502\n  \u2502                       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n  \u2502                       \u2502 two: 2 \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\"\"\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "caplog"
      ],
      "imports": [
        "logging",
        "os",
        "platform",
        "sys",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.__version__",
        "sanic.application.logo.BASE_LOGO",
        "sanic.application.motd.MOTD",
        "sanic.application.motd.MOTDTTY"
      ],
      "fixtures": [],
      "assertions": [
        "assert ''.join(caplog.messages) == f'\\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n  \u2502 {version_line} \u2502\\n  \u2502                                \u2502\\n  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n  \u2502        foobar         \u2502 one: 1 \u2502\\n  \u2502                       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n  \u2502                       \u2502 two: 2 \u2502\\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "motd.display",
          "body": "@app.on_response\ndef display(_, response):\n    response['foo'] = 'bar'\n    return json(response)"
        }
      ]
    },
    {
      "name": "test_reload_dirs",
      "module": "test_motd",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_motd.py",
      "line_number": 73,
      "end_line_number": 84,
      "source_code": "def test_reload_dirs(app):\n    app.config.LOGO = None\n    app.config.MOTD = True\n    app.config.AUTO_RELOAD = True\n\n    with patch.object(MOTD, \"output\") as mock:\n        app.prepare(\n            reload_dir=\"./\", auto_reload=True, motd_display={\"foo\": \"bar\"}\n        )\n    mock.assert_called()\n    assert mock.call_args.args[2][\"auto-reload\"] == f\"enabled, {os.getcwd()}\"\n    assert mock.call_args.args[3] == {\"foo\": \"bar\"}",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(sys.version_info < (3, 8), reason='Not on 3.7')"
      ],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "platform",
        "sys",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.__version__",
        "sanic.application.logo.BASE_LOGO",
        "sanic.application.motd.MOTD",
        "sanic.application.motd.MOTDTTY"
      ],
      "fixtures": [],
      "assertions": [
        "assert mock.call_args.args[2]['auto-reload'] == f'enabled, {os.getcwd()}'",
        "assert mock.call_args.args[3] == {'foo': 'bar'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_shutdown_tasks_on_app_stop",
      "module": "test_tasks",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tasks.py",
      "line_number": 95,
      "end_line_number": 110,
      "source_code": "def test_shutdown_tasks_on_app_stop():\n    class TestSanic(Sanic):\n        shutdown_tasks = Mock()\n\n    app = TestSanic(\"Test\")\n\n    @app.route(\"/\")\n    async def handler(_):\n        return empty()\n\n    app.test_client.get(\"/\")\n\n    app.shutdown_tasks.call_args == [\n        call(timeout=0),\n        call(15.0),\n    ]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "asyncio.tasks.Task",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "pytest",
        "sanic.app.Sanic",
        "sanic.application.state.ApplicationServerInfo",
        "sanic.application.state.ServerStage",
        "sanic.response.empty",
        "unittest.mock.AsyncMock",
        "tests.asyncmock.AsyncMock"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_app_loop_running",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 31,
      "end_line_number": 38,
      "source_code": "def test_app_loop_running(app: Sanic):\n    @app.get(\"/test\")\n    async def handler(request):\n        assert isinstance(app.loop, asyncio.AbstractEventLoop)\n        return text(\"pass\")\n\n    request, response = app.test_client.get(\"/test\")\n    assert response.text == \"pass\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'pass'",
        "assert isinstance(app.loop, asyncio.AbstractEventLoop)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_create_asyncio_server",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 42,
      "end_line_number": 47,
      "source_code": "def test_create_asyncio_server(app: Sanic, port: int):\n    loop = asyncio.get_event_loop()\n    asyncio_srv_coro = app.create_server(return_asyncio_server=True, port=port)\n    assert isawaitable(asyncio_srv_coro)\n    srv = loop.run_until_complete(asyncio_srv_coro)\n    assert srv.is_serving() is True",
      "docstring": null,
      "decorators": [
        "pytest.mark.asyncio"
      ],
      "arguments": [
        "app",
        "port"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert isawaitable(asyncio_srv_coro)",
        "assert srv.is_serving() is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_asyncio_server_no_start_serving",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 51,
      "end_line_number": 59,
      "source_code": "def test_asyncio_server_no_start_serving(app: Sanic, port):\n    loop = asyncio.get_event_loop()\n    asyncio_srv_coro = app.create_server(\n        port=port,\n        return_asyncio_server=True,\n        asyncio_server_kwargs=dict(start_serving=False),\n    )\n    srv = loop.run_until_complete(asyncio_srv_coro)\n    assert srv.is_serving() is False",
      "docstring": null,
      "decorators": [
        "pytest.mark.asyncio"
      ],
      "arguments": [
        "app",
        "port"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert srv.is_serving() is False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_asyncio_server_start_serving",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 63,
      "end_line_number": 76,
      "source_code": "def test_asyncio_server_start_serving(app: Sanic):\n    loop = asyncio.get_event_loop()\n    asyncio_srv_coro = app.create_server(\n        port=43124,\n        return_asyncio_server=True,\n        asyncio_server_kwargs=dict(start_serving=False),\n    )\n    srv = loop.run_until_complete(asyncio_srv_coro)\n    assert srv.is_serving() is False\n    loop.run_until_complete(srv.startup())\n    loop.run_until_complete(srv.start_serving())\n    assert srv.is_serving() is True\n    wait_close = srv.close()\n    loop.run_until_complete(wait_close)",
      "docstring": null,
      "decorators": [
        "pytest.mark.asyncio"
      ],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert srv.is_serving() is False",
        "assert srv.is_serving() is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_create_server_main",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 81,
      "end_line_number": 94,
      "source_code": "def test_create_server_main(app: Sanic, caplog, port):\n    app.listener(\"main_process_start\")(lambda *_: ...)\n    loop = asyncio.get_event_loop()\n    with caplog.at_level(logging.INFO):\n        asyncio_srv_coro = app.create_server(\n            return_asyncio_server=True, port=port\n        )\n        loop.run_until_complete(asyncio_srv_coro)\n    assert (\n        \"sanic.root\",\n        30,\n        \"Listener events for the main process are not available with \"\n        \"create_server()\",\n    ) in caplog.record_tuples",
      "docstring": null,
      "decorators": [
        "pytest.mark.asyncio"
      ],
      "arguments": [
        "app",
        "caplog",
        "port"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert ('sanic.root', 30, 'Listener events for the main process are not available with create_server()') in caplog.record_tuples"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_create_server_no_startup",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 98,
      "end_line_number": 110,
      "source_code": "def test_create_server_no_startup(app: Sanic, port):\n    loop = asyncio.get_event_loop()\n    asyncio_srv_coro = app.create_server(\n        port=port,\n        return_asyncio_server=True,\n        asyncio_server_kwargs=dict(start_serving=False),\n    )\n    srv = loop.run_until_complete(asyncio_srv_coro)\n    message = (\n        \"Cannot run Sanic server without first running await server.startup()\"\n    )\n    with pytest.raises(SanicException, match=message):\n        loop.run_until_complete(srv.start_serving())",
      "docstring": null,
      "decorators": [
        "pytest.mark.asyncio"
      ],
      "arguments": [
        "app",
        "port"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_create_server_main_convenience",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 114,
      "end_line_number": 127,
      "source_code": "def test_create_server_main_convenience(app: Sanic, caplog, port):\n    app.main_process_start(lambda *_: ...)\n    loop = asyncio.get_event_loop()\n    with caplog.at_level(logging.INFO):\n        asyncio_srv_coro = app.create_server(\n            return_asyncio_server=True, port=port\n        )\n        loop.run_until_complete(asyncio_srv_coro)\n    assert (\n        \"sanic.root\",\n        30,\n        \"Listener events for the main process are not available with \"\n        \"create_server()\",\n    ) in caplog.record_tuples",
      "docstring": null,
      "decorators": [
        "pytest.mark.asyncio"
      ],
      "arguments": [
        "app",
        "caplog",
        "port"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert ('sanic.root', 30, 'Listener events for the main process are not available with create_server()') in caplog.record_tuples"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.main_process_start",
          "body": "@app.listener('main_process_start')\ndef main_process_start(app, loop):\n    logger.info('main_process_start')"
        }
      ]
    },
    {
      "name": "test_app_loop_not_running",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 130,
      "end_line_number": 137,
      "source_code": "def test_app_loop_not_running(app: Sanic):\n    with pytest.raises(SanicException) as excinfo:\n        app.loop\n\n    assert str(excinfo.value) == (\n        \"Loop can only be retrieved after the app has started \"\n        \"running. Not supported with `create_server` function\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(excinfo.value) == 'Loop can only be retrieved after the app has started running. Not supported with `create_server` function'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_app_run_raise_type_error",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 140,
      "end_line_number": 149,
      "source_code": "def test_app_run_raise_type_error(app: Sanic, port):\n    with pytest.raises(TypeError) as excinfo:\n        app.run(loop=\"loop\", port=port)\n\n    assert str(excinfo.value) == (\n        \"loop is not a valid argument. To use an existing loop, \"\n        \"change to create_server().\\nSee more: \"\n        \"https://sanic.readthedocs.io/en/latest/sanic/deploying.html\"\n        \"#asynchronous-support\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "port"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(excinfo.value) == 'loop is not a valid argument. To use an existing loop, change to create_server().\\nSee more: https://sanic.readthedocs.io/en/latest/sanic/deploying.html#asynchronous-support'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ]
    },
    {
      "name": "test_app_route_raise_value_error",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 152,
      "end_line_number": 162,
      "source_code": "def test_app_route_raise_value_error(app: Sanic):\n    with pytest.raises(ValueError) as excinfo:\n\n        @app.route(\"/test\")\n        async def handler():\n            return text(\"test\")\n\n    assert (\n        str(excinfo.value)\n        == \"Required parameter `request` missing in the handler() route?\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(excinfo.value) == 'Required parameter `request` missing in the handler() route?'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_app_handle_request_handler_is_none",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 165,
      "end_line_number": 185,
      "source_code": "def test_app_handle_request_handler_is_none(app: Sanic, monkeypatch):\n    app.config.TOUCHUP = False\n    route = Mock(spec=Route)\n    route.extra.request_middleware = []\n    route.extra.response_middleware = []\n\n    def mockreturn(*args, **kwargs):\n        return route, None, {}\n\n    monkeypatch.setattr(app.router, \"get\", mockreturn)\n\n    @app.get(\"/test\")\n    def handler(request):\n        return text(\"test\")\n\n    _, response = app.test_client.get(\"/test\")\n\n    assert (\n        \"'None' was returned while requesting a handler from the router\"\n        in response.text\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "monkeypatch"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert \"'None' was returned while requesting a handler from the router\" in response.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_app_enable_websocket",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 190,
      "end_line_number": 200,
      "source_code": "def test_app_enable_websocket(app: Sanic, websocket_enabled, enable):\n    app.websocket_enabled = websocket_enabled\n    app.enable_websocket(enable=enable)\n\n    assert app.websocket_enabled == enable\n\n    @app.websocket(\"/ws\")\n    async def handler(request, ws):\n        await ws.send(\"test\")\n\n    assert app.websocket_enabled is True",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('websocket_enabled', [True, False])",
        "pytest.mark.parametrize('enable', [True, False])"
      ],
      "arguments": [
        "app",
        "websocket_enabled",
        "enable"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.websocket_enabled == enable",
        "assert app.websocket_enabled is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "ws.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        }
      ]
    },
    {
      "name": "test_app_websocket_parameters",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 204,
      "end_line_number": 230,
      "source_code": "def test_app_websocket_parameters(websocket_protocol_mock, app: Sanic):\n    app.config.WEBSOCKET_MAX_SIZE = 44\n    app.config.WEBSOCKET_PING_TIMEOUT = 48\n    app.config.WEBSOCKET_PING_INTERVAL = 50\n\n    @app.websocket(\"/ws\")\n    async def handler(request, ws):\n        await ws.send(\"test\")\n\n    try:\n        # This will fail because WebSocketProtocol is mocked and only the\n        # call kwargs matter\n        app.test_client.get(\"/ws\")\n    except Exception:\n        pass\n\n    websocket_protocol_call_args = websocket_protocol_mock.call_args\n    ws_kwargs = websocket_protocol_call_args[1]\n    assert ws_kwargs[\"websocket_max_size\"] == app.config.WEBSOCKET_MAX_SIZE\n    assert (\n        ws_kwargs[\"websocket_ping_timeout\"]\n        == app.config.WEBSOCKET_PING_TIMEOUT\n    )\n    assert (\n        ws_kwargs[\"websocket_ping_interval\"]\n        == app.config.WEBSOCKET_PING_INTERVAL\n    )",
      "docstring": null,
      "decorators": [
        "patch('sanic.mixins.startup.WebSocketProtocol')"
      ],
      "arguments": [
        "websocket_protocol_mock",
        "app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert ws_kwargs['websocket_max_size'] == app.config.WEBSOCKET_MAX_SIZE",
        "assert ws_kwargs['websocket_ping_timeout'] == app.config.WEBSOCKET_PING_TIMEOUT",
        "assert ws_kwargs['websocket_ping_interval'] == app.config.WEBSOCKET_PING_INTERVAL"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "ws.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        }
      ]
    },
    {
      "name": "test_handle_request_with_nested_exception",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 233,
      "end_line_number": 249,
      "source_code": "def test_handle_request_with_nested_exception(app: Sanic, monkeypatch):\n    err_msg = \"Mock Exception\"\n\n    def mock_error_handler_response(*args, **kwargs):\n        raise Exception(err_msg)\n\n    monkeypatch.setattr(\n        app.error_handler, \"response\", mock_error_handler_response\n    )\n\n    @app.get(\"/\")\n    def handler(request):\n        raise Exception\n\n    request, response = app.test_client.get(\"/\")\n    assert response.status == 500\n    assert response.text == \"An error occurred while handling an error\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "monkeypatch"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert response.text == 'An error occurred while handling an error'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_handle_request_with_nested_exception_debug",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 252,
      "end_line_number": 271,
      "source_code": "def test_handle_request_with_nested_exception_debug(app: Sanic, monkeypatch):\n    err_msg = \"Mock Exception\"\n\n    def mock_error_handler_response(*args, **kwargs):\n        raise Exception(err_msg)\n\n    monkeypatch.setattr(\n        app.error_handler, \"response\", mock_error_handler_response\n    )\n\n    @app.get(\"/\")\n    def handler(request):\n        raise Exception\n\n    request, response = app.test_client.get(\"/\", debug=True)\n    assert response.status == 500\n    assert response.text.startswith(\n        f\"Error while handling error: {err_msg}\\n\"\n        \"Stack: Traceback (most recent call last):\\n\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "monkeypatch"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert response.text.startswith(f'Error while handling error: {err_msg}\\nStack: Traceback (most recent call last):\\n')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_handle_request_with_nested_sanic_exception",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 274,
      "end_line_number": 298,
      "source_code": "def test_handle_request_with_nested_sanic_exception(\n    app: Sanic, monkeypatch, caplog\n):\n    def mock_error_handler_response(*args, **kwargs):\n        raise SanicException(\"Mock SanicException\")\n\n    monkeypatch.setattr(\n        app.error_handler, \"response\", mock_error_handler_response\n    )\n\n    @app.get(\"/\")\n    def handler(request):\n        raise Exception\n\n    with caplog.at_level(logging.ERROR):\n        request, response = app.test_client.get(\"/\")\n    port = request.server_port\n    assert port > 0\n    assert response.status == 500\n    assert \"Mock SanicException\" in response.text\n    assert (\n        \"sanic.error\",\n        logging.ERROR,\n        f\"Exception occurred while handling uri: 'http://127.0.0.1:{port}/'\",\n    ) in caplog.record_tuples",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "monkeypatch",
        "caplog"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert port > 0",
        "assert response.status == 500",
        "assert 'Mock SanicException' in response.text",
        "assert ('sanic.error', logging.ERROR, f\"Exception occurred while handling uri: 'http://127.0.0.1:{port}/'\") in caplog.record_tuples"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_app_name_required",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 301,
      "end_line_number": 303,
      "source_code": "def test_app_name_required():\n    with pytest.raises(TypeError):\n        Sanic()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_app_has_test_mode_sync",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 306,
      "end_line_number": 315,
      "source_code": "def test_app_has_test_mode_sync():\n    app = Sanic(\"test\")\n\n    @app.get(\"/\")\n    def handler(request):\n        assert request.app.test_mode\n        return text(\"test\")\n\n    _, response = app.test_client.get(\"/\")\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert request.app.test_mode"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_app_registry",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 318,
      "end_line_number": 324,
      "source_code": "def test_app_registry():\n    assert len(Sanic._app_registry) == 0\n    instance = Sanic(\"test\")\n    assert len(Sanic._app_registry) == 1\n    assert Sanic._app_registry[\"test\"] is instance\n    Sanic.unregister_app(instance)\n    assert len(Sanic._app_registry) == 0",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(Sanic._app_registry) == 0",
        "assert len(Sanic._app_registry) == 1",
        "assert Sanic._app_registry['test'] is instance",
        "assert len(Sanic._app_registry) == 0"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_app_registry_wrong_type",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 327,
      "end_line_number": 331,
      "source_code": "def test_app_registry_wrong_type():\n    with pytest.raises(\n        SanicException, match=\"Registered app must be an instance of Sanic\"\n    ):\n        Sanic.register_app(1)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_app_registry_name_reuse",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 334,
      "end_line_number": 342,
      "source_code": "def test_app_registry_name_reuse():\n    Sanic(\"test\")\n    Sanic.test_mode = False\n    with pytest.raises(\n        SanicException, match='Sanic app name \"test\" already in use.'\n    ):\n        Sanic(\"test\")\n    Sanic.test_mode = True\n    Sanic(\"test\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_app_registry_retrieval",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 345,
      "end_line_number": 347,
      "source_code": "def test_app_registry_retrieval():\n    instance = Sanic(\"test\")\n    assert Sanic.get_app(\"test\") is instance",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert Sanic.get_app('test') is instance"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_app_registry_retrieval_from_multiple",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 350,
      "end_line_number": 353,
      "source_code": "def test_app_registry_retrieval_from_multiple():\n    instance = Sanic(\"test\")\n    Sanic(\"something_else\")\n    assert Sanic.get_app(\"test\") is instance",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert Sanic.get_app('test') is instance"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_get_app_does_not_exist",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 356,
      "end_line_number": 368,
      "source_code": "def test_get_app_does_not_exist():\n    with pytest.raises(\n        SanicException,\n        match=(\n            \"Sanic app name 'does-not-exist' not found.\\n\"\n            \"App instantiation must occur outside \"\n            \"if __name__ == '__main__' \"\n            \"block or by using an AppLoader.\\nSee \"\n            \"https://sanic.dev/en/guide/deployment/app-loader.html\"\n            \" for more details.\"\n        ),\n    ):\n        Sanic.get_app(\"does-not-exist\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_get_app_does_not_exist_force_create",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 371,
      "end_line_number": 374,
      "source_code": "def test_get_app_does_not_exist_force_create():\n    assert isinstance(\n        Sanic.get_app(\"does-not-exist\", force_create=True), Sanic\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(Sanic.get_app('does-not-exist', force_create=True), Sanic)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_get_app_default",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 377,
      "end_line_number": 379,
      "source_code": "def test_get_app_default():\n    instance = Sanic(\"test\")\n    assert Sanic.get_app() is instance",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert Sanic.get_app() is instance"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_get_app_no_default",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 382,
      "end_line_number": 386,
      "source_code": "def test_get_app_no_default():\n    with pytest.raises(\n        SanicException, match=\"No Sanic apps have been registered.\"\n    ):\n        Sanic.get_app()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_get_app_default_ambiguous",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 389,
      "end_line_number": 398,
      "source_code": "def test_get_app_default_ambiguous():\n    Sanic(\"test1\")\n    Sanic(\"test2\")\n    with pytest.raises(\n        SanicException,\n        match=re.escape(\n            'Multiple Sanic apps found, use Sanic.get_app(\"app_name\")'\n        ),\n    ):\n        Sanic.get_app()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_app_set_attribute_warning",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 401,
      "end_line_number": 407,
      "source_code": "def test_app_set_attribute_warning(app: Sanic):\n    message = (\n        \"Setting variables on Sanic instances is not allowed. You should \"\n        \"change your Sanic instance to use instance.ctx.foo instead.\"\n    )\n    with pytest.raises(AttributeError, match=message):\n        app.foo = 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_app_set_context",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 410,
      "end_line_number": 414,
      "source_code": "def test_app_set_context(app: Sanic):\n    app.ctx.foo = 1\n\n    retrieved = Sanic.get_app(app.name)\n    assert retrieved.ctx.foo == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert retrieved.ctx.foo == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_subclass_initialisation",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 417,
      "end_line_number": 421,
      "source_code": "def test_subclass_initialisation():\n    class CustomSanic(Sanic):\n        pass\n\n    CustomSanic(\"test_subclass_initialisation\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_bad_custom_config",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 424,
      "end_line_number": 432,
      "source_code": "def test_bad_custom_config():\n    with pytest.raises(\n        SanicException,\n        match=(\n            \"When instantiating Sanic with config, you cannot also pass \"\n            \"env_prefix\"\n        ),\n    ):\n        Sanic(\"test\", config=1, env_prefix=1)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_custom_config",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 435,
      "end_line_number": 441,
      "source_code": "def test_custom_config():\n    class CustomConfig(Config): ...\n\n    config = CustomConfig()\n    app = Sanic(\"custom\", config=config)\n\n    assert app.config == config",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.config == config"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_custom_context",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 444,
      "end_line_number": 450,
      "source_code": "def test_custom_context():\n    class CustomContext: ...\n\n    ctx = CustomContext()\n    app = Sanic(\"custom\", ctx=ctx)\n\n    assert app.ctx == ctx",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.ctx == ctx"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_uvloop_config",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 454,
      "end_line_number": 476,
      "source_code": "def test_uvloop_config(app: Sanic, monkeypatch, use):\n    @app.get(\"/test\", name=\"test\")\n    def handler(request):\n        return text(\"ok\")\n\n    try_use_uvloop = Mock()\n    monkeypatch.setattr(sanic.mixins.startup, \"try_use_uvloop\", try_use_uvloop)\n\n    # Default config\n    app.test_client.get(\"/test\")\n    if OS_IS_WINDOWS:\n        try_use_uvloop.assert_not_called()\n    else:\n        try_use_uvloop.assert_called_once()\n\n    try_use_uvloop.reset_mock()\n    app.config[\"USE_UVLOOP\"] = use\n    app.test_client.get(\"/test\")\n\n    if use:\n        try_use_uvloop.assert_called_once()\n    else:\n        try_use_uvloop.assert_not_called()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('use', (False, True))"
      ],
      "arguments": [
        "app",
        "monkeypatch",
        "use"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "try_use_uvloop.reset_mock",
          "body": "def reset_mock(self, *args, **kwargs):\n    super().reset_mock(*args, **kwargs)\n    self.await_count = 0"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_uvloop_cannot_never_called_with_create_server",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 480,
      "end_line_number": 514,
      "source_code": "def test_uvloop_cannot_never_called_with_create_server(caplog, monkeypatch):\n    apps = (Sanic(\"default-uvloop\"), Sanic(\"no-uvloop\"), Sanic(\"yes-uvloop\"))\n\n    apps[1].config.USE_UVLOOP = False\n    apps[2].config.USE_UVLOOP = True\n\n    try_use_uvloop = Mock()\n    monkeypatch.setattr(sanic.mixins.startup, \"try_use_uvloop\", try_use_uvloop)\n\n    loop = asyncio.get_event_loop()\n\n    with caplog.at_level(logging.WARNING):\n        for app in apps:\n            srv_coro = app.create_server(\n                return_asyncio_server=True,\n                asyncio_server_kwargs=dict(start_serving=False),\n                port=get_port(),\n            )\n            loop.run_until_complete(srv_coro)\n\n    try_use_uvloop.assert_not_called()  # Check it didn't try to change policy\n\n    message = (\n        \"You are trying to change the uvloop configuration, but \"\n        \"this is only effective when using the run(...) method. \"\n        \"When using the create_server(...) method Sanic will use \"\n        \"the already existing loop.\"\n    )\n\n    counter = Counter([(r[1], r[2]) for r in caplog.record_tuples])\n    modified = sum(\n        1 for app in apps if not isinstance(app.config.USE_UVLOOP, Default)\n    )\n\n    assert counter[(logging.WARNING, message)] == modified",
      "docstring": null,
      "decorators": [
        "pytest.mark.asyncio"
      ],
      "arguments": [
        "caplog",
        "monkeypatch"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert counter[logging.WARNING, message] == modified"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_port",
          "body": "def get_port():\n    sock = socket.socket()\n    sock.bind(('', 0))\n    return sock.getsockname()[1]"
        }
      ]
    },
    {
      "name": "test_multiple_uvloop_configs_display_warning",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 518,
      "end_line_number": 548,
      "source_code": "def test_multiple_uvloop_configs_display_warning(caplog):\n    Sanic._uvloop_setting = None  # Reset the setting (changed in prev tests)\n\n    default_uvloop = Sanic(\"default-uvloop\")\n    no_uvloop = Sanic(\"no-uvloop\")\n    yes_uvloop = Sanic(\"yes-uvloop\")\n\n    no_uvloop.config.USE_UVLOOP = False\n    yes_uvloop.config.USE_UVLOOP = True\n\n    loop = asyncio.get_event_loop()\n\n    with caplog.at_level(logging.WARNING):\n        for app in (default_uvloop, no_uvloop, yes_uvloop):\n            srv_coro = app.create_server(\n                return_asyncio_server=True,\n                asyncio_server_kwargs=dict(start_serving=False),\n                port=get_port(),\n            )\n            srv = loop.run_until_complete(srv_coro)\n            loop.run_until_complete(srv.startup())\n\n    message = (\n        \"It looks like you're running several apps with different \"\n        \"uvloop settings. This is not supported and may lead to \"\n        \"unintended behaviour.\"\n    )\n\n    counter = Counter([(r[1], r[2]) for r in caplog.record_tuples])\n\n    assert counter[(logging.WARNING, message)] == 3",
      "docstring": null,
      "decorators": [
        "pytest.mark.asyncio"
      ],
      "arguments": [
        "caplog"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert counter[logging.WARNING, message] == 3"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "get_port",
          "body": "def get_port():\n    sock = socket.socket()\n    sock.bind(('', 0))\n    return sock.getsockname()[1]"
        }
      ]
    },
    {
      "name": "test_cannot_run_fast_and_workers",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 551,
      "end_line_number": 554,
      "source_code": "def test_cannot_run_fast_and_workers(app: Sanic, port):\n    message = \"You cannot use both fast=True and workers=X\"\n    with pytest.raises(RuntimeError, match=message):\n        app.run(fast=True, workers=4, port=port)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "port"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ]
    },
    {
      "name": "test_no_workers",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 557,
      "end_line_number": 559,
      "source_code": "def test_no_workers(app: Sanic, port):\n    with pytest.raises(RuntimeError, match=\"Cannot serve with no workers\"):\n        app.run(workers=0, port=port)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "port"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ]
    },
    {
      "name": "test_cannot_run_single_process_and_workers_or_auto_reload",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 570,
      "end_line_number": 577,
      "source_code": "def test_cannot_run_single_process_and_workers_or_auto_reload(\n    app: Sanic, extra, port\n):\n    message = (\n        \"Single process cannot be run with multiple workers or auto-reload\"\n    )\n    with pytest.raises(RuntimeError, match=message):\n        app.run(single_process=True, port=port, **extra)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('extra', ({'fast': True}, {'workers': 2}, {'auto_reload': True}))"
      ],
      "arguments": [
        "app",
        "extra",
        "port"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ]
    },
    {
      "name": "test_default_configure_logging",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 580,
      "end_line_number": 584,
      "source_code": "def test_default_configure_logging():\n    with patch(\"sanic.app.logging\") as mock:\n        Sanic(\"Test\")\n\n    mock.config.dictConfig.assert_called_with(LOGGING_CONFIG_DEFAULTS)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ]
    },
    {
      "name": "test_custom_configure_logging",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 587,
      "end_line_number": 591,
      "source_code": "def test_custom_configure_logging():\n    with patch(\"sanic.app.logging\") as mock:\n        Sanic(\"Test\", log_config={\"foo\": \"bar\"})\n\n    mock.config.dictConfig.assert_called_with({\"foo\": \"bar\"})",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ]
    },
    {
      "name": "test_disable_configure_logging",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 594,
      "end_line_number": 598,
      "source_code": "def test_disable_configure_logging():\n    with patch(\"sanic.app.logging\") as mock:\n        Sanic(\"Test\", configure_logging=False)\n\n    mock.config.dictConfig.assert_not_called()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ]
    },
    {
      "name": "test_inspector",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 602,
      "end_line_number": 604,
      "source_code": "def test_inspector(inspector):\n    app = Sanic(\"Test\", inspector=inspector)\n    assert app.config.INSPECTOR is inspector",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('inspector', (True, False))"
      ],
      "arguments": [
        "inspector"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.config.INSPECTOR is inspector"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_build_endpoint_name",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 607,
      "end_line_number": 610,
      "source_code": "def test_build_endpoint_name():\n    app = Sanic(\"Test\")\n    name = app._build_endpoint_name(\"foo\", \"bar\")\n    assert name == \"Test.foo.bar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert name == 'Test.foo.bar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_manager_in_main_process_only",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 613,
      "end_line_number": 627,
      "source_code": "def test_manager_in_main_process_only(app: Sanic):\n    message = \"Can only access the manager from the main process\"\n\n    with pytest.raises(SanicException, match=message):\n        app.manager\n\n    app._manager = 1\n    environ[\"SANIC_WORKER_PROCESS\"] = \"ok\"\n\n    with pytest.raises(SanicException, match=message):\n        app.manager\n\n    del environ[\"SANIC_WORKER_PROCESS\"]\n\n    assert app.manager == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.manager == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_inspector_in_main_process_only",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 630,
      "end_line_number": 644,
      "source_code": "def test_inspector_in_main_process_only(app: Sanic):\n    message = \"Can only access the inspector from the main process\"\n\n    with pytest.raises(SanicException, match=message):\n        app.inspector\n\n    app._inspector = 1\n    environ[\"SANIC_WORKER_PROCESS\"] = \"ok\"\n\n    with pytest.raises(SanicException, match=message):\n        app.inspector\n\n    del environ[\"SANIC_WORKER_PROCESS\"]\n\n    assert app.inspector == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.inspector == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_stop_trigger_terminate",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 647,
      "end_line_number": 665,
      "source_code": "def test_stop_trigger_terminate(app: Sanic):\n    app.multiplexer = Mock()\n\n    app.stop()\n\n    app.multiplexer.terminate.assert_called_once()\n    app.multiplexer.reset_mock()\n    assert len(Sanic._app_registry) == 1\n    Sanic._app_registry.clear()\n\n    app.stop(terminate=True)\n\n    app.multiplexer.terminate.assert_called_once()\n    app.multiplexer.reset_mock()\n    assert len(Sanic._app_registry) == 0\n    Sanic._app_registry.clear()\n\n    app.stop(unregister=False)\n    app.multiplexer.terminate.assert_called_once()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(Sanic._app_registry) == 1",
        "assert len(Sanic._app_registry) == 0"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        },
        {
          "name": "app.multiplexer.reset_mock",
          "body": "def reset_mock(self, *args, **kwargs):\n    super().reset_mock(*args, **kwargs)\n    self.await_count = 0"
        },
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        },
        {
          "name": "app.multiplexer.reset_mock",
          "body": "def reset_mock(self, *args, **kwargs):\n    super().reset_mock(*args, **kwargs)\n    self.await_count = 0"
        },
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        }
      ]
    },
    {
      "name": "test_refresh_pass_passthru_data_to_new_instance",
      "module": "test_app",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_app.py",
      "line_number": 668,
      "end_line_number": 674,
      "source_code": "def test_refresh_pass_passthru_data_to_new_instance(app: Sanic):\n    # arrange\n    passthru = {\"_inspector\": 2, \"config\": {\"TOUCHUP\": 23}}\n    app = app.refresh(passthru)\n\n    assert app.inspector == 2\n    assert app.config.TOUCHUP == 23",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "re",
        "collections.Counter",
        "inspect.isawaitable",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.config.Config",
        "sanic.exceptions.SanicException",
        "sanic.helpers.Default",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text",
        "sanic.router.Route",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.inspector == 2",
        "assert app.config.TOUCHUP == 23"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_setup",
      "module": "test_timeout_logic",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_timeout_logic.py",
      "line_number": 35,
      "end_line_number": 38,
      "source_code": "def test_setup(protocol: HttpProtocol):\n    assert protocol._task is not None\n    assert protocol._http is not None\n    assert protocol._time is not None",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "protocol"
      ],
      "imports": [
        "asyncio",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.exceptions.RequestTimeout",
        "sanic.exceptions.ServiceUnavailable",
        "sanic.http.Stage",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert protocol._task is not None",
        "assert protocol._http is not None",
        "assert protocol._time is not None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_check_timeouts_no_timeout",
      "module": "test_timeout_logic",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_timeout_logic.py",
      "line_number": 41,
      "end_line_number": 50,
      "source_code": "def test_check_timeouts_no_timeout(protocol: HttpProtocol):\n    protocol.keep_alive_timeout = 1\n    protocol.loop.call_later = Mock()\n    protocol.check_timeouts()\n    protocol._task.cancel.assert_not_called()\n    assert protocol._http.stage is Stage.IDLE\n    assert protocol._http.exception is None\n    protocol.loop.call_later.assert_called_with(\n        protocol.keep_alive_timeout / 2, protocol.check_timeouts\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "protocol"
      ],
      "imports": [
        "asyncio",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.exceptions.RequestTimeout",
        "sanic.exceptions.ServiceUnavailable",
        "sanic.http.Stage",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert protocol._http.stage is Stage.IDLE",
        "assert protocol._http.exception is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_check_timeouts_keep_alive_timeout",
      "module": "test_timeout_logic",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_timeout_logic.py",
      "line_number": 53,
      "end_line_number": 58,
      "source_code": "def test_check_timeouts_keep_alive_timeout(protocol: HttpProtocol):\n    protocol._http.stage = Stage.IDLE\n    protocol._time = 0\n    protocol.check_timeouts()\n    protocol._task.cancel.assert_called_once()\n    assert protocol._http.exception is None",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "protocol"
      ],
      "imports": [
        "asyncio",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.exceptions.RequestTimeout",
        "sanic.exceptions.ServiceUnavailable",
        "sanic.http.Stage",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert protocol._http.exception is None"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_check_timeouts_request_timeout",
      "module": "test_timeout_logic",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_timeout_logic.py",
      "line_number": 61,
      "end_line_number": 66,
      "source_code": "def test_check_timeouts_request_timeout(protocol: HttpProtocol):\n    protocol._http.stage = Stage.REQUEST\n    protocol._time = 0\n    protocol.check_timeouts()\n    protocol._task.cancel.assert_called_once()\n    assert isinstance(protocol._http.exception, RequestTimeout)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "protocol"
      ],
      "imports": [
        "asyncio",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.exceptions.RequestTimeout",
        "sanic.exceptions.ServiceUnavailable",
        "sanic.http.Stage",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(protocol._http.exception, RequestTimeout)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_check_timeouts_response_timeout",
      "module": "test_timeout_logic",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_timeout_logic.py",
      "line_number": 69,
      "end_line_number": 74,
      "source_code": "def test_check_timeouts_response_timeout(protocol: HttpProtocol):\n    protocol._http.stage = Stage.RESPONSE\n    protocol._time = 0\n    protocol.check_timeouts()\n    protocol._task.cancel.assert_called_once()\n    assert isinstance(protocol._http.exception, ServiceUnavailable)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "protocol"
      ],
      "imports": [
        "asyncio",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.exceptions.RequestTimeout",
        "sanic.exceptions.ServiceUnavailable",
        "sanic.http.Stage",
        "sanic.server.HttpProtocol"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(protocol._http.exception, ServiceUnavailable)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_load_module_from_file_location",
      "module": "test_utils",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_utils.py",
      "line_number": 19,
      "end_line_number": 22,
      "source_code": "def test_load_module_from_file_location(location):\n    module = load_module_from_file_location(location)\n\n    assert isinstance(module, ModuleType)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('location', (Path(__file__).parent / 'static' / 'app_test_config.py', str(Path(__file__).parent / 'static' / 'app_test_config.py'), str(Path(__file__).parent / 'static' / 'app_test_config.py').encode()))"
      ],
      "arguments": [
        "location"
      ],
      "imports": [
        "os.environ",
        "pathlib.Path",
        "types.ModuleType",
        "pytest",
        "sanic.exceptions.LoadFileException",
        "sanic.utils.load_module_from_file_location"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(module, ModuleType)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_loaded_module_from_file_location_name",
      "module": "test_utils",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_utils.py",
      "line_number": 25,
      "end_line_number": 33,
      "source_code": "def test_loaded_module_from_file_location_name():\n    module = load_module_from_file_location(\n        str(Path(__file__).parent / \"static\" / \"app_test_config.py\")\n    )\n\n    name = module.__name__\n    if \"C:\\\\\" in name:\n        name = name.split(\"\\\\\")[-1]\n    assert name == \"app_test_config\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "os.environ",
        "pathlib.Path",
        "types.ModuleType",
        "pytest",
        "sanic.exceptions.LoadFileException",
        "sanic.utils.load_module_from_file_location"
      ],
      "fixtures": [],
      "assertions": [
        "assert name == 'app_test_config'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_load_module_from_file_location_with_non_existing_env_variable",
      "module": "test_utils",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_utils.py",
      "line_number": 36,
      "end_line_number": 41,
      "source_code": "def test_load_module_from_file_location_with_non_existing_env_variable():\n    with pytest.raises(\n        LoadFileException,\n        match=\"The following environment variables are not set: MuuMilk\",\n    ):\n        load_module_from_file_location(\"${MuuMilk}\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "os.environ",
        "pathlib.Path",
        "types.ModuleType",
        "pytest",
        "sanic.exceptions.LoadFileException",
        "sanic.utils.load_module_from_file_location"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_load_module_from_file_location_using_env",
      "module": "test_utils",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_utils.py",
      "line_number": 44,
      "end_line_number": 49,
      "source_code": "def test_load_module_from_file_location_using_env():\n    environ[\"APP_TEST_CONFIG\"] = \"static/app_test_config.py\"\n    location = str(Path(__file__).parent / \"${APP_TEST_CONFIG}\")\n    module = load_module_from_file_location(location)\n\n    assert isinstance(module, ModuleType)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "os.environ",
        "pathlib.Path",
        "types.ModuleType",
        "pytest",
        "sanic.exceptions.LoadFileException",
        "sanic.utils.load_module_from_file_location"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(module, ModuleType)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_handler_operation_order",
      "module": "test_handler",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_handler.py",
      "line_number": 6,
      "end_line_number": 36,
      "source_code": "def test_handler_operation_order(app: Sanic):\n    operations = []\n\n    @app.on_request\n    async def on_request(_):\n        nonlocal operations\n        operations.append(1)\n\n    @app.on_response\n    async def on_response(*_):\n        nonlocal operations\n        operations.append(5)\n\n    @app.get(\"/\")\n    async def handler(_):\n        nonlocal operations\n        operations.append(3)\n        return empty()\n\n    @app.signal(Event.HTTP_HANDLER_BEFORE)\n    async def handler_before(**_):\n        nonlocal operations\n        operations.append(2)\n\n    @app.signal(Event.HTTP_HANDLER_AFTER)\n    async def handler_after(**_):\n        nonlocal operations\n        operations.append(4)\n\n    app.test_client.get(\"/\")\n    assert operations == [1, 2, 3, 4, 5]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "sanic.app.Sanic",
        "sanic.response.empty",
        "sanic.signals.Event"
      ],
      "fixtures": [],
      "assertions": [
        "assert operations == [1, 2, 3, 4, 5]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_register_system_signals",
      "module": "test_signal_handlers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_signal_handlers.py",
      "line_number": 44,
      "end_line_number": 56,
      "source_code": "def test_register_system_signals(app):\n    \"\"\"Test if sanic register system signals\"\"\"\n\n    @app.route(\"/hello\")\n    async def hello_route(request):\n        return HTTPResponse()\n\n    app.listener(\"after_server_start\")(stop)\n    app.listener(\"before_server_start\")(set_loop)\n    app.listener(\"after_server_stop\")(after)\n\n    app.run(HOST, PORT, single_process=True)\n    assert calledq.get() is True",
      "docstring": "Test if sanic register system signals",
      "decorators": [
        "pytest.mark.skipif(os.name == 'nt', reason='May hang CI on py38/windows')"
      ],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "os",
        "signal",
        "queue.Queue",
        "types.SimpleNamespace",
        "typing.Optional",
        "unittest.mock.MagicMock",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.compat.ctrlc_workaround_for_windows",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ServerError",
        "sanic.response.HTTPResponse",
        "sanic.signals.Event"
      ],
      "fixtures": [],
      "assertions": [
        "assert calledq.get() is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "calledq.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_no_register_system_signals_fails",
      "module": "test_signal_handlers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_signal_handlers.py",
      "line_number": 60,
      "end_line_number": 77,
      "source_code": "def test_no_register_system_signals_fails(app):\n    \"\"\"Test if sanic don't register system signals\"\"\"\n\n    @app.route(\"/hello\")\n    async def hello_route(request):\n        return HTTPResponse()\n\n    app.listener(\"after_server_start\")(stop)\n    app.listener(\"before_server_start\")(set_loop)\n    app.listener(\"after_server_stop\")(after)\n\n    message = (\n        r\"Cannot run Sanic\\.serve with register_sys_signals=False\\. Use \"\n        r\"Sanic.serve_single\\.\"\n    )\n    with pytest.raises(RuntimeError, match=message):\n        app.prepare(HOST, PORT, register_sys_signals=False)\n    assert calledq.empty()",
      "docstring": "Test if sanic don't register system signals",
      "decorators": [
        "pytest.mark.skipif(os.name == 'nt', reason='May hang CI on py38/windows')"
      ],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "os",
        "signal",
        "queue.Queue",
        "types.SimpleNamespace",
        "typing.Optional",
        "unittest.mock.MagicMock",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.compat.ctrlc_workaround_for_windows",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ServerError",
        "sanic.response.HTTPResponse",
        "sanic.signals.Event"
      ],
      "fixtures": [],
      "assertions": [
        "assert calledq.empty()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_dont_register_system_signals",
      "module": "test_signal_handlers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_signal_handlers.py",
      "line_number": 81,
      "end_line_number": 93,
      "source_code": "def test_dont_register_system_signals(app):\n    \"\"\"Test if sanic don't register system signals\"\"\"\n\n    @app.route(\"/hello\")\n    async def hello_route(request):\n        return HTTPResponse()\n\n    app.listener(\"after_server_start\")(stop)\n    app.listener(\"before_server_start\")(set_loop)\n    app.listener(\"after_server_stop\")(after)\n\n    app.run(HOST, PORT, register_sys_signals=False, single_process=True)\n    assert calledq.get() is False",
      "docstring": "Test if sanic don't register system signals",
      "decorators": [
        "pytest.mark.skipif(os.name == 'nt', reason='May hang CI on py38/windows')"
      ],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "os",
        "signal",
        "queue.Queue",
        "types.SimpleNamespace",
        "typing.Optional",
        "unittest.mock.MagicMock",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.compat.ctrlc_workaround_for_windows",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ServerError",
        "sanic.response.HTTPResponse",
        "sanic.signals.Event"
      ],
      "fixtures": [],
      "assertions": [
        "assert calledq.get() is False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "calledq.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_windows_workaround",
      "module": "test_signal_handlers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_signal_handlers.py",
      "line_number": 97,
      "end_line_number": 139,
      "source_code": "def test_windows_workaround():\n    \"\"\"Test Windows workaround (on any other OS)\"\"\"\n\n    # At least some code coverage, even though this test doesn't work on\n    # Windows...\n    class MockApp:\n        def __init__(self):\n            self.state = SimpleNamespace()\n            self.state.is_stopping = False\n\n        def stop(self):\n            assert not self.state.is_stopping\n            self.state.is_stopping = True\n\n        def add_task(self, func):\n            loop = asyncio.get_event_loop()\n            self.stay_active_task = loop.create_task(func(self))\n\n    async def atest(stop_first):\n        app = MockApp()\n        ctrlc_workaround_for_windows(app)\n        await asyncio.sleep(0.05)\n        if stop_first:\n            app.stop()\n            await asyncio.sleep(0.2)\n        assert app.state.is_stopping == stop_first\n        # First Ctrl+C: should call app.stop() within 0.1 seconds\n        os.kill(os.getpid(), signal.SIGINT)\n        await asyncio.sleep(0.2)\n        assert app.state.is_stopping\n        assert app.stay_active_task.result() is None\n        # Second Ctrl+C should raise\n        with pytest.raises(KeyboardInterrupt):\n            os.kill(os.getpid(), signal.SIGINT)\n        return \"OK\"\n\n    # Run in our private loop\n    loop = asyncio.new_event_loop()\n    asyncio.set_event_loop(loop)\n    res = loop.run_until_complete(atest(False))\n    assert res == \"OK\"\n    res = loop.run_until_complete(atest(True))\n    assert res == \"OK\"",
      "docstring": "Test Windows workaround (on any other OS)",
      "decorators": [
        "pytest.mark.skipif(os.name == 'nt', reason='windows cannot SIGINT processes')"
      ],
      "arguments": [],
      "imports": [
        "asyncio",
        "os",
        "signal",
        "queue.Queue",
        "types.SimpleNamespace",
        "typing.Optional",
        "unittest.mock.MagicMock",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.compat.ctrlc_workaround_for_windows",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ServerError",
        "sanic.response.HTTPResponse",
        "sanic.signals.Event"
      ],
      "fixtures": [],
      "assertions": [
        "assert res == 'OK'",
        "assert res == 'OK'",
        "assert app.state.is_stopping == stop_first",
        "assert app.state.is_stopping",
        "assert app.stay_active_task.result() is None",
        "assert not self.state.is_stopping"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        }
      ]
    },
    {
      "name": "test_signals_with_invalid_invocation",
      "module": "test_signal_handlers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_signal_handlers.py",
      "line_number": 143,
      "end_line_number": 153,
      "source_code": "def test_signals_with_invalid_invocation(app):\n    \"\"\"Test if sanic register fails with invalid invocation\"\"\"\n\n    @app.route(\"/hello\")\n    async def hello_route(request):\n        return HTTPResponse()\n\n    with pytest.raises(\n        BadRequest, match=\"Invalid event registration: Missing event name\"\n    ):\n        app.listener(stop)",
      "docstring": "Test if sanic register fails with invalid invocation",
      "decorators": [
        "pytest.mark.skipif(os.name == 'nt', reason='May hang CI on py38/windows')"
      ],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "os",
        "signal",
        "queue.Queue",
        "types.SimpleNamespace",
        "typing.Optional",
        "unittest.mock.MagicMock",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.compat.ctrlc_workaround_for_windows",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ServerError",
        "sanic.response.HTTPResponse",
        "sanic.signals.Event"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_signal_server_lifecycle_exception",
      "module": "test_signal_handlers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_signal_handlers.py",
      "line_number": 156,
      "end_line_number": 176,
      "source_code": "def test_signal_server_lifecycle_exception(app: Sanic):\n    trigger: Optional[Exception] = None\n\n    @app.route(\"/hello\")\n    async def hello_route(request):\n        return HTTPResponse()\n\n    @app.signal(Event.SERVER_EXCEPTION_REPORT)\n    async def test_signal(exception: Exception):\n        nonlocal trigger\n        trigger = exception\n\n    @app.before_server_start\n    async def test_before_server_start(app):\n        raise ServerError(\"test_before_server_start\")\n\n    with pytest.raises(ServerError, match=\"test_before_server_start\"):\n        app.run(single_process=True)\n\n    assert isinstance(trigger, ServerError)\n    assert str(trigger) == \"test_before_server_start\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "os",
        "signal",
        "queue.Queue",
        "types.SimpleNamespace",
        "typing.Optional",
        "unittest.mock.MagicMock",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic.Sanic",
        "sanic.compat.ctrlc_workaround_for_windows",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ServerError",
        "sanic.response.HTTPResponse",
        "sanic.signals.Event"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(trigger, ServerError)",
        "assert str(trigger) == 'test_before_server_start'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ]
    },
    {
      "name": "test_url_attributes_with_ssl_context",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 140,
      "end_line_number": 160,
      "source_code": "def test_url_attributes_with_ssl_context(app, path, query, expected_url):\n    context = ssl.create_default_context(purpose=ssl.Purpose.CLIENT_AUTH)\n    context.load_cert_chain(localhost_cert, localhost_key)\n\n    async def handler(request):\n        return text(\"OK\")\n\n    app.add_route(handler, path)\n\n    request, _ = app.test_client.get(\n        f\"https://{HOST}:{PORT}\" + path + f\"?{query}\",\n        server_kwargs={\"ssl\": context},\n    )\n    assert request.url == expected_url.format(HOST, request.server_port)\n\n    parsed = urlparse(request.url)\n\n    assert parsed.scheme == request.scheme\n    assert parsed.path == request.path\n    assert parsed.query == request.query_string\n    assert parsed.netloc == request.host",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('path,query,expected_url', [('/foo', '', 'https://{}:{}/foo'), ('/bar/baz', '', 'https://{}:{}/bar/baz'), ('/moo/boo', 'arg1=val1', 'https://{}:{}/moo/boo?arg1=val1')])"
      ],
      "arguments": [
        "app",
        "path",
        "query",
        "expected_url"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.url == expected_url.format(HOST, request.server_port)",
        "assert parsed.scheme == request.scheme",
        "assert parsed.path == request.path",
        "assert parsed.query == request.query_string",
        "assert parsed.netloc == request.host"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_url_attributes_with_ssl_dict",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 171,
      "end_line_number": 190,
      "source_code": "def test_url_attributes_with_ssl_dict(app, path, query, expected_url):\n    ssl_dict = {\"cert\": localhost_cert, \"key\": localhost_key}\n\n    async def handler(request):\n        return text(\"OK\")\n\n    app.add_route(handler, path)\n\n    request, _ = app.test_client.get(\n        f\"https://{HOST}:{PORT}\" + path + f\"?{query}\",\n        server_kwargs={\"ssl\": ssl_dict},\n    )\n    assert request.url == expected_url.format(HOST, request.server_port)\n\n    parsed = urlparse(request.url)\n\n    assert parsed.scheme == request.scheme\n    assert parsed.path == request.path\n    assert parsed.query == request.query_string\n    assert parsed.netloc == request.host",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('path,query,expected_url', [('/foo', '', 'https://{}:{}/foo'), ('/bar/baz', '', 'https://{}:{}/bar/baz'), ('/moo/boo', 'arg1=val1', 'https://{}:{}/moo/boo?arg1=val1')])"
      ],
      "arguments": [
        "app",
        "path",
        "query",
        "expected_url"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.url == expected_url.format(HOST, request.server_port)",
        "assert parsed.scheme == request.scheme",
        "assert parsed.path == request.path",
        "assert parsed.query == request.query_string",
        "assert parsed.netloc == request.host"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_cert_sni_single",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 193,
      "end_line_number": 215,
      "source_code": "def test_cert_sni_single(app):\n    @app.get(\"/sni\")\n    async def handler1(request):\n        return text(request.conn_info.server_name)\n\n    @app.get(\"/commonname\")\n    async def handler2(request):\n        return text(request.conn_info.cert.get(\"commonName\"))\n\n    port = app.test_client.port\n    _, response = app.test_client.get(\n        f\"https://localhost:{port}/sni\",\n        server_kwargs={\"ssl\": localhost_dir},\n    )\n    assert response.status == 200\n    assert response.text == \"localhost\"\n\n    _, response = app.test_client.get(\n        f\"https://localhost:{port}/commonname\",\n        server_kwargs={\"ssl\": localhost_dir},\n    )\n    assert response.status == 200\n    assert response.text == \"localhost\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'localhost'",
        "assert response.status == 200",
        "assert response.text == 'localhost'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "request.conn_info.cert.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_cert_sni_list",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 218,
      "end_line_number": 275,
      "source_code": "def test_cert_sni_list(app):\n    ssl_list = [sanic_dir, localhost_dir]\n\n    @app.get(\"/sni\")\n    async def handler1(request):\n        return text(request.conn_info.server_name)\n\n    @app.get(\"/commonname\")\n    async def handler2(request):\n        return text(request.conn_info.cert.get(\"commonName\"))\n\n    # This test should match the localhost cert\n    port = app.test_client.port\n    _, response = app.test_client.get(\n        f\"https://localhost:{port}/sni\",\n        server_kwargs={\"ssl\": ssl_list},\n    )\n    assert response.status == 200\n    assert response.text == \"localhost\"\n\n    request, response = app.test_client.get(\n        f\"https://localhost:{port}/commonname\",\n        server_kwargs={\"ssl\": ssl_list},\n    )\n    assert response.status == 200\n    assert response.text == \"localhost\"\n\n    # This part should use the sanic.example cert because it matches\n    with replace_server_name(\"www.sanic.example\"):\n        _, response = app.test_client.get(\n            f\"https://127.0.0.1:{port}/sni\",\n            server_kwargs={\"ssl\": ssl_list},\n        )\n        assert response.status == 200\n        assert response.text == \"www.sanic.example\"\n\n        _, response = app.test_client.get(\n            f\"https://127.0.0.1:{port}/commonname\",\n            server_kwargs={\"ssl\": ssl_list},\n        )\n        assert response.status == 200\n        assert response.text == \"sanic.example\"\n\n    # This part should use the sanic.example cert, that being the first listed\n    with replace_server_name(\"invalid.test\"):\n        _, response = app.test_client.get(\n            f\"https://127.0.0.1:{port}/sni\",\n            server_kwargs={\"ssl\": ssl_list},\n        )\n        assert response.status == 200\n        assert response.text == \"invalid.test\"\n\n        _, response = app.test_client.get(\n            f\"https://127.0.0.1:{port}/commonname\",\n            server_kwargs={\"ssl\": ssl_list},\n        )\n        assert response.status == 200\n        assert response.text == \"sanic.example\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'localhost'",
        "assert response.status == 200",
        "assert response.text == 'localhost'",
        "assert response.status == 200",
        "assert response.text == 'www.sanic.example'",
        "assert response.status == 200",
        "assert response.text == 'sanic.example'",
        "assert response.status == 200",
        "assert response.text == 'invalid.test'",
        "assert response.status == 200",
        "assert response.text == 'sanic.example'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "replace_server_name",
          "body": "@contextmanager\ndef replace_server_name(hostname):\n    \"\"\"Temporarily replace the server name sent with all TLS requests with\n    a fake hostname.\"\"\"\n\n    def hack_wrap_bio(self, incoming, outgoing, server_side=False, server_hostname=None, session=None):\n        return orig_wrap_bio(self, incoming, outgoing, server_side, hostname, session)\n    (orig_wrap_bio, ssl.SSLContext.wrap_bio) = (ssl.SSLContext.wrap_bio, hack_wrap_bio)\n    try:\n        yield\n    finally:\n        ssl.SSLContext.wrap_bio = orig_wrap_bio"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "replace_server_name",
          "body": "@contextmanager\ndef replace_server_name(hostname):\n    \"\"\"Temporarily replace the server name sent with all TLS requests with\n    a fake hostname.\"\"\"\n\n    def hack_wrap_bio(self, incoming, outgoing, server_side=False, server_hostname=None, session=None):\n        return orig_wrap_bio(self, incoming, outgoing, server_side, hostname, session)\n    (orig_wrap_bio, ssl.SSLContext.wrap_bio) = (ssl.SSLContext.wrap_bio, hack_wrap_bio)\n    try:\n        yield\n    finally:\n        ssl.SSLContext.wrap_bio = orig_wrap_bio"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "request.conn_info.cert.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_missing_sni",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 279,
      "end_line_number": 294,
      "source_code": "def test_missing_sni(app):\n    \"\"\"The sanic cert does not list 127.0.0.1 and httpx does not send\n    IP as SNI anyway.\"\"\"\n    ssl_list = [None, sanic_dir]\n\n    @app.get(\"/sni\")\n    async def handler(request):\n        return text(request.conn_info.server_name)\n\n    port = app.test_client.port\n    with pytest.raises(Exception) as exc:\n        app.test_client.get(\n            f\"https://127.0.0.1:{port}/sni\",\n            server_kwargs={\"ssl\": ssl_list},\n        )\n    assert \"Request and response object expected\" in str(exc.value)",
      "docstring": "The sanic cert does not list 127.0.0.1 and httpx does not send\nIP as SNI anyway.",
      "decorators": [
        "pytest.mark.xfail"
      ],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'Request and response object expected' in str(exc.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_no_matching_cert",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 298,
      "end_line_number": 314,
      "source_code": "def test_no_matching_cert(app):\n    \"\"\"The sanic cert does not list 127.0.0.1 and httpx does not send\n    IP as SNI anyway.\"\"\"\n    ssl_list = [None, sanic_dir]\n\n    @app.get(\"/sni\")\n    async def handler(request):\n        return text(request.conn_info.server_name)\n\n    port = app.test_client.port\n    with replace_server_name(\"invalid.test\"):\n        with pytest.raises(Exception) as exc:\n            app.test_client.get(\n                f\"https://127.0.0.1:{port}/sni\",\n                server_kwargs={\"ssl\": ssl_list},\n            )\n    assert \"Request and response object expected\" in str(exc.value)",
      "docstring": "The sanic cert does not list 127.0.0.1 and httpx does not send\nIP as SNI anyway.",
      "decorators": [
        "pytest.mark.xfail"
      ],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'Request and response object expected' in str(exc.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "replace_server_name",
          "body": "@contextmanager\ndef replace_server_name(hostname):\n    \"\"\"Temporarily replace the server name sent with all TLS requests with\n    a fake hostname.\"\"\"\n\n    def hack_wrap_bio(self, incoming, outgoing, server_side=False, server_hostname=None, session=None):\n        return orig_wrap_bio(self, incoming, outgoing, server_side, hostname, session)\n    (orig_wrap_bio, ssl.SSLContext.wrap_bio) = (ssl.SSLContext.wrap_bio, hack_wrap_bio)\n    try:\n        yield\n    finally:\n        ssl.SSLContext.wrap_bio = orig_wrap_bio"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_wildcards",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 318,
      "end_line_number": 348,
      "source_code": "def test_wildcards(app):\n    ssl_list = [None, localhost_dir, sanic_dir]\n\n    @app.get(\"/sni\")\n    async def handler(request):\n        return text(request.conn_info.server_name)\n\n    port = app.test_client.port\n\n    with replace_server_name(\"foo.sanic.test\"):\n        _, response = app.test_client.get(\n            f\"https://127.0.0.1:{port}/sni\",\n            server_kwargs={\"ssl\": ssl_list},\n        )\n        assert response.status == 200\n        assert response.text == \"foo.sanic.test\"\n\n    with replace_server_name(\"sanic.test\"):\n        with pytest.raises(Exception) as exc:\n            _, response = app.test_client.get(\n                f\"https://127.0.0.1:{port}/sni\",\n                server_kwargs={\"ssl\": ssl_list},\n            )\n        assert \"Request and response object expected\" in str(exc.value)\n    with replace_server_name(\"sub.foo.sanic.test\"):\n        with pytest.raises(Exception) as exc:\n            _, response = app.test_client.get(\n                f\"https://127.0.0.1:{port}/sni\",\n                server_kwargs={\"ssl\": ssl_list},\n            )\n        assert \"Request and response object expected\" in str(exc.value)",
      "docstring": null,
      "decorators": [
        "pytest.mark.xfail"
      ],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'foo.sanic.test'",
        "assert 'Request and response object expected' in str(exc.value)",
        "assert 'Request and response object expected' in str(exc.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "replace_server_name",
          "body": "@contextmanager\ndef replace_server_name(hostname):\n    \"\"\"Temporarily replace the server name sent with all TLS requests with\n    a fake hostname.\"\"\"\n\n    def hack_wrap_bio(self, incoming, outgoing, server_side=False, server_hostname=None, session=None):\n        return orig_wrap_bio(self, incoming, outgoing, server_side, hostname, session)\n    (orig_wrap_bio, ssl.SSLContext.wrap_bio) = (ssl.SSLContext.wrap_bio, hack_wrap_bio)\n    try:\n        yield\n    finally:\n        ssl.SSLContext.wrap_bio = orig_wrap_bio"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "replace_server_name",
          "body": "@contextmanager\ndef replace_server_name(hostname):\n    \"\"\"Temporarily replace the server name sent with all TLS requests with\n    a fake hostname.\"\"\"\n\n    def hack_wrap_bio(self, incoming, outgoing, server_side=False, server_hostname=None, session=None):\n        return orig_wrap_bio(self, incoming, outgoing, server_side, hostname, session)\n    (orig_wrap_bio, ssl.SSLContext.wrap_bio) = (ssl.SSLContext.wrap_bio, hack_wrap_bio)\n    try:\n        yield\n    finally:\n        ssl.SSLContext.wrap_bio = orig_wrap_bio"
        },
        {
          "name": "replace_server_name",
          "body": "@contextmanager\ndef replace_server_name(hostname):\n    \"\"\"Temporarily replace the server name sent with all TLS requests with\n    a fake hostname.\"\"\"\n\n    def hack_wrap_bio(self, incoming, outgoing, server_side=False, server_hostname=None, session=None):\n        return orig_wrap_bio(self, incoming, outgoing, server_side, hostname, session)\n    (orig_wrap_bio, ssl.SSLContext.wrap_bio) = (ssl.SSLContext.wrap_bio, hack_wrap_bio)\n    try:\n        yield\n    finally:\n        ssl.SSLContext.wrap_bio = orig_wrap_bio"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_invalid_ssl_dict",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 351,
      "end_line_number": 361,
      "source_code": "def test_invalid_ssl_dict(app):\n    @app.get(\"/test\")\n    async def handler(request):\n        return text(\"ssl test\")\n\n    ssl_dict = {\"cert\": None, \"key\": None}\n\n    with pytest.raises(ValueError) as excinfo:\n        app.test_client.get(\"/test\", server_kwargs={\"ssl\": ssl_dict})\n\n    assert str(excinfo.value) == \"SSL dict needs filenames for cert and key.\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert str(excinfo.value) == 'SSL dict needs filenames for cert and key.'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_invalid_ssl_type",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 364,
      "end_line_number": 372,
      "source_code": "def test_invalid_ssl_type(app):\n    @app.get(\"/test\")\n    async def handler(request):\n        return text(\"ssl test\")\n\n    with pytest.raises(ValueError) as excinfo:\n        app.test_client.get(\"/test\", server_kwargs={\"ssl\": False})\n\n    assert \"Invalid ssl argument\" in str(excinfo.value)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'Invalid ssl argument' in str(excinfo.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_cert_file_on_pathlist",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 375,
      "end_line_number": 386,
      "source_code": "def test_cert_file_on_pathlist(app):\n    @app.get(\"/test\")\n    async def handler(request):\n        return text(\"ssl test\")\n\n    ssl_list = [sanic_cert]\n\n    with pytest.raises(ValueError) as excinfo:\n        app.test_client.get(\"/test\", server_kwargs={\"ssl\": ssl_list})\n\n    assert \"folder expected\" in str(excinfo.value)\n    assert sanic_cert in str(excinfo.value)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'folder expected' in str(excinfo.value)",
        "assert sanic_cert in str(excinfo.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_missing_cert_path",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 389,
      "end_line_number": 400,
      "source_code": "def test_missing_cert_path(app):\n    @app.get(\"/test\")\n    async def handler(request):\n        return text(\"ssl test\")\n\n    ssl_list = [invalid_dir]\n\n    with pytest.raises(ValueError) as excinfo:\n        app.test_client.get(\"/test\", server_kwargs={\"ssl\": ssl_list})\n\n    assert \"not found\" in str(excinfo.value)\n    assert invalid_dir + \"/privkey.pem\" in str(excinfo.value)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'not found' in str(excinfo.value)",
        "assert invalid_dir + '/privkey.pem' in str(excinfo.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_missing_cert_file",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 403,
      "end_line_number": 415,
      "source_code": "def test_missing_cert_file(app):\n    @app.get(\"/test\")\n    async def handler(request):\n        return text(\"ssl test\")\n\n    invalid2 = invalid_dir.replace(\"nonexist\", \"certmissing\")\n    ssl_list = [invalid2]\n\n    with pytest.raises(ValueError) as excinfo:\n        app.test_client.get(\"/test\", server_kwargs={\"ssl\": ssl_list})\n\n    assert \"not found\" in str(excinfo.value)\n    assert invalid2 + \"/fullchain.pem\" in str(excinfo.value)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'not found' in str(excinfo.value)",
        "assert invalid2 + '/fullchain.pem' in str(excinfo.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_no_certs_on_list",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 418,
      "end_line_number": 428,
      "source_code": "def test_no_certs_on_list(app):\n    @app.get(\"/test\")\n    async def handler(request):\n        return text(\"ssl test\")\n\n    ssl_list = [None]\n\n    with pytest.raises(ValueError) as excinfo:\n        app.test_client.get(\"/test\", server_kwargs={\"ssl\": ssl_list})\n\n    assert \"No certificates\" in str(excinfo.value)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'No certificates' in str(excinfo.value)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_custom_cert_loader",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 431,
      "end_line_number": 451,
      "source_code": "def test_custom_cert_loader():\n    class MyCertLoader(CertLoader):\n        def load(self, app: Sanic):\n            self._ssl_data = {\n                \"key\": localhost_key,\n                \"cert\": localhost_cert,\n            }\n            return super().load(app)\n\n    app = Sanic(\"custom\", certloader_class=MyCertLoader)\n\n    @app.get(\"/test\")\n    async def handler(request):\n        return text(\"ssl test\")\n\n    client = SanicTestClient(app, port=44556)\n\n    request, response = client.get(\"https://localhost:44556/test\")\n    assert request.scheme == \"https\"\n    assert response.status_code == 200\n    assert response.text == \"ssl test\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.scheme == 'https'",
        "assert response.status_code == 200",
        "assert response.text == 'ssl test'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_logger_vhosts",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 454,
      "end_line_number": 479,
      "source_code": "def test_logger_vhosts(caplog):\n    app = Sanic(name=\"test_logger_vhosts\")\n\n    @app.after_server_start\n    def stop(*args):\n        app.stop()\n\n    with caplog.at_level(logging.INFO):\n        app.run(\n            host=\"127.0.0.1\",\n            port=42102,\n            ssl=[localhost_dir, sanic_dir],\n            single_process=True,\n        )\n\n    logmsg = [\n        msg\n        for name, levelno, msg in caplog.record_tuples\n        if (msg.startswith(\"Certificate\"))\n    ][0]\n\n    assert logmsg == (\n        \"Certificate vhosts: localhost, 127.0.0.1, 0:0:0:0:0:0:0:1, \"\n        \"sanic.example, www.sanic.example, *.sanic.test, \"\n        \"2001:DB8:0:0:0:0:0:541C\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "caplog"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert logmsg == 'Certificate vhosts: localhost, 127.0.0.1, 0:0:0:0:0:0:0:1, sanic.example, www.sanic.example, *.sanic.test, 2001:DB8:0:0:0:0:0:541C'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        },
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ]
    },
    {
      "name": "test_mk_cert_creator_default",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 482,
      "end_line_number": 485,
      "source_code": "def test_mk_cert_creator_default(app: Sanic):\n    cert_creator = MkcertCreator(app, _default, _default)\n    assert isinstance(cert_creator.tmpdir, Path)\n    assert cert_creator.tmpdir.exists()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(cert_creator.tmpdir, Path)",
        "assert cert_creator.tmpdir.exists()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_mk_cert_creator_is_supported",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 488,
      "end_line_number": 497,
      "source_code": "def test_mk_cert_creator_is_supported(app):\n    cert_creator = MkcertCreator(app, _default, _default)\n    with patch(\"subprocess.run\") as run:\n        cert_creator.check_supported()\n        run.assert_called_once_with(\n            [\"mkcert\", \"-help\"],\n            check=True,\n            stderr=subprocess.DEVNULL,\n            stdout=subprocess.DEVNULL,\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "cert_creator.check_supported",
          "body": "def check_supported(self):\n    if not self.SUPPORTED:\n        raise SanicException('Nope')"
        }
      ]
    },
    {
      "name": "test_mk_cert_creator_is_not_supported",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 500,
      "end_line_number": 507,
      "source_code": "def test_mk_cert_creator_is_not_supported(app):\n    cert_creator = MkcertCreator(app, _default, _default)\n    with patch(\"subprocess.run\") as run:\n        run.side_effect = Exception(\"\")\n        with pytest.raises(\n            SanicException, match=\"Sanic is attempting to use mkcert\"\n        ):\n            cert_creator.check_supported()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "cert_creator.check_supported",
          "body": "def check_supported(self):\n    if not self.SUPPORTED:\n        raise SanicException('Nope')"
        }
      ]
    },
    {
      "name": "test_mk_cert_creator_generate_cert_default",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 510,
      "end_line_number": 518,
      "source_code": "def test_mk_cert_creator_generate_cert_default(app):\n    cert_creator = MkcertCreator(app, _default, _default)\n    with patch(\"subprocess.run\") as run:\n        with patch(\"sanic.http.tls.creators.CertSimple\"):\n            retval = Mock()\n            retval.stdout = \"foo\"\n            run.return_value = retval\n            cert_creator.generate_cert(\"localhost\")\n            run.assert_called_once()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ]
    },
    {
      "name": "test_mk_cert_creator_generate_cert_localhost",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 521,
      "end_line_number": 526,
      "source_code": "def test_mk_cert_creator_generate_cert_localhost(app):\n    cert_creator = MkcertCreator(app, localhost_key, localhost_cert)\n    with patch(\"subprocess.run\") as run:\n        with patch(\"sanic.http.tls.creators.CertSimple\"):\n            cert_creator.generate_cert(\"localhost\")\n            run.assert_not_called()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ]
    },
    {
      "name": "test_trustme_creator_default",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 529,
      "end_line_number": 532,
      "source_code": "def test_trustme_creator_default(app: Sanic):\n    cert_creator = TrustmeCreator(app, _default, _default)\n    assert isinstance(cert_creator.tmpdir, Path)\n    assert cert_creator.tmpdir.exists()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(cert_creator.tmpdir, Path)",
        "assert cert_creator.tmpdir.exists()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_trustme_creator_is_supported",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 535,
      "end_line_number": 538,
      "source_code": "def test_trustme_creator_is_supported(app, monkeypatch):\n    monkeypatch.setattr(sanic.http.tls.creators, \"TRUSTME_INSTALLED\", True)\n    cert_creator = TrustmeCreator(app, _default, _default)\n    cert_creator.check_supported()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "monkeypatch"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "cert_creator.check_supported",
          "body": "def check_supported(self):\n    if not self.SUPPORTED:\n        raise SanicException('Nope')"
        }
      ]
    },
    {
      "name": "test_trustme_creator_is_not_supported",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 541,
      "end_line_number": 547,
      "source_code": "def test_trustme_creator_is_not_supported(app, monkeypatch):\n    monkeypatch.setattr(sanic.http.tls.creators, \"TRUSTME_INSTALLED\", False)\n    cert_creator = TrustmeCreator(app, _default, _default)\n    with pytest.raises(\n        SanicException, match=\"Sanic is attempting to use trustme\"\n    ):\n        cert_creator.check_supported()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "monkeypatch"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "cert_creator.check_supported",
          "body": "def check_supported(self):\n    if not self.SUPPORTED:\n        raise SanicException('Nope')"
        }
      ]
    },
    {
      "name": "test_trustme_creator_generate_cert_default",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 550,
      "end_line_number": 564,
      "source_code": "def test_trustme_creator_generate_cert_default(\n    app, monkeypatch, trustme, issue_cert, server_cert, ca\n):\n    monkeypatch.setattr(sanic.http.tls.creators, \"trustme\", trustme)\n    cert_creator = TrustmeCreator(app, _default, _default)\n    cert = cert_creator.generate_cert(\"localhost\")\n\n    assert isinstance(cert, SanicSSLContext)\n    trustme.CA.assert_called_once_with()\n    issue_cert.assert_called_once_with(\"localhost\")\n    server_cert.configure_cert.assert_called_once()\n    ca.configure_trust.assert_called_once()\n    ca.cert_pem.write_to_path.assert_called_once_with(str(cert.sanic[\"cert\"]))\n    write_to_path = server_cert.private_key_and_cert_chain_pem.write_to_path\n    write_to_path.assert_called_once_with(str(cert.sanic[\"key\"]))",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "monkeypatch",
        "trustme",
        "issue_cert",
        "server_cert",
        "ca"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(cert, SanicSSLContext)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_trustme_creator_generate_cert_localhost",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 567,
      "end_line_number": 576,
      "source_code": "def test_trustme_creator_generate_cert_localhost(\n    app, monkeypatch, trustme, server_cert, ca\n):\n    monkeypatch.setattr(sanic.http.tls.creators, \"trustme\", trustme)\n    cert_creator = TrustmeCreator(app, localhost_key, localhost_cert)\n    cert_creator.generate_cert(\"localhost\")\n\n    ca.cert_pem.write_to_path.assert_called_once_with(localhost_cert)\n    write_to_path = server_cert.private_key_and_cert_chain_pem.write_to_path\n    write_to_path.assert_called_once_with(localhost_key)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "monkeypatch",
        "trustme",
        "server_cert",
        "ca"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_get_ssl_context_with_ssl_context",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 579,
      "end_line_number": 582,
      "source_code": "def test_get_ssl_context_with_ssl_context(app):\n    mock_context = Mock()\n    context = get_ssl_context(app, mock_context)\n    assert context is mock_context",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert context is mock_context"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_get_ssl_context_in_production",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 585,
      "end_line_number": 591,
      "source_code": "def test_get_ssl_context_in_production(app):\n    app.state.mode = Mode.PRODUCTION\n    with pytest.raises(\n        SanicException,\n        match=\"Cannot run Sanic as an HTTPS server in PRODUCTION mode\",\n    ):\n        get_ssl_context(app, None)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_get_ssl_context_only_mkcert",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 618,
      "end_line_number": 654,
      "source_code": "def test_get_ssl_context_only_mkcert(\n    app,\n    monkeypatch,\n    MockMkcertCreator,\n    MockTrustmeCreator,\n    requirement,\n    mk_supported,\n    trustme_supported,\n    mk_called,\n    trustme_called,\n    err,\n):\n    app.state.mode = Mode.DEBUG\n    app.config.LOCAL_CERT_CREATOR = requirement\n    monkeypatch.setattr(\n        sanic.http.tls.creators, \"MkcertCreator\", MockMkcertCreator\n    )\n    monkeypatch.setattr(\n        sanic.http.tls.creators, \"TrustmeCreator\", MockTrustmeCreator\n    )\n    MockMkcertCreator.SUPPORTED = mk_supported\n    MockTrustmeCreator.SUPPORTED = trustme_supported\n\n    if err:\n        with pytest.raises(SanicException, match=err):\n            get_ssl_context(app, None)\n    else:\n        get_ssl_context(app, None)\n\n    if mk_called:\n        MockMkcertCreator.generate_cert.assert_called_once_with(\"localhost\")\n    else:\n        MockMkcertCreator.generate_cert.assert_not_called()\n    if trustme_called:\n        MockTrustmeCreator.generate_cert.assert_called_once_with(\"localhost\")\n    else:\n        MockTrustmeCreator.generate_cert.assert_not_called()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('requirement,mk_supported,trustme_supported,mk_called,trustme_called,err', ((LocalCertCreator.AUTO, True, False, True, False, None), (LocalCertCreator.AUTO, True, True, True, False, None), (LocalCertCreator.AUTO, False, True, False, True, None), (LocalCertCreator.AUTO, False, False, False, False, 'Sanic could not find package to create a TLS certificate'), (LocalCertCreator.MKCERT, True, False, True, False, None), (LocalCertCreator.MKCERT, True, True, True, False, None), (LocalCertCreator.MKCERT, False, True, False, False, 'Nope'), (LocalCertCreator.MKCERT, False, False, False, False, 'Nope'), (LocalCertCreator.TRUSTME, True, False, False, False, 'Nope'), (LocalCertCreator.TRUSTME, True, True, False, True, None), (LocalCertCreator.TRUSTME, False, True, False, True, None), (LocalCertCreator.TRUSTME, False, False, False, False, 'Nope')))"
      ],
      "arguments": [
        "app",
        "monkeypatch",
        "MockMkcertCreator",
        "MockTrustmeCreator",
        "requirement",
        "mk_supported",
        "trustme_supported",
        "mk_called",
        "trustme_called",
        "err"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_sanic_ssl_context_create",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 677,
      "end_line_number": 682,
      "source_code": "def test_sanic_ssl_context_create():\n    context = ssl.SSLContext()\n    sanic_context = SanicSSLContext.create_from_ssl_context(context)\n\n    assert sanic_context is context\n    assert isinstance(sanic_context, SanicSSLContext)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert sanic_context is context",
        "assert isinstance(sanic_context, SanicSSLContext)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_ssl_in_multiprocess_mode",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 689,
      "end_line_number": 712,
      "source_code": "def test_ssl_in_multiprocess_mode(app: Sanic, caplog):\n    ssl_dict = {\"cert\": localhost_cert, \"key\": localhost_key}\n    event = Event()\n\n    @app.main_process_start\n    async def main_start(app: Sanic):\n        app.shared_ctx.event = event\n\n    @app.after_server_start\n    async def shutdown(app):\n        app.shared_ctx.event.set()\n        app.stop()\n\n    assert not event.is_set()\n    with use_context(\"fork\"):\n        with caplog.at_level(logging.INFO):\n            app.run(ssl=ssl_dict)\n    assert event.is_set()\n\n    assert (\n        \"sanic.root\",\n        logging.INFO,\n        \"Goin' Fast @ https://127.0.0.1:8000\",\n    ) in caplog.record_tuples",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(sys.platform not in ('linux', 'darwin'), reason='This test requires fork context')"
      ],
      "arguments": [
        "app",
        "caplog"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert not event.is_set()",
        "assert event.is_set()",
        "assert ('sanic.root', logging.INFO, \"Goin' Fast @ https://127.0.0.1:8000\") in caplog.record_tuples"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        },
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ]
    },
    {
      "name": "test_ssl_in_multiprocess_mode_password",
      "module": "test_tls",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_tls.py",
      "line_number": 719,
      "end_line_number": 743,
      "source_code": "def test_ssl_in_multiprocess_mode_password(\n    app: Sanic, caplog: pytest.LogCaptureFixture\n):\n    event = Event()\n\n    @app.main_process_start\n    async def main_start(app: Sanic):\n        app.shared_ctx.event = event\n\n    @app.after_server_start\n    async def shutdown(app):\n        app.shared_ctx.event.set()\n        app.stop()\n\n    assert not event.is_set()\n    with use_context(\"fork\"):\n        with caplog.at_level(logging.INFO):\n            app.run(ssl=password_dict)\n    assert event.is_set()\n\n    assert (\n        \"sanic.root\",\n        logging.INFO,\n        \"Goin' Fast @ https://127.0.0.1:8000\",\n    ) in caplog.record_tuples",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(sys.platform not in ('linux', 'darwin'), reason='This test requires fork context')"
      ],
      "arguments": [
        "app",
        "caplog"
      ],
      "imports": [
        "logging",
        "os",
        "ssl",
        "subprocess",
        "sys",
        "contextlib.contextmanager",
        "multiprocessing.Event",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.parse.urlparse",
        "pytest",
        "sanic_testing.testing.HOST",
        "sanic_testing.testing.PORT",
        "sanic_testing.testing.SanicTestClient",
        "sanic.http.tls.creators",
        "sanic.Sanic",
        "sanic.application.constants.Mode",
        "sanic.compat.use_context",
        "sanic.constants.LocalCertCreator",
        "sanic.exceptions.SanicException",
        "sanic.helpers._default",
        "sanic.http.tls.context.SanicSSLContext",
        "sanic.http.tls.creators.MkcertCreator",
        "sanic.http.tls.creators.TrustmeCreator",
        "sanic.http.tls.creators.get_ssl_context",
        "sanic.response.text",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert not event.is_set()",
        "assert event.is_set()",
        "assert ('sanic.root', logging.INFO, \"Goin' Fast @ https://127.0.0.1:8000\") in caplog.record_tuples"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        },
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ]
    },
    {
      "name": "test_should_return_html_valid_setting",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 85,
      "end_line_number": 108,
      "source_code": "def test_should_return_html_valid_setting(\n    fake_request, fallback, content_type, exception, status\n):\n    # Note: if fallback is None or \"auto\", prior to PR #2668 base was returned\n    # and after that a text response is given because it matches */*. Changed\n    # base to TextRenderer in this test, like it is in Sanic itself, so the\n    # test passes with either version but still covers everything that it did.\n    if fallback:\n        fake_request.app.config.FALLBACK_ERROR_FORMAT = fallback\n\n    try:\n        raise exception(\"bad stuff\")\n    except Exception as e:\n        response = exception_response(\n            fake_request,\n            e,\n            True,\n            base=TextRenderer,\n            fallback=fake_request.app.config.FALLBACK_ERROR_FORMAT,\n        )\n\n    assert isinstance(response, HTTPResponse)\n    assert response.status == status\n    assert response.content_type == content_type",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('fallback,content_type, exception, status', ((None, 'text/plain; charset=utf-8', Exception, 500), ('html', 'text/html; charset=utf-8', Exception, 500), ('auto', 'text/plain; charset=utf-8', Exception, 500), ('text', 'text/plain; charset=utf-8', Exception, 500), ('json', 'application/json', Exception, 500), (None, 'text/plain; charset=utf-8', NotFound, 404), ('html', 'text/html; charset=utf-8', NotFound, 404), ('auto', 'text/plain; charset=utf-8', NotFound, 404), ('text', 'text/plain; charset=utf-8', NotFound, 404), ('json', 'application/json', NotFound, 404)))"
      ],
      "arguments": [
        "fake_request",
        "fallback",
        "content_type",
        "exception",
        "status"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(response, HTTPResponse)",
        "assert response.status == status",
        "assert response.content_type == content_type"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception",
          "body": "@app.route('/')\ndef exception(request):\n    raise SanicExceptionTestException(\"You won't see me\")"
        }
      ]
    },
    {
      "name": "test_auto_fallback_with_data",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 111,
      "end_line_number": 124,
      "source_code": "def test_auto_fallback_with_data(app):\n    app.config.FALLBACK_ERROR_FORMAT = \"auto\"\n\n    _, response = app.test_client.get(\"/error\")\n    assert response.status == 500\n    assert response.content_type == \"text/plain; charset=utf-8\"\n\n    _, response = app.test_client.post(\"/error\", json={\"foo\": \"bar\"})\n    assert response.status == 500\n    assert response.content_type == \"application/json\"\n\n    _, response = app.test_client.post(\"/error\", data={\"foo\": \"bar\"})\n    assert response.status == 500\n    assert response.content_type == \"text/plain; charset=utf-8\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert response.content_type == 'text/plain; charset=utf-8'",
        "assert response.status == 500",
        "assert response.content_type == 'application/json'",
        "assert response.status == 500",
        "assert response.content_type == 'text/plain; charset=utf-8'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_auto_fallback_with_content_type",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 127,
      "end_line_number": 140,
      "source_code": "def test_auto_fallback_with_content_type(app):\n    app.config.FALLBACK_ERROR_FORMAT = \"auto\"\n\n    _, response = app.test_client.get(\n        \"/error\", headers={\"content-type\": \"application/json\", \"accept\": \"*/*\"}\n    )\n    assert response.status == 500\n    assert response.content_type == \"application/json\"\n\n    _, response = app.test_client.get(\n        \"/error\", headers={\"content-type\": \"foo/bar\", \"accept\": \"*/*\"}\n    )\n    assert response.status == 500\n    assert response.content_type == \"text/plain; charset=utf-8\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert response.content_type == 'application/json'",
        "assert response.status == 500",
        "assert response.content_type == 'text/plain; charset=utf-8'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_route_error_format_set_on_auto",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 143,
      "end_line_number": 163,
      "source_code": "def test_route_error_format_set_on_auto(app):\n    @app.get(\"/text\")\n    def text_response(request):\n        return text(request.route.extra.error_format)\n\n    @app.get(\"/json\")\n    def json_response(request):\n        return json({\"format\": request.route.extra.error_format})\n\n    @app.get(\"/html\")\n    def html_response(request):\n        return html(request.route.extra.error_format)\n\n    _, response = app.test_client.get(\"/text\")\n    assert response.text == \"text\"\n\n    _, response = app.test_client.get(\"/json\")\n    assert response.json[\"format\"] == \"json\"\n\n    _, response = app.test_client.get(\"/html\")\n    assert response.text == \"html\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'text'",
        "assert response.json['format'] == 'json'",
        "assert response.text == 'html'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_route_error_response_from_auto_route",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 166,
      "end_line_number": 189,
      "source_code": "def test_route_error_response_from_auto_route(app):\n    @app.get(\"/text\")\n    def text_response(request):\n        raise Exception(\"oops\")\n        return text(\"Never gonna see this\")\n\n    @app.get(\"/json\")\n    def json_response(request):\n        raise Exception(\"oops\")\n        return json({\"message\": \"Never gonna see this\"})\n\n    @app.get(\"/html\")\n    def html_response(request):\n        raise Exception(\"oops\")\n        return html(\"<h1>Never gonna see this</h1>\")\n\n    _, response = app.test_client.get(\"/text\")\n    assert response.content_type == \"text/plain; charset=utf-8\"\n\n    _, response = app.test_client.get(\"/json\")\n    assert response.content_type == \"application/json\"\n\n    _, response = app.test_client.get(\"/html\")\n    assert response.content_type == \"text/html; charset=utf-8\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.content_type == 'text/plain; charset=utf-8'",
        "assert response.content_type == 'application/json'",
        "assert response.content_type == 'text/html; charset=utf-8'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_route_error_response_from_explicit_format",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 192,
      "end_line_number": 207,
      "source_code": "def test_route_error_response_from_explicit_format(app):\n    @app.get(\"/text\", error_format=\"json\")\n    def text_response(request):\n        raise Exception(\"oops\")\n        return text(\"Never gonna see this\")\n\n    @app.get(\"/json\", error_format=\"text\")\n    def json_response(request):\n        raise Exception(\"oops\")\n        return json({\"message\": \"Never gonna see this\"})\n\n    _, response = app.test_client.get(\"/text\")\n    assert response.content_type == \"application/json\"\n\n    _, response = app.test_client.get(\"/json\")\n    assert response.content_type == \"text/plain; charset=utf-8\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.content_type == 'application/json'",
        "assert response.content_type == 'text/plain; charset=utf-8'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_blueprint_error_response_from_explicit_format",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 210,
      "end_line_number": 228,
      "source_code": "def test_blueprint_error_response_from_explicit_format(app):\n    bp = sanic.Blueprint(\"MyBlueprint\")\n\n    @bp.get(\"/text\", error_format=\"json\")\n    def text_response(request):\n        raise Exception(\"oops\")\n        return text(\"Never gonna see this\")\n\n    @bp.get(\"/json\", error_format=\"text\")\n    def json_response(request):\n        raise Exception(\"oops\")\n        return json({\"message\": \"Never gonna see this\"})\n\n    app.blueprint(bp)\n    _, response = app.test_client.get(\"/text\")\n    assert response.content_type == \"application/json\"\n\n    _, response = app.test_client.get(\"/json\")\n    assert response.content_type == \"text/plain; charset=utf-8\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.content_type == 'application/json'",
        "assert response.content_type == 'text/plain; charset=utf-8'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "bp.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_unknown_fallback_format",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 231,
      "end_line_number": 233,
      "source_code": "def test_unknown_fallback_format(app):\n    with pytest.raises(SanicException, match=\"Unknown format: bad\"):\n        app.config.FALLBACK_ERROR_FORMAT = \"bad\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_route_error_format_unknown",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 236,
      "end_line_number": 240,
      "source_code": "def test_route_error_format_unknown(app):\n    with pytest.raises(SanicException, match=\"Unknown format: bad\"):\n\n        @app.get(\"/text\", error_format=\"bad\")\n        def handler(request): ...",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_fallback_with_content_type_html",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 243,
      "end_line_number": 251,
      "source_code": "def test_fallback_with_content_type_html(app):\n    app.config.FALLBACK_ERROR_FORMAT = \"auto\"\n\n    _, response = app.test_client.get(\n        \"/error\",\n        headers={\"content-type\": \"application/json\", \"accept\": \"text/html\"},\n    )\n    assert response.status == 500\n    assert response.content_type == \"text/html; charset=utf-8\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert response.content_type == 'text/html; charset=utf-8'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_fallback_with_content_type_mismatch_accept",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 254,
      "end_line_number": 321,
      "source_code": "def test_fallback_with_content_type_mismatch_accept(app):\n    app.config.FALLBACK_ERROR_FORMAT = \"auto\"\n\n    _, response = app.test_client.get(\n        \"/error\",\n        headers={\"content-type\": \"application/json\", \"accept\": \"text/plain\"},\n    )\n    assert response.status == 500\n    assert response.content_type == \"text/plain; charset=utf-8\"\n\n    _, response = app.test_client.get(\n        \"/error\",\n        headers={\"content-type\": \"text/html\", \"accept\": \"foo/bar\"},\n    )\n    assert response.status == 500\n    assert response.content_type == \"text/plain; charset=utf-8\"\n\n    app.router.reset()\n\n    @app.route(\"/alt1\", name=\"alt1\")\n    @app.route(\"/alt2\", error_format=\"text\", name=\"alt2\")\n    @app.route(\"/alt3\", error_format=\"html\", name=\"alt3\")\n    def handler(_):\n        raise Exception(\"problem here\")\n        # Yes, we know this return value is unreachable. This is on purpose.\n        return json({})\n\n    app.router.finalize()\n\n    _, response = app.test_client.get(\n        \"/alt1\",\n        headers={\"accept\": \"foo/bar\"},\n    )\n    assert response.status == 500\n    assert response.content_type == \"text/plain; charset=utf-8\"\n    _, response = app.test_client.get(\n        \"/alt1\",\n        headers={\"accept\": \"foo/bar,*/*\"},\n    )\n    assert response.status == 500\n    assert response.content_type == \"application/json\"\n\n    _, response = app.test_client.get(\n        \"/alt2\",\n        headers={\"accept\": \"foo/bar\"},\n    )\n    assert response.status == 500\n    assert response.content_type == \"text/plain; charset=utf-8\"\n    _, response = app.test_client.get(\n        \"/alt2\",\n        headers={\"accept\": \"foo/bar,*/*\"},\n    )\n    assert response.status == 500\n    assert response.content_type == \"text/plain; charset=utf-8\"\n\n    _, response = app.test_client.get(\n        \"/alt3\",\n        headers={\"accept\": \"foo/bar\"},\n    )\n    assert response.status == 500\n    assert response.content_type == \"text/plain; charset=utf-8\"\n\n    _, response = app.test_client.get(\n        \"/alt3\",\n        headers={\"accept\": \"foo/bar,text/html\"},\n    )\n    assert response.status == 500\n    assert response.content_type == \"text/html; charset=utf-8\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert response.content_type == 'text/plain; charset=utf-8'",
        "assert response.status == 500",
        "assert response.content_type == 'text/plain; charset=utf-8'",
        "assert response.status == 500",
        "assert response.content_type == 'text/plain; charset=utf-8'",
        "assert response.status == 500",
        "assert response.content_type == 'application/json'",
        "assert response.status == 500",
        "assert response.content_type == 'text/plain; charset=utf-8'",
        "assert response.status == 500",
        "assert response.content_type == 'text/plain; charset=utf-8'",
        "assert response.status == 500",
        "assert response.content_type == 'text/plain; charset=utf-8'",
        "assert response.status == 500",
        "assert response.content_type == 'text/html; charset=utf-8'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.router.reset",
          "body": "@pytest.fixture(autouse=True)\ndef reset():\n    try:\n        del os.environ['SANIC_MOTD_OUTPUT']\n    except KeyError:\n        ..."
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_combinations_for_auto",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 340,
      "end_line_number": 360,
      "source_code": "def test_combinations_for_auto(fake_request, accept, content_type, expected):\n    if accept:\n        fake_request.headers[\"accept\"] = accept\n    else:\n        del fake_request.headers[\"accept\"]\n\n    if content_type:\n        fake_request.headers[\"content-type\"] = content_type\n\n    try:\n        raise Exception(\"bad stuff\")\n    except Exception as e:\n        response = exception_response(\n            fake_request,\n            e,\n            True,\n            base=TextRenderer,\n            fallback=\"auto\",\n        )\n\n    assert response.content_type == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('accept,content_type,expected', ((None, None, 'text/plain; charset=utf-8'), ('foo/bar', None, 'text/plain; charset=utf-8'), ('application/json', None, 'application/json'), ('application/json,text/plain', None, 'application/json'), ('text/plain,application/json', None, 'application/json'), ('text/plain,foo/bar', None, 'text/plain; charset=utf-8'), ('text/plain,text/html', None, 'text/plain; charset=utf-8'), ('*/*', 'foo/bar', 'text/plain; charset=utf-8'), ('*/*', 'application/json', 'application/json'), ('text/*,*/plain', None, 'text/plain; charset=utf-8')))"
      ],
      "arguments": [
        "fake_request",
        "accept",
        "content_type",
        "expected"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.content_type == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_allow_fallback_error_format_set_main_process_start",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 363,
      "end_line_number": 370,
      "source_code": "def test_allow_fallback_error_format_set_main_process_start(app):\n    @app.main_process_start\n    async def start(app, _):\n        app.config.FALLBACK_ERROR_FORMAT = \"text\"\n\n    _, response = app.test_client.get(\"/error\")\n    assert response.status == 500\n    assert response.content_type == \"text/plain; charset=utf-8\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert response.content_type == 'text/plain; charset=utf-8'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_setting_fallback_on_config_changes_as_expected",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 373,
      "end_line_number": 385,
      "source_code": "def test_setting_fallback_on_config_changes_as_expected(app):\n    app.error_handler = ErrorHandler()\n\n    _, response = app.test_client.get(\"/error\")\n    assert response.content_type == \"text/plain; charset=utf-8\"\n\n    app.config.FALLBACK_ERROR_FORMAT = \"html\"\n    _, response = app.test_client.get(\"/error\")\n    assert response.content_type == \"text/html; charset=utf-8\"\n\n    app.config.FALLBACK_ERROR_FORMAT = \"text\"\n    _, response = app.test_client.get(\"/error\")\n    assert response.content_type == \"text/plain; charset=utf-8\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.content_type == 'text/plain; charset=utf-8'",
        "assert response.content_type == 'text/html; charset=utf-8'",
        "assert response.content_type == 'text/plain; charset=utf-8'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_allow_fallback_error_format_in_config_injection",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 388,
      "end_line_number": 400,
      "source_code": "def test_allow_fallback_error_format_in_config_injection():\n    class MyConfig(Config):\n        FALLBACK_ERROR_FORMAT = \"text\"\n\n    app = Sanic(\"test\", config=MyConfig())\n\n    @app.route(\"/error\", methods=[\"GET\", \"POST\"])\n    def err(request):\n        raise Exception(\"something went wrong\")\n\n    request, response = app.test_client.get(\"/error\")\n    assert response.status == 500\n    assert response.content_type == \"text/plain; charset=utf-8\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert response.content_type == 'text/plain; charset=utf-8'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_allow_fallback_error_format_in_config_replacement",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 403,
      "end_line_number": 411,
      "source_code": "def test_allow_fallback_error_format_in_config_replacement(app):\n    class MyConfig(Config):\n        FALLBACK_ERROR_FORMAT = \"text\"\n\n    app.config = MyConfig()\n\n    request, response = app.test_client.get(\"/error\")\n    assert response.status == 500\n    assert response.content_type == \"text/plain; charset=utf-8\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert response.content_type == 'text/plain; charset=utf-8'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_config_fallback_before_and_after_startup",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 414,
      "end_line_number": 423,
      "source_code": "def test_config_fallback_before_and_after_startup(app):\n    app.config.FALLBACK_ERROR_FORMAT = \"json\"\n\n    @app.main_process_start\n    async def start(app, _):\n        app.config.FALLBACK_ERROR_FORMAT = \"text\"\n\n    _, response = app.test_client.get(\"/error\")\n    assert response.status == 500\n    assert response.content_type == \"application/json\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert response.content_type == 'application/json'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_config_fallback_using_update_dict",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 426,
      "end_line_number": 431,
      "source_code": "def test_config_fallback_using_update_dict(app):\n    app.config.update({\"FALLBACK_ERROR_FORMAT\": \"text\"})\n\n    _, response = app.test_client.get(\"/error\")\n    assert response.status == 500\n    assert response.content_type == \"text/plain; charset=utf-8\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert response.content_type == 'text/plain; charset=utf-8'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_config_fallback_using_update_kwarg",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 434,
      "end_line_number": 439,
      "source_code": "def test_config_fallback_using_update_kwarg(app):\n    app.config.update(FALLBACK_ERROR_FORMAT=\"text\")\n\n    _, response = app.test_client.get(\"/error\")\n    assert response.status == 500\n    assert response.content_type == \"text/plain; charset=utf-8\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert response.content_type == 'text/plain; charset=utf-8'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_config_fallback_bad_value",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 442,
      "end_line_number": 445,
      "source_code": "def test_config_fallback_bad_value(app):\n    message = \"Unknown format: fake\"\n    with pytest.raises(SanicException, match=message):\n        app.config.FALLBACK_ERROR_FORMAT = \"fake\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_guess_mime_logging",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 523,
      "end_line_number": 552,
      "source_code": "def test_guess_mime_logging(\n    caplog, fake_request, route_format, fallback, accept, expected\n):\n    class FakeObject:\n        pass\n\n    fake_request.route = FakeObject()\n    fake_request.route.name = \"fakeroute\"\n    fake_request.route.extra = FakeObject()\n    fake_request.route.extra.error_format = route_format\n    if accept is None:\n        del fake_request.headers[\"accept\"]\n    else:\n        fake_request.headers[\"accept\"] = accept\n\n    if \"content-type\" in expected:\n        fake_request.headers[\"content-type\"] = \"application/json\"\n\n    # Fake JSON content (DEPRECATED: remove in 24.3)\n    if \"request.json\" in expected:\n        fake_request.parsed_json = {\"foo\": \"bar\"}\n\n    with caplog.at_level(logging.DEBUG, logger=\"sanic.root\"):\n        guess_mime(fake_request, fallback)\n\n    (logmsg,) = [\n        r.message for r in caplog.records if r.funcName == \"guess_mime\"\n    ]\n\n    assert logmsg == f\"Error Page: {expected}\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('route_format,fallback,accept,expected', (('json', 'html', '*/*', \"The client accepts */*, using 'json' from fakeroute\"), ('json', 'auto', 'text/html,*/*;q=0.8', \"The client accepts text/html, using 'html' from any\"), ('json', 'json', 'text/html,*/*;q=0.8', \"The client accepts */*;q=0.8, using 'json' from fakeroute\"), ('', 'html', 'text/*,*/plain', \"The client accepts text/*, using 'html' from FALLBACK_ERROR_FORMAT\"), ('', 'json', 'text/*,*/*', \"The client accepts */*, using 'json' from FALLBACK_ERROR_FORMAT\"), ('', 'auto', '*/*,application/json;q=0.5', \"The client accepts */*, using 'json' from request.accept\"), ('', 'auto', '*/*', \"The client accepts */*, using 'json' from content-type\"), ('', 'auto', 'text/html,text/plain', \"The client accepts text/plain, using 'text' from any\"), ('', 'auto', 'text/html,text/plain;q=0.9', \"The client accepts text/html, using 'html' from any\"), ('html', 'json', 'application/xml', 'No format found, the client accepts [application/xml]'), ('', 'auto', '*/*', \"The client accepts */*, using 'text' from any\"), ('', '', '*/*', 'No format found, the client accepts [*/*]'), ('', 'auto', '*/*', \"The client accepts */*, using 'json' from request.json\")))"
      ],
      "arguments": [
        "caplog",
        "fake_request",
        "route_format",
        "fallback",
        "accept",
        "expected"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert logmsg == f'Error Page: {expected}'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_exception_header_on_renderers",
      "module": "test_errorpages",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_errorpages.py",
      "line_number": 563,
      "end_line_number": 575,
      "source_code": "def test_exception_header_on_renderers(app: Sanic, format, expected):\n    app.config.FALLBACK_ERROR_FORMAT = format\n\n    @app.get(\"/test\")\n    def test(request):\n        raise SanicException(\n            \"test\", status_code=400, headers={\"exception\": \"test\"}\n        )\n\n    _, response = app.test_client.get(\"/test\")\n    assert response.status == 400\n    assert response.headers.get(\"exception\") == \"test\"\n    assert response.content_type == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('format,expected', (('html', 'text/html; charset=utf-8'), ('text', 'text/plain; charset=utf-8'), ('json', 'application/json')))"
      ],
      "arguments": [
        "app",
        "format",
        "expected"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.config.Config",
        "sanic.errorpages.TextRenderer",
        "sanic.errorpages.exception_response",
        "sanic.errorpages.guess_mime",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.SanicException",
        "sanic.handlers.ErrorHandler",
        "sanic.request.Request",
        "sanic.response.HTTPResponse",
        "sanic.response.empty",
        "sanic.response.html",
        "sanic.response.json",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 400",
        "assert response.headers.get('exception') == 'test'",
        "assert response.content_type == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response.headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_catch_exception_list",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions.py",
      "line_number": 118,
      "end_line_number": 131,
      "source_code": "def test_catch_exception_list(app):\n    @app.exception([SanicExceptionTestException, NotFound])\n    def exception_list(request, exception):\n        return text(\"ok\")\n\n    @app.route(\"/\")\n    def exception(request):\n        raise SanicExceptionTestException(\"You won't see me\")\n\n    request, response = app.test_client.get(\"/random\")\n    assert response.text == \"ok\"\n\n    request, response = app.test_client.get(\"/\")\n    assert response.text == \"ok\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "itertools.count",
        "pytest",
        "bs4.BeautifulSoup",
        "sanic.Sanic",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ContentRangeError",
        "sanic.exceptions.ExpectationFailed",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.HeaderExpectationFailed",
        "sanic.exceptions.InvalidUsage",
        "sanic.exceptions.MethodNotAllowed",
        "sanic.exceptions.MethodNotSupported",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.RangeNotSatisfiable",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.exceptions.Unauthorized",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.text == 'ok'",
        "assert response.text == 'ok'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.exception",
          "body": "@app.route('/')\ndef exception(request):\n    raise SanicExceptionTestException(\"You won't see me\")"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_no_exception",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions.py",
      "line_number": 134,
      "end_line_number": 138,
      "source_code": "def test_no_exception(exception_app):\n    \"\"\"Test that a route works without an exception\"\"\"\n    request, response = exception_app.test_client.get(\"/\")\n    assert response.status == 200\n    assert response.text == \"OK\"",
      "docstring": "Test that a route works without an exception",
      "decorators": [],
      "arguments": [
        "exception_app"
      ],
      "imports": [
        "logging",
        "itertools.count",
        "pytest",
        "bs4.BeautifulSoup",
        "sanic.Sanic",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ContentRangeError",
        "sanic.exceptions.ExpectationFailed",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.HeaderExpectationFailed",
        "sanic.exceptions.InvalidUsage",
        "sanic.exceptions.MethodNotAllowed",
        "sanic.exceptions.MethodNotSupported",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.RangeNotSatisfiable",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.exceptions.Unauthorized",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'OK'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_server_error_exception",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions.py",
      "line_number": 141,
      "end_line_number": 144,
      "source_code": "def test_server_error_exception(exception_app):\n    \"\"\"Test the built-in ServerError exception works\"\"\"\n    request, response = exception_app.test_client.get(\"/error\")\n    assert response.status == 500",
      "docstring": "Test the built-in ServerError exception works",
      "decorators": [],
      "arguments": [
        "exception_app"
      ],
      "imports": [
        "logging",
        "itertools.count",
        "pytest",
        "bs4.BeautifulSoup",
        "sanic.Sanic",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ContentRangeError",
        "sanic.exceptions.ExpectationFailed",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.HeaderExpectationFailed",
        "sanic.exceptions.InvalidUsage",
        "sanic.exceptions.MethodNotAllowed",
        "sanic.exceptions.MethodNotSupported",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.RangeNotSatisfiable",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.exceptions.Unauthorized",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_invalid_usage_exception",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions.py",
      "line_number": 147,
      "end_line_number": 150,
      "source_code": "def test_invalid_usage_exception(exception_app):\n    \"\"\"Test the built-in BadRequest exception works\"\"\"\n    request, response = exception_app.test_client.get(\"/invalid\")\n    assert response.status == 400",
      "docstring": "Test the built-in BadRequest exception works",
      "decorators": [],
      "arguments": [
        "exception_app"
      ],
      "imports": [
        "logging",
        "itertools.count",
        "pytest",
        "bs4.BeautifulSoup",
        "sanic.Sanic",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ContentRangeError",
        "sanic.exceptions.ExpectationFailed",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.HeaderExpectationFailed",
        "sanic.exceptions.InvalidUsage",
        "sanic.exceptions.MethodNotAllowed",
        "sanic.exceptions.MethodNotSupported",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.RangeNotSatisfiable",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.exceptions.Unauthorized",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 400"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_not_found_exception",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions.py",
      "line_number": 153,
      "end_line_number": 156,
      "source_code": "def test_not_found_exception(exception_app):\n    \"\"\"Test the built-in NotFound exception works\"\"\"\n    request, response = exception_app.test_client.get(\"/404\")\n    assert response.status == 404",
      "docstring": "Test the built-in NotFound exception works",
      "decorators": [],
      "arguments": [
        "exception_app"
      ],
      "imports": [
        "logging",
        "itertools.count",
        "pytest",
        "bs4.BeautifulSoup",
        "sanic.Sanic",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ContentRangeError",
        "sanic.exceptions.ExpectationFailed",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.HeaderExpectationFailed",
        "sanic.exceptions.InvalidUsage",
        "sanic.exceptions.MethodNotAllowed",
        "sanic.exceptions.MethodNotSupported",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.RangeNotSatisfiable",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.exceptions.Unauthorized",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_forbidden_exception",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions.py",
      "line_number": 159,
      "end_line_number": 162,
      "source_code": "def test_forbidden_exception(exception_app):\n    \"\"\"Test the built-in Forbidden exception\"\"\"\n    request, response = exception_app.test_client.get(\"/403\")\n    assert response.status == 403",
      "docstring": "Test the built-in Forbidden exception",
      "decorators": [],
      "arguments": [
        "exception_app"
      ],
      "imports": [
        "logging",
        "itertools.count",
        "pytest",
        "bs4.BeautifulSoup",
        "sanic.Sanic",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ContentRangeError",
        "sanic.exceptions.ExpectationFailed",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.HeaderExpectationFailed",
        "sanic.exceptions.InvalidUsage",
        "sanic.exceptions.MethodNotAllowed",
        "sanic.exceptions.MethodNotSupported",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.RangeNotSatisfiable",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.exceptions.Unauthorized",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 403"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_unauthorized_exception",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions.py",
      "line_number": 165,
      "end_line_number": 188,
      "source_code": "def test_unauthorized_exception(exception_app):\n    \"\"\"Test the built-in Unauthorized exception\"\"\"\n    request, response = exception_app.test_client.get(\"/401\")\n    assert response.status == 401\n\n    request, response = exception_app.test_client.get(\"/401/basic\")\n    assert response.status == 401\n    assert response.headers.get(\"WWW-Authenticate\") is not None\n    assert response.headers.get(\"WWW-Authenticate\") == 'Basic realm=\"Sanic\"'\n\n    request, response = exception_app.test_client.get(\"/401/digest\")\n    assert response.status == 401\n\n    auth_header = response.headers.get(\"WWW-Authenticate\")\n    assert auth_header is not None\n    assert auth_header.startswith(\"Digest\")\n    assert 'qop=\"auth, auth-int\"' in auth_header\n    assert 'algorithm=\"MD5\"' in auth_header\n    assert 'nonce=\"abcdef\"' in auth_header\n    assert 'opaque=\"zyxwvu\"' in auth_header\n\n    request, response = exception_app.test_client.get(\"/401/bearer\")\n    assert response.status == 401\n    assert response.headers.get(\"WWW-Authenticate\") == \"Bearer\"",
      "docstring": "Test the built-in Unauthorized exception",
      "decorators": [],
      "arguments": [
        "exception_app"
      ],
      "imports": [
        "logging",
        "itertools.count",
        "pytest",
        "bs4.BeautifulSoup",
        "sanic.Sanic",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ContentRangeError",
        "sanic.exceptions.ExpectationFailed",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.HeaderExpectationFailed",
        "sanic.exceptions.InvalidUsage",
        "sanic.exceptions.MethodNotAllowed",
        "sanic.exceptions.MethodNotSupported",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.RangeNotSatisfiable",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.exceptions.Unauthorized",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 401",
        "assert response.status == 401",
        "assert response.headers.get('WWW-Authenticate') is not None",
        "assert response.headers.get('WWW-Authenticate') == 'Basic realm=\"Sanic\"'",
        "assert response.status == 401",
        "assert auth_header is not None",
        "assert auth_header.startswith('Digest')",
        "assert 'qop=\"auth, auth-int\"' in auth_header",
        "assert 'algorithm=\"MD5\"' in auth_header",
        "assert 'nonce=\"abcdef\"' in auth_header",
        "assert 'opaque=\"zyxwvu\"' in auth_header",
        "assert response.status == 401",
        "assert response.headers.get('WWW-Authenticate') == 'Bearer'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "exception_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "exception_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response.headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "exception_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response.headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response.headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "response.headers.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_handled_unhandled_exception",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions.py",
      "line_number": 191,
      "end_line_number": 199,
      "source_code": "def test_handled_unhandled_exception(exception_app):\n    \"\"\"Test that an exception not built into sanic is handled\"\"\"\n    request, response = exception_app.test_client.get(\"/divide_by_zero\")\n    assert response.status == 500\n    soup = BeautifulSoup(response.body, \"html.parser\")\n    assert \"Internal Server Error\" in soup.h1.text\n\n    message = \" \".join(soup.p.text.split())\n    assert \"The application encountered an unexpected error\" in message",
      "docstring": "Test that an exception not built into sanic is handled",
      "decorators": [],
      "arguments": [
        "exception_app"
      ],
      "imports": [
        "logging",
        "itertools.count",
        "pytest",
        "bs4.BeautifulSoup",
        "sanic.Sanic",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ContentRangeError",
        "sanic.exceptions.ExpectationFailed",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.HeaderExpectationFailed",
        "sanic.exceptions.InvalidUsage",
        "sanic.exceptions.MethodNotAllowed",
        "sanic.exceptions.MethodNotSupported",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.RangeNotSatisfiable",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.exceptions.Unauthorized",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert 'Internal Server Error' in soup.h1.text",
        "assert 'The application encountered an unexpected error' in message"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_exception_in_exception_handler",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions.py",
      "line_number": 202,
      "end_line_number": 208,
      "source_code": "def test_exception_in_exception_handler(exception_app):\n    \"\"\"Test that an exception thrown in an error handler is handled\"\"\"\n    request, response = exception_app.test_client.get(\n        \"/error_in_error_handler_handler\"\n    )\n    assert response.status == 500\n    assert response.body == b\"An error occurred while handling an error\"",
      "docstring": "Test that an exception thrown in an error handler is handled",
      "decorators": [],
      "arguments": [
        "exception_app"
      ],
      "imports": [
        "logging",
        "itertools.count",
        "pytest",
        "bs4.BeautifulSoup",
        "sanic.Sanic",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ContentRangeError",
        "sanic.exceptions.ExpectationFailed",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.HeaderExpectationFailed",
        "sanic.exceptions.InvalidUsage",
        "sanic.exceptions.MethodNotAllowed",
        "sanic.exceptions.MethodNotSupported",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.RangeNotSatisfiable",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.exceptions.Unauthorized",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert response.body == b'An error occurred while handling an error'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_exception_in_exception_handler_debug_off",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions.py",
      "line_number": 211,
      "end_line_number": 217,
      "source_code": "def test_exception_in_exception_handler_debug_off(exception_app):\n    \"\"\"Test that an exception thrown in an error handler is handled\"\"\"\n    request, response = exception_app.test_client.get(\n        \"/error_in_error_handler_handler\", debug=False\n    )\n    assert response.status == 500\n    assert response.body == b\"An error occurred while handling an error\"",
      "docstring": "Test that an exception thrown in an error handler is handled",
      "decorators": [],
      "arguments": [
        "exception_app"
      ],
      "imports": [
        "logging",
        "itertools.count",
        "pytest",
        "bs4.BeautifulSoup",
        "sanic.Sanic",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ContentRangeError",
        "sanic.exceptions.ExpectationFailed",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.HeaderExpectationFailed",
        "sanic.exceptions.InvalidUsage",
        "sanic.exceptions.MethodNotAllowed",
        "sanic.exceptions.MethodNotSupported",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.RangeNotSatisfiable",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.exceptions.Unauthorized",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert response.body == b'An error occurred while handling an error'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_exception_in_exception_handler_debug_on",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions.py",
      "line_number": 220,
      "end_line_number": 226,
      "source_code": "def test_exception_in_exception_handler_debug_on(exception_app):\n    \"\"\"Test that an exception thrown in an error handler is handled\"\"\"\n    request, response = exception_app.test_client.get(\n        \"/error_in_error_handler_handler\", debug=True\n    )\n    assert response.status == 500\n    assert response.body.startswith(b\"Exception raised in exception \")",
      "docstring": "Test that an exception thrown in an error handler is handled",
      "decorators": [],
      "arguments": [
        "exception_app"
      ],
      "imports": [
        "logging",
        "itertools.count",
        "pytest",
        "bs4.BeautifulSoup",
        "sanic.Sanic",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ContentRangeError",
        "sanic.exceptions.ExpectationFailed",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.HeaderExpectationFailed",
        "sanic.exceptions.InvalidUsage",
        "sanic.exceptions.MethodNotAllowed",
        "sanic.exceptions.MethodNotSupported",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.RangeNotSatisfiable",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.exceptions.Unauthorized",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert response.body.startswith(b'Exception raised in exception ')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_sanic_exception",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions.py",
      "line_number": 229,
      "end_line_number": 241,
      "source_code": "def test_sanic_exception(exception_app):\n    \"\"\"Test sanic exceptions are handled\"\"\"\n    request, response = exception_app.test_client.get(\"/abort/401\")\n    assert response.status == 401\n\n    request, response = exception_app.test_client.get(\"/abort\")\n    assert response.status == 500\n    # check fallback message\n    assert \"Internal Server Error\" in response.text\n\n    request, response = exception_app.test_client.get(\"/abort/message\")\n    assert response.status == 500\n    assert \"Custom Message\" in response.text",
      "docstring": "Test sanic exceptions are handled",
      "decorators": [],
      "arguments": [
        "exception_app"
      ],
      "imports": [
        "logging",
        "itertools.count",
        "pytest",
        "bs4.BeautifulSoup",
        "sanic.Sanic",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ContentRangeError",
        "sanic.exceptions.ExpectationFailed",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.HeaderExpectationFailed",
        "sanic.exceptions.InvalidUsage",
        "sanic.exceptions.MethodNotAllowed",
        "sanic.exceptions.MethodNotSupported",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.RangeNotSatisfiable",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.exceptions.Unauthorized",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 401",
        "assert response.status == 500",
        "assert 'Internal Server Error' in response.text",
        "assert response.status == 500",
        "assert 'Custom Message' in response.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "exception_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "exception_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_custom_exception_default_message",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions.py",
      "line_number": 244,
      "end_line_number": 257,
      "source_code": "def test_custom_exception_default_message(exception_app):\n    class TeaError(SanicException):\n        message = \"Tempest in a teapot\"\n        status_code = 418\n\n    exception_app.router.reset()\n\n    @exception_app.get(\"/tempest\")\n    def tempest(_):\n        raise TeaError\n\n    _, response = exception_app.test_client.get(\"/tempest\", debug=True)\n    assert response.status == 418\n    assert b\"Tempest in a teapot\" in response.body",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "exception_app"
      ],
      "imports": [
        "logging",
        "itertools.count",
        "pytest",
        "bs4.BeautifulSoup",
        "sanic.Sanic",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ContentRangeError",
        "sanic.exceptions.ExpectationFailed",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.HeaderExpectationFailed",
        "sanic.exceptions.InvalidUsage",
        "sanic.exceptions.MethodNotAllowed",
        "sanic.exceptions.MethodNotSupported",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.RangeNotSatisfiable",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.exceptions.Unauthorized",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 418",
        "assert b'Tempest in a teapot' in response.body"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "exception_app.router.reset",
          "body": "@pytest.fixture(autouse=True)\ndef reset():\n    try:\n        del os.environ['SANIC_MOTD_OUTPUT']\n    except KeyError:\n        ..."
        },
        {
          "name": "exception_app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "exception_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_exception_in_ws_logged",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions.py",
      "line_number": 260,
      "end_line_number": 276,
      "source_code": "def test_exception_in_ws_logged(caplog):\n    app = Sanic(\"Test\")\n\n    @app.websocket(\"/feed\")\n    async def feed(request, ws):\n        raise Exception(\"...\")\n\n    with caplog.at_level(logging.INFO):\n        app.test_client.websocket(\"/feed\")\n\n    for record in caplog.record_tuples:\n        if record[2].startswith(\"Exception occurred\"):\n            break\n\n    assert record[0] == \"sanic.error\"\n    assert record[1] == logging.ERROR\n    assert \"Exception occurred while handling uri:\" in record[2]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "caplog"
      ],
      "imports": [
        "logging",
        "itertools.count",
        "pytest",
        "bs4.BeautifulSoup",
        "sanic.Sanic",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ContentRangeError",
        "sanic.exceptions.ExpectationFailed",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.HeaderExpectationFailed",
        "sanic.exceptions.InvalidUsage",
        "sanic.exceptions.MethodNotAllowed",
        "sanic.exceptions.MethodNotSupported",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.RangeNotSatisfiable",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.exceptions.Unauthorized",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert record[0] == 'sanic.error'",
        "assert record[1] == logging.ERROR",
        "assert 'Exception occurred while handling uri:' in record[2]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_contextual_exception_context",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions.py",
      "line_number": 280,
      "end_line_number": 317,
      "source_code": "def test_contextual_exception_context(debug):\n    app = Sanic(\"Test\")\n\n    class TeapotError(SanicException):\n        status_code = 418\n        message = \"Sorry, I cannot brew coffee\"\n\n    def fail():\n        raise TeapotError(context={\"foo\": \"bar\"})\n\n    app.post(\"/coffee/json\", error_format=\"json\", name=\"json\")(\n        lambda _: fail()\n    )\n    app.post(\"/coffee/html\", error_format=\"html\", name=\"html\")(\n        lambda _: fail()\n    )\n    app.post(\"/coffee/text\", error_format=\"text\", name=\"text\")(\n        lambda _: fail()\n    )\n\n    _, response = app.test_client.post(\"/coffee/json\", debug=debug)\n    assert response.status == 418\n    assert response.json[\"message\"] == \"Sorry, I cannot brew coffee\"\n    assert response.json[\"context\"] == {\"foo\": \"bar\"}\n\n    _, response = app.test_client.post(\"/coffee/html\", debug=debug)\n    soup = BeautifulSoup(response.body, \"html.parser\")\n    dl = dl_to_dict(soup, \"exception-context\")\n    assert response.status == 418\n    assert \"Sorry, I cannot brew coffee\" in soup.find(\"p\").text\n    assert dl == {\"foo\": \"bar\"}\n\n    _, response = app.test_client.post(\"/coffee/text\", debug=debug)\n    lines = list(map(lambda x: x.decode(), response.body.split(b\"\\n\")))\n    idx = lines.index(\"Context\") + 1\n    assert response.status == 418\n    assert lines[2] == \"Sorry, I cannot brew coffee\"\n    assert lines[idx] == '    foo: \"bar\"'",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('debug', (True, False))"
      ],
      "arguments": [
        "debug"
      ],
      "imports": [
        "logging",
        "itertools.count",
        "pytest",
        "bs4.BeautifulSoup",
        "sanic.Sanic",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ContentRangeError",
        "sanic.exceptions.ExpectationFailed",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.HeaderExpectationFailed",
        "sanic.exceptions.InvalidUsage",
        "sanic.exceptions.MethodNotAllowed",
        "sanic.exceptions.MethodNotSupported",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.RangeNotSatisfiable",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.exceptions.Unauthorized",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 418",
        "assert response.json['message'] == 'Sorry, I cannot brew coffee'",
        "assert response.json['context'] == {'foo': 'bar'}",
        "assert response.status == 418",
        "assert 'Sorry, I cannot brew coffee' in soup.find('p').text",
        "assert dl == {'foo': 'bar'}",
        "assert response.status == 418",
        "assert lines[2] == 'Sorry, I cannot brew coffee'",
        "assert lines[idx] == '    foo: \"bar\"'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "dl_to_dict",
          "body": "def dl_to_dict(soup, dl_id):\n    (keys, values) = ([], [])\n    for dl in soup.find_all('dl', {'id': dl_id}):\n        for dt in dl.find_all('dt'):\n            keys.append(dt.text.split(':', 1)[0])\n        for dd in dl.find_all('dd'):\n            values.append(dd.text.strip())\n    return dict(zip(keys, values))"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "lines.index",
          "body": "@app.route('/', name='hostindex', host='example.com')\n@app.route('/path', name='hostpath', host='path.example.com')\ndef index(request):\n    pass"
        },
        {
          "name": "fail",
          "body": "@app.route('/fail')\ndef fail(request):\n    return text('this should fail')"
        },
        {
          "name": "fail",
          "body": "@app.route('/fail')\ndef fail(request):\n    return text('this should fail')"
        },
        {
          "name": "fail",
          "body": "@app.route('/fail')\ndef fail(request):\n    return text('this should fail')"
        }
      ]
    },
    {
      "name": "test_contextual_exception_extra",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions.py",
      "line_number": 321,
      "end_line_number": 370,
      "source_code": "def test_contextual_exception_extra(debug):\n    app = Sanic(\"Test\")\n\n    class TeapotError(SanicException):\n        status_code = 418\n\n        @property\n        def message(self):\n            return f\"Found {self.extra['foo']}\"\n\n    def fail():\n        raise TeapotError(extra={\"foo\": \"bar\"})\n\n    app.post(\"/coffee/json\", error_format=\"json\", name=\"json\")(\n        lambda _: fail()\n    )\n    app.post(\"/coffee/html\", error_format=\"html\", name=\"html\")(\n        lambda _: fail()\n    )\n    app.post(\"/coffee/text\", error_format=\"text\", name=\"text\")(\n        lambda _: fail()\n    )\n\n    _, response = app.test_client.post(\"/coffee/json\", debug=debug)\n    assert response.status == 418\n    assert response.json[\"message\"] == \"Found bar\"\n    if debug:\n        assert response.json[\"extra\"] == {\"foo\": \"bar\"}\n    else:\n        assert \"extra\" not in response.json\n\n    _, response = app.test_client.post(\"/coffee/html\", debug=debug)\n    soup = BeautifulSoup(response.body, \"html.parser\")\n    dl = dl_to_dict(soup, \"exception-extra\")\n    assert response.status == 418\n    assert \"Found bar\" in soup.find(\"p\").text\n    if debug:\n        assert dl == {\"foo\": \"bar\"}\n    else:\n        assert not dl\n\n    _, response = app.test_client.post(\"/coffee/text\", debug=debug)\n    lines = list(map(lambda x: x.decode(), response.body.split(b\"\\n\")))\n    assert response.status == 418\n    assert lines[2] == \"Found bar\"\n    if debug:\n        idx = lines.index(\"Extra\") + 1\n        assert lines[idx] == '    foo: \"bar\"'\n    else:\n        assert \"Extra\" not in lines",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('debug', (True, False))"
      ],
      "arguments": [
        "debug"
      ],
      "imports": [
        "logging",
        "itertools.count",
        "pytest",
        "bs4.BeautifulSoup",
        "sanic.Sanic",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ContentRangeError",
        "sanic.exceptions.ExpectationFailed",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.HeaderExpectationFailed",
        "sanic.exceptions.InvalidUsage",
        "sanic.exceptions.MethodNotAllowed",
        "sanic.exceptions.MethodNotSupported",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.RangeNotSatisfiable",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.exceptions.Unauthorized",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 418",
        "assert response.json['message'] == 'Found bar'",
        "assert response.status == 418",
        "assert 'Found bar' in soup.find('p').text",
        "assert response.status == 418",
        "assert lines[2] == 'Found bar'",
        "assert response.json['extra'] == {'foo': 'bar'}",
        "assert 'extra' not in response.json",
        "assert dl == {'foo': 'bar'}",
        "assert not dl",
        "assert lines[idx] == '    foo: \"bar\"'",
        "assert 'Extra' not in lines"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "dl_to_dict",
          "body": "def dl_to_dict(soup, dl_id):\n    (keys, values) = ([], [])\n    for dl in soup.find_all('dl', {'id': dl_id}):\n        for dt in dl.find_all('dt'):\n            keys.append(dt.text.split(':', 1)[0])\n        for dd in dl.find_all('dd'):\n            values.append(dd.text.strip())\n    return dict(zip(keys, values))"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "fail",
          "body": "@app.route('/fail')\ndef fail(request):\n    return text('this should fail')"
        },
        {
          "name": "fail",
          "body": "@app.route('/fail')\ndef fail(request):\n    return text('this should fail')"
        },
        {
          "name": "fail",
          "body": "@app.route('/fail')\ndef fail(request):\n    return text('this should fail')"
        },
        {
          "name": "lines.index",
          "body": "@app.route('/', name='hostindex', host='example.com')\n@app.route('/path', name='hostpath', host='path.example.com')\ndef index(request):\n    pass"
        }
      ]
    },
    {
      "name": "test_contextual_exception_functional_message",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions.py",
      "line_number": 374,
      "end_line_number": 395,
      "source_code": "def test_contextual_exception_functional_message(override):\n    app = Sanic(\"Test\")\n\n    class TeapotError(SanicException):\n        status_code = 418\n\n        @property\n        def message(self):\n            return f\"Received foo={self.context['foo']}\"\n\n    @app.post(\"/coffee\", error_format=\"json\")\n    async def make_coffee(_):\n        error_args = {\"context\": {\"foo\": \"bar\"}}\n        if override:\n            error_args[\"message\"] = \"override\"\n        raise TeapotError(**error_args)\n\n    _, response = app.test_client.post(\"/coffee\", debug=True)\n    error_message = \"override\" if override else \"Received foo=bar\"\n    assert response.status == 418\n    assert response.json[\"message\"] == error_message\n    assert response.json[\"context\"] == {\"foo\": \"bar\"}",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('override', (True, False))"
      ],
      "arguments": [
        "override"
      ],
      "imports": [
        "logging",
        "itertools.count",
        "pytest",
        "bs4.BeautifulSoup",
        "sanic.Sanic",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ContentRangeError",
        "sanic.exceptions.ExpectationFailed",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.HeaderExpectationFailed",
        "sanic.exceptions.InvalidUsage",
        "sanic.exceptions.MethodNotAllowed",
        "sanic.exceptions.MethodNotSupported",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.RangeNotSatisfiable",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.exceptions.Unauthorized",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 418",
        "assert response.json['message'] == error_message",
        "assert response.json['context'] == {'foo': 'bar'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_exception_aliases",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions.py",
      "line_number": 398,
      "end_line_number": 402,
      "source_code": "def test_exception_aliases():\n    assert InvalidUsage is BadRequest\n    assert MethodNotSupported is MethodNotAllowed\n    assert ContentRangeError is RangeNotSatisfiable\n    assert HeaderExpectationFailed is ExpectationFailed",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "itertools.count",
        "pytest",
        "bs4.BeautifulSoup",
        "sanic.Sanic",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ContentRangeError",
        "sanic.exceptions.ExpectationFailed",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.HeaderExpectationFailed",
        "sanic.exceptions.InvalidUsage",
        "sanic.exceptions.MethodNotAllowed",
        "sanic.exceptions.MethodNotSupported",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.RangeNotSatisfiable",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.exceptions.Unauthorized",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert InvalidUsage is BadRequest",
        "assert MethodNotSupported is MethodNotAllowed",
        "assert ContentRangeError is RangeNotSatisfiable",
        "assert HeaderExpectationFailed is ExpectationFailed"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_exception_message_attribute",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions.py",
      "line_number": 405,
      "end_line_number": 417,
      "source_code": "def test_exception_message_attribute():\n    assert ServerError(\"it failed\").message == \"it failed\"\n    assert ServerError(b\"it failed\").message == \"it failed\"\n    assert (\n        ServerError().message == str(ServerError()) == \"Internal Server Error\"\n    )\n\n    class CustomError(SanicException):\n        message = \"Something bad happened\"\n\n    assert CustomError().message == CustomError.message == str(CustomError())\n    assert SanicException().message != \"\"\n    assert SanicException(\"\").message == \"\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "itertools.count",
        "pytest",
        "bs4.BeautifulSoup",
        "sanic.Sanic",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ContentRangeError",
        "sanic.exceptions.ExpectationFailed",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.HeaderExpectationFailed",
        "sanic.exceptions.InvalidUsage",
        "sanic.exceptions.MethodNotAllowed",
        "sanic.exceptions.MethodNotSupported",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.RangeNotSatisfiable",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.exceptions.Unauthorized",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert ServerError('it failed').message == 'it failed'",
        "assert ServerError(b'it failed').message == 'it failed'",
        "assert ServerError().message == str(ServerError()) == 'Internal Server Error'",
        "assert CustomError().message == CustomError.message == str(CustomError())",
        "assert SanicException().message != ''",
        "assert SanicException('').message == ''"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_request_middleware_exception_on_404",
      "module": "test_exceptions",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_exceptions.py",
      "line_number": 420,
      "end_line_number": 435,
      "source_code": "def test_request_middleware_exception_on_404(app: Sanic):\n    \"\"\"See https://github.com/sanic-org/sanic/issues/2950\"\"\"\n    counter = count()\n\n    @app.on_request\n    def request_middleware(request):\n        next(counter)\n        raise Exception\n\n    @app.route(\"/\")\n    async def handler(request): ...\n\n    _, response = app.test_client.get(\"/not-found\")\n\n    assert response.status == 500\n    assert next(counter) == 1",
      "docstring": "See https://github.com/sanic-org/sanic/issues/2950",
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "itertools.count",
        "pytest",
        "bs4.BeautifulSoup",
        "sanic.Sanic",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.ContentRangeError",
        "sanic.exceptions.ExpectationFailed",
        "sanic.exceptions.Forbidden",
        "sanic.exceptions.HeaderExpectationFailed",
        "sanic.exceptions.InvalidUsage",
        "sanic.exceptions.MethodNotAllowed",
        "sanic.exceptions.MethodNotSupported",
        "sanic.exceptions.NotFound",
        "sanic.exceptions.RangeNotSatisfiable",
        "sanic.exceptions.SanicException",
        "sanic.exceptions.ServerError",
        "sanic.exceptions.Unauthorized",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 500",
        "assert next(counter) == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_log",
      "module": "test_logging",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_logging.py",
      "line_number": 36,
      "end_line_number": 54,
      "source_code": "def test_log(app):\n    log_stream = StringIO()\n    for handler in logging.root.handlers[:]:\n        logging.root.removeHandler(handler)\n    logging.basicConfig(\n        format=logging_format, level=logging.DEBUG, stream=log_stream\n    )\n    logging.getLogger(\"asyncio\").setLevel(logging.WARNING)\n    log = logging.getLogger()\n    rand_string = str(uuid.uuid4())\n\n    @app.route(\"/\")\n    def handler(request):\n        log.info(rand_string)\n        return text(\"hello\")\n\n    request, response = app.test_client.get(\"/\")\n    log_text = log_stream.getvalue()\n    assert rand_string in log_text",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "sys",
        "uuid",
        "importlib.reload",
        "io.StringIO",
        "unittest.mock.ANY",
        "unittest.mock.Mock",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.log.Colors",
        "sanic.log.logger",
        "sanic.logging.formatter.AutoFormatter",
        "sanic.logging.formatter.DebugAccessFormatter",
        "sanic.logging.formatter.DebugFormatter",
        "sanic.logging.formatter.ProdAccessFormatter",
        "sanic.logging.formatter.ProdFormatter",
        "sanic.logging.setup.setup_logging",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert rand_string in log_text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_logging_defaults",
      "module": "test_logging",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_logging.py",
      "line_number": 58,
      "end_line_number": 81,
      "source_code": "def test_logging_defaults(debug):\n    AutoFormatter.ATTY = False\n    AutoFormatter.SETUP = False\n    Sanic(\"test_logging\")\n    setup_logging(debug)\n    std_formatter = (DebugFormatter if debug else ProdFormatter)()\n    access_formatter = (\n        DebugAccessFormatter if debug else ProdAccessFormatter\n    )()\n\n    for logger_name, formatter in [\n        (\"sanic.root\", std_formatter),\n        (\"sanic.error\", std_formatter),\n        (\"sanic.access\", access_formatter),\n        (\"sanic.server\", std_formatter),\n        (\"sanic.websockets\", std_formatter),\n    ]:\n        print(\"....\", logger_name)\n        for fmt in [\n            h.formatter for h in logging.getLogger(logger_name).handlers\n        ]:\n            print(f\"{logger_name} logger_formatter: \", fmt._fmt)\n            print(f\"{logger_name}        formatter: \", formatter._fmt)\n            assert fmt._fmt == formatter._fmt",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('debug', (True, False))"
      ],
      "arguments": [
        "debug"
      ],
      "imports": [
        "logging",
        "sys",
        "uuid",
        "importlib.reload",
        "io.StringIO",
        "unittest.mock.ANY",
        "unittest.mock.Mock",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.log.Colors",
        "sanic.log.logger",
        "sanic.logging.formatter.AutoFormatter",
        "sanic.logging.formatter.DebugAccessFormatter",
        "sanic.logging.formatter.DebugFormatter",
        "sanic.logging.formatter.ProdAccessFormatter",
        "sanic.logging.formatter.ProdFormatter",
        "sanic.logging.setup.setup_logging",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert fmt._fmt == formatter._fmt"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_logging_pass_customer_logconfig",
      "module": "test_logging",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_logging.py",
      "line_number": 84,
      "end_line_number": 108,
      "source_code": "def test_logging_pass_customer_logconfig():\n    # reset_logging()\n\n    modified_config = LOGGING_CONFIG_DEFAULTS\n    modified_config[\"formatters\"][\"generic\"][\"format\"] = (\n        \"%(asctime)s - (%(name)s)[%(levelname)s]: %(message)s\"\n    )\n    modified_config[\"formatters\"][\"access\"][\"format\"] = (\n        \"%(asctime)s - (%(name)s)[%(levelname)s]: %(message)s\"\n    )\n\n    Sanic(\"test_logging\", log_config=modified_config)\n\n    for fmt in [h.formatter for h in logging.getLogger(\"sanic.root\").handlers]:\n        assert fmt._fmt == modified_config[\"formatters\"][\"generic\"][\"format\"]\n\n    for fmt in [\n        h.formatter for h in logging.getLogger(\"sanic.error\").handlers\n    ]:\n        assert fmt._fmt == modified_config[\"formatters\"][\"generic\"][\"format\"]\n\n    for fmt in [\n        h.formatter for h in logging.getLogger(\"sanic.access\").handlers\n    ]:\n        assert fmt._fmt == modified_config[\"formatters\"][\"access\"][\"format\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "sys",
        "uuid",
        "importlib.reload",
        "io.StringIO",
        "unittest.mock.ANY",
        "unittest.mock.Mock",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.log.Colors",
        "sanic.log.logger",
        "sanic.logging.formatter.AutoFormatter",
        "sanic.logging.formatter.DebugAccessFormatter",
        "sanic.logging.formatter.DebugFormatter",
        "sanic.logging.formatter.ProdAccessFormatter",
        "sanic.logging.formatter.ProdFormatter",
        "sanic.logging.setup.setup_logging",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert fmt._fmt == modified_config['formatters']['generic']['format']",
        "assert fmt._fmt == modified_config['formatters']['generic']['format']",
        "assert fmt._fmt == modified_config['formatters']['access']['format']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_logging_modified_root_logger_config",
      "module": "test_logging",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_logging.py",
      "line_number": 129,
      "end_line_number": 137,
      "source_code": "def test_logging_modified_root_logger_config():\n    # reset_logging()\n\n    modified_config = LOGGING_CONFIG_DEFAULTS\n    modified_config[\"loggers\"][\"sanic.root\"][\"level\"] = \"DEBUG\"\n\n    Sanic(\"test_logging\", log_config=modified_config)\n\n    assert logging.getLogger(\"sanic.root\").getEffectiveLevel() == logging.DEBUG",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "sys",
        "uuid",
        "importlib.reload",
        "io.StringIO",
        "unittest.mock.ANY",
        "unittest.mock.Mock",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.log.Colors",
        "sanic.log.logger",
        "sanic.logging.formatter.AutoFormatter",
        "sanic.logging.formatter.DebugAccessFormatter",
        "sanic.logging.formatter.DebugFormatter",
        "sanic.logging.formatter.ProdAccessFormatter",
        "sanic.logging.formatter.ProdFormatter",
        "sanic.logging.setup.setup_logging",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert logging.getLogger('sanic.root').getEffectiveLevel() == logging.DEBUG"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_access_log_client_ip_remote_addr",
      "module": "test_logging",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_logging.py",
      "line_number": 140,
      "end_line_number": 166,
      "source_code": "def test_access_log_client_ip_remote_addr(monkeypatch):\n    access = Mock()\n    monkeypatch.setattr(sanic.http.http1, \"access_logger\", access)\n\n    app = Sanic(\"test_logging\")\n    app.config.ACCESS_LOG = True\n    app.config.PROXIES_COUNT = 2\n\n    @app.route(\"/\")\n    async def handler(request):\n        return text(request.remote_addr)\n\n    headers = {\"X-Forwarded-For\": \"1.1.1.1, 2.2.2.2\"}\n\n    request, response = app.test_client.get(\"/\", headers=headers)\n\n    assert request.remote_addr == \"1.1.1.1\"\n    access.info.assert_called_with(\n        \"\",\n        extra={\n            \"status\": 200,\n            \"byte\": len(response.content),\n            \"host\": f\"{request.remote_addr}:{request.port}\",\n            \"request\": f\"GET {request.scheme}://{request.host}/\",\n            \"duration\": ANY,\n        },\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "logging",
        "sys",
        "uuid",
        "importlib.reload",
        "io.StringIO",
        "unittest.mock.ANY",
        "unittest.mock.Mock",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.log.Colors",
        "sanic.log.logger",
        "sanic.logging.formatter.AutoFormatter",
        "sanic.logging.formatter.DebugAccessFormatter",
        "sanic.logging.formatter.DebugFormatter",
        "sanic.logging.formatter.ProdAccessFormatter",
        "sanic.logging.formatter.ProdFormatter",
        "sanic.logging.setup.setup_logging",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.remote_addr == '1.1.1.1'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_access_log_client_ip_reqip",
      "module": "test_logging",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_logging.py",
      "line_number": 169,
      "end_line_number": 191,
      "source_code": "def test_access_log_client_ip_reqip(monkeypatch):\n    access = Mock()\n    monkeypatch.setattr(sanic.http.http1, \"access_logger\", access)\n\n    app = Sanic(\"test_logging\")\n    app.config.ACCESS_LOG = True\n\n    @app.route(\"/\")\n    async def handler(request):\n        return text(request.ip)\n\n    request, response = app.test_client.get(\"/\")\n\n    access.info.assert_called_with(\n        \"\",\n        extra={\n            \"status\": 200,\n            \"byte\": len(response.content),\n            \"host\": f\"{request.ip}:{request.port}\",\n            \"request\": f\"GET {request.scheme}://{request.host}/\",\n            \"duration\": ANY,\n        },\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "logging",
        "sys",
        "uuid",
        "importlib.reload",
        "io.StringIO",
        "unittest.mock.ANY",
        "unittest.mock.Mock",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.log.Colors",
        "sanic.log.logger",
        "sanic.logging.formatter.AutoFormatter",
        "sanic.logging.formatter.DebugAccessFormatter",
        "sanic.logging.formatter.DebugFormatter",
        "sanic.logging.formatter.ProdAccessFormatter",
        "sanic.logging.formatter.ProdFormatter",
        "sanic.logging.setup.setup_logging",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_verbosity",
      "module": "test_logging",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_logging.py",
      "line_number": 208,
      "end_line_number": 230,
      "source_code": "def test_verbosity(app, caplog, app_verbosity, log_verbosity, exists):\n    rand_string = str(uuid.uuid4())\n\n    @app.get(\"/\")\n    def log_info(request):\n        logger.info(\"DEFAULT\")\n        logger.info(rand_string, extra={\"verbosity\": log_verbosity})\n        return text(\"hello\")\n\n    with caplog.at_level(logging.INFO):\n        _ = app.test_client.get(\n            \"/\", server_kwargs={\"verbosity\": app_verbosity}\n        )\n\n    record = (\"sanic.root\", logging.INFO, rand_string)\n\n    if exists:\n        assert record in caplog.record_tuples\n    else:\n        assert record not in caplog.record_tuples\n\n    if app_verbosity == 0:\n        assert (\"sanic.root\", logging.INFO, \"DEFAULT\") in caplog.record_tuples",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('app_verbosity,log_verbosity,exists', ((0, 0, True), (0, 1, False), (0, 2, False), (1, 0, True), (1, 1, True), (1, 2, False), (2, 0, True), (2, 1, True), (2, 2, True)))"
      ],
      "arguments": [
        "app",
        "caplog",
        "app_verbosity",
        "log_verbosity",
        "exists"
      ],
      "imports": [
        "logging",
        "sys",
        "uuid",
        "importlib.reload",
        "io.StringIO",
        "unittest.mock.ANY",
        "unittest.mock.Mock",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.log.Colors",
        "sanic.log.logger",
        "sanic.logging.formatter.AutoFormatter",
        "sanic.logging.formatter.DebugAccessFormatter",
        "sanic.logging.formatter.DebugFormatter",
        "sanic.logging.formatter.ProdAccessFormatter",
        "sanic.logging.formatter.ProdFormatter",
        "sanic.logging.setup.setup_logging",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert record in caplog.record_tuples",
        "assert record not in caplog.record_tuples",
        "assert ('sanic.root', logging.INFO, 'DEFAULT') in caplog.record_tuples"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_colors_enum_format",
      "module": "test_logging",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_logging.py",
      "line_number": 233,
      "end_line_number": 241,
      "source_code": "def test_colors_enum_format():\n    assert f\"{Colors.END}\" == Colors.END.value\n    assert f\"{Colors.BOLD}\" == Colors.BOLD.value\n    assert f\"{Colors.BLUE}\" == Colors.BLUE.value\n    assert f\"{Colors.GREEN}\" == Colors.GREEN.value\n    assert f\"{Colors.PURPLE}\" == Colors.PURPLE.value\n    assert f\"{Colors.RED}\" == Colors.RED.value\n    assert f\"{Colors.SANIC}\" == Colors.SANIC.value\n    assert f\"{Colors.YELLOW}\" == Colors.YELLOW.value",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "sys",
        "uuid",
        "importlib.reload",
        "io.StringIO",
        "unittest.mock.ANY",
        "unittest.mock.Mock",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.log.Colors",
        "sanic.log.logger",
        "sanic.logging.formatter.AutoFormatter",
        "sanic.logging.formatter.DebugAccessFormatter",
        "sanic.logging.formatter.DebugFormatter",
        "sanic.logging.formatter.ProdAccessFormatter",
        "sanic.logging.formatter.ProdFormatter",
        "sanic.logging.setup.setup_logging",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert f'{Colors.END}' == Colors.END.value",
        "assert f'{Colors.BOLD}' == Colors.BOLD.value",
        "assert f'{Colors.BLUE}' == Colors.BLUE.value",
        "assert f'{Colors.GREEN}' == Colors.GREEN.value",
        "assert f'{Colors.PURPLE}' == Colors.PURPLE.value",
        "assert f'{Colors.RED}' == Colors.RED.value",
        "assert f'{Colors.SANIC}' == Colors.SANIC.value",
        "assert f'{Colors.YELLOW}' == Colors.YELLOW.value"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_debug_formatter_formatException",
      "module": "test_logging",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_logging.py",
      "line_number": 254,
      "end_line_number": 286,
      "source_code": "def test_debug_formatter_formatException(atty, no_color, expected):\n    formatter = DebugFormatter()\n    formatter.ATTY = atty\n    formatter.NO_COLOR = no_color\n\n    try:\n        1 / 0\n    except Exception as e:\n        exc_info = (type(e), e, e.__traceback__)\n\n    output = formatter.formatException(exc_info)\n    lines = output.splitlines()\n\n    assert len(lines) == 5 if sys.version_info >= (3, 11) else 4\n    assert (\"\\033\" in output) is expected\n    assert (\"\\033[36m\\033[1m\" in lines[1]) is expected\n    assert (\n        lines[1].endswith(\n            \"\\033[34m\\033[1mtest_debug_formatter_formatException\\033[0m\"\n        )\n        is expected\n    )\n    assert (\n        lines[1].endswith(\"test_debug_formatter_formatException\")\n        is not expected\n    )\n    assert (lines[2] == \"\\033[33m    1 / 0\\033[0m\") is expected\n    assert (lines[2] == \"    1 / 0\") is not expected\n    assert (\n        lines[-1] == \"\\033[38;2;255;13;104m\\033[1mZeroDivisionError\\033[0m: \"\n        \"\\033[1mdivision by zero\\033[0m\"\n    ) is expected\n    assert (lines[-1] == \"ZeroDivisionError: division by zero\") is not expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('atty,no_color,expected', [(True, False, True), (False, False, False), (True, True, False), (False, True, False)])",
        "pytest.mark.xfail(reason='Runs on local but fails on CI, not highly critical')"
      ],
      "arguments": [
        "atty",
        "no_color",
        "expected"
      ],
      "imports": [
        "logging",
        "sys",
        "uuid",
        "importlib.reload",
        "io.StringIO",
        "unittest.mock.ANY",
        "unittest.mock.Mock",
        "pytest",
        "sanic",
        "sanic.Sanic",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.log.Colors",
        "sanic.log.logger",
        "sanic.logging.formatter.AutoFormatter",
        "sanic.logging.formatter.DebugAccessFormatter",
        "sanic.logging.formatter.DebugFormatter",
        "sanic.logging.formatter.ProdAccessFormatter",
        "sanic.logging.formatter.ProdFormatter",
        "sanic.logging.setup.setup_logging",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(lines) == 5 if sys.version_info >= (3, 11) else 4",
        "assert ('\\x1b' in output) is expected",
        "assert ('\\x1b[36m\\x1b[1m' in lines[1]) is expected",
        "assert lines[1].endswith('\\x1b[34m\\x1b[1mtest_debug_formatter_formatException\\x1b[0m') is expected",
        "assert lines[1].endswith('test_debug_formatter_formatException') is not expected",
        "assert (lines[2] == '\\x1b[33m    1 / 0\\x1b[0m') is expected",
        "assert (lines[2] == '    1 / 0') is not expected",
        "assert (lines[-1] == '\\x1b[38;2;255;13;104m\\x1b[1mZeroDivisionError\\x1b[0m: \\x1b[1mdivision by zero\\x1b[0m') is expected",
        "assert (lines[-1] == 'ZeroDivisionError: division by zero') is not expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_server_run",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cli.py",
      "line_number": 62,
      "end_line_number": 70,
      "source_code": "def test_server_run(\n    appname: str, extra: Optional[str], caplog: pytest.LogCaptureFixture, port\n):\n    command = [appname, f\"-p={port}\"]\n    if extra:\n        command.append(extra)\n    lines = capture(command, caplog)\n\n    assert f\"Goin' Fast @ http://127.0.0.1:{port}\" in lines",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('appname,extra', (('fake.server.app', None), ('fake.server', None), ('fake.server:create_app', '--factory'), ('fake.server.create_app()', None), ('fake.server.create_app', None)))"
      ],
      "arguments": [
        "appname",
        "extra",
        "caplog",
        "port"
      ],
      "imports": [
        "json",
        "os",
        "sys",
        "pathlib.Path",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock.patch",
        "pytest",
        "sanic_routing.__version__",
        "sanic.__version__",
        "sanic.__main__.main",
        "sanic.cli.inspector_client.InspectorClient",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert f\"Goin' Fast @ http://127.0.0.1:{port}\" in lines"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "capture",
          "body": "def capture(command: List[str], caplog=None, capsys=None):\n    if capsys:\n        capsys.readouterr()\n    if caplog:\n        caplog.clear()\n    os.chdir(Path(__file__).parent)\n    try:\n        main(command)\n    except SystemExit:\n        ...\n    if capsys:\n        captured_err = capsys.readouterr()\n        return captured_err\n    if caplog:\n        return [record.message for record in caplog.records]\n    return None"
        }
      ]
    },
    {
      "name": "test_server_run_factory_with_args",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cli.py",
      "line_number": 80,
      "end_line_number": 84,
      "source_code": "def test_server_run_factory_with_args(caplog, command, port):\n    command.append(f\"-p={port}\")\n    lines = capture(command, caplog)\n\n    assert \"target=fake.server.create_app_with_args\" in lines",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('command', (['fake.server.create_app_with_args', '--factory'], ['fake.server.create_app_with_args']))"
      ],
      "arguments": [
        "caplog",
        "command",
        "port"
      ],
      "imports": [
        "json",
        "os",
        "sys",
        "pathlib.Path",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock.patch",
        "pytest",
        "sanic_routing.__version__",
        "sanic.__version__",
        "sanic.__main__.main",
        "sanic.cli.inspector_client.InspectorClient",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'target=fake.server.create_app_with_args' in lines"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "capture",
          "body": "def capture(command: List[str], caplog=None, capsys=None):\n    if capsys:\n        capsys.readouterr()\n    if caplog:\n        caplog.clear()\n    os.chdir(Path(__file__).parent)\n    try:\n        main(command)\n    except SystemExit:\n        ...\n    if capsys:\n        captured_err = capsys.readouterr()\n        return captured_err\n    if caplog:\n        return [record.message for record in caplog.records]\n    return None"
        }
      ]
    },
    {
      "name": "test_server_run_factory_with_args_arbitrary",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cli.py",
      "line_number": 87,
      "end_line_number": 96,
      "source_code": "def test_server_run_factory_with_args_arbitrary(caplog, port):\n    command = [\n        \"fake.server.create_app_with_args\",\n        \"--factory\",\n        \"--foo=bar\",\n        f\"-p={port}\",\n    ]\n    lines = capture(command, caplog)\n\n    assert \"foo=bar\" in lines",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "caplog",
        "port"
      ],
      "imports": [
        "json",
        "os",
        "sys",
        "pathlib.Path",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock.patch",
        "pytest",
        "sanic_routing.__version__",
        "sanic.__version__",
        "sanic.__main__.main",
        "sanic.cli.inspector_client.InspectorClient",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'foo=bar' in lines"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "capture",
          "body": "def capture(command: List[str], caplog=None, capsys=None):\n    if capsys:\n        capsys.readouterr()\n    if caplog:\n        caplog.clear()\n    os.chdir(Path(__file__).parent)\n    try:\n        main(command)\n    except SystemExit:\n        ...\n    if capsys:\n        captured_err = capsys.readouterr()\n        return captured_err\n    if caplog:\n        return [record.message for record in caplog.records]\n    return None"
        }
      ]
    },
    {
      "name": "test_tls_options",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cli.py",
      "line_number": 117,
      "end_line_number": 126,
      "source_code": "def test_tls_options(cmd: Tuple[str, ...], caplog, port):\n    command = [\n        \"fake.server.app\",\n        *cmd,\n        f\"--port={port}\",\n        \"--debug\",\n        \"--single-process\",\n    ]\n    lines = capture(command, caplog)\n    assert f\"Goin' Fast @ https://127.0.0.1:{port}\" in lines",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('cmd', (('--cert=certs/sanic.example/fullchain.pem', '--key=certs/sanic.example/privkey.pem'), ('--tls=certs/sanic.example/', '--tls=certs/localhost/'), ('--tls=certs/sanic.example/', '--tls=certs/localhost/', '--tls-strict-host')))"
      ],
      "arguments": [
        "cmd",
        "caplog",
        "port"
      ],
      "imports": [
        "json",
        "os",
        "sys",
        "pathlib.Path",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock.patch",
        "pytest",
        "sanic_routing.__version__",
        "sanic.__version__",
        "sanic.__main__.main",
        "sanic.cli.inspector_client.InspectorClient",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert f\"Goin' Fast @ https://127.0.0.1:{port}\" in lines"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "capture",
          "body": "def capture(command: List[str], caplog=None, capsys=None):\n    if capsys:\n        capsys.readouterr()\n    if caplog:\n        caplog.clear()\n    os.chdir(Path(__file__).parent)\n    try:\n        main(command)\n    except SystemExit:\n        ...\n    if capsys:\n        captured_err = capsys.readouterr()\n        return captured_err\n    if caplog:\n        return [record.message for record in caplog.records]\n    return None"
        }
      ]
    },
    {
      "name": "test_tls_wrong_options",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cli.py",
      "line_number": 141,
      "end_line_number": 149,
      "source_code": "def test_tls_wrong_options(cmd: Tuple[str, ...], caplog, port):\n    command = [\"fake.server.app\", *cmd, f\"-p={port}\", \"--debug\"]\n    lines = capture(command, caplog)\n\n    assert (\n        \"TLS certificates must be specified by either of:\\n  \"\n        \"--cert certdir/fullchain.pem --key certdir/privkey.pem\\n  \"\n        \"--tls certdir  (equivalent to the above)\"\n    ) in lines",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('cmd', (('--cert=certs/sanic.example/fullchain.pem',), ('--cert=certs/sanic.example/fullchain.pem', '--key=certs/sanic.example/privkey.pem', '--tls=certs/localhost/'), ('--tls-strict-host',)))"
      ],
      "arguments": [
        "cmd",
        "caplog",
        "port"
      ],
      "imports": [
        "json",
        "os",
        "sys",
        "pathlib.Path",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock.patch",
        "pytest",
        "sanic_routing.__version__",
        "sanic.__version__",
        "sanic.__main__.main",
        "sanic.cli.inspector_client.InspectorClient",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'TLS certificates must be specified by either of:\\n  --cert certdir/fullchain.pem --key certdir/privkey.pem\\n  --tls certdir  (equivalent to the above)' in lines"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "capture",
          "body": "def capture(command: List[str], caplog=None, capsys=None):\n    if capsys:\n        capsys.readouterr()\n    if caplog:\n        caplog.clear()\n    os.chdir(Path(__file__).parent)\n    try:\n        main(command)\n    except SystemExit:\n        ...\n    if capsys:\n        captured_err = capsys.readouterr()\n        return captured_err\n    if caplog:\n        return [record.message for record in caplog.records]\n    return None"
        }
      ]
    },
    {
      "name": "test_host_port_localhost",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cli.py",
      "line_number": 159,
      "end_line_number": 165,
      "source_code": "def test_host_port_localhost(cmd: Tuple[str, ...], caplog, port):\n    cmd = [c.format(port=str(port)) for c in cmd]\n    command = [\"fake.server.app\", *cmd]\n    lines = capture(command, caplog)\n    expected = f\"Goin' Fast @ http://localhost:{port}\"\n\n    assert expected in lines",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('cmd', (('--host=localhost', '--port={port}'), ('-H', 'localhost', '-p', '{port}')))"
      ],
      "arguments": [
        "cmd",
        "caplog",
        "port"
      ],
      "imports": [
        "json",
        "os",
        "sys",
        "pathlib.Path",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock.patch",
        "pytest",
        "sanic_routing.__version__",
        "sanic.__version__",
        "sanic.__main__.main",
        "sanic.cli.inspector_client.InspectorClient",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert expected in lines"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "capture",
          "body": "def capture(command: List[str], caplog=None, capsys=None):\n    if capsys:\n        capsys.readouterr()\n    if caplog:\n        caplog.clear()\n    os.chdir(Path(__file__).parent)\n    try:\n        main(command)\n    except SystemExit:\n        ...\n    if capsys:\n        captured_err = capsys.readouterr()\n        return captured_err\n    if caplog:\n        return [record.message for record in caplog.records]\n    return None"
        }
      ]
    },
    {
      "name": "test_host_port",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cli.py",
      "line_number": 193,
      "end_line_number": 199,
      "source_code": "def test_host_port(cmd: Tuple[str, ...], expected: str, caplog, port):\n    cmd = [c.format(port=str(port)) for c in cmd]\n    expected = expected.format(port=str(port))\n    command = [\"fake.server.app\", *cmd]\n    lines = capture(command, caplog)\n\n    assert expected in lines",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('cmd,expected', ((('--host=localhost', '--port={port}'), \"Goin' Fast @ http://localhost:{port}\"), (('-H', 'localhost', '-p', '{port}'), \"Goin' Fast @ http://localhost:{port}\"), (('--host=127.0.0.1', '--port={port}'), \"Goin' Fast @ http://127.0.0.1:{port}\"), (('-H', '127.0.0.1', '-p', '{port}'), \"Goin' Fast @ http://127.0.0.1:{port}\"), (('--host=::', '--port={port}'), \"Goin' Fast @ http://[::]:{port}\"), (('-H', '::', '-p', '{port}'), \"Goin' Fast @ http://[::]:{port}\"), (('--host=::1', '--port={port}'), \"Goin' Fast @ http://[::1]:{port}\"), (('-H', '::1', '-p', '{port}'), \"Goin' Fast @ http://[::1]:{port}\")))"
      ],
      "arguments": [
        "cmd",
        "expected",
        "caplog",
        "port"
      ],
      "imports": [
        "json",
        "os",
        "sys",
        "pathlib.Path",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock.patch",
        "pytest",
        "sanic_routing.__version__",
        "sanic.__version__",
        "sanic.__main__.main",
        "sanic.cli.inspector_client.InspectorClient",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert expected in lines"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "capture",
          "body": "def capture(command: List[str], caplog=None, capsys=None):\n    if capsys:\n        capsys.readouterr()\n    if caplog:\n        caplog.clear()\n    os.chdir(Path(__file__).parent)\n    try:\n        main(command)\n    except SystemExit:\n        ...\n    if capsys:\n        captured_err = capsys.readouterr()\n        return captured_err\n    if caplog:\n        return [record.message for record in caplog.records]\n    return None"
        }
      ]
    },
    {
      "name": "test_num_workers",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cli.py",
      "line_number": 213,
      "end_line_number": 222,
      "source_code": "def test_num_workers(num: int, cmd: Tuple[str, ...], caplog, port):\n    command = [\"fake.server.app\", *cmd, f\"-p={port}\"]\n    lines = capture(command, caplog)\n\n    if num == 1:\n        expected = \"mode: production, single worker\"\n    else:\n        expected = f\"mode: production, w/ {num} workers\"\n\n    assert expected in lines",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('num,cmd', ((1, (f'--workers={1}',)), (2, (f'--workers={2}',)), (4, (f'--workers={4}',)), (1, ('-w', '1')), (2, ('-w', '2')), (4, ('-w', '4'))))"
      ],
      "arguments": [
        "num",
        "cmd",
        "caplog",
        "port"
      ],
      "imports": [
        "json",
        "os",
        "sys",
        "pathlib.Path",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock.patch",
        "pytest",
        "sanic_routing.__version__",
        "sanic.__version__",
        "sanic.__main__.main",
        "sanic.cli.inspector_client.InspectorClient",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert expected in lines"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "capture",
          "body": "def capture(command: List[str], caplog=None, capsys=None):\n    if capsys:\n        capsys.readouterr()\n    if caplog:\n        caplog.clear()\n    os.chdir(Path(__file__).parent)\n    try:\n        main(command)\n    except SystemExit:\n        ...\n    if capsys:\n        captured_err = capsys.readouterr()\n        return captured_err\n    if caplog:\n        return [record.message for record in caplog.records]\n    return None"
        }
      ]
    },
    {
      "name": "test_debug",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cli.py",
      "line_number": 226,
      "end_line_number": 232,
      "source_code": "def test_debug(cmd: str, caplog, port):\n    command = [\"fake.server.app\", cmd, f\"-p={port}\"]\n    lines = capture(command, caplog)\n    info = read_app_info(lines)\n\n    assert info[\"debug\"] is True\n    assert info[\"auto_reload\"] is False",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('cmd', ('--debug',))"
      ],
      "arguments": [
        "cmd",
        "caplog",
        "port"
      ],
      "imports": [
        "json",
        "os",
        "sys",
        "pathlib.Path",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock.patch",
        "pytest",
        "sanic_routing.__version__",
        "sanic.__version__",
        "sanic.__main__.main",
        "sanic.cli.inspector_client.InspectorClient",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert info['debug'] is True",
        "assert info['auto_reload'] is False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "capture",
          "body": "def capture(command: List[str], caplog=None, capsys=None):\n    if capsys:\n        capsys.readouterr()\n    if caplog:\n        caplog.clear()\n    os.chdir(Path(__file__).parent)\n    try:\n        main(command)\n    except SystemExit:\n        ...\n    if capsys:\n        captured_err = capsys.readouterr()\n        return captured_err\n    if caplog:\n        return [record.message for record in caplog.records]\n    return None"
        },
        {
          "name": "read_app_info",
          "body": "def read_app_info(lines: List[str]):\n    for line in lines:\n        if line.startswith('{') and line.endswith('}'):\n            return json.loads(line)"
        }
      ]
    },
    {
      "name": "test_dev",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cli.py",
      "line_number": 236,
      "end_line_number": 242,
      "source_code": "def test_dev(cmd: str, caplog, port):\n    command = [\"fake.server.app\", cmd, f\"-p={port}\"]\n    lines = capture(command, caplog)\n    info = read_app_info(lines)\n\n    assert info[\"debug\"] is True\n    assert info[\"auto_reload\"] is True",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('cmd', ('--dev', '-d'))"
      ],
      "arguments": [
        "cmd",
        "caplog",
        "port"
      ],
      "imports": [
        "json",
        "os",
        "sys",
        "pathlib.Path",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock.patch",
        "pytest",
        "sanic_routing.__version__",
        "sanic.__version__",
        "sanic.__main__.main",
        "sanic.cli.inspector_client.InspectorClient",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert info['debug'] is True",
        "assert info['auto_reload'] is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "capture",
          "body": "def capture(command: List[str], caplog=None, capsys=None):\n    if capsys:\n        capsys.readouterr()\n    if caplog:\n        caplog.clear()\n    os.chdir(Path(__file__).parent)\n    try:\n        main(command)\n    except SystemExit:\n        ...\n    if capsys:\n        captured_err = capsys.readouterr()\n        return captured_err\n    if caplog:\n        return [record.message for record in caplog.records]\n    return None"
        },
        {
          "name": "read_app_info",
          "body": "def read_app_info(lines: List[str]):\n    for line in lines:\n        if line.startswith('{') and line.endswith('}'):\n            return json.loads(line)"
        }
      ]
    },
    {
      "name": "test_auto_reload",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cli.py",
      "line_number": 246,
      "end_line_number": 254,
      "source_code": "def test_auto_reload(cmd: str, caplog, port):\n    command = [\"fake.server.app\", cmd, f\"-p={port}\"]\n    lines = capture(command, caplog)\n    info = read_app_info(lines)\n\n    assert info[\"debug\"] is False, f\"Unexpected value of debug {info}\"\n    assert (\n        info[\"auto_reload\"] is True\n    ), f\"Unexpected value of auto reload {info}\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('cmd', ('--auto-reload', '-r'))"
      ],
      "arguments": [
        "cmd",
        "caplog",
        "port"
      ],
      "imports": [
        "json",
        "os",
        "sys",
        "pathlib.Path",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock.patch",
        "pytest",
        "sanic_routing.__version__",
        "sanic.__version__",
        "sanic.__main__.main",
        "sanic.cli.inspector_client.InspectorClient",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert info['debug'] is False, f'Unexpected value of debug {info}'",
        "assert info['auto_reload'] is True, f'Unexpected value of auto reload {info}'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "capture",
          "body": "def capture(command: List[str], caplog=None, capsys=None):\n    if capsys:\n        capsys.readouterr()\n    if caplog:\n        caplog.clear()\n    os.chdir(Path(__file__).parent)\n    try:\n        main(command)\n    except SystemExit:\n        ...\n    if capsys:\n        captured_err = capsys.readouterr()\n        return captured_err\n    if caplog:\n        return [record.message for record in caplog.records]\n    return None"
        },
        {
          "name": "read_app_info",
          "body": "def read_app_info(lines: List[str]):\n    for line in lines:\n        if line.startswith('{') and line.endswith('}'):\n            return json.loads(line)"
        }
      ]
    },
    {
      "name": "test_access_logs",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cli.py",
      "line_number": 266,
      "end_line_number": 277,
      "source_code": "def test_access_logs(cmd: str, expected: bool, caplog, port):\n    command = [\"fake.server.app\", f\"-p={port}\"]\n    if cmd:\n        command.append(cmd)\n    lines = capture(command, caplog)\n    print(lines)\n    info = read_app_info(lines)\n    if info[\"access_log\"] != expected:\n        print(lines)\n    assert (\n        info[\"access_log\"] is expected\n    ), f\"Expected: {expected}. Received: {info}. Lines: {lines}\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('cmd,expected', (('', False), ('--debug', True), ('--access-log', True), ('--no-access-log', False)))"
      ],
      "arguments": [
        "cmd",
        "expected",
        "caplog",
        "port"
      ],
      "imports": [
        "json",
        "os",
        "sys",
        "pathlib.Path",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock.patch",
        "pytest",
        "sanic_routing.__version__",
        "sanic.__version__",
        "sanic.__main__.main",
        "sanic.cli.inspector_client.InspectorClient",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert info['access_log'] is expected, f'Expected: {expected}. Received: {info}. Lines: {lines}'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "capture",
          "body": "def capture(command: List[str], caplog=None, capsys=None):\n    if capsys:\n        capsys.readouterr()\n    if caplog:\n        caplog.clear()\n    os.chdir(Path(__file__).parent)\n    try:\n        main(command)\n    except SystemExit:\n        ...\n    if capsys:\n        captured_err = capsys.readouterr()\n        return captured_err\n    if caplog:\n        return [record.message for record in caplog.records]\n    return None"
        },
        {
          "name": "read_app_info",
          "body": "def read_app_info(lines: List[str]):\n    for line in lines:\n        if line.startswith('{') and line.endswith('}'):\n            return json.loads(line)"
        }
      ]
    },
    {
      "name": "test_version",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cli.py",
      "line_number": 281,
      "end_line_number": 286,
      "source_code": "def test_version(cmd: str, caplog, capsys):\n    command = [cmd]\n    capture(command, caplog)\n    version_string = f\"Sanic {__version__}; Routing {__routing_version__}\\n\"\n    out, _ = capsys.readouterr()\n    assert version_string == out",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('cmd', ('--version', '-v'))"
      ],
      "arguments": [
        "cmd",
        "caplog",
        "capsys"
      ],
      "imports": [
        "json",
        "os",
        "sys",
        "pathlib.Path",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock.patch",
        "pytest",
        "sanic_routing.__version__",
        "sanic.__version__",
        "sanic.__main__.main",
        "sanic.cli.inspector_client.InspectorClient",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert version_string == out"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "capture",
          "body": "def capture(command: List[str], caplog=None, capsys=None):\n    if capsys:\n        capsys.readouterr()\n    if caplog:\n        caplog.clear()\n    os.chdir(Path(__file__).parent)\n    try:\n        main(command)\n    except SystemExit:\n        ...\n    if capsys:\n        captured_err = capsys.readouterr()\n        return captured_err\n    if caplog:\n        return [record.message for record in caplog.records]\n    return None"
        }
      ]
    },
    {
      "name": "test_noisy_exceptions",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cli.py",
      "line_number": 296,
      "end_line_number": 301,
      "source_code": "def test_noisy_exceptions(cmd: str, expected: bool, caplog, port):\n    command = [\"fake.server.app\", cmd, f\"-p={port}\"]\n    lines = capture(command, caplog)\n    info = read_app_info(lines)\n\n    assert info[\"noisy_exceptions\"] is expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('cmd,expected', (('--noisy-exceptions', True), ('--no-noisy-exceptions', False)))"
      ],
      "arguments": [
        "cmd",
        "expected",
        "caplog",
        "port"
      ],
      "imports": [
        "json",
        "os",
        "sys",
        "pathlib.Path",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock.patch",
        "pytest",
        "sanic_routing.__version__",
        "sanic.__version__",
        "sanic.__main__.main",
        "sanic.cli.inspector_client.InspectorClient",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert info['noisy_exceptions'] is expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "capture",
          "body": "def capture(command: List[str], caplog=None, capsys=None):\n    if capsys:\n        capsys.readouterr()\n    if caplog:\n        caplog.clear()\n    os.chdir(Path(__file__).parent)\n    try:\n        main(command)\n    except SystemExit:\n        ...\n    if capsys:\n        captured_err = capsys.readouterr()\n        return captured_err\n    if caplog:\n        return [record.message for record in caplog.records]\n    return None"
        },
        {
          "name": "read_app_info",
          "body": "def read_app_info(lines: List[str]):\n    for line in lines:\n        if line.startswith('{') and line.endswith('}'):\n            return json.loads(line)"
        }
      ]
    },
    {
      "name": "test_inspector_inspect",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cli.py",
      "line_number": 304,
      "end_line_number": 323,
      "source_code": "def test_inspector_inspect(urlopen, caplog, capsys):\n    urlopen.read.return_value = json.dumps(\n        {\n            \"result\": {\n                \"info\": {\n                    \"packages\": [\"foo\"],\n                },\n                \"extra\": {\n                    \"more\": \"data\",\n                },\n                \"workers\": {\"Worker-Name\": {\"some\": \"state\"}},\n            }\n        }\n    ).encode()\n    with patch(\"sys.argv\", [\"sanic\", \"inspect\"]):\n        capture([\"inspect\"], caplog)\n    captured = capsys.readouterr()\n    assert \"Inspecting @ http://localhost:6457\" in captured.out\n    assert \"Worker-Name\" in captured.out\n    assert captured.err == \"\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "urlopen",
        "caplog",
        "capsys"
      ],
      "imports": [
        "json",
        "os",
        "sys",
        "pathlib.Path",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock.patch",
        "pytest",
        "sanic_routing.__version__",
        "sanic.__version__",
        "sanic.__main__.main",
        "sanic.cli.inspector_client.InspectorClient",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'Inspecting @ http://localhost:6457' in captured.out",
        "assert 'Worker-Name' in captured.out",
        "assert captured.err == ''"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "capture",
          "body": "def capture(command: List[str], caplog=None, capsys=None):\n    if capsys:\n        capsys.readouterr()\n    if caplog:\n        caplog.clear()\n    os.chdir(Path(__file__).parent)\n    try:\n        main(command)\n    except SystemExit:\n        ...\n    if capsys:\n        captured_err = capsys.readouterr()\n        return captured_err\n    if caplog:\n        return [record.message for record in caplog.records]\n    return None"
        }
      ]
    },
    {
      "name": "test_inspector_command",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cli.py",
      "line_number": 343,
      "end_line_number": 348,
      "source_code": "def test_inspector_command(command, params):\n    with patch.object(InspectorClient, \"request\") as client:\n        with patch(\"sys.argv\", [\"sanic\", \"inspect\", *command]):\n            main()\n\n    client.assert_called_once_with(command[0], **params)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('command,params', ((['reload'], {'zero_downtime': False}), (['reload', '--zero-downtime'], {'zero_downtime': True}), (['shutdown'], {}), (['scale', '9'], {'replicas': 9}), (['foo', '--bar=something'], {'bar': 'something'}), (['foo', '--bar'], {'bar': True}), (['foo', '--no-bar'], {'bar': False}), (['foo', 'positional'], {'args': ['positional']}), (['foo', 'positional', '--bar=something'], {'args': ['positional'], 'bar': 'something'})))"
      ],
      "arguments": [
        "command",
        "params"
      ],
      "imports": [
        "json",
        "os",
        "sys",
        "pathlib.Path",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock.patch",
        "pytest",
        "sanic_routing.__version__",
        "sanic.__version__",
        "sanic.__main__.main",
        "sanic.cli.inspector_client.InspectorClient",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ]
    },
    {
      "name": "test_server_run_with_repl",
      "module": "test_cli",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cli.py",
      "line_number": 351,
      "end_line_number": 371,
      "source_code": "def test_server_run_with_repl(caplog, capsys):\n    record = (\n        \"sanic.error\",\n        40,\n        \"Can't start REPL in non-interactive mode. \"\n        \"You can only run with --repl in a TTY.\",\n    )\n\n    def run():\n        command = [\"fake.server.app\", \"--repl\", f\"-p={get_port()}\"]\n        return capture(command, capsys=capsys)\n\n    with patch(\"sanic.cli.app.is_atty\", return_value=True):\n        result = run()\n\n    assert record not in caplog.record_tuples\n    assert \"Welcome to the Sanic interactive console\" in result.err\n    assert \">>> \" in result.out\n\n    run()\n    assert record in caplog.record_tuples",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "caplog",
        "capsys"
      ],
      "imports": [
        "json",
        "os",
        "sys",
        "pathlib.Path",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "unittest.mock.patch",
        "pytest",
        "sanic_routing.__version__",
        "sanic.__version__",
        "sanic.__main__.main",
        "sanic.cli.inspector_client.InspectorClient",
        "conftest.get_port"
      ],
      "fixtures": [],
      "assertions": [
        "assert record not in caplog.record_tuples",
        "assert 'Welcome to the Sanic interactive console' in result.err",
        "assert '>>> ' in result.out",
        "assert record in caplog.record_tuples"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "capture",
          "body": "def capture(command: List[str], caplog=None, capsys=None):\n    if capsys:\n        capsys.readouterr()\n    if caplog:\n        caplog.clear()\n    os.chdir(Path(__file__).parent)\n    try:\n        main(command)\n    except SystemExit:\n        ...\n    if capsys:\n        captured_err = capsys.readouterr()\n        return captured_err\n    if caplog:\n        return [record.message for record in caplog.records]\n    return None"
        },
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "get_port",
          "body": "def get_port():\n    sock = socket.socket()\n    sock.bind(('', 0))\n    return sock.getsockname()[1]"
        }
      ]
    },
    {
      "name": "test_late_route",
      "module": "test_late_adds",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_late_adds.py",
      "line_number": 13,
      "end_line_number": 22,
      "source_code": "def test_late_route(late_app: Sanic):\n    @late_app.before_server_start\n    async def late(app: Sanic):\n        @app.get(\"/late\")\n        def handler(_):\n            return text(\"late\")\n\n    _, response = late_app.test_client.get(\"/late\")\n    assert response.status_code == 200\n    assert response.text == \"late\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "late_app"
      ],
      "imports": [
        "pytest",
        "sanic.Sanic",
        "sanic.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.text == 'late'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "late_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_late_middleware",
      "module": "test_late_adds",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_late_adds.py",
      "line_number": 25,
      "end_line_number": 38,
      "source_code": "def test_late_middleware(late_app: Sanic):\n    @late_app.get(\"/late\")\n    def handler(request):\n        return text(request.ctx.late)\n\n    @late_app.before_server_start\n    async def late(app: Sanic):\n        @app.on_request\n        def handler(request):\n            request.ctx.late = \"late\"\n\n    _, response = late_app.test_client.get(\"/late\")\n    assert response.status_code == 200\n    assert response.text == \"late\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "late_app"
      ],
      "imports": [
        "pytest",
        "sanic.Sanic",
        "sanic.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.text == 'late'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "late_app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "late_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_late_signal",
      "module": "test_late_adds",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_late_adds.py",
      "line_number": 41,
      "end_line_number": 54,
      "source_code": "def test_late_signal(late_app: Sanic):\n    @late_app.get(\"/late\")\n    def handler(request):\n        return text(request.ctx.late)\n\n    @late_app.before_server_start\n    async def late(app: Sanic):\n        @app.signal(\"http.lifecycle.request\")\n        def handler(request):\n            request.ctx.late = \"late\"\n\n    _, response = late_app.test_client.get(\"/late\")\n    assert response.status_code == 200\n    assert response.text == \"late\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "late_app"
      ],
      "imports": [
        "pytest",
        "sanic.Sanic",
        "sanic.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status_code == 200",
        "assert response.text == 'late'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "late_app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "late_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_server_error_response_timeout",
      "module": "test_response_timeout",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response_timeout.py",
      "line_number": 67,
      "end_line_number": 70,
      "source_code": "def test_server_error_response_timeout(response_timeout_app):\n    request, response = response_timeout_app.test_client.get(\"/1\")\n    assert response.status == 503\n    assert response.text == \"Response Timeout from error_handler.\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "response_timeout_app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "time.sleep",
        "pytest",
        "sanic.Sanic",
        "sanic.exceptions.ServiceUnavailable",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 503",
        "assert response.text == 'Response Timeout from error_handler.'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "response_timeout_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_default_server_error_response_timeout",
      "module": "test_response_timeout",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response_timeout.py",
      "line_number": 73,
      "end_line_number": 76,
      "source_code": "def test_default_server_error_response_timeout(response_timeout_default_app):\n    request, response = response_timeout_default_app.test_client.get(\"/1\")\n    assert response.status == 503\n    assert \"Response Timeout\" in response.text",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "response_timeout_default_app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "time.sleep",
        "pytest",
        "sanic.Sanic",
        "sanic.exceptions.ServiceUnavailable",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 503",
        "assert 'Response Timeout' in response.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "response_timeout_default_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_response_handler_cancelled",
      "module": "test_response_timeout",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response_timeout.py",
      "line_number": 79,
      "end_line_number": 83,
      "source_code": "def test_response_handler_cancelled(response_handler_cancelled_app):\n    request, response = response_handler_cancelled_app.test_client.get(\"/1\")\n    assert response.status == 503\n    assert \"Response Timeout\" in response.text\n    assert response_handler_cancelled_app.ctx.flag is False",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "response_handler_cancelled_app"
      ],
      "imports": [
        "asyncio",
        "logging",
        "time.sleep",
        "pytest",
        "sanic.Sanic",
        "sanic.exceptions.ServiceUnavailable",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 503",
        "assert 'Response Timeout' in response.text",
        "assert response_handler_cancelled_app.ctx.flag is False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "response_handler_cancelled_app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_response_timeout_not_applied",
      "module": "test_response_timeout",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_response_timeout.py",
      "line_number": 86,
      "end_line_number": 107,
      "source_code": "def test_response_timeout_not_applied(caplog):\n    modified_config = LOGGING_CONFIG_DEFAULTS\n    modified_config[\"loggers\"][\"sanic.websockets\"][\"level\"] = \"DEBUG\"\n\n    app = Sanic(\"test_logging\", log_config=modified_config)\n    app.config.RESPONSE_TIMEOUT = 1\n    app.ctx.event = asyncio.Event()\n\n    @app.websocket(\"/ws\")\n    async def ws_handler(request, ws):\n        sleep(2)\n        await asyncio.sleep(0)\n        request.app.ctx.event.set()\n\n    with caplog.at_level(logging.DEBUG):\n        _ = app.test_client.websocket(\"/ws\")\n    assert app.ctx.event.is_set()\n    assert (\n        \"sanic.websockets\",\n        10,\n        \"Handling websocket. Timeouts disabled.\",\n    ) in caplog.record_tuples",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "caplog"
      ],
      "imports": [
        "asyncio",
        "logging",
        "time.sleep",
        "pytest",
        "sanic.Sanic",
        "sanic.exceptions.ServiceUnavailable",
        "sanic.log.LOGGING_CONFIG_DEFAULTS",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.ctx.event.is_set()",
        "assert ('sanic.websockets', 10, 'Handling websocket. Timeouts disabled.') in caplog.record_tuples"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_bp_copy",
      "module": "test_blueprint_copy",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprint_copy.py",
      "line_number": 9,
      "end_line_number": 80,
      "source_code": "def test_bp_copy(app: Sanic):\n    bp1 = Blueprint(\"test_bp1\", version=1)\n    bp1.ctx.test = 1\n    assert hasattr(bp1.ctx, \"test\")\n\n    @bp1.route(\"/page\")\n    def handle_request(request):\n        return text(\"Hello world!\")\n\n    bp2 = bp1.copy(name=\"test_bp2\", version=2)\n    assert id(bp1) != id(bp2)\n    assert bp1._apps == bp2._apps == set()\n    assert not hasattr(bp2.ctx, \"test\")\n    assert len(bp2._future_exceptions) == len(bp1._future_exceptions)\n    assert len(bp2._future_listeners) == len(bp1._future_listeners)\n    assert len(bp2._future_middleware) == len(bp1._future_middleware)\n    assert len(bp2._future_routes) == len(bp1._future_routes)\n    assert len(bp2._future_signals) == len(bp1._future_signals)\n\n    app.blueprint(bp1)\n    app.blueprint(bp2)\n\n    bp3 = bp1.copy(name=\"test_bp3\", version=3, with_registration=True)\n    assert id(bp1) != id(bp3)\n    assert bp1._apps == bp3._apps and bp3._apps\n    assert not hasattr(bp3.ctx, \"test\")\n\n    bp4 = bp1.copy(name=\"test_bp4\", version=4, with_ctx=True)\n    assert id(bp1) != id(bp4)\n    assert bp4.ctx.test == 1\n\n    bp5 = bp1.copy(name=\"test_bp5\", version=5, with_registration=False)\n    assert id(bp1) != id(bp5)\n    assert not bp5._apps\n    assert bp1._apps != set()\n\n    app.blueprint(bp5)\n\n    bp6 = bp1.copy(\n        name=\"test_bp6\",\n        version=6,\n        with_registration=True,\n        version_prefix=\"/version\",\n    )\n    assert bp6._apps\n    assert bp6.version_prefix == \"/version\"\n\n    _, response = app.test_client.get(\"/v1/page\")\n    assert \"Hello world!\" in response.text\n\n    _, response = app.test_client.get(\"/v2/page\")\n    assert \"Hello world!\" in response.text\n\n    _, response = app.test_client.get(\"/v3/page\")\n    assert \"Hello world!\" in response.text\n\n    _, response = app.test_client.get(\"/v4/page\")\n    assert \"Hello world!\" in response.text\n\n    _, response = app.test_client.get(\"/v5/page\")\n    assert \"Hello world!\" in response.text\n\n    _, response = app.test_client.get(\"/version6/page\")\n    assert \"Hello world!\" in response.text\n\n    route_names = [route.name for route in app.router.routes]\n    assert \"test_bp_copy.test_bp1.handle_request\" in route_names\n    assert \"test_bp_copy.test_bp2.handle_request\" in route_names\n    assert \"test_bp_copy.test_bp3.handle_request\" in route_names\n    assert \"test_bp_copy.test_bp4.handle_request\" in route_names\n    assert \"test_bp_copy.test_bp5.handle_request\" in route_names\n    assert \"test_bp_copy.test_bp6.handle_request\" in route_names",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic_routing.exceptions.RouteExists",
        "sanic.Blueprint",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert hasattr(bp1.ctx, 'test')",
        "assert id(bp1) != id(bp2)",
        "assert bp1._apps == bp2._apps == set()",
        "assert not hasattr(bp2.ctx, 'test')",
        "assert len(bp2._future_exceptions) == len(bp1._future_exceptions)",
        "assert len(bp2._future_listeners) == len(bp1._future_listeners)",
        "assert len(bp2._future_middleware) == len(bp1._future_middleware)",
        "assert len(bp2._future_routes) == len(bp1._future_routes)",
        "assert len(bp2._future_signals) == len(bp1._future_signals)",
        "assert id(bp1) != id(bp3)",
        "assert bp1._apps == bp3._apps and bp3._apps",
        "assert not hasattr(bp3.ctx, 'test')",
        "assert id(bp1) != id(bp4)",
        "assert bp4.ctx.test == 1",
        "assert id(bp1) != id(bp5)",
        "assert not bp5._apps",
        "assert bp1._apps != set()",
        "assert bp6._apps",
        "assert bp6.version_prefix == '/version'",
        "assert 'Hello world!' in response.text",
        "assert 'Hello world!' in response.text",
        "assert 'Hello world!' in response.text",
        "assert 'Hello world!' in response.text",
        "assert 'Hello world!' in response.text",
        "assert 'Hello world!' in response.text",
        "assert 'test_bp_copy.test_bp1.handle_request' in route_names",
        "assert 'test_bp_copy.test_bp2.handle_request' in route_names",
        "assert 'test_bp_copy.test_bp3.handle_request' in route_names",
        "assert 'test_bp_copy.test_bp4.handle_request' in route_names",
        "assert 'test_bp_copy.test_bp5.handle_request' in route_names",
        "assert 'test_bp_copy.test_bp6.handle_request' in route_names"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_bp_copy_without_route_overwriting",
      "module": "test_blueprint_copy",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprint_copy.py",
      "line_number": 83,
      "end_line_number": 114,
      "source_code": "def test_bp_copy_without_route_overwriting(app: Sanic):\n    bpv1 = Blueprint(\"bp_v1\", version=1, url_prefix=\"my_api\")\n\n    @bpv1.route(\"/\")\n    async def handler_v1(request: Request):\n        return text(\"v1\")\n\n    app.blueprint(bpv1)\n\n    bpv2 = bpv1.copy(\"bp_v2\", version=2, allow_route_overwrite=False)\n    bpv3 = bpv1.copy(\n        \"bp_v3\",\n        version=3,\n        allow_route_overwrite=False,\n        with_registration=False,\n    )\n\n    with pytest.raises(RouteExists, match=\"Route already registered*\"):\n\n        @bpv2.route(\"/\")\n        async def handler_v2(request: Request):\n            return text(\"v2\")\n\n        app.blueprint(bpv2)\n\n    with pytest.raises(RouteExists, match=\"Route already registered*\"):\n\n        @bpv3.route(\"/\")\n        async def handler_v3(request: Request):\n            return text(\"v3\")\n\n        app.blueprint(bpv3)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic_routing.exceptions.RouteExists",
        "sanic.Blueprint",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_bp_copy_with_route_overwriting",
      "module": "test_blueprint_copy",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_blueprint_copy.py",
      "line_number": 117,
      "end_line_number": 153,
      "source_code": "def test_bp_copy_with_route_overwriting(app: Sanic):\n    bpv1 = Blueprint(\"bp_v1\", version=1, url_prefix=\"my_api\")\n\n    @bpv1.route(\"/\")\n    async def handler_v1(request: Request):\n        return text(\"v1\")\n\n    app.blueprint(bpv1)\n\n    bpv2 = bpv1.copy(\"bp_v2\", version=2, allow_route_overwrite=True)\n    bpv3 = bpv1.copy(\n        \"bp_v3\", version=3, allow_route_overwrite=True, with_registration=False\n    )\n\n    @bpv2.route(\"/\")\n    async def handler_v2(request: Request):\n        return text(\"v2\")\n\n    app.blueprint(bpv2)\n\n    @bpv3.route(\"/\")\n    async def handler_v3(request: Request):\n        return text(\"v3\")\n\n    app.blueprint(bpv3)\n\n    _, response = app.test_client.get(\"/v1/my_api\")\n    assert response.status == 200\n    assert response.text == \"v1\"\n\n    _, response = app.test_client.get(\"/v2/my_api\")\n    assert response.status == 200\n    assert response.text == \"v2\"\n\n    _, response = app.test_client.get(\"/v3/my_api\")\n    assert response.status == 200\n    assert response.text == \"v3\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "pytest",
        "sanic_routing.exceptions.RouteExists",
        "sanic.Blueprint",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.response.text"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'v1'",
        "assert response.status == 200",
        "assert response.text == 'v2'",
        "assert response.status == 200",
        "assert response.text == 'v3'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_reload_listeners",
      "module": "test_reloader",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_reloader.py",
      "line_number": 219,
      "end_line_number": 243,
      "source_code": "def test_reload_listeners():\n    with TemporaryDirectory() as tmpdir:\n        filename = os.path.join(tmpdir, \"reloader.py\")\n        start_text, stop_text = write_listener_app(\n            filename, port=42305, auto_reload=True\n        )\n\n        proc = Popen(\n            argv[\"script\"], cwd=tmpdir, stdout=PIPE, creationflags=flags\n        )\n        try:\n            timeout = Timer(TIMER_DELAY, terminate, [proc])\n            timeout.start()\n            # Python apparently keeps using the old source sometimes if\n            # we don't sleep before rewrite (pycache timestamp problem?)\n            sleep(1)\n            line = scanner(proc, \"reload_start\")\n            assert start_text in next(line)\n            line = scanner(proc, \"reload_stop\")\n            assert stop_text in next(line)\n        finally:\n            timeout.cancel()\n            terminate(proc)\n            with suppress(TimeoutExpired):\n                proc.wait(timeout=3)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "os",
        "secrets",
        "sys",
        "contextlib.suppress",
        "subprocess.PIPE",
        "subprocess.Popen",
        "subprocess.TimeoutExpired",
        "tempfile.TemporaryDirectory",
        "textwrap.dedent",
        "threading.Timer",
        "time.sleep",
        "pytest",
        "signal.CTRL_BREAK_EVENT",
        "subprocess.CREATE_NEW_PROCESS_GROUP"
      ],
      "fixtures": [],
      "assertions": [
        "assert start_text in next(line)",
        "assert stop_text in next(line)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "write_listener_app",
          "body": "def write_listener_app(filename, **runargs):\n    start_text = secrets.token_urlsafe()\n    stop_text = secrets.token_urlsafe()\n    with open(filename, 'w') as f:\n        f.write(dedent(f'            import os\\n            from sanic import Sanic\\n\\n            app = Sanic(__name__)\\n\\n            app.route(\"/\")(lambda x: x)\\n\\n            @app.reload_process_start\\n            async def reload_start(*_):\\n                print(\"reload_start\", os.getpid(), {start_text!r})\\n\\n            @app.reload_process_stop\\n            async def reload_stop(*_):\\n                print(\"reload_stop\", os.getpid(), {stop_text!r})\\n\\n            if __name__ == \"__main__\":\\n                app.run(**{runargs!r})\\n            '))\n    return (start_text, stop_text)"
        },
        {
          "name": "timeout.start",
          "body": "def start(self):\n    worker_process.set_state(ProcessState.ACKED)\n    self._target()"
        },
        {
          "name": "scanner",
          "body": "def scanner(proc, trigger='complete'):\n    for line in proc.stdout:\n        line = line.decode().strip()\n        if line.startswith(trigger):\n            yield line"
        },
        {
          "name": "scanner",
          "body": "def scanner(proc, trigger='complete'):\n    for line in proc.stdout:\n        line = line.decode().strip()\n        if line.startswith(trigger):\n            yield line"
        },
        {
          "name": "terminate",
          "body": "def terminate(proc):\n    if flags:\n        proc.send_signal(CTRL_BREAK_EVENT)\n    else:\n        proc.terminate()"
        }
      ]
    },
    {
      "name": "test_touchup_methods",
      "module": "test_touchup",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_touchup.py",
      "line_number": 11,
      "end_line_number": 12,
      "source_code": "def test_touchup_methods(app):\n    assert len(TouchUp._registry) == 9",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "pytest",
        "sanic_routing.exceptions.NotFound",
        "sanic.signals.RESERVED_NAMESPACES",
        "sanic.touchup.TouchUp"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(TouchUp._registry) == 9"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_raises_warning_if_os_is_windows",
      "module": "test_server_loop",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_server_loop.py",
      "line_number": 15,
      "end_line_number": 29,
      "source_code": "def test_raises_warning_if_os_is_windows(caplog):\n    with caplog.at_level(logging.WARNING):\n        loop.try_use_uvloop()\n\n    for record in caplog.records:\n        if record.message.startswith(\"You are trying to use\"):\n            break\n\n    assert record.message == (\n        \"You are trying to use uvloop, but uvloop is not compatible \"\n        \"with your system. You can disable uvloop completely by setting \"\n        \"the 'USE_UVLOOP' configuration value to false, or simply not \"\n        \"defining it and letting Sanic handle it for you. Sanic will now \"\n        \"continue to run using the default event loop.\"\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(not OS_IS_WINDOWS, reason='Not testable with current client')"
      ],
      "arguments": [
        "caplog"
      ],
      "imports": [
        "logging",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.compat.UVLOOP_INSTALLED",
        "sanic.server.loop",
        "uvloop"
      ],
      "fixtures": [],
      "assertions": [
        "assert record.message == \"You are trying to use uvloop, but uvloop is not compatible with your system. You can disable uvloop completely by setting the 'USE_UVLOOP' configuration value to false, or simply not defining it and letting Sanic handle it for you. Sanic will now continue to run using the default event loop.\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_raises_warning_if_uvloop_not_installed",
      "module": "test_server_loop",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_server_loop.py",
      "line_number": 36,
      "end_line_number": 51,
      "source_code": "def test_raises_warning_if_uvloop_not_installed(caplog):\n    with caplog.at_level(logging.WARNING):\n        loop.try_use_uvloop()\n\n    for record in caplog.records:\n        if record.message.startswith(\"You are trying to use\"):\n            break\n\n    assert record.message == (\n        \"You are trying to use uvloop, but uvloop is not \"\n        \"installed in your system. In order to use uvloop \"\n        \"you must first install it. Otherwise, you can disable \"\n        \"uvloop completely by setting the 'USE_UVLOOP' \"\n        \"configuration value to false. Sanic will now continue \"\n        \"to run with the default event loop.\"\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(OS_IS_WINDOWS or UVLOOP_INSTALLED, reason='Not testable with current client')"
      ],
      "arguments": [
        "caplog"
      ],
      "imports": [
        "logging",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.compat.UVLOOP_INSTALLED",
        "sanic.server.loop",
        "uvloop"
      ],
      "fixtures": [],
      "assertions": [
        "assert record.message == \"You are trying to use uvloop, but uvloop is not installed in your system. In order to use uvloop you must first install it. Otherwise, you can disable uvloop completely by setting the 'USE_UVLOOP' configuration value to false. Sanic will now continue to run with the default event loop.\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_logs_when_install_and_runtime_config_mismatch",
      "module": "test_server_loop",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_server_loop.py",
      "line_number": 58,
      "end_line_number": 85,
      "source_code": "def test_logs_when_install_and_runtime_config_mismatch(caplog, monkeypatch):\n    getenv = Mock(return_value=\"no\")\n    monkeypatch.setattr(loop, \"getenv\", getenv)\n\n    with caplog.at_level(logging.INFO):\n        loop.try_use_uvloop()\n\n    getenv.assert_called_once_with(\"SANIC_NO_UVLOOP\", \"no\")\n    assert caplog.record_tuples == []\n\n    getenv = Mock(return_value=\"yes\")\n    monkeypatch.setattr(loop, \"getenv\", getenv)\n    with caplog.at_level(logging.INFO):\n        loop.try_use_uvloop()\n\n    getenv.assert_called_once_with(\"SANIC_NO_UVLOOP\", \"no\")\n    for record in caplog.records:\n        if record.message.startswith(\"You are requesting to run\"):\n            break\n\n    assert record.message == (\n        \"You are requesting to run Sanic using uvloop, but the \"\n        \"install-time 'SANIC_NO_UVLOOP' environment variable (used to \"\n        \"opt-out of installing uvloop with Sanic) is set to true. If \"\n        \"you want to prevent Sanic from overriding the event loop policy \"\n        \"during runtime, set the 'USE_UVLOOP' configuration value to \"\n        \"false.\"\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(OS_IS_WINDOWS or not UVLOOP_INSTALLED, reason='Not testable with current client')"
      ],
      "arguments": [
        "caplog",
        "monkeypatch"
      ],
      "imports": [
        "logging",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.compat.UVLOOP_INSTALLED",
        "sanic.server.loop",
        "uvloop"
      ],
      "fixtures": [],
      "assertions": [
        "assert caplog.record_tuples == []",
        "assert record.message == \"You are requesting to run Sanic using uvloop, but the install-time 'SANIC_NO_UVLOOP' environment variable (used to opt-out of installing uvloop with Sanic) is set to true. If you want to prevent Sanic from overriding the event loop policy during runtime, set the 'USE_UVLOOP' configuration value to false.\""
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_sets_loop_policy_only_when_not_already_set",
      "module": "test_server_loop",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_server_loop.py",
      "line_number": 92,
      "end_line_number": 116,
      "source_code": "def test_sets_loop_policy_only_when_not_already_set(monkeypatch):\n    import uvloop  # type: ignore\n\n    # Existing policy is not uvloop.EventLoopPolicy\n    get_event_loop_policy = Mock(return_value=None)\n    monkeypatch.setattr(\n        loop.asyncio, \"get_event_loop_policy\", get_event_loop_policy\n    )\n\n    with patch(\"asyncio.set_event_loop_policy\") as set_event_loop_policy:\n        loop.try_use_uvloop()\n        set_event_loop_policy.assert_called_once()\n        args, _ = set_event_loop_policy.call_args\n        policy = args[0]\n        assert isinstance(policy, uvloop.EventLoopPolicy)\n\n    # Existing policy is uvloop.EventLoopPolicy\n    get_event_loop_policy = Mock(return_value=policy)\n    monkeypatch.setattr(\n        loop.asyncio, \"get_event_loop_policy\", get_event_loop_policy\n    )\n\n    with patch(\"asyncio.set_event_loop_policy\") as set_event_loop_policy:\n        loop.try_use_uvloop()\n        set_event_loop_policy.assert_not_called()",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(OS_IS_WINDOWS or not UVLOOP_INSTALLED, reason='Not testable with current client')"
      ],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "logging",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.compat.UVLOOP_INSTALLED",
        "sanic.server.loop",
        "uvloop"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(policy, uvloop.EventLoopPolicy)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ]
    },
    {
      "name": "test_request_stream_method_view",
      "module": "test_request_stream",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request_stream.py",
      "line_number": 15,
      "end_line_number": 38,
      "source_code": "def test_request_stream_method_view(app):\n    class SimpleView(HTTPMethodView):\n        def get(self, request):\n            return text(\"OK\")\n\n        @stream_decorator\n        async def post(self, request):\n            result = b\"\"\n            while True:\n                body = await request.stream.read()\n                if body is None:\n                    break\n                result += body\n            return text(result.decode())\n\n    app.add_route(SimpleView.as_view(), \"/method_view\")\n\n    request, response = app.test_client.get(\"/method_view\")\n    assert response.status == 200\n    assert response.text == \"OK\"\n\n    request, response = app.test_client.post(\"/method_view\", data=data)\n    assert response.status == 200\n    assert response.text == data",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.views.HTTPMethodView",
        "sanic.views.stream"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'OK'",
        "assert response.status == 200",
        "assert response.text == data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_request_stream_100_continue",
      "module": "test_request_stream",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request_stream.py",
      "line_number": 51,
      "end_line_number": 75,
      "source_code": "def test_request_stream_100_continue(app, headers, expect_raise_exception):\n    class SimpleView(HTTPMethodView):\n        @stream_decorator\n        async def post(self, request):\n            result = \"\"\n            while True:\n                body = await request.stream.read()\n                if body is None:\n                    break\n                result += body.decode(\"utf-8\")\n            return text(result)\n\n    app.add_route(SimpleView.as_view(), \"/method_view\")\n\n    if not expect_raise_exception:\n        request, response = app.test_client.post(\n            \"/method_view\", data=data, headers=headers\n        )\n        assert response.status == 200\n        assert response.text == data\n    else:\n        request, response = app.test_client.post(\n            \"/method_view\", data=data, headers=headers\n        )\n        assert response.status == 417",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('headers, expect_raise_exception', [({'EXPECT': '100-continue'}, False)])"
      ],
      "arguments": [
        "app",
        "headers",
        "expect_raise_exception"
      ],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.views.HTTPMethodView",
        "sanic.views.stream"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == data",
        "assert response.status == 417"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_request_stream_app",
      "module": "test_request_stream",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request_stream.py",
      "line_number": 78,
      "end_line_number": 175,
      "source_code": "def test_request_stream_app(app):\n    @app.get(\"/get\")\n    async def get(request):\n        return text(\"GET\")\n\n    @app.head(\"/head\")\n    async def head(request):\n        return text(\"HEAD\")\n\n    @app.delete(\"/delete\")\n    async def delete(request):\n        return text(\"DELETE\")\n\n    @app.options(\"/options\")\n    async def options(request):\n        return text(\"OPTIONS\")\n\n    @app.post(\"/_post/<id>\")\n    async def _post(request, id):\n        return text(\"_POST\")\n\n    @app.post(\"/post/<id>\", stream=True)\n    async def post(request, id):\n        result = \"\"\n        while True:\n            body = await request.stream.read()\n            if body is None:\n                break\n            result += body.decode(\"utf-8\")\n        return text(result)\n\n    @app.put(\"/_put\")\n    async def _put(request):\n        return text(\"_PUT\")\n\n    @app.put(\"/put\", stream=True)\n    async def put(request):\n        result = \"\"\n        while True:\n            body = await request.stream.read()\n            if body is None:\n                break\n            result += body.decode(\"utf-8\")\n        return text(result)\n\n    @app.patch(\"/_patch\")\n    async def _patch(request):\n        return text(\"_PATCH\")\n\n    @app.patch(\"/patch\", stream=True)\n    async def patch(request):\n        result = \"\"\n        while True:\n            body = await request.stream.read()\n            if body is None:\n                break\n            result += body.decode(\"utf-8\")\n        return text(result)\n\n    request, response = app.test_client.get(\"/get\")\n    assert response.status == 200\n    assert response.text == \"GET\"\n\n    request, response = app.test_client.head(\"/head\")\n    assert response.status == 200\n    assert response.text == \"\"\n\n    request, response = app.test_client.delete(\"/delete\")\n    assert response.status == 200\n    assert response.text == \"DELETE\"\n\n    request, response = app.test_client.options(\"/options\")\n    assert response.status == 200\n    assert response.text == \"OPTIONS\"\n\n    request, response = app.test_client.post(\"/_post/1\", data=data)\n    assert response.status == 200\n    assert response.text == \"_POST\"\n\n    request, response = app.test_client.post(\"/post/1\", data=data)\n    assert response.status == 200\n    assert response.text == data\n\n    request, response = app.test_client.put(\"/_put\", data=data)\n    assert response.status == 200\n    assert response.text == \"_PUT\"\n\n    request, response = app.test_client.put(\"/put\", data=data)\n    assert response.status == 200\n    assert response.text == data\n\n    request, response = app.test_client.patch(\"/_patch\", data=data)\n    assert response.status == 200\n    assert response.text == \"_PATCH\"\n\n    request, response = app.test_client.patch(\"/patch\", data=data)\n    assert response.status == 200\n    assert response.text == data",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.views.HTTPMethodView",
        "sanic.views.stream"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'GET'",
        "assert response.status == 200",
        "assert response.text == ''",
        "assert response.status == 200",
        "assert response.text == 'DELETE'",
        "assert response.status == 200",
        "assert response.text == 'OPTIONS'",
        "assert response.status == 200",
        "assert response.text == '_POST'",
        "assert response.status == 200",
        "assert response.text == data",
        "assert response.status == 200",
        "assert response.text == '_PUT'",
        "assert response.status == 200",
        "assert response.text == data",
        "assert response.status == 200",
        "assert response.text == '_PATCH'",
        "assert response.status == 200",
        "assert response.text == data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "app.patch('/_patch')",
        "app.patch('/patch', stream=True)",
        "app.test_client.patch('/_patch', data=data)",
        "app.test_client.patch('/patch', data=data)"
      ],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.head",
          "body": "def head(self, request):\n    return text('', headers={'method': 'HEAD'})"
        },
        {
          "name": "app.delete",
          "body": "def delete(self, request):\n    return text('I am delete method')"
        },
        {
          "name": "app.options",
          "body": "def options(self, request):\n    return text('', headers={'method': 'OPTIONS'})"
        },
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "app.patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.head",
          "body": "def head(self, request):\n    return text('', headers={'method': 'HEAD'})"
        },
        {
          "name": "app.test_client.delete",
          "body": "def delete(self, request):\n    return text('I am delete method')"
        },
        {
          "name": "app.test_client.options",
          "body": "def options(self, request):\n    return text('', headers={'method': 'OPTIONS'})"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.test_client.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.test_client.patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "app.test_client.patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ]
    },
    {
      "name": "test_request_stream_handle_exception",
      "module": "test_request_stream",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request_stream.py",
      "line_number": 279,
      "end_line_number": 300,
      "source_code": "def test_request_stream_handle_exception(app):\n    \"\"\"for handling exceptions properly\"\"\"\n\n    @app.post(\"/post/<id>\", stream=True)\n    async def post(request, id):\n        result = b\"\"\n        while True:\n            body = await request.stream.read()\n            if body is None:\n                break\n            result += body\n        return text(result.decode())\n\n    # 404\n    request, response = app.test_client.post(\"/in_valid_post\", data=data)\n    assert response.status == 404\n    assert \"Requested URL /in_valid_post not found\" in response.text\n\n    # 405\n    request, response = app.test_client.get(\"/post/random_id\")\n    assert response.status == 405\n    assert \"Method GET not allowed for URL /post/random_id\" in response.text",
      "docstring": "for handling exceptions properly",
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.views.HTTPMethodView",
        "sanic.views.stream"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 404",
        "assert 'Requested URL /in_valid_post not found' in response.text",
        "assert response.status == 405",
        "assert 'Method GET not allowed for URL /post/random_id' in response.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_request_stream_blueprint",
      "module": "test_request_stream",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request_stream.py",
      "line_number": 303,
      "end_line_number": 420,
      "source_code": "def test_request_stream_blueprint(app):\n    bp = Blueprint(\"test_blueprint_request_stream_blueprint\")\n\n    @app.get(\"/get\")\n    async def get(request):\n        return text(\"GET\")\n\n    @bp.head(\"/head\")\n    async def head(request):\n        return text(\"HEAD\")\n\n    @bp.delete(\"/delete\")\n    async def delete(request):\n        return text(\"DELETE\")\n\n    @bp.options(\"/options\")\n    async def options(request):\n        return text(\"OPTIONS\")\n\n    @bp.post(\"/_post/<id>\")\n    async def _post(request, id):\n        return text(\"_POST\")\n\n    @bp.post(\"/post/<id>\", stream=True)\n    async def post(request, id):\n        result = \"\"\n        while True:\n            body = await request.stream.read()\n            if body is None:\n                break\n            result += body.decode(\"utf-8\")\n        return text(result)\n\n    @bp.put(\"/_put\")\n    async def _put(request):\n        return text(\"_PUT\")\n\n    @bp.put(\"/put\", stream=True)\n    async def put(request):\n        result = \"\"\n        while True:\n            body = await request.stream.read()\n            if body is None:\n                break\n            result += body.decode(\"utf-8\")\n        return text(result)\n\n    @bp.patch(\"/_patch\")\n    async def _patch(request):\n        return text(\"_PATCH\")\n\n    @bp.patch(\"/patch\", stream=True)\n    async def patch(request):\n        result = \"\"\n        while True:\n            body = await request.stream.read()\n            if body is None:\n                break\n            result += body.decode(\"utf-8\")\n        return text(result)\n\n    async def post_add_route(request):\n        result = \"\"\n        while True:\n            body = await request.stream.read()\n            if body is None:\n                break\n            result += body.decode(\"utf-8\")\n        return text(result)\n\n    bp.add_route(\n        post_add_route, \"/post/add_route\", methods=[\"POST\"], stream=True\n    )\n    app.blueprint(bp)\n\n    request, response = app.test_client.get(\"/get\")\n    assert response.status == 200\n    assert response.text == \"GET\"\n\n    request, response = app.test_client.head(\"/head\")\n    assert response.status == 200\n    assert response.text == \"\"\n\n    request, response = app.test_client.delete(\"/delete\")\n    assert response.status == 200\n    assert response.text == \"DELETE\"\n\n    request, response = app.test_client.options(\"/options\")\n    assert response.status == 200\n    assert response.text == \"OPTIONS\"\n\n    request, response = app.test_client.post(\"/_post/1\", data=data)\n    assert response.status == 200\n    assert response.text == \"_POST\"\n\n    request, response = app.test_client.post(\"/post/1\", data=data)\n    assert response.status == 200\n    assert response.text == data\n\n    request, response = app.test_client.put(\"/_put\", data=data)\n    assert response.status == 200\n    assert response.text == \"_PUT\"\n\n    request, response = app.test_client.put(\"/put\", data=data)\n    assert response.status == 200\n    assert response.text == data\n\n    request, response = app.test_client.patch(\"/_patch\", data=data)\n    assert response.status == 200\n    assert response.text == \"_PATCH\"\n\n    request, response = app.test_client.patch(\"/patch\", data=data)\n    assert response.status == 200\n    assert response.text == data\n\n    request, response = app.test_client.post(\"/post/add_route\", data=data)\n    assert response.status == 200\n    assert response.text == data",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.views.HTTPMethodView",
        "sanic.views.stream"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'GET'",
        "assert response.status == 200",
        "assert response.text == ''",
        "assert response.status == 200",
        "assert response.text == 'DELETE'",
        "assert response.status == 200",
        "assert response.text == 'OPTIONS'",
        "assert response.status == 200",
        "assert response.text == '_POST'",
        "assert response.status == 200",
        "assert response.text == data",
        "assert response.status == 200",
        "assert response.text == '_PUT'",
        "assert response.status == 200",
        "assert response.text == data",
        "assert response.status == 200",
        "assert response.text == '_PATCH'",
        "assert response.status == 200",
        "assert response.text == data",
        "assert response.status == 200",
        "assert response.text == data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [
        "bp.patch('/_patch')",
        "bp.patch('/patch', stream=True)",
        "app.test_client.patch('/_patch', data=data)",
        "app.test_client.patch('/patch', data=data)"
      ],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp.head",
          "body": "def head(self, request):\n    return text('', headers={'method': 'HEAD'})"
        },
        {
          "name": "bp.delete",
          "body": "def delete(self, request):\n    return text('I am delete method')"
        },
        {
          "name": "bp.options",
          "body": "def options(self, request):\n    return text('', headers={'method': 'OPTIONS'})"
        },
        {
          "name": "bp.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "bp.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "bp.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "bp.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "bp.patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "bp.patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.head",
          "body": "def head(self, request):\n    return text('', headers={'method': 'HEAD'})"
        },
        {
          "name": "app.test_client.delete",
          "body": "def delete(self, request):\n    return text('I am delete method')"
        },
        {
          "name": "app.test_client.options",
          "body": "def options(self, request):\n    return text('', headers={'method': 'OPTIONS'})"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.test_client.put",
          "body": "def put(self, request):\n    return text('I am put method')"
        },
        {
          "name": "app.test_client.patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "app.test_client.patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_request_stream",
      "module": "test_request_stream",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request_stream.py",
      "line_number": 423,
      "end_line_number": 507,
      "source_code": "def test_request_stream(app):\n    \"\"\"test for complex application\"\"\"\n    bp = Blueprint(\"test_blueprint_request_stream\")\n\n    class SimpleView(HTTPMethodView):\n        def get(self, request):\n            return text(\"OK\")\n\n        @stream_decorator\n        async def post(self, request):\n            result = \"\"\n            while True:\n                body = await request.stream.read()\n                if body is None:\n                    break\n                result += body.decode(\"utf-8\")\n            return text(result)\n\n    @app.post(\"/stream\", stream=True)\n    async def handler(request):\n        result = \"\"\n        while True:\n            body = await request.stream.read()\n            if body is None:\n                break\n            result += body.decode(\"utf-8\")\n        return text(result)\n\n    @app.get(\"/get\")\n    async def get(request):\n        return text(\"OK\")\n\n    @bp.post(\"/bp_stream\", stream=True)\n    async def bp_stream(request):\n        result = \"\"\n        while True:\n            body = await request.stream.read()\n            if body is None:\n                break\n            result += body.decode(\"utf-8\")\n        return text(result)\n\n    @bp.get(\"/bp_get\")\n    async def bp_get(request):\n        return text(\"OK\")\n\n    def get_handler(request):\n        return text(\"OK\")\n\n    async def post_handler(request):\n        result = \"\"\n        while True:\n            body = await request.stream.read()\n            if body is None:\n                break\n            result += body.decode(\"utf-8\")\n        return text(result)\n\n    app.add_route(SimpleView.as_view(), \"/method_view\")\n\n    app.blueprint(bp)\n\n    request, response = app.test_client.get(\"/method_view\")\n    assert response.status == 200\n    assert response.text == \"OK\"\n\n    request, response = app.test_client.post(\"/method_view\", data=data)\n    assert response.status == 200\n    assert response.text == data\n\n    request, response = app.test_client.get(\"/get\")\n    assert response.status == 200\n    assert response.text == \"OK\"\n\n    request, response = app.test_client.post(\"/stream\", data=data)\n    assert response.status == 200\n    assert response.text == data\n\n    request, response = app.test_client.get(\"/bp_get\")\n    assert response.status == 200\n    assert response.text == \"OK\"\n\n    request, response = app.test_client.post(\"/bp_stream\", data=data)\n    assert response.status == 200\n    assert response.text == data",
      "docstring": "test for complex application",
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.views.HTTPMethodView",
        "sanic.views.stream"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'OK'",
        "assert response.status == 200",
        "assert response.text == data",
        "assert response.status == 200",
        "assert response.text == 'OK'",
        "assert response.status == 200",
        "assert response.text == data",
        "assert response.status == 200",
        "assert response.text == 'OK'",
        "assert response.status == 200",
        "assert response.text == data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "bp.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "bp.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_streaming_new_api",
      "module": "test_request_stream",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request_stream.py",
      "line_number": 510,
      "end_line_number": 547,
      "source_code": "def test_streaming_new_api(app):\n    @app.post(\"/non-stream\")\n    async def handler1(request):\n        assert request.body == b\"x\"\n        await request.receive_body()  # This should do nothing\n        assert request.body == b\"x\"\n        return text(\"OK\")\n\n    @app.post(\"/1\", stream=True)\n    async def handler2(request):\n        assert request.stream\n        assert not request.body\n        await request.receive_body()\n        return text(request.body.decode().upper())\n\n    @app.post(\"/2\", stream=True)\n    async def handler(request):\n        ret = []\n        async for data in request.stream:\n            # We should have no b\"\" or None, just proper chunks\n            assert data\n            assert isinstance(data, bytes)\n            ret.append(data.decode(\"ASCII\"))\n        return json(ret)\n\n    request, response = app.test_client.post(\"/non-stream\", data=\"x\")\n    assert response.status == 200\n\n    request, response = app.test_client.post(\"/1\", data=\"TEST data\")\n    assert request.body == b\"TEST data\"\n    assert response.status == 200\n    assert response.text == \"TEST DATA\"\n\n    request, response = app.test_client.post(\"/2\", data=data)\n    assert response.status == 200\n    res = response.json\n    assert isinstance(res, list)\n    assert \"\".join(res) == data",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.views.HTTPMethodView",
        "sanic.views.stream"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert request.body == b'TEST data'",
        "assert response.status == 200",
        "assert response.text == 'TEST DATA'",
        "assert response.status == 200",
        "assert isinstance(res, list)",
        "assert ''.join(res) == data",
        "assert request.body == b'x'",
        "assert request.body == b'x'",
        "assert request.stream",
        "assert not request.body",
        "assert data",
        "assert isinstance(data, bytes)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.test_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_streaming_echo",
      "module": "test_request_stream",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_request_stream.py",
      "line_number": 550,
      "end_line_number": 623,
      "source_code": "def test_streaming_echo():\n    \"\"\"2-way streaming chat between server and client.\"\"\"\n    app = Sanic(name=\"Test\")\n\n    @app.post(\"/echo\", stream=True)\n    async def handler(request):\n        res = await request.respond(content_type=\"text/plain; charset=utf-8\")\n        # Send headers\n        await res.send(end_stream=False)\n        # Echo back data (case swapped)\n        async for data in request.stream:\n            await res.send(data.swapcase())\n        # Add EOF marker after successful operation\n        await res.send(b\"-\", end_stream=True)\n\n    @app.listener(\"after_server_start\")\n    async def client_task(app, loop):\n        try:\n            reader, writer = await asyncio.open_connection(\"localhost\", 8000)\n            await client(app, reader, writer)\n        finally:\n            writer.close()\n            app.stop()\n\n    async def client(app, reader, writer):\n        # httpx doesn't support 2-way streaming,so do it by hand.\n        host = \"host: localhost:8000\\r\\n\".encode()\n        writer.write(\n            b\"POST /echo HTTP/1.1\\r\\n\" + host + b\"content-length: 2\\r\\n\"\n            b\"content-type: text/plain; charset=utf-8\\r\\n\"\n            b\"\\r\\n\"\n        )\n        # Read response\n        res = b\"\"\n        while b\"\\r\\n\\r\\n\" not in res:\n            res += await reader.read(4096)\n        assert res.startswith(b\"HTTP/1.1 200 OK\\r\\n\")\n        assert res.endswith(b\"\\r\\n\\r\\n\")\n        buffer = b\"\"\n\n        async def read_chunk():\n            nonlocal buffer\n            while b\"\\r\\n\" not in buffer:\n                data = await reader.read(4096)\n                assert data\n                buffer += data\n            size, buffer = buffer.split(b\"\\r\\n\", 1)\n            size = int(size, 16)\n            if size == 0:\n                return None\n            while len(buffer) < size + 2:\n                data = await reader.read(4096)\n                assert data\n                buffer += data\n            assert buffer[size : size + 2] == b\"\\r\\n\"\n            ret, buffer = buffer[:size], buffer[size + 2 :]\n            return ret\n\n        # Chat with server\n        writer.write(b\"a\")\n        res = await read_chunk()\n        assert res == b\"A\"\n\n        writer.write(b\"b\")\n        res = await read_chunk()\n        assert res == b\"B\"\n\n        res = await read_chunk()\n        assert res == b\"-\"\n\n        res = await read_chunk()\n        assert res is None\n\n    app.run(access_log=False, single_process=True)",
      "docstring": "2-way streaming chat between server and client.",
      "decorators": [],
      "arguments": [],
      "imports": [
        "asyncio",
        "pytest",
        "sanic.Sanic",
        "sanic.blueprints.Blueprint",
        "sanic.response.json",
        "sanic.response.text",
        "sanic.views.HTTPMethodView",
        "sanic.views.stream"
      ],
      "fixtures": [],
      "assertions": [
        "assert res.startswith(b'HTTP/1.1 200 OK\\r\\n')",
        "assert res.endswith(b'\\r\\n\\r\\n')",
        "assert res == b'A'",
        "assert res == b'B'",
        "assert res == b'-'",
        "assert res is None",
        "assert buffer[size:size + 2] == b'\\r\\n'",
        "assert data",
        "assert data"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        },
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "res.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "res.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        },
        {
          "name": "res.send",
          "body": "@pytest.fixture\ndef send(message_stack):\n\n    async def _send(message):\n        message_stack.append(message)\n    return _send"
        },
        {
          "name": "client",
          "body": "@pytest.fixture\ndef client(runner: ReusableClient):\n    client = namedtuple('Client', ('raw', 'send', 'recv'))\n    raw = RawClient(runner.host, runner.port)\n    runner._run(raw.connect())\n\n    def send(msg):\n        nonlocal runner\n        nonlocal raw\n        runner._run(raw.send(msg))\n\n    def recv(**kwargs):\n        nonlocal runner\n        nonlocal raw\n        method = raw.recv_until if 'until' in kwargs else raw.recv\n        return runner._run(method(**kwargs))\n    yield client(raw, send, recv)\n    runner._run(raw.close())"
        }
      ]
    },
    {
      "name": "test_can_raise_in_handler",
      "module": "test_cancellederror",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_cancellederror.py",
      "line_number": 6,
      "end_line_number": 17,
      "source_code": "def test_can_raise_in_handler(app: Sanic):\n    @app.get(\"/\")\n    async def handler(request: Request):\n        raise CancelledError(\"STOP!!\")\n\n    @app.exception(CancelledError)\n    async def handle_cancel(request: Request, exc: CancelledError):\n        return json({\"message\": exc.args[0]}, status=418)\n\n    _, response = app.test_client.get(\"/\")\n    assert response.status == 418\n    assert response.json[\"message\"] == \"STOP!!\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio.CancelledError",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.json"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 418",
        "assert response.json['message'] == 'STOP!!'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.exception",
          "body": "@app.route('/')\ndef exception(request):\n    raise SanicExceptionTestException(\"You won't see me\")"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_parse_headers",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 68,
      "end_line_number": 69,
      "source_code": "def test_parse_headers(input, expected):\n    assert headers.parse_content_header(input) == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('input, expected', [('text/plain', ('text/plain', {})), ('text/vnd.just.made.this.up ; ', ('text/vnd.just.made.this.up', {})), ('text/plain;charset=us-ascii', ('text/plain', {'charset': 'us-ascii'})), ('text/plain ; charset=\"us-ascii\"', ('text/plain', {'charset': 'us-ascii'})), ('text/plain ; charset=\"us-ascii\"; another=opt', ('text/plain', {'charset': 'us-ascii', 'another': 'opt'})), ('attachment; filename=\"silly.txt\"', ('attachment', {'filename': 'silly.txt'})), ('attachment; filename=\"strange;name\"', ('attachment', {'filename': 'strange;name'})), ('attachment; filename=\"strange;name\";size=123;', ('attachment', {'filename': 'strange;name', 'size': '123'})), ('form-data; name=\"foo\"; value=\"%22\\\\%0D%0A\"', ('form-data', {'name': 'foo', 'value': '\"\\\\\\n'})), ('form-data; name=\"foo%22;bar\\\\\"; filename=\"\ud83d\ude00\"', ('form-data', {'name': 'foo\";bar\\\\', 'filename': '\ud83d\ude00'}))])"
      ],
      "arguments": [
        "input",
        "expected"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [
        "assert headers.parse_content_header(input) == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_raw_headers",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 150,
      "end_line_number": 166,
      "source_code": "def test_raw_headers(app):\n    app.route(\"/\")(lambda _: text(\"\"))\n    request, _ = app.test_client.get(\n        \"/\",\n        headers={\n            \"FOO\": \"bar\",\n            \"Host\": \"example.com\",\n            \"User-Agent\": \"Sanic-Testing\",\n        },\n    )\n\n    assert b\"Host: example.com\" in request.raw_headers\n    assert b\"Accept: */*\" in request.raw_headers\n    assert b\"Accept-Encoding: gzip, deflate\" in request.raw_headers\n    assert b\"Connection: keep-alive\" in request.raw_headers\n    assert b\"User-Agent: Sanic-Testing\" in request.raw_headers\n    assert b\"FOO: bar\" in request.raw_headers",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [
        "assert b'Host: example.com' in request.raw_headers",
        "assert b'Accept: */*' in request.raw_headers",
        "assert b'Accept-Encoding: gzip, deflate' in request.raw_headers",
        "assert b'Connection: keep-alive' in request.raw_headers",
        "assert b'User-Agent: Sanic-Testing' in request.raw_headers",
        "assert b'FOO: bar' in request.raw_headers"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_request_line",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 169,
      "end_line_number": 180,
      "source_code": "def test_request_line(app):\n    app.route(\"/\")(lambda _: text(\"\"))\n    request, _ = app.test_client.get(\n        \"/\",\n        headers={\n            \"FOO\": \"bar\",\n            \"Host\": \"example.com\",\n            \"User-Agent\": \"Sanic-Testing\",\n        },\n    )\n\n    assert request.request_line == b\"GET / HTTP/1.1\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.request_line == b'GET / HTTP/1.1'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_parse_accept_ordered_okay",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 199,
      "end_line_number": 202,
      "source_code": "def test_parse_accept_ordered_okay(raw, expected_subtype):\n    ordered = headers.parse_accept(raw)\n    assert ordered[0].type == \"show\"\n    assert ordered[0].subtype == expected_subtype",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('raw,expected_subtype', (('show/first, show/second', 'first'), ('show/*, show/first', 'first'), ('*/*, show/first', 'first'), ('*/*, show/*', '*'), ('other/*; q=0.1, show/*; q=0.2', '*'), ('show/first; q=0.5, show/second; q=0.5', 'first'), ('show/first; foo=bar, show/second; foo=bar', 'first'), ('show/second, show/first; foo=bar', 'first'), ('show/second; q=0.5, show/first; foo=bar; q=0.5', 'first'), ('show/second; q=0.5, show/first; q=1.0', 'first'), ('show/first, show/second; q=1.0', 'second')))"
      ],
      "arguments": [
        "raw",
        "expected_subtype"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [
        "assert ordered[0].type == 'show'",
        "assert ordered[0].subtype == expected_subtype"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_bad_accept",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 214,
      "end_line_number": 216,
      "source_code": "def test_bad_accept(raw):\n    with pytest.raises(InvalidHeader):\n        headers.parse_accept(raw)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('raw', ('missing', 'missing/', '/missing', '/'))"
      ],
      "arguments": [
        "raw"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_empty_accept",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 219,
      "end_line_number": 222,
      "source_code": "def test_empty_accept():\n    a = headers.parse_accept(\"\")\n    assert a == []\n    assert not a.match(\"*/*\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [
        "assert a == []",
        "assert not a.match('*/*')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_wildcard_accept_set_ok",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 225,
      "end_line_number": 239,
      "source_code": "def test_wildcard_accept_set_ok():\n    accept = headers.parse_accept(\"*/*\")[0]\n    assert accept.type == \"*\"\n    assert accept.subtype == \"*\"\n    assert accept.has_wildcard\n\n    accept = headers.parse_accept(\"foo/*\")[0]\n    assert accept.type == \"foo\"\n    assert accept.subtype == \"*\"\n    assert accept.has_wildcard\n\n    accept = headers.parse_accept(\"foo/bar\")[0]\n    assert accept.type == \"foo\"\n    assert accept.subtype == \"bar\"\n    assert not accept.has_wildcard",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [
        "assert accept.type == '*'",
        "assert accept.subtype == '*'",
        "assert accept.has_wildcard",
        "assert accept.type == 'foo'",
        "assert accept.subtype == '*'",
        "assert accept.has_wildcard",
        "assert accept.type == 'foo'",
        "assert accept.subtype == 'bar'",
        "assert not accept.has_wildcard"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_accept_parsed_against_str",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 242,
      "end_line_number": 244,
      "source_code": "def test_accept_parsed_against_str():\n    accept = headers.Matched.parse(\"foo/bar\")\n    assert accept == \"foo/bar; q=0.1\"",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [
        "assert accept == 'foo/bar; q=0.1'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_media_type_matching",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 247,
      "end_line_number": 251,
      "source_code": "def test_media_type_matching():\n    assert headers.MediaType(\"foo\", \"bar\").match(\n        headers.MediaType(\"foo\", \"bar\")\n    )\n    assert headers.MediaType(\"foo\", \"bar\").match(\"foo/bar\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [
        "assert headers.MediaType('foo', 'bar').match(headers.MediaType('foo', 'bar'))",
        "assert headers.MediaType('foo', 'bar').match('foo/bar')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_accept_matching",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 278,
      "end_line_number": 279,
      "source_code": "def test_accept_matching(value, other, outcome):\n    assert bool(headers.Matched.parse(value).match(other)) is outcome",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('value,other,outcome', (('foo/bar', 'foo/bar', True), ('foo/bar', headers.Matched.parse('foo/bar'), True), ('foo/bar', 'foo/*', True), ('foo/bar', headers.Matched.parse('foo/*'), True), ('foo/bar', '*/*', True), ('foo/bar', headers.Matched.parse('*/*'), True), ('foo/*', 'foo/bar', True), ('foo/*', headers.Matched.parse('foo/bar'), True), ('foo/*', 'foo/*', True), ('foo/*', headers.Matched.parse('foo/*'), True), ('foo/*', '*/*', True), ('foo/*', headers.Matched.parse('*/*'), True), ('*/*', 'foo/bar', True), ('*/*', headers.Matched.parse('foo/bar'), True), ('*/*', 'foo/*', True), ('*/*', headers.Matched.parse('foo/*'), True), ('*/*', '*/*', True), ('*/*', headers.Matched.parse('*/*'), True)))"
      ],
      "arguments": [
        "value",
        "other",
        "outcome"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [
        "assert bool(headers.Matched.parse(value).match(other)) is outcome"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_value_in_accept",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 283,
      "end_line_number": 287,
      "source_code": "def test_value_in_accept(value):\n    acceptable = headers.parse_accept(value)\n    assert acceptable.match(\"foo/bar\")\n    assert acceptable.match(\"foo/*\")\n    assert acceptable.match(\"*/*\")",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('value', ('foo/bar', 'foo/*', '*/*'))"
      ],
      "arguments": [
        "value"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [
        "assert acceptable.match('foo/bar')",
        "assert acceptable.match('foo/*')",
        "assert acceptable.match('*/*')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_value_not_in_accept",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 291,
      "end_line_number": 296,
      "source_code": "def test_value_not_in_accept(value):\n    acceptable = headers.parse_accept(value)\n    assert not acceptable.match(\"no/match\")\n    assert not acceptable.match(\"no/*\")\n    assert \"*/*\" not in acceptable\n    assert \"*/bar\" not in acceptable",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('value', ('foo/bar', 'foo/*'))"
      ],
      "arguments": [
        "value"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [
        "assert not acceptable.match('no/match')",
        "assert not acceptable.match('no/*')",
        "assert '*/*' not in acceptable",
        "assert '*/bar' not in acceptable"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_browser_headers_general",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 315,
      "end_line_number": 317,
      "source_code": "def test_browser_headers_general(header, expected):\n    request = Request(b\"/\", {\"accept\": header}, \"1.1\", \"GET\", None, None)\n    assert [str(item) for item in request.accept] == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('header,expected', (('text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8', ['text/html', 'application/xhtml+xml', 'image/avif', 'image/webp', 'application/xml;q=0.9', '*/*;q=0.8']),))"
      ],
      "arguments": [
        "header",
        "expected"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [
        "assert [str(item) for item in request.accept] == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_browser_headers_specific",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 336,
      "end_line_number": 344,
      "source_code": "def test_browser_headers_specific(header, expected):\n    mimes = [e[0] for e in expected]\n    qs = [e[1] for e in expected]\n    request = Request(b\"/\", {\"accept\": header}, \"1.1\", \"GET\", None, None)\n    assert request.accept == mimes\n    for a, m, q in zip(request.accept, mimes, qs):\n        assert a == m\n        assert a.mime == m\n        assert a.q == q",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('header,expected', (('text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8', [('text/html', 1.0), ('application/xhtml+xml', 1.0), ('image/avif', 1.0), ('image/webp', 1.0), ('application/xml', 0.9), ('*/*', 0.8)]),))"
      ],
      "arguments": [
        "header",
        "expected"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.accept == mimes",
        "assert a == m",
        "assert a.mime == m",
        "assert a.q == q"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_accept_ordering",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 358,
      "end_line_number": 365,
      "source_code": "def test_accept_ordering(raw):\n    \"\"\"Should sort by q but also be stable.\"\"\"\n    accept = headers.parse_accept(raw)\n    assert accept[0].type == \"text\"\n    raw1 = \", \".join(str(a) for a in accept)\n    accept = headers.parse_accept(raw1)\n    raw2 = \", \".join(str(a) for a in accept)\n    assert raw1 == raw2",
      "docstring": "Should sort by q but also be stable.",
      "decorators": [
        "pytest.mark.parametrize('raw', ('text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8', 'application/xml;q=0.9, */*;q=0.8, text/html, application/xhtml+xml', 'foo/bar;q=0.9, */*;q=0.8, text/html=0.8, text/plain, application/xhtml+xml'))"
      ],
      "arguments": [
        "raw"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [
        "assert accept[0].type == 'text'",
        "assert raw1 == raw2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_not_accept_wildcard",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 368,
      "end_line_number": 380,
      "source_code": "def test_not_accept_wildcard():\n    accept = headers.parse_accept(\"*/*, foo/*, */bar, foo/bar;q=0.1\")\n    assert not accept.match(\n        \"text/html\", \"foo/foo\", \"bar/bar\", accept_wildcards=False\n    )\n    # Should ignore wildcards in accept but still matches them from mimes\n    m = accept.match(\"text/plain\", \"*/*\", accept_wildcards=False)\n    assert m.mime == \"*/*\"\n    assert m.match(\"*/*\")\n    assert m.header == \"foo/bar\"\n    assert not accept.match(\n        \"text/html\", \"foo/foo\", \"bar/bar\", accept_wildcards=False\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [
        "assert not accept.match('text/html', 'foo/foo', 'bar/bar', accept_wildcards=False)",
        "assert m.mime == '*/*'",
        "assert m.match('*/*')",
        "assert m.header == 'foo/bar'",
        "assert not accept.match('text/html', 'foo/foo', 'bar/bar', accept_wildcards=False)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_accept_misc",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 383,
      "end_line_number": 428,
      "source_code": "def test_accept_misc():\n    header = (\n        \"foo/bar;q=0.0, */plain;param=123, text/plain, text/*, foo/bar;q=0.5\"\n    )\n    a = headers.parse_accept(header)\n    assert repr(a) == (\n        \"[*/plain;param=123, text/plain, text/*, \"\n        \"foo/bar;q=0.5, foo/bar;q=0.0]\"\n    )  # noqa: E501\n    assert str(a) == (\n        \"*/plain;param=123, text/plain, text/*, \"\n        \"foo/bar;q=0.5, foo/bar;q=0.0\"\n    )  # noqa: E501\n    # q=1 types don't match foo/bar but match the two others,\n    # text/* comes first and matches */plain because it\n    # comes first in the header\n    m = a.match(\"foo/bar\", \"text/*\", \"text/plain\")\n    assert repr(m) == \"<text/* matched */plain;param=123>\"\n    assert m == \"text/*\"\n    assert m.mime == \"text/*\"\n    assert m.header.mime == \"*/plain\"\n    assert m.header.type == \"*\"\n    assert m.header.subtype == \"plain\"\n    assert m.header.q == 1.0\n    assert m.header.params == dict(param=\"123\")\n    # Matches object against another Matched object (by mime and header)\n    assert m == a.match(\"text/*\")\n    # Against unsupported type falls back to object id matching\n    assert m != 123\n    # Matches the highest q value\n    m = a.match(\"foo/bar\")\n    assert repr(m) == \"<foo/bar matched foo/bar;q=0.5>\"\n    assert m == \"foo/bar\"\n    assert m == \"foo/bar;q=0.5\"\n    # Matching nothing special case\n    m = a.match()\n    assert m == \"\"\n    assert m.header is None\n    # No header means anything\n    a = headers.parse_accept(None)\n    assert a == [\"*/*\"]\n    assert a.match(\"foo/bar\")\n    # Empty header means nothing\n    a = headers.parse_accept(\"\")\n    assert a == []\n    assert not a.match(\"foo/bar\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(a) == '[*/plain;param=123, text/plain, text/*, foo/bar;q=0.5, foo/bar;q=0.0]'",
        "assert str(a) == '*/plain;param=123, text/plain, text/*, foo/bar;q=0.5, foo/bar;q=0.0'",
        "assert repr(m) == '<text/* matched */plain;param=123>'",
        "assert m == 'text/*'",
        "assert m.mime == 'text/*'",
        "assert m.header.mime == '*/plain'",
        "assert m.header.type == '*'",
        "assert m.header.subtype == 'plain'",
        "assert m.header.q == 1.0",
        "assert m.header.params == dict(param='123')",
        "assert m == a.match('text/*')",
        "assert m != 123",
        "assert repr(m) == '<foo/bar matched foo/bar;q=0.5>'",
        "assert m == 'foo/bar'",
        "assert m == 'foo/bar;q=0.5'",
        "assert m == ''",
        "assert m.header is None",
        "assert a == ['*/*']",
        "assert a.match('foo/bar')",
        "assert a == []",
        "assert not a.match('foo/bar')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_field_simple_accessor",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 439,
      "end_line_number": 441,
      "source_code": "def test_field_simple_accessor(headers, expected):\n    request = make_request(headers)\n    assert request.headers.foo == request.headers.foo_ == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('headers,expected', (({'foo': 'bar'}, 'bar'), ((('foo', 'bar'), ('foo', 'baz')), 'bar,baz'), ({}, '')))"
      ],
      "arguments": [
        "headers",
        "expected"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.headers.foo == request.headers.foo_ == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "def make_request(headers) -> Request:\n    return Request(b'/', headers, '1.1', 'GET', None, None)"
        }
      ]
    },
    {
      "name": "test_field_hyphenated_accessor",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 451,
      "end_line_number": 453,
      "source_code": "def test_field_hyphenated_accessor(headers, expected):\n    request = make_request(headers)\n    assert request.headers.foo_bar == request.headers.foo_bar_ == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('headers,expected', (({'foo-bar': 'bar'}, 'bar'), ((('foo-bar', 'bar'), ('foo-bar', 'baz')), 'bar,baz')))"
      ],
      "arguments": [
        "headers",
        "expected"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [
        "assert request.headers.foo_bar == request.headers.foo_bar_ == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "def make_request(headers) -> Request:\n    return Request(b'/', headers, '1.1', 'GET', None, None)"
        }
      ]
    },
    {
      "name": "test_bad_accessor",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 456,
      "end_line_number": 460,
      "source_code": "def test_bad_accessor():\n    request = make_request({})\n    msg = \"'Header' object has no attribute '_foo'\"\n    with pytest.raises(AttributeError, match=msg):\n        request.headers._foo",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_request",
          "body": "def make_request(headers) -> Request:\n    return Request(b'/', headers, '1.1', 'GET', None, None)"
        }
      ]
    },
    {
      "name": "test_multiple_fields_accessor",
      "module": "test_headers",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_headers.py",
      "line_number": 463,
      "end_line_number": 471,
      "source_code": "def test_multiple_fields_accessor(app: Sanic):\n    @app.get(\"\")\n    async def handler(request: Request):\n        return json({\"field\": request.headers.example_field})\n\n    _, response = app.test_client.get(\n        \"/\", headers=((\"Example-Field\", \"Foo, Bar\"), (\"Example-Field\", \"Baz\"))\n    )\n    assert response.json[\"field\"] == \"Foo, Bar,Baz\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.headers",
        "sanic.json",
        "sanic.text",
        "sanic.exceptions.InvalidHeader",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.Http",
        "sanic.request.Request"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.json['field'] == 'Foo, Bar,Baz'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_static_file",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 82,
      "end_line_number": 89,
      "source_code": "def test_static_file(app, static_file_directory, file_name):\n    app.static(\n        \"/testing.file\", get_file_path(static_file_directory, file_name)\n    )\n\n    request, response = app.test_client.get(\"/testing.file\")\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, file_name)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt', 'python.png', 'symlink', 'hard_link'])"
      ],
      "arguments": [
        "app",
        "static_file_directory",
        "file_name"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, file_name)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ]
    },
    {
      "name": "test_static_file_pathlib",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 96,
      "end_line_number": 101,
      "source_code": "def test_static_file_pathlib(app, static_file_directory, file_name):\n    file_path = Path(get_file_path(static_file_directory, file_name))\n    app.static(\"/testing.file\", file_path)\n    request, response = app.test_client.get(\"/testing.file\")\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, file_name)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt', 'python.png', 'symlink', 'hard_link'])"
      ],
      "arguments": [
        "app",
        "static_file_directory",
        "file_name"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, file_name)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ]
    },
    {
      "name": "test_static_file_pathlib_relative_path_traversal",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 114,
      "end_line_number": 126,
      "source_code": "def test_static_file_pathlib_relative_path_traversal(\n    app, static_file_directory, file_name\n):\n    \"\"\"Get the current working directory and check if it ends with \"sanic\" \"\"\"\n    cwd = Path.cwd()\n    if not str(cwd).endswith(\"sanic\"):\n        pytest.skip(\"Current working directory does not end with 'sanic'\")\n\n    file_path = \"./tests/static/../static/\"\n    app.static(\"/\", file_path)\n    _, response = app.test_client.get(f\"/{file_name}\")\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, file_name)",
      "docstring": "Get the current working directory and check if it ends with \"sanic\" ",
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt', 'python.png', 'symlink', 'hard_link'])"
      ],
      "arguments": [
        "app",
        "static_file_directory",
        "file_name"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, file_name)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ]
    },
    {
      "name": "test_static_file_bytes",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 133,
      "end_line_number": 138,
      "source_code": "def test_static_file_bytes(app, static_file_directory, file_name):\n    bsep = os.path.sep.encode(\"utf-8\")\n    file_path = static_file_directory.encode(\"utf-8\") + bsep + file_name\n    message = \"Static file or directory must be a path-like object or string\"\n    with pytest.raises(TypeError, match=message):\n        app.static(\"/testing.file\", file_path)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', [b'test.file', b'decode me.txt', b'python.png'])"
      ],
      "arguments": [
        "app",
        "static_file_directory",
        "file_name"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_static_file_invalid_path",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 145,
      "end_line_number": 150,
      "source_code": "def test_static_file_invalid_path(app, static_file_directory, file_name):\n    app.route(\"/\")(lambda x: x)\n    with pytest.raises(ValueError):\n        app.static(\"/testing.file\", file_name)\n    request, response = app.test_client.get(\"/testing.file\")\n    assert response.status == 404",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', [{}, [], object()])"
      ],
      "arguments": [
        "app",
        "static_file_directory",
        "file_name"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_static_file_content_type",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 154,
      "end_line_number": 164,
      "source_code": "def test_static_file_content_type(app, static_file_directory, file_name):\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        content_type=\"text/html; charset=utf-8\",\n    )\n\n    request, response = app.test_client.get(\"/testing.file\")\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, file_name)\n    assert response.headers[\"Content-Type\"] == \"text/html; charset=utf-8\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.html'])"
      ],
      "arguments": [
        "app",
        "static_file_directory",
        "file_name"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, file_name)",
        "assert response.headers['Content-Type'] == 'text/html; charset=utf-8'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ]
    },
    {
      "name": "test_static_file_content_type_guessed",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 175,
      "end_line_number": 186,
      "source_code": "def test_static_file_content_type_guessed(\n    app, static_file_directory, file_name, expected\n):\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n    )\n\n    request, response = app.test_client.get(\"/testing.file\")\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, file_name)\n    assert response.headers[\"Content-Type\"] == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name,expected', [('test.html', 'text/html; charset=utf-8'), ('decode me.txt', 'text/plain; charset=utf-8'), ('test.file', 'application/octet-stream')])"
      ],
      "arguments": [
        "app",
        "static_file_directory",
        "file_name",
        "expected"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, file_name)",
        "assert response.headers['Content-Type'] == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ]
    },
    {
      "name": "test_static_file_content_type_with_charset",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 189,
      "end_line_number": 198,
      "source_code": "def test_static_file_content_type_with_charset(app, static_file_directory):\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, \"decode me.txt\"),\n        content_type=\"text/plain;charset=ISO-8859-1\",\n    )\n\n    request, response = app.test_client.get(\"/testing.file\")\n    assert response.status == 200\n    assert response.headers[\"Content-Type\"] == \"text/plain;charset=ISO-8859-1\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "static_file_directory"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.headers['Content-Type'] == 'text/plain;charset=ISO-8859-1'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        }
      ]
    },
    {
      "name": "test_static_directory",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 205,
      "end_line_number": 210,
      "source_code": "def test_static_directory(app, file_name, base_uri, static_file_directory):\n    app.static(base_uri, static_file_directory)\n\n    request, response = app.test_client.get(uri=f\"{base_uri}/{file_name}\")\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, file_name)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt', 'symlink', 'hard_link'])",
        "pytest.mark.parametrize('base_uri', ['/static', '', '/dir'])"
      ],
      "arguments": [
        "app",
        "file_name",
        "base_uri",
        "static_file_directory"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, file_name)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ]
    },
    {
      "name": "test_static_head_request",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 214,
      "end_line_number": 227,
      "source_code": "def test_static_head_request(app, file_name, static_file_directory):\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n\n    request, response = app.test_client.head(\"/testing.file\")\n    assert response.status == 200\n    assert \"Accept-Ranges\" in response.headers\n    assert \"Content-Length\" in response.headers\n    assert int(response.headers[\"Content-Length\"]) == len(\n        get_file_content(static_file_directory, file_name)\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt'])"
      ],
      "arguments": [
        "app",
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert 'Accept-Ranges' in response.headers",
        "assert 'Content-Length' in response.headers",
        "assert int(response.headers['Content-Length']) == len(get_file_content(static_file_directory, file_name))"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.head",
          "body": "def head(self, request):\n    return text('', headers={'method': 'HEAD'})"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ]
    },
    {
      "name": "test_static_content_range_correct",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 231,
      "end_line_number": 247,
      "source_code": "def test_static_content_range_correct(app, file_name, static_file_directory):\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n\n    headers = {\"Range\": \"bytes=12-19\"}\n    request, response = app.test_client.get(\"/testing.file\", headers=headers)\n    assert response.status == 206\n    assert \"Content-Length\" in response.headers\n    assert \"Content-Range\" in response.headers\n    static_content = bytes(get_file_content(static_file_directory, file_name))[\n        12:20\n    ]\n    assert int(response.headers[\"Content-Length\"]) == len(static_content)\n    assert response.body == static_content",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt'])"
      ],
      "arguments": [
        "app",
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 206",
        "assert 'Content-Length' in response.headers",
        "assert 'Content-Range' in response.headers",
        "assert int(response.headers['Content-Length']) == len(static_content)",
        "assert response.body == static_content"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ]
    },
    {
      "name": "test_static_content_range_front",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 251,
      "end_line_number": 267,
      "source_code": "def test_static_content_range_front(app, file_name, static_file_directory):\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n\n    headers = {\"Range\": \"bytes=12-\"}\n    request, response = app.test_client.get(\"/testing.file\", headers=headers)\n    assert response.status == 206\n    assert \"Content-Length\" in response.headers\n    assert \"Content-Range\" in response.headers\n    static_content = bytes(get_file_content(static_file_directory, file_name))[\n        12:\n    ]\n    assert int(response.headers[\"Content-Length\"]) == len(static_content)\n    assert response.body == static_content",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt'])"
      ],
      "arguments": [
        "app",
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 206",
        "assert 'Content-Length' in response.headers",
        "assert 'Content-Range' in response.headers",
        "assert int(response.headers['Content-Length']) == len(static_content)",
        "assert response.body == static_content"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ]
    },
    {
      "name": "test_static_content_range_back",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 271,
      "end_line_number": 287,
      "source_code": "def test_static_content_range_back(app, file_name, static_file_directory):\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n\n    headers = {\"Range\": \"bytes=-12\"}\n    request, response = app.test_client.get(\"/testing.file\", headers=headers)\n    assert response.status == 206\n    assert \"Content-Length\" in response.headers\n    assert \"Content-Range\" in response.headers\n    static_content = bytes(get_file_content(static_file_directory, file_name))[\n        -12:\n    ]\n    assert int(response.headers[\"Content-Length\"]) == len(static_content)\n    assert response.body == static_content",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt'])"
      ],
      "arguments": [
        "app",
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 206",
        "assert 'Content-Length' in response.headers",
        "assert 'Content-Range' in response.headers",
        "assert int(response.headers['Content-Length']) == len(static_content)",
        "assert response.body == static_content"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ]
    },
    {
      "name": "test_static_content_range_empty",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 292,
      "end_line_number": 311,
      "source_code": "def test_static_content_range_empty(\n    app, file_name, static_file_directory, use_modified_since\n):\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n        use_modified_since=use_modified_since,\n    )\n\n    request, response = app.test_client.get(\"/testing.file\")\n    assert response.status == 200\n    assert \"Content-Length\" in response.headers\n    assert \"Content-Range\" not in response.headers\n    assert int(response.headers[\"Content-Length\"]) == len(\n        get_file_content(static_file_directory, file_name)\n    )\n    assert response.body == bytes(\n        get_file_content(static_file_directory, file_name)\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('use_modified_since', [True, False])",
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt'])"
      ],
      "arguments": [
        "app",
        "file_name",
        "static_file_directory",
        "use_modified_since"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert 'Content-Length' in response.headers",
        "assert 'Content-Range' not in response.headers",
        "assert int(response.headers['Content-Length']) == len(get_file_content(static_file_directory, file_name))",
        "assert response.body == bytes(get_file_content(static_file_directory, file_name))"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ]
    },
    {
      "name": "test_static_content_range_error",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 315,
      "end_line_number": 329,
      "source_code": "def test_static_content_range_error(app, file_name, static_file_directory):\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n\n    headers = {\"Range\": \"bytes=1-0\"}\n    request, response = app.test_client.get(\"/testing.file\", headers=headers)\n    assert response.status == 416\n    assert \"Content-Length\" in response.headers\n    assert \"Content-Range\" in response.headers\n    assert response.headers[\"Content-Range\"] == \"bytes */%s\" % (\n        len(get_file_content(static_file_directory, file_name)),\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt'])"
      ],
      "arguments": [
        "app",
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 416",
        "assert 'Content-Length' in response.headers",
        "assert 'Content-Range' in response.headers",
        "assert response.headers['Content-Range'] == 'bytes */%s' % (len(get_file_content(static_file_directory, file_name)),)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ]
    },
    {
      "name": "test_static_content_range_invalid_unit",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 333,
      "end_line_number": 347,
      "source_code": "def test_static_content_range_invalid_unit(\n    app, file_name, static_file_directory\n):\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n\n    unit = \"bit\"\n    headers = {\"Range\": f\"{unit}=1-0\"}\n    request, response = app.test_client.get(\"/testing.file\", headers=headers)\n\n    assert response.status == 416\n    assert f\"{unit} is not a valid Range Type\" in response.text",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt'])"
      ],
      "arguments": [
        "app",
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 416",
        "assert f'{unit} is not a valid Range Type' in response.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        }
      ]
    },
    {
      "name": "test_static_content_range_invalid_start",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 351,
      "end_line_number": 365,
      "source_code": "def test_static_content_range_invalid_start(\n    app, file_name, static_file_directory\n):\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n\n    start = \"start\"\n    headers = {\"Range\": f\"bytes={start}-0\"}\n    request, response = app.test_client.get(\"/testing.file\", headers=headers)\n\n    assert response.status == 416\n    assert f\"'{start}' is invalid for Content Range\" in response.text",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt'])"
      ],
      "arguments": [
        "app",
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 416",
        "assert f\"'{start}' is invalid for Content Range\" in response.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        }
      ]
    },
    {
      "name": "test_static_content_range_invalid_end",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 369,
      "end_line_number": 383,
      "source_code": "def test_static_content_range_invalid_end(\n    app, file_name, static_file_directory\n):\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n\n    end = \"end\"\n    headers = {\"Range\": f\"bytes=1-{end}\"}\n    request, response = app.test_client.get(\"/testing.file\", headers=headers)\n\n    assert response.status == 416\n    assert f\"'{end}' is invalid for Content Range\" in response.text",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt'])"
      ],
      "arguments": [
        "app",
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 416",
        "assert f\"'{end}' is invalid for Content Range\" in response.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        }
      ]
    },
    {
      "name": "test_static_content_range_invalid_parameters",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 387,
      "end_line_number": 400,
      "source_code": "def test_static_content_range_invalid_parameters(\n    app, file_name, static_file_directory\n):\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_content_range=True,\n    )\n\n    headers = {\"Range\": \"bytes=-\"}\n    request, response = app.test_client.get(\"/testing.file\", headers=headers)\n\n    assert response.status == 416\n    assert \"Invalid for Content Range parameters\" in response.text",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt'])"
      ],
      "arguments": [
        "app",
        "file_name",
        "static_file_directory"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 416",
        "assert 'Invalid for Content Range parameters' in response.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        }
      ]
    },
    {
      "name": "test_static_file_specified_host",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 406,
      "end_line_number": 418,
      "source_code": "def test_static_file_specified_host(app, static_file_directory, file_name):\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        host=\"www.example.com\",\n    )\n\n    headers = {\"Host\": \"www.example.com\"}\n    request, response = app.test_client.get(\"/testing.file\", headers=headers)\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, file_name)\n    request, response = app.test_client.get(\"/testing.file\")\n    assert response.status == 404",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt', 'python.png'])"
      ],
      "arguments": [
        "app",
        "static_file_directory",
        "file_name"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, file_name)",
        "assert response.status == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ]
    },
    {
      "name": "test_static_stream_large_file",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 424,
      "end_line_number": 442,
      "source_code": "def test_static_stream_large_file(\n    app,\n    static_file_directory,\n    file_name,\n    use_modified_since,\n    stream_large_files,\n    large_file,\n):\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_modified_since=use_modified_since,\n        stream_large_files=stream_large_files,\n    )\n\n    request, response = app.test_client.get(\"/testing.file\")\n\n    assert response.status == 200\n    assert response.body == get_file_content(static_file_directory, file_name)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('use_modified_since', [True, False])",
        "pytest.mark.parametrize('stream_large_files', [True, 1024])",
        "pytest.mark.parametrize('file_name', ['test.file', 'large.file'])"
      ],
      "arguments": [
        "app",
        "static_file_directory",
        "file_name",
        "use_modified_since",
        "stream_large_files",
        "large_file"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, file_name)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ]
    },
    {
      "name": "test_use_modified_since",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 448,
      "end_line_number": 464,
      "source_code": "def test_use_modified_since(app, static_file_directory, file_name):\n    file_stat = os.stat(get_file_path(static_file_directory, file_name))\n    modified_since = strftime(\n        \"%a, %d %b %Y %H:%M:%S GMT\", gmtime(file_stat.st_mtime)\n    )\n\n    app.static(\n        \"/testing.file\",\n        get_file_path(static_file_directory, file_name),\n        use_modified_since=True,\n    )\n\n    request, response = app.test_client.get(\n        \"/testing.file\", headers={\"If-Modified-Since\": modified_since}\n    )\n\n    assert response.status == 304",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('file_name', ['test.file', 'decode me.txt', 'python.png'])"
      ],
      "arguments": [
        "app",
        "static_file_directory",
        "file_name"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 304"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        }
      ]
    },
    {
      "name": "test_file_not_found",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 467,
      "end_line_number": 473,
      "source_code": "def test_file_not_found(app, static_file_directory):\n    app.static(\"/static\", static_file_directory)\n\n    request, response = app.test_client.get(\"/static/not_found\")\n\n    assert response.status == 404\n    assert \"File not found\" in response.text",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "static_file_directory"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 404",
        "assert 'File not found' in response.text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_static_name",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 478,
      "end_line_number": 483,
      "source_code": "def test_static_name(app, static_file_directory, static_name, file_name):\n    app.static(\"/static\", static_file_directory, name=static_name)\n\n    request, response = app.test_client.get(f\"/static/{file_name}\")\n\n    assert response.status == 200",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('static_name', ['_static_name', 'static'])",
        "pytest.mark.parametrize('file_name', ['test.html'])"
      ],
      "arguments": [
        "app",
        "static_file_directory",
        "static_name",
        "file_name"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_nested_dir",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 486,
      "end_line_number": 492,
      "source_code": "def test_nested_dir(app, static_file_directory):\n    app.static(\"/static\", static_file_directory)\n\n    request, response = app.test_client.get(\"/static/nested/dir/foo.txt\")\n\n    assert response.status == 200\n    assert response.text == \"foo\\n\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "static_file_directory"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.text == 'foo\\n'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_handle_is_a_directory_error",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 495,
      "end_line_number": 508,
      "source_code": "def test_handle_is_a_directory_error(app, static_file_directory):\n    error_text = \"Is a directory. Access denied\"\n    app.static(\"/static\", static_file_directory)\n\n    @app.exception(Exception)\n    async def handleStaticDirError(request, exception):\n        if isinstance(exception, IsADirectoryError):\n            return text(error_text, status=403)\n        raise exception\n\n    request, response = app.test_client.get(\"/static/\")\n\n    assert response.status == 403\n    assert response.text == error_text",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "static_file_directory"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 403",
        "assert response.text == error_text"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.exception",
          "body": "@app.route('/')\ndef exception(request):\n    raise SanicExceptionTestException(\"You won't see me\")"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_stack_trace_on_not_found",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 511,
      "end_line_number": 523,
      "source_code": "def test_stack_trace_on_not_found(app, static_file_directory, caplog):\n    app.static(\"/static\", static_file_directory)\n\n    with caplog.at_level(logging.INFO):\n        _, response = app.test_client.get(\"/static/non_existing_file.file\")\n\n    counter = Counter([(r[0], r[1]) for r in caplog.record_tuples])\n\n    assert response.status == 404\n    assert counter[(\"sanic.root\", logging.INFO)] == 10\n    assert counter[(\"sanic.root\", logging.ERROR)] == 0\n    assert counter[(\"sanic.error\", logging.ERROR)] == 0\n    assert counter[(\"sanic.server\", logging.INFO)] == 3",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "static_file_directory",
        "caplog"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 404",
        "assert counter['sanic.root', logging.INFO] == 10",
        "assert counter['sanic.root', logging.ERROR] == 0",
        "assert counter['sanic.error', logging.ERROR] == 0",
        "assert counter['sanic.server', logging.INFO] == 3"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_no_stack_trace_on_not_found",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 526,
      "end_line_number": 543,
      "source_code": "def test_no_stack_trace_on_not_found(app, static_file_directory, caplog):\n    app.static(\"/static\", static_file_directory)\n\n    @app.exception(FileNotFound)\n    async def file_not_found(request, exception):\n        return text(f\"No file: {request.path}\", status=404)\n\n    with caplog.at_level(logging.INFO):\n        _, response = app.test_client.get(\"/static/non_existing_file.file\")\n\n    counter = Counter([(r[0], r[1]) for r in caplog.record_tuples])\n\n    assert response.status == 404\n    assert counter[(\"sanic.root\", logging.INFO)] == 10\n    assert counter[(\"sanic.root\", logging.ERROR)] == 0\n    assert counter[(\"sanic.error\", logging.ERROR)] == 0\n    assert counter[(\"sanic.server\", logging.INFO)] == 3\n    assert response.text == \"No file: /static/non_existing_file.file\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "static_file_directory",
        "caplog"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 404",
        "assert counter['sanic.root', logging.INFO] == 10",
        "assert counter['sanic.root', logging.ERROR] == 0",
        "assert counter['sanic.error', logging.ERROR] == 0",
        "assert counter['sanic.server', logging.INFO] == 3",
        "assert response.text == 'No file: /static/non_existing_file.file'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.exception",
          "body": "@app.route('/')\ndef exception(request):\n    raise SanicExceptionTestException(\"You won't see me\")"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_multiple_statics",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 558,
      "end_line_number": 576,
      "source_code": "def test_multiple_statics(app, static_file_directory):\n    app.static(\n        \"/file\", get_file_path(static_file_directory, \"test.file\"), name=\"file\"\n    )\n    app.static(\n        \"/png\", get_file_path(static_file_directory, \"python.png\"), name=\"png\"\n    )\n\n    _, response = app.test_client.get(\"/file\")\n    assert response.status == 200\n    assert response.body == get_file_content(\n        static_file_directory, \"test.file\"\n    )\n\n    _, response = app.test_client.get(\"/png\")\n    assert response.status == 200\n    assert response.body == get_file_content(\n        static_file_directory, \"python.png\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "static_file_directory"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, 'test.file')",
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, 'python.png')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ]
    },
    {
      "name": "test_resource_type_default",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 592,
      "end_line_number": 605,
      "source_code": "def test_resource_type_default(app, static_file_directory):\n    app.static(\"/static\", static_file_directory, name=\"static\")\n    app.static(\n        \"/file\", get_file_path(static_file_directory, \"test.file\"), name=\"file\"\n    )\n\n    _, response = app.test_client.get(\"/static\")\n    assert response.status == 404\n\n    _, response = app.test_client.get(\"/file\")\n    assert response.status == 200\n    assert response.body == get_file_content(\n        static_file_directory, \"test.file\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "static_file_directory"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 404",
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, 'test.file')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ]
    },
    {
      "name": "test_resource_type_file",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 608,
      "end_line_number": 622,
      "source_code": "def test_resource_type_file(app, static_file_directory):\n    app.static(\n        \"/file\",\n        get_file_path(static_file_directory, \"test.file\"),\n        resource_type=\"file\",\n    )\n\n    _, response = app.test_client.get(\"/file\")\n    assert response.status == 200\n    assert response.body == get_file_content(\n        static_file_directory, \"test.file\"\n    )\n\n    with pytest.raises(TypeError):\n        app.static(\"/static\", static_file_directory, resource_type=\"file\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "static_file_directory"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, 'test.file')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        }
      ]
    },
    {
      "name": "test_resource_type_dir",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 625,
      "end_line_number": 639,
      "source_code": "def test_resource_type_dir(app, static_file_directory):\n    app.static(\"/static\", static_file_directory, resource_type=\"dir\")\n\n    _, response = app.test_client.get(\"/static/test.file\")\n    assert response.status == 200\n    assert response.body == get_file_content(\n        static_file_directory, \"test.file\"\n    )\n\n    with pytest.raises(TypeError):\n        app.static(\n            \"/file\",\n            get_file_path(static_file_directory, \"test.file\"),\n            resource_type=\"dir\",\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "static_file_directory"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == get_file_content(static_file_directory, 'test.file')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "get_file_content",
          "body": "def get_file_content(static_file_directory: Union[Path, str], file_name: str):\n    \"\"\"The content of the static file to check\"\"\"\n    static_file_directory = path_str_to_path_obj(static_file_directory)\n    with open(static_file_directory / file_name, 'rb') as file:\n        return file.read()"
        },
        {
          "name": "get_file_path",
          "body": "def get_file_path(static_file_directory, file_name):\n    return os.path.join(static_file_directory, file_name)"
        }
      ]
    },
    {
      "name": "test_resource_type_unknown",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 642,
      "end_line_number": 644,
      "source_code": "def test_resource_type_unknown(app, static_file_directory, caplog):\n    with pytest.raises(ValueError):\n        app.static(\"/static\", static_file_directory, resource_type=\"unknown\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "static_file_directory",
        "caplog"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_dotted_dir_ok",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 651,
      "end_line_number": 660,
      "source_code": "def test_dotted_dir_ok(\n    app: Sanic, static_file_directory: str, double_dotted_directory_file: Path\n):\n    app.static(\"/foo\", static_file_directory)\n    dot_relative_path = str(\n        double_dotted_directory_file.relative_to(static_file_directory)\n    )\n    _, response = app.test_client.get(\"/foo/\" + dot_relative_path)\n    assert response.status == 200\n    assert response.body == b\"DOT\\n\"",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(sys.platform == 'win32', reason='Windows does not support double dotted directories')"
      ],
      "arguments": [
        "app",
        "static_file_directory",
        "double_dotted_directory_file"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.body == b'DOT\\n'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_breakout",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 663,
      "end_line_number": 670,
      "source_code": "def test_breakout(app: Sanic, static_file_directory: str):\n    app.static(\"/foo\", static_file_directory)\n\n    _, response = app.test_client.get(\"/foo/..%2Ffake/server.py\")\n    assert response.status == 404\n\n    _, response = app.test_client.get(\"/foo/..%2Fstatic/test.file\")\n    assert response.status == 404",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "static_file_directory"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 404",
        "assert response.status == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_double_backslash_prohibited_on_win32",
      "module": "test_static",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_static.py",
      "line_number": 676,
      "end_line_number": 684,
      "source_code": "def test_double_backslash_prohibited_on_win32(\n    app: Sanic, static_file_directory: str\n):\n    app.static(\"/foo\", static_file_directory)\n\n    _, response = app.test_client.get(\"/foo/static/..\\\\static/test.file\")\n    assert response.status == 404\n    _, response = app.test_client.get(\"/foo/static\\\\../static/test.file\")\n    assert response.status == 404",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(sys.platform != 'win32', reason='Block backslash on Windows only')"
      ],
      "arguments": [
        "app",
        "static_file_directory"
      ],
      "imports": [
        "logging",
        "os",
        "sys",
        "collections.Counter",
        "pathlib.Path",
        "time.gmtime",
        "time.strftime",
        "pytest",
        "sanic.Sanic",
        "sanic.text",
        "sanic.exceptions.FileNotFound",
        "sanic.exceptions.ServerError"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 404",
        "assert response.status == 404"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_ext_is_loaded",
      "module": "test_ext_integration",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_ext_integration.py",
      "line_number": 25,
      "end_line_number": 27,
      "source_code": "def test_ext_is_loaded(stoppable_app: Sanic, mock_sanic_ext, port):\n    stoppable_app.run(single_process=True, port=port)\n    mock_sanic_ext.Extend.assert_called_once_with(stoppable_app)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "stoppable_app",
        "mock_sanic_ext",
        "port"
      ],
      "imports": [
        "sys",
        "pytest",
        "sanic.Sanic",
        "sanic_ext"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "stoppable_app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ]
    },
    {
      "name": "test_ext_is_not_loaded",
      "module": "test_ext_integration",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_ext_integration.py",
      "line_number": 30,
      "end_line_number": 33,
      "source_code": "def test_ext_is_not_loaded(stoppable_app: Sanic, mock_sanic_ext, port):\n    stoppable_app.config.AUTO_EXTEND = False\n    stoppable_app.run(single_process=True, port=port)\n    mock_sanic_ext.Extend.assert_not_called()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "stoppable_app",
        "mock_sanic_ext",
        "port"
      ],
      "imports": [
        "sys",
        "pytest",
        "sanic.Sanic",
        "sanic_ext"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "stoppable_app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ]
    },
    {
      "name": "test_extend_with_args",
      "module": "test_ext_integration",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_ext_integration.py",
      "line_number": 36,
      "end_line_number": 41,
      "source_code": "def test_extend_with_args(stoppable_app: Sanic, mock_sanic_ext, port):\n    stoppable_app.extend(built_in_extensions=False)\n    stoppable_app.run(single_process=True, port=port)\n    mock_sanic_ext.Extend.assert_called_once_with(\n        stoppable_app, built_in_extensions=False, config=None, extensions=None\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "stoppable_app",
        "mock_sanic_ext",
        "port"
      ],
      "imports": [
        "sys",
        "pytest",
        "sanic.Sanic",
        "sanic_ext"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "stoppable_app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ]
    },
    {
      "name": "test_access_object_sets_up_extension",
      "module": "test_ext_integration",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_ext_integration.py",
      "line_number": 44,
      "end_line_number": 46,
      "source_code": "def test_access_object_sets_up_extension(app: Sanic, mock_sanic_ext):\n    app.ext\n    mock_sanic_ext.Extend.assert_called_once_with(app)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "mock_sanic_ext"
      ],
      "imports": [
        "sys",
        "pytest",
        "sanic.Sanic",
        "sanic_ext"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_extend_cannot_be_called_multiple_times",
      "module": "test_ext_integration",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_ext_integration.py",
      "line_number": 49,
      "end_line_number": 57,
      "source_code": "def test_extend_cannot_be_called_multiple_times(app: Sanic, mock_sanic_ext):\n    app.extend()\n\n    message = \"Cannot extend Sanic after Sanic Extensions has been setup.\"\n    with pytest.raises(RuntimeError, match=message):\n        app.extend()\n    mock_sanic_ext.Extend.assert_called_once_with(\n        app, extensions=None, built_in_extensions=True, config=None\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "mock_sanic_ext"
      ],
      "imports": [
        "sys",
        "pytest",
        "sanic.Sanic",
        "sanic_ext"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_fail_if_not_loaded",
      "module": "test_ext_integration",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_ext_integration.py",
      "line_number": 64,
      "end_line_number": 69,
      "source_code": "def test_fail_if_not_loaded(app: Sanic):\n    del sys.modules[\"sanic_ext\"]\n    with pytest.raises(\n        RuntimeError, match=\"Sanic Extensions is not installed.*\"\n    ):\n        app.extend(built_in_extensions=False)",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(SANIC_EXT_IN_ENV, reason='Running tests with sanic_ext already in the environment')"
      ],
      "arguments": [
        "app"
      ],
      "imports": [
        "sys",
        "pytest",
        "sanic.Sanic",
        "sanic_ext"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_can_access_app_ext_while_running",
      "module": "test_ext_integration",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_ext_integration.py",
      "line_number": 72,
      "end_line_number": 84,
      "source_code": "def test_can_access_app_ext_while_running(\n    app: Sanic, mock_sanic_ext, ext_instance, port\n):\n    class IceCream:\n        flavor: str\n\n    @app.before_server_start\n    async def injections(*_):\n        app.ext.injection(IceCream)\n        app.stop()\n\n    app.run(single_process=True, port=port)\n    ext_instance.injection.assert_called_with(IceCream)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "mock_sanic_ext",
        "ext_instance",
        "port"
      ],
      "imports": [
        "sys",
        "pytest",
        "sanic.Sanic",
        "sanic_ext"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        }
      ]
    },
    {
      "name": "test_routes_with_host",
      "module": "test_url_for",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_for.py",
      "line_number": 10,
      "end_line_number": 22,
      "source_code": "def test_routes_with_host(app):\n    @app.route(\"/\", name=\"hostindex\", host=\"example.com\")\n    @app.route(\"/path\", name=\"hostpath\", host=\"path.example.com\")\n    def index(request):\n        pass\n\n    assert app.url_for(\"hostindex\") == \"/\"\n    assert app.url_for(\"hostpath\") == \"/path\"\n    assert app.url_for(\"hostindex\", _external=True) == \"http://example.com/\"\n    assert (\n        app.url_for(\"hostpath\", _external=True)\n        == \"http://path.example.com/path\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "pytest",
        "sanic_testing.testing.SanicTestClient",
        "sanic.blueprints.Blueprint"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.url_for('hostindex') == '/'",
        "assert app.url_for('hostpath') == '/path'",
        "assert app.url_for('hostindex', _external=True) == 'http://example.com/'",
        "assert app.url_for('hostpath', _external=True) == 'http://path.example.com/path'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_routes_with_multiple_hosts",
      "module": "test_url_for",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_for.py",
      "line_number": 25,
      "end_line_number": 43,
      "source_code": "def test_routes_with_multiple_hosts(app):\n    @app.route(\"/\", name=\"hostindex\", host=[\"example.com\", \"path.example.com\"])\n    def index(request):\n        pass\n\n    assert app.url_for(\"hostindex\") == \"/\"\n    assert (\n        app.url_for(\"hostindex\", _host=\"example.com\") == \"http://example.com/\"\n    )\n\n    with pytest.raises(ValueError) as e:\n        assert app.url_for(\"hostindex\", _external=True)\n    assert str(e.value).startswith(\"Host is ambiguous\")\n\n    with pytest.raises(ValueError) as e:\n        assert app.url_for(\"hostindex\", _host=\"unknown.com\")\n    assert str(e.value).startswith(\n        \"Requested host (unknown.com) is not available for this route\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "asyncio",
        "pytest",
        "sanic_testing.testing.SanicTestClient",
        "sanic.blueprints.Blueprint"
      ],
      "fixtures": [],
      "assertions": [
        "assert app.url_for('hostindex') == '/'",
        "assert app.url_for('hostindex', _host='example.com') == 'http://example.com/'",
        "assert str(e.value).startswith('Host is ambiguous')",
        "assert str(e.value).startswith('Requested host (unknown.com) is not available for this route')",
        "assert app.url_for('hostindex', _external=True)",
        "assert app.url_for('hostindex', _host='unknown.com')"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_websocket_bp_route_name",
      "module": "test_url_for",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_for.py",
      "line_number": 54,
      "end_line_number": 83,
      "source_code": "def test_websocket_bp_route_name(app, name, expected):\n    \"\"\"Tests that blueprint websocket route is named.\"\"\"\n    event = asyncio.Event()\n    bp = Blueprint(\"test_bp\", url_prefix=\"/bp\")\n\n    @bp.get(\"/main\")\n    async def main(request): ...\n\n    @bp.websocket(\"/route\")\n    async def test_route(request, ws):\n        event.set()\n\n    @bp.websocket(\"/route2\")\n    async def test_route2(request, ws):\n        event.set()\n\n    @bp.websocket(\"/route3\", name=\"foobar_3\")\n    async def test_route3(request, ws):\n        event.set()\n\n    app.blueprint(bp)\n\n    uri = app.url_for(\"test_bp.main\")\n    assert uri == \"/bp/main\"\n\n    uri = app.url_for(f\"test_bp.{name}\")\n    assert uri == expected\n    request, response = SanicTestClient(app).websocket(uri)\n    assert response.opened is True\n    assert event.is_set()",
      "docstring": "Tests that blueprint websocket route is named.",
      "decorators": [
        "pytest.mark.parametrize('name,expected', (('test_route', '/bp/route'), ('test_route2', '/bp/route2'), ('foobar_3', '/bp/route3')))"
      ],
      "arguments": [
        "app",
        "name",
        "expected"
      ],
      "imports": [
        "asyncio",
        "pytest",
        "sanic_testing.testing.SanicTestClient",
        "sanic.blueprints.Blueprint"
      ],
      "fixtures": [],
      "assertions": [
        "assert uri == '/bp/main'",
        "assert uri == expected",
        "assert response.opened is True",
        "assert event.is_set()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "bp.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        },
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_trailing_slash_url_for",
      "module": "test_url_for",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/test_url_for.py",
      "line_number": 97,
      "end_line_number": 102,
      "source_code": "def test_trailing_slash_url_for(app, path, strict, expected):\n    @app.route(path, strict_slashes=strict)\n    def handler(*_): ...\n\n    url = app.url_for(\"handler\")\n    assert url == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('path,strict,expected', (('/foo', False, '/foo'), ('/foo/', False, '/foo'), ('/foo', True, '/foo'), ('/foo/', True, '/foo/')))"
      ],
      "arguments": [
        "app",
        "path",
        "strict",
        "expected"
      ],
      "imports": [
        "asyncio",
        "pytest",
        "sanic_testing.testing.SanicTestClient",
        "sanic.blueprints.Blueprint"
      ],
      "fixtures": [],
      "assertions": [
        "assert url == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.url_for",
          "body": "@app.route('/url-for')\ndef url_for(request):\n    return text('url-for')"
        }
      ]
    },
    {
      "name": "test_check_app_default",
      "module": "test_typing",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/typing/test_typing.py",
      "line_number": 98,
      "end_line_number": 117,
      "source_code": "def test_check_app_default(\n    path_location: str, expected: List[Tuple[str, int]]\n) -> None:\n    output = run_check(f\"samples/{path_location}\")\n\n    for text, number in expected:\n        current = CURRENT_DIR / f\"samples/{path_location}\"\n        path = current.relative_to(CURRENT_DIR.parent)\n\n        target = Path.cwd()\n        while True:\n            note = _text_from_path(current, path, target, number, text)\n            try:\n                assert note in output, output\n            except AssertionError:\n                target = target.parent\n                if not target.exists() or target == target.parent:\n                    raise\n            else:\n                break",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('path_location,expected', (('app_default.py', [('sanic.app.Sanic[sanic.config.Config, types.SimpleNamespace]', 5)]), ('app_custom_config.py', [('sanic.app.Sanic[app_custom_config.CustomConfig, types.SimpleNamespace]', 10)]), ('app_custom_ctx.py', [('sanic.app.Sanic[sanic.config.Config, app_custom_ctx.Foo]', 9)]), ('app_fully_custom.py', [('sanic.app.Sanic[app_fully_custom.CustomConfig, app_fully_custom.Foo]', 14)]), ('request_custom_sanic.py', [('types.SimpleNamespace', 18), ('sanic.app.Sanic[request_custom_sanic.CustomConfig, types.SimpleNamespace]', 19)]), ('request_custom_ctx.py', [('request_custom_ctx.Foo', 16), ('sanic.app.Sanic[sanic.config.Config, types.SimpleNamespace]', 17)]), ('request_fully_custom.py', [('request_fully_custom.CustomRequest', 32), ('request_fully_custom.RequestContext', 33), ('sanic.app.Sanic[request_fully_custom.CustomConfig, request_fully_custom.Foo]', 34)])))"
      ],
      "arguments": [
        "path_location",
        "expected"
      ],
      "imports": [
        "subprocess",
        "pathlib.Path",
        "typing.List",
        "typing.Tuple",
        "pytest"
      ],
      "fixtures": [],
      "assertions": [
        "assert note in output, output"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "run_check",
          "body": "def run_check(path_location: str) -> str:\n    \"\"\"Use mypy to check the given path location and return the output.\"\"\"\n    mypy_path = 'mypy'\n    path = CURRENT_DIR / path_location\n    command = [mypy_path, path.resolve().as_posix()]\n    process = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)\n    output = process.stdout + process.stderr\n    return output"
        },
        {
          "name": "_text_from_path",
          "body": "def _text_from_path(base: Path, path: Path, target: Path, number: int, text: str) -> str:\n    relative_to_cwd = base.relative_to(target)\n    prefix = '.'.join(relative_to_cwd.parts[:-1])\n    text = text.replace(path.stem, f'{prefix}.{path.stem}')\n    return f'{path}:{number}: note: Revealed type is \"{text}\"'"
        }
      ]
    },
    {
      "name": "test_setup_and_teardown_unix",
      "module": "test_socket",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_socket.py",
      "line_number": 10,
      "end_line_number": 17,
      "source_code": "def test_setup_and_teardown_unix():\n    socket_address = \"./test.sock\"\n    path = Path.cwd() / socket_address\n    assert not path.exists()\n    bind_unix_socket(socket_address)\n    assert path.exists()\n    remove_unix_socket(socket_address)\n    assert not path.exists()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pathlib.Path",
        "sanic.server.socket.bind_unix_socket",
        "sanic.server.socket.configure_socket",
        "sanic.server.socket.remove_unix_socket"
      ],
      "fixtures": [],
      "assertions": [
        "assert not path.exists()",
        "assert path.exists()",
        "assert not path.exists()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_configure_socket",
      "module": "test_socket",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_socket.py",
      "line_number": 20,
      "end_line_number": 27,
      "source_code": "def test_configure_socket():\n    socket_address = \"./test.sock\"\n    path = Path.cwd() / socket_address\n    assert not path.exists()\n    configure_socket({\"unix\": socket_address, \"backlog\": 100})\n    assert path.exists()\n    remove_unix_socket(socket_address)\n    assert not path.exists()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pathlib.Path",
        "sanic.server.socket.bind_unix_socket",
        "sanic.server.socket.configure_socket",
        "sanic.server.socket.remove_unix_socket"
      ],
      "fixtures": [],
      "assertions": [
        "assert not path.exists()",
        "assert path.exists()",
        "assert not path.exists()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_manager_no_workers",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 34,
      "end_line_number": 37,
      "source_code": "def test_manager_no_workers():\n    message = \"Cannot serve with no workers\"\n    with pytest.raises(RuntimeError, match=message):\n        WorkerManager(0, fake_serve, {}, Mock(), (Mock(), Mock()), {})",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_terminate",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 41,
      "end_line_number": 48,
      "source_code": "def test_terminate(os_mock: Mock):\n    process = Mock()\n    process.pid = 1234\n    context = Mock()\n    context.Process.return_value = process\n    manager = WorkerManager(1, fake_serve, {}, context, (Mock(), Mock()), {})\n    manager.terminate()\n    os_mock.kill.assert_called_once_with(1234, SIGINT)",
      "docstring": null,
      "decorators": [
        "patch('sanic.worker.process.os')"
      ],
      "arguments": [
        "os_mock"
      ],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "manager.terminate",
          "body": "def terminate(proc):\n    if flags:\n        proc.send_signal(CTRL_BREAK_EVENT)\n    else:\n        proc.terminate()"
        }
      ]
    },
    {
      "name": "test_shutown",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 52,
      "end_line_number": 60,
      "source_code": "def test_shutown(os_mock: Mock):\n    process = Mock()\n    process.pid = 1234\n    process.is_alive.return_value = True\n    context = Mock()\n    context.Process.return_value = process\n    manager = WorkerManager(1, fake_serve, {}, context, (Mock(), Mock()), {})\n    manager.shutdown()\n    os_mock.kill.assert_called_once_with(1234, SIGINT)",
      "docstring": null,
      "decorators": [
        "patch('sanic.worker.process.os')"
      ],
      "arguments": [
        "os_mock"
      ],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "manager.shutdown",
          "body": "@app.after_server_start\ndef shutdown(*_):\n    app.stop()"
        }
      ]
    },
    {
      "name": "test_kill",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 64,
      "end_line_number": 72,
      "source_code": "def test_kill(os_mock: Mock):\n    process = Mock()\n    process.pid = 1234\n    context = Mock()\n    context.Process.return_value = process\n    manager = WorkerManager(1, fake_serve, {}, context, (Mock(), Mock()), {})\n    with pytest.raises(ServerKilled):\n        manager.kill()\n    os_mock.kill.assert_called_once_with(1234, SIGKILL)",
      "docstring": null,
      "decorators": [
        "patch('sanic.worker.manager.os')"
      ],
      "arguments": [
        "os_mock"
      ],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ]
    },
    {
      "name": "test_shutdown_signal_send_kill",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 77,
      "end_line_number": 90,
      "source_code": "def test_shutdown_signal_send_kill(\n    manager_os_mock: Mock, process_os_mock: Mock\n):\n    process = Mock()\n    process.pid = 1234\n    context = Mock()\n    context.Process.return_value = process\n    manager = WorkerManager(1, fake_serve, {}, context, (Mock(), Mock()), {})\n    assert manager._shutting_down is False\n    manager.shutdown_signal(SIGINT, None)\n    assert manager._shutting_down is True\n    process_os_mock.kill.assert_called_once_with(1234, SIGINT)\n    manager.shutdown_signal(SIGINT, None)\n    manager_os_mock.kill.assert_called_once_with(1234, SIGKILL)",
      "docstring": null,
      "decorators": [
        "patch('sanic.worker.process.os')",
        "patch('sanic.worker.manager.os')"
      ],
      "arguments": [
        "manager_os_mock",
        "process_os_mock"
      ],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [
        "assert manager._shutting_down is False",
        "assert manager._shutting_down is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ]
    },
    {
      "name": "test_restart_all",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 93,
      "end_line_number": 130,
      "source_code": "def test_restart_all():\n    p1 = Mock()\n    p2 = Mock()\n    context = Mock()\n    context.Process.side_effect = [p1, p2, p1, p2]\n    manager = WorkerManager(2, fake_serve, {}, context, (Mock(), Mock()), {})\n    assert len(list(manager.transient_processes))\n    manager.restart()\n    p1.terminate.assert_called_once()\n    p2.terminate.assert_called_once()\n    context.Process.assert_has_calls(\n        [\n            call(\n                name=\"Sanic-Server-0-0\",\n                target=fake_serve,\n                kwargs={},\n                daemon=True,\n            ),\n            call(\n                name=\"Sanic-Server-1-0\",\n                target=fake_serve,\n                kwargs={},\n                daemon=True,\n            ),\n            call(\n                name=\"Sanic-Server-0-0\",\n                target=fake_serve,\n                kwargs={},\n                daemon=True,\n            ),\n            call(\n                name=\"Sanic-Server-1-0\",\n                target=fake_serve,\n                kwargs={},\n                daemon=True,\n            ),\n        ]\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(list(manager.transient_processes))"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_monitor_all",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 134,
      "end_line_number": 160,
      "source_code": "def test_monitor_all(zero_downtime):\n    p1 = Mock()\n    p2 = Mock()\n    sub = Mock()\n    incoming = (\n        \"__ALL_PROCESSES__::STARTUP_FIRST\"\n        if zero_downtime\n        else \"__ALL_PROCESSES__:\"\n    )\n    sub.recv.side_effect = [incoming, \"\"]\n    context = Mock()\n    context.Process.side_effect = [p1, p2]\n    manager = WorkerManager(2, fake_serve, {}, context, (Mock(), sub), {})\n    manager.restart = Mock()  # type: ignore\n    manager.wait_for_ack = Mock()  # type: ignore\n    manager.monitor()\n\n    restart_order = (\n        RestartOrder.STARTUP_FIRST\n        if zero_downtime\n        else RestartOrder.SHUTDOWN_FIRST\n    )\n    manager.restart.assert_called_once_with(\n        process_names=None,\n        reloaded_files=\"\",\n        restart_order=restart_order,\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('zero_downtime', (False, True))"
      ],
      "arguments": [
        "zero_downtime"
      ],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_monitor_all_with_files",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 164,
      "end_line_number": 190,
      "source_code": "def test_monitor_all_with_files(zero_downtime):\n    p1 = Mock()\n    p2 = Mock()\n    sub = Mock()\n    incoming = (\n        \"__ALL_PROCESSES__:foo,bar:STARTUP_FIRST\"\n        if zero_downtime\n        else \"__ALL_PROCESSES__:foo,bar\"\n    )\n    sub.recv.side_effect = [incoming, \"\"]\n    context = Mock()\n    context.Process.side_effect = [p1, p2]\n    manager = WorkerManager(2, fake_serve, {}, context, (Mock(), sub), {})\n    manager.restart = Mock()  # type: ignore\n    manager.wait_for_ack = Mock()  # type: ignore\n    manager.monitor()\n\n    restart_order = (\n        RestartOrder.STARTUP_FIRST\n        if zero_downtime\n        else RestartOrder.SHUTDOWN_FIRST\n    )\n    manager.restart.assert_called_once_with(\n        process_names=None,\n        reloaded_files=\"foo,bar\",\n        restart_order=restart_order,\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('zero_downtime', (False, True))"
      ],
      "arguments": [
        "zero_downtime"
      ],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_monitor_one_process",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 194,
      "end_line_number": 221,
      "source_code": "def test_monitor_one_process(zero_downtime):\n    p1 = Mock()\n    p1.name = \"Testing\"\n    p2 = Mock()\n    sub = Mock()\n    incoming = (\n        f\"{p1.name}:foo,bar:STARTUP_FIRST\"\n        if zero_downtime\n        else f\"{p1.name}:foo,bar\"\n    )\n    sub.recv.side_effect = [incoming, \"\"]\n    context = Mock()\n    context.Process.side_effect = [p1, p2]\n    manager = WorkerManager(2, fake_serve, {}, context, (Mock(), sub), {})\n    manager.restart = Mock()  # type: ignore\n    manager.wait_for_ack = Mock()  # type: ignore\n    manager.monitor()\n\n    restart_order = (\n        RestartOrder.STARTUP_FIRST\n        if zero_downtime\n        else RestartOrder.SHUTDOWN_FIRST\n    )\n    manager.restart.assert_called_once_with(\n        process_names=[p1.name],\n        reloaded_files=\"foo,bar\",\n        restart_order=restart_order,\n    )",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('zero_downtime', (False, True))"
      ],
      "arguments": [
        "zero_downtime"
      ],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_shutdown_signal",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 224,
      "end_line_number": 231,
      "source_code": "def test_shutdown_signal():\n    pub = Mock()\n    manager = WorkerManager(1, fake_serve, {}, Mock(), (pub, Mock()), {})\n    manager.shutdown = Mock()  # type: ignore\n\n    manager.shutdown_signal(SIGINT, None)\n    pub.send.assert_called_with(None)\n    manager.shutdown.assert_called_once_with()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_shutdown_servers",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 234,
      "end_line_number": 259,
      "source_code": "def test_shutdown_servers(caplog):\n    p1 = Mock()\n    p1.pid = 1234\n    context = Mock()\n    context.Process.side_effect = [p1]\n    pub = Mock()\n    manager = WorkerManager(1, fake_serve, {}, context, (pub, Mock()), {})\n\n    with patch(\"os.kill\") as kill:\n        with caplog.at_level(ERROR):\n            manager.shutdown_server()\n\n            kill.assert_called_once_with(1234, SIGINT)\n            kill.reset_mock()\n\n            assert not caplog.record_tuples\n\n            manager.shutdown_server()\n\n            kill.assert_not_called()\n\n            assert (\n                \"sanic.error\",\n                ERROR,\n                \"Server shutdown failed because a server was not found.\",\n            ) in caplog.record_tuples",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "caplog"
      ],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [
        "assert not caplog.record_tuples",
        "assert ('sanic.error', ERROR, 'Server shutdown failed because a server was not found.') in caplog.record_tuples"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "kill.reset_mock",
          "body": "def reset_mock(self, *args, **kwargs):\n    super().reset_mock(*args, **kwargs)\n    self.await_count = 0"
        }
      ]
    },
    {
      "name": "test_shutdown_servers_named",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 262,
      "end_line_number": 277,
      "source_code": "def test_shutdown_servers_named():\n    p1 = Mock()\n    p1.pid = 1234\n    p2 = Mock()\n    p2.pid = 6543\n    context = Mock()\n    context.Process.side_effect = [p1, p2]\n    pub = Mock()\n    manager = WorkerManager(2, fake_serve, {}, context, (pub, Mock()), {})\n\n    with patch(\"os.kill\") as kill:\n        with pytest.raises(KeyError):\n            manager.shutdown_server(\"foo\")\n        manager.shutdown_server(\"Server-1\")\n\n        kill.assert_called_once_with(6543, SIGINT)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ]
    },
    {
      "name": "test_scale",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 280,
      "end_line_number": 316,
      "source_code": "def test_scale(caplog):\n    p1 = Mock()\n    p1.pid = 1234\n    p2 = Mock()\n    p2.pid = 3456\n    p3 = Mock()\n    p3.pid = 5678\n    context = Mock()\n    context.Process.side_effect = [p1, p2, p3]\n    pub = Mock()\n    manager = WorkerManager(1, fake_serve, {}, context, (pub, Mock()), {})\n\n    assert len(manager.transient) == 1\n\n    manager.scale(3)\n    assert len(manager.transient) == 3\n\n    with patch(\"os.kill\") as kill:\n        manager.scale(2)\n        assert len(manager.transient) == 2\n\n        manager.scale(1)\n        assert len(manager.transient) == 1\n\n        kill.call_count == 2\n\n    with caplog.at_level(INFO):\n        manager.scale(1)\n\n    assert (\n        \"sanic.root\",\n        INFO,\n        \"No change needed. There are already 1 workers.\",\n    ) in caplog.record_tuples\n\n    with pytest.raises(ValueError, match=r\"Cannot scale to 0 workers\\.\"):\n        manager.scale(0)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "caplog"
      ],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(manager.transient) == 1",
        "assert len(manager.transient) == 3",
        "assert ('sanic.root', INFO, 'No change needed. There are already 1 workers.') in caplog.record_tuples",
        "assert len(manager.transient) == 2",
        "assert len(manager.transient) == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ]
    },
    {
      "name": "test_manage_basic",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 319,
      "end_line_number": 333,
      "source_code": "def test_manage_basic(manager: WorkerManager):\n    assert len(manager.transient) == 1\n    assert len(manager.durable) == 0\n    manager.manage(\"TEST\", fake_serve, kwargs={\"foo\": \"bar\"})\n    assert len(manager.transient) == 1\n    assert len(manager.durable) == 1\n\n    worker_process = manager.durable[\"TEST\"]\n\n    assert isinstance(worker_process, Worker)\n    assert worker_process.server_settings == {\"foo\": \"bar\"}\n    assert worker_process.restartable is False\n    assert worker_process.tracked is True\n    assert worker_process.auto_start is True\n    assert worker_process.num == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "manager"
      ],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(manager.transient) == 1",
        "assert len(manager.durable) == 0",
        "assert len(manager.transient) == 1",
        "assert len(manager.durable) == 1",
        "assert isinstance(worker_process, Worker)",
        "assert worker_process.server_settings == {'foo': 'bar'}",
        "assert worker_process.restartable is False",
        "assert worker_process.tracked is True",
        "assert worker_process.auto_start is True",
        "assert worker_process.num == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_manage_transient",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 336,
      "end_line_number": 349,
      "source_code": "def test_manage_transient(manager: WorkerManager):\n    manager.manage(\n        \"TEST\", fake_serve, kwargs={\"foo\": \"bar\"}, workers=3, transient=True\n    )\n    assert len(manager.transient) == 2\n    assert len(manager.durable) == 0\n\n    worker_process = manager.transient[\"TEST\"]\n\n    assert isinstance(worker_process, Worker)\n    assert worker_process.restartable is True\n    assert worker_process.tracked is True\n    assert worker_process.auto_start is True\n    assert worker_process.num == 3",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "manager"
      ],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(manager.transient) == 2",
        "assert len(manager.durable) == 0",
        "assert isinstance(worker_process, Worker)",
        "assert worker_process.restartable is True",
        "assert worker_process.tracked is True",
        "assert worker_process.auto_start is True",
        "assert worker_process.num == 3"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_manage_restartable",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 352,
      "end_line_number": 368,
      "source_code": "def test_manage_restartable(manager: WorkerManager):\n    manager.manage(\n        \"TEST\",\n        fake_serve,\n        kwargs={\"foo\": \"bar\"},\n        restartable=True,\n        auto_start=False,\n    )\n    assert len(manager.transient) == 1\n    assert len(manager.durable) == 1\n\n    worker_process = manager.durable[\"TEST\"]\n\n    assert isinstance(worker_process, Worker)\n    assert worker_process.restartable is True\n    assert worker_process.tracked is True\n    assert worker_process.auto_start is False",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "manager"
      ],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(manager.transient) == 1",
        "assert len(manager.durable) == 1",
        "assert isinstance(worker_process, Worker)",
        "assert worker_process.restartable is True",
        "assert worker_process.tracked is True",
        "assert worker_process.auto_start is False"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_manage_untracked",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 371,
      "end_line_number": 381,
      "source_code": "def test_manage_untracked(manager: WorkerManager):\n    manager.manage(\"TEST\", fake_serve, kwargs={\"foo\": \"bar\"}, tracked=False)\n    assert len(manager.transient) == 1\n    assert len(manager.durable) == 1\n\n    worker_process = manager.durable[\"TEST\"]\n\n    assert isinstance(worker_process, Worker)\n    assert worker_process.restartable is False\n    assert worker_process.tracked is False\n    assert worker_process.auto_start is True",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "manager"
      ],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(manager.transient) == 1",
        "assert len(manager.durable) == 1",
        "assert isinstance(worker_process, Worker)",
        "assert worker_process.restartable is False",
        "assert worker_process.tracked is False",
        "assert worker_process.auto_start is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_manage_duplicate_ident",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 384,
      "end_line_number": 388,
      "source_code": "def test_manage_duplicate_ident(manager: WorkerManager):\n    manager.manage(\"TEST\", fake_serve, kwargs={\"foo\": \"bar\"})\n    message = \"Worker TEST already exists\"\n    with pytest.raises(ValueError, match=message):\n        manager.manage(\"TEST\", fake_serve, kwargs={\"foo\": \"bar\"})",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "manager"
      ],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_transient_not_restartable",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 391,
      "end_line_number": 400,
      "source_code": "def test_transient_not_restartable(manager: WorkerManager):\n    message = \"Cannot create a transient worker that is not restartable\"\n    with pytest.raises(ValueError, match=message):\n        manager.manage(\n            \"TEST\",\n            fake_serve,\n            kwargs={\"foo\": \"bar\"},\n            transient=True,\n            restartable=False,\n        )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "manager"
      ],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_remove_worker",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 403,
      "end_line_number": 416,
      "source_code": "def test_remove_worker(manager: WorkerManager, caplog):\n    worker = manager.manage(\"TEST\", fake_serve, kwargs={})\n\n    assert \"Sanic-TEST-0\" in worker.worker_state\n    assert len(manager.transient) == 1\n    assert len(manager.durable) == 1\n\n    manager.remove_worker(worker)\n    message = \"Worker TEST is tracked and cannot be removed.\"\n\n    assert \"Sanic-TEST-0\" in worker.worker_state\n    assert len(manager.transient) == 1\n    assert len(manager.durable) == 1\n    assert (\"sanic.error\", 40, message) in caplog.record_tuples",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "manager",
        "caplog"
      ],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'Sanic-TEST-0' in worker.worker_state",
        "assert len(manager.transient) == 1",
        "assert len(manager.durable) == 1",
        "assert 'Sanic-TEST-0' in worker.worker_state",
        "assert len(manager.transient) == 1",
        "assert len(manager.durable) == 1",
        "assert ('sanic.error', 40, message) in caplog.record_tuples"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_remove_untracked_worker",
      "module": "test_manager",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
      "line_number": 419,
      "end_line_number": 443,
      "source_code": "def test_remove_untracked_worker(manager: WorkerManager, caplog):\n    caplog.set_level(20)\n    worker = manager.manage(\"TEST\", fake_serve, kwargs={}, tracked=False)\n    worker.has_alive_processes = Mock(return_value=True)\n\n    assert \"Sanic-TEST-0\" in worker.worker_state\n    assert len(manager.transient) == 1\n    assert len(manager.durable) == 1\n\n    manager.remove_worker(worker)\n    message = \"Worker TEST has alive processes and cannot be removed.\"\n\n    assert \"Sanic-TEST-0\" in worker.worker_state\n    assert len(manager.transient) == 1\n    assert len(manager.durable) == 1\n    assert (\"sanic.error\", 40, message) in caplog.record_tuples\n\n    worker.has_alive_processes = Mock(return_value=False)\n    manager.remove_worker(worker)\n    message = \"Removed worker TEST\"\n\n    assert \"Sanic-TEST-0\" not in worker.worker_state\n    assert len(manager.transient) == 1\n    assert len(manager.durable) == 0\n    assert (\"sanic.root\", 20, message) in caplog.record_tuples",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "manager",
        "caplog"
      ],
      "imports": [
        "logging.ERROR",
        "logging.INFO",
        "signal.SIGINT",
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.compat.OS_IS_WINDOWS",
        "sanic.exceptions.ServerKilled",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.manager.WorkerManager",
        "sanic.worker.process.Worker",
        "signal.SIGKILL"
      ],
      "fixtures": [],
      "assertions": [
        "assert 'Sanic-TEST-0' in worker.worker_state",
        "assert len(manager.transient) == 1",
        "assert len(manager.durable) == 1",
        "assert 'Sanic-TEST-0' in worker.worker_state",
        "assert len(manager.transient) == 1",
        "assert len(manager.durable) == 1",
        "assert ('sanic.error', 40, message) in caplog.record_tuples",
        "assert 'Sanic-TEST-0' not in worker.worker_state",
        "assert len(manager.transient) == 1",
        "assert len(manager.durable) == 0",
        "assert ('sanic.root', 20, message) in caplog.record_tuples"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_set_get_state",
      "module": "test_state",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_state.py",
      "line_number": 10,
      "end_line_number": 15,
      "source_code": "def test_set_get_state():\n    state = gen_state()\n    state[\"additional\"] = 123\n    assert state[\"additional\"] == 123\n    assert state.get(\"additional\") == 123\n    assert state._state == {\"foo\": {\"additional\": 123}}",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [
        "assert state['additional'] == 123",
        "assert state.get('additional') == 123",
        "assert state._state == {'foo': {'additional': 123}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "gen_state",
          "body": "def gen_state(**kwargs):\n    return WorkerState({'foo': kwargs}, 'foo')"
        },
        {
          "name": "state.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_del_state",
      "module": "test_state",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_state.py",
      "line_number": 18,
      "end_line_number": 22,
      "source_code": "def test_del_state():\n    state = gen_state(one=1)\n    assert state[\"one\"] == 1\n    del state[\"one\"]\n    assert state._state == {\"foo\": {}}",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [
        "assert state['one'] == 1",
        "assert state._state == {'foo': {}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "gen_state",
          "body": "def gen_state(**kwargs):\n    return WorkerState({'foo': kwargs}, 'foo')"
        }
      ]
    },
    {
      "name": "test_iter_state",
      "module": "test_state",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_state.py",
      "line_number": 25,
      "end_line_number": 27,
      "source_code": "def test_iter_state():\n    result = [item for item in gen_state(one=1, two=2)]\n    assert result == [\"one\", \"two\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [
        "assert result == ['one', 'two']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "gen_state",
          "body": "def gen_state(**kwargs):\n    return WorkerState({'foo': kwargs}, 'foo')"
        }
      ]
    },
    {
      "name": "test_state_len",
      "module": "test_state",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_state.py",
      "line_number": 30,
      "end_line_number": 32,
      "source_code": "def test_state_len():\n    result = [item for item in gen_state(one=1, two=2)]\n    assert len(result) == 2",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(result) == 2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "gen_state",
          "body": "def gen_state(**kwargs):\n    return WorkerState({'foo': kwargs}, 'foo')"
        }
      ]
    },
    {
      "name": "test_state_repr",
      "module": "test_state",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_state.py",
      "line_number": 35,
      "end_line_number": 36,
      "source_code": "def test_state_repr():\n    assert repr(gen_state(one=1, two=2)) == repr({\"one\": 1, \"two\": 2})",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [
        "assert repr(gen_state(one=1, two=2)) == repr({'one': 1, 'two': 2})"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "gen_state",
          "body": "def gen_state(**kwargs):\n    return WorkerState({'foo': kwargs}, 'foo')"
        }
      ]
    },
    {
      "name": "test_state_eq",
      "module": "test_state",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_state.py",
      "line_number": 39,
      "end_line_number": 42,
      "source_code": "def test_state_eq():\n    state = gen_state(one=1, two=2)\n    assert state == {\"one\": 1, \"two\": 2}\n    assert state != {\"one\": 1}",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [
        "assert state == {'one': 1, 'two': 2}",
        "assert state != {'one': 1}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "gen_state",
          "body": "def gen_state(**kwargs):\n    return WorkerState({'foo': kwargs}, 'foo')"
        }
      ]
    },
    {
      "name": "test_state_keys",
      "module": "test_state",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_state.py",
      "line_number": 45,
      "end_line_number": 48,
      "source_code": "def test_state_keys():\n    assert list(gen_state(one=1, two=2).keys()) == list(\n        {\"one\": 1, \"two\": 2}.keys()\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [
        "assert list(gen_state(one=1, two=2).keys()) == list({'one': 1, 'two': 2}.keys())"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "gen_state",
          "body": "def gen_state(**kwargs):\n    return WorkerState({'foo': kwargs}, 'foo')"
        }
      ]
    },
    {
      "name": "test_state_values",
      "module": "test_state",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_state.py",
      "line_number": 51,
      "end_line_number": 54,
      "source_code": "def test_state_values():\n    assert list(gen_state(one=1, two=2).values()) == list(\n        {\"one\": 1, \"two\": 2}.values()\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [
        "assert list(gen_state(one=1, two=2).values()) == list({'one': 1, 'two': 2}.values())"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "gen_state",
          "body": "def gen_state(**kwargs):\n    return WorkerState({'foo': kwargs}, 'foo')"
        }
      ]
    },
    {
      "name": "test_state_items",
      "module": "test_state",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_state.py",
      "line_number": 57,
      "end_line_number": 60,
      "source_code": "def test_state_items():\n    assert list(gen_state(one=1, two=2).items()) == list(\n        {\"one\": 1, \"two\": 2}.items()\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [
        "assert list(gen_state(one=1, two=2).items()) == list({'one': 1, 'two': 2}.items())"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "gen_state",
          "body": "def gen_state(**kwargs):\n    return WorkerState({'foo': kwargs}, 'foo')"
        }
      ]
    },
    {
      "name": "test_state_update",
      "module": "test_state",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_state.py",
      "line_number": 63,
      "end_line_number": 68,
      "source_code": "def test_state_update():\n    state = gen_state()\n    assert len(state) == 0\n    state.update({\"nine\": 9})\n    assert len(state) == 1\n    assert state[\"nine\"] == 9",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(state) == 0",
        "assert len(state) == 1",
        "assert state['nine'] == 9"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "gen_state",
          "body": "def gen_state(**kwargs):\n    return WorkerState({'foo': kwargs}, 'foo')"
        }
      ]
    },
    {
      "name": "test_state_pop",
      "module": "test_state",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_state.py",
      "line_number": 71,
      "end_line_number": 74,
      "source_code": "def test_state_pop():\n    state = gen_state(one=1)\n    with pytest.raises(NotImplementedError):\n        state.pop()",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "gen_state",
          "body": "def gen_state(**kwargs):\n    return WorkerState({'foo': kwargs}, 'foo')"
        }
      ]
    },
    {
      "name": "test_state_full",
      "module": "test_state",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_state.py",
      "line_number": 77,
      "end_line_number": 79,
      "source_code": "def test_state_full():\n    state = gen_state(one=1)\n    assert state.full() == {\"foo\": {\"one\": 1}}",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "pytest",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [
        "assert state.full() == {'foo': {'one': 1}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "gen_state",
          "body": "def gen_state(**kwargs):\n    return WorkerState({'foo': kwargs}, 'foo')"
        }
      ]
    },
    {
      "name": "test_state_restricted_operation",
      "module": "test_state",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_state.py",
      "line_number": 83,
      "end_line_number": 91,
      "source_code": "def test_state_restricted_operation(key):\n    state = gen_state()\n    message = f\"Cannot set restricted key on WorkerState: {key}\"\n    with pytest.raises(LookupError, match=message):\n        state[key] = \"Nope\"\n        del state[key]\n\n    with pytest.raises(LookupError, match=message):\n        state.update({\"okay\": True, key: \"bad\"})",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('key', WorkerState.RESTRICTED)"
      ],
      "arguments": [
        "key"
      ],
      "imports": [
        "pytest",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "gen_state",
          "body": "def gen_state(**kwargs):\n    return WorkerState({'foo': kwargs}, 'foo')"
        }
      ]
    },
    {
      "name": "test_config_app",
      "module": "test_worker_serve",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_worker_serve.py",
      "line_number": 37,
      "end_line_number": 40,
      "source_code": "def test_config_app(mock_app: Mock):\n    with patch(\"sanic.worker.serve._serve_http_1\"):\n        worker_serve(**args(mock_app, config={\"FOO\": \"BAR\"}))\n    mock_app.update_config.assert_called_once_with({\"FOO\": \"BAR\"})",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "mock_app"
      ],
      "imports": [
        "logging",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.multiplexer.WorkerMultiplexer",
        "sanic.worker.process.Worker",
        "sanic.worker.process.WorkerProcess",
        "sanic.worker.serve.worker_serve"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "args",
          "body": "def args(app, **kwargs):\n    params = {**kwargs}\n    params.setdefault('host', '127.0.0.1')\n    params.setdefault('port', 9999)\n    params.setdefault('app_name', 'test_config_app')\n    params.setdefault('monitor_publisher', None)\n    params.setdefault('app_loader', AppLoader(factory=lambda : app))\n    return params"
        }
      ]
    },
    {
      "name": "test_bad_process",
      "module": "test_worker_serve",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_worker_serve.py",
      "line_number": 43,
      "end_line_number": 60,
      "source_code": "def test_bad_process(mock_app: Mock, caplog):\n    environ[\"SANIC_WORKER_NAME\"] = (\n        f\"{Worker.WORKER_PREFIX}-{WorkerProcess.SERVER_LABEL}-FOO\"\n    )\n\n    message = \"No restart publisher found in worker process\"\n    with pytest.raises(RuntimeError, match=message):\n        worker_serve(**args(mock_app))\n\n    message = \"No worker state found in worker process\"\n    publisher = Mock()\n    with caplog.at_level(logging.ERROR):\n        worker_serve(**args(mock_app, monitor_publisher=publisher))\n\n    assert (\"sanic.error\", logging.ERROR, message) in caplog.record_tuples\n    publisher.send.assert_called_once_with(\"__TERMINATE_EARLY__\")\n\n    del environ[\"SANIC_WORKER_NAME\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "mock_app",
        "caplog"
      ],
      "imports": [
        "logging",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.multiplexer.WorkerMultiplexer",
        "sanic.worker.process.Worker",
        "sanic.worker.process.WorkerProcess",
        "sanic.worker.serve.worker_serve"
      ],
      "fixtures": [],
      "assertions": [
        "assert ('sanic.error', logging.ERROR, message) in caplog.record_tuples"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "args",
          "body": "def args(app, **kwargs):\n    params = {**kwargs}\n    params.setdefault('host', '127.0.0.1')\n    params.setdefault('port', 9999)\n    params.setdefault('app_name', 'test_config_app')\n    params.setdefault('monitor_publisher', None)\n    params.setdefault('app_loader', AppLoader(factory=lambda : app))\n    return params"
        },
        {
          "name": "args",
          "body": "def args(app, **kwargs):\n    params = {**kwargs}\n    params.setdefault('host', '127.0.0.1')\n    params.setdefault('port', 9999)\n    params.setdefault('app_name', 'test_config_app')\n    params.setdefault('monitor_publisher', None)\n    params.setdefault('app_loader', AppLoader(factory=lambda : app))\n    return params"
        }
      ]
    },
    {
      "name": "test_has_multiplexer",
      "module": "test_worker_serve",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_worker_serve.py",
      "line_number": 63,
      "end_line_number": 75,
      "source_code": "def test_has_multiplexer(app: Sanic):\n    environ[\"SANIC_WORKER_NAME\"] = (\n        f\"{Worker.WORKER_PREFIX}-{WorkerProcess.SERVER_LABEL}-FOO\"\n    )\n\n    Sanic.register_app(app)\n    with patch(\"sanic.worker.serve._serve_http_1\"):\n        worker_serve(\n            **args(app, monitor_publisher=Mock(), worker_state=Mock())\n        )\n    assert isinstance(app.multiplexer, WorkerMultiplexer)\n\n    del environ[\"SANIC_WORKER_NAME\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "logging",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.multiplexer.WorkerMultiplexer",
        "sanic.worker.process.Worker",
        "sanic.worker.process.WorkerProcess",
        "sanic.worker.serve.worker_serve"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(app.multiplexer, WorkerMultiplexer)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "args",
          "body": "def args(app, **kwargs):\n    params = {**kwargs}\n    params.setdefault('host', '127.0.0.1')\n    params.setdefault('port', 9999)\n    params.setdefault('app_name', 'test_config_app')\n    params.setdefault('monitor_publisher', None)\n    params.setdefault('app_loader', AppLoader(factory=lambda : app))\n    return params"
        }
      ]
    },
    {
      "name": "test_serve_app_implicit",
      "module": "test_worker_serve",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_worker_serve.py",
      "line_number": 79,
      "end_line_number": 82,
      "source_code": "def test_serve_app_implicit(wm: Mock, app):\n    app.prepare()\n    Sanic.serve()\n    wm.call_args[0] == app.state.workers",
      "docstring": null,
      "decorators": [
        "patch('sanic.mixins.startup.WorkerManager')"
      ],
      "arguments": [
        "wm",
        "app"
      ],
      "imports": [
        "logging",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.multiplexer.WorkerMultiplexer",
        "sanic.worker.process.Worker",
        "sanic.worker.process.WorkerProcess",
        "sanic.worker.serve.worker_serve"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ]
    },
    {
      "name": "test_serve_app_explicit",
      "module": "test_worker_serve",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_worker_serve.py",
      "line_number": 86,
      "end_line_number": 88,
      "source_code": "def test_serve_app_explicit(wm: Mock, mock_app):\n    Sanic.serve(mock_app)\n    wm.call_args[0] == mock_app.state.workers",
      "docstring": null,
      "decorators": [
        "patch('sanic.mixins.startup.WorkerManager')"
      ],
      "arguments": [
        "wm",
        "mock_app"
      ],
      "imports": [
        "logging",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.multiplexer.WorkerMultiplexer",
        "sanic.worker.process.Worker",
        "sanic.worker.process.WorkerProcess",
        "sanic.worker.serve.worker_serve"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ]
    },
    {
      "name": "test_serve_app_loader",
      "module": "test_worker_serve",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_worker_serve.py",
      "line_number": 92,
      "end_line_number": 94,
      "source_code": "def test_serve_app_loader(wm: Mock, mock_app):\n    Sanic.serve(app_loader=AppLoader(factory=lambda: mock_app))\n    wm.call_args[0] == mock_app.state.workers",
      "docstring": null,
      "decorators": [
        "patch('sanic.mixins.startup.WorkerManager')"
      ],
      "arguments": [
        "wm",
        "mock_app"
      ],
      "imports": [
        "logging",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.multiplexer.WorkerMultiplexer",
        "sanic.worker.process.Worker",
        "sanic.worker.process.WorkerProcess",
        "sanic.worker.serve.worker_serve"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ]
    },
    {
      "name": "test_serve_app_factory",
      "module": "test_worker_serve",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_worker_serve.py",
      "line_number": 99,
      "end_line_number": 101,
      "source_code": "def test_serve_app_factory(wm: Mock, mock_app):\n    Sanic.serve(factory=lambda: mock_app)\n    wm.call_args[0] == mock_app.state.workers",
      "docstring": null,
      "decorators": [
        "patch('sanic.mixins.startup.WorkerManager')"
      ],
      "arguments": [
        "wm",
        "mock_app"
      ],
      "imports": [
        "logging",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.multiplexer.WorkerMultiplexer",
        "sanic.worker.process.Worker",
        "sanic.worker.process.WorkerProcess",
        "sanic.worker.serve.worker_serve"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ]
    },
    {
      "name": "test_serve_with_inspector",
      "module": "test_worker_serve",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_worker_serve.py",
      "line_number": 106,
      "end_line_number": 125,
      "source_code": "def test_serve_with_inspector(\n    WorkerManager: Mock, mock_app: Mock, config: bool\n):\n    Inspector = Mock()\n    mock_app.config.INSPECTOR = config\n    mock_app.inspector_class = Inspector\n    inspector = Mock()\n    Inspector.return_value = inspector\n    WorkerManager.return_value = WorkerManager\n\n    Sanic.serve(mock_app)\n\n    if config:\n        Inspector.assert_called_once()\n        WorkerManager.manage.assert_called_once_with(\n            \"Inspector\", inspector, {}, transient=False\n        )\n    else:\n        Inspector.assert_not_called()\n        WorkerManager.manage.assert_not_called()",
      "docstring": null,
      "decorators": [
        "patch('sanic.mixins.startup.WorkerManager')",
        "pytest.mark.parametrize('config', (True, False))"
      ],
      "arguments": [
        "WorkerManager",
        "mock_app",
        "config"
      ],
      "imports": [
        "logging",
        "os.environ",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.multiplexer.WorkerMultiplexer",
        "sanic.worker.process.Worker",
        "sanic.worker.process.WorkerProcess",
        "sanic.worker.serve.worker_serve"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ]
    },
    {
      "name": "test_load_app_instance",
      "module": "test_loader",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_loader.py",
      "line_number": 20,
      "end_line_number": 23,
      "source_code": "def test_load_app_instance(module_input):\n    loader = AppLoader(module_input)\n    app = loader.load()\n    assert isinstance(app, Sanic)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('module_input', ('tests.fake.server:app', 'tests.fake.server.app'))"
      ],
      "arguments": [
        "module_input"
      ],
      "imports": [
        "sys",
        "os.getcwd",
        "pathlib.Path",
        "types.SimpleNamespace",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(app, Sanic)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "loader.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        }
      ]
    },
    {
      "name": "test_load_app_factory",
      "module": "test_loader",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_loader.py",
      "line_number": 30,
      "end_line_number": 33,
      "source_code": "def test_load_app_factory(module_input):\n    loader = AppLoader(module_input, as_factory=True)\n    app = loader.load()\n    assert isinstance(app, Sanic)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('module_input', ('tests.fake.server:create_app', 'tests.fake.server:create_app()'))"
      ],
      "arguments": [
        "module_input"
      ],
      "imports": [
        "sys",
        "os.getcwd",
        "pathlib.Path",
        "types.SimpleNamespace",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(app, Sanic)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "loader.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        }
      ]
    },
    {
      "name": "test_load_app_simple",
      "module": "test_loader",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_loader.py",
      "line_number": 36,
      "end_line_number": 39,
      "source_code": "def test_load_app_simple():\n    loader = AppLoader(str(STATIC), as_simple=True)\n    app = loader.load()\n    assert isinstance(app, Sanic)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "sys",
        "os.getcwd",
        "pathlib.Path",
        "types.SimpleNamespace",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(app, Sanic)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "loader.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        }
      ]
    },
    {
      "name": "test_create_with_factory",
      "module": "test_loader",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_loader.py",
      "line_number": 42,
      "end_line_number": 45,
      "source_code": "def test_create_with_factory():\n    loader = AppLoader(factory=lambda: Sanic(\"Test\"))\n    app = loader.load()\n    assert isinstance(app, Sanic)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "sys",
        "os.getcwd",
        "pathlib.Path",
        "types.SimpleNamespace",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(app, Sanic)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "loader.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        }
      ]
    },
    {
      "name": "test_cwd_in_path",
      "module": "test_loader",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_loader.py",
      "line_number": 48,
      "end_line_number": 50,
      "source_code": "def test_cwd_in_path():\n    AppLoader(\"tests.fake.server:app\").load()\n    assert getcwd() in sys.path",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "sys",
        "os.getcwd",
        "pathlib.Path",
        "types.SimpleNamespace",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert getcwd() in sys.path"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_input_is_dir",
      "module": "test_loader",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_loader.py",
      "line_number": 53,
      "end_line_number": 56,
      "source_code": "def test_input_is_dir():\n    loader = AppLoader(str(STATIC))\n    app = loader.load()\n    assert isinstance(app, Sanic)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "sys",
        "os.getcwd",
        "pathlib.Path",
        "types.SimpleNamespace",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(app, Sanic)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "loader.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        }
      ]
    },
    {
      "name": "test_input_is_factory",
      "module": "test_loader",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_loader.py",
      "line_number": 59,
      "end_line_number": 63,
      "source_code": "def test_input_is_factory():\n    ns = SimpleNamespace(target=\"foo\")\n    loader = AppLoader(\"tests.fake.server:create_app\", args=ns)\n    app = loader.load()\n    assert isinstance(app, Sanic)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "sys",
        "os.getcwd",
        "pathlib.Path",
        "types.SimpleNamespace",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(app, Sanic)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "loader.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        }
      ]
    },
    {
      "name": "test_input_is_module",
      "module": "test_loader",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_loader.py",
      "line_number": 66,
      "end_line_number": 71,
      "source_code": "def test_input_is_module():\n    ns = SimpleNamespace(target=\"foo\")\n    loader = AppLoader(\"tests.fake.server\", args=ns)\n\n    app = loader.load()\n    assert isinstance(app, Sanic)",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "sys",
        "os.getcwd",
        "pathlib.Path",
        "types.SimpleNamespace",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(app, Sanic)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "loader.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        }
      ]
    },
    {
      "name": "test_cert_loader",
      "module": "test_loader",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_loader.py",
      "line_number": 77,
      "end_line_number": 95,
      "source_code": "def test_cert_loader(MkcertCreator: Mock, TrustmeCreator: Mock, creator: str):\n    CertLoader._creators = {\n        \"mkcert\": MkcertCreator,\n        \"trustme\": TrustmeCreator,\n    }\n    MkcertCreator.return_value = MkcertCreator\n    TrustmeCreator.return_value = TrustmeCreator\n    data = {\n        \"creator\": creator,\n        \"key\": Path.cwd() / \"tests\" / \"certs\" / \"localhost\" / \"privkey.pem\",\n        \"cert\": Path.cwd() / \"tests\" / \"certs\" / \"localhost\" / \"fullchain.pem\",\n        \"localhost\": \"localhost\",\n    }\n    app = Sanic(\"Test\")\n    loader = CertLoader(data)  # type: ignore\n    loader.load(app)\n    creator_class = MkcertCreator if creator == \"mkcert\" else TrustmeCreator\n    creator_class.assert_called_once_with(app, data[\"key\"], data[\"cert\"])\n    creator_class.generate_cert.assert_called_once_with(\"localhost\")",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('creator', ('mkcert', 'trustme'))",
        "patch('sanic.worker.loader.TrustmeCreator')",
        "patch('sanic.worker.loader.MkcertCreator')"
      ],
      "arguments": [
        "MkcertCreator",
        "TrustmeCreator",
        "creator"
      ],
      "imports": [
        "sys",
        "os.getcwd",
        "pathlib.Path",
        "types.SimpleNamespace",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.loader.CertLoader"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "loader.load",
          "body": "def load(self, app: Sanic):\n    self._ssl_data = {'key': localhost_key, 'cert': localhost_cert}\n    return super().load(app)"
        }
      ]
    },
    {
      "name": "test_run_http_1",
      "module": "test_runner",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_runner.py",
      "line_number": 12,
      "end_line_number": 15,
      "source_code": "def test_run_http_1(_serve_http_3: Mock, _serve_http_1: Mock, app: Sanic):\n    serve(\"\", 0, app)\n    _serve_http_3.assert_not_called()\n    _serve_http_1.assert_called_once()",
      "docstring": null,
      "decorators": [
        "patch('sanic.server.runners._serve_http_1')",
        "patch('sanic.server.runners._serve_http_3')"
      ],
      "arguments": [
        "_serve_http_3",
        "_serve_http_1",
        "app"
      ],
      "imports": [
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.app.Sanic",
        "sanic.http.constants.HTTP",
        "sanic.server.runners._run_server_forever",
        "sanic.server.runners.serve"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ]
    },
    {
      "name": "test_run_http_3",
      "module": "test_runner",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_runner.py",
      "line_number": 20,
      "end_line_number": 23,
      "source_code": "def test_run_http_3(_serve_http_3: Mock, _serve_http_1: Mock, app: Sanic):\n    serve(\"\", 0, app, version=HTTP.VERSION_3)\n    _serve_http_1.assert_not_called()\n    _serve_http_3.assert_called_once()",
      "docstring": null,
      "decorators": [
        "patch('sanic.server.runners._serve_http_1')",
        "patch('sanic.server.runners._serve_http_3')"
      ],
      "arguments": [
        "_serve_http_3",
        "_serve_http_1",
        "app"
      ],
      "imports": [
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.app.Sanic",
        "sanic.http.constants.HTTP",
        "sanic.server.runners._run_server_forever",
        "sanic.server.runners.serve"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ]
    },
    {
      "name": "test_run_server_forever",
      "module": "test_runner",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_runner.py",
      "line_number": 28,
      "end_line_number": 58,
      "source_code": "def test_run_server_forever(remove_unix_socket: Mock, do_cleanup: bool):\n    loop = Mock()\n    cleanup = Mock()\n    loop.run_forever = Mock(side_effect=KeyboardInterrupt())\n    before_stop = Mock()\n    before_stop.return_value = Mock()\n    after_stop = Mock()\n    after_stop.return_value = Mock()\n    unix = Mock()\n\n    with pytest.raises(KeyboardInterrupt):\n        _run_server_forever(\n            loop,\n            before_stop,\n            after_stop,\n            cleanup if do_cleanup else None,\n            unix,\n        )\n\n    loop.run_forever.assert_called_once_with()\n    loop.run_until_complete.assert_has_calls(\n        [call(before_stop.return_value), call(after_stop.return_value)]\n    )\n\n    if do_cleanup:\n        cleanup.assert_called_once_with()\n    else:\n        cleanup.assert_not_called()\n\n    remove_unix_socket.assert_called_once_with(unix)\n    loop.close.assert_called_once_with()",
      "docstring": null,
      "decorators": [
        "patch('sanic.server.runners.remove_unix_socket')",
        "pytest.mark.parametrize('do_cleanup', (True, False))"
      ],
      "arguments": [
        "remove_unix_socket",
        "do_cleanup"
      ],
      "imports": [
        "unittest.mock.Mock",
        "unittest.mock.call",
        "unittest.mock.patch",
        "pytest",
        "sanic.app.Sanic",
        "sanic.http.constants.HTTP",
        "sanic.server.runners._run_server_forever",
        "sanic.server.runners.serve"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ]
    },
    {
      "name": "test_get_context",
      "module": "test_startup",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_startup.py",
      "line_number": 24,
      "end_line_number": 28,
      "source_code": "def test_get_context(start_method, platform, expected):\n    if start_method:\n        Sanic.start_method = start_method\n    with patch(\"sys.platform\", platform):\n        assert Sanic._get_startup_method() == expected",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('start_method,platform,expected', ((None, 'linux', 'spawn'), (None, 'other', 'spawn'), ('fork', 'linux', 'fork'), ('fork', 'other', 'fork'), ('forkserver', 'linux', 'forkserver'), ('forkserver', 'other', 'forkserver'), ('spawn', 'linux', 'spawn'), ('spawn', 'other', 'spawn')))"
      ],
      "arguments": [
        "start_method",
        "platform",
        "expected"
      ],
      "imports": [
        "sys",
        "multiprocessing.set_start_method",
        "unittest.mock.patch",
        "pytest",
        "sanic.Sanic"
      ],
      "fixtures": [],
      "assertions": [
        "assert Sanic._get_startup_method() == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ]
    },
    {
      "name": "test_set_startup_catch",
      "module": "test_startup",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_startup.py",
      "line_number": 34,
      "end_line_number": 44,
      "source_code": "def test_set_startup_catch():\n    Sanic.START_METHOD_SET = False\n    set_start_method(\"fork\", force=True)\n    Sanic.test_mode = False\n    message = (\n        \"Start method 'spawn' was requested, but 'fork' was already set.\\n\"\n        \"For more information, see: https://sanic.dev/en/guide/running/manager.html#overcoming-a-coderuntimeerrorcode\"\n    )\n    with pytest.raises(RuntimeError, match=message):\n        Sanic._set_startup_method()\n    Sanic.test_mode = True",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(not sys.platform.startswith('linux'), reason='Only test on Linux')"
      ],
      "arguments": [],
      "imports": [
        "sys",
        "multiprocessing.set_start_method",
        "unittest.mock.patch",
        "pytest",
        "sanic.Sanic"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_restart_transient",
      "module": "test_restarter",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_restarter.py",
      "line_number": 24,
      "end_line_number": 40,
      "source_code": "def test_restart_transient():\n    transient = make_worker_process(\"Transient\")\n    durable = make_worker_process(\"Durable\")\n    restarter = Restarter()\n\n    restarter.restart([transient], [durable])\n    transient.restart.assert_called_once_with(\n        restart_order=RestartOrder.SHUTDOWN_FIRST\n    )\n    durable.restart.assert_not_called()\n    transient.restart.reset_mock()\n    restarter.restart(\n        [transient], [durable], restart_order=RestartOrder.STARTUP_FIRST\n    )\n    transient.restart.assert_called_once_with(\n        restart_order=RestartOrder.STARTUP_FIRST\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.worker.constants.ProcessState",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.process.WorkerProcess",
        "sanic.worker.restarter.Restarter"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_worker_process",
          "body": "def make_worker_process(name: str, state: ProcessState=ProcessState.STARTED) -> WorkerProcess:\n    worker_process = Mock()\n    worker_process.restart = Mock()\n    worker_process.name = name\n    worker_process.state = state\n    return worker_process"
        },
        {
          "name": "make_worker_process",
          "body": "def make_worker_process(name: str, state: ProcessState=ProcessState.STARTED) -> WorkerProcess:\n    worker_process = Mock()\n    worker_process.restart = Mock()\n    worker_process.name = name\n    worker_process.state = state\n    return worker_process"
        },
        {
          "name": "transient.restart.reset_mock",
          "body": "def reset_mock(self, *args, **kwargs):\n    super().reset_mock(*args, **kwargs)\n    self.await_count = 0"
        }
      ]
    },
    {
      "name": "test_restart_durable",
      "module": "test_restarter",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_restarter.py",
      "line_number": 58,
      "end_line_number": 89,
      "source_code": "def test_restart_durable(caplog, state, called):\n    transient = make_worker_process(\"Transient\")\n    durable = make_worker_process(\"Durable\")\n    restarter = Restarter()\n\n    restarter.restart([transient], [durable], process_names=[\"Durable\"])\n\n    transient.restart.assert_not_called()\n    durable.restart.assert_not_called()\n\n    assert (\n        \"sanic.error\",\n        40,\n        \"Cannot restart process Durable because it is not in a \"\n        \"final state. Current state is: STARTED.\",\n    ) in caplog.record_tuples\n    assert (\n        \"sanic.error\",\n        40,\n        \"Failed to restart processes: Durable\",\n    ) in caplog.record_tuples\n\n    durable.state = state\n    restarter.restart([transient], [durable], process_names=[\"Durable\"])\n\n    transient.restart.assert_not_called()\n    if called:\n        durable.restart.assert_called_once_with(\n            restart_order=RestartOrder.SHUTDOWN_FIRST\n        )\n    else:\n        durable.restart.assert_not_called()",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('state,called', ((ProcessState.IDLE, False), (ProcessState.RESTARTING, False), (ProcessState.STARTING, False), (ProcessState.STARTED, False), (ProcessState.ACKED, False), (ProcessState.JOINED, False), (ProcessState.TERMINATED, False), (ProcessState.FAILED, True), (ProcessState.COMPLETED, True), (ProcessState.NONE, True)))"
      ],
      "arguments": [
        "caplog",
        "state",
        "called"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "sanic.worker.constants.ProcessState",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.process.WorkerProcess",
        "sanic.worker.restarter.Restarter"
      ],
      "fixtures": [],
      "assertions": [
        "assert ('sanic.error', 40, 'Cannot restart process Durable because it is not in a final state. Current state is: STARTED.') in caplog.record_tuples",
        "assert ('sanic.error', 40, 'Failed to restart processes: Durable') in caplog.record_tuples"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "make_worker_process",
          "body": "def make_worker_process(name: str, state: ProcessState=ProcessState.STARTED) -> WorkerProcess:\n    worker_process = Mock()\n    worker_process.restart = Mock()\n    worker_process.name = name\n    worker_process.state = state\n    return worker_process"
        },
        {
          "name": "make_worker_process",
          "body": "def make_worker_process(name: str, state: ProcessState=ProcessState.STARTED) -> WorkerProcess:\n    worker_process = Mock()\n    worker_process.restart = Mock()\n    worker_process.name = name\n    worker_process.state = state\n    return worker_process"
        }
      ]
    },
    {
      "name": "test_set_items",
      "module": "test_shared_ctx",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_shared_ctx.py",
      "line_number": 33,
      "end_line_number": 44,
      "source_code": "def test_set_items(item: Any, okay: bool, caplog):\n    ctx = SharedContext()\n\n    with caplog.at_level(logging.INFO):\n        ctx.item = item\n\n    assert ctx.is_locked is False\n    assert len(caplog.record_tuples) == 0 if okay else 1\n    if not okay:\n        assert caplog.record_tuples[0][0] == \"sanic.error\"\n        assert caplog.record_tuples[0][1] == logging.WARNING\n        assert \"Unsafe object\" in caplog.record_tuples[0][2]",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('item,okay', ((Pipe(), True), (Value('i', 0), True), (Queue(), True), (c_int32(1), True), (1, False), ('thing', False), (object(), False)))"
      ],
      "arguments": [
        "item",
        "okay",
        "caplog"
      ],
      "imports": [
        "logging",
        "ctypes.c_int32",
        "multiprocessing.Pipe",
        "multiprocessing.Queue",
        "multiprocessing.Value",
        "os.environ",
        "typing.Any",
        "pytest",
        "sanic.types.shared_ctx.SharedContext"
      ],
      "fixtures": [],
      "assertions": [
        "assert ctx.is_locked is False",
        "assert len(caplog.record_tuples) == 0 if okay else 1",
        "assert caplog.record_tuples[0][0] == 'sanic.error'",
        "assert caplog.record_tuples[0][1] == logging.WARNING",
        "assert 'Unsafe object' in caplog.record_tuples[0][2]"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_set_items_in_worker",
      "module": "test_shared_ctx",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_shared_ctx.py",
      "line_number": 59,
      "end_line_number": 68,
      "source_code": "def test_set_items_in_worker(item: Any, caplog):\n    ctx = SharedContext()\n\n    environ[\"SANIC_WORKER_NAME\"] = \"foo\"\n    with caplog.at_level(logging.INFO):\n        ctx.item = item\n    del environ[\"SANIC_WORKER_NAME\"]\n\n    assert ctx.is_locked is False\n    assert len(caplog.record_tuples) == 0",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('item', (Pipe(), Value('i', 0), Queue(), c_int32(1), 1, 'thing', object()))"
      ],
      "arguments": [
        "item",
        "caplog"
      ],
      "imports": [
        "logging",
        "ctypes.c_int32",
        "multiprocessing.Pipe",
        "multiprocessing.Queue",
        "multiprocessing.Value",
        "os.environ",
        "typing.Any",
        "pytest",
        "sanic.types.shared_ctx.SharedContext"
      ],
      "fixtures": [],
      "assertions": [
        "assert ctx.is_locked is False",
        "assert len(caplog.record_tuples) == 0"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_lock",
      "module": "test_shared_ctx",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_shared_ctx.py",
      "line_number": 71,
      "end_line_number": 82,
      "source_code": "def test_lock():\n    ctx = SharedContext()\n\n    assert ctx.is_locked is False\n\n    ctx.lock()\n\n    assert ctx.is_locked is True\n\n    message = \"Cannot set item on locked SharedContext object\"\n    with pytest.raises(RuntimeError, match=message):\n        ctx.item = 1",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "logging",
        "ctypes.c_int32",
        "multiprocessing.Pipe",
        "multiprocessing.Queue",
        "multiprocessing.Value",
        "os.environ",
        "typing.Any",
        "pytest",
        "sanic.types.shared_ctx.SharedContext"
      ],
      "fixtures": [],
      "assertions": [
        "assert ctx.is_locked is False",
        "assert ctx.is_locked is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_send_inspect",
      "module": "test_inspector",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_inspector.py",
      "line_number": 61,
      "end_line_number": 67,
      "source_code": "def test_send_inspect(write, urlopen, command: str):\n    urlopen.read.return_value = FULL_SERIALIZED.encode()\n    InspectorClient(\"localhost\", 9999, False, False, None).do(command)\n    write.assert_called()\n    write.reset_mock()\n    InspectorClient(\"localhost\", 9999, False, True, None).do(command)\n    write.assert_called_with(OUT_SERIALIZED + \"\\n\")",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('command', ('info',))",
        "patch('sanic.cli.inspector_client.sys.stdout.write')"
      ],
      "arguments": [
        "write",
        "urlopen",
        "command"
      ],
      "imports": [
        "datetime.datetime",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.error.URLError",
        "pytest",
        "sanic_testing.TestManager",
        "sanic.cli.inspector_client.InspectorClient",
        "sanic.helpers.Default",
        "sanic.log.Colors",
        "sanic.worker.inspector.Inspector",
        "ujson.dumps",
        "json.dumps"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        },
        {
          "name": "write.reset_mock",
          "body": "def reset_mock(self, *args, **kwargs):\n    super().reset_mock(*args, **kwargs)\n    self.await_count = 0"
        }
      ]
    },
    {
      "name": "test_send_inspect_conn_refused",
      "module": "test_inspector",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_inspector.py",
      "line_number": 71,
      "end_line_number": 82,
      "source_code": "def test_send_inspect_conn_refused(sys: Mock, urlopen):\n    urlopen.side_effect = URLError(\"\")\n    InspectorClient(\"localhost\", 9999, False, False, None).do(\"info\")\n\n    message = (\n        f\"{Colors.RED}Could not connect to inspector at: \"\n        f\"{Colors.YELLOW}http://localhost:9999{Colors.END}\\n\"\n        \"Either the application is not running, or it did not start \"\n        \"an inspector instance.\\n<urlopen error >\\n\"\n    )\n    sys.exit.assert_called_once_with(1)\n    sys.stderr.write.assert_called_once_with(message)",
      "docstring": null,
      "decorators": [
        "patch('sanic.cli.inspector_client.sys')"
      ],
      "arguments": [
        "sys",
        "urlopen"
      ],
      "imports": [
        "datetime.datetime",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.error.URLError",
        "pytest",
        "sanic_testing.TestManager",
        "sanic.cli.inspector_client.InspectorClient",
        "sanic.helpers.Default",
        "sanic.log.Colors",
        "sanic.worker.inspector.Inspector",
        "ujson.dumps",
        "json.dumps"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "patch",
          "body": "def patch(self, request):\n    return text('I am patch method')"
        }
      ]
    },
    {
      "name": "test_run_inspector_reload",
      "module": "test_inspector",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_inspector.py",
      "line_number": 85,
      "end_line_number": 88,
      "source_code": "def test_run_inspector_reload(publisher, http_client):\n    _, response = http_client.post(\"/reload\")\n    assert response.status == 200\n    publisher.send.assert_called_once_with(\"__ALL_PROCESSES__:\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "publisher",
        "http_client"
      ],
      "imports": [
        "datetime.datetime",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.error.URLError",
        "pytest",
        "sanic_testing.TestManager",
        "sanic.cli.inspector_client.InspectorClient",
        "sanic.helpers.Default",
        "sanic.log.Colors",
        "sanic.worker.inspector.Inspector",
        "ujson.dumps",
        "json.dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "http_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_run_inspector_reload_zero_downtime",
      "module": "test_inspector",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_inspector.py",
      "line_number": 91,
      "end_line_number": 94,
      "source_code": "def test_run_inspector_reload_zero_downtime(publisher, http_client):\n    _, response = http_client.post(\"/reload\", json={\"zero_downtime\": True})\n    assert response.status == 200\n    publisher.send.assert_called_once_with(\"__ALL_PROCESSES__::STARTUP_FIRST\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "publisher",
        "http_client"
      ],
      "imports": [
        "datetime.datetime",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.error.URLError",
        "pytest",
        "sanic_testing.TestManager",
        "sanic.cli.inspector_client.InspectorClient",
        "sanic.helpers.Default",
        "sanic.log.Colors",
        "sanic.worker.inspector.Inspector",
        "ujson.dumps",
        "json.dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "http_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_run_inspector_shutdown",
      "module": "test_inspector",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_inspector.py",
      "line_number": 97,
      "end_line_number": 100,
      "source_code": "def test_run_inspector_shutdown(publisher, http_client):\n    _, response = http_client.post(\"/shutdown\")\n    assert response.status == 200\n    publisher.send.assert_called_once_with(\"__TERMINATE__\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "publisher",
        "http_client"
      ],
      "imports": [
        "datetime.datetime",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.error.URLError",
        "pytest",
        "sanic_testing.TestManager",
        "sanic.cli.inspector_client.InspectorClient",
        "sanic.helpers.Default",
        "sanic.log.Colors",
        "sanic.worker.inspector.Inspector",
        "ujson.dumps",
        "json.dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "http_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_run_inspector_scale",
      "module": "test_inspector",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_inspector.py",
      "line_number": 103,
      "end_line_number": 106,
      "source_code": "def test_run_inspector_scale(publisher, http_client):\n    _, response = http_client.post(\"/scale\", json={\"replicas\": 4})\n    assert response.status == 200\n    publisher.send.assert_called_once_with(\"__SCALE__:4\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "publisher",
        "http_client"
      ],
      "imports": [
        "datetime.datetime",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.error.URLError",
        "pytest",
        "sanic_testing.TestManager",
        "sanic.cli.inspector_client.InspectorClient",
        "sanic.helpers.Default",
        "sanic.log.Colors",
        "sanic.worker.inspector.Inspector",
        "ujson.dumps",
        "json.dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "http_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_run_inspector_arbitrary",
      "module": "test_inspector",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_inspector.py",
      "line_number": 109,
      "end_line_number": 112,
      "source_code": "def test_run_inspector_arbitrary(http_client):\n    _, response = http_client.post(\"/foo\", json={\"bar\": 99})\n    assert response.status == 200\n    assert response.json == {\"meta\": {\"action\": \"foo\"}, \"result\": \"bar is 99\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "http_client"
      ],
      "imports": [
        "datetime.datetime",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.error.URLError",
        "pytest",
        "sanic_testing.TestManager",
        "sanic.cli.inspector_client.InspectorClient",
        "sanic.helpers.Default",
        "sanic.log.Colors",
        "sanic.worker.inspector.Inspector",
        "ujson.dumps",
        "json.dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 200",
        "assert response.json == {'meta': {'action': 'foo'}, 'result': 'bar is 99'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "http_client.post",
          "body": "def post(self, request):\n    return text('I am post method')"
        }
      ]
    },
    {
      "name": "test_state_to_json",
      "module": "test_inspector",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_inspector.py",
      "line_number": 115,
      "end_line_number": 128,
      "source_code": "def test_state_to_json():\n    now = datetime.now()\n    now_iso = now.isoformat()\n    app_info = {\"app\": \"hello\"}\n    worker_state = {\"Test\": {\"now\": now, \"nested\": {\"foo\": now}}}\n    inspector = Inspector(\n        Mock(), app_info, worker_state, \"\", 0, \"\", Default(), Default()\n    )\n    state = inspector._state_to_json()\n\n    assert state == {\n        \"info\": app_info,\n        \"workers\": {\"Test\": {\"now\": now_iso, \"nested\": {\"foo\": now_iso}}},\n    }",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.error.URLError",
        "pytest",
        "sanic_testing.TestManager",
        "sanic.cli.inspector_client.InspectorClient",
        "sanic.helpers.Default",
        "sanic.log.Colors",
        "sanic.worker.inspector.Inspector",
        "ujson.dumps",
        "json.dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert state == {'info': app_info, 'workers': {'Test': {'now': now_iso, 'nested': {'foo': now_iso}}}}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_run_inspector_authentication",
      "module": "test_inspector",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_inspector.py",
      "line_number": 131,
      "end_line_number": 141,
      "source_code": "def test_run_inspector_authentication():\n    inspector = Inspector(\n        Mock(), {}, {}, \"\", 0, \"super-secret\", Default(), Default()\n    )(False)\n    manager = TestManager(inspector.app)\n    _, response = manager.test_client.get(\"/\")\n    assert response.status == 401\n    _, response = manager.test_client.get(\n        \"/\", headers={\"Authorization\": \"Bearer super-secret\"}\n    )\n    assert response.status == 200",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "urllib.error.URLError",
        "pytest",
        "sanic_testing.TestManager",
        "sanic.cli.inspector_client.InspectorClient",
        "sanic.helpers.Default",
        "sanic.log.Colors",
        "sanic.worker.inspector.Inspector",
        "ujson.dumps",
        "json.dumps"
      ],
      "fixtures": [],
      "assertions": [
        "assert response.status == 401",
        "assert response.status == 200"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "manager.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        },
        {
          "name": "manager.test_client.get",
          "body": "def get(self, request):\n    return text('I am get method')"
        }
      ]
    },
    {
      "name": "test_reload_send",
      "module": "test_reloader",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
      "line_number": 54,
      "end_line_number": 58,
      "source_code": "def test_reload_send():\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, set(), Mock())\n    reloader.reload(\"foobar\")\n    publisher.send.assert_called_once_with(\"__ALL_PROCESSES__:foobar\")",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "re",
        "signal",
        "threading",
        "asyncio.Event",
        "logging.DEBUG",
        "pathlib.Path",
        "time.sleep",
        "unittest.mock.Mock",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.constants.ProcessState",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.process.WorkerProcess",
        "sanic.worker.reloader.Reloader"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_iter_files",
      "module": "test_reloader",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
      "line_number": 61,
      "end_line_number": 71,
      "source_code": "def test_iter_files():\n    reloader = Reloader(Mock(), 0.1, set(), Mock())\n    len_python_files = len(list(reloader.files()))\n    assert len_python_files > 0\n\n    static_dir = Path(__file__).parent.parent / \"static\"\n    len_static_files = len(list(static_dir.glob(\"**/*\")))\n    reloader = Reloader(Mock(), 0.1, set({static_dir}), Mock())\n    len_total_files = len(list(reloader.files()))\n    assert len_static_files > 0\n    assert len_total_files == len_python_files + len_static_files",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "re",
        "signal",
        "threading",
        "asyncio.Event",
        "logging.DEBUG",
        "pathlib.Path",
        "time.sleep",
        "unittest.mock.Mock",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.constants.ProcessState",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.process.WorkerProcess",
        "sanic.worker.reloader.Reloader"
      ],
      "fixtures": [],
      "assertions": [
        "assert len_python_files > 0",
        "assert len_static_files > 0",
        "assert len_total_files == len_python_files + len_static_files"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_default_reload_shutdown_order",
      "module": "test_reloader",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
      "line_number": 97,
      "end_line_number": 128,
      "source_code": "def test_default_reload_shutdown_order(monkeypatch, caplog, order, expected):\n    current_process = Mock()\n    worker_process = WorkerProcess(\n        lambda **_: current_process,\n        \"Test\",\n        \"TST\",\n        lambda **_: ...,\n        {},\n        {},\n    )\n\n    def start(self):\n        worker_process.set_state(ProcessState.ACKED)\n        self._target()\n\n    orig = threading.Thread.start\n    monkeypatch.setattr(threading.Thread, \"start\", start)\n\n    with caplog.at_level(DEBUG):\n        worker_process.restart(restart_order=order)\n\n    ansi = re.compile(r\"\\x1B(?:[@-Z\\\\-_]|\\[[0-?]*[ -/]*[@-~])\")\n\n    def clean(msg: str):\n        msg, _ = ansi.sub(\"\", msg).split(\":\", 1)\n        return msg\n\n    debug = [clean(record[2]) for record in caplog.record_tuples]\n    assert debug == expected\n    current_process.start.assert_called_once()\n    current_process.terminate.assert_called_once()\n    monkeypatch.setattr(threading.Thread, \"start\", orig)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('order,expected', ((RestartOrder.SHUTDOWN_FIRST, ['Restarting a process', 'Begin restart termination', 'Starting a process']), (RestartOrder.STARTUP_FIRST, ['Restarting a process', 'Starting a process', 'Begin restart termination', 'Waiting for process to be acked', 'Process acked. Terminating'])))"
      ],
      "arguments": [
        "monkeypatch",
        "caplog",
        "order",
        "expected"
      ],
      "imports": [
        "re",
        "signal",
        "threading",
        "asyncio.Event",
        "logging.DEBUG",
        "pathlib.Path",
        "time.sleep",
        "unittest.mock.Mock",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.constants.ProcessState",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.process.WorkerProcess",
        "sanic.worker.reloader.Reloader"
      ],
      "fixtures": [],
      "assertions": [
        "assert debug == expected"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "clean",
          "body": "def clean(msg: str):\n    (msg, _) = ansi.sub('', msg).split(':', 1)\n    return msg"
        }
      ]
    },
    {
      "name": "test_reload_delayed",
      "module": "test_reloader",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
      "line_number": 131,
      "end_line_number": 155,
      "source_code": "def test_reload_delayed(monkeypatch):\n    WorkerProcess.THRESHOLD = 1\n\n    current_process = Mock()\n    worker_process = WorkerProcess(\n        lambda **_: current_process,\n        \"Test\",\n        \"TST\",\n        lambda **_: ...,\n        {},\n        {},\n    )\n\n    def start(self):\n        sleep(0.2)\n        self._target()\n\n    orig = threading.Thread.start\n    monkeypatch.setattr(threading.Thread, \"start\", start)\n\n    message = \"Worker Test failed to come ack within 0.1 seconds\"\n    with pytest.raises(TimeoutError, match=message):\n        worker_process.restart(restart_order=RestartOrder.STARTUP_FIRST)\n\n    monkeypatch.setattr(threading.Thread, \"start\", orig)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monkeypatch"
      ],
      "imports": [
        "re",
        "signal",
        "threading",
        "asyncio.Event",
        "logging.DEBUG",
        "pathlib.Path",
        "time.sleep",
        "unittest.mock.Mock",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.constants.ProcessState",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.process.WorkerProcess",
        "sanic.worker.reloader.Reloader"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_reloader_triggers_start_stop_listeners",
      "module": "test_reloader",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
      "line_number": 158,
      "end_line_number": 174,
      "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "app_loader"
      ],
      "imports": [
        "re",
        "signal",
        "threading",
        "asyncio.Event",
        "logging.DEBUG",
        "pathlib.Path",
        "time.sleep",
        "unittest.mock.Mock",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.constants.ProcessState",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.process.WorkerProcess",
        "sanic.worker.reloader.Reloader"
      ],
      "fixtures": [],
      "assertions": [
        "assert results == ['reload_process_start', 'reload_process_stop']"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "run_reloader",
          "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()"
        }
      ]
    },
    {
      "name": "test_not_triggered",
      "module": "test_reloader",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
      "line_number": 177,
      "end_line_number": 183,
      "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app_loader"
      ],
      "imports": [
        "re",
        "signal",
        "threading",
        "asyncio.Event",
        "logging.DEBUG",
        "pathlib.Path",
        "time.sleep",
        "unittest.mock.Mock",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.constants.ProcessState",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.process.WorkerProcess",
        "sanic.worker.reloader.Reloader"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "run_reloader",
          "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()"
        }
      ]
    },
    {
      "name": "test_triggered",
      "module": "test_reloader",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
      "line_number": 186,
      "end_line_number": 210,
      "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app_loader"
      ],
      "imports": [
        "re",
        "signal",
        "threading",
        "asyncio.Event",
        "logging.DEBUG",
        "pathlib.Path",
        "time.sleep",
        "unittest.mock.Mock",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.constants.ProcessState",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.process.WorkerProcess",
        "sanic.worker.reloader.Reloader"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(paths) == 2",
        "assert call_arg.startswith('__ALL_PROCESSES__:')",
        "assert call_arg.count(',') == 1",
        "assert str(path) in call_arg"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "run_reloader",
          "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()"
        }
      ]
    },
    {
      "name": "test_reloader_triggers_reload_listeners",
      "module": "test_reloader",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
      "line_number": 213,
      "end_line_number": 237,
      "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "app_loader"
      ],
      "imports": [
        "re",
        "signal",
        "threading",
        "asyncio.Event",
        "logging.DEBUG",
        "pathlib.Path",
        "time.sleep",
        "unittest.mock.Mock",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.constants.ProcessState",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.process.WorkerProcess",
        "sanic.worker.reloader.Reloader"
      ],
      "fixtures": [],
      "assertions": [
        "assert before.is_set()",
        "assert after.is_set()",
        "assert len(changed_files) > 0",
        "assert changed_files == set(reloader.files())"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "run_reloader",
          "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()"
        }
      ]
    },
    {
      "name": "test_check_file",
      "module": "test_reloader",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
      "line_number": 240,
      "end_line_number": 248,
      "source_code": "def test_check_file(tmp_path):\n    current = tmp_path / \"testing.txt\"\n    current.touch()\n    mtimes = {}\n    assert Reloader.check_file(current, mtimes) is False\n    assert len(mtimes) == 1\n    assert Reloader.check_file(current, mtimes) is False\n    mtimes[current] = mtimes[current] - 1\n    assert Reloader.check_file(current, mtimes) is True",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "tmp_path"
      ],
      "imports": [
        "re",
        "signal",
        "threading",
        "asyncio.Event",
        "logging.DEBUG",
        "pathlib.Path",
        "time.sleep",
        "unittest.mock.Mock",
        "pytest",
        "sanic.app.Sanic",
        "sanic.worker.constants.ProcessState",
        "sanic.worker.constants.RestartOrder",
        "sanic.worker.loader.AppLoader",
        "sanic.worker.process.WorkerProcess",
        "sanic.worker.reloader.Reloader"
      ],
      "fixtures": [],
      "assertions": [
        "assert Reloader.check_file(current, mtimes) is False",
        "assert len(mtimes) == 1",
        "assert Reloader.check_file(current, mtimes) is False",
        "assert Reloader.check_file(current, mtimes) is True"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "Reloader.check_file",
          "body": "def check_file(filename, mtimes):\n    if isinstance(filename, Path) and filename.name == 'server.py' or (isinstance(filename, str) and 'sanic/app.py' in filename):\n        paths.add(str(filename))\n        return True\n    return False"
        },
        {
          "name": "Reloader.check_file",
          "body": "def check_file(filename, mtimes):\n    if isinstance(filename, Path) and filename.name == 'server.py' or (isinstance(filename, str) and 'sanic/app.py' in filename):\n        paths.add(str(filename))\n        return True\n    return False"
        },
        {
          "name": "Reloader.check_file",
          "body": "def check_file(filename, mtimes):\n    if isinstance(filename, Path) and filename.name == 'server.py' or (isinstance(filename, str) and 'sanic/app.py' in filename):\n        paths.add(str(filename))\n        return True\n    return False"
        }
      ]
    },
    {
      "name": "test_has_multiplexer_default",
      "module": "test_multiplexer",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_multiplexer.py",
      "line_number": 42,
      "end_line_number": 58,
      "source_code": "def test_has_multiplexer_default(app: Sanic):\n    event = Event()\n\n    @app.main_process_start\n    async def setup(app, _):\n        app.shared_ctx.event = event\n\n    @app.after_server_start\n    def stop(app):\n        if hasattr(app, \"m\") and isinstance(app.m, WorkerMultiplexer):\n            app.shared_ctx.event.set()\n        app.stop()\n\n    with use_context(\"fork\"):\n        app.run()\n\n    assert event.is_set()",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(sys.platform not in ('linux', 'darwin'), reason='This test requires fork context')"
      ],
      "arguments": [
        "app"
      ],
      "imports": [
        "sys",
        "multiprocessing.Event",
        "os.environ",
        "os.getpid",
        "typing.Any",
        "typing.Dict",
        "typing.Type",
        "typing.Union",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.compat.use_context",
        "sanic.worker.multiplexer.WorkerMultiplexer",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [
        "assert event.is_set()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        },
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ]
    },
    {
      "name": "test_not_have_multiplexer_single",
      "module": "test_multiplexer",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_multiplexer.py",
      "line_number": 61,
      "end_line_number": 76,
      "source_code": "def test_not_have_multiplexer_single(app: Sanic):\n    event = Event()\n\n    @app.main_process_start\n    async def setup(app, _):\n        app.shared_ctx.event = event\n\n    @app.after_server_start\n    def stop(app):\n        if hasattr(app, \"m\") and isinstance(app.m, WorkerMultiplexer):\n            app.shared_ctx.event.set()\n        app.stop()\n\n    app.run(single_process=True)\n\n    assert not event.is_set()",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "sys",
        "multiprocessing.Event",
        "os.environ",
        "os.getpid",
        "typing.Any",
        "typing.Dict",
        "typing.Type",
        "typing.Union",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.compat.use_context",
        "sanic.worker.multiplexer.WorkerMultiplexer",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [
        "assert not event.is_set()"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        },
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        }
      ]
    },
    {
      "name": "test_ack",
      "module": "test_multiplexer",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_multiplexer.py",
      "line_number": 79,
      "end_line_number": 82,
      "source_code": "def test_ack(worker_state: Dict[str, Any], m: WorkerMultiplexer):\n    worker_state[\"Test\"] = {\"foo\": \"bar\"}\n    m.ack()\n    assert worker_state[\"Test\"] == {\"foo\": \"bar\", \"state\": \"ACKED\"}",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "worker_state",
        "m"
      ],
      "imports": [
        "sys",
        "multiprocessing.Event",
        "os.environ",
        "os.getpid",
        "typing.Any",
        "typing.Dict",
        "typing.Type",
        "typing.Union",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.compat.use_context",
        "sanic.worker.multiplexer.WorkerMultiplexer",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [
        "assert worker_state['Test'] == {'foo': 'bar', 'state': 'ACKED'}"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_restart_self",
      "module": "test_multiplexer",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_multiplexer.py",
      "line_number": 85,
      "end_line_number": 87,
      "source_code": "def test_restart_self(monitor_publisher: Mock, m: WorkerMultiplexer):\n    m.restart()\n    monitor_publisher.send.assert_called_once_with(\"Test:\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monitor_publisher",
        "m"
      ],
      "imports": [
        "sys",
        "multiprocessing.Event",
        "os.environ",
        "os.getpid",
        "typing.Any",
        "typing.Dict",
        "typing.Type",
        "typing.Union",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.compat.use_context",
        "sanic.worker.multiplexer.WorkerMultiplexer",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_restart_foo",
      "module": "test_multiplexer",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_multiplexer.py",
      "line_number": 90,
      "end_line_number": 92,
      "source_code": "def test_restart_foo(monitor_publisher: Mock, m: WorkerMultiplexer):\n    m.restart(\"foo\")\n    monitor_publisher.send.assert_called_once_with(\"foo:\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monitor_publisher",
        "m"
      ],
      "imports": [
        "sys",
        "multiprocessing.Event",
        "os.environ",
        "os.getpid",
        "typing.Any",
        "typing.Dict",
        "typing.Type",
        "typing.Union",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.compat.use_context",
        "sanic.worker.multiplexer.WorkerMultiplexer",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_reload_alias",
      "module": "test_multiplexer",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_multiplexer.py",
      "line_number": 95,
      "end_line_number": 97,
      "source_code": "def test_reload_alias(monitor_publisher: Mock, m: WorkerMultiplexer):\n    m.reload()\n    monitor_publisher.send.assert_called_once_with(\"Test:\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monitor_publisher",
        "m"
      ],
      "imports": [
        "sys",
        "multiprocessing.Event",
        "os.environ",
        "os.getpid",
        "typing.Any",
        "typing.Dict",
        "typing.Type",
        "typing.Union",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.compat.use_context",
        "sanic.worker.multiplexer.WorkerMultiplexer",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_terminate",
      "module": "test_multiplexer",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_multiplexer.py",
      "line_number": 100,
      "end_line_number": 102,
      "source_code": "def test_terminate(monitor_publisher: Mock, m: WorkerMultiplexer):\n    m.terminate()\n    monitor_publisher.send.assert_called_once_with(\"__TERMINATE__\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monitor_publisher",
        "m"
      ],
      "imports": [
        "sys",
        "multiprocessing.Event",
        "os.environ",
        "os.getpid",
        "typing.Any",
        "typing.Dict",
        "typing.Type",
        "typing.Union",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.compat.use_context",
        "sanic.worker.multiplexer.WorkerMultiplexer",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "m.terminate",
          "body": "def terminate(proc):\n    if flags:\n        proc.send_signal(CTRL_BREAK_EVENT)\n    else:\n        proc.terminate()"
        }
      ]
    },
    {
      "name": "test_scale",
      "module": "test_multiplexer",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_multiplexer.py",
      "line_number": 105,
      "end_line_number": 107,
      "source_code": "def test_scale(monitor_publisher: Mock, m: WorkerMultiplexer):\n    m.scale(99)\n    monitor_publisher.send.assert_called_once_with(\"__SCALE__:99\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monitor_publisher",
        "m"
      ],
      "imports": [
        "sys",
        "multiprocessing.Event",
        "os.environ",
        "os.getpid",
        "typing.Any",
        "typing.Dict",
        "typing.Type",
        "typing.Union",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.compat.use_context",
        "sanic.worker.multiplexer.WorkerMultiplexer",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_manage",
      "module": "test_multiplexer",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_multiplexer.py",
      "line_number": 110,
      "end_line_number": 114,
      "source_code": "def test_manage(monitor_publisher: Mock, m: WorkerMultiplexer):\n    m.manage(\"NEW\", noop, auto_start=False, kwargs={\"foo\": 99})\n    monitor_publisher.send.assert_called_once_with(\n        (\"NEW\", noop, {\"foo\": 99}, False, None, False, False, 1)\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monitor_publisher",
        "m"
      ],
      "imports": [
        "sys",
        "multiprocessing.Event",
        "os.environ",
        "os.getpid",
        "typing.Any",
        "typing.Dict",
        "typing.Type",
        "typing.Union",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.compat.use_context",
        "sanic.worker.multiplexer.WorkerMultiplexer",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_properties",
      "module": "test_multiplexer",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_multiplexer.py",
      "line_number": 117,
      "end_line_number": 125,
      "source_code": "def test_properties(\n    monitor_publisher: Mock, worker_state: Dict[str, Any], m: WorkerMultiplexer\n):\n    assert m.reload == m.restart\n    assert m.pid == getpid()\n    assert m.name == \"Test\"\n    assert m.workers == worker_state\n    assert m.state == worker_state[\"Test\"]\n    assert isinstance(m.state, WorkerState)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "monitor_publisher",
        "worker_state",
        "m"
      ],
      "imports": [
        "sys",
        "multiprocessing.Event",
        "os.environ",
        "os.getpid",
        "typing.Any",
        "typing.Dict",
        "typing.Type",
        "typing.Union",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.compat.use_context",
        "sanic.worker.multiplexer.WorkerMultiplexer",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [
        "assert m.reload == m.restart",
        "assert m.pid == getpid()",
        "assert m.name == 'Test'",
        "assert m.workers == worker_state",
        "assert m.state == worker_state['Test']",
        "assert isinstance(m.state, WorkerState)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_restart_params",
      "module": "test_multiplexer",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/worker/test_multiplexer.py",
      "line_number": 147,
      "end_line_number": 158,
      "source_code": "def test_restart_params(\n    monitor_publisher: Mock,\n    m: WorkerMultiplexer,\n    params: Dict[str, Any],\n    expected: Union[str, Type[Exception]],\n):\n    if isinstance(expected, str):\n        m.restart(**params)\n        monitor_publisher.send.assert_called_once_with(expected)\n    else:\n        with pytest.raises(expected):\n            m.restart(**params)",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('params,expected', (({}, 'Test:'), ({'name': 'foo'}, 'foo:'), ({'all_workers': True}, '__ALL_PROCESSES__:'), ({'zero_downtime': True}, 'Test::STARTUP_FIRST'), ({'name': 'foo', 'all_workers': True}, ValueError), ({'name': 'foo', 'zero_downtime': True}, 'foo::STARTUP_FIRST'), ({'all_workers': True, 'zero_downtime': True}, '__ALL_PROCESSES__::STARTUP_FIRST'), ({'name': 'foo', 'all_workers': True, 'zero_downtime': True}, ValueError)))"
      ],
      "arguments": [
        "monitor_publisher",
        "m",
        "params",
        "expected"
      ],
      "imports": [
        "sys",
        "multiprocessing.Event",
        "os.environ",
        "os.getpid",
        "typing.Any",
        "typing.Dict",
        "typing.Type",
        "typing.Union",
        "unittest.mock.Mock",
        "pytest",
        "sanic.Sanic",
        "sanic.compat.use_context",
        "sanic.worker.multiplexer.WorkerMultiplexer",
        "sanic.worker.state.WorkerState"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": []
    },
    {
      "name": "test_session_ticket_store",
      "module": "test_session_ticket_store",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/http3/test_session_ticket_store.py",
      "line_number": 22,
      "end_line_number": 46,
      "source_code": "def test_session_ticket_store():\n    store = SessionTicketStore()\n\n    assert len(store.tickets) == 0\n\n    ticket1 = _generate_ticket(b\"foo\")\n    store.add(ticket1)\n\n    assert len(store.tickets) == 1\n\n    ticket2 = _generate_ticket(b\"bar\")\n    store.add(ticket2)\n\n    assert len(store.tickets) == 2\n    assert len(store.tickets) == 2\n\n    popped2 = store.pop(ticket2.ticket)\n\n    assert len(store.tickets) == 1\n    assert popped2 is ticket2\n\n    popped1 = store.pop(ticket1.ticket)\n\n    assert len(store.tickets) == 0\n    assert popped1 is ticket1",
      "docstring": null,
      "decorators": [],
      "arguments": [],
      "imports": [
        "datetime.datetime",
        "aioquic.tls.CipherSuite",
        "aioquic.tls.SessionTicket",
        "sanic.http.http3.SessionTicketStore"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(store.tickets) == 0",
        "assert len(store.tickets) == 1",
        "assert len(store.tickets) == 2",
        "assert len(store.tickets) == 2",
        "assert len(store.tickets) == 1",
        "assert popped2 is ticket2",
        "assert len(store.tickets) == 0",
        "assert popped1 is ticket1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "_generate_ticket",
          "body": "def _generate_ticket(label):\n    return SessionTicket(1, CipherSuite.AES_128_GCM_SHA256, datetime.now(), datetime.now(), label, label.decode(), label, None, [])"
        },
        {
          "name": "_generate_ticket",
          "body": "def _generate_ticket(label):\n    return SessionTicket(1, CipherSuite.AES_128_GCM_SHA256, datetime.now(), datetime.now(), label, label.decode(), label, None, [])"
        }
      ]
    },
    {
      "name": "test_http_receiver_init",
      "module": "test_http_receiver",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/http3/test_http_receiver.py",
      "line_number": 71,
      "end_line_number": 78,
      "source_code": "def test_http_receiver_init(app: Sanic, http_request: Request):\n    receiver = generate_http_receiver(app, http_request)\n    assert receiver.request_body is None\n    assert receiver.stage is Stage.IDLE\n    assert receiver.headers_sent is False\n    assert receiver.response is None\n    assert receiver.request_max_size == DEFAULT_CONFIG[\"REQUEST_MAX_SIZE\"]\n    assert receiver.request_bytes == 0",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "http_request"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "aioquic.h3.connection.H3Connection",
        "aioquic.h3.events.DataReceived",
        "aioquic.h3.events.HeadersReceived",
        "aioquic.quic.configuration.QuicConfiguration",
        "aioquic.quic.connection.QuicConnection",
        "aioquic.quic.events.ProtocolNegotiated",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.constants.Stage",
        "sanic.http.http3.Http3",
        "sanic.http.http3.HTTPReceiver",
        "sanic.models.server_types.ConnInfo",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.server.protocols.http_protocol.Http3Protocol",
        "unittest.mock.AsyncMock",
        "tests.asyncmock.AsyncMock"
      ],
      "fixtures": [],
      "assertions": [
        "assert receiver.request_body is None",
        "assert receiver.stage is Stage.IDLE",
        "assert receiver.headers_sent is False",
        "assert receiver.response is None",
        "assert receiver.request_max_size == DEFAULT_CONFIG['REQUEST_MAX_SIZE']",
        "assert receiver.request_bytes == 0"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "generate_http_receiver",
          "body": "def generate_http_receiver(app, http_request) -> HTTPReceiver:\n    protocol = generate_protocol(app)\n    receiver = HTTPReceiver(protocol.transmit, protocol, http_request)\n    http_request.stream = receiver\n    return receiver"
        }
      ]
    },
    {
      "name": "test_http_receiver_respond",
      "module": "test_http_receiver",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/http3/test_http_receiver.py",
      "line_number": 117,
      "end_line_number": 131,
      "source_code": "def test_http_receiver_respond(app: Sanic, http_request: Request):\n    receiver = generate_http_receiver(app, http_request)\n    response = empty()\n\n    receiver.stage = Stage.RESPONSE\n    with pytest.raises(RuntimeError, match=\"Response already started\"):\n        receiver.respond(response)\n\n    receiver.stage = Stage.HANDLER\n    receiver.response = Mock()\n    resp = receiver.respond(response)\n\n    assert receiver.response is resp\n    assert resp is response\n    assert response.stream is receiver",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "http_request"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "aioquic.h3.connection.H3Connection",
        "aioquic.h3.events.DataReceived",
        "aioquic.h3.events.HeadersReceived",
        "aioquic.quic.configuration.QuicConfiguration",
        "aioquic.quic.connection.QuicConnection",
        "aioquic.quic.events.ProtocolNegotiated",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.constants.Stage",
        "sanic.http.http3.Http3",
        "sanic.http.http3.HTTPReceiver",
        "sanic.models.server_types.ConnInfo",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.server.protocols.http_protocol.Http3Protocol",
        "unittest.mock.AsyncMock",
        "tests.asyncmock.AsyncMock"
      ],
      "fixtures": [],
      "assertions": [
        "assert receiver.response is resp",
        "assert resp is response",
        "assert response.stream is receiver"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "generate_http_receiver",
          "body": "def generate_http_receiver(app, http_request) -> HTTPReceiver:\n    protocol = generate_protocol(app)\n    receiver = HTTPReceiver(protocol.transmit, protocol, http_request)\n    http_request.stream = receiver\n    return receiver"
        }
      ]
    },
    {
      "name": "test_http_receiver_receive_body",
      "module": "test_http_receiver",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/http3/test_http_receiver.py",
      "line_number": 134,
      "end_line_number": 147,
      "source_code": "def test_http_receiver_receive_body(app: Sanic, http_request: Request):\n    receiver = generate_http_receiver(app, http_request)\n    receiver.request_max_size = 4\n\n    receiver.receive_body(b\"..\")\n    assert receiver.request.body == b\"..\"\n\n    receiver.receive_body(b\"..\")\n    assert receiver.request.body == b\"....\"\n\n    with pytest.raises(\n        PayloadTooLarge, match=\"Request body exceeds the size limit\"\n    ):\n        receiver.receive_body(b\"..\")",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app",
        "http_request"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "aioquic.h3.connection.H3Connection",
        "aioquic.h3.events.DataReceived",
        "aioquic.h3.events.HeadersReceived",
        "aioquic.quic.configuration.QuicConfiguration",
        "aioquic.quic.connection.QuicConnection",
        "aioquic.quic.events.ProtocolNegotiated",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.constants.Stage",
        "sanic.http.http3.Http3",
        "sanic.http.http3.HTTPReceiver",
        "sanic.models.server_types.ConnInfo",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.server.protocols.http_protocol.Http3Protocol",
        "unittest.mock.AsyncMock",
        "tests.asyncmock.AsyncMock"
      ],
      "fixtures": [],
      "assertions": [
        "assert receiver.request.body == b'..'",
        "assert receiver.request.body == b'....'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "generate_http_receiver",
          "body": "def generate_http_receiver(app, http_request) -> HTTPReceiver:\n    protocol = generate_protocol(app)\n    receiver = HTTPReceiver(protocol.transmit, protocol, http_request)\n    http_request.stream = receiver\n    return receiver"
        }
      ]
    },
    {
      "name": "test_http3_events",
      "module": "test_http_receiver",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/http3/test_http_receiver.py",
      "line_number": 150,
      "end_line_number": 174,
      "source_code": "def test_http3_events(app):\n    protocol = generate_protocol(app)\n    http3 = Http3(protocol, protocol.transmit)\n    http3.http_event_received(\n        HeadersReceived(\n            [\n                (b\":method\", b\"GET\"),\n                (b\":path\", b\"/location\"),\n                (b\":scheme\", b\"https\"),\n                (b\":authority\", b\"localhost:8443\"),\n                (b\"foo\", b\"bar\"),\n            ],\n            1,\n            False,\n        )\n    )\n    http3.http_event_received(DataReceived(b\"foobar\", 1, False))\n    receiver = http3.receivers[1]\n\n    assert len(http3.receivers) == 1\n    assert receiver.request.stream_id == 1\n    assert receiver.request.path == \"/location\"\n    assert receiver.request.method == \"GET\"\n    assert receiver.request.headers[\"foo\"] == \"bar\"\n    assert receiver.request.body == b\"foobar\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "aioquic.h3.connection.H3Connection",
        "aioquic.h3.events.DataReceived",
        "aioquic.h3.events.HeadersReceived",
        "aioquic.quic.configuration.QuicConfiguration",
        "aioquic.quic.connection.QuicConnection",
        "aioquic.quic.events.ProtocolNegotiated",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.constants.Stage",
        "sanic.http.http3.Http3",
        "sanic.http.http3.HTTPReceiver",
        "sanic.models.server_types.ConnInfo",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.server.protocols.http_protocol.Http3Protocol",
        "unittest.mock.AsyncMock",
        "tests.asyncmock.AsyncMock"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(http3.receivers) == 1",
        "assert receiver.request.stream_id == 1",
        "assert receiver.request.path == '/location'",
        "assert receiver.request.method == 'GET'",
        "assert receiver.request.headers['foo'] == 'bar'",
        "assert receiver.request.body == b'foobar'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "generate_protocol",
          "body": "def generate_protocol(app):\n    connection = QuicConnection(configuration=QuicConfiguration())\n    connection._ack_delay = 0\n    connection._loss = Mock()\n    connection._loss.spaces = []\n    connection._loss.get_loss_detection_time = lambda : None\n    connection.datagrams_to_send = Mock(return_value=[])\n    return Http3Protocol(connection, app=app, stream_handler=None)"
        }
      ]
    },
    {
      "name": "test_multiple_streams",
      "module": "test_http_receiver",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/http3/test_http_receiver.py",
      "line_number": 216,
      "end_line_number": 251,
      "source_code": "def test_multiple_streams(app):\n    protocol = generate_protocol(app)\n    http3 = Http3(protocol, protocol.transmit)\n    http3.http_event_received(\n        HeadersReceived(\n            [\n                (b\":method\", b\"GET\"),\n                (b\":path\", b\"/location\"),\n                (b\":scheme\", b\"https\"),\n                (b\":authority\", b\"localhost:8443\"),\n                (b\"foo\", b\"bar\"),\n            ],\n            1,\n            False,\n        )\n    )\n    http3.http_event_received(\n        HeadersReceived(\n            [\n                (b\":method\", b\"GET\"),\n                (b\":path\", b\"/location\"),\n                (b\":scheme\", b\"https\"),\n                (b\":authority\", b\"localhost:8443\"),\n                (b\"foo\", b\"bar\"),\n            ],\n            2,\n            False,\n        )\n    )\n\n    receiver1 = http3.get_receiver_by_stream_id(1)\n    receiver2 = http3.get_receiver_by_stream_id(2)\n    assert len(http3.receivers) == 2\n    assert isinstance(receiver1, HTTPReceiver)\n    assert isinstance(receiver2, HTTPReceiver)\n    assert receiver1 is not receiver2",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "aioquic.h3.connection.H3Connection",
        "aioquic.h3.events.DataReceived",
        "aioquic.h3.events.HeadersReceived",
        "aioquic.quic.configuration.QuicConfiguration",
        "aioquic.quic.connection.QuicConnection",
        "aioquic.quic.events.ProtocolNegotiated",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.constants.Stage",
        "sanic.http.http3.Http3",
        "sanic.http.http3.HTTPReceiver",
        "sanic.models.server_types.ConnInfo",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.server.protocols.http_protocol.Http3Protocol",
        "unittest.mock.AsyncMock",
        "tests.asyncmock.AsyncMock"
      ],
      "fixtures": [],
      "assertions": [
        "assert len(http3.receivers) == 2",
        "assert isinstance(receiver1, HTTPReceiver)",
        "assert isinstance(receiver2, HTTPReceiver)",
        "assert receiver1 is not receiver2"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "generate_protocol",
          "body": "def generate_protocol(app):\n    connection = QuicConnection(configuration=QuicConfiguration())\n    connection._ack_delay = 0\n    connection._loss = Mock()\n    connection._loss.spaces = []\n    connection._loss.get_loss_detection_time = lambda : None\n    connection.datagrams_to_send = Mock(return_value=[])\n    return Http3Protocol(connection, app=app, stream_handler=None)"
        }
      ]
    },
    {
      "name": "test_request_stream_id",
      "module": "test_http_receiver",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/http3/test_http_receiver.py",
      "line_number": 254,
      "end_line_number": 273,
      "source_code": "def test_request_stream_id(app):\n    protocol = generate_protocol(app)\n    http3 = Http3(protocol, protocol.transmit)\n    http3.http_event_received(\n        HeadersReceived(\n            [\n                (b\":method\", b\"GET\"),\n                (b\":path\", b\"/location\"),\n                (b\":scheme\", b\"https\"),\n                (b\":authority\", b\"localhost:8443\"),\n                (b\"foo\", b\"bar\"),\n            ],\n            1,\n            False,\n        )\n    )\n    receiver = http3.get_receiver_by_stream_id(1)\n\n    assert isinstance(receiver.request, Request)\n    assert receiver.request.stream_id == 1",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "aioquic.h3.connection.H3Connection",
        "aioquic.h3.events.DataReceived",
        "aioquic.h3.events.HeadersReceived",
        "aioquic.quic.configuration.QuicConfiguration",
        "aioquic.quic.connection.QuicConnection",
        "aioquic.quic.events.ProtocolNegotiated",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.constants.Stage",
        "sanic.http.http3.Http3",
        "sanic.http.http3.HTTPReceiver",
        "sanic.models.server_types.ConnInfo",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.server.protocols.http_protocol.Http3Protocol",
        "unittest.mock.AsyncMock",
        "tests.asyncmock.AsyncMock"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(receiver.request, Request)",
        "assert receiver.request.stream_id == 1"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "generate_protocol",
          "body": "def generate_protocol(app):\n    connection = QuicConnection(configuration=QuicConfiguration())\n    connection._ack_delay = 0\n    connection._loss = Mock()\n    connection._loss.spaces = []\n    connection._loss.get_loss_detection_time = lambda : None\n    connection.datagrams_to_send = Mock(return_value=[])\n    return Http3Protocol(connection, app=app, stream_handler=None)"
        }
      ]
    },
    {
      "name": "test_request_conn_info",
      "module": "test_http_receiver",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/http3/test_http_receiver.py",
      "line_number": 276,
      "end_line_number": 294,
      "source_code": "def test_request_conn_info(app):\n    protocol = generate_protocol(app)\n    http3 = Http3(protocol, protocol.transmit)\n    http3.http_event_received(\n        HeadersReceived(\n            [\n                (b\":method\", b\"GET\"),\n                (b\":path\", b\"/location\"),\n                (b\":scheme\", b\"https\"),\n                (b\":authority\", b\"localhost:8443\"),\n                (b\"foo\", b\"bar\"),\n            ],\n            1,\n            False,\n        )\n    )\n    receiver = http3.get_receiver_by_stream_id(1)\n\n    assert isinstance(receiver.request.conn_info, ConnInfo)",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "aioquic.h3.connection.H3Connection",
        "aioquic.h3.events.DataReceived",
        "aioquic.h3.events.HeadersReceived",
        "aioquic.quic.configuration.QuicConfiguration",
        "aioquic.quic.connection.QuicConnection",
        "aioquic.quic.events.ProtocolNegotiated",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.constants.Stage",
        "sanic.http.http3.Http3",
        "sanic.http.http3.HTTPReceiver",
        "sanic.models.server_types.ConnInfo",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.server.protocols.http_protocol.Http3Protocol",
        "unittest.mock.AsyncMock",
        "tests.asyncmock.AsyncMock"
      ],
      "fixtures": [],
      "assertions": [
        "assert isinstance(receiver.request.conn_info, ConnInfo)"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "generate_protocol",
          "body": "def generate_protocol(app):\n    connection = QuicConnection(configuration=QuicConfiguration())\n    connection._ack_delay = 0\n    connection._loss = Mock()\n    connection._loss.spaces = []\n    connection._loss.get_loss_detection_time = lambda : None\n    connection.datagrams_to_send = Mock(return_value=[])\n    return Http3Protocol(connection, app=app, stream_handler=None)"
        }
      ]
    },
    {
      "name": "test_request_header_encoding",
      "module": "test_http_receiver",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/http3/test_http_receiver.py",
      "line_number": 297,
      "end_line_number": 318,
      "source_code": "def test_request_header_encoding(app):\n    protocol = generate_protocol(app)\n    http3 = Http3(protocol, protocol.transmit)\n    with pytest.raises(BadRequest) as exc_info:\n        http3.http_event_received(\n            HeadersReceived(\n                [\n                    (b\":method\", b\"GET\"),\n                    (b\":path\", b\"/location\"),\n                    (b\":scheme\", b\"https\"),\n                    (b\":authority\", b\"localhost:8443\"),\n                    (\"foo\\u00a0\".encode(), b\"bar\"),\n                ],\n                1,\n                False,\n            )\n        )\n    assert exc_info.value.status_code == 400\n    assert (\n        str(exc_info.value)\n        == \"Header names may only contain US-ASCII characters.\"\n    )",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "aioquic.h3.connection.H3Connection",
        "aioquic.h3.events.DataReceived",
        "aioquic.h3.events.HeadersReceived",
        "aioquic.quic.configuration.QuicConfiguration",
        "aioquic.quic.connection.QuicConnection",
        "aioquic.quic.events.ProtocolNegotiated",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.constants.Stage",
        "sanic.http.http3.Http3",
        "sanic.http.http3.HTTPReceiver",
        "sanic.models.server_types.ConnInfo",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.server.protocols.http_protocol.Http3Protocol",
        "unittest.mock.AsyncMock",
        "tests.asyncmock.AsyncMock"
      ],
      "fixtures": [],
      "assertions": [
        "assert exc_info.value.status_code == 400",
        "assert str(exc_info.value) == 'Header names may only contain US-ASCII characters.'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "generate_protocol",
          "body": "def generate_protocol(app):\n    connection = QuicConnection(configuration=QuicConfiguration())\n    connection._ack_delay = 0\n    connection._loss = Mock()\n    connection._loss.spaces = []\n    connection._loss.get_loss_detection_time = lambda : None\n    connection.datagrams_to_send = Mock(return_value=[])\n    return Http3Protocol(connection, app=app, stream_handler=None)"
        }
      ]
    },
    {
      "name": "test_request_url_encoding",
      "module": "test_http_receiver",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/http3/test_http_receiver.py",
      "line_number": 321,
      "end_line_number": 339,
      "source_code": "def test_request_url_encoding(app):\n    protocol = generate_protocol(app)\n    http3 = Http3(protocol, protocol.transmit)\n    with pytest.raises(BadRequest) as exc_info:\n        http3.http_event_received(\n            HeadersReceived(\n                [\n                    (b\":method\", b\"GET\"),\n                    (b\":path\", b\"/location\\xa0\"),\n                    (b\":scheme\", b\"https\"),\n                    (b\":authority\", b\"localhost:8443\"),\n                    (b\"foo\", b\"bar\"),\n                ],\n                1,\n                False,\n            )\n        )\n    assert exc_info.value.status_code == 400\n    assert str(exc_info.value) == \"URL may only contain US-ASCII characters.\"",
      "docstring": null,
      "decorators": [],
      "arguments": [
        "app"
      ],
      "imports": [
        "unittest.mock.Mock",
        "pytest",
        "aioquic.h3.connection.H3Connection",
        "aioquic.h3.events.DataReceived",
        "aioquic.h3.events.HeadersReceived",
        "aioquic.quic.configuration.QuicConfiguration",
        "aioquic.quic.connection.QuicConnection",
        "aioquic.quic.events.ProtocolNegotiated",
        "sanic.Request",
        "sanic.Sanic",
        "sanic.compat.Header",
        "sanic.config.DEFAULT_CONFIG",
        "sanic.exceptions.BadRequest",
        "sanic.exceptions.PayloadTooLarge",
        "sanic.http.constants.Stage",
        "sanic.http.http3.Http3",
        "sanic.http.http3.HTTPReceiver",
        "sanic.models.server_types.ConnInfo",
        "sanic.response.empty",
        "sanic.response.json",
        "sanic.server.protocols.http_protocol.Http3Protocol",
        "unittest.mock.AsyncMock",
        "tests.asyncmock.AsyncMock"
      ],
      "fixtures": [],
      "assertions": [
        "assert exc_info.value.status_code == 400",
        "assert str(exc_info.value) == 'URL may only contain US-ASCII characters.'"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "generate_protocol",
          "body": "def generate_protocol(app):\n    connection = QuicConnection(configuration=QuicConfiguration())\n    connection._ack_delay = 0\n    connection._loss = Mock()\n    connection._loss.spaces = []\n    connection._loss.get_loss_detection_time = lambda : None\n    connection.datagrams_to_send = Mock(return_value=[])\n    return Http3Protocol(connection, app=app, stream_handler=None)"
        }
      ]
    },
    {
      "name": "test_server_starts_http3",
      "module": "test_server",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/http3/test_server.py",
      "line_number": 23,
      "end_line_number": 46,
      "source_code": "def test_server_starts_http3(app: Sanic, version, caplog):\n    ev = Event()\n\n    @app.after_server_start\n    def shutdown(*_):\n        ev.set()\n        app.stop()\n\n    with caplog.at_level(logging.INFO):\n        app.run(\n            version=version,\n            ssl={\n                \"cert\": localhost_dir / \"fullchain.pem\",\n                \"key\": localhost_dir / \"privkey.pem\",\n            },\n            single_process=True,\n        )\n\n    assert ev.is_set()\n    assert (\n        \"sanic.root\",\n        logging.INFO,\n        \"server: sanic, HTTP/3\",\n    ) in caplog.record_tuples",
      "docstring": null,
      "decorators": [
        "pytest.mark.parametrize('version', (3, HTTP.VERSION_3))",
        "pytest.mark.skipif(sys.version_info < (3, 8) and (not UVLOOP_INSTALLED), reason='In 3.7 w/o uvloop the port is not always released')"
      ],
      "arguments": [
        "app",
        "version",
        "caplog"
      ],
      "imports": [
        "logging",
        "sys",
        "asyncio.Event",
        "pathlib.Path",
        "pytest",
        "sanic.Sanic",
        "sanic.compat.UVLOOP_INSTALLED",
        "sanic.http.constants.HTTP"
      ],
      "fixtures": [],
      "assertions": [
        "assert ev.is_set()",
        "assert ('sanic.root', logging.INFO, 'server: sanic, HTTP/3') in caplog.record_tuples"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        },
        {
          "name": "app.run",
          "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)"
        }
      ]
    },
    {
      "name": "test_server_starts_http1_and_http3",
      "module": "test_server",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/http3/test_server.py",
      "line_number": 53,
      "end_line_number": 84,
      "source_code": "def test_server_starts_http1_and_http3(app: Sanic, caplog):\n    @app.after_server_start\n    def shutdown(*_):\n        app.stop()\n\n    app.prepare(\n        version=3,\n        ssl={\n            \"cert\": localhost_dir / \"fullchain.pem\",\n            \"key\": localhost_dir / \"privkey.pem\",\n        },\n    )\n    app.prepare(\n        version=1,\n        ssl={\n            \"cert\": localhost_dir / \"fullchain.pem\",\n            \"key\": localhost_dir / \"privkey.pem\",\n        },\n    )\n    with caplog.at_level(logging.INFO):\n        Sanic.serve_single()\n\n    assert (\n        \"sanic.root\",\n        logging.INFO,\n        \"server: sanic, HTTP/1.1\",\n    ) in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.INFO,\n        \"server: sanic, HTTP/3\",\n    ) in caplog.record_tuples",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(sys.version_info < (3, 8) and (not UVLOOP_INSTALLED), reason='In 3.7 w/o uvloop the port is not always released')"
      ],
      "arguments": [
        "app",
        "caplog"
      ],
      "imports": [
        "logging",
        "sys",
        "asyncio.Event",
        "pathlib.Path",
        "pytest",
        "sanic.Sanic",
        "sanic.compat.UVLOOP_INSTALLED",
        "sanic.http.constants.HTTP"
      ],
      "fixtures": [],
      "assertions": [
        "assert ('sanic.root', logging.INFO, 'server: sanic, HTTP/1.1') in caplog.record_tuples",
        "assert ('sanic.root', logging.INFO, 'server: sanic, HTTP/3') in caplog.record_tuples"
      ],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        }
      ]
    },
    {
      "name": "test_server_starts_http1_and_http3_bad_order",
      "module": "test_server",
      "class_name": null,
      "file_path": "__internal__/data/sanic/tests/http3/test_server.py",
      "line_number": 91,
      "end_line_number": 115,
      "source_code": "def test_server_starts_http1_and_http3_bad_order(app: Sanic, caplog):\n    @app.after_server_start\n    def shutdown(*_):\n        app.stop()\n\n    app.prepare(\n        version=1,\n        ssl={\n            \"cert\": localhost_dir / \"fullchain.pem\",\n            \"key\": localhost_dir / \"privkey.pem\",\n        },\n    )\n    message = (\n        \"Serving HTTP/3 instances as a secondary server is not supported. \"\n        \"There can only be a single HTTP/3 worker and it must be the first \"\n        \"instance prepared.\"\n    )\n    with pytest.raises(RuntimeError, match=message):\n        app.prepare(\n            version=3,\n            ssl={\n                \"cert\": localhost_dir / \"fullchain.pem\",\n                \"key\": localhost_dir / \"privkey.pem\",\n            },\n        )",
      "docstring": null,
      "decorators": [
        "pytest.mark.skipif(sys.version_info < (3, 8) and (not UVLOOP_INSTALLED), reason='In 3.7 w/o uvloop the port is not always released')"
      ],
      "arguments": [
        "app",
        "caplog"
      ],
      "imports": [
        "logging",
        "sys",
        "asyncio.Event",
        "pathlib.Path",
        "pytest",
        "sanic.Sanic",
        "sanic.compat.UVLOOP_INSTALLED",
        "sanic.http.constants.HTTP"
      ],
      "fixtures": [],
      "assertions": [],
      "setup_method": null,
      "teardown_method": null,
      "mocks": [],
      "methods_under_test": [
        {
          "name": "app.stop",
          "body": "def stop(app):\n    app.stop()"
        }
      ]
    }
  ]
}